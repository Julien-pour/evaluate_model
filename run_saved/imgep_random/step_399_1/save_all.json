[{"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of distinct pairs (i, j) where i < j and nums[i] + nums[j] is divisible by 3.\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if (nums[i] + nums[j]) % 3 == 0:\n                count += 1\n    return count\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6]\n    return nums\n\nassert f(g()) == 8\n", "emb": null, "idx_generation": 300, "target_skills": [1, 1, 1, 0, 0, 1, 1, 0, 1, 0], "problem_func": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of distinct pairs (i, j) where i < j and nums[i] + nums[j] is divisible by 3.\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if (nums[i] + nums[j]) % 3 == 0:\n                count += 1\n    return count", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5, 6]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom collections import deque\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the length of the shortest path from the top-left corner to the bottom-right corner.\n    You can only move down or right in the grid.\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    \n    # Initialize the distance grid\n    distance = [[float('inf')] * m for _ in range(n)]\n    distance[0][0] = grid[0][0]\n    \n    # Initialize the queue with the starting position\n    queue = deque([(0, 0)])\n    \n    # BFS to find the shortest path\n    while queue:\n        x, y = queue.popleft()\n        \n        # Check right neighbor\n        if x + 1 < n:\n            new_distance = distance[x][y] + grid[x+1][y]\n            if new_distance < distance[x+1][y]:\n                distance[x+1][y] = new_distance\n                queue.append((x+1, y))\n        \n        # Check down neighbor\n        if y + 1 < m:\n            new_distance = distance[x][y] + grid[x][y+1]\n            if new_distance < distance[x][y+1]:\n                distance[x][y+1] = new_distance\n                queue.append((x, y+1))\n    \n    return distance[n-1][m-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 300, "target_skills": [0, 1, 1, 1, 0, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom collections import deque\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the length of the shortest path from the top-left corner to the bottom-right corner.\n    You can only move down or right in the grid.\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    \n    # Initialize the distance grid\n    distance = [[float('inf')] * m for _ in range(n)]\n    distance[0][0] = grid[0][0]\n    \n    # Initialize the queue with the starting position\n    queue = deque([(0, 0)])\n    \n    # BFS to find the shortest path\n    while queue:\n        x, y = queue.popleft()\n        \n        # Check right neighbor\n        if x + 1 < n:\n            new_distance = distance[x][y] + grid[x+1][y]\n            if new_distance < distance[x+1][y]:\n                distance[x+1][y] = new_distance\n                queue.append((x+1, y))\n        \n        # Check down neighbor\n        if y + 1 < m:\n            new_distance = distance[x][y] + grid[x][y+1]\n            if new_distance < distance[x][y+1]:\n                distance[x][y+1] = new_distance\n                queue.append((x, y+1))\n    \n    return distance[n-1][m-1]", "solution_func": "def g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters where 'X' represents walls and '.' represents empty spaces,\n    count the number of connected regions in the grid.\n    Two empty spaces are considered connected if they are adjacent horizontally or vertically.\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    \n    visited = [[False] * m for _ in range(n)]\n    \n    count = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.' and not visited[i][j]:\n                dfs(grid, visited, i, j)\n                count += 1\n    \n    return count\n\ndef dfs(grid, visited, x, y):\n    n = len(grid)\n    m = len(grid[0])\n    \n    if x < 0 or x >= n or y < 0 or y >= m:\n        return\n    \n    if grid[x][y] != '.' or visited[x][y]:\n        return\n    \n    visited[x][y] = True\n    \n    dfs(grid, visited, x+1, y)\n    dfs(grid, visited, x-1, y)\n    dfs(grid, visited, x, y+1)\n    dfs(grid, visited, x, y-1)\n\ndef g():\n    grid = [\n        ['X', '.', '.', 'X'],\n        ['.', '.', '.', 'X'],\n        ['X', 'X', '.', 'X']\n    ]\n    return grid\n\nassert f(g()) == 2\n", "emb": null, "idx_generation": 300, "target_skills": [1, 1, 1, 0, 1, 0, 1, 1, 0, 0], "problem_func": "from typing import*\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters where 'X' represents walls and '.' represents empty spaces,\n    count the number of connected regions in the grid.\n    Two empty spaces are considered connected if they are adjacent horizontally or vertically.\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    \n    visited = [[False] * m for _ in range(n)]\n    \n    count = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.' and not visited[i][j]:\n                dfs(grid, visited, i, j)\n                count += 1\n    \n    return count\n\ndef dfs(grid, visited, x, y):\n    n = len(grid)\n    m = len(grid[0])\n    \n    if x < 0 or x >= n or y < 0 or y >= m:\n        return\n    \n    if grid[x][y] != '.' or visited[x][y]:\n        return\n    \n    visited[x][y] = True\n    \n    dfs(grid, visited, x+1, y)\n    dfs(grid, visited, x-1, y)\n    dfs(grid, visited, x, y+1)\n    dfs(grid, visited, x, y-1)", "solution_func": "def g():\n    grid = [\n        ['X', '.', '.', 'X'],\n        ['.', '.', '.', 'X'],\n        ['X', 'X', '.', 'X']\n    ]\n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of possible combinations that sum up to the target value.\n    \n    Example:\n    nums = [1, 2, 3]\n    Output: 4\n    Explanation: The possible combinations are [1, 1, 1], [1, 2], [2, 1], and [3].\n    \"\"\"\n    target = sum(nums)\n    dp = [0] * (target + 1)\n    dp[0] = 1\n    for num in nums:\n        for i in range(num, target + 1):\n            dp[i] += dp[i - num]\n    return dp[target]\n\ndef g(nums=[1, 2, 3]):\n    return [nums]\n\nassert f(*g()) == 4\n", "emb": null, "idx_generation": 300, "target_skills": [0, 1, 0, 1, 0, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of possible combinations that sum up to the target value.\n    \n    Example:\n    nums = [1, 2, 3]\n    Output: 4\n    Explanation: The possible combinations are [1, 1, 1], [1, 2], [2, 1], and [3].\n    \"\"\"\n    target = sum(nums)\n    dp = [0] * (target + 1)\n    dp[0] = 1\n    for num in nums:\n        for i in range(num, target + 1):\n            dp[i] += dp[i - num]\n    return dp[target]", "solution_func": "def g(nums=[1, 2, 3]):\n    return [nums]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 8\n    Explanation: The maximum sum path is 1 -> 3 -> 1 -> 1 -> 1, which gives a total sum of 8.\n    \"\"\"\n    rows, cols = len(grid), len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[rows-1][cols-1]\n\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return [grid]\n\nassert f(*g()) == 8\n", "emb": null, "idx_generation": 300, "target_skills": [1, 1, 1, 0, 0, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 8\n    Explanation: The maximum sum path is 1 -> 3 -> 1 -> 1 -> 1, which gives a total sum of 8.\n    \"\"\"\n    rows, cols = len(grid), len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[rows-1][cols-1]", "solution_func": "def g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return [grid]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix and two nodes, determine if there is a path from the start node to the end node.\n    \n    Example:\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n    Output: True\n    Explanation: There is a path from node 0 to node 3: 0 -> 1 -> 2 -> 3.\n    \"\"\"\n    visited = [False] * len(graph)\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if not visited[node]:\n            visited[node] = True\n            neighbors = graph[node]\n            for i in range(len(neighbors)):\n                if neighbors[i] == 1:\n                    stack.append(i)\n    return False\n\ndef g(graph=[[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [0, 0, 0, 0]], start=0, end=3):\n    return [graph, start, end]\n\nassert f(*g())\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 300, "target_skills": [1, 1, 0, 0, 0, 0, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix and two nodes, determine if there is a path from the start node to the end node.\n    \n    Example:\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n    Output: True\n    Explanation: There is a path from node 0 to node 3: 0 -> 1 -> 2 -> 3.\n    \"\"\"\n    visited = [False] * len(graph)\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if not visited[node]:\n            visited[node] = True\n            neighbors = graph[node]\n            for i in range(len(neighbors)):\n                if neighbors[i] == 1:\n                    stack.append(i)\n    return False", "solution_func": "def g(graph=[[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [0, 0, 0, 0]], start=0, end=3):\n    return [graph, start, end]", "map_ix": [0, 0, 1, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array of integers 'nums' and a target integer 'target', find all unique combinations in 'nums' where the sum of the elements is equal to 'target'. Each number in 'nums' may only be used once in each combination. The combinations should be returned as a list of lists.\n    \"\"\"\n    def backtrack(nums: List[int], target: int, start: int, path: List[int], res: List[List[int]]):\n        if target < 0:\n            return\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            backtrack(nums, target-nums[i], i+1, path+[nums[i]], res)\n    \n    nums.sort()\n    res = []\n    backtrack(nums, target, 0, [], res)\n    return res\n\ndef g() -> Tuple[List[int], int]:\n    return ([10,1,2,7,6,1,5], 8)\n\nassert f(*g()) == [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 300, "target_skills": [1, 1, 1, 0, 1, 1, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array of integers 'nums' and a target integer 'target', find all unique combinations in 'nums' where the sum of the elements is equal to 'target'. Each number in 'nums' may only be used once in each combination. The combinations should be returned as a list of lists.\n    \"\"\"\n    def backtrack(nums: List[int], target: int, start: int, path: List[int], res: List[List[int]]):\n        if target < 0:\n            return\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            backtrack(nums, target-nums[i], i+1, path+[nums[i]], res)\n    \n    nums.sort()\n    res = []\n    backtrack(nums, target, 0, [], res)\n    return res", "solution_func": "def g() -> Tuple[List[int], int]:\n    return ([10,1,2,7,6,1,5], 8)", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given an m x n matrix filled with non-negative integers, find the number of unique paths from the top-left corner to the bottom-right corner. Each movement can only go either down or right.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n    \n    for i in range(m):\n        for j in range(n):\n            if i == 0 or j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    return [[1, 1, 1], [1, 2, 1], [1, 1, 1]]\n\nassert f(g()) == 6\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 300, "target_skills": [1, 1, 1, 0, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given an m x n matrix filled with non-negative integers, find the number of unique paths from the top-left corner to the bottom-right corner. Each movement can only go either down or right.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n    \n    for i in range(m):\n        for j in range(n):\n            if i == 0 or j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[m-1][n-1]", "solution_func": "def g() -> List[List[int]]:\n    return [[1, 1, 1], [1, 2, 1], [1, 1, 1]]", "map_ix": [1, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum from top-left to bottom-right, moving only right or down.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    \n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 12\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 300, "target_skills": [0, 0, 1, 1, 0, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum from top-left to bottom-right, moving only right or down.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    \n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]", "solution_func": "def g() -> List[List[int]]:\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two positive integers n and k, compute the number of combinations (n choose k).\n\n    \"\"\"\n    def factorial(n: int) -> int:\n        if n == 0 or n == 1:\n            return 1\n        return n * factorial(n-1)\n\n    return factorial(n) // (factorial(k) * factorial(n-k))\n\ndef g():\n    return 5, 2\n\nassert f(*g()) == 10\n", "emb": [0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 300, "target_skills": [0, 1, 1, 1, 1, 1, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two positive integers n and k, compute the number of combinations (n choose k).\n\n    \"\"\"\n    def factorial(n: int) -> int:\n        if n == 0 or n == 1:\n            return 1\n        return n * factorial(n-1)\n\n    return factorial(n) // (factorial(k) * factorial(n-k))", "solution_func": "def g():\n    return 5, 2", "map_ix": [0, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, calculate the determinant of the matrix.\n\n    Args:\n    - matrix: A square matrix represented as a list of lists.\n\n    Returns:\n    - The determinant of the matrix.\n    \"\"\"\n    def determinant(matrix):\n        n = len(matrix)\n        if n == 1:\n            return matrix[0][0]\n\n        det = 0\n        for col in range(n):\n            sub_matrix = [row[:col] + row[col+1:] for row in matrix[1:]]\n            det += (-1) ** col * matrix[0][col] * determinant(sub_matrix)\n        return det\n\n    return determinant(matrix)\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a square matrix.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 0\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 301, "target_skills": [0, 0, 1, 1, 0, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, calculate the determinant of the matrix.\n\n    Args:\n    - matrix: A square matrix represented as a list of lists.\n\n    Returns:\n    - The determinant of the matrix.\n    \"\"\"\n    def determinant(matrix):\n        n = len(matrix)\n        if n == 1:\n            return matrix[0][0]\n\n        det = 0\n        for col in range(n):\n            sub_matrix = [row[:col] + row[col+1:] for row in matrix[1:]]\n            det += (-1) ** col * matrix[0][col] * determinant(sub_matrix)\n        return det\n\n    return determinant(matrix)", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a square matrix.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(string: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of words in the string.\n\n    Args:\n    - string: The input string.\n\n    Returns:\n    - The string with the order of words reversed.\n    \"\"\"\n    words = string.split()\n    return \" \".join(words[::-1])\n\ndef g() -> str:\n    \"\"\"\n    Generate a string with multiple words.\n    \"\"\"\n    return \"hello world\"\n\nassert f(g()) == \"world hello\"\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 301, "target_skills": [0, 1, 0, 1, 0, 0, 1, 0, 0, 1], "problem_func": "from typing import*\ndef f(string: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of words in the string.\n\n    Args:\n    - string: The input string.\n\n    Returns:\n    - The string with the order of words reversed.\n    \"\"\"\n    words = string.split()\n    return \" \".join(words[::-1])", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate a string with multiple words.\n    \"\"\"\n    return \"hello world\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters representing a crossword puzzle, count the number of words in the grid.\n\n    Args:\n    - grid: A grid of characters represented as a list of lists.\n\n    Returns:\n    - The number of words in the grid.\n    \"\"\"\n    def count_words(grid):\n        count = 0\n        for row in grid:\n            word = False\n            for cell in row:\n                if cell != '#':\n                    if not word:\n                        count += 1\n                        word = True\n                else:\n                    word = False\n        return count\n\n    return count_words(grid)\n\ndef g() -> List[List[str]]:\n    \"\"\"\n    Generate a crossword puzzle grid.\n    \"\"\"\n    return [\n        ['#', '#', '#', '#', '#'],\n        ['#', 'A', 'B', 'C', '#'],\n        ['#', '#', '#', '#', '#'],\n        ['#', 'D', 'E', 'F', '#'],\n        ['#', '#', '#', '#', '#']\n    ]\n\nassert f(g()) == 4\n\n", "emb": null, "idx_generation": 301, "target_skills": [0, 1, 0, 1, 1, 0, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters representing a crossword puzzle, count the number of words in the grid.\n\n    Args:\n    - grid: A grid of characters represented as a list of lists.\n\n    Returns:\n    - The number of words in the grid.\n    \"\"\"\n    def count_words(grid):\n        count = 0\n        for row in grid:\n            word = False\n            for cell in row:\n                if cell != '#':\n                    if not word:\n                        count += 1\n                        word = True\n                else:\n                    word = False\n        return count\n\n    return count_words(grid)", "solution_func": "def g() -> List[List[str]]:\n    \"\"\"\n    Generate a crossword puzzle grid.\n    \"\"\"\n    return [\n        ['#', '#', '#', '#', '#'],\n        ['#', 'A', 'B', 'C', '#'],\n        ['#', '#', '#', '#', '#'],\n        ['#', 'D', 'E', 'F', '#'],\n        ['#', '#', '#', '#', '#']\n    ]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums and an integer n, find the number of subsequences of nums that have a sum greater than or equal to n.\n    A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n\n    Example:\n    n = 10\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    6\n\n    Explanation:\n    The subsequences with a sum greater than or equal to 10 are [10], [4, 6], [3, 7], [5, 5], [1, 2, 7], [1, 3, 6].\n\n    Hint: Use a recursive function to generate all possible subsequences and count the ones with a sum greater than or equal to n.\n    \"\"\"\n\n    def count_subsequences(index: int, current_sum: int) -> int:\n        if index == len(nums):\n            return 1 if current_sum >= n else 0\n\n        count = 0\n        count += count_subsequences(index + 1, current_sum)  # Exclude current number\n        count += count_subsequences(index + 1, current_sum + nums[index])  # Include current number\n\n        return count\n\n    return count_subsequences(0, 0)\n\ndef g(n=10, nums=[1, 2, 3, 4, 5]):\n    return n, nums\n\nassert f(*g()) == 6\n\n", "emb": null, "idx_generation": 301, "target_skills": [1, 1, 0, 0, 1, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums and an integer n, find the number of subsequences of nums that have a sum greater than or equal to n.\n    A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n\n    Example:\n    n = 10\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    6\n\n    Explanation:\n    The subsequences with a sum greater than or equal to 10 are [10], [4, 6], [3, 7], [5, 5], [1, 2, 7], [1, 3, 6].\n\n    Hint: Use a recursive function to generate all possible subsequences and count the ones with a sum greater than or equal to n.\n    \"\"\"\n\n    def count_subsequences(index: int, current_sum: int) -> int:\n        if index == len(nums):\n            return 1 if current_sum >= n else 0\n\n        count = 0\n        count += count_subsequences(index + 1, current_sum)  # Exclude current number\n        count += count_subsequences(index + 1, current_sum + nums[index])  # Include current number\n\n        return count\n\n    return count_subsequences(0, 0)", "solution_func": "def g(n=10, nums=[1, 2, 3, 4, 5]):\n    return n, nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of arithmetic subsequences in nums.\n    An arithmetic subsequence is a sequence of numbers in which the difference between consecutive numbers is the same.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    7\n\n    Explanation:\n    The arithmetic subsequences are [1, 2, 3], [2, 3, 4], [3, 4, 5], [1, 3, 5], [1, 2, 4], [2, 4, 6], [1, 4, 7].\n\n    Hint: Use dynamic programming to build a table of counts for each number in the list, and then calculate the total count based on the table.\n    \"\"\"\n\n    count = 0\n    dp = [{} for _ in range(len(nums))]\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            diff = nums[i] - nums[j]\n            dp[i][diff] = dp[i].get(diff, 0) + dp[j].get(diff, 0) + 1\n            count += dp[j].get(diff, 0)\n\n    return count\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    return nums\n\nassert f(*g()) == 7\n\n", "emb": null, "idx_generation": 301, "target_skills": [0, 0, 1, 1, 0, 0, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of arithmetic subsequences in nums.\n    An arithmetic subsequence is a sequence of numbers in which the difference between consecutive numbers is the same.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    7\n\n    Explanation:\n    The arithmetic subsequences are [1, 2, 3], [2, 3, 4], [3, 4, 5], [1, 3, 5], [1, 2, 4], [2, 4, 6], [1, 4, 7].\n\n    Hint: Use dynamic programming to build a table of counts for each number in the list, and then calculate the total count based on the table.\n    \"\"\"\n\n    count = 0\n    dp = [{} for _ in range(len(nums))]\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            diff = nums[i] - nums[j]\n            dp[i][diff] = dp[i].get(diff, 0) + dp[j].get(diff, 0) + 1\n            count += dp[j].get(diff, 0)\n\n    return count", "solution_func": "def g(nums=[1, 2, 3, 4, 5]):\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a subgrid of size n x m.\n    A subgrid is a contiguous rectangular area within the grid.\n\n    Example:\n    n = 2\n    m = 2\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    20\n\n    Explanation:\n    The maximum sum subgrid is [[5, 6], [8, 9]], with a sum of 20.\n\n    Hint: Use dynamic programming to calculate the sum of each subgrid and keep track of the maximum sum.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Calculating the prefix sum for each row\n    prefix_sum = [[0] * (cols + 1) for _ in range(rows)]\n    for i in range(rows):\n        for j in range(1, cols + 1):\n            prefix_sum[i][j] = prefix_sum[i][j - 1] + grid[i][j - 1]\n\n    max_sum = float('-inf')\n\n    for i in range(n, rows + 1):\n        for j in range(m, cols + 1):\n            # Calculating the sum of the subgrid using the prefix sum\n            subgrid_sum = 0\n            for k in range(i - n, i):\n                subgrid_sum += prefix_sum[k][j] - prefix_sum[k][j - m]\n\n            max_sum = max(max_sum, subgrid_sum)\n\n    return max_sum\n\ndef g(n=2, m=2, grid=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return n, m, grid\n\nassert f(*g()) == 20\n\n", "emb": null, "idx_generation": 301, "target_skills": [1, 1, 0, 0, 0, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a subgrid of size n x m.\n    A subgrid is a contiguous rectangular area within the grid.\n\n    Example:\n    n = 2\n    m = 2\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    20\n\n    Explanation:\n    The maximum sum subgrid is [[5, 6], [8, 9]], with a sum of 20.\n\n    Hint: Use dynamic programming to calculate the sum of each subgrid and keep track of the maximum sum.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Calculating the prefix sum for each row\n    prefix_sum = [[0] * (cols + 1) for _ in range(rows)]\n    for i in range(rows):\n        for j in range(1, cols + 1):\n            prefix_sum[i][j] = prefix_sum[i][j - 1] + grid[i][j - 1]\n\n    max_sum = float('-inf')\n\n    for i in range(n, rows + 1):\n        for j in range(m, cols + 1):\n            # Calculating the sum of the subgrid using the prefix sum\n            subgrid_sum = 0\n            for k in range(i - n, i):\n                subgrid_sum += prefix_sum[k][j] - prefix_sum[k][j - m]\n\n            max_sum = max(max_sum, subgrid_sum)\n\n    return max_sum", "solution_func": "def g(n=2, m=2, grid=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return n, m, grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of trailing zeros in n factorial.\n\n    Example:\n    n = 5\n\n    Output:\n    1\n\n    Explanation:\n    5 factorial is 120, which has 1 trailing zero.\n\n    Hint: The number of trailing zeros in n factorial is equal to the number of times n is divisible by 5.\n    \"\"\"\n\n    count = 0\n\n    while n >= 5:\n        n //= 5\n        count += n\n\n    return count\n\ndef g() -> int:\n    n = 10\n    return n\n\nassert f(g()) == 2\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 301, "target_skills": [1, 0, 1, 1, 0, 1, 0, 1, 1, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of trailing zeros in n factorial.\n\n    Example:\n    n = 5\n\n    Output:\n    1\n\n    Explanation:\n    5 factorial is 120, which has 1 trailing zero.\n\n    Hint: The number of trailing zeros in n factorial is equal to the number of times n is divisible by 5.\n    \"\"\"\n\n    count = 0\n\n    while n >= 5:\n        n //= 5\n        count += n\n\n    return count", "solution_func": "def g() -> int:\n    n = 10\n    return n", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the sum of all positive integers less than or equal to n that are divisible by either 3 or 5.\n\n    Example:\n    n = 10\n\n    Output:\n    33\n\n    Explanation:\n    The positive integers less than or equal to 10 that are divisible by either 3 or 5 are: 3, 5, 6, 9. Their sum is 33.\n\n    Hint: Use the principle of inclusion-exclusion to count the numbers divisible by either 3 or 5.\n    \"\"\"\n\n    def sum_divisible_by(k: int, n: int) -> int:\n        \"\"\"\n        Helper function to calculate the sum of all positive integers less than or equal to n that are divisible by k.\n        \"\"\"\n        m = (n - 1) // k\n        return k * (m * (m + 1)) // 2\n\n    return sum_divisible_by(3, n) + sum_divisible_by(5, n) - sum_divisible_by(15, n)\n\n\ndef g() -> int:\n    n = 20\n    return n\n\nassert f(g()) == 98\n", "emb": null, "idx_generation": 301, "target_skills": [1, 0, 0, 1, 1, 0, 0, 1, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the sum of all positive integers less than or equal to n that are divisible by either 3 or 5.\n\n    Example:\n    n = 10\n\n    Output:\n    33\n\n    Explanation:\n    The positive integers less than or equal to 10 that are divisible by either 3 or 5 are: 3, 5, 6, 9. Their sum is 33.\n\n    Hint: Use the principle of inclusion-exclusion to count the numbers divisible by either 3 or 5.\n    \"\"\"\n\n    def sum_divisible_by(k: int, n: int) -> int:\n        \"\"\"\n        Helper function to calculate the sum of all positive integers less than or equal to n that are divisible by k.\n        \"\"\"\n        m = (n - 1) // k\n        return k * (m * (m + 1)) // 2\n\n    return sum_divisible_by(3, n) + sum_divisible_by(5, n) - sum_divisible_by(15, n)", "solution_func": "def g() -> int:\n    n = 20\n    return n", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the next power of 2 that is greater than or equal to n.\n\n    Example:\n    n = 7\n\n    Output:\n    8\n\n    Explanation:\n    The next power of 2 that is greater than or equal to 7 is 8.\n\n    Hint: Use bitwise operations to find the next power of 2.\n    \"\"\"\n\n    power = 1\n\n    while power < n:\n        power <<= 1\n\n    return power\n\n\ndef g() -> int:\n    n = 10\n    return n\n\nassert f(g()) == 16\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 301, "target_skills": [0, 0, 0, 0, 1, 0, 1, 1, 0, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the next power of 2 that is greater than or equal to n.\n\n    Example:\n    n = 7\n\n    Output:\n    8\n\n    Explanation:\n    The next power of 2 that is greater than or equal to 7 is 8.\n\n    Hint: Use bitwise operations to find the next power of 2.\n    \"\"\"\n\n    power = 1\n\n    while power < n:\n        power <<= 1\n\n    return power", "solution_func": "def g() -> int:\n    n = 10\n    return n", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, count the number of pairs (i, j) where i < j and nums[i] < nums[j].\n\n    Return the count of such pairs.\n\n    Example:\n    nums = [4, 2, 7, 1, 5]\n\n    Output:\n    4\n\n    Explanation:\n    The pairs (0, 1), (0, 2), (0, 4), and (3, 4) satisfy the condition nums[i] < nums[j].\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] < nums[j]:\n                count += 1\n    return count\n\ndef g() -> List[int]:\n    nums = [4, 2, 7, 1, 5]\n    return [nums]\n\nassert f(*g()) == 4\n\n", "emb": null, "idx_generation": 301, "target_skills": [1, 1, 0, 0, 0, 0, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, count the number of pairs (i, j) where i < j and nums[i] < nums[j].\n\n    Return the count of such pairs.\n\n    Example:\n    nums = [4, 2, 7, 1, 5]\n\n    Output:\n    4\n\n    Explanation:\n    The pairs (0, 1), (0, 2), (0, 4), and (3, 4) satisfy the condition nums[i] < nums[j].\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] < nums[j]:\n                count += 1\n    return count", "solution_func": "def g() -> List[int]:\n    nums = [4, 2, 7, 1, 5]\n    return [nums]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of n x m integers, find the number of unique paths from the top-left corner to the bottom-right corner.\n    You can only move down or right at any point in time.\n\n    Example:\n    matrix = [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1]\n    ]\n    output: 6\n    Explanation: There are 6 unique paths to reach the bottom-right corner:\n    1. Right -> Right -> Right -> Down -> Down -> Down\n    2. Right -> Right -> Down -> Right -> Down -> Down\n    3. Right -> Down -> Right -> Right -> Down -> Down\n    4. Down -> Right -> Right -> Right -> Down -> Down\n    5. Down -> Right -> Right -> Down -> Right -> Down\n    6. Down -> Right -> Down -> Right -> Right -> Down\n    \"\"\"\n\n    if not matrix:\n        return 0\n\n    n = len(matrix)\n    m = len(matrix[0])\n\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = 1\n\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0]\n\n    for j in range(1, m):\n        dp[0][j] = dp[0][j - 1]\n\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[n - 1][m - 1]\n\ndef g(matrix=[[1, 1, 1], [1, 1, 1], [1, 1, 1]]):\n    return matrix\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 302, "target_skills": [0, 1, 1, 0, 0, 0, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of n x m integers, find the number of unique paths from the top-left corner to the bottom-right corner.\n    You can only move down or right at any point in time.\n\n    Example:\n    matrix = [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1]\n    ]\n    output: 6\n    Explanation: There are 6 unique paths to reach the bottom-right corner:\n    1. Right -> Right -> Right -> Down -> Down -> Down\n    2. Right -> Right -> Down -> Right -> Down -> Down\n    3. Right -> Down -> Right -> Right -> Down -> Down\n    4. Down -> Right -> Right -> Right -> Down -> Down\n    5. Down -> Right -> Right -> Down -> Right -> Down\n    6. Down -> Right -> Down -> Right -> Right -> Down\n    \"\"\"\n\n    if not matrix:\n        return 0\n\n    n = len(matrix)\n    m = len(matrix[0])\n\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = 1\n\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0]\n\n    for j in range(1, m):\n        dp[0][j] = dp[0][j - 1]\n\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[n - 1][m - 1]", "solution_func": "def g(matrix=[[1, 1, 1], [1, 1, 1], [1, 1, 1]]):\n    return matrix", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    Given a number of nodes and a list of directed edges between the nodes, determine if there is a cycle in the graph.\n\n    Example:\n    n = 4\n    edges = [[0, 1], [1, 2], [2, 3], [3, 1]]\n    output: True\n    Explanation: There is a cycle in the graph: 1 -> 2 -> 3 -> 1\n    \"\"\"\n\n    graph = [[] for _ in range(n)]\n    visited = [False] * n\n    recursion_stack = [False] * n\n\n    for edge in edges:\n        u, v = edge\n        graph[u].append(v)\n\n    def is_cycle(node):\n        visited[node] = True\n        recursion_stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if is_cycle(neighbor):\n                    return True\n            elif recursion_stack[neighbor]:\n                return True\n\n        recursion_stack[node] = False\n        return False\n\n    for node in range(n):\n        if not visited[node]:\n            if is_cycle(node):\n                return True\n\n    return False\n\ndef g(n=4, edges=[[0, 1], [1, 2], [2, 3], [3, 1]]):\n    return n, edges\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 302, "target_skills": [0, 1, 1, 1, 0, 1, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    Given a number of nodes and a list of directed edges between the nodes, determine if there is a cycle in the graph.\n\n    Example:\n    n = 4\n    edges = [[0, 1], [1, 2], [2, 3], [3, 1]]\n    output: True\n    Explanation: There is a cycle in the graph: 1 -> 2 -> 3 -> 1\n    \"\"\"\n\n    graph = [[] for _ in range(n)]\n    visited = [False] * n\n    recursion_stack = [False] * n\n\n    for edge in edges:\n        u, v = edge\n        graph[u].append(v)\n\n    def is_cycle(node):\n        visited[node] = True\n        recursion_stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if is_cycle(neighbor):\n                    return True\n            elif recursion_stack[neighbor]:\n                return True\n\n        recursion_stack[node] = False\n        return False\n\n    for node in range(n):\n        if not visited[node]:\n            if is_cycle(node):\n                return True\n\n    return False", "solution_func": "def g(n=4, edges=[[0, 1], [1, 2], [2, 3], [3, 1]]):\n    return n, edges", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum along a path from the top-left corner to the bottom-right corner.\n    You can only move down or right at any point in time.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    output: 12\n    Explanation: The maximum sum path is: 1 -> 3 -> 1 -> 1 -> 1\n\n    \"\"\"\n\n    if not grid:\n        return 0\n\n    n = len(grid)\n    m = len(grid[0])\n\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, m):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[n - 1][m - 1]\n\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(g()) == 12\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 302, "target_skills": [1, 1, 1, 1, 1, 0, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum along a path from the top-left corner to the bottom-right corner.\n    You can only move down or right at any point in time.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    output: 12\n    Explanation: The maximum sum path is: 1 -> 3 -> 1 -> 1 -> 1\n\n    \"\"\"\n\n    if not grid:\n        return 0\n\n    n = len(grid)\n    m = len(grid[0])\n\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, m):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[n - 1][m - 1]", "solution_func": "def g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid", "map_ix": [1, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of trailing zeros in n!.\n\n    Example:\n    n = 5\n    5! = 120\n    The number of trailing zeros in 120 is 1.\n\n    Return the number of trailing zeros in n!\n    \"\"\"\n    count = 0\n    power_of_5 = 5\n\n    while power_of_5 <= n:\n        count += n // power_of_5\n        power_of_5 *= 5\n\n    return count\n\ndef g() -> int:\n    return 20\n\nassert f(g()) == 4\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 302, "target_skills": [1, 0, 0, 1, 0, 1, 1, 0, 1, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of trailing zeros in n!.\n\n    Example:\n    n = 5\n    5! = 120\n    The number of trailing zeros in 120 is 1.\n\n    Return the number of trailing zeros in n!\n    \"\"\"\n    count = 0\n    power_of_5 = 5\n\n    while power_of_5 <= n:\n        count += n // power_of_5\n        power_of_5 *= 5\n\n    return count", "solution_func": "def g() -> int:\n    return 20", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> List[str]:\n    \"\"\"\n    Given a string s, return a list of all possible permutations of the characters in the string.\n\n    Example:\n    s = \"abc\"\n    Possible permutations are [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n\n    Return a list of all possible permutations of the characters in the string.\n    \"\"\"\n    def backtrack(curr_str: str, remaining_chars: List[str], result: List[str]):\n        if not remaining_chars:\n            result.append(curr_str)\n            return\n        \n        for i in range(len(remaining_chars)):\n            new_str = curr_str + remaining_chars[i]\n            new_remaining = remaining_chars[:i] + remaining_chars[i+1:]\n            backtrack(new_str, new_remaining, result)\n\n    result = []\n    backtrack(\"\", list(s), result)\n    return result\n\ndef g() -> str:\n    return \"abc\"\n\nassert f(g()) == [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 302, "target_skills": [1, 0, 1, 0, 1, 1, 1, 0, 1, 1], "problem_func": "from typing import*\ndef f(s: str) -> List[str]:\n    \"\"\"\n    Given a string s, return a list of all possible permutations of the characters in the string.\n\n    Example:\n    s = \"abc\"\n    Possible permutations are [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n\n    Return a list of all possible permutations of the characters in the string.\n    \"\"\"\n    def backtrack(curr_str: str, remaining_chars: List[str], result: List[str]):\n        if not remaining_chars:\n            result.append(curr_str)\n            return\n        \n        for i in range(len(remaining_chars)):\n            new_str = curr_str + remaining_chars[i]\n            new_remaining = remaining_chars[:i] + remaining_chars[i+1:]\n            backtrack(new_str, new_remaining, result)\n\n    result = []\n    backtrack(\"\", list(s), result)\n    return result", "solution_func": "def g() -> str:\n    return \"abc\"", "map_ix": [0, 1, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(prices: List[int]) -> int:\n    \"\"\"\n    Given an array prices where prices[i] is the price of a given stock on the ith day, return the maximum profit you can achieve from buying and selling the stock.\n\n    You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\n\n    - You must sell the stock before you buy again.\n    - After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).\n\n    Example:\n    prices = [1, 2, 3, 0, 2]\n    The maximum profit can be achieved by buying at day 1 (price = 1) and selling at day 2 (price = 3), then buying at day 4 (price = 0) and selling at day 5 (price = 2).\n    The maximum profit is 3.\n\n    Return the maximum profit you can achieve from buying and selling the stock.\n    \"\"\"\n    n = len(prices)\n    dp = [[0] * 3 for _ in range(n)]\n\n    dp[0][0] = -prices[0]\n\n    for i in range(1, n):\n        dp[i][0] = max(dp[i-1][0], dp[i-1][2] - prices[i])\n        dp[i][1] = dp[i-1][0] + prices[i]\n        dp[i][2] = max(dp[i-1][1], dp[i-1][2])\n\n    return max(dp[n-1][1], dp[n-1][2])\n\ndef g() -> List[int]:\n    return [1, 2, 3, 0, 2]\n\nassert f(g()) == 3\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 302, "target_skills": [0, 0, 1, 0, 1, 1, 1, 1, 1, 0], "problem_func": "from typing import*\ndef f(prices: List[int]) -> int:\n    \"\"\"\n    Given an array prices where prices[i] is the price of a given stock on the ith day, return the maximum profit you can achieve from buying and selling the stock.\n\n    You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\n\n    - You must sell the stock before you buy again.\n    - After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).\n\n    Example:\n    prices = [1, 2, 3, 0, 2]\n    The maximum profit can be achieved by buying at day 1 (price = 1) and selling at day 2 (price = 3), then buying at day 4 (price = 0) and selling at day 5 (price = 2).\n    The maximum profit is 3.\n\n    Return the maximum profit you can achieve from buying and selling the stock.\n    \"\"\"\n    n = len(prices)\n    dp = [[0] * 3 for _ in range(n)]\n\n    dp[0][0] = -prices[0]\n\n    for i in range(1, n):\n        dp[i][0] = max(dp[i-1][0], dp[i-1][2] - prices[i])\n        dp[i][1] = dp[i-1][0] + prices[i]\n        dp[i][2] = max(dp[i-1][1], dp[i-1][2])\n\n    return max(dp[n-1][1], dp[n-1][2])", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3, 0, 2]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers in ascending order, determine if there are two numbers in the list that add up to the target number.\n    \n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    \n    Output:\n    True\n    \n    Explanation:\n    There are two numbers in the list, 2 and 5, that add up to the target number 7.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    \"\"\"\n    Return a sorted list of integers and the target number.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target\n\nassert f(*g()) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 302, "target_skills": [1, 0, 1, 0, 1, 0, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers in ascending order, determine if there are two numbers in the list that add up to the target number.\n    \n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    \n    Output:\n    True\n    \n    Explanation:\n    There are two numbers in the list, 2 and 5, that add up to the target number 7.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False", "solution_func": "def g():\n    \"\"\"\n    Return a sorted list of integers and the target number.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of valid paths from the top-left cell to the bottom-right cell of an n x n grid.\n    You can only move down or right.\n    \n    Example:\n    n = 3\n    \n    Output:\n    6\n    \n    Explanation:\n    There are 6 valid paths from the top-left cell to the bottom-right cell:\n    - Right -> Right -> Down\n    - Right -> Down -> Right\n    - Right -> Down -> Down\n    - Down -> Right -> Right\n    - Down -> Right -> Down\n    - Down -> Down -> Right\n    \"\"\"\n    dp = [[0] * (n+1) for _ in range(n+1)]\n    \n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i == 1 or j == 1:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[n][n]\n\ndef g(n: int = 3):\n    \"\"\"\n    Return the size of the grid.\n    \"\"\"\n    return n\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 302, "target_skills": [1, 0, 1, 0, 1, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of valid paths from the top-left cell to the bottom-right cell of an n x n grid.\n    You can only move down or right.\n    \n    Example:\n    n = 3\n    \n    Output:\n    6\n    \n    Explanation:\n    There are 6 valid paths from the top-left cell to the bottom-right cell:\n    - Right -> Right -> Down\n    - Right -> Down -> Right\n    - Right -> Down -> Down\n    - Down -> Right -> Right\n    - Down -> Right -> Down\n    - Down -> Down -> Right\n    \"\"\"\n    dp = [[0] * (n+1) for _ in range(n+1)]\n    \n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i == 1 or j == 1:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[n][n]", "solution_func": "def g(n: int = 3):\n    \"\"\"\n    Return the size of the grid.\n    \"\"\"\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\nclass Graph:\n    def __init__(self, num_vertices: int):\n        self.num_vertices = num_vertices\n        self.adj_list = [[] for _ in range(num_vertices)]\n    \n    def add_edge(self, u: int, v: int):\n        self.adj_list[u].append(v)\n    \n    def is_path(self, start: int, end: int) -> bool:\n        visited = [False] * self.num_vertices\n        stack = [start]\n        \n        while stack:\n            vertex = stack.pop()\n            \n            if vertex == end:\n                return True\n            \n            if not visited[vertex]:\n                visited[vertex] = True\n                \n                for neighbor in self.adj_list[vertex]:\n                    stack.append(neighbor)\n        \n        return False\n\ndef f(edges: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a list of directed edges, check if there is a path from a start node to an end node in the graph.\n    \"\"\"\n    num_vertices = max(max(edge) for edge in edges) + 1\n    graph = Graph(num_vertices)\n    \n    for edge in edges:\n        u, v = edge\n        graph.add_edge(u, v)\n    \n    return graph.is_path(start, end)\n\ndef g():\n    edges = [[0, 1], [1, 2], [2, 3]]\n    start = 0\n    end = 3\n    return edges, start, end\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 302, "target_skills": [0, 0, 0, 1, 0, 0, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\nclass Graph:\n    def __init__(self, num_vertices: int):\n        self.num_vertices = num_vertices\n        self.adj_list = [[] for _ in range(num_vertices)]\n    \n    def add_edge(self, u: int, v: int):\n        self.adj_list[u].append(v)\n    \n    def is_path(self, start: int, end: int) -> bool:\n        visited = [False] * self.num_vertices\n        stack = [start]\n        \n        while stack:\n            vertex = stack.pop()\n            \n            if vertex == end:\n                return True\n            \n            if not visited[vertex]:\n                visited[vertex] = True\n                \n                for neighbor in self.adj_list[vertex]:\n                    stack.append(neighbor)\n        \n        return False\n\ndef f(edges: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a list of directed edges, check if there is a path from a start node to an end node in the graph.\n    \"\"\"\n    num_vertices = max(max(edge) for edge in edges) + 1\n    graph = Graph(num_vertices)\n    \n    for edge in edges:\n        u, v = edge\n        graph.add_edge(u, v)\n    \n    return graph.is_path(start, end)", "solution_func": "def g():\n    edges = [[0, 1], [1, 2], [2, 3]]\n    start = 0\n    end = 3\n    return edges, start, end", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - A sorted list of integers in ascending order.\n    \"\"\"\n    return sorted(nums)\n\ndef g():\n    nums = [5, 2, 8, 1, 9, 4]\n    return nums\n\nassert f(g()) == [1, 2, 4, 5, 8, 9]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 302, "target_skills": [1, 0, 1, 1, 1, 1, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - A sorted list of integers in ascending order.\n    \"\"\"\n    return sorted(nums)", "solution_func": "def g():\n    nums = [5, 2, 8, 1, 9, 4]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph, determine if it is a tree.\n\n    Example:\n    Input:\n    graph = [[1, 2], [2, 3], [3, 4], [4, 1]]\n\n    Output:\n    False\n\n    Explanation:\n    The graph has a cycle (1 -> 2 -> 3 -> 4 -> 1), so it is not a tree.\n    \"\"\"\n\n    def dfs(node, visited, parent):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, node):\n                    return True\n            elif neighbor != parent:\n                return True\n        return False\n\n    n = len(graph)\n    visited = [False] * n\n\n    if dfs(0, visited, -1):\n        return False\n\n    for i in range(n):\n        if not visited[i]:\n            return False\n\n    return True\n\ndef g():\n    \"\"\"\n    Generate a graph represented as a list of lists with the following structure:\n    [[1, 2], [2, 3], [3, 4]]\n\n    Note: The graph must not contain any cycles.\n    \"\"\"\n    return [[1, 2], [2, 3], [3, 4]]\n\nassert f(g()) == True\n\n", "emb": null, "idx_generation": 303, "target_skills": [0, 0, 1, 1, 0, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph, determine if it is a tree.\n\n    Example:\n    Input:\n    graph = [[1, 2], [2, 3], [3, 4], [4, 1]]\n\n    Output:\n    False\n\n    Explanation:\n    The graph has a cycle (1 -> 2 -> 3 -> 4 -> 1), so it is not a tree.\n    \"\"\"\n\n    def dfs(node, visited, parent):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, node):\n                    return True\n            elif neighbor != parent:\n                return True\n        return False\n\n    n = len(graph)\n    visited = [False] * n\n\n    if dfs(0, visited, -1):\n        return False\n\n    for i in range(n):\n        if not visited[i]:\n            return False\n\n    return True", "solution_func": "def g():\n    \"\"\"\n    Generate a graph represented as a list of lists with the following structure:\n    [[1, 2], [2, 3], [3, 4]]\n\n    Note: The graph must not contain any cycles.\n    \"\"\"\n    return [[1, 2], [2, 3], [3, 4]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the sum of the first n natural numbers.\n\n    Example:\n    Input:\n    n = 5\n\n    Output:\n    15\n\n    Explanation:\n    The sum of the first 5 natural numbers is 1 + 2 + 3 + 4 + 5 = 15.\n    \"\"\"\n\n    return (n * (n + 1)) // 2\n\ndef g():\n    \"\"\"\n    Generate an integer with the following structure:\n    7\n    \"\"\"\n    return 7\n\nassert f(g()) == 28\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 303, "target_skills": [1, 1, 0, 0, 1, 1, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the sum of the first n natural numbers.\n\n    Example:\n    Input:\n    n = 5\n\n    Output:\n    15\n\n    Explanation:\n    The sum of the first 5 natural numbers is 1 + 2 + 3 + 4 + 5 = 15.\n    \"\"\"\n\n    return (n * (n + 1)) // 2", "solution_func": "def g():\n    \"\"\"\n    Generate an integer with the following structure:\n    7\n    \"\"\"\n    return 7", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum steps required to reach the target cell from the starting cell.\n\n    Example:\n    Input:\n    grid = [\n        [1, 1, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 0],\n        [0, 1, 1, 1]\n    ]\n\n    Output:\n    5\n\n    Explanation:\n    The minimum steps required to reach the target cell (3, 3) from the starting cell (0, 0) are:\n    (0, 0) -> (1, 0) -> (1, 1) -> (2, 1) -> (3, 1) -> (3, 2) -> (3, 3)\n    \"\"\"\n\n    m, n = len(grid), len(grid[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    queue = [(0, 0)]\n    steps = 0\n\n    while queue:\n        size = len(queue)\n        for _ in range(size):\n            x, y = queue.pop(0)\n            if x == m - 1 and y == n - 1:\n                return steps\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1:\n                    queue.append((nx, ny))\n                    grid[nx][ny] = 0\n        steps += 1\n\n    return -1\n\ndef g():\n    \"\"\"\n    Generate a grid represented as a list of lists with the following structure:\n    [\n        [1, 1, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 0],\n        [0, 1, 1, 1]\n    ]\n    \"\"\"\n    return [\n        [1, 1, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 0],\n        [0, 1, 1, 1]\n    ]\n\nassert f(g()) == 5\n\n", "emb": null, "idx_generation": 303, "target_skills": [0, 0, 1, 0, 0, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum steps required to reach the target cell from the starting cell.\n\n    Example:\n    Input:\n    grid = [\n        [1, 1, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 0],\n        [0, 1, 1, 1]\n    ]\n\n    Output:\n    5\n\n    Explanation:\n    The minimum steps required to reach the target cell (3, 3) from the starting cell (0, 0) are:\n    (0, 0) -> (1, 0) -> (1, 1) -> (2, 1) -> (3, 1) -> (3, 2) -> (3, 3)\n    \"\"\"\n\n    m, n = len(grid), len(grid[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    queue = [(0, 0)]\n    steps = 0\n\n    while queue:\n        size = len(queue)\n        for _ in range(size):\n            x, y = queue.pop(0)\n            if x == m - 1 and y == n - 1:\n                return steps\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1:\n                    queue.append((nx, ny))\n                    grid[nx][ny] = 0\n        steps += 1\n\n    return -1", "solution_func": "def g():\n    \"\"\"\n    Generate a grid represented as a list of lists with the following structure:\n    [\n        [1, 1, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 0],\n        [0, 1, 1, 1]\n    ]\n    \"\"\"\n    return [\n        [1, 1, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 0],\n        [0, 1, 1, 1]\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers and a target value, find the index of the target in the array. If the target is not found, return -1.\n\n    Example:\n    nums = [-1, 0, 3, 5, 9, 12]\n    target = 9\n\n    Output:\n    4 (since the target value 9 is found at index 4 in the array)\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> List[int]:\n    return [-1, 0, 3, 5, 9, 12]\n\nassert f(g(), 9) == 4\n\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 303, "target_skills": [0, 0, 1, 1, 1, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers and a target value, find the index of the target in the array. If the target is not found, return -1.\n\n    Example:\n    nums = [-1, 0, 3, 5, 9, 12]\n    target = 9\n\n    Output:\n    4 (since the target value 9 is found at index 4 in the array)\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g() -> List[int]:\n    return [-1, 0, 3, 5, 9, 12]", "map_ix": [1, 0, 0, 1, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of numbers, generate all possible permutations of the numbers.\n\n    Example:\n    nums = [1, 2, 3]\n\n    Output:\n    [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n    \"\"\"\n    def backtrack(nums, path, used, res):\n        if len(path) == len(nums):\n            res.append(path[:])\n            return\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(nums, path, used, res)\n            used[i] = False\n            path.pop()\n\n    res = []\n    used = [False] * len(nums)\n    backtrack(nums, [], used, res)\n    return res\n\ndef g() -> List[int]:\n    return [1, 2, 3]\n\nassert f(g()) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 303, "target_skills": [1, 1, 1, 1, 0, 1, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of numbers, generate all possible permutations of the numbers.\n\n    Example:\n    nums = [1, 2, 3]\n\n    Output:\n    [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n    \"\"\"\n    def backtrack(nums, path, used, res):\n        if len(path) == len(nums):\n            res.append(path[:])\n            return\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(nums, path, used, res)\n            used[i] = False\n            path.pop()\n\n    res = []\n    used = [False] * len(nums)\n    backtrack(nums, [], used, res)\n    return res", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the maximum number of connected 1s in the grid. Two 1s are considered connected if they are adjacent horizontally or vertically.\n\n    Example:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 1, 1, 0],\n        [1, 0, 0, 0, 0],\n        [1, 1, 1, 0, 0],\n        [0, 0, 0, 0, 0]\n    ]\n\n    Output:\n    8 (since the maximum number of connected 1s in the grid is 8)\n    \"\"\"\n    def dfs(grid, row, col):\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] != 1:\n            return 0\n        grid[row][col] = -1\n        count = 1\n        count += dfs(grid, row - 1, col)\n        count += dfs(grid, row + 1, col)\n        count += dfs(grid, row, col - 1)\n        count += dfs(grid, row, col + 1)\n        return count\n\n    max_count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                count = dfs(grid, i, j)\n                max_count = max(max_count, count)\n\n    return max_count\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 1, 0, 0, 0],\n        [1, 1, 1, 1, 0],\n        [1, 0, 0, 0, 0],\n        [1, 1, 1, 0, 0],\n        [0, 0, 0, 0, 0]\n    ]\n\nassert f(g()) == 8\n\n", "emb": null, "idx_generation": 303, "target_skills": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the maximum number of connected 1s in the grid. Two 1s are considered connected if they are adjacent horizontally or vertically.\n\n    Example:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 1, 1, 0],\n        [1, 0, 0, 0, 0],\n        [1, 1, 1, 0, 0],\n        [0, 0, 0, 0, 0]\n    ]\n\n    Output:\n    8 (since the maximum number of connected 1s in the grid is 8)\n    \"\"\"\n    def dfs(grid, row, col):\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] != 1:\n            return 0\n        grid[row][col] = -1\n        count = 1\n        count += dfs(grid, row - 1, col)\n        count += dfs(grid, row + 1, col)\n        count += dfs(grid, row, col - 1)\n        count += dfs(grid, row, col + 1)\n        return count\n\n    max_count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                count = dfs(grid, i, j)\n                max_count = max(max_count, count)\n\n    return max_count", "solution_func": "def g() -> List[List[int]]:\n    return [\n        [1, 1, 0, 0, 0],\n        [1, 1, 1, 1, 0],\n        [1, 0, 0, 0, 0],\n        [1, 1, 1, 0, 0],\n        [0, 0, 0, 0, 0]\n    ]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum you can obtain by starting at the top-left corner and moving only\n    right or down to the bottom-right corner. Each cell can only be visited once.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The maximum sum is obtained by following the path 1 -> 3 -> 1 -> 1 -> 1, which gives a total sum of 7.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 7\n", "emb": null, "idx_generation": 303, "target_skills": [0, 1, 0, 0, 0, 0, 1, 0, 0, 0], "problem_func": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum you can obtain by starting at the top-left corner and moving only\n    right or down to the bottom-right corner. Each cell can only be visited once.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The maximum sum is obtained by following the path 1 -> 3 -> 1 -> 1 -> 1, which gives a total sum of 7.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of ways to climb to the top of a staircase. You can climb either 1 or 2 steps\n    at a time. The order of steps is important.\n\n    Example:\n    Input: n = 4\n    Output: 5\n\n    Explanation:\n    There are 5 ways to climb to the top:\n    1. 1 step + 1 step + 1 step + 1 step\n    2. 1 step + 1 step + 2 steps\n    3. 1 step + 2 steps + 1 step\n    4. 2 steps + 1 step + 1 step\n    5. 2 steps + 2 steps\n    \"\"\"\n\n    if n == 0 or n == 1:\n        return 1\n\n    dp = [0] * (n+1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n+1):\n        dp[i] = dp[i-1] + dp[i-2]\n\n    return dp[n]\n\ndef g():\n    return 4\n\nassert f(g()) == 5\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 303, "target_skills": [0, 1, 0, 0, 0, 1, 1, 1, 1, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of ways to climb to the top of a staircase. You can climb either 1 or 2 steps\n    at a time. The order of steps is important.\n\n    Example:\n    Input: n = 4\n    Output: 5\n\n    Explanation:\n    There are 5 ways to climb to the top:\n    1. 1 step + 1 step + 1 step + 1 step\n    2. 1 step + 1 step + 2 steps\n    3. 1 step + 2 steps + 1 step\n    4. 2 steps + 1 step + 1 step\n    5. 2 steps + 2 steps\n    \"\"\"\n\n    if n == 0 or n == 1:\n        return 1\n\n    dp = [0] * (n+1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n+1):\n        dp[i] = dp[i-1] + dp[i-2]\n\n    return dp[n]", "solution_func": "def g():\n    return 4", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\nfrom collections import deque\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum number of moves required to reach the bottom-right corner from the top-left\n    corner. Each move can only be made to a neighboring cell with a lower or equal value.\n\n    Example:\n    grid = [\n        [5, 1, 2],\n        [3, 4, 7],\n        [6, 9, 8]\n    ]\n\n    Output:\n    2\n\n    Explanation:\n    The minimum number of moves is obtained by following the path 5 -> 3 -> 4 -> 7 -> 8, which takes a total of 2 moves.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n\n    queue = deque([(0, 0)])\n\n    while queue:\n        i, j = queue.popleft()\n\n        for dx, dy in [(1, 0), (0, 1)]:\n            ni, nj = i + dx, j + dy\n            if ni >= m or nj >= n:\n                continue\n            if grid[ni][nj] <= grid[i][j] and dp[ni][nj] > dp[i][j] + 1:\n                dp[ni][nj] = dp[i][j] + 1\n                queue.append((ni, nj))\n\n    return dp[m-1][n-1]\n\ndef g():\n    return [[5, 1, 2], [3, 4, 7], [6, 9, 8]]\n\nassert f(g()) == 2\n", "emb": null, "idx_generation": 303, "target_skills": [1, 0, 1, 0, 0, 0, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\nfrom collections import deque\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum number of moves required to reach the bottom-right corner from the top-left\n    corner. Each move can only be made to a neighboring cell with a lower or equal value.\n\n    Example:\n    grid = [\n        [5, 1, 2],\n        [3, 4, 7],\n        [6, 9, 8]\n    ]\n\n    Output:\n    2\n\n    Explanation:\n    The minimum number of moves is obtained by following the path 5 -> 3 -> 4 -> 7 -> 8, which takes a total of 2 moves.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n\n    queue = deque([(0, 0)])\n\n    while queue:\n        i, j = queue.popleft()\n\n        for dx, dy in [(1, 0), (0, 1)]:\n            ni, nj = i + dx, j + dy\n            if ni >= m or nj >= n:\n                continue\n            if grid[ni][nj] <= grid[i][j] and dp[ni][nj] > dp[i][j] + 1:\n                dp[ni][nj] = dp[i][j] + 1\n                queue.append((ni, nj))\n\n    return dp[m-1][n-1]", "solution_func": "def g():\n    return [[5, 1, 2], [3, 4, 7], [6, 9, 8]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target integer k, check if there exists a pair of integers in the list whose sum is equal to k.\n    \"\"\"\n    num_set = set()\n    for num in nums:\n        if k - num in num_set:\n            return True\n        num_set.add(num)\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    k = 7\n    return nums, k\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 303, "target_skills": [1, 0, 0, 0, 0, 0, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target integer k, check if there exists a pair of integers in the list whose sum is equal to k.\n    \"\"\"\n    num_set = set()\n    for num in nums:\n        if k - num in num_set:\n            return True\n        num_set.add(num)\n    return False", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    k = 7\n    return nums, k", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target\n    value.\n\n    If target is not found in the array, return [-1, -1].\n\n    Args:\n    - nums: A list of integers sorted in ascending order\n    - target: The target value to search for\n\n    Returns:\n    - A list containing the starting and ending position of the target value, or [-1, -1] if not found.\n    \"\"\"\n    def binary_search(nums: List[int], target: int, left: bool) -> int:\n        low = 0\n        high = len(nums) - 1\n        result = -1\n        \n        while low <= high:\n            mid = (low + high) // 2\n            if nums[mid] == target:\n                result = mid\n                if left:\n                    high = mid - 1\n                else:\n                    low = mid + 1\n            elif nums[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return result\n\n    start = binary_search(nums, target, True)\n    end = binary_search(nums, target, False)\n\n    return [start, end]\n\ndef g() -> Tuple[List[int], int]:\n    nums = [5, 7, 7, 8, 8, 10]\n    target = 8\n    return nums, target\n\nassert f(*g()) == [3, 4]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 304, "target_skills": [1, 1, 1, 0, 0, 1, 0, 0, 1, 1], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target\n    value.\n\n    If target is not found in the array, return [-1, -1].\n\n    Args:\n    - nums: A list of integers sorted in ascending order\n    - target: The target value to search for\n\n    Returns:\n    - A list containing the starting and ending position of the target value, or [-1, -1] if not found.\n    \"\"\"\n    def binary_search(nums: List[int], target: int, left: bool) -> int:\n        low = 0\n        high = len(nums) - 1\n        result = -1\n        \n        while low <= high:\n            mid = (low + high) // 2\n            if nums[mid] == target:\n                result = mid\n                if left:\n                    high = mid - 1\n                else:\n                    low = mid + 1\n            elif nums[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return result\n\n    start = binary_search(nums, target, True)\n    end = binary_search(nums, target, False)\n\n    return [start, end]", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [5, 7, 7, 8, 8, 10]\n    target = 8\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of unique BST (binary search tree) structures that can be formed with values\n    from 1 to n.\n\n    Args:\n    - n: An integer\n\n    Returns:\n    - The number of unique BST structures that can be formed\n    \"\"\"\n    def count_unique_bst(n: int, memo: dict) -> int:\n        if n <= 1:\n            return 1\n        if n in memo:\n            return memo[n]\n        \n        count = 0\n        for i in range(1, n+1):\n            left = count_unique_bst(i-1, memo)\n            right = count_unique_bst(n-i, memo)\n            count += left * right\n        \n        memo[n] = count\n        return count\n\n    memo = {}\n    return count_unique_bst(n, memo)\n\ndef g() -> int:\n    n = 3\n    return n\n\nassert f(g()) == 5\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 304, "target_skills": [0, 1, 1, 0, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of unique BST (binary search tree) structures that can be formed with values\n    from 1 to n.\n\n    Args:\n    - n: An integer\n\n    Returns:\n    - The number of unique BST structures that can be formed\n    \"\"\"\n    def count_unique_bst(n: int, memo: dict) -> int:\n        if n <= 1:\n            return 1\n        if n in memo:\n            return memo[n]\n        \n        count = 0\n        for i in range(1, n+1):\n            left = count_unique_bst(i-1, memo)\n            right = count_unique_bst(n-i, memo)\n            count += left * right\n        \n        memo[n] = count\n        return count\n\n    memo = {}\n    return count_unique_bst(n, memo)", "solution_func": "def g() -> int:\n    n = 3\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, find the area of the largest island. An island is a group of connected 1s\n    horizontally or vertically. You may assume that the grid is rectangular and that there is at least one island.\n\n    Args:\n    - grid: A 2D list of 0s and 1s\n\n    Returns:\n    - The area of the largest island\n    \"\"\"\n    def dfs(grid: List[List[int]], i: int, j: int) -> int:\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0:\n            return 0\n        \n        grid[i][j] = 0\n        count = 1\n        count += dfs(grid, i-1, j)\n        count += dfs(grid, i+1, j)\n        count += dfs(grid, i, j-1)\n        count += dfs(grid, i, j+1)\n\n        return count\n\n    max_area = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                area = dfs(grid, i, j)\n                max_area = max(max_area, area)\n\n    return max_area\n\ndef g() -> List[List[int]]:\n    grid = [[1, 1, 0, 0, 0],\n            [1, 1, 0, 0, 0],\n            [0, 0, 0, 1, 1],\n            [0, 0, 0, 1, 1]]\n    return grid\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 304, "target_skills": [0, 1, 1, 1, 1, 1, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, find the area of the largest island. An island is a group of connected 1s\n    horizontally or vertically. You may assume that the grid is rectangular and that there is at least one island.\n\n    Args:\n    - grid: A 2D list of 0s and 1s\n\n    Returns:\n    - The area of the largest island\n    \"\"\"\n    def dfs(grid: List[List[int]], i: int, j: int) -> int:\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0:\n            return 0\n        \n        grid[i][j] = 0\n        count = 1\n        count += dfs(grid, i-1, j)\n        count += dfs(grid, i+1, j)\n        count += dfs(grid, i, j-1)\n        count += dfs(grid, i, j+1)\n\n        return count\n\n    max_area = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                area = dfs(grid, i, j)\n                max_area = max(max_area, area)\n\n    return max_area", "solution_func": "def g() -> List[List[int]]:\n    grid = [[1, 1, 0, 0, 0],\n            [1, 1, 0, 0, 0],\n            [0, 0, 0, 1, 1],\n            [0, 0, 0, 1, 1]]\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int, nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums and an integer k, determine if there exists two distinct indices i and j\n    such that nums[i] + nums[j] = k.\n\n    Example:\n    Input:\n    n = 5\n    k = 10\n    nums = [3, 2, 5, 7, 1]\n\n    Output: True\n\n    Explanation: nums[2] + nums[3] = 5 + 5 = 10\n    \"\"\"\n\n    def two_sum(nums: List[int], k: int) -> bool:\n        seen = set()\n\n        for num in nums:\n            if k - num in seen:\n                return True\n            seen.add(num)\n\n        return False\n\n    return two_sum(nums, k)\n\ndef g():\n    n = 5\n    k = 10\n    nums = [3, 2, 5, 7, 1]\n    return n, k, nums\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 304, "target_skills": [1, 1, 0, 0, 0, 1, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int, nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums and an integer k, determine if there exists two distinct indices i and j\n    such that nums[i] + nums[j] = k.\n\n    Example:\n    Input:\n    n = 5\n    k = 10\n    nums = [3, 2, 5, 7, 1]\n\n    Output: True\n\n    Explanation: nums[2] + nums[3] = 5 + 5 = 10\n    \"\"\"\n\n    def two_sum(nums: List[int], k: int) -> bool:\n        seen = set()\n\n        for num in nums:\n            if k - num in seen:\n                return True\n            seen.add(num)\n\n        return False\n\n    return two_sum(nums, k)", "solution_func": "def g():\n    n = 5\n    k = 10\n    nums = [3, 2, 5, 7, 1]\n    return n, k, nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a list of words, determine if it is possible to break the string s into a space-separated\n    sequence of one or more dictionary words.\n\n    Example:\n    Input:\n    s = \"leetcode\"\n    words = [\"leet\", \"code\"]\n\n    Output: True\n\n    Explanation: \"leetcode\" can be broken into \"leet\" and \"code\"\n    \"\"\"\n\n    def word_break(s: str, words: List[str]) -> bool:\n        n = len(s)\n        dp = [False] * (n + 1)\n        dp[0] = True\n\n        for i in range(1, n + 1):\n            for word in words:\n                if i >= len(word) and dp[i - len(word)] and s[i - len(word):i] == word:\n                    dp[i] = True\n                    break\n\n        return dp[-1]\n\n    return word_break(s, words)\n\ndef g():\n    s = \"leetcode\"\n    words = [\"leet\", \"code\"]\n    return s, words\n\nassert f(*g()) == True\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 304, "target_skills": [0, 1, 0, 1, 1, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a list of words, determine if it is possible to break the string s into a space-separated\n    sequence of one or more dictionary words.\n\n    Example:\n    Input:\n    s = \"leetcode\"\n    words = [\"leet\", \"code\"]\n\n    Output: True\n\n    Explanation: \"leetcode\" can be broken into \"leet\" and \"code\"\n    \"\"\"\n\n    def word_break(s: str, words: List[str]) -> bool:\n        n = len(s)\n        dp = [False] * (n + 1)\n        dp[0] = True\n\n        for i in range(1, n + 1):\n            for word in words:\n                if i >= len(word) and dp[i - len(word)] and s[i - len(word):i] == word:\n                    dp[i] = True\n                    break\n\n        return dp[-1]\n\n    return word_break(s, words)", "solution_func": "def g():\n    s = \"leetcode\"\n    words = [\"leet\", \"code\"]\n    return s, words", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums, determine if there exists a subarray with the bitwise XOR of its elements equal to 0.\n\n    Example:\n    Input:\n    nums = [3, 2, 1, 0, 2, 3, 1, 0]\n\n    Output: True\n\n    Explanation: The subarray [3, 2, 1, 0, 2, 3, 1, 0] has a bitwise XOR of 0.\n    \"\"\"\n\n    def zero_xor_subarray(nums: List[int]) -> bool:\n        xor = 0\n        prefix_xor = set()\n\n        for num in nums:\n            xor ^= num\n            if xor == 0 or xor in prefix_xor:\n                return True\n            prefix_xor.add(xor)\n\n        return False\n\n    return zero_xor_subarray(nums)\n\ndef g():\n    nums = [3, 2, 1, 0, 2, 3, 1, 0]\n    return nums\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 304, "target_skills": [0, 0, 1, 0, 1, 0, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums, determine if there exists a subarray with the bitwise XOR of its elements equal to 0.\n\n    Example:\n    Input:\n    nums = [3, 2, 1, 0, 2, 3, 1, 0]\n\n    Output: True\n\n    Explanation: The subarray [3, 2, 1, 0, 2, 3, 1, 0] has a bitwise XOR of 0.\n    \"\"\"\n\n    def zero_xor_subarray(nums: List[int]) -> bool:\n        xor = 0\n        prefix_xor = set()\n\n        for num in nums:\n            xor ^= num\n            if xor == 0 or xor in prefix_xor:\n                return True\n            prefix_xor.add(xor)\n\n        return False\n\n    return zero_xor_subarray(nums)", "solution_func": "def g():\n    nums = [3, 2, 1, 0, 2, 3, 1, 0]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique combinations that add up to a target value.\n    \"\"\"\n    def backtrack(start, target):\n        if target == 0:\n            return 1\n        elif target < 0:\n            return 0\n\n        count = 0\n        for i in range(start, len(nums)):\n            count += backtrack(i, target - nums[i])\n        return count\n\n    return backtrack(0, sum(nums))\n\ndef g(nums: List[int]):\n    return nums\n\nassert f(g([1, 2, 3, 4, 5])) == 3\n", "emb": null, "idx_generation": 304, "target_skills": [1, 1, 1, 0, 0, 0, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique combinations that add up to a target value.\n    \"\"\"\n    def backtrack(start, target):\n        if target == 0:\n            return 1\n        elif target < 0:\n            return 0\n\n        count = 0\n        for i in range(start, len(nums)):\n            count += backtrack(i, target - nums[i])\n        return count\n\n    return backtrack(0, sum(nums))", "solution_func": "def g(nums: List[int]):\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string, find the number of palindromic substrings.\n    \"\"\"\n    count = 0\n\n    def expand(left, right):\n        nonlocal count\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            count += 1\n            left -= 1\n            right += 1\n\n    for i in range(len(s)):\n        expand(i, i)  # odd length palindromes\n        expand(i, i + 1)  # even length palindromes\n\n    return count\n\ndef g(s: str):\n    return s\n\nassert f(g(\"abcba\")) == 7\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 304, "target_skills": [0, 1, 1, 0, 0, 0, 1, 1, 1, 0], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string, find the number of palindromic substrings.\n    \"\"\"\n    count = 0\n\n    def expand(left, right):\n        nonlocal count\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            count += 1\n            left -= 1\n            right += 1\n\n    for i in range(len(s)):\n        expand(i, i)  # odd length palindromes\n        expand(i, i + 1)  # even length palindromes\n\n    return count", "solution_func": "def g(s: str):\n    return s", "map_ix": [1, 1, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find a subarray whose sum is equal to the target value.\n    \"\"\"\n    prefix_sum = {}\n    current_sum = 0\n\n    for i in range(len(nums)):\n        current_sum += nums[i]\n\n        if current_sum == target:\n            return nums[:i+1]\n\n        if current_sum - target in prefix_sum:\n            return nums[prefix_sum[current_sum - target] + 1:i+1]\n\n        prefix_sum[current_sum] = i\n\n    return []\n\ndef g(nums: List[int], target: int):\n    return nums, target\n\nassert f(g([1, 2, 3, 4, 5], 9)) == [2, 3, 4]\n", "emb": null, "idx_generation": 304, "target_skills": [0, 1, 1, 0, 1, 1, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find a subarray whose sum is equal to the target value.\n    \"\"\"\n    prefix_sum = {}\n    current_sum = 0\n\n    for i in range(len(nums)):\n        current_sum += nums[i]\n\n        if current_sum == target:\n            return nums[:i+1]\n\n        if current_sum - target in prefix_sum:\n            return nums[prefix_sum[current_sum - target] + 1:i+1]\n\n        prefix_sum[current_sum] = i\n\n    return []", "solution_func": "def g(nums: List[int], target: int):\n    return nums, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the longest increasing subsequence (LIS) and return its length.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n\n    Hint: Use dynamic programming to keep track of the LIS at each index.\n    \"\"\"\n\n    n = len(nums)\n    if n == 0:\n        return 0\n\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g(nums=[10, 9, 2, 5, 3, 7, 101, 18]):\n    return nums\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 304, "target_skills": [1, 1, 1, 1, 0, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the longest increasing subsequence (LIS) and return its length.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n\n    Hint: Use dynamic programming to keep track of the LIS at each index.\n    \"\"\"\n\n    n = len(nums)\n    if n == 0:\n        return 0\n\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)", "solution_func": "def g(nums=[10, 9, 2, 5, 3, 7, 101, 18]):\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique combinations of three numbers that add up to zero.\n\n    Parameters:\n    nums (List[int]): A list of integers.\n\n    Returns:\n    int: The number of unique combinations of three numbers that add up to zero.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    count = 0\n    for i in range(n-2):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n        left = i + 1\n        right = n - 1\n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n            if total < 0:\n                left += 1\n            elif total > 0:\n                right -= 1\n            else:\n                count += 1\n                while left < right and nums[left] == nums[left+1]:\n                    left += 1\n                while left < right and nums[right] == nums[right-1]:\n                    right -= 1\n                left += 1\n                right -= 1\n    return count\n\ndef g(nums=[-1, 0, 1, 2, -1, -4]):\n    return nums\n\nassert f(g()) == 2\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 305, "target_skills": [0, 1, 1, 0, 0, 1, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique combinations of three numbers that add up to zero.\n\n    Parameters:\n    nums (List[int]): A list of integers.\n\n    Returns:\n    int: The number of unique combinations of three numbers that add up to zero.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    count = 0\n    for i in range(n-2):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n        left = i + 1\n        right = n - 1\n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n            if total < 0:\n                left += 1\n            elif total > 0:\n                right -= 1\n            else:\n                count += 1\n                while left < right and nums[left] == nums[left+1]:\n                    left += 1\n                while left < right and nums[right] == nums[right-1]:\n                    right -= 1\n                left += 1\n                right -= 1\n    return count", "solution_func": "def g(nums=[-1, 0, 1, 2, -1, -4]):\n    return nums", "map_ix": [1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of words in the string.\n\n    Parameters:\n    s (str): A string.\n\n    Returns:\n    str: The string with words reversed.\n    \"\"\"\n    words = s.split()\n    reversed_words = \" \".join(words[::-1])\n    return reversed_words\n\ndef g(s=\"hello world\"):\n    return s\n\nassert f(g()) == \"world hello\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 305, "target_skills": [1, 1, 1, 1, 0, 1, 1, 0, 1, 1], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of words in the string.\n\n    Parameters:\n    s (str): A string.\n\n    Returns:\n    str: The string with words reversed.\n    \"\"\"\n    words = s.split()\n    reversed_words = \" \".join(words[::-1])\n    return reversed_words", "solution_func": "def g(s=\"hello world\"):\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find two numbers in the list that add up to the target.\n\n    Parameters:\n    nums (List[int]): A list of integers.\n    target (int): The target number.\n\n    Returns:\n    List[int]: The indices of the two numbers that add up to the target.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "idx_generation": 305, "target_skills": [1, 0, 0, 1, 0, 0, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find two numbers in the list that add up to the target.\n\n    Parameters:\n    nums (List[int]): A list of integers.\n    target (int): The target number.\n\n    Returns:\n    List[int]: The indices of the two numbers that add up to the target.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []", "solution_func": "def g(nums=[2, 7, 11, 15], target=9):\n    return nums, target", "map_ix": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Check if the given list of integers is a strictly increasing sequence.\n    \"\"\"\n\n    for i in range(1, len(nums)):\n        if nums[i] <= nums[i-1]:\n            return False\n\n    return True\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g())\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 305, "target_skills": [0, 1, 0, 1, 0, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Check if the given list of integers is a strictly increasing sequence.\n    \"\"\"\n\n    for i in range(1, len(nums)):\n        if nums[i] <= nums[i-1]:\n            return False\n\n    return True", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Calculate the length of the longest substring without repeating characters in the given string.\n    \"\"\"\n\n    max_length = 0\n    start = 0\n    visited = {}\n\n    for i in range(len(s)):\n        if s[i] in visited and start <= visited[s[i]]:\n            start = visited[s[i]] + 1\n        else:\n            max_length = max(max_length, i - start + 1)\n\n        visited[s[i]] = i\n\n    return max_length\n\ndef g():\n    s = \"abcabcbb\"\n    return s\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 305, "target_skills": [0, 1, 1, 0, 0, 1, 0, 0, 1, 0], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Calculate the length of the longest substring without repeating characters in the given string.\n    \"\"\"\n\n    max_length = 0\n    start = 0\n    visited = {}\n\n    for i in range(len(s)):\n        if s[i] in visited and start <= visited[s[i]]:\n            start = visited[s[i]] + 1\n        else:\n            max_length = max(max_length, i - start + 1)\n\n        visited[s[i]] = i\n\n    return max_length", "solution_func": "def g():\n    s = \"abcabcbb\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Find two numbers in the given list that add up to the target value.\n    \"\"\"\n\n    num_map = {}\n\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[nums[i]] = i\n\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 305, "target_skills": [0, 0, 1, 0, 1, 1, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Find two numbers in the given list that add up to the target value.\n    \"\"\"\n\n    num_map = {}\n\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[nums[i]] = i\n\n    return []", "solution_func": "def g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 1, 0, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n\n    Example:\n    Input:\n    nums = [1, 3, 5, 7, 9, 11, 13]\n    target = 7\n\n    Output:\n    3\n    Explanation:\n    The target value 7 is located at index 3 in the list.\n\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    nums = [1, 3, 5, 7, 9, 11, 13]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 3\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 305, "target_skills": [0, 0, 1, 1, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n\n    Example:\n    Input:\n    nums = [1, 3, 5, 7, 9, 11, 13]\n    target = 7\n\n    Output:\n    3\n    Explanation:\n    The target value 7 is located at index 3 in the list.\n\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g():\n    nums = [1, 3, 5, 7, 9, 11, 13]\n    target = 7\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order using bubble sort algorithm.\n\n    Example:\n    Input:\n    nums = [5, 3, 8, 2, 1]\n\n    Output:\n    [1, 2, 3, 5, 8]\n    Explanation:\n    After sorting, the list is in ascending order.\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n\n    return nums\n\ndef g():\n    nums = [5, 3, 8, 2, 1]\n    return nums\n\nassert f(*g()) == [1, 2, 3, 5, 8]\n", "emb": null, "idx_generation": 305, "target_skills": [1, 1, 0, 1, 0, 0, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order using bubble sort algorithm.\n\n    Example:\n    Input:\n    nums = [5, 3, 8, 2, 1]\n\n    Output:\n    [1, 2, 3, 5, 8]\n    Explanation:\n    After sorting, the list is in ascending order.\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n\n    return nums", "solution_func": "def g():\n    nums = [5, 3, 8, 2, 1]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, reverse the order of the elements in the list using a stack.\n\n    Example:\n    Input:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    [5, 4, 3, 2, 1]\n    Explanation:\n    After reversing, the elements in the list are in reverse order.\n    \"\"\"\n    stack = []\n    for num in nums:\n        stack.append(num)\n\n    reversed_nums = []\n    while stack:\n        reversed_nums.append(stack.pop())\n\n    return reversed_nums\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(*g()) == [5, 4, 3, 2, 1]\n", "emb": null, "idx_generation": 305, "target_skills": [0, 0, 1, 0, 1, 1, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, reverse the order of the elements in the list using a stack.\n\n    Example:\n    Input:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    [5, 4, 3, 2, 1]\n    Explanation:\n    After reversing, the elements in the list are in reverse order.\n    \"\"\"\n    stack = []\n    for num in nums:\n        stack.append(num)\n\n    reversed_nums = []\n    while stack:\n        reversed_nums.append(stack.pop())\n\n    return reversed_nums", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "import math\nfrom typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the sum of all even numbers from 1 to n (inclusive).\n\n    Example:\n    n = 10\n\n    Output:\n    30\n\n    Explanation:\n    The even numbers from 1 to 10 are 2, 4, 6, 8, and 10. Their sum is 30.\n\n    Hint: Use mathematical principles to calculate the sum of even numbers.\n    \"\"\"\n\n    return sum(num for num in range(2, n + 1, 2))\n\n\ndef g(n=10):\n    return n\n\nassert f(g()) == 30\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 305, "target_skills": [1, 0, 1, 0, 1, 0, 1, 0, 1, 1], "problem_func": "import math\nfrom typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the sum of all even numbers from 1 to n (inclusive).\n\n    Example:\n    n = 10\n\n    Output:\n    30\n\n    Explanation:\n    The even numbers from 1 to 10 are 2, 4, 6, 8, and 10. Their sum is 30.\n\n    Hint: Use mathematical principles to calculate the sum of even numbers.\n    \"\"\"\n\n    return sum(num for num in range(2, n + 1, 2))", "solution_func": "def g(n=10):\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid filled with non-negative integers, find the minimum path sum from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    Input:\n    [\n      [1,3,1],\n      [1,5,1],\n      [4,2,1]\n    ]\n    Output: 7\n    Explanation: Because the path 1\u21923\u21921\u21921\u21921 minimizes the sum.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    \n    # Create a dp table to store the minimum path sum for each cell\n    dp = [[0] * n for _ in range(m)]\n    \n    # Initialize the first row and first column of the dp table\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    # Fill in the rest of the dp table using dynamic programming\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    # Return the minimum path sum for the bottom-right corner\n    return dp[m-1][n-1]\n\ndef g(grid = [[1,3,1],[1,5,1],[4,2,1]]):\n    return grid\n\nassert f(g()) == 7\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 306, "target_skills": [1, 0, 1, 0, 0, 0, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid filled with non-negative integers, find the minimum path sum from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    Input:\n    [\n      [1,3,1],\n      [1,5,1],\n      [4,2,1]\n    ]\n    Output: 7\n    Explanation: Because the path 1\u21923\u21921\u21921\u21921 minimizes the sum.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    \n    # Create a dp table to store the minimum path sum for each cell\n    dp = [[0] * n for _ in range(m)]\n    \n    # Initialize the first row and first column of the dp table\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    # Fill in the rest of the dp table using dynamic programming\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    # Return the minimum path sum for the bottom-right corner\n    return dp[m-1][n-1]", "solution_func": "def g(grid = [[1,3,1],[1,5,1],[4,2,1]]):\n    return grid", "map_ix": [1, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers, find two numbers such that they add up to a specific target.\n    Return the indices of the two numbers in the array.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n    Explanation: nums[0] + nums[1] = 2 + 7 = 9, so the indices are [0, 1].\n    \"\"\"\n    # Create a dictionary to store the indices of each number\n    num_dict = {}\n    \n    # Iterate through the array\n    for i, num in enumerate(nums):\n        # Check if the complement of the current number exists in the dictionary\n        complement = target - num\n        if complement in num_dict:\n            # Return the indices of the two numbers\n            return [num_dict[complement], i]\n        \n        # Add the current number and its index to the dictionary\n        num_dict[num] = i\n    \n    # If no solution is found, return an empty list\n    return []\n\ndef g(nums = [2, 7, 11, 15], target = 9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 306, "target_skills": [0, 0, 0, 0, 0, 1, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers, find two numbers such that they add up to a specific target.\n    Return the indices of the two numbers in the array.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n    Explanation: nums[0] + nums[1] = 2 + 7 = 9, so the indices are [0, 1].\n    \"\"\"\n    # Create a dictionary to store the indices of each number\n    num_dict = {}\n    \n    # Iterate through the array\n    for i, num in enumerate(nums):\n        # Check if the complement of the current number exists in the dictionary\n        complement = target - num\n        if complement in num_dict:\n            # Return the indices of the two numbers\n            return [num_dict[complement], i]\n        \n        # Add the current number and its index to the dictionary\n        num_dict[num] = i\n    \n    # If no solution is found, return an empty list\n    return []", "solution_func": "def g(nums = [2, 7, 11, 15], target = 9):\n    return nums, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid filled with non-negative integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    Input:\n    [\n      [1,3,1],\n      [1,5,1],\n      [4,2,1]\n    ]\n    Output: 12\n    Explanation: Because the path 1\u21923\u21925\u21921\u21922\u21921 maximizes the sum.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    \n    # Create a dp table to store the maximum path sum for each cell\n    dp = [[0] * n for _ in range(m)]\n    \n    # Initialize the first row and first column of the dp table\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    # Fill in the rest of the dp table using dynamic programming\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    # Return the maximum path sum for the bottom-right corner\n    return dp[m-1][n-1]\n\ndef g(grid = [[1,3,1],[1,5,1],[4,2,1]]):\n    return grid\n\nassert f(g()) == 12\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 306, "target_skills": [0, 1, 1, 0, 0, 0, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid filled with non-negative integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    Input:\n    [\n      [1,3,1],\n      [1,5,1],\n      [4,2,1]\n    ]\n    Output: 12\n    Explanation: Because the path 1\u21923\u21925\u21921\u21922\u21921 maximizes the sum.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    \n    # Create a dp table to store the maximum path sum for each cell\n    dp = [[0] * n for _ in range(m)]\n    \n    # Initialize the first row and first column of the dp table\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    # Fill in the rest of the dp table using dynamic programming\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    # Return the maximum path sum for the bottom-right corner\n    return dp[m-1][n-1]", "solution_func": "def g(grid = [[1,3,1],[1,5,1],[4,2,1]]):\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> int:\n    \"\"\"\n    Given a list of words, return the length of the longest common prefix among them.\n\n    Example:\n    words = [\"apple\", \"app\", \"apply\", \"aptitude\"]\n\n    Output:\n    2 (since the longest common prefix is \"ap\")\n    \"\"\"\n    if not words:\n        return 0\n\n    prefix = words[0]\n    for i in range(1, len(words)):\n        while words[i].find(prefix) != 0:\n            prefix = prefix[:-1]\n            if not prefix:\n                return 0\n    return len(prefix)\n\ndef g() -> List[str]:\n    return [\"apple\", \"app\", \"apply\", \"aptitude\"]\n\nassert f(g()) == 2\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 306, "target_skills": [1, 1, 1, 1, 1, 0, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> int:\n    \"\"\"\n    Given a list of words, return the length of the longest common prefix among them.\n\n    Example:\n    words = [\"apple\", \"app\", \"apply\", \"aptitude\"]\n\n    Output:\n    2 (since the longest common prefix is \"ap\")\n    \"\"\"\n    if not words:\n        return 0\n\n    prefix = words[0]\n    for i in range(1, len(words)):\n        while words[i].find(prefix) != 0:\n            prefix = prefix[:-1]\n            if not prefix:\n                return 0\n    return len(prefix)", "solution_func": "def g() -> List[str]:\n    return [\"apple\", \"app\", \"apply\", \"aptitude\"]", "map_ix": [1, 1, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 0 represents an empty cell and 1 represents a wall, find the size of the largest island in the grid. \n    An island is a group of connected cells (horizontally or vertically) with no walls between them.\n\n    Example:\n    grid = [\n        [0, 1, 0, 1, 1],\n        [1, 1, 0, 0, 0],\n        [0, 1, 0, 1, 1],\n        [1, 0, 1, 0, 0]\n    ]\n\n    Output:\n    6 (since the largest island has size 6)\n    \"\"\"\n    if not grid:\n        return 0\n\n    rows, cols = len(grid), len(grid[0])\n    max_island_size = 0\n\n    def dfs(i, j):\n        if i < 0 or i >= rows or j < 0 or j >= cols or grid[i][j] != 1:\n            return 0\n\n        size = 1\n        grid[i][j] = -1\n\n        size += dfs(i + 1, j)\n        size += dfs(i - 1, j)\n        size += dfs(i, j + 1)\n        size += dfs(i, j - 1)\n\n        return size\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                max_island_size = max(max_island_size, dfs(i, j))\n\n    return max_island_size\n\ndef g() -> List[List[int]]:\n    return [\n        [0, 1, 0, 1, 1],\n        [1, 1, 0, 0, 0],\n        [0, 1, 0, 1, 1],\n        [1, 0, 1, 0, 0]\n    ]\n\nassert f(g()) == 6\n\n", "emb": null, "idx_generation": 306, "target_skills": [1, 1, 1, 0, 1, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 0 represents an empty cell and 1 represents a wall, find the size of the largest island in the grid. \n    An island is a group of connected cells (horizontally or vertically) with no walls between them.\n\n    Example:\n    grid = [\n        [0, 1, 0, 1, 1],\n        [1, 1, 0, 0, 0],\n        [0, 1, 0, 1, 1],\n        [1, 0, 1, 0, 0]\n    ]\n\n    Output:\n    6 (since the largest island has size 6)\n    \"\"\"\n    if not grid:\n        return 0\n\n    rows, cols = len(grid), len(grid[0])\n    max_island_size = 0\n\n    def dfs(i, j):\n        if i < 0 or i >= rows or j < 0 or j >= cols or grid[i][j] != 1:\n            return 0\n\n        size = 1\n        grid[i][j] = -1\n\n        size += dfs(i + 1, j)\n        size += dfs(i - 1, j)\n        size += dfs(i, j + 1)\n        size += dfs(i, j - 1)\n\n        return size\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                max_island_size = max(max_island_size, dfs(i, j))\n\n    return max_island_size", "solution_func": "def g() -> List[List[int]]:\n    return [\n        [0, 1, 0, 1, 1],\n        [1, 1, 0, 0, 0],\n        [0, 1, 0, 1, 1],\n        [1, 0, 1, 0, 0]\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer 'n', return the number of unique paths to reach the bottom-right corner of a 'n x n' grid.\n    You can only move either down or right at any point in time.\n\n    Example:\n    n = 3\n\n    Output:\n    6 (since there are 6 unique paths to reach the bottom-right corner)\n    \"\"\"\n    def dfs(i, j):\n        if i == n - 1 and j == n - 1:\n            return 1\n        if i >= n or j >= n:\n            return 0\n\n        return dfs(i + 1, j) + dfs(i, j + 1)\n\n    return dfs(0, 0)\n\ndef g() -> int:\n    return 3\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 306, "target_skills": [0, 1, 1, 1, 1, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer 'n', return the number of unique paths to reach the bottom-right corner of a 'n x n' grid.\n    You can only move either down or right at any point in time.\n\n    Example:\n    n = 3\n\n    Output:\n    6 (since there are 6 unique paths to reach the bottom-right corner)\n    \"\"\"\n    def dfs(i, j):\n        if i == n - 1 and j == n - 1:\n            return 1\n        if i >= n or j >= n:\n            return 0\n\n        return dfs(i + 1, j) + dfs(i, j + 1)\n\n    return dfs(0, 0)", "solution_func": "def g() -> int:\n    return 3", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of ways to arrange n items in a row such that\n    no more than k items are adjacent to each other.\n\n    Example:\n    n = 3, k = 1\n\n    Output:\n    5\n\n    Explanation:\n    There are 5 ways to arrange 3 items in a row such that no more than 1 item is adjacent to each other:\n    [[1, 2, 3], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n    Hint: Use dynamic programming to calculate the number of ways at each position.\n    \"\"\"\n\n    def count_arrangements(n, k):\n        if n == 0:\n            return 1\n        if k == 0:\n            return count_arrangements(n - 1, k)\n        return count_arrangements(n - 1, k) + count_arrangements(n - k, k)\n\n    return count_arrangements(n, k)\n\ndef g(n=3, k=1):\n    return n, k\n\nassert f(*g()) == 5\n", "emb": null, "idx_generation": 306, "target_skills": [0, 1, 1, 1, 0, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of ways to arrange n items in a row such that\n    no more than k items are adjacent to each other.\n\n    Example:\n    n = 3, k = 1\n\n    Output:\n    5\n\n    Explanation:\n    There are 5 ways to arrange 3 items in a row such that no more than 1 item is adjacent to each other:\n    [[1, 2, 3], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n    Hint: Use dynamic programming to calculate the number of ways at each position.\n    \"\"\"\n\n    def count_arrangements(n, k):\n        if n == 0:\n            return 1\n        if k == 0:\n            return count_arrangements(n - 1, k)\n        return count_arrangements(n - 1, k) + count_arrangements(n - k, k)\n\n    return count_arrangements(n, k)", "solution_func": "def g(n=3, k=1):\n    return n, k", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, determine if there is a path from a\n    given start node to a given end node.\n\n    Example:\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 0 to node 3 in the given directed graph.\n\n    Hint: Use depth-first search (DFS) to traverse the graph and check for a path.\n    \"\"\"\n\n    def dfs(graph, visited, current, end):\n        if current == end:\n            return True\n        visited[current] = True\n        for i in range(len(graph)):\n            if graph[current][i] == 1 and not visited[i]:\n                if dfs(graph, visited, i, end):\n                    return True\n        return False\n\n    visited = [False] * len(graph)\n    return dfs(graph, visited, start, end)\n\ndef g(graph=[[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [0, 0, 0, 0]], start=0, end=3):\n    return graph, start, end\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 306, "target_skills": [0, 1, 0, 1, 1, 1, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, determine if there is a path from a\n    given start node to a given end node.\n\n    Example:\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 0 to node 3 in the given directed graph.\n\n    Hint: Use depth-first search (DFS) to traverse the graph and check for a path.\n    \"\"\"\n\n    def dfs(graph, visited, current, end):\n        if current == end:\n            return True\n        visited[current] = True\n        for i in range(len(graph)):\n            if graph[current][i] == 1 and not visited[i]:\n                if dfs(graph, visited, i, end):\n                    return True\n        return False\n\n    visited = [False] * len(graph)\n    return dfs(graph, visited, start, end)", "solution_func": "def g(graph=[[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [0, 0, 0, 0]], start=0, end=3):\n    return graph, start, end", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell\n    by only moving down or right at each step.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    8\n\n    Explanation:\n    The maximum sum of a path from the top-left cell to the bottom-right cell is 8:\n    [[1, 3, 1],\n     [1, 1, 1],\n     [4, 2, 1]]\n\n    Hint: Use dynamic programming to calculate the maximum sum at each cell.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[m - 1][n - 1]\n\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return [grid]\n\nassert f(*g()) == 8\n", "emb": null, "idx_generation": 306, "target_skills": [0, 0, 0, 1, 1, 1, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell\n    by only moving down or right at each step.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    8\n\n    Explanation:\n    The maximum sum of a path from the top-left cell to the bottom-right cell is 8:\n    [[1, 3, 1],\n     [1, 1, 1],\n     [4, 2, 1]]\n\n    Hint: Use dynamic programming to calculate the maximum sum at each cell.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[m - 1][n - 1]", "solution_func": "def g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return [grid]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n    You must write an algorithm with O(log n) runtime complexity.\n\n    Example:\n    nums = [1,3,5,6], target = 5\n    Output: 2\n\n    nums = [1,3,5,6], target = 2\n    Output: 1\n\n    nums = [1,3,5,6], target = 7\n    Output: 4\n\n    nums = [1,3,5,6], target = 0\n    Output: 0\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted array of distinct integers and a target value.\n    \"\"\"\n    nums = [1, 3, 5, 6]\n    target = 5\n    return nums, target\n\n\nassert f(*g()) == 2\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 306, "target_skills": [0, 0, 0, 1, 0, 1, 0, 1, 0, 1], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n    You must write an algorithm with O(log n) runtime complexity.\n\n    Example:\n    nums = [1,3,5,6], target = 5\n    Output: 2\n\n    nums = [1,3,5,6], target = 2\n    Output: 1\n\n    nums = [1,3,5,6], target = 7\n    Output: 4\n\n    nums = [1,3,5,6], target = 0\n    Output: 0\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted array of distinct integers and a target value.\n    \"\"\"\n    nums = [1, 3, 5, 6]\n    target = 5\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given a directed graph, determine if it contains a cycle.\n\n    Example:\n    Input: graph = [[1, 2], [2, 3], [3, 4], [4, 2]]\n    Output: True (The graph contains a cycle: 2 -> 3 -> 4 -> 2)\n    \"\"\"\n    visited = set()\n    stack = set()\n\n    def dfs(node):\n        visited.add(node)\n        stack.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor in stack:\n                return True\n            if neighbor not in visited and dfs(neighbor):\n                return True\n\n        stack.remove(node)\n        return False\n\n    for node in range(len(graph)):\n        if node not in visited and dfs(node):\n            return True\n\n    return False\n\ndef g(graph=[[1, 2], [2, 3], [3, 4], [4, 2]]):\n    return (graph,)\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 307, "target_skills": [0, 0, 1, 0, 1, 1, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given a directed graph, determine if it contains a cycle.\n\n    Example:\n    Input: graph = [[1, 2], [2, 3], [3, 4], [4, 2]]\n    Output: True (The graph contains a cycle: 2 -> 3 -> 4 -> 2)\n    \"\"\"\n    visited = set()\n    stack = set()\n\n    def dfs(node):\n        visited.add(node)\n        stack.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor in stack:\n                return True\n            if neighbor not in visited and dfs(neighbor):\n                return True\n\n        stack.remove(node)\n        return False\n\n    for node in range(len(graph)):\n        if node not in visited and dfs(node):\n            return True\n\n    return False", "solution_func": "def g(graph=[[1, 2], [2, 3], [3, 4], [4, 2]]):\n    return (graph,)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum subarray sum.\n\n    Example:\n    Input: arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6 (The maximum subarray sum is [4, -1, 2, 1])\n\n    Note: The solution should have a time complexity of O(n) using Kadane's algorithm.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in arr:\n        curr_sum += num\n        if curr_sum > max_sum:\n            max_sum = curr_sum\n        if curr_sum < 0:\n            curr_sum = 0\n\n    return max_sum\n\ndef g(arr=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return (arr,)\n\nassert f(*g()) == 6\n", "emb": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "idx_generation": 307, "target_skills": [0, 1, 1, 0, 1, 1, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum subarray sum.\n\n    Example:\n    Input: arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6 (The maximum subarray sum is [4, -1, 2, 1])\n\n    Note: The solution should have a time complexity of O(n) using Kadane's algorithm.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in arr:\n        curr_sum += num\n        if curr_sum > max_sum:\n            max_sum = curr_sum\n        if curr_sum < 0:\n            curr_sum = 0\n\n    return max_sum", "solution_func": "def g(arr=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return (arr,)", "map_ix": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix, rotate it 90 degrees clockwise.\n\n    Example:\n    Input: matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    Output: [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n    \"\"\"\n    n = len(matrix)\n\n    # Transpose the matrix\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n    # Reverse each row\n    for i in range(n):\n        matrix[i] = matrix[i][::-1]\n\n    return matrix\n\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return (matrix,)\n\nassert f(*g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n", "emb": null, "idx_generation": 307, "target_skills": [1, 0, 0, 1, 0, 0, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix, rotate it 90 degrees clockwise.\n\n    Example:\n    Input: matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    Output: [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n    \"\"\"\n    n = len(matrix)\n\n    # Transpose the matrix\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n    # Reverse each row\n    for i in range(n):\n        matrix[i] = matrix[i][::-1]\n\n    return matrix", "solution_func": "def g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return (matrix,)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of all the even numbers in the original list that are greater than or equal to the current element.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: [6, 6, 6, 4, 0]\n    Explanation: \n    - For the first element, the even numbers are [2, 4]. Their sum is 6.\n    - For the second element, the even numbers are [2, 4]. Their sum is 6.\n    - For the third element, the even numbers are [2, 4]. Their sum is 6.\n    - For the fourth element, the even numbers are [4]. Their sum is 4.\n    - For the fifth element, there are no even numbers. Their sum is 0.\n    \"\"\"\n    even_nums = [x for x in nums if x % 2 == 0]\n    result = []\n    for i in range(len(nums)):\n        current_sum = sum(x for x in even_nums if x >= nums[i])\n        result.append(current_sum)\n    return result\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == [6, 6, 6, 4, 0]\n", "emb": null, "idx_generation": 307, "target_skills": [1, 1, 1, 0, 0, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of all the even numbers in the original list that are greater than or equal to the current element.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: [6, 6, 6, 4, 0]\n    Explanation: \n    - For the first element, the even numbers are [2, 4]. Their sum is 6.\n    - For the second element, the even numbers are [2, 4]. Their sum is 6.\n    - For the third element, the even numbers are [2, 4]. Their sum is 6.\n    - For the fourth element, the even numbers are [4]. Their sum is 4.\n    - For the fifth element, there are no even numbers. Their sum is 0.\n    \"\"\"\n    even_nums = [x for x in nums if x % 2 == 0]\n    result = []\n    for i in range(len(nums)):\n        current_sum = sum(x for x in even_nums if x >= nums[i])\n        result.append(current_sum)\n    return result", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency matrix and two nodes (start and end), determine if there is a path from start to end in the graph.\n\n    Example:\n    Input:\n    graph = [[0, 1, 0, 0],\n             [0, 0, 1, 0],\n             [1, 0, 0, 1],\n             [0, 0, 0, 0]]\n    start = 0\n    end = 3\n\n    Output: True\n    Explanation: There is a path from node 0 to node 3: 0 -> 1 -> 2 -> 3.\n    \"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        current = stack.pop()\n        visited.add(current)\n        if current == end:\n            return True\n        for neighbor in range(len(graph[current])):\n            if graph[current][neighbor] == 1 and neighbor not in visited:\n                stack.append(neighbor)\n    return False\n\ndef g() -> Tuple[List[List[int]], int, int]:\n    graph = [[0, 1, 0, 0],\n             [0, 0, 1, 0],\n             [1, 0, 0, 1],\n             [0, 0, 0, 0]]\n    start = 0\n    end = 3\n    return graph, start, end\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 307, "target_skills": [0, 0, 1, 1, 1, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency matrix and two nodes (start and end), determine if there is a path from start to end in the graph.\n\n    Example:\n    Input:\n    graph = [[0, 1, 0, 0],\n             [0, 0, 1, 0],\n             [1, 0, 0, 1],\n             [0, 0, 0, 0]]\n    start = 0\n    end = 3\n\n    Output: True\n    Explanation: There is a path from node 0 to node 3: 0 -> 1 -> 2 -> 3.\n    \"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        current = stack.pop()\n        visited.add(current)\n        if current == end:\n            return True\n        for neighbor in range(len(graph[current])):\n            if graph[current][neighbor] == 1 and neighbor not in visited:\n                stack.append(neighbor)\n    return False", "solution_func": "def g() -> Tuple[List[List[int]], int, int]:\n    graph = [[0, 1, 0, 0],\n             [0, 0, 1, 0],\n             [1, 0, 0, 1],\n             [0, 0, 0, 0]]\n    start = 0\n    end = 3\n    return graph, start, end", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(num1: int, num2: int) -> int:\n    \"\"\"\n    Given two integers, return the maximum XOR value of any two integers in the range [num1, num2].\n\n    Example:\n    Input: num1 = 2, num2 = 5\n    Output: 7\n    Explanation: The maximum XOR value can be obtained by taking the XOR of 5 and 2, which is 7.\n    \"\"\"\n    max_xor = 0\n    for i in range(num1, num2+1):\n        for j in range(i, num2+1):\n            xor = i ^ j\n            max_xor = max(max_xor, xor)\n    return max_xor\n\ndef g() -> Tuple[int, int]:\n    num1 = 2\n    num2 = 5\n    return num1, num2\n\nassert f(*g()) == 7\n", "emb": [1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0], "idx_generation": 307, "target_skills": [0, 1, 1, 1, 1, 0, 1, 0, 0, 0], "problem_func": "from typing import*\ndef f(num1: int, num2: int) -> int:\n    \"\"\"\n    Given two integers, return the maximum XOR value of any two integers in the range [num1, num2].\n\n    Example:\n    Input: num1 = 2, num2 = 5\n    Output: 7\n    Explanation: The maximum XOR value can be obtained by taking the XOR of 5 and 2, which is 7.\n    \"\"\"\n    max_xor = 0\n    for i in range(num1, num2+1):\n        for j in range(i, num2+1):\n            xor = i ^ j\n            max_xor = max(max_xor, xor)\n    return max_xor", "solution_func": "def g() -> Tuple[int, int]:\n    num1 = 2\n    num2 = 5\n    return num1, num2", "map_ix": [1, 1, 0, 1, 1, 1, 1, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value, determine if there are two numbers in the array that add up to the target value.\n    \n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    \n    Output:\n    True (3 + 4 = 7)\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        current_sum = arr[left] + arr[right]\n        \n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g() -> Tuple[List[int], int]:\n    return [1, 2, 3, 4, 5], 7\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 307, "target_skills": [1, 1, 1, 1, 1, 1, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value, determine if there are two numbers in the array that add up to the target value.\n    \n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    \n    Output:\n    True (3 + 4 = 7)\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        current_sum = arr[left] + arr[right]\n        \n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False", "solution_func": "def g() -> Tuple[List[int], int]:\n    return [1, 2, 3, 4, 5], 7", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers, sort the array using the bubble sort algorithm.\n    \n    Example:\n    arr = [5, 2, 8, 1, 3]\n    \n    Output:\n    [1, 2, 3, 5, 8]\n    \"\"\"\n    n = len(arr)\n    \n    for i in range(n):\n        for j in range(n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n    \n    return arr\n\ndef g() -> List[int]:\n    return [5, 2, 8, 1, 3]\n\nassert f(g()) == [1, 2, 3, 5, 8]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 307, "target_skills": [1, 0, 1, 0, 1, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers, sort the array using the bubble sort algorithm.\n    \n    Example:\n    arr = [5, 2, 8, 1, 3]\n    \n    Output:\n    [1, 2, 3, 5, 8]\n    \"\"\"\n    n = len(arr)\n    \n    for i in range(n):\n        for j in range(n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n    \n    return arr", "solution_func": "def g() -> List[int]:\n    return [5, 2, 8, 1, 3]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value, determine if the target is present in the array using binary search.\n    \n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 3\n    \n    Output:\n    True\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        \n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return False\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5], 3\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 307, "target_skills": [0, 1, 0, 1, 0, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value, determine if the target is present in the array using binary search.\n    \n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 3\n    \n    Output:\n    True\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        \n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return False", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3, 4, 5], 3", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers, find two numbers such that they add up to a specific target number.\n    Return the indices of the two numbers in ascending order.\n\n    Args:\n    - nums: The sorted array of integers.\n    - target: The target number.\n\n    Returns:\n    - A list of two numbers that add up to the target number.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        sum = nums[left] + nums[right]\n        if sum == target:\n            return [left, right]\n        elif sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate the input array and target number for the function f.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 10\n    return nums, target\n\nassert f(*g()) == [0, 8]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 307, "target_skills": [0, 1, 1, 0, 0, 0, 0, 0, 0, 1], "problem_func": "from typing import*\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers, find two numbers such that they add up to a specific target number.\n    Return the indices of the two numbers in ascending order.\n\n    Args:\n    - nums: The sorted array of integers.\n    - target: The target number.\n\n    Returns:\n    - A list of two numbers that add up to the target number.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        sum = nums[left] + nums[right]\n        if sum == target:\n            return [left, right]\n        elif sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate the input array and target number for the function f.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 10\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort them in non-decreasing order using bit manipulation.\n\n    Example:\n    f([3, 1, 5, 2, 4]) returns [1, 2, 3, 4, 5].\n\n    Note:\n    - The input list can contain duplicate numbers.\n    \"\"\"\n\n    # Convert the list elements to binary strings\n    binary_nums = [bin(num)[2:] for num in nums]\n\n    # Sort the binary strings based on their length and then their values\n    sorted_binary_nums = sorted(binary_nums, key=lambda x: (len(x), x))\n\n    # Convert the binary strings back to integers\n    sorted_nums = [int(binary, 2) for binary in sorted_binary_nums]\n\n    return sorted_nums\n\n\ndef g(nums: List[int] = [3, 1, 5, 2, 4]) -> List[int]:\n    \"\"\"\n    Generate a list of positive integers.\n\n    Example:\n    g() returns [3, 1, 5, 2, 4].\n\n    Note:\n    - The input list can contain duplicate numbers.\n    \"\"\"\n\n    return nums\n\n\nassert f(g()) == [1, 2, 3, 4, 5]\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 308, "target_skills": [1, 0, 0, 1, 1, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort them in non-decreasing order using bit manipulation.\n\n    Example:\n    f([3, 1, 5, 2, 4]) returns [1, 2, 3, 4, 5].\n\n    Note:\n    - The input list can contain duplicate numbers.\n    \"\"\"\n\n    # Convert the list elements to binary strings\n    binary_nums = [bin(num)[2:] for num in nums]\n\n    # Sort the binary strings based on their length and then their values\n    sorted_binary_nums = sorted(binary_nums, key=lambda x: (len(x), x))\n\n    # Convert the binary strings back to integers\n    sorted_nums = [int(binary, 2) for binary in sorted_binary_nums]\n\n    return sorted_nums", "solution_func": "def g(nums: List[int] = [3, 1, 5, 2, 4]) -> List[int]:\n    \"\"\"\n    Generate a list of positive integers.\n\n    Example:\n    g() returns [3, 1, 5, 2, 4].\n\n    Note:\n    - The input list can contain duplicate numbers.\n    \"\"\"\n\n    return nums", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> float:\n    \"\"\"\n    Given a list of 2D points, find the closest pair of points using the Euclidean distance formula.\n\n    Example:\n    f([[1, 2], [3, 4], [5, 6], [7, 8]]) returns 2.8284271247461903, as the closest pair of points is [3, 4] and [5, 6].\n\n    Note:\n    - The input list can contain duplicate points.\n    \"\"\"\n\n    # Calculate the Euclidean distance between each pair of points\n    min_distance = float('inf')\n\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            distance = ((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) ** 0.5\n            if distance < min_distance:\n                min_distance = distance\n\n    return min_distance\n\n\ndef g(points: List[List[int]] = [[1, 2], [3, 4], [5, 6], [7, 8]]) -> List[List[int]]:\n    \"\"\"\n    Generate a list of 2D points.\n\n    Example:\n    g() returns [[1, 2], [3, 4], [5, 6], [7, 8]].\n\n    Note:\n    - The input list can contain duplicate points.\n    \"\"\"\n\n    return points\n\n\nassert f(g()) == 2.8284271247461903\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], "idx_generation": 308, "target_skills": [1, 0, 1, 0, 1, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> float:\n    \"\"\"\n    Given a list of 2D points, find the closest pair of points using the Euclidean distance formula.\n\n    Example:\n    f([[1, 2], [3, 4], [5, 6], [7, 8]]) returns 2.8284271247461903, as the closest pair of points is [3, 4] and [5, 6].\n\n    Note:\n    - The input list can contain duplicate points.\n    \"\"\"\n\n    # Calculate the Euclidean distance between each pair of points\n    min_distance = float('inf')\n\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            distance = ((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) ** 0.5\n            if distance < min_distance:\n                min_distance = distance\n\n    return min_distance", "solution_func": "def g(points: List[List[int]] = [[1, 2], [3, 4], [5, 6], [7, 8]]) -> List[List[int]]:\n    \"\"\"\n    Generate a list of 2D points.\n\n    Example:\n    g() returns [[1, 2], [3, 4], [5, 6], [7, 8]].\n\n    Note:\n    - The input list can contain duplicate points.\n    \"\"\"\n\n    return points", "map_ix": [0, 0, 0, 1, 0, 0, 1, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target sum, find the number of unique combinations that add up to the target sum\n    using dynamic programming.\n\n    Example:\n    f([1, 2, 3, 4], 5) returns 3, as there are 3 unique combinations ([1, 1, 1, 1, 1], [1, 1, 1, 2], [1, 2, 2]) that add up to 5.\n\n    Note:\n    - The input list can contain duplicate numbers.\n    \"\"\"\n\n    # Initialize a dynamic programming table\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for num in nums:\n        for i in range(num, target + 1):\n            dp[i] += dp[i - num]\n\n    return dp[target]\n\n\ndef g(nums: List[int] = [1, 2, 3, 4], target: int = 5) -> List[int]:\n    \"\"\"\n    Generate a list of positive integers and a target sum.\n\n    Example:\n    g() returns ([1, 2, 3, 4], 5).\n\n    Note:\n    - The input list can contain duplicate numbers.\n    \"\"\"\n\n    return nums, target\n\n\nassert f(*g()) == 3\n", "emb": null, "idx_generation": 308, "target_skills": [1, 1, 0, 0, 0, 0, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target sum, find the number of unique combinations that add up to the target sum\n    using dynamic programming.\n\n    Example:\n    f([1, 2, 3, 4], 5) returns 3, as there are 3 unique combinations ([1, 1, 1, 1, 1], [1, 1, 1, 2], [1, 2, 2]) that add up to 5.\n\n    Note:\n    - The input list can contain duplicate numbers.\n    \"\"\"\n\n    # Initialize a dynamic programming table\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for num in nums:\n        for i in range(num, target + 1):\n            dp[i] += dp[i - num]\n\n    return dp[target]", "solution_func": "def g(nums: List[int] = [1, 2, 3, 4], target: int = 5) -> List[int]:\n    \"\"\"\n    Generate a list of positive integers and a target sum.\n\n    Example:\n    g() returns ([1, 2, 3, 4], 5).\n\n    Note:\n    - The input list can contain duplicate numbers.\n    \"\"\"\n\n    return nums, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers, find two numbers in the array that sum up to a given target value.\n    Return the indices of the two numbers in the array.\n\n    Example:\n    arr = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1, i.e. 2 and 7, sum up to 9.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g() -> List[int]:\n    arr = [2, 7, 11, 15]\n    target = 9\n    return arr, target\n\nassert f(*g()) == [0, 1]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 308, "target_skills": [0, 1, 0, 0, 0, 1, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers, find two numbers in the array that sum up to a given target value.\n    Return the indices of the two numbers in the array.\n\n    Example:\n    arr = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1, i.e. 2 and 7, sum up to 9.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []", "solution_func": "def g() -> List[int]:\n    arr = [2, 7, 11, 15]\n    target = 9\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters representing a word search puzzle and a target word, determine if the word exists in the grid.\n    The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring.\n    The same letter cell may not be used more than once.\n\n    Return the number of occurrences of the target word in the grid.\n\n    Example:\n    grid = [['A','B','C','E'],\n            ['S','F','C','S'],\n            ['A','D','E','E']]\n    word = \"ABCCED\"\n\n    Output:\n    1\n\n    Explanation:\n    The target word \"ABCCED\" exists in the grid.\n\n    Hint: Use backtracking to explore all possible paths in the grid and check if the current letter matches the corresponding letter in the target word.\n    \"\"\"\n    if not grid or not grid[0]:\n        return 0\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    count = 0\n    \n    def backtrack(row, col, index):\n        if index == len(word):\n            return True\n        \n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] != word[index]:\n            return False\n        \n        temp = grid[row][col]\n        grid[row][col] = \"\"\n        \n        found = backtrack(row+1, col, index+1) \\\n                or backtrack(row-1, col, index+1) \\\n                or backtrack(row, col+1, index+1) \\\n                or backtrack(row, col-1, index+1)\n        \n        grid[row][col] = temp\n        return found\n    \n    for row in range(rows):\n        for col in range(cols):\n            if grid[row][col] == word[0] and backtrack(row, col, 0):\n                count += 1\n    \n    return count\n\ndef g():\n    grid = [['A','B','C','E'],\n            ['S','F','C','S'],\n            ['A','D','E','E']]\n    word = \"ABCCED\"\n    return grid, word\n\nassert f(*g()) == 1\n\n", "emb": null, "idx_generation": 308, "target_skills": [0, 1, 0, 1, 1, 0, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters representing a word search puzzle and a target word, determine if the word exists in the grid.\n    The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring.\n    The same letter cell may not be used more than once.\n\n    Return the number of occurrences of the target word in the grid.\n\n    Example:\n    grid = [['A','B','C','E'],\n            ['S','F','C','S'],\n            ['A','D','E','E']]\n    word = \"ABCCED\"\n\n    Output:\n    1\n\n    Explanation:\n    The target word \"ABCCED\" exists in the grid.\n\n    Hint: Use backtracking to explore all possible paths in the grid and check if the current letter matches the corresponding letter in the target word.\n    \"\"\"\n    if not grid or not grid[0]:\n        return 0\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    count = 0\n    \n    def backtrack(row, col, index):\n        if index == len(word):\n            return True\n        \n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] != word[index]:\n            return False\n        \n        temp = grid[row][col]\n        grid[row][col] = \"\"\n        \n        found = backtrack(row+1, col, index+1) \\\n                or backtrack(row-1, col, index+1) \\\n                or backtrack(row, col+1, index+1) \\\n                or backtrack(row, col-1, index+1)\n        \n        grid[row][col] = temp\n        return found\n    \n    for row in range(rows):\n        for col in range(cols):\n            if grid[row][col] == word[0] and backtrack(row, col, 0):\n                count += 1\n    \n    return count", "solution_func": "def g():\n    grid = [['A','B','C','E'],\n            ['S','F','C','S'],\n            ['A','D','E','E']]\n    word = \"ABCCED\"\n    return grid, word", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the single number that appears only once while all the other numbers appear twice.\n\n    Example:\n    nums = [2, 2, 1, 3, 3]\n\n    Output:\n    1\n\n    Explanation:\n    The number 1 appears only once in the array, while 2 and 3 appear twice.\n    \"\"\"\n    result = 0\n    \n    for num in nums:\n        result ^= num\n    \n    return result\n\ndef g() -> List[int]:\n    nums = [2, 2, 1, 3, 3]\n    return nums\n\nassert f(g()) == 1\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 308, "target_skills": [1, 0, 1, 1, 1, 1, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the single number that appears only once while all the other numbers appear twice.\n\n    Example:\n    nums = [2, 2, 1, 3, 3]\n\n    Output:\n    1\n\n    Explanation:\n    The number 1 appears only once in the array, while 2 and 3 appear twice.\n    \"\"\"\n    result = 0\n    \n    for num in nums:\n        result ^= num\n    \n    return result", "solution_func": "def g() -> List[int]:\n    nums = [2, 2, 1, 3, 3]\n    return nums", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, return all possible permutations of the numbers.\n\n    Example:\n    nums = [1, 2, 3]\n\n    Output:\n    [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n    Hint: Use backtracking to generate all possible permutations.\n    \"\"\"\n    def backtrack(nums: List[int], perm: List[int], result: List[List[int]]) -> None:\n        if len(perm) == len(nums):\n            result.append(perm[:])\n            return\n        \n        for num in nums:\n            if num in perm:\n                continue\n            perm.append(num)\n            backtrack(nums, perm, result)\n            perm.pop()\n\n    result = []\n    backtrack(nums, [], result)\n    return result\n\n\ndef g(nums=[1, 2, 3]):\n    return (nums,)\n\n\nassert f(*g()) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 308, "target_skills": [0, 0, 1, 0, 1, 1, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, return all possible permutations of the numbers.\n\n    Example:\n    nums = [1, 2, 3]\n\n    Output:\n    [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n    Hint: Use backtracking to generate all possible permutations.\n    \"\"\"\n    def backtrack(nums: List[int], perm: List[int], result: List[List[int]]) -> None:\n        if len(perm) == len(nums):\n            result.append(perm[:])\n            return\n        \n        for num in nums:\n            if num in perm:\n                continue\n            perm.append(num)\n            backtrack(nums, perm, result)\n            perm.pop()\n\n    result = []\n    backtrack(nums, [], result)\n    return result", "solution_func": "def g(nums=[1, 2, 3]):\n    return (nums,)", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the length of the largest island (connected component) in the grid.\n    An island is a group of 1s connected horizontally or vertically.\n\n    Example:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 1, 1, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 1, 1]\n    ]\n\n    Output:\n    8\n\n    Hint: Use depth-first search (DFS) to explore the grid and count the size of each island.\n    \"\"\"\n    def dfs(grid: List[List[int]], row: int, col: int, visited: List[List[bool]]) -> int:\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or visited[row][col] or grid[row][col] == 0:\n            return 0\n        \n        visited[row][col] = True\n        size = 1\n\n        size += dfs(grid, row + 1, col, visited)\n        size += dfs(grid, row - 1, col, visited)\n        size += dfs(grid, row, col + 1, visited)\n        size += dfs(grid, row, col - 1, visited)\n\n        return size\n\n    max_size = 0\n    visited = [[False] * len(grid[0]) for _ in range(len(grid))]\n\n    for row in range(len(grid)):\n        for col in range(len(grid[0])):\n            if grid[row][col] == 1 and not visited[row][col]:\n                max_size = max(max_size, dfs(grid, row, col, visited))\n\n    return max_size\n\n\ndef g(grid=[[1, 1, 0, 0, 0], [1, 1, 1, 1, 0], [0, 0, 0, 1, 0], [0, 0, 0, 1, 1]]):\n    return (grid,)\n\n\nassert f(*g()) == 8\n", "emb": null, "idx_generation": 308, "target_skills": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the length of the largest island (connected component) in the grid.\n    An island is a group of 1s connected horizontally or vertically.\n\n    Example:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 1, 1, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 1, 1]\n    ]\n\n    Output:\n    8\n\n    Hint: Use depth-first search (DFS) to explore the grid and count the size of each island.\n    \"\"\"\n    def dfs(grid: List[List[int]], row: int, col: int, visited: List[List[bool]]) -> int:\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or visited[row][col] or grid[row][col] == 0:\n            return 0\n        \n        visited[row][col] = True\n        size = 1\n\n        size += dfs(grid, row + 1, col, visited)\n        size += dfs(grid, row - 1, col, visited)\n        size += dfs(grid, row, col + 1, visited)\n        size += dfs(grid, row, col - 1, visited)\n\n        return size\n\n    max_size = 0\n    visited = [[False] * len(grid[0]) for _ in range(len(grid))]\n\n    for row in range(len(grid)):\n        for col in range(len(grid[0])):\n            if grid[row][col] == 1 and not visited[row][col]:\n                max_size = max(max_size, dfs(grid, row, col, visited))\n\n    return max_size", "solution_func": "def g(grid=[[1, 1, 0, 0, 0], [1, 1, 1, 1, 0], [0, 0, 0, 1, 0], [0, 0, 0, 1, 1]]):\n    return (grid,)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth number in the Fibonacci sequence.\n\n    Example:\n    n = 6\n\n    Output:\n    8\n\n    Hint: Use dynamic programming to store previously calculated Fibonacci numbers.\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    fib = [0] * (n + 1)\n    fib[1] = 1\n\n    for i in range(2, n + 1):\n        fib[i] = fib[i - 1] + fib[i - 2]\n\n    return fib[n]\n\n\ndef g(n=6):\n    return (n,)\n\n\nassert f(*g()) == 8\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 308, "target_skills": [1, 0, 0, 0, 1, 0, 0, 1, 1, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth number in the Fibonacci sequence.\n\n    Example:\n    n = 6\n\n    Output:\n    8\n\n    Hint: Use dynamic programming to store previously calculated Fibonacci numbers.\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    fib = [0] * (n + 1)\n    fib[1] = 1\n\n    for i in range(2, n + 1):\n        fib[i] = fib[i - 1] + fib[i - 2]\n\n    return fib[n]", "solution_func": "def g(n=6):\n    return (n,)", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, find the longest word that can be formed by concatenating other words in the list.\n    If there are multiple longest words, return them in lexicographical order.\n\n    Args:\n    - words: A list of strings.\n\n    Returns:\n    - A list of longest words that can be formed by concatenating other words in the list.\n    \"\"\"\n    def is_concatenated(word: str, words: List[str]) -> bool:\n        if word in memo:\n            return memo[word]\n\n        if word == '':\n            return True\n\n        for i in range(1, len(word) + 1):\n            prefix = word[:i]\n            suffix = word[i:]\n\n            if prefix in words and is_concatenated(suffix, words):\n                memo[word] = True\n                return True\n\n        memo[word] = False\n        return False\n\n    longest = 0\n    longest_words = []\n    memo = {}\n\n    for word in words:\n        if is_concatenated(word, words):\n            if len(word) > longest:\n                longest = len(word)\n                longest_words = [word]\n            elif len(word) == longest:\n                longest_words.append(word)\n\n    return sorted(longest_words)\n\ndef g():\n    words = [\"cat\", \"cats\", \"catsdogcats\", \"dog\", \"dogcatsdog\", \"hippopotamuses\", \"rat\", \"ratcatdogcat\"]\n    return words\n\nassert f(g()) == ['catsdogcats', 'dogcatsdog', 'ratcatdogcat']\n\n", "emb": null, "idx_generation": 308, "target_skills": [1, 1, 0, 0, 0, 1, 0, 1, 1, 1], "problem_func": "from typing import*\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, find the longest word that can be formed by concatenating other words in the list.\n    If there are multiple longest words, return them in lexicographical order.\n\n    Args:\n    - words: A list of strings.\n\n    Returns:\n    - A list of longest words that can be formed by concatenating other words in the list.\n    \"\"\"\n    def is_concatenated(word: str, words: List[str]) -> bool:\n        if word in memo:\n            return memo[word]\n\n        if word == '':\n            return True\n\n        for i in range(1, len(word) + 1):\n            prefix = word[:i]\n            suffix = word[i:]\n\n            if prefix in words and is_concatenated(suffix, words):\n                memo[word] = True\n                return True\n\n        memo[word] = False\n        return False\n\n    longest = 0\n    longest_words = []\n    memo = {}\n\n    for word in words:\n        if is_concatenated(word, words):\n            if len(word) > longest:\n                longest = len(word)\n                longest_words = [word]\n            elif len(word) == longest:\n                longest_words.append(word)\n\n    return sorted(longest_words)", "solution_func": "def g():\n    words = [\"cat\", \"cats\", \"catsdogcats\", \"dog\", \"dogcatsdog\", \"hippopotamuses\", \"rat\", \"ratcatdogcat\"]\n    return words", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str, target=10) -> bool:\n    \"\"\"\n    Given a string s containing only digits, determine if it is possible to split the string into two non-empty parts\n    such that the sum of the digits in each part is equal to the target.\n\n    Sample Input:\n    `\"12345\"`\n\n    Sample Output:\n    `True`\n    \"\"\"\n    n = len(s)\n    total = sum(int(d) for d in s)\n\n    if total % 2 != 0:\n        return False\n\n    target_sum = total // 2\n    dp = [[False] * (target_sum + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(target_sum + 1):\n            if j < int(s[i - 1]):\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - int(s[i - 1])]\n\n    return dp[n][target_sum]\n\ndef g(s=\"12345\", target=10):\n    # target is ignored\n    return s\n\nassert f(g())\n", "emb": null, "idx_generation": 309, "target_skills": [0, 1, 0, 1, 1, 1, 0, 0, 0, 1], "problem_func": "from typing import*\ndef f(s: str, target=10) -> bool:\n    \"\"\"\n    Given a string s containing only digits, determine if it is possible to split the string into two non-empty parts\n    such that the sum of the digits in each part is equal to the target.\n\n    Sample Input:\n    `\"12345\"`\n\n    Sample Output:\n    `True`\n    \"\"\"\n    n = len(s)\n    total = sum(int(d) for d in s)\n\n    if total % 2 != 0:\n        return False\n\n    target_sum = total // 2\n    dp = [[False] * (target_sum + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(target_sum + 1):\n            if j < int(s[i - 1]):\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - int(s[i - 1])]\n\n    return dp[n][target_sum]", "solution_func": "def g(s=\"12345\", target=10):\n    # target is ignored\n    return s", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, nums: List[int]) -> bool:\n    \"\"\"\n    Given an integer n and a list of integers nums, determine if it is possible to partition the list into two\n    non-empty parts such that the sum of the elements in each part is equal.\n\n    Sample Input:\n    `n = 5`\n    `nums = [1, 5, 11, 5]`\n\n    Sample Output:\n    `True`\n    \"\"\"\n    total = sum(nums)\n\n    if total % 2 != 0:\n        return False\n\n    target_sum = total // 2\n    dp = [[False] * (target_sum + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(target_sum + 1):\n            if j < nums[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n\n    return dp[n][target_sum]\n\ndef g(n=5, nums=[1, 5, 11, 5]):\n    # n is ignored\n    return nums\n\nassert f(g())\n", "emb": null, "idx_generation": 309, "target_skills": [1, 1, 0, 1, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int, nums: List[int]) -> bool:\n    \"\"\"\n    Given an integer n and a list of integers nums, determine if it is possible to partition the list into two\n    non-empty parts such that the sum of the elements in each part is equal.\n\n    Sample Input:\n    `n = 5`\n    `nums = [1, 5, 11, 5]`\n\n    Sample Output:\n    `True`\n    \"\"\"\n    total = sum(nums)\n\n    if total % 2 != 0:\n        return False\n\n    target_sum = total // 2\n    dp = [[False] * (target_sum + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(target_sum + 1):\n            if j < nums[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n\n    return dp[n][target_sum]", "solution_func": "def g(n=5, nums=[1, 5, 11, 5]):\n    # n is ignored\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(arr: List[int], target=7) -> bool:\n    \"\"\"\n    Given a list of integers arr, determine if it is possible to select a subset of the integers such that the sum of\n    the selected integers is equal to the target.\n\n    Sample Input:\n    `arr = [3, 1, 5, 9, 12]`\n\n    Sample Output:\n    `True`\n    \"\"\"\n    n = len(arr)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(target + 1):\n            if j < arr[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n\n    return dp[n][target]\n\ndef g(arr=[3, 1, 5, 9, 12], target=7):\n    # target is ignored\n    return arr\n\nassert f(g())\n", "emb": null, "idx_generation": 309, "target_skills": [1, 0, 1, 1, 1, 1, 0, 1, 0, 1], "problem_func": "from typing import*\ndef f(arr: List[int], target=7) -> bool:\n    \"\"\"\n    Given a list of integers arr, determine if it is possible to select a subset of the integers such that the sum of\n    the selected integers is equal to the target.\n\n    Sample Input:\n    `arr = [3, 1, 5, 9, 12]`\n\n    Sample Output:\n    `True`\n    \"\"\"\n    n = len(arr)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(target + 1):\n            if j < arr[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n\n    return dp[n][target]", "solution_func": "def g(arr=[3, 1, 5, 9, 12], target=7):\n    # target is ignored\n    return arr", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there are k integers in the list that\n    sum up to the target value. Return True if such k-sums exist, otherwise return False.\n\n    Example:\n    arr = [1, 4, 2, 8, 3, 5]\n    target = 10\n    k = 3\n\n    Output:\n    True\n\n    Explanation:\n    The triplets [1, 2, 7] and [4, 3, 3] sum up to the target value 10.\n\n    Hint: Use a combination of sorting, searching, and counting techniques to find the k-sums.\n    \"\"\"\n    arr.sort()\n    return find_k_sum(arr, target, k)\n\ndef find_k_sum(arr: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Helper function to find if there are k integers in the list that sum up to the target value.\n    \"\"\"\n    if k == 0:\n        return target == 0\n    if k == 1:\n        return target in arr\n    for i in range(len(arr) - k + 1):\n        if i > 0 and arr[i] == arr[i - 1]:\n            continue\n        if find_k_sum(arr[i + 1:], target - arr[i], k - 1):\n            return True\n    return False\n\ndef g(arr=[1, 4, 2, 8, 3, 5], target=10, k=3):\n    return arr, target, k\n\nassert f(*g()) == True\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 309, "target_skills": [0, 0, 0, 0, 1, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there are k integers in the list that\n    sum up to the target value. Return True if such k-sums exist, otherwise return False.\n\n    Example:\n    arr = [1, 4, 2, 8, 3, 5]\n    target = 10\n    k = 3\n\n    Output:\n    True\n\n    Explanation:\n    The triplets [1, 2, 7] and [4, 3, 3] sum up to the target value 10.\n\n    Hint: Use a combination of sorting, searching, and counting techniques to find the k-sums.\n    \"\"\"\n    arr.sort()\n    return find_k_sum(arr, target, k)\n\ndef find_k_sum(arr: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Helper function to find if there are k integers in the list that sum up to the target value.\n    \"\"\"\n    if k == 0:\n        return target == 0\n    if k == 1:\n        return target in arr\n    for i in range(len(arr) - k + 1):\n        if i > 0 and arr[i] == arr[i - 1]:\n            continue\n        if find_k_sum(arr[i + 1:], target - arr[i], k - 1):\n            return True\n    return False", "solution_func": "def g(arr=[1, 4, 2, 8, 3, 5], target=10, k=3):\n    return arr, target, k", "map_ix": [1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, determine the number of distinct prime factors of n.\n\n    Example:\n    n = 36\n\n    Output:\n    2\n\n    Explanation:\n    The distinct prime factors of 36 are 2 and 3.\n\n    Hint: Use prime factorization and counting techniques to solve the problem.\n    \"\"\"\n    if n < 2:\n        return 0\n    count = 0\n    for i in range(2, n + 1):\n        if n % i == 0:\n            count += 1\n            while n % i == 0:\n                n //= i\n    return count\n\ndef g(n=36):\n    return n\n\nassert f(g()) == 2\n", "emb": [0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 309, "target_skills": [1, 1, 0, 1, 1, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, determine the number of distinct prime factors of n.\n\n    Example:\n    n = 36\n\n    Output:\n    2\n\n    Explanation:\n    The distinct prime factors of 36 are 2 and 3.\n\n    Hint: Use prime factorization and counting techniques to solve the problem.\n    \"\"\"\n    if n < 2:\n        return 0\n    count = 0\n    for i in range(2, n + 1):\n        if n % i == 0:\n            count += 1\n            while n % i == 0:\n                n //= i\n    return count", "solution_func": "def g(n=36):\n    return n", "map_ix": [0, 1, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, determine the number of pairs of integers in the list that have a difference of exactly 1.\n\n    Example:\n    arr = [1, 4, 2, 8, 3, 5]\n\n    Output:\n    4\n\n    Explanation:\n    The pairs with a difference of 1 are (1, 2), (1, 3), (4, 5), and (8, 9).\n\n    Hint: Use sorting and counting techniques to find the pairs.\n    \"\"\"\n    arr.sort()\n    count = 0\n    for i in range(len(arr) - 1):\n        if arr[i + 1] - arr[i] == 1:\n            count += 1\n    return count\n\ndef g(arr=[1, 4, 2, 8, 3, 5]):\n    return arr\n\nassert f(g()) == 4\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 309, "target_skills": [0, 0, 1, 1, 1, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, determine the number of pairs of integers in the list that have a difference of exactly 1.\n\n    Example:\n    arr = [1, 4, 2, 8, 3, 5]\n\n    Output:\n    4\n\n    Explanation:\n    The pairs with a difference of 1 are (1, 2), (1, 3), (4, 5), and (8, 9).\n\n    Hint: Use sorting and counting techniques to find the pairs.\n    \"\"\"\n    arr.sort()\n    count = 0\n    for i in range(len(arr) - 1):\n        if arr[i + 1] - arr[i] == 1:\n            count += 1\n    return count", "solution_func": "def g(arr=[1, 4, 2, 8, 3, 5]):\n    return arr", "map_ix": [1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph as a dictionary where the keys represent the nodes and the values represent the neighbors,\n    determine if there is a path from the start node to the end node.\n\n    Sample Input:\n    graph = {1: [2, 3], 2: [4], 3: [4, 5], 4: [6], 5: [6], 6: []}\n    start = 1\n    end = 6\n\n    Sample Output:\n    True\n    \"\"\"\n    visited = set()\n    return dfs(graph, start, end, visited)\n\ndef dfs(graph, node, end, visited):\n    if node == end:\n        return True\n    visited.add(node)\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, end, visited):\n                return True\n    return False\n\ndef g():\n    \"\"\"\n    Generate the input values for the function f.\n    \"\"\"\n    graph = {1: [2, 3], 2: [4], 3: [4, 5], 4: [6], 5: [6], 6: []}\n    start = 1\n    end = 6\n    return (graph, start, end)\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 309, "target_skills": [0, 1, 0, 0, 0, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph as a dictionary where the keys represent the nodes and the values represent the neighbors,\n    determine if there is a path from the start node to the end node.\n\n    Sample Input:\n    graph = {1: [2, 3], 2: [4], 3: [4, 5], 4: [6], 5: [6], 6: []}\n    start = 1\n    end = 6\n\n    Sample Output:\n    True\n    \"\"\"\n    visited = set()\n    return dfs(graph, start, end, visited)\n\ndef dfs(graph, node, end, visited):\n    if node == end:\n        return True\n    visited.add(node)\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, end, visited):\n                return True\n    return False", "solution_func": "def g():\n    \"\"\"\n    Generate the input values for the function f.\n    \"\"\"\n    graph = {1: [2, 3], 2: [4], 3: [4, 5], 4: [6], 5: [6], 6: []}\n    start = 1\n    end = 6\n    return (graph, start, end)", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "import math\nfrom typing import*\nfrom typing import List\n\ndef f(expression: str) -> bool:\n    \"\"\"\n    Given a mathematical expression as a string, determine if the expression is balanced.\n    A balanced expression has an equal number of opening and closing parentheses.\n\n    Sample Input:\n    expression = \"((2 + 3) * 4) - (5 / 2)\"\n\n    Sample Output:\n    True\n    \"\"\"\n    stack = []\n    for char in expression:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g():\n    \"\"\"\n    Generate the input values for the function f.\n    \"\"\"\n    expression = \"((2 + 3) * 4) - (5 / 2)\"\n    return expression\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 309, "target_skills": [0, 1, 0, 0, 1, 0, 1, 1, 0, 1], "problem_func": "import math\nfrom typing import*\nfrom typing import List\n\ndef f(expression: str) -> bool:\n    \"\"\"\n    Given a mathematical expression as a string, determine if the expression is balanced.\n    A balanced expression has an equal number of opening and closing parentheses.\n\n    Sample Input:\n    expression = \"((2 + 3) * 4) - (5 / 2)\"\n\n    Sample Output:\n    True\n    \"\"\"\n    stack = []\n    for char in expression:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0", "solution_func": "def g():\n    \"\"\"\n    Generate the input values for the function f.\n    \"\"\"\n    expression = \"((2 + 3) * 4) - (5 / 2)\"\n    return expression", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find two numbers in the list that add up to the target value.\n    Return the indices of the two numbers if found, otherwise return an empty list.\n\n    Sample Input:\n    nums = [2, 4, 6, 8, 10]\n    target = 14\n\n    Sample Output:\n    [1, 3]\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return [left, right]\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\ndef g():\n    \"\"\"\n    Generate the input values for the function f.\n    \"\"\"\n    nums = [2, 4, 6, 8, 10]\n    target = 14\n    return (nums, target)\n\nassert f(*g()) == [1, 3]\n", "emb": null, "idx_generation": 309, "target_skills": [1, 1, 0, 1, 0, 1, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find two numbers in the list that add up to the target value.\n    Return the indices of the two numbers if found, otherwise return an empty list.\n\n    Sample Input:\n    nums = [2, 4, 6, 8, 10]\n    target = 14\n\n    Sample Output:\n    [1, 3]\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return [left, right]\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return []", "solution_func": "def g():\n    \"\"\"\n    Generate the input values for the function f.\n    \"\"\"\n    nums = [2, 4, 6, 8, 10]\n    target = 14\n    return (nums, target)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n    Return the maximum XOR value.\n\n    Sample input:\n    nums = [2, 5, 8, 10]\n\n    Sample output:\n    13 (5 XOR 8)\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor_value = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor_value)\n    return max_xor\n\ndef g():\n    return [2, 5, 8, 10]\n\nassert f(g()) == 13\n", "emb": null, "idx_generation": 309, "target_skills": [1, 0, 1, 1, 0, 0, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n    Return the maximum XOR value.\n\n    Sample input:\n    nums = [2, 5, 8, 10]\n\n    Sample output:\n    13 (5 XOR 8)\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor_value = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor_value)\n    return max_xor", "solution_func": "def g():\n    return [2, 5, 8, 10]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, find two numbers in nums that add up to the target.\n    Return the indices of the two numbers in the original list.\n    \"\"\"\n\n    def binary_search(nums, target):\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        complement_index = binary_search(nums, complement)\n        if complement_index != -1 and complement_index != i:\n            return [i, complement_index]\n\n    return []\n\ndef g() -> List[int]:\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 310, "target_skills": [1, 1, 0, 0, 1, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, find two numbers in nums that add up to the target.\n    Return the indices of the two numbers in the original list.\n    \"\"\"\n\n    def binary_search(nums, target):\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        complement_index = binary_search(nums, complement)\n        if complement_index != -1 and complement_index != i:\n            return [i, complement_index]\n\n    return []", "solution_func": "def g() -> List[int]:\n    return ([2, 7, 11, 15], 9)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers n and m, representing the dimensions of a grid, \n    return the number of unique paths from the top-left corner to the bottom-right corner of the grid.\n    You can only move down or right at any point in time.\n\n    Example:\n    Input: n = 3, m = 7\n    Output: 28\n    Explanation: There are 28 unique paths from the top-left corner to the bottom-right corner of a 3x7 grid.\n    \"\"\"\n\n    def unique_paths_helper(x: int, y: int, memo: List[List[int]]) -> int:\n        if x == 0 or y == 0:\n            return 1\n        if memo[x][y] != 0:\n            return memo[x][y]\n        memo[x][y] = unique_paths_helper(x-1, y, memo) + unique_paths_helper(x, y-1, memo)\n        return memo[x][y]\n\n    memo = [[0] * (m+1) for _ in range(n+1)]\n    return unique_paths_helper(n, m, memo)\n\ndef g() -> List[int]:\n    return (3, 7)\n\nassert f(*g()) == 28\n", "emb": null, "idx_generation": 310, "target_skills": [0, 0, 0, 0, 0, 1, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers n and m, representing the dimensions of a grid, \n    return the number of unique paths from the top-left corner to the bottom-right corner of the grid.\n    You can only move down or right at any point in time.\n\n    Example:\n    Input: n = 3, m = 7\n    Output: 28\n    Explanation: There are 28 unique paths from the top-left corner to the bottom-right corner of a 3x7 grid.\n    \"\"\"\n\n    def unique_paths_helper(x: int, y: int, memo: List[List[int]]) -> int:\n        if x == 0 or y == 0:\n            return 1\n        if memo[x][y] != 0:\n            return memo[x][y]\n        memo[x][y] = unique_paths_helper(x-1, y, memo) + unique_paths_helper(x, y-1, memo)\n        return memo[x][y]\n\n    memo = [[0] * (m+1) for _ in range(n+1)]\n    return unique_paths_helper(n, m, memo)", "solution_func": "def g() -> List[int]:\n    return (3, 7)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s consisting of lowercase English letters and digits, \n    return the maximum possible value of a valid arithmetic expression that can be formed by inserting the '+' and '*' operators between the digits.\n\n    Example:\n    Input: s = \"123\"\n    Output: 123\n    Explanation: The maximum value is obtained by evaluating the expression 1 + 2 * 3 = 7.\n\n    Note:\n    - The given string will always be a valid arithmetic expression.\n    - The length of the string is between 1 and 1000.\n    \"\"\"\n\n    def evaluate_expression(expression: str) -> int:\n        stack = []\n        current_number = 0\n        current_operator = \"+\"\n\n        for i in range(len(expression)):\n            char = expression[i]\n\n            if char.isdigit():\n                current_number = current_number * 10 + int(char)\n\n            if not char.isdigit() or i == len(expression) - 1:\n                if current_operator == \"+\":\n                    stack.append(current_number)\n                elif current_operator == \"*\":\n                    stack[-1] *= current_number\n                current_number = 0\n                current_operator = char\n\n        return sum(stack)\n\n    def generate_expressions_helper(s: str, index: int, expression: str, result: int, max_value: int) -> int:\n        if index == len(s):\n            max_value = max(max_value, evaluate_expression(expression))\n            return max_value\n\n        max_value = generate_expressions_helper(s, index + 1, expression + s[index], result, max_value)\n        max_value = generate_expressions_helper(s, index + 1, expression + \"+\" + s[index], result, max_value)\n        max_value = generate_expressions_helper(s, index + 1, expression + \"*\" + s[index], result, max_value)\n\n        return max_value\n\n    return generate_expressions_helper(s, 1, s[0], 0, 0)\n\ndef g() -> str:\n    return \"123\"\n\nassert f(g()) == 7\n", "emb": null, "idx_generation": 310, "target_skills": [0, 1, 1, 0, 1, 1, 1, 1, 1, 0], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s consisting of lowercase English letters and digits, \n    return the maximum possible value of a valid arithmetic expression that can be formed by inserting the '+' and '*' operators between the digits.\n\n    Example:\n    Input: s = \"123\"\n    Output: 123\n    Explanation: The maximum value is obtained by evaluating the expression 1 + 2 * 3 = 7.\n\n    Note:\n    - The given string will always be a valid arithmetic expression.\n    - The length of the string is between 1 and 1000.\n    \"\"\"\n\n    def evaluate_expression(expression: str) -> int:\n        stack = []\n        current_number = 0\n        current_operator = \"+\"\n\n        for i in range(len(expression)):\n            char = expression[i]\n\n            if char.isdigit():\n                current_number = current_number * 10 + int(char)\n\n            if not char.isdigit() or i == len(expression) - 1:\n                if current_operator == \"+\":\n                    stack.append(current_number)\n                elif current_operator == \"*\":\n                    stack[-1] *= current_number\n                current_number = 0\n                current_operator = char\n\n        return sum(stack)\n\n    def generate_expressions_helper(s: str, index: int, expression: str, result: int, max_value: int) -> int:\n        if index == len(s):\n            max_value = max(max_value, evaluate_expression(expression))\n            return max_value\n\n        max_value = generate_expressions_helper(s, index + 1, expression + s[index], result, max_value)\n        max_value = generate_expressions_helper(s, index + 1, expression + \"+\" + s[index], result, max_value)\n        max_value = generate_expressions_helper(s, index + 1, expression + \"*\" + s[index], result, max_value)\n\n        return max_value\n\n    return generate_expressions_helper(s, 1, s[0], 0, 0)", "solution_func": "def g() -> str:\n    return \"123\"", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 1s and 0s, find the maximum size of a square subgrid where all elements are 1s.\n\n    Example:\n    Input: \n    grid = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n    Output:\n    4\n    Explanation:\n    The largest square subgrid with all 1s has a size of 4.\n\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * (n+1) for _ in range(m+1)]\n    max_size = 0\n\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if grid[i-1][j-1] == 1:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n                max_size = max(max_size, dp[i][j])\n\n    return max_size\n\n\ndef g(grid: List[List[int]] = [[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]):\n    \"\"\"\n    Find the maximum size of a square subgrid with all 1s in the given grid.\n    \"\"\"\n    return grid\n\n\nassert f(g()) == 4\n\n", "emb": null, "idx_generation": 310, "target_skills": [0, 0, 0, 0, 1, 0, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 1s and 0s, find the maximum size of a square subgrid where all elements are 1s.\n\n    Example:\n    Input: \n    grid = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n    Output:\n    4\n    Explanation:\n    The largest square subgrid with all 1s has a size of 4.\n\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * (n+1) for _ in range(m+1)]\n    max_size = 0\n\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if grid[i-1][j-1] == 1:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n                max_size = max(max_size, dp[i][j])\n\n    return max_size", "solution_func": "def g(grid: List[List[int]] = [[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]):\n    \"\"\"\n    Find the maximum size of a square subgrid with all 1s in the given grid.\n    \"\"\"\n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, find the number of islands.\n    An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.\n    You may assume all four edges of the grid are all surrounded by water.\n\n    Example:\n    Input:\n    grid = [\n        ['1', '1', '1', '1', '0'],\n        ['1', '1', '0', '1', '0'],\n        ['1', '1', '0', '0', '0'],\n        ['0', '0', '0', '0', '0']\n    ]\n    Output:\n    1\n    Explanation:\n    There is only one island in the given grid.\n\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n    count = 0\n\n    def dfs(i, j):\n        if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != '1':\n            return\n        grid[i][j] = '0'\n        dfs(i+1, j)\n        dfs(i-1, j)\n        dfs(i, j+1)\n        dfs(i, j-1)\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '1':\n                count += 1\n                dfs(i, j)\n\n    return count\n\n\ndef g(grid: List[List[str]] = [['1', '1', '1', '1', '0'], ['1', '1', '0', '1', '0'], ['1', '1', '0', '0', '0'], ['0', '0', '0', '0', '0']]):\n    \"\"\"\n    Find the number of islands in the given grid.\n    \"\"\"\n    return grid\n\n\nassert f(g()) == 1\n\n", "emb": null, "idx_generation": 310, "target_skills": [1, 1, 1, 1, 1, 1, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, find the number of islands.\n    An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.\n    You may assume all four edges of the grid are all surrounded by water.\n\n    Example:\n    Input:\n    grid = [\n        ['1', '1', '1', '1', '0'],\n        ['1', '1', '0', '1', '0'],\n        ['1', '1', '0', '0', '0'],\n        ['0', '0', '0', '0', '0']\n    ]\n    Output:\n    1\n    Explanation:\n    There is only one island in the given grid.\n\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n    count = 0\n\n    def dfs(i, j):\n        if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != '1':\n            return\n        grid[i][j] = '0'\n        dfs(i+1, j)\n        dfs(i-1, j)\n        dfs(i, j+1)\n        dfs(i, j-1)\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '1':\n                count += 1\n                dfs(i, j)\n\n    return count", "solution_func": "def g(grid: List[List[str]] = [['1', '1', '1', '1', '0'], ['1', '1', '0', '1', '0'], ['1', '1', '0', '0', '0'], ['0', '0', '0', '0', '0']]):\n    \"\"\"\n    Find the number of islands in the given grid.\n    \"\"\"\n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum of a path from the top left cell to the bottom right cell.\n    You can only move down, right, or diagonally.\n\n    Example:\n    Input:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output:\n    8\n    Explanation:\n    The maximum sum of a path from the top left cell to the bottom right cell is 8.\n\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * (n+1) for _ in range(m+1)]\n\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + grid[i-1][j-1]\n\n    return dp[m][n]\n\n\ndef g(grid: List[List[int]] = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    \"\"\"\n    Find the maximum sum of a path from the top left cell to the bottom right cell in the grid.\n    \"\"\"\n    return grid\n\n\nassert f(g()) == 8\n\n", "emb": null, "idx_generation": 310, "target_skills": [1, 1, 0, 0, 0, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum of a path from the top left cell to the bottom right cell.\n    You can only move down, right, or diagonally.\n\n    Example:\n    Input:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output:\n    8\n    Explanation:\n    The maximum sum of a path from the top left cell to the bottom right cell is 8.\n\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * (n+1) for _ in range(m+1)]\n\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + grid[i-1][j-1]\n\n    return dp[m][n]", "solution_func": "def g(grid: List[List[int]] = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    \"\"\"\n    Find the maximum sum of a path from the top left cell to the bottom right cell in the grid.\n    \"\"\"\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a list of words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.\n\n    Args:\n    - s: The input string.\n    - words: The list of dictionary words.\n\n    Returns:\n    - True if s can be segmented into a sequence of dictionary words, False otherwise.\n    \"\"\"\n    n = len(s)\n    dp = [False] * (n + 1)\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in words:\n                dp[i] = True\n                break\n\n    return dp[n]\n\ndef g() -> Tuple[str, List[str]]:\n    s = \"leetcode\"\n    words = [\"leet\", \"code\"]\n    return s, words\n\nassert f(*g())\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 310, "target_skills": [0, 0, 0, 1, 0, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a list of words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.\n\n    Args:\n    - s: The input string.\n    - words: The list of dictionary words.\n\n    Returns:\n    - True if s can be segmented into a sequence of dictionary words, False otherwise.\n    \"\"\"\n    n = len(s)\n    dp = [False] * (n + 1)\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in words:\n                dp[i] = True\n                break\n\n    return dp[n]", "solution_func": "def g() -> Tuple[str, List[str]]:\n    s = \"leetcode\"\n    words = [\"leet\", \"code\"]\n    return s, words", "map_ix": [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val: int):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef f(nums: List[int]) -> TreeNode:\n    \"\"\"\n    Given a list of unique integers, construct a binary search tree from the given numbers.\n\n    Args:\n    - nums: The list of unique integers.\n\n    Returns:\n    - The root of the constructed binary search tree.\n    \"\"\"\n    def construct_bst(nums: List[int], start: int, end: int) -> TreeNode:\n        if start > end:\n            return None\n\n        mid = (start + end) // 2\n        root = TreeNode(nums[mid])\n        root.left = construct_bst(nums, start, mid - 1)\n        root.right = construct_bst(nums, mid + 1, end)\n\n        return root\n\n    return construct_bst(nums, 0, len(nums) - 1)\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5, 6, 7]\n    return nums\n\nassert f(*g())\n", "emb": null, "idx_generation": 310, "target_skills": [1, 0, 0, 1, 1, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val: int):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef f(nums: List[int]) -> TreeNode:\n    \"\"\"\n    Given a list of unique integers, construct a binary search tree from the given numbers.\n\n    Args:\n    - nums: The list of unique integers.\n\n    Returns:\n    - The root of the constructed binary search tree.\n    \"\"\"\n    def construct_bst(nums: List[int], start: int, end: int) -> TreeNode:\n        if start > end:\n            return None\n\n        mid = (start + end) // 2\n        root = TreeNode(nums[mid])\n        root.left = construct_bst(nums, start, mid - 1)\n        root.right = construct_bst(nums, mid + 1, end)\n\n        return root\n\n    return construct_bst(nums, 0, len(nums) - 1)", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5, 6, 7]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size m x n, where each cell represents the number of coins in that cell, find the maximum number of coins you can collect starting from the top-left cell and ending at the bottom-right cell. You can only move right or down.\n\n    Args:\n    - grid: The grid of size m x n, where grid[i][j] represents the number of coins in the cell at row i and column j.\n\n    Returns:\n    - The maximum number of coins that can be collected.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(*g()) == 12\n", "emb": null, "idx_generation": 310, "target_skills": [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size m x n, where each cell represents the number of coins in that cell, find the maximum number of coins you can collect starting from the top-left cell and ending at the bottom-right cell. You can only move right or down.\n\n    Args:\n    - grid: The grid of size m x n, where grid[i][j] represents the number of coins in the cell at row i and column j.\n\n    Returns:\n    - The maximum number of coins that can be collected.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix consisting of 0's and 1's, find the size of the largest square submatrix that contains only 1's.\n\n    Example:\n    Input: \n    matrix = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n    Output: 4\n\n    Explanation:\n    The largest square submatrix that contains only 1's is:\n    [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n        [1, 1, 1, 1]\n    ]\n    \"\"\"\n\n    if not matrix:\n        return 0\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n    max_side = 0\n\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            if matrix[i - 1][j - 1] == 1:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                max_side = max(max_side, dp[i][j])\n\n    return max_side * max_side\n\ndef g():\n    \"\"\"\n    Generate a matrix consisting of 0's and 1's.\n    \"\"\"\n    return [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n\nassert f(g()) == 4\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 310, "target_skills": [1, 1, 1, 1, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix consisting of 0's and 1's, find the size of the largest square submatrix that contains only 1's.\n\n    Example:\n    Input: \n    matrix = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n    Output: 4\n\n    Explanation:\n    The largest square submatrix that contains only 1's is:\n    [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n        [1, 1, 1, 1]\n    ]\n    \"\"\"\n\n    if not matrix:\n        return 0\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n    max_side = 0\n\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            if matrix[i - 1][j - 1] == 1:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                max_side = max(max_side, dp[i][j])\n\n    return max_side * max_side", "solution_func": "def g():\n    \"\"\"\n    Generate a matrix consisting of 0's and 1's.\n    \"\"\"\n    return [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]", "map_ix": [1, 1, 0, 1, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[int]:\n    \"\"\"\n    Given two integers n and k, generate all possible combinations of k numbers out of the range [1, n].\n    Return the combinations as a list of lists.\n\n    Example:\n    n = 4\n    k = 2\n\n    Output:\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n\n    Explanation:\n    There are six possible combinations of two numbers from the range [1, 4].\n    \"\"\"\n\n    def backtrack(start, curr_comb):\n        if len(curr_comb) == k:\n            result.append(curr_comb[:])\n        else:\n            for i in range(start, n + 1):\n                curr_comb.append(i)\n                backtrack(i + 1, curr_comb)\n                curr_comb.pop()\n\n    result = []\n    backtrack(1, [])\n    return result\n\ndef g(n=4, k=2):\n    return n, k\n\nassert f(*g()) == [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 311, "target_skills": [0, 0, 0, 0, 0, 1, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[int]:\n    \"\"\"\n    Given two integers n and k, generate all possible combinations of k numbers out of the range [1, n].\n    Return the combinations as a list of lists.\n\n    Example:\n    n = 4\n    k = 2\n\n    Output:\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n\n    Explanation:\n    There are six possible combinations of two numbers from the range [1, 4].\n    \"\"\"\n\n    def backtrack(start, curr_comb):\n        if len(curr_comb) == k:\n            result.append(curr_comb[:])\n        else:\n            for i in range(start, n + 1):\n                curr_comb.append(i)\n                backtrack(i + 1, curr_comb)\n                curr_comb.pop()\n\n    result = []\n    backtrack(1, [])\n    return result", "solution_func": "def g(n=4, k=2):\n    return n, k", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it can be segmented into a space-separated sequence of one or more dictionary words.\n\n    Example:\n    s = \"leetcode\"\n\n    Output:\n    True\n\n    Explanation:\n    The string \"leetcode\" can be segmented into \"leet\" and \"code\", both of which are dictionary words.\n    \"\"\"\n\n    def backtrack(start):\n        if start == len(s):\n            return True\n\n        for end in range(start + 1, len(s) + 1):\n            if s[start:end] in dictionary and backtrack(end):\n                return True\n\n        return False\n\n    # Dictionary of valid words\n    dictionary = {\"leet\", \"code\"}\n\n    return backtrack(0)\n\ndef g(s=\"leetcode\"):\n    return s\n\nassert f(g()) == True\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 311, "target_skills": [1, 0, 1, 0, 1, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it can be segmented into a space-separated sequence of one or more dictionary words.\n\n    Example:\n    s = \"leetcode\"\n\n    Output:\n    True\n\n    Explanation:\n    The string \"leetcode\" can be segmented into \"leet\" and \"code\", both of which are dictionary words.\n    \"\"\"\n\n    def backtrack(start):\n        if start == len(s):\n            return True\n\n        for end in range(start + 1, len(s) + 1):\n            if s[start:end] in dictionary and backtrack(end):\n                return True\n\n        return False\n\n    # Dictionary of valid words\n    dictionary = {\"leet\", \"code\"}\n\n    return backtrack(0)", "solution_func": "def g(s=\"leetcode\"):\n    return s", "map_ix": [1, 1, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of non-negative integers nums and a target integer, find the minimum number of jumps to reach the\n    target position. Each element in the list represents the maximum jump length at that position.\n\n    Example:\n    nums = [2, 3, 1, 1, 4]\n    target = 4\n\n    Output:\n    2\n\n    Explanation:\n    The minimum number of jumps to reach the target position is 2.\n    The first jump takes us from index 0 to index 1.\n    The second jump takes us from index 1 to index 4.\n    \"\"\"\n\n    def jump(start, jumps):\n        if start == target:\n            return jumps\n\n        if start >= len(nums):\n            return float('inf')\n\n        min_jumps = float('inf')\n        for i in range(1, nums[start] + 1):\n            min_jumps = min(min_jumps, jump(start + i, jumps + 1))\n\n        return min_jumps\n\n    return jump(0, 0)\n\ndef g(nums=[2, 3, 1, 1, 4], target=4):\n    return nums, target\n\nassert f(*g()) == 2\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 311, "target_skills": [1, 1, 0, 1, 1, 1, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of non-negative integers nums and a target integer, find the minimum number of jumps to reach the\n    target position. Each element in the list represents the maximum jump length at that position.\n\n    Example:\n    nums = [2, 3, 1, 1, 4]\n    target = 4\n\n    Output:\n    2\n\n    Explanation:\n    The minimum number of jumps to reach the target position is 2.\n    The first jump takes us from index 0 to index 1.\n    The second jump takes us from index 1 to index 4.\n    \"\"\"\n\n    def jump(start, jumps):\n        if start == target:\n            return jumps\n\n        if start >= len(nums):\n            return float('inf')\n\n        min_jumps = float('inf')\n        for i in range(1, nums[start] + 1):\n            min_jumps = min(min_jumps, jump(start + i, jumps + 1))\n\n        return min_jumps\n\n    return jump(0, 0)", "solution_func": "def g(nums=[2, 3, 1, 1, 4], target=4):\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target element using binary search.\n    If the target element is not found, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target\n\nassert f(*g()) == 2\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 311, "target_skills": [1, 1, 0, 0, 1, 0, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target element using binary search.\n    If the target element is not found, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g():\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid, count the number of connected components in the grid.\n    Each cell in the grid can be connected to its adjacent cells (up, down, left, and right).\n    \"\"\"\n    def dfs(i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:\n            return\n        grid[i][j] = 0\n        dfs(i+1, j)\n        dfs(i-1, j)\n        dfs(i, j+1)\n        dfs(i, j-1)\n\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                dfs(i, j)\n                count += 1\n\n    return count\n\ndef g():\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 3\n\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 311, "target_skills": [0, 0, 0, 0, 0, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid, count the number of connected components in the grid.\n    Each cell in the grid can be connected to its adjacent cells (up, down, left, and right).\n    \"\"\"\n    def dfs(i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:\n            return\n        grid[i][j] = 0\n        dfs(i+1, j)\n        dfs(i-1, j)\n        dfs(i, j+1)\n        dfs(i, j-1)\n\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                dfs(i, j)\n                count += 1\n\n    return count", "solution_func": "def g():\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    return grid", "map_ix": [1, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum using the Kadane's algorithm.\n    The maximum subarray sum is the sum of the contiguous subarray with the largest sum.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g():\n    nums = [-2, -3, 4, -1, -2, 1, 5, -3]\n    return nums\n\nassert f(g()) == 7\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 311, "target_skills": [1, 0, 1, 0, 0, 0, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum using the Kadane's algorithm.\n    The maximum subarray sum is the sum of the contiguous subarray with the largest sum.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g():\n    nums = [-2, -3, 4, -1, -2, 1, 5, -3]\n    return nums", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Find two numbers in the given list that add up to the target value.\n    Return the indices of the two numbers.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate the list of numbers and the target value for the puzzle.\n    \"\"\"\n    nums = [2, 7, 11, 15, 3, 6, 8]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "idx_generation": 311, "target_skills": [1, 0, 0, 0, 1, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Find two numbers in the given list that add up to the target value.\n    Return the indices of the two numbers.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate the list of numbers and the target value for the puzzle.\n    \"\"\"\n    nums = [2, 7, 11, 15, 3, 6, 8]\n    target = 9\n    return nums, target", "map_ix": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Count the number of distinct substrings in the given string.\n    \"\"\"\n    n = len(s)\n    substrings = set()\n    for i in range(n):\n        for j in range(i, n):\n            substrings.add(s[i:j+1])\n    return len(substrings)\n\ndef g() -> str:\n    \"\"\"\n    Generate the string for the puzzle.\n    \"\"\"\n    return \"abab\"\n\nassert f(g()) == 6\n", "emb": null, "idx_generation": 311, "target_skills": [1, 0, 0, 1, 0, 1, 1, 1, 1, 0], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Count the number of distinct substrings in the given string.\n    \"\"\"\n    n = len(s)\n    substrings = set()\n    for i in range(n):\n        for j in range(i, n):\n            substrings.add(s[i:j+1])\n    return len(substrings)", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate the string for the puzzle.\n    \"\"\"\n    return \"abab\"", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Find the maximum sum that can be obtained by dividing the given list of numbers into non-empty subarrays,\n    such that the sum of each subarray is divisible by 3.\n    \"\"\"\n    n = len(nums)\n    dp = [0] * 3\n    for num in nums:\n        new_dp = dp.copy()\n        for i in range(3):\n            new_dp[(num + i) % 3] = max(dp[(num + i) % 3], dp[i] + num)\n        dp = new_dp\n    return dp[0]\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate the list of numbers for the puzzle.\n    \"\"\"\n    nums = [3, 6, 5, 1, 8]\n    return nums\n\nassert f(g()) == 18\n", "emb": null, "idx_generation": 311, "target_skills": [0, 0, 1, 0, 1, 0, 0, 1, 0, 1], "problem_func": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Find the maximum sum that can be obtained by dividing the given list of numbers into non-empty subarrays,\n    such that the sum of each subarray is divisible by 3.\n    \"\"\"\n    n = len(nums)\n    dp = [0] * 3\n    for num in nums:\n        new_dp = dp.copy()\n        for i in range(3):\n            new_dp[(num + i) % 3] = max(dp[(num + i) % 3], dp[i] + num)\n        dp = new_dp\n    return dp[0]", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate the list of numbers for the puzzle.\n    \"\"\"\n    nums = [3, 6, 5, 1, 8]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all possible combinations of numbers, \n    where each number can be used zero or more times.\n    Return the sum modulo 10^9 + 7.\n\n    Example:\n    nums = [1, 2, 3]\n\n    Output:\n    19 (since the possible combinations are [], [1], [2], [3], [1, 1], [1, 2], [1, 3], [2, 2], [2, 3], [3, 3], [1, 1, 1], [1, 1, 2], [1, 1, 3], [1, 2, 2], [1, 2, 3], [1, 3, 3], [2, 2, 2], [2, 2, 3], [2, 3, 3], [3, 3, 3])\n    \"\"\"\n    mod = 10**9 + 7\n    dp = [0] * (sum(nums) + 1)\n    dp[0] = 1\n\n    for i in range(1, len(dp)):\n        for num in nums:\n            if i >= num:\n                dp[i] += dp[i - num]\n                dp[i] %= mod\n\n    return dp[-1]\n\ndef g():\n    return [1, 2, 3]\n\nassert f(g()) == 19\n", "emb": null, "idx_generation": 311, "target_skills": [0, 0, 1, 0, 0, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all possible combinations of numbers, \n    where each number can be used zero or more times.\n    Return the sum modulo 10^9 + 7.\n\n    Example:\n    nums = [1, 2, 3]\n\n    Output:\n    19 (since the possible combinations are [], [1], [2], [3], [1, 1], [1, 2], [1, 3], [2, 2], [2, 3], [3, 3], [1, 1, 1], [1, 1, 2], [1, 1, 3], [1, 2, 2], [1, 2, 3], [1, 3, 3], [2, 2, 2], [2, 2, 3], [2, 3, 3], [3, 3, 3])\n    \"\"\"\n    mod = 10**9 + 7\n    dp = [0] * (sum(nums) + 1)\n    dp[0] = 1\n\n    for i in range(1, len(dp)):\n        for num in nums:\n            if i >= num:\n                dp[i] += dp[i - num]\n                dp[i] %= mod\n\n    return dp[-1]", "solution_func": "def g():\n    return [1, 2, 3]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of integers, determine if it is a magic square.\n    A magic square is a square grid of numbers where the sums of the numbers in each row, each column, and both diagonals are the same.\n\n    Example:\n    grid = [[2, 7, 6],\n            [9, 5, 1],\n            [4, 3, 8]]\n\n    Output:\n    True\n\n    Explanation:\n    The sums of each row, column, and diagonal are all equal to 15.\n\n    Hint: Use sorting and searching to find the sum of each row, column, and diagonal.\n    \"\"\"\n\n    n = len(grid)\n    target_sum = sum(grid[0])\n\n    # Check rows\n    for row in grid:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for i in range(n):\n        col_sum = sum(row[i] for row in grid)\n        if col_sum != target_sum:\n            return False\n\n    # Check diagonals\n    main_diag_sum = sum(grid[i][i] for i in range(n))\n    anti_diag_sum = sum(grid[i][n-i-1] for i in range(n))\n    if main_diag_sum != target_sum or anti_diag_sum != target_sum:\n        return False\n\n    return True\n\ndef g():\n    return [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 312, "target_skills": [1, 0, 1, 1, 0, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of integers, determine if it is a magic square.\n    A magic square is a square grid of numbers where the sums of the numbers in each row, each column, and both diagonals are the same.\n\n    Example:\n    grid = [[2, 7, 6],\n            [9, 5, 1],\n            [4, 3, 8]]\n\n    Output:\n    True\n\n    Explanation:\n    The sums of each row, column, and diagonal are all equal to 15.\n\n    Hint: Use sorting and searching to find the sum of each row, column, and diagonal.\n    \"\"\"\n\n    n = len(grid)\n    target_sum = sum(grid[0])\n\n    # Check rows\n    for row in grid:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for i in range(n):\n        col_sum = sum(row[i] for row in grid)\n        if col_sum != target_sum:\n            return False\n\n    # Check diagonals\n    main_diag_sum = sum(grid[i][i] for i in range(n))\n    anti_diag_sum = sum(grid[i][n-i-1] for i in range(n))\n    if main_diag_sum != target_sum or anti_diag_sum != target_sum:\n        return False\n\n    return True", "solution_func": "def g():\n    return [[2, 7, 6], [9, 5, 1], [4, 3, 8]]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed acyclic graph (DAG) represented as an adjacency list, determine if there is a path from the start node to the end node.\n\n    Example:\n    graph = [[1, 2], [3], [3], []]\n    start = 0\n    end = 3\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 0 to node 3: 0 -> 1 -> 3.\n\n    Hint: Use depth-first search (DFS) to traverse the graph and find a path from the start node to the end node.\n    \"\"\"\n\n    def dfs(node):\n        if node == end:\n            return True\n\n        visited[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n\n        return False\n\n    n = len(graph)\n    visited = [False] * n\n\n    return dfs(start)\n\ndef g():\n    return [[1, 2], [3], [3], []], 0, 3\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 312, "target_skills": [1, 0, 1, 1, 0, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed acyclic graph (DAG) represented as an adjacency list, determine if there is a path from the start node to the end node.\n\n    Example:\n    graph = [[1, 2], [3], [3], []]\n    start = 0\n    end = 3\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 0 to node 3: 0 -> 1 -> 3.\n\n    Hint: Use depth-first search (DFS) to traverse the graph and find a path from the start node to the end node.\n    \"\"\"\n\n    def dfs(node):\n        if node == end:\n            return True\n\n        visited[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n\n        return False\n\n    n = len(graph)\n    visited = [False] * n\n\n    return dfs(start)", "solution_func": "def g():\n    return [[1, 2], [3], [3], []], 0, 3", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [2, 7]\n\n    Explanation:\n    The numbers 2 and 7 add up to 9.\n\n    Hint: Use a two-pointer approach to search for the two numbers that add up to the target.\n    \"\"\"\n\n    n = len(nums)\n    nums = sorted(nums)\n    left = 0\n    right = n - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [nums[left], nums[right]]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g():\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [2, 7]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 312, "target_skills": [1, 0, 0, 0, 0, 1, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [2, 7]\n\n    Explanation:\n    The numbers 2 and 7 add up to 9.\n\n    Hint: Use a two-pointer approach to search for the two numbers that add up to the target.\n    \"\"\"\n\n    n = len(nums)\n    nums = sorted(nums)\n    left = 0\n    right = n - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [nums[left], nums[right]]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g():\n    return [2, 7, 11, 15], 9", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort them in descending order using bubble sort algorithm.\n\n    Example:\n    f([3, 1, 5, 2, 4]) returns [5, 4, 3, 2, 1].\n\n    Note:\n    - The input list can contain duplicate numbers.\n    \"\"\"\n\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] < nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n\n    return nums\n\n\ndef g(nums: List[int] = [3, 1, 5, 2, 4]) -> List[int]:\n    \"\"\"\n    Generate a list of positive integers.\n\n    Example:\n    g() returns [3, 1, 5, 2, 4].\n\n    Note:\n    - The input list can contain duplicate numbers.\n    \"\"\"\n\n    return nums\n\n\nassert f(g()) == [5, 4, 3, 2, 1]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 312, "target_skills": [1, 0, 1, 1, 1, 1, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort them in descending order using bubble sort algorithm.\n\n    Example:\n    f([3, 1, 5, 2, 4]) returns [5, 4, 3, 2, 1].\n\n    Note:\n    - The input list can contain duplicate numbers.\n    \"\"\"\n\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] < nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n\n    return nums", "solution_func": "def g(nums: List[int] = [3, 1, 5, 2, 4]) -> List[int]:\n    \"\"\"\n    Generate a list of positive integers.\n\n    Example:\n    g() returns [3, 1, 5, 2, 4].\n\n    Note:\n    - The input list can contain duplicate numbers.\n    \"\"\"\n\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, check if it is a magic square.\n\n    A magic square is a square grid of numbers such that the sums of the numbers in each row, each column, and both main diagonals are the same.\n\n    Example:\n    f([[2, 7, 6], [9, 5, 1], [4, 3, 8]]) returns True.\n\n    Note:\n    - The input matrix will always be a square matrix.\n    - The size of the matrix will always be odd.\n    \"\"\"\n\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for j in range(n):\n        column_sum = sum(matrix[i][j] for i in range(n))\n        if column_sum != target_sum:\n            return False\n\n    # Check main diagonal\n    if sum(matrix[i][i] for i in range(n)) != target_sum:\n        return False\n\n    # Check secondary diagonal\n    if sum(matrix[i][n-i-1] for i in range(n)) != target_sum:\n        return False\n\n    return True\n\n\ndef g(matrix: List[List[int]] = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]) -> List[List[int]]:\n    \"\"\"\n    Generate a square matrix of positive integers.\n\n    Example:\n    g() returns [[2, 7, 6], [9, 5, 1], [4, 3, 8]].\n\n    Note:\n    - The size of the matrix will always be odd.\n    \"\"\"\n\n    return matrix\n\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], "idx_generation": 312, "target_skills": [1, 1, 0, 0, 0, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, check if it is a magic square.\n\n    A magic square is a square grid of numbers such that the sums of the numbers in each row, each column, and both main diagonals are the same.\n\n    Example:\n    f([[2, 7, 6], [9, 5, 1], [4, 3, 8]]) returns True.\n\n    Note:\n    - The input matrix will always be a square matrix.\n    - The size of the matrix will always be odd.\n    \"\"\"\n\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for j in range(n):\n        column_sum = sum(matrix[i][j] for i in range(n))\n        if column_sum != target_sum:\n            return False\n\n    # Check main diagonal\n    if sum(matrix[i][i] for i in range(n)) != target_sum:\n        return False\n\n    # Check secondary diagonal\n    if sum(matrix[i][n-i-1] for i in range(n)) != target_sum:\n        return False\n\n    return True", "solution_func": "def g(matrix: List[List[int]] = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]) -> List[List[int]]:\n    \"\"\"\n    Generate a square matrix of positive integers.\n\n    Example:\n    g() returns [[2, 7, 6], [9, 5, 1], [4, 3, 8]].\n\n    Note:\n    - The size of the matrix will always be odd.\n    \"\"\"\n\n    return matrix", "map_ix": [0, 0, 0, 1, 0, 0, 1, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(points: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Given a list of 2D points, find the minimum distance between any two points.\n\n    Example:\n    f([(1, 2), (3, 4), (5, 6)]) returns 2.\n\n    Note:\n    - The input list will contain at least two points.\n    \"\"\"\n\n    n = len(points)\n    min_distance = float('inf')\n\n    for i in range(n):\n        for j in range(i+1, n):\n            distance = ((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) ** 0.5\n            min_distance = min(min_distance, distance)\n\n    return min_distance\n\n\ndef g(points: List[Tuple[int, int]] = [(1, 2), (3, 4), (5, 6)]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Generate a list of 2D points.\n\n    Example:\n    g() returns [(1, 2), (3, 4), (5, 6)].\n\n    Note:\n    - The input list will contain at least two points.\n    \"\"\"\n\n    return points\n\n\nassert f(g()) == 2\n", "emb": null, "idx_generation": 312, "target_skills": [1, 0, 1, 0, 0, 1, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(points: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Given a list of 2D points, find the minimum distance between any two points.\n\n    Example:\n    f([(1, 2), (3, 4), (5, 6)]) returns 2.\n\n    Note:\n    - The input list will contain at least two points.\n    \"\"\"\n\n    n = len(points)\n    min_distance = float('inf')\n\n    for i in range(n):\n        for j in range(i+1, n):\n            distance = ((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) ** 0.5\n            min_distance = min(min_distance, distance)\n\n    return min_distance", "solution_func": "def g(points: List[Tuple[int, int]] = [(1, 2), (3, 4), (5, 6)]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Generate a list of 2D points.\n\n    Example:\n    g() returns [(1, 2), (3, 4), (5, 6)].\n\n    Note:\n    - The input list will contain at least two points.\n    \"\"\"\n\n    return points", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, find if there exists a pair of numbers that sum up to the target.\n    \"\"\"\n    def binary_search(arr, target, start, end):\n        if start > end:\n            return False\n        mid = (start + end) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            return binary_search(arr, target, mid + 1, end)\n        else:\n            return binary_search(arr, target, start, mid - 1)\n    \n    for i in range(len(arr)):\n        complement = target - arr[i]\n        if binary_search(arr, complement, i + 1, len(arr) - 1):\n            return True\n    return False\n\ndef g(arr=[1, 4, 7, 9, 12, 15, 18], target=16):\n    return arr, target\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 312, "target_skills": [0, 1, 0, 1, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, find if there exists a pair of numbers that sum up to the target.\n    \"\"\"\n    def binary_search(arr, target, start, end):\n        if start > end:\n            return False\n        mid = (start + end) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            return binary_search(arr, target, mid + 1, end)\n        else:\n            return binary_search(arr, target, start, mid - 1)\n    \n    for i in range(len(arr)):\n        complement = target - arr[i]\n        if binary_search(arr, complement, i + 1, len(arr) - 1):\n            return True\n    return False", "solution_func": "def g(arr=[1, 4, 7, 9, 12, 15, 18], target=16):\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome after removing a single character.\n    \"\"\"\n    def is_palindrome(s, left, right):\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n    \n    left = 0\n    right = len(s) - 1\n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s, left + 1, right) or is_palindrome(s, left, right - 1)\n        left += 1\n        right -= 1\n    return True\n\ndef g(s=\"level\"):\n    return s\n\nassert f(g()) == True\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 312, "target_skills": [1, 1, 1, 0, 0, 0, 0, 1, 0, 1], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome after removing a single character.\n    \"\"\"\n    def is_palindrome(s, left, right):\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n    \n    left = 0\n    right = len(s) - 1\n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s, left + 1, right) or is_palindrome(s, left, right - 1)\n        left += 1\n        right -= 1\n    return True", "solution_func": "def g(s=\"level\"):\n    return s", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n    \"\"\"\n    def max_subarray_sum(nums, left, right):\n        if left == right:\n            return nums[left]\n        mid = (left + right) // 2\n        left_sum = max_subarray_sum(nums, left, mid)\n        right_sum = max_subarray_sum(nums, mid + 1, right)\n        cross_sum = cross_max_subarray_sum(nums, left, mid, right)\n        return max(left_sum, right_sum, cross_sum)\n    \n    def cross_max_subarray_sum(nums, left, mid, right):\n        left_sum = float('-inf')\n        curr_sum = 0\n        for i in range(mid, left - 1, -1):\n            curr_sum += nums[i]\n            left_sum = max(left_sum, curr_sum)\n        \n        right_sum = float('-inf')\n        curr_sum = 0\n        for i in range(mid + 1, right + 1):\n            curr_sum += nums[i]\n            right_sum = max(right_sum, curr_sum)\n        \n        return left_sum + right_sum\n    \n    return max_subarray_sum(nums, 0, len(nums) - 1)\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\n\nassert f(g()) == 6\n", "emb": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "idx_generation": 312, "target_skills": [0, 0, 1, 1, 1, 1, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n    \"\"\"\n    def max_subarray_sum(nums, left, right):\n        if left == right:\n            return nums[left]\n        mid = (left + right) // 2\n        left_sum = max_subarray_sum(nums, left, mid)\n        right_sum = max_subarray_sum(nums, mid + 1, right)\n        cross_sum = cross_max_subarray_sum(nums, left, mid, right)\n        return max(left_sum, right_sum, cross_sum)\n    \n    def cross_max_subarray_sum(nums, left, mid, right):\n        left_sum = float('-inf')\n        curr_sum = 0\n        for i in range(mid, left - 1, -1):\n            curr_sum += nums[i]\n            left_sum = max(left_sum, curr_sum)\n        \n        right_sum = float('-inf')\n        curr_sum = 0\n        for i in range(mid + 1, right + 1):\n            curr_sum += nums[i]\n            right_sum = max(right_sum, curr_sum)\n        \n        return left_sum + right_sum\n    \n    return max_subarray_sum(nums, 0, len(nums) - 1)", "solution_func": "def g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums", "map_ix": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers 'arr', determine if there exists a subarray whose sum is a perfect square.\n\n    Args:\n    - arr: A list of integers.\n\n    Returns:\n    - True if there exists a subarray whose sum is a perfect square, False otherwise.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n\n    Output:\n    True\n\n    Explanation:\n    The subarray [3, 4] has a sum of 7, which is a perfect square (3^2 = 9).\n    \"\"\"\n\n    prefix_sum = 0\n    sum_map = {0: 0}\n\n    for i in range(len(arr)):\n        prefix_sum += arr[i]\n        if prefix_sum in sum_map:\n            return True\n        sum_map[prefix_sum] = i + 1\n\n        for j in range(1, int(prefix_sum ** 0.5) + 1):\n            if (prefix_sum - j * j) in sum_map:\n                return True\n\n    return False\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for the function f.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == True\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 312, "target_skills": [0, 1, 0, 1, 0, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers 'arr', determine if there exists a subarray whose sum is a perfect square.\n\n    Args:\n    - arr: A list of integers.\n\n    Returns:\n    - True if there exists a subarray whose sum is a perfect square, False otherwise.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n\n    Output:\n    True\n\n    Explanation:\n    The subarray [3, 4] has a sum of 7, which is a perfect square (3^2 = 9).\n    \"\"\"\n\n    prefix_sum = 0\n    sum_map = {0: 0}\n\n    for i in range(len(arr)):\n        prefix_sum += arr[i]\n        if prefix_sum in sum_map:\n            return True\n        sum_map[prefix_sum] = i + 1\n\n        for j in range(1, int(prefix_sum ** 0.5) + 1):\n            if (prefix_sum - j * j) in sum_map:\n                return True\n\n    return False", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for the function f.\n    \"\"\"\n    return [1, 2, 3, 4, 5]", "map_ix": [1, 1, 0, 1, 0, 0, 1, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int, nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums and a positive integer n, find the number of subarrays that have a sum less than or equal to n.\n\n    Example:\n    n = 4\n    k = 3\n    nums = [1, 2, 3, 4]\n\n    Output:\n    4\n\n    Explanation:\n    The subarrays with a sum less than or equal to 3 are:\n    [1], [2], [1, 2], [3]\n    \"\"\"\n    count = 0\n    prefix_sum = 0\n    queue = []\n    \n    for num in nums:\n        prefix_sum += num\n        \n        if prefix_sum <= n:\n            count += 1\n        \n        while queue and prefix_sum - queue[0] > n:\n            prefix_sum -= queue.pop(0)\n            count -= 1\n        \n        queue.append(num)\n    \n    return count\n\ndef g(n: int = 4, k: int = 3, nums: List[int] = [1, 2, 3, 4]):\n    return (n, k, nums,)\n\nassert f(*g()) == 4\n\n", "emb": null, "idx_generation": 313, "target_skills": [0, 1, 1, 1, 0, 1, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int, nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums and a positive integer n, find the number of subarrays that have a sum less than or equal to n.\n\n    Example:\n    n = 4\n    k = 3\n    nums = [1, 2, 3, 4]\n\n    Output:\n    4\n\n    Explanation:\n    The subarrays with a sum less than or equal to 3 are:\n    [1], [2], [1, 2], [3]\n    \"\"\"\n    count = 0\n    prefix_sum = 0\n    queue = []\n    \n    for num in nums:\n        prefix_sum += num\n        \n        if prefix_sum <= n:\n            count += 1\n        \n        while queue and prefix_sum - queue[0] > n:\n            prefix_sum -= queue.pop(0)\n            count -= 1\n        \n        queue.append(num)\n    \n    return count", "solution_func": "def g(n: int = 4, k: int = 3, nums: List[int] = [1, 2, 3, 4]):\n    return (n, k, nums,)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of three numbers from the list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    24\n\n    Explanation:\n    The maximum product of three numbers is 2 * 3 * 4 = 24.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    \n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g(nums: List[int] = [1, 2, 3, 4]):\n    return (nums,)\n\nassert f(*g()) == 24\n\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 313, "target_skills": [1, 1, 0, 0, 0, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of three numbers from the list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    24\n\n    Explanation:\n    The maximum product of three numbers is 2 * 3 * 4 = 24.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    \n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])", "solution_func": "def g(nums: List[int] = [1, 2, 3, 4]):\n    return (nums,)", "map_ix": [1, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, s: str) -> str:\n    \"\"\"\n    Given a positive integer n and a string s, find the lexicographically smallest subsequence of length n that can be formed from the characters of s.\n\n    Example:\n    n = 3\n    s = \"abcd\"\n\n    Output:\n    \"abc\"\n\n    Explanation:\n    The lexicographically smallest subsequence of length 3 that can be formed from the characters of \"abcd\" is \"abc\".\n    \"\"\"\n    stack = []\n    remaining = len(s)\n    \n    for i, char in enumerate(s):\n        while stack and stack[-1] > char and remaining - len(stack) >= n:\n            stack.pop()\n        \n        if len(stack) < n:\n            stack.append(char)\n            remaining -= 1\n        \n        if remaining == 0 or len(stack) == n:\n            break\n    \n    return ''.join(stack)\n\ndef g(n: int = 3, s: str = \"abcd\"):\n    return (n, s,)\n\nassert f(*g()) == \"abc\"\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 313, "target_skills": [1, 0, 0, 1, 0, 1, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, s: str) -> str:\n    \"\"\"\n    Given a positive integer n and a string s, find the lexicographically smallest subsequence of length n that can be formed from the characters of s.\n\n    Example:\n    n = 3\n    s = \"abcd\"\n\n    Output:\n    \"abc\"\n\n    Explanation:\n    The lexicographically smallest subsequence of length 3 that can be formed from the characters of \"abcd\" is \"abc\".\n    \"\"\"\n    stack = []\n    remaining = len(s)\n    \n    for i, char in enumerate(s):\n        while stack and stack[-1] > char and remaining - len(stack) >= n:\n            stack.pop()\n        \n        if len(stack) < n:\n            stack.append(char)\n            remaining -= 1\n        \n        if remaining == 0 or len(stack) == n:\n            break\n    \n    return ''.join(stack)", "solution_func": "def g(n: int = 3, s: str = \"abcd\"):\n    return (n, s,)", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers 'arr', return a new list where each element is the square of the original element.\n    The new list should be sorted in non-decreasing order.\n\n    Example:\n    arr = [5, 2, 9, 8, 3]\n\n    Output:\n    [4, 9, 25, 64, 81]\n    \"\"\"\n    return sorted([num**2 for num in arr])\n\ndef g():\n    return [5, 2, 9, 8, 3]\n\nassert f(g()) == [4, 9, 25, 64, 81]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 313, "target_skills": [1, 1, 0, 1, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers 'arr', return a new list where each element is the square of the original element.\n    The new list should be sorted in non-decreasing order.\n\n    Example:\n    arr = [5, 2, 9, 8, 3]\n\n    Output:\n    [4, 9, 25, 64, 81]\n    \"\"\"\n    return sorted([num**2 for num in arr])", "solution_func": "def g():\n    return [5, 2, 9, 8, 3]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of different ways to choose k objects from a set of n objects.\n    The order of the objects does not matter.\n\n    Example:\n    n = 5, k = 3\n\n    Output:\n    10\n    \"\"\"\n    def factorial(num: int) -> int:\n        if num == 0 or num == 1:\n            return 1\n        return num * factorial(num-1)\n    \n    return factorial(n) // (factorial(k) * factorial(n-k))\n\ndef g():\n    return 5, 3\n\nassert f(*g()) == 10\n", "emb": null, "idx_generation": 313, "target_skills": [1, 1, 0, 0, 1, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of different ways to choose k objects from a set of n objects.\n    The order of the objects does not matter.\n\n    Example:\n    n = 5, k = 3\n\n    Output:\n    10\n    \"\"\"\n    def factorial(num: int) -> int:\n        if num == 0 or num == 1:\n            return 1\n        return num * factorial(num-1)\n    \n    return factorial(n) // (factorial(k) * factorial(n-k))", "solution_func": "def g():\n    return 5, 3", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(string: str) -> str:\n    \"\"\"\n    Given a string, return a new string where each occurrence of the word 'not' has been replaced by 'good'.\n\n    Example:\n    string = \"This is not good, this is not acceptable.\"\n\n    Output:\n    \"This is good, this is good acceptable.\"\n    \"\"\"\n    return string.replace('not', 'good')\n\ndef g():\n    return \"This is not good, this is not acceptable.\"\n\nassert f(g()) == \"This is good, this is good acceptable.\"\n", "emb": null, "idx_generation": 313, "target_skills": [0, 0, 0, 0, 0, 1, 0, 1, 0, 1], "problem_func": "from typing import*\ndef f(string: str) -> str:\n    \"\"\"\n    Given a string, return a new string where each occurrence of the word 'not' has been replaced by 'good'.\n\n    Example:\n    string = \"This is not good, this is not acceptable.\"\n\n    Output:\n    \"This is good, this is good acceptable.\"\n    \"\"\"\n    return string.replace('not', 'good')", "solution_func": "def g():\n    return \"This is not good, this is not acceptable.\"", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> Tuple[int, int]:\n    \"\"\"\n    Given a sorted array of integers and a target value, find two numbers in the array that add up to the target.\n\n    Example:\n    arr = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    (2, 7)\n    \"\"\"\n    left, right = 0, len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return (arr[left], arr[right])\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return ()\n\ndef g():\n    arr = [2, 7, 11, 15]\n    target = 9\n    return arr, target\n\nassert f(*g()) == (2, 7)\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 313, "target_skills": [1, 1, 0, 1, 1, 0, 0, 0, 0, 1], "problem_func": "from typing import*\ndef f(arr: List[int], target: int) -> Tuple[int, int]:\n    \"\"\"\n    Given a sorted array of integers and a target value, find two numbers in the array that add up to the target.\n\n    Example:\n    arr = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    (2, 7)\n    \"\"\"\n    left, right = 0, len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return (arr[left], arr[right])\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return ()", "solution_func": "def g():\n    arr = [2, 7, 11, 15]\n    target = 9\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the n-th Fibonacci number.\n\n    Example:\n    n = 5\n\n    Output:\n    3\n    \"\"\"\n    if n <= 1:\n        return n\n\n    prev, curr = 0, 1\n    for _ in range(2, n + 1):\n        prev, curr = curr, prev + curr\n\n    return curr\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == 3\n", "emb": null, "idx_generation": 313, "target_skills": [0, 1, 0, 0, 1, 1, 0, 1, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the n-th Fibonacci number.\n\n    Example:\n    n = 5\n\n    Output:\n    3\n    \"\"\"\n    if n <= 1:\n        return n\n\n    prev, curr = 0, 1\n    for _ in range(2, n + 1):\n        prev, curr = curr, prev + curr\n\n    return curr", "solution_func": "def g():\n    n = 5\n    return n", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, return the reverse of the string.\n\n    Example:\n    s = \"hello\"\n\n    Output:\n    \"olleh\"\n    \"\"\"\n    return s[::-1]\n\ndef g():\n    s = \"hello\"\n    return s\n\nassert f(g()) == \"olleh\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 313, "target_skills": [1, 1, 1, 1, 1, 0, 0, 1, 1, 1], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, return the reverse of the string.\n\n    Example:\n    s = \"hello\"\n\n    Output:\n    \"olleh\"\n    \"\"\"\n    return s[::-1]", "solution_func": "def g():\n    s = \"hello\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if the list is sorted in non-decreasing order.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    \n    Output:\n    True\n\n    Explanation:\n    The list is sorted in non-decreasing order.\n\n    Hint: Compare each element with its next element to check if the list is sorted.\n    \"\"\"\n    for i in range(len(arr)-1):\n        if arr[i] > arr[i+1]:\n            return False\n    return True\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5]\n\nassert f(g())\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 313, "target_skills": [0, 0, 1, 1, 0, 1, 0, 1, 1, 1], "problem_func": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if the list is sorted in non-decreasing order.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    \n    Output:\n    True\n\n    Explanation:\n    The list is sorted in non-decreasing order.\n\n    Hint: Compare each element with its next element to check if the list is sorted.\n    \"\"\"\n    for i in range(len(arr)-1):\n        if arr[i] > arr[i+1]:\n            return False\n    return True", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3, 4, 5]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nimport math\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a perfect square.\n    A perfect square is a number that can be expressed as the product of two equal integers.\n\n    Example:\n    n = 16\n\n    Output:\n    True\n\n    Explanation:\n    16 is a perfect square because it can be expressed as 4 * 4.\n    \"\"\"\n    if n < 0:\n        return False\n\n    sqrt = math.isqrt(n)\n    return sqrt * sqrt == n\n\ndef g() -> int:\n    n = 16\n    return n\n\nassert f(g())\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 314, "target_skills": [0, 0, 0, 1, 0, 0, 1, 0, 1, 1], "problem_func": "from typing import*\nimport math\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a perfect square.\n    A perfect square is a number that can be expressed as the product of two equal integers.\n\n    Example:\n    n = 16\n\n    Output:\n    True\n\n    Explanation:\n    16 is a perfect square because it can be expressed as 4 * 4.\n    \"\"\"\n    if n < 0:\n        return False\n\n    sqrt = math.isqrt(n)\n    return sqrt * sqrt == n", "solution_func": "def g() -> int:\n    n = 16\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and a target number, find two numbers in the array that add up to the target.\n    Return a list containing the indices of the two numbers.\n\n    Example:\n    arr = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    2 + 7 = 9, so the indices of the two numbers are 0 and 1.\n    \"\"\"\n    complement_indices = {}\n    for i, num in enumerate(arr):\n        complement = target - num\n        if complement in complement_indices:\n            return [complement_indices[complement], i]\n        complement_indices[num] = i\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    arr = [2, 7, 11, 15]\n    target = 9\n    return arr, target\n\nassert f(*g()) == [0, 1]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 314, "target_skills": [0, 0, 0, 0, 0, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and a target number, find two numbers in the array that add up to the target.\n    Return a list containing the indices of the two numbers.\n\n    Example:\n    arr = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    2 + 7 = 9, so the indices of the two numbers are 0 and 1.\n    \"\"\"\n    complement_indices = {}\n    for i, num in enumerate(arr):\n        complement = target - num\n        if complement in complement_indices:\n            return [complement_indices[complement], i]\n        complement_indices[num] = i\n\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    arr = [2, 7, 11, 15]\n    target = 9\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid represented by a 2D list of integers, find the minimum path sum from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum path sum from the top-left cell (1) to the bottom-right cell (1) is 7.\n    The path is: 1 -> 3 -> 1 -> 1 -> 1.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 314, "target_skills": [0, 0, 1, 0, 1, 0, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid represented by a 2D list of integers, find the minimum path sum from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum path sum from the top-left cell (1) to the bottom-right cell (1) is 7.\n    The path is: 1 -> 3 -> 1 -> 1 -> 1.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Determine if a given string s is a palindrome.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n    \"\"\"\n    stack = []\n    queue = []\n    for c in s:\n        if c.isalnum():\n            stack.append(c.lower())\n            queue.append(c.lower())\n    \n    while stack and queue:\n        if stack.pop() != queue.pop(0):\n            return False\n    \n    return True\n\ndef g() -> str:\n    return \"A man, a plan, a canal: Panama\"\n\nassert f(g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 314, "target_skills": [0, 0, 1, 0, 1, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Determine if a given string s is a palindrome.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n    \"\"\"\n    stack = []\n    queue = []\n    for c in s:\n        if c.isalnum():\n            stack.append(c.lower())\n            queue.append(c.lower())\n    \n    while stack and queue:\n        if stack.pop() != queue.pop(0):\n            return False\n    \n    return True", "solution_func": "def g() -> str:\n    return \"A man, a plan, a canal: Panama\"", "map_ix": [1, 0, 0, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], target: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a target word, find all words from the list that can be formed by rearranging the letters of the target word.\n    \"\"\"\n    def backtrack(word: str, remaining: List[str], path: List[str], res: List[str]) -> None:\n        if not remaining:\n            res.append(\"\".join(path))\n            return\n        \n        for i in range(len(remaining)):\n            if sorted(word) == sorted(remaining[i]):\n                path.append(remaining[i])\n                backtrack(word, remaining[:i] + remaining[i+1:], path, res)\n                path.pop()\n    \n    res = []\n    backtrack(target, words, [], res)\n    return res\n\ndef g() -> Tuple[List[str], str]:\n    return ([\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"], \"ate\")\n\nassert f(*g()) == [\"eat\", \"tea\", \"ate\"]\n", "emb": null, "idx_generation": 314, "target_skills": [0, 1, 0, 1, 1, 1, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], target: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a target word, find all words from the list that can be formed by rearranging the letters of the target word.\n    \"\"\"\n    def backtrack(word: str, remaining: List[str], path: List[str], res: List[str]) -> None:\n        if not remaining:\n            res.append(\"\".join(path))\n            return\n        \n        for i in range(len(remaining)):\n            if sorted(word) == sorted(remaining[i]):\n                path.append(remaining[i])\n                backtrack(word, remaining[:i] + remaining[i+1:], path, res)\n                path.pop()\n    \n    res = []\n    backtrack(target, words, [], res)\n    return res", "solution_func": "def g() -> Tuple[List[str], str]:\n    return ([\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"], \"ate\")", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort them in descending order using a stack.\n    \"\"\"\n    stack = []\n    for num in nums:\n        while stack and num > stack[-1]:\n            nums.append(stack.pop())\n        stack.append(num)\n    \n    return stack[::-1]\n\ndef g() -> List[int]:\n    return [4, 2, 9, 6, 1, 7, 5]\n\nassert f(g()) == [9, 7, 6, 5, 4, 2, 1]\n", "emb": null, "idx_generation": 314, "target_skills": [0, 1, 1, 0, 0, 0, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort them in descending order using a stack.\n    \"\"\"\n    stack = []\n    for num in nums:\n        while stack and num > stack[-1]:\n            nums.append(stack.pop())\n        stack.append(num)\n    \n    return stack[::-1]", "solution_func": "def g() -> List[int]:\n    return [4, 2, 9, 6, 1, 7, 5]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given an adjacency matrix representation of an undirected graph,\n    perform a breadth-first search (BFS) and return the shortest path between two vertices.\n    \"\"\"\n    n = len(graph)\n    queue = [[0]]\n    visited = [False] * n\n\n    while queue:\n        path = queue.pop(0)\n        node = path[-1]\n\n        if node == n - 1:\n            return path\n\n        for neighbor in range(n):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                visited[neighbor] = True\n                new_path = path + [neighbor]\n                queue.append(new_path)\n\n    return []\n\ndef g(graph: List[List[int]] = [[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 0], [0, 1, 0, 0]]):\n    return graph\n\nassert f(*g()) == [0, 1, 3]\n\n", "emb": null, "idx_generation": 314, "target_skills": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given an adjacency matrix representation of an undirected graph,\n    perform a breadth-first search (BFS) and return the shortest path between two vertices.\n    \"\"\"\n    n = len(graph)\n    queue = [[0]]\n    visited = [False] * n\n\n    while queue:\n        path = queue.pop(0)\n        node = path[-1]\n\n        if node == n - 1:\n            return path\n\n        for neighbor in range(n):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                visited[neighbor] = True\n                new_path = path + [neighbor]\n                queue.append(new_path)\n\n    return []", "solution_func": "def g(graph: List[List[int]] = [[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 0], [0, 1, 0, 0]]):\n    return graph", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of valid parentheses expressions of length 2n.\n    A valid parentheses expression must have an opening parenthesis '(' followed by a closing parenthesis ')'.\n    \"\"\"\n    if n == 0:\n        return 1\n\n    count = 0\n    for i in range(n):\n        count += f(i) * f(n - i - 1)\n\n    return count\n\ndef g(n: int = 3):\n    return n\n\nassert f(g()) == 5\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 314, "target_skills": [0, 0, 0, 0, 0, 0, 0, 1, 0, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of valid parentheses expressions of length 2n.\n    A valid parentheses expression must have an opening parenthesis '(' followed by a closing parenthesis ')'.\n    \"\"\"\n    if n == 0:\n        return 1\n\n    count = 0\n    for i in range(n):\n        count += f(i) * f(n - i - 1)\n\n    return count", "solution_func": "def g(n: int = 3):\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of 0s and 1s, find the maximum size of a square submatrix where all elements are 1s.\n    \"\"\"\n    if not matrix:\n        return 0\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n    max_size = 0\n\n    dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            if matrix[i - 1][j - 1] == 1:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                max_size = max(max_size, dp[i][j])\n\n    return max_size\n\ndef g(matrix: List[List[int]] = [[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]):\n    return matrix\n\nassert f(*g()) == 3\n\n", "emb": null, "idx_generation": 314, "target_skills": [0, 1, 0, 0, 1, 0, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of 0s and 1s, find the maximum size of a square submatrix where all elements are 1s.\n    \"\"\"\n    if not matrix:\n        return 0\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n    max_size = 0\n\n    dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            if matrix[i - 1][j - 1] == 1:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                max_size = max(max_size, dp[i][j])\n\n    return max_size", "solution_func": "def g(matrix: List[List[int]] = [[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]):\n    return matrix", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph, determine if it is a tree.\n\n    An undirected graph is a tree if it is connected and contains no cycles.\n\n    Parameters:\n    graph (List[List[int]]): The adjacency list representation of the graph.\n\n    Returns:\n    bool: True if the graph is a tree, False otherwise.\n    \"\"\"\n\n    def dfs(node, parent):\n        visited.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor == parent:\n                continue\n            if neighbor in visited:\n                return False\n            if not dfs(neighbor, node):\n                return False\n\n        return True\n\n    n = len(graph)\n    visited = set()\n\n    if not dfs(0, -1):\n        return False\n\n    if len(visited) != n:\n        return False\n\n    return True\n\ndef g(graph=[\n    [1, 2],\n    [0, 3, 4],\n    [0, 5],\n    [1],\n    [1],\n    [2]\n]) -> List[List[int]]:\n    return graph\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 314, "target_skills": [1, 0, 0, 0, 1, 1, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph, determine if it is a tree.\n\n    An undirected graph is a tree if it is connected and contains no cycles.\n\n    Parameters:\n    graph (List[List[int]]): The adjacency list representation of the graph.\n\n    Returns:\n    bool: True if the graph is a tree, False otherwise.\n    \"\"\"\n\n    def dfs(node, parent):\n        visited.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor == parent:\n                continue\n            if neighbor in visited:\n                return False\n            if not dfs(neighbor, node):\n                return False\n\n        return True\n\n    n = len(graph)\n    visited = set()\n\n    if not dfs(0, -1):\n        return False\n\n    if len(visited) != n:\n        return False\n\n    return True", "solution_func": "def g(graph=[\n    [1, 2],\n    [0, 3, 4],\n    [0, 5],\n    [1],\n    [1],\n    [2]\n]) -> List[List[int]]:\n    return graph", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the factorial of n.\n    Return the factorial value.\n\n    Sample input:\n    n = 5\n\n    Sample output:\n    120\n    \"\"\"\n    if n == 0:\n        return 1\n    else:\n        return n * f(n-1)\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 120\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 315, "target_skills": [0, 1, 0, 1, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the factorial of n.\n    Return the factorial value.\n\n    Sample input:\n    n = 5\n\n    Sample output:\n    120\n    \"\"\"\n    if n == 0:\n        return 1\n    else:\n        return n * f(n-1)", "solution_func": "def g(n=5):\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, check if it is a palindrome.\n    Return True if s is a palindrome, False otherwise.\n\n    Sample input:\n    s = \"level\"\n\n    Sample output:\n    True\n    \"\"\"\n    return s == s[::-1]\n\ndef g(s=\"level\"):\n    return s\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 315, "target_skills": [1, 1, 1, 1, 1, 1, 0, 0, 0, 1], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, check if it is a palindrome.\n    Return True if s is a palindrome, False otherwise.\n\n    Sample input:\n    s = \"level\"\n\n    Sample output:\n    True\n    \"\"\"\n    return s == s[::-1]", "solution_func": "def g(s=\"level\"):\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"\n    Given an integer num, return the number of set bits (1s) in its binary representation.\n\n    Sample input:\n    num = 10\n\n    Sample output:\n    2\n    \"\"\"\n    count = 0\n    while num:\n        count += num & 1\n        num >>= 1\n    return count\n\ndef g(num=10):\n    return num\n\nassert f(g()) == 2\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 315, "target_skills": [0, 0, 1, 1, 0, 1, 1, 1, 1, 1], "problem_func": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"\n    Given an integer num, return the number of set bits (1s) in its binary representation.\n\n    Sample input:\n    num = 10\n\n    Sample output:\n    2\n    \"\"\"\n    count = 0\n    while num:\n        count += num & 1\n        num >>= 1\n    return count", "solution_func": "def g(num=10):\n    return num", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target number, find the number of occurrences of the target number in the list.\n\n    Args:\n    - nums: A sorted list of integers.\n    - target: The target number to search for.\n\n    Returns:\n    - The number of occurrences of the target number in the list.\n    \"\"\"\n\n    def binary_search_left(nums: List[int], target: int) -> int:\n        \"\"\"\n        Perform binary search to find the leftmost occurrence of the target number in the list.\n\n        Args:\n        - nums: A sorted list of integers.\n        - target: The target number to search for.\n\n        Returns:\n        - The index of the leftmost occurrence of the target number in the list, or -1 if not found.\n        \"\"\"\n        left = 0\n        right = len(nums) - 1\n        result = -1\n\n        while left <= right:\n            mid = (left + right) // 2\n\n            if nums[mid] == target:\n                result = mid\n                right = mid - 1\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return result\n\n    def binary_search_right(nums: List[int], target: int) -> int:\n        \"\"\"\n        Perform binary search to find the rightmost occurrence of the target number in the list.\n\n        Args:\n        - nums: A sorted list of integers.\n        - target: The target number to search for.\n\n        Returns:\n        - The index of the rightmost occurrence of the target number in the list, or -1 if not found.\n        \"\"\"\n        left = 0\n        right = len(nums) - 1\n        result = -1\n\n        while left <= right:\n            mid = (left + right) // 2\n\n            if nums[mid] == target:\n                result = mid\n                left = mid + 1\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return result\n\n    left_index = binary_search_left(nums, target)\n    right_index = binary_search_right(nums, target)\n\n    if left_index == -1 or right_index == -1:\n        return 0\n\n    return right_index - left_index + 1\n\ndef g() -> List[int]:\n    nums = [1, 1, 2, 2, 2, 3, 3, 4, 5, 5, 5]\n    target = 2\n    return nums, target\n\nassert f(*g()) == 3\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 315, "target_skills": [0, 0, 1, 0, 1, 0, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target number, find the number of occurrences of the target number in the list.\n\n    Args:\n    - nums: A sorted list of integers.\n    - target: The target number to search for.\n\n    Returns:\n    - The number of occurrences of the target number in the list.\n    \"\"\"\n\n    def binary_search_left(nums: List[int], target: int) -> int:\n        \"\"\"\n        Perform binary search to find the leftmost occurrence of the target number in the list.\n\n        Args:\n        - nums: A sorted list of integers.\n        - target: The target number to search for.\n\n        Returns:\n        - The index of the leftmost occurrence of the target number in the list, or -1 if not found.\n        \"\"\"\n        left = 0\n        right = len(nums) - 1\n        result = -1\n\n        while left <= right:\n            mid = (left + right) // 2\n\n            if nums[mid] == target:\n                result = mid\n                right = mid - 1\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return result\n\n    def binary_search_right(nums: List[int], target: int) -> int:\n        \"\"\"\n        Perform binary search to find the rightmost occurrence of the target number in the list.\n\n        Args:\n        - nums: A sorted list of integers.\n        - target: The target number to search for.\n\n        Returns:\n        - The index of the rightmost occurrence of the target number in the list, or -1 if not found.\n        \"\"\"\n        left = 0\n        right = len(nums) - 1\n        result = -1\n\n        while left <= right:\n            mid = (left + right) // 2\n\n            if nums[mid] == target:\n                result = mid\n                left = mid + 1\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return result\n\n    left_index = binary_search_left(nums, target)\n    right_index = binary_search_right(nums, target)\n\n    if left_index == -1 or right_index == -1:\n        return 0\n\n    return right_index - left_index + 1", "solution_func": "def g() -> List[int]:\n    nums = [1, 1, 2, 2, 2, 3, 3, 4, 5, 5, 5]\n    target = 2\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of any path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Args:\n    - grid: A 2D grid of integers.\n\n    Returns:\n    - The maximum sum of any path from the top-left cell to the bottom-right cell.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 9\n", "emb": null, "idx_generation": 315, "target_skills": [0, 1, 0, 0, 0, 0, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of any path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Args:\n    - grid: A 2D grid of integers.\n\n    Returns:\n    - The maximum sum of any path from the top-left cell to the bottom-right cell.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]", "solution_func": "def g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers n and m, find the number of ways to reach the point (n, m) from the point (0, 0) by only moving right or up.\n    You can only move right or up.\n\n    Args:\n    - n: The number of rows.\n    - m: The number of columns.\n\n    Returns:\n    - The number of ways to reach the point (n, m) from the point (0, 0).\n    \"\"\"\n\n    def factorial(num: int) -> int:\n        \"\"\"\n        Compute the factorial of a number.\n\n        Args:\n        - num: An integer.\n\n        Returns:\n        - The factorial of the number.\n        \"\"\"\n        result = 1\n\n        for i in range(1, num+1):\n            result *= i\n\n        return result\n\n    def combinations(n: int, r: int) -> int:\n        \"\"\"\n        Compute the number of combinations of n choose r.\n\n        Args:\n        - n: An integer.\n        - r: An integer.\n\n        Returns:\n        - The number of combinations of n choose r.\n        \"\"\"\n        return factorial(n) // (factorial(r) * factorial(n-r))\n\n    return combinations(n+m-2, n-1)\n\ndef g() -> List[int]:\n    n = 3\n    m = 4\n    return n, m\n\nassert f(*g()) == 10\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 315, "target_skills": [0, 1, 0, 1, 0, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers n and m, find the number of ways to reach the point (n, m) from the point (0, 0) by only moving right or up.\n    You can only move right or up.\n\n    Args:\n    - n: The number of rows.\n    - m: The number of columns.\n\n    Returns:\n    - The number of ways to reach the point (n, m) from the point (0, 0).\n    \"\"\"\n\n    def factorial(num: int) -> int:\n        \"\"\"\n        Compute the factorial of a number.\n\n        Args:\n        - num: An integer.\n\n        Returns:\n        - The factorial of the number.\n        \"\"\"\n        result = 1\n\n        for i in range(1, num+1):\n            result *= i\n\n        return result\n\n    def combinations(n: int, r: int) -> int:\n        \"\"\"\n        Compute the number of combinations of n choose r.\n\n        Args:\n        - n: An integer.\n        - r: An integer.\n\n        Returns:\n        - The number of combinations of n choose r.\n        \"\"\"\n        return factorial(n) // (factorial(r) * factorial(n-r))\n\n    return combinations(n+m-2, n-1)", "solution_func": "def g() -> List[int]:\n    n = 3\n    m = 4\n    return n, m", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the length of the longest path of consecutive 1s.\n    A path consists of adjacent 1s (horizontally or vertically).\n    \n    Example:\n    grid = [\n        [1, 1, 0, 0],\n        [0, 1, 1, 1],\n        [1, 0, 0, 1],\n        [1, 1, 1, 1]\n    ]\n    \n    Output:\n    4 (the longest path of consecutive 1s is 1 -> 1 -> 1 -> 1)\n    \"\"\"\n    def dfs(grid: List[List[int]], row: int, col: int, path_length: int) -> int:\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] == 0:\n            return path_length\n        \n        grid[row][col] = 0\n        path_length += 1\n        \n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        max_length = path_length\n        \n        for dx, dy in directions:\n            max_length = max(max_length, dfs(grid, row + dx, col + dy, path_length))\n        \n        return max_length\n    \n    max_path_length = 0\n    \n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                max_path_length = max(max_path_length, dfs(grid, i, j, 0))\n    \n    return max_path_length\n\ndef g(grid: List[List[int]]):\n    return grid\n\nassert f(g([[1, 1, 0, 0], [0, 1, 1, 1], [1, 0, 0, 1], [1, 1, 1, 1]])) == 4\n", "emb": null, "idx_generation": 315, "target_skills": [1, 1, 0, 1, 1, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the length of the longest path of consecutive 1s.\n    A path consists of adjacent 1s (horizontally or vertically).\n    \n    Example:\n    grid = [\n        [1, 1, 0, 0],\n        [0, 1, 1, 1],\n        [1, 0, 0, 1],\n        [1, 1, 1, 1]\n    ]\n    \n    Output:\n    4 (the longest path of consecutive 1s is 1 -> 1 -> 1 -> 1)\n    \"\"\"\n    def dfs(grid: List[List[int]], row: int, col: int, path_length: int) -> int:\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] == 0:\n            return path_length\n        \n        grid[row][col] = 0\n        path_length += 1\n        \n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        max_length = path_length\n        \n        for dx, dy in directions:\n            max_length = max(max_length, dfs(grid, row + dx, col + dy, path_length))\n        \n        return max_length\n    \n    max_path_length = 0\n    \n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                max_path_length = max(max_path_length, dfs(grid, i, j, 0))\n    \n    return max_path_length", "solution_func": "def g(grid: List[List[int]]):\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n    \n    Example:\n    s = \"abcabcbb\"\n    \n    Output:\n    3 (the longest substring without repeating characters is \"abc\")\n    \"\"\"\n    max_length = 0\n    start = 0\n    char_to_index = {}\n    \n    for i in range(len(s)):\n        if s[i] in char_to_index:\n            start = max(start, char_to_index[s[i]] + 1)\n        \n        char_to_index[s[i]] = i\n        max_length = max(max_length, i - start + 1)\n    \n    return max_length\n\ndef g(s: str):\n    return s\n\nassert f(g(\"abcabcbb\")) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 315, "target_skills": [1, 0, 1, 0, 1, 0, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n    \n    Example:\n    s = \"abcabcbb\"\n    \n    Output:\n    3 (the longest substring without repeating characters is \"abc\")\n    \"\"\"\n    max_length = 0\n    start = 0\n    char_to_index = {}\n    \n    for i in range(len(s)):\n        if s[i] in char_to_index:\n            start = max(start, char_to_index[s[i]] + 1)\n        \n        char_to_index[s[i]] = i\n        max_length = max(max_length, i - start + 1)\n    \n    return max_length", "solution_func": "def g(s: str):\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    12 (since the maximum sum path is 1 + 3 + 5 + 1 + 2 + 1 = 12)\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g():\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 12\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 315, "target_skills": [1, 1, 0, 0, 1, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    12 (since the maximum sum path is 1 + 3 + 5 + 1 + 2 + 1 = 12)\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]", "solution_func": "def g():\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers from the list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    24\n\n    Explanation:\n    The maximum product of any three numbers from the list is 2 * 3 * 4 = 24.\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n\n    return max(nums[0] * nums[1] * nums[n - 1], nums[n - 3] * nums[n - 2] * nums[n - 1])\n\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4]\n    return [nums]\n\nassert f(g()) == 24\n\n", "emb": null, "idx_generation": 315, "target_skills": [0, 1, 0, 0, 1, 0, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers from the list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    24\n\n    Explanation:\n    The maximum product of any three numbers from the list is 2 * 3 * 4 = 24.\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n\n    return max(nums[0] * nums[1] * nums[n - 1], nums[n - 3] * nums[n - 2] * nums[n - 1])", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4]\n    return [nums]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, return the index of the target value if it is found in the list.\n    If the target value is not found, return -1.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(arr = [1, 3, 5, 7, 9], target = 5):\n    return arr, target\n\nassert f(*g()) == 2\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 316, "target_skills": [1, 0, 1, 0, 1, 1, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, return the index of the target value if it is found in the list.\n    If the target value is not found, return -1.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g(arr = [1, 3, 5, 7, 9], target = 5):\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer, count the number of set bits (1s) in its binary representation.\n    Return the count.\n    \"\"\"\n    count = 0\n    while n > 0:\n        if n & 1 == 1:\n            count += 1\n        n >>= 1\n    return count\n\ndef g(n = 10):\n    return n\n\nassert f(g()) == 2\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 316, "target_skills": [0, 1, 1, 1, 0, 1, 1, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer, count the number of set bits (1s) in its binary representation.\n    Return the count.\n    \"\"\"\n    count = 0\n    while n > 0:\n        if n & 1 == 1:\n            count += 1\n        n >>= 1\n    return count", "solution_func": "def g(n = 10):\n    return n", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Given two strings, check if they are anagrams of each other.\n    Return True if they are anagrams, otherwise return False.\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n\n    count = [0] * 26\n\n    for ch in s1:\n        count[ord(ch) - ord('a')] += 1\n\n    for ch in s2:\n        count[ord(ch) - ord('a')] -= 1\n\n    for c in count:\n        if c != 0:\n            return False\n\n    return True\n\ndef g(s1 = \"listen\", s2 = \"silent\"):\n    return s1, s2\n\nassert f(*g()) == True\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 316, "target_skills": [1, 0, 1, 0, 0, 1, 0, 0, 1, 1], "problem_func": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Given two strings, check if they are anagrams of each other.\n    Return True if they are anagrams, otherwise return False.\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n\n    count = [0] * 26\n\n    for ch in s1:\n        count[ord(ch) - ord('a')] += 1\n\n    for ch in s2:\n        count[ord(ch) - ord('a')] -= 1\n\n    for c in count:\n        if c != 0:\n            return False\n\n    return True", "solution_func": "def g(s1 = \"listen\", s2 = \"silent\"):\n    return s1, s2", "map_ix": [0, 1, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> int:\n    \"\"\"\n    Given a string s and a list of words, count the number of occurrences of each word in the string.\n\n    Example:\n    s = \"hello world hello\"\n    words = [\"hello\", \"world\"]\n    The word \"hello\" occurs 2 times and the word \"world\" occurs 1 time, so the output should be [2, 1].\n    \"\"\"\n    word_count = [0] * len(words)\n    for i, word in enumerate(words):\n        word_count[i] = s.count(word)\n    return word_count\n\ndef g(s: str = \"hello world hello\", words: List[str] = [\"hello\", \"world\"]) -> int:\n    \"\"\"Generate a string and a list of words.\"\"\"\n    return s, words\n\nassert f(*g()) == [2, 1]\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 316, "target_skills": [0, 0, 0, 1, 0, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> int:\n    \"\"\"\n    Given a string s and a list of words, count the number of occurrences of each word in the string.\n\n    Example:\n    s = \"hello world hello\"\n    words = [\"hello\", \"world\"]\n    The word \"hello\" occurs 2 times and the word \"world\" occurs 1 time, so the output should be [2, 1].\n    \"\"\"\n    word_count = [0] * len(words)\n    for i, word in enumerate(words):\n        word_count[i] = s.count(word)\n    return word_count", "solution_func": "def g(s: str = \"hello world hello\", words: List[str] = [\"hello\", \"world\"]) -> int:\n    \"\"\"Generate a string and a list of words.\"\"\"\n    return s, words", "map_ix": [1, 1, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the sum of all the elements in the matrix.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    The sum of all the elements in the matrix is 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45, so the output should be 45.\n    \"\"\"\n    total_sum = 0\n    for row in matrix:\n        total_sum += sum(row)\n    return total_sum\n\ndef g(matrix: List[List[int]] = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) -> int:\n    \"\"\"Generate a matrix of integers.\"\"\"\n    return matrix\n\nassert f(*g()) == 45\n", "emb": null, "idx_generation": 316, "target_skills": [0, 0, 1, 1, 0, 0, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the sum of all the elements in the matrix.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    The sum of all the elements in the matrix is 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45, so the output should be 45.\n    \"\"\"\n    total_sum = 0\n    for row in matrix:\n        total_sum += sum(row)\n    return total_sum", "solution_func": "def g(matrix: List[List[int]] = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) -> int:\n    \"\"\"Generate a matrix of integers.\"\"\"\n    return matrix", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str]) -> str:\n    \"\"\"\n    Given a list of strings, concatenate all the strings together.\n\n    Example:\n    strings = [\"Hello\", \"World\", \"!\"]\n    The concatenated string is \"HelloWorld!\", so the output should be \"HelloWorld!\".\n    \"\"\"\n    return ''.join(strings)\n\ndef g(strings: List[str] = [\"Hello\", \"World\", \"!\"]) -> str:\n    \"\"\"Generate a list of strings.\"\"\"\n    return strings\n\nassert f(*g()) == \"HelloWorld!\"\n", "emb": null, "idx_generation": 316, "target_skills": [1, 1, 0, 0, 1, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str]) -> str:\n    \"\"\"\n    Given a list of strings, concatenate all the strings together.\n\n    Example:\n    strings = [\"Hello\", \"World\", \"!\"]\n    The concatenated string is \"HelloWorld!\", so the output should be \"HelloWorld!\".\n    \"\"\"\n    return ''.join(strings)", "solution_func": "def g(strings: List[str] = [\"Hello\", \"World\", \"!\"]) -> str:\n    \"\"\"Generate a list of strings.\"\"\"\n    return strings", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target number, use binary search to find the index of the target in the list.\n    If the target is not found, return -1.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    target = 6\n\n    Output:\n    5\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    target = 6\n    return nums, target\n\nassert f(*g()) == 5\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 316, "target_skills": [0, 0, 1, 1, 1, 0, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target number, use binary search to find the index of the target in the list.\n    If the target is not found, return -1.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    target = 6\n\n    Output:\n    5\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    target = 6\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\n    Output:\n    8\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n    return grid\n\nassert f(g()) == 8\n\n", "emb": null, "idx_generation": 316, "target_skills": [0, 1, 0, 0, 0, 0, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\n    Output:\n    8\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g() -> List[List[int]]:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, return the longest substring that contains only unique characters.\n\n    Example:\n    s = \"abcabcbb\"\n\n    Output:\n    \"abc\"\n    \"\"\"\n    max_length = 0\n    start = 0\n    char_map = {}\n\n    for i, char in enumerate(s):\n        if char in char_map and start <= char_map[char]:\n            start = char_map[char] + 1\n        else:\n            max_length = max(max_length, i - start + 1)\n\n        char_map[char] = i\n\n    return s[start:start+max_length]\n\ndef g() -> str:\n    s = \"abcabcbb\"\n    return s\n\nassert f(g()) == \"abc\"\n\n", "emb": null, "idx_generation": 316, "target_skills": [0, 1, 1, 1, 0, 0, 1, 1, 1, 1], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, return the longest substring that contains only unique characters.\n\n    Example:\n    s = \"abcabcbb\"\n\n    Output:\n    \"abc\"\n    \"\"\"\n    max_length = 0\n    start = 0\n    char_map = {}\n\n    for i, char in enumerate(s):\n        if char in char_map and start <= char_map[char]:\n            start = char_map[char] + 1\n        else:\n            max_length = max(max_length, i - start + 1)\n\n        char_map[char] = i\n\n    return s[start:start+max_length]", "solution_func": "def g() -> str:\n    s = \"abcabcbb\"\n    return s", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nimport math\n\ndef f(string: str) -> int:\n    \"\"\"\n    Given a string of digits, return the sum of all the digits squared.\n    \n    Sample Input:\n    string = \"12345\"\n    \n    Sample Output:\n    55\n    \"\"\"\n    total = 0\n    for digit in string:\n        num = int(digit)\n        total += math.pow(num, 2)\n    return int(total)\n\ndef g() -> str:\n    string = \"12345\"\n    return string\n\nassert f(g()) == 55\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 316, "target_skills": [0, 0, 1, 0, 1, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nimport math\n\ndef f(string: str) -> int:\n    \"\"\"\n    Given a string of digits, return the sum of all the digits squared.\n    \n    Sample Input:\n    string = \"12345\"\n    \n    Sample Output:\n    55\n    \"\"\"\n    total = 0\n    for digit in string:\n        num = int(digit)\n        total += math.pow(num, 2)\n    return int(total)", "solution_func": "def g() -> str:\n    string = \"12345\"\n    return string", "map_ix": [0, 0, 0, 1, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    matrix = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    8\n\n    Explanation:\n    The maximum sum path is 1 -> 3 -> 1 -> 1 -> 1, which gives a sum of 8.\n    \"\"\"\n\n    m = len(matrix)\n    n = len(matrix[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = matrix[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    return dp[m-1][n-1]\n\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 8\n\n", "emb": null, "idx_generation": 317, "target_skills": [0, 0, 1, 1, 1, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    matrix = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    8\n\n    Explanation:\n    The maximum sum path is 1 -> 3 -> 1 -> 1 -> 1, which gives a sum of 8.\n    \"\"\"\n\n    m = len(matrix)\n    n = len(matrix[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = matrix[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\nclass Stack:\n    def __init__(self):\n        self.stack = []\n\n    def push(self, value):\n        self.stack.append(value)\n\n    def pop(self):\n        if self.is_empty():\n            return None\n        return self.stack.pop()\n\n    def peek(self):\n        if self.is_empty():\n            return None\n        return self.stack[-1]\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string containing parentheses, brackets, and braces, determine if they are balanced and properly nested.\n\n    Example:\n    s = \"{[()]}\"\n\n    Output:\n    True\n\n    Explanation:\n    The string contains balanced and properly nested parentheses, brackets, and braces.\n    \"\"\"\n\n    stack = Stack()\n\n    for char in s:\n        if char in ['(', '[', '{']:\n            stack.push(char)\n        elif char in [')', ']', '}']:\n            if stack.is_empty():\n                return False\n            top = stack.pop()\n            if (char == ')' and top != '(') or (char == ']' and top != '[') or (char == '}' and top != '{'):\n                return False\n\n    return stack.is_empty()\n\ndef g():\n    return \"{[()]}\"\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 317, "target_skills": [0, 0, 1, 0, 0, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\nclass Stack:\n    def __init__(self):\n        self.stack = []\n\n    def push(self, value):\n        self.stack.append(value)\n\n    def pop(self):\n        if self.is_empty():\n            return None\n        return self.stack.pop()\n\n    def peek(self):\n        if self.is_empty():\n            return None\n        return self.stack[-1]\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string containing parentheses, brackets, and braces, determine if they are balanced and properly nested.\n\n    Example:\n    s = \"{[()]}\"\n\n    Output:\n    True\n\n    Explanation:\n    The string contains balanced and properly nested parentheses, brackets, and braces.\n    \"\"\"\n\n    stack = Stack()\n\n    for char in s:\n        if char in ['(', '[', '{']:\n            stack.push(char)\n        elif char in [')', ']', '}']:\n            if stack.is_empty():\n                return False\n            top = stack.pop()\n            if (char == ')' and top != '(') or (char == ']' and top != '[') or (char == '}' and top != '{'):\n                return False\n\n    return stack.is_empty()", "solution_func": "def g():\n    return \"{[()]}\"", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two elements in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value is obtained by XORing 5 and 25, which gives a result of 28.\n    \"\"\"\n\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = set()\n        for num in nums:\n            prefixes.add(num & mask)\n        candidate = max_xor | (1 << i)\n        for prefix in prefixes:\n            if candidate ^ prefix in prefixes:\n                max_xor = candidate\n                break\n\n    return max_xor\n\ndef g():\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 317, "target_skills": [0, 0, 1, 1, 0, 0, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two elements in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value is obtained by XORing 5 and 25, which gives a result of 28.\n    \"\"\"\n\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = set()\n        for num in nums:\n            prefixes.add(num & mask)\n        candidate = max_xor | (1 << i)\n        for prefix in prefixes:\n            if candidate ^ prefix in prefixes:\n                max_xor = candidate\n                break\n\n    return max_xor", "solution_func": "def g():\n    return [3, 10, 5, 25, 2, 8]", "map_ix": [1, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> List[int]:\n    \"\"\"\n    Given the root of a binary tree, return a list containing the values of the nodes at each level.\n    \n    Example:\n    Input:\n        3\n       / \\\n      9  20\n        /  \\\n       15   7\n    Output:\n    [[3], [9, 20], [15, 7]]\n    \n    Hint: Use a queue data structure and perform level order traversal.\n    \"\"\"\n    if not root:\n        return []\n    \n    result = []\n    queue = [root]\n    \n    while queue:\n        level = []\n        size = len(queue)\n        \n        for _ in range(size):\n            node = queue.pop(0)\n            level.append(node.val)\n            \n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        result.append(level)\n    \n    return result\n\ndef g():\n    root = TreeNode(3)\n    root.left = TreeNode(9)\n    root.right = TreeNode(20)\n    root.right.left = TreeNode(15)\n    root.right.right = TreeNode(7)\n    return root\n\nassert f(g()) == [[3], [9, 20], [15, 7]]\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 317, "target_skills": [1, 0, 0, 1, 0, 0, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> List[int]:\n    \"\"\"\n    Given the root of a binary tree, return a list containing the values of the nodes at each level.\n    \n    Example:\n    Input:\n        3\n       / \\\n      9  20\n        /  \\\n       15   7\n    Output:\n    [[3], [9, 20], [15, 7]]\n    \n    Hint: Use a queue data structure and perform level order traversal.\n    \"\"\"\n    if not root:\n        return []\n    \n    result = []\n    queue = [root]\n    \n    while queue:\n        level = []\n        size = len(queue)\n        \n        for _ in range(size):\n            node = queue.pop(0)\n            level.append(node.val)\n            \n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        result.append(level)\n    \n    return result", "solution_func": "def g():\n    root = TreeNode(3)\n    root.left = TreeNode(9)\n    root.right = TreeNode(20)\n    root.right.left = TreeNode(15)\n    root.right.right = TreeNode(7)\n    return root", "map_ix": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a valid palindrome. A valid palindrome is a string that can be\n    read the same forwards and backwards, ignoring case and non-alphanumeric characters.\n    \n    Example:\n    Input: \"A man, a plan, a canal: Panama\"\n    Output: True\n    \n    Explanation: \"amanaplanacanalpanama\" is a valid palindrome.\n    \n    Hint: Use two pointers to compare characters from both ends of the string.\n    \"\"\"\n    s = ''.join([char.lower() for char in s if char.isalnum()])\n    \n    left = 0\n    right = len(s) - 1\n    \n    while left < right:\n        if s[left] != s[right]:\n            return False\n        left += 1\n        right -= 1\n    \n    return True\n\ndef g(s=\"A man, a plan, a canal: Panama\"):\n    return s\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 317, "target_skills": [0, 1, 1, 0, 0, 0, 1, 0, 1, 1], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a valid palindrome. A valid palindrome is a string that can be\n    read the same forwards and backwards, ignoring case and non-alphanumeric characters.\n    \n    Example:\n    Input: \"A man, a plan, a canal: Panama\"\n    Output: True\n    \n    Explanation: \"amanaplanacanalpanama\" is a valid palindrome.\n    \n    Hint: Use two pointers to compare characters from both ends of the string.\n    \"\"\"\n    s = ''.join([char.lower() for char in s if char.isalnum()])\n    \n    left = 0\n    right = len(s) - 1\n    \n    while left < right:\n        if s[left] != s[right]:\n            return False\n        left += 1\n        right -= 1\n    \n    return True", "solution_func": "def g(s=\"A man, a plan, a canal: Panama\"):\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers nums, find the maximum sum of a contiguous subarray.\n    \n    Example:\n    Input: [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n    \n    Explanation: The contiguous subarray [4, -1, 2, 1] has the largest sum of 6.\n    \n    Hint: Use Kadane's algorithm to find the maximum sum subarray.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 317, "target_skills": [1, 1, 0, 0, 0, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers nums, find the maximum sum of a contiguous subarray.\n    \n    Example:\n    Input: [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n    \n    Explanation: The contiguous subarray [4, -1, 2, 1] has the largest sum of 6.\n    \n    Hint: Use Kadane's algorithm to find the maximum sum subarray.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum", "solution_func": "def g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> int:\n    \"\"\"\n    Given an array of integers and a positive integer k, find the maximum sum of any contiguous subarray of size k.\n\n    Sample Input:\n    arr = [2, 3, 4, 1, 5]\n    k = 3\n\n    Sample Output:\n    9\n\n    Explanation:\n    The subarray with maximum sum of size 3 is [4, 1, 5], which gives a sum of 9.\n    \"\"\"\n    n = len(arr)\n    if k > n:\n        return -1\n    \n    max_sum = float('-inf')\n    curr_sum = sum(arr[:k])\n    max_sum = max(max_sum, curr_sum)\n\n    for i in range(k, n):\n        curr_sum += arr[i] - arr[i - k]\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum\n\n\ndef g():\n    arr = [2, 3, 4, 1, 5]\n    k = 3\n    return arr, k\n\nassert f(*g()) == 9\n\n", "emb": null, "idx_generation": 317, "target_skills": [1, 0, 0, 1, 0, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> int:\n    \"\"\"\n    Given an array of integers and a positive integer k, find the maximum sum of any contiguous subarray of size k.\n\n    Sample Input:\n    arr = [2, 3, 4, 1, 5]\n    k = 3\n\n    Sample Output:\n    9\n\n    Explanation:\n    The subarray with maximum sum of size 3 is [4, 1, 5], which gives a sum of 9.\n    \"\"\"\n    n = len(arr)\n    if k > n:\n        return -1\n    \n    max_sum = float('-inf')\n    curr_sum = sum(arr[:k])\n    max_sum = max(max_sum, curr_sum)\n\n    for i in range(k, n):\n        curr_sum += arr[i] - arr[i - k]\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum", "solution_func": "def g():\n    arr = [2, 3, 4, 1, 5]\n    k = 3\n    return arr, k", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n\n    Sample Output:\n    20\n\n    Explanation:\n    The maximum product of two distinct numbers is 5 * 4 = 20.\n    \"\"\"\n    max_product = float('-inf')\n    n = len(nums)\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            max_product = max(max_product, nums[i] * nums[j])\n    \n    return max_product\n\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 20\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 317, "target_skills": [0, 1, 0, 1, 1, 1, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n\n    Sample Output:\n    20\n\n    Explanation:\n    The maximum product of two distinct numbers is 5 * 4 = 20.\n    \"\"\"\n    max_product = float('-inf')\n    n = len(nums)\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            max_product = max(max_product, nums[i] * nums[j])\n    \n    return max_product", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [1, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum that can be obtained by selecting a subarray with a length of at least one.\n\n    Sample Input:\n    nums = [1, -2, 3, -4, 5]\n\n    Sample Output:\n    5\n\n    Explanation:\n    The maximum sum that can be obtained by selecting the subarray [5] with a length of one.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum\n\n\ndef g():\n    nums = [1, -2, 3, -4, 5]\n    return nums\n\nassert f(g()) == 5\n\n", "emb": [1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 317, "target_skills": [1, 1, 0, 1, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum that can be obtained by selecting a subarray with a length of at least one.\n\n    Sample Input:\n    nums = [1, -2, 3, -4, 5]\n\n    Sample Output:\n    5\n\n    Explanation:\n    The maximum sum that can be obtained by selecting the subarray [5] with a length of one.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum", "solution_func": "def g():\n    nums = [1, -2, 3, -4, 5]\n    return nums", "map_ix": [1, 1, 1, 1, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    1 + 4 + 7 + 8 + 9 = 29\n    \"\"\"\n\n    def dfs(row: int, col: int) -> int:\n        if row >= len(matrix) or col >= len(matrix[0]):\n            return 0\n\n        right = dfs(row, col + 1)\n        down = dfs(row + 1, col)\n\n        return matrix[row][col] + max(right, down)\n\n    return dfs(0, 0)\n\n\ndef g():\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n\nassert f(g()) == 29\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 317, "target_skills": [1, 1, 0, 1, 1, 1, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    1 + 4 + 7 + 8 + 9 = 29\n    \"\"\"\n\n    def dfs(row: int, col: int) -> int:\n        if row >= len(matrix) or col >= len(matrix[0]):\n            return 0\n\n        right = dfs(row, col + 1)\n        down = dfs(row + 1, col)\n\n        return matrix[row][col] + max(right, down)\n\n    return dfs(0, 0)", "solution_func": "def g():\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, return True if there exists a subset of the list\n    that has a sum equal to the target value. Otherwise, return False.\n\n    Example:\n    f([1, 2, 3, 4, 5], 9) -> True\n\n    Explanation:\n    The subset [2, 3, 4] has a sum of 9.\n\n    Hint: Use dynamic programming and recursion to solve this problem.\n    \"\"\"\n    def helper(index: int, target: int) -> bool:\n        if target == 0:\n            return True\n        if index == len(nums):\n            return False\n        if nums[index] > target:\n            return helper(index + 1, target)\n        return helper(index + 1, target) or helper(index + 1, target - nums[index])\n\n    return helper(0, sum(nums) // 2)\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 318, "target_skills": [0, 1, 0, 1, 1, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, return True if there exists a subset of the list\n    that has a sum equal to the target value. Otherwise, return False.\n\n    Example:\n    f([1, 2, 3, 4, 5], 9) -> True\n\n    Explanation:\n    The subset [2, 3, 4] has a sum of 9.\n\n    Hint: Use dynamic programming and recursion to solve this problem.\n    \"\"\"\n    def helper(index: int, target: int) -> bool:\n        if target == 0:\n            return True\n        if index == len(nums):\n            return False\n        if nums[index] > target:\n            return helper(index + 1, target)\n        return helper(index + 1, target) or helper(index + 1, target - nums[index])\n\n    return helper(0, sum(nums) // 2)", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray.\n\n    Example:\n    f([-2, 1, -3, 4, -1, 2, 1, -5, 4]) -> 6\n\n    Explanation:\n    The subarray [4, -1, 2, 1] has the maximum sum of 6.\n\n    Hint: Use dynamic programming to solve this problem.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 318, "target_skills": [0, 0, 1, 1, 0, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray.\n\n    Example:\n    f([-2, 1, -3, 4, -1, 2, 1, -5, 4]) -> 6\n\n    Explanation:\n    The subarray [4, -1, 2, 1] has the maximum sum of 6.\n\n    Hint: Use dynamic programming to solve this problem.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum", "solution_func": "def g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(string: str) -> str:\n    \"\"\"\n    Given a string, return the longest palindromic substring.\n\n    Example:\n    f(\"babad\") -> \"bab\" or \"aba\"\n\n    Explanation:\n    The longest palindromic substring in \"babad\" is \"bab\" or \"aba\".\n\n    Hint: Use dynamic programming to solve this problem.\n    \"\"\"\n    if len(string) <= 1:\n        return string\n\n    longest = \"\"\n    for i in range(len(string)):\n        # Check for odd-length palindromes\n        left, right = i, i\n        while left >= 0 and right < len(string) and string[left] == string[right]:\n            left -= 1\n            right += 1\n        if right - left - 1 > len(longest):\n            longest = string[left+1:right]\n\n        # Check for even-length palindromes\n        left, right = i, i + 1\n        while left >= 0 and right < len(string) and string[left] == string[right]:\n            left -= 1\n            right += 1\n        if right - left - 1 > len(longest):\n            longest = string[left+1:right]\n\n    return longest\n\ndef g():\n    string = \"babad\"\n    return string\n\nassert f(g()) == \"bab\"\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 318, "target_skills": [0, 1, 1, 0, 0, 1, 1, 1, 0, 0], "problem_func": "from typing import*\ndef f(string: str) -> str:\n    \"\"\"\n    Given a string, return the longest palindromic substring.\n\n    Example:\n    f(\"babad\") -> \"bab\" or \"aba\"\n\n    Explanation:\n    The longest palindromic substring in \"babad\" is \"bab\" or \"aba\".\n\n    Hint: Use dynamic programming to solve this problem.\n    \"\"\"\n    if len(string) <= 1:\n        return string\n\n    longest = \"\"\n    for i in range(len(string)):\n        # Check for odd-length palindromes\n        left, right = i, i\n        while left >= 0 and right < len(string) and string[left] == string[right]:\n            left -= 1\n            right += 1\n        if right - left - 1 > len(longest):\n            longest = string[left+1:right]\n\n        # Check for even-length palindromes\n        left, right = i, i + 1\n        while left >= 0 and right < len(string) and string[left] == string[right]:\n            left -= 1\n            right += 1\n        if right - left - 1 > len(longest):\n            longest = string[left+1:right]\n\n    return longest", "solution_func": "def g():\n    string = \"babad\"\n    return string", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums and a target integer n, find the number of different combinations\n    of numbers in nums that add up to n.\n\n    Example:\n    Input: n = 4, nums = [1, 2, 3]\n    Output: 4\n\n    Explanation: The different combinations of numbers in nums that add up to 4 are:\n    1. [1, 1, 1, 1]\n    2. [1, 1, 2]\n    3. [1, 3]\n    4. [2, 2]\n    \"\"\"\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for num in nums:\n        for i in range(num, n + 1):\n            dp[i] += dp[i - num]\n\n    return dp[n]\n\ndef g() -> (int, List[int]):\n    return 4, [1, 2, 3]\n\nassert f(*g()) == 4\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 318, "target_skills": [0, 0, 1, 1, 1, 1, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums and a target integer n, find the number of different combinations\n    of numbers in nums that add up to n.\n\n    Example:\n    Input: n = 4, nums = [1, 2, 3]\n    Output: 4\n\n    Explanation: The different combinations of numbers in nums that add up to 4 are:\n    1. [1, 1, 1, 1]\n    2. [1, 1, 2]\n    3. [1, 3]\n    4. [2, 2]\n    \"\"\"\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for num in nums:\n        for i in range(num, n + 1):\n            dp[i] += dp[i - num]\n\n    return dp[n]", "solution_func": "def g() -> (int, List[int]):\n    return 4, [1, 2, 3]", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence.\n\n    Example:\n    Input: nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n    \"\"\"\n    if not nums:\n        return 0\n\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[int]:\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 318, "target_skills": [1, 0, 1, 1, 0, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence.\n\n    Example:\n    Input: nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n    \"\"\"\n    if not nums:\n        return 0\n\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)", "solution_func": "def g() -> List[int]:\n    return [10, 9, 2, 5, 3, 7, 101, 18]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, coins: List[int]) -> int:\n    \"\"\"\n    Given a value n and a list of coin denominations, find the minimum number of coins needed to make up the value n.\n    You have an infinite supply of each coin denomination.\n\n    Example:\n    Input: n = 11, coins = [1, 2, 5]\n    Output: 3\n\n    Explanation: The minimum number of coins needed to make up the value 11 is 3, using [5, 5, 1].\n    \"\"\"\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n\n    for i in range(1, n + 1):\n        for coin in coins:\n            if i >= coin:\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return dp[n]\n\ndef g() -> (int, List[int]):\n    return 11, [1, 2, 5]\n\nassert f(*g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 318, "target_skills": [0, 1, 1, 0, 1, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, coins: List[int]) -> int:\n    \"\"\"\n    Given a value n and a list of coin denominations, find the minimum number of coins needed to make up the value n.\n    You have an infinite supply of each coin denomination.\n\n    Example:\n    Input: n = 11, coins = [1, 2, 5]\n    Output: 3\n\n    Explanation: The minimum number of coins needed to make up the value 11 is 3, using [5, 5, 1].\n    \"\"\"\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n\n    for i in range(1, n + 1):\n        for coin in coins:\n            if i >= coin:\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return dp[n]", "solution_func": "def g() -> (int, List[int]):\n    return 11, [1, 2, 5]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a subset of the list such that the sum of its elements is 0.\n\n    Example:\n    nums = [1, -2, 3, 4, -5]\n\n    Output:\n    True (subset [-2, 3, -5] has a sum of 0)\n    \"\"\"\n    def subset_sum(nums: List[int], target: int, index: int) -> bool:\n        if target == 0:\n            return True\n        if index >= len(nums):\n            return False\n        return subset_sum(nums, target-nums[index], index+1) or subset_sum(nums, target, index+1)\n    \n    return subset_sum(nums, 0, 0)\n\n\ndef g() -> List[int]:\n    return [1, -2, 3, 4, -5]\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 318, "target_skills": [1, 1, 1, 1, 1, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a subset of the list such that the sum of its elements is 0.\n\n    Example:\n    nums = [1, -2, 3, 4, -5]\n\n    Output:\n    True (subset [-2, 3, -5] has a sum of 0)\n    \"\"\"\n    def subset_sum(nums: List[int], target: int, index: int) -> bool:\n        if target == 0:\n            return True\n        if index >= len(nums):\n            return False\n        return subset_sum(nums, target-nums[index], index+1) or subset_sum(nums, target, index+1)\n    \n    return subset_sum(nums, 0, 0)", "solution_func": "def g() -> List[int]:\n    return [1, -2, 3, 4, -5]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum of a path from the top left cell to the bottom right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7 (path: 1 -> 3 -> 1 -> 1 -> 1)\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 318, "target_skills": [0, 1, 0, 0, 0, 1, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum of a path from the top left cell to the bottom right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7 (path: 1 -> 3 -> 1 -> 1 -> 1)\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]", "solution_func": "def g() -> List[List[int]]:\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[int]:\n    \"\"\"\n    Given a list of words, return a list of indices (0-indexed) of words that are anagrams of each other.\n\n    Example:\n    words = [\"cat\", \"dog\", \"tac\", \"god\", \"act\"]\n\n    Output:\n    [0, 1, 2, 3, 4] (all words are anagrams of each other)\n    \"\"\"\n    def count_chars(word: str) -> List[int]:\n        counts = [0] * 26\n        for ch in word:\n            counts[ord(ch) - ord('a')] += 1\n        return counts\n    \n    anagram_groups = {}\n    for i, word in enumerate(words):\n        counts = count_chars(word)\n        key = tuple(counts)\n        if key in anagram_groups:\n            anagram_groups[key].append(i)\n        else:\n            anagram_groups[key] = [i]\n    \n    result = []\n    for group in anagram_groups.values():\n        if len(group) > 1:\n            result.extend(group)\n    \n    return result\n\n\ndef g() -> List[str]:\n    return [\"cat\", \"dog\", \"tac\", \"god\", \"act\"]\n\nassert f(g()) == [0, 1, 2, 3, 4]\n", "emb": null, "idx_generation": 318, "target_skills": [0, 0, 1, 1, 0, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[int]:\n    \"\"\"\n    Given a list of words, return a list of indices (0-indexed) of words that are anagrams of each other.\n\n    Example:\n    words = [\"cat\", \"dog\", \"tac\", \"god\", \"act\"]\n\n    Output:\n    [0, 1, 2, 3, 4] (all words are anagrams of each other)\n    \"\"\"\n    def count_chars(word: str) -> List[int]:\n        counts = [0] * 26\n        for ch in word:\n            counts[ord(ch) - ord('a')] += 1\n        return counts\n    \n    anagram_groups = {}\n    for i, word in enumerate(words):\n        counts = count_chars(word)\n        key = tuple(counts)\n        if key in anagram_groups:\n            anagram_groups[key].append(i)\n        else:\n            anagram_groups[key] = [i]\n    \n    result = []\n    for group in anagram_groups.values():\n        if len(group) > 1:\n            result.extend(group)\n    \n    return result", "solution_func": "def g() -> List[str]:\n    return [\"cat\", \"dog\", \"tac\", \"god\", \"act\"]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"Check if there exists a subsequence in the given array that sums up to k.\"\"\"\n    n = len(arr)\n    dp = [[False] * (k+1) for _ in range(n+1)]\n    dp[0][0] = True\n\n    for i in range(1, n+1):\n        for j in range(k+1):\n            dp[i][j] = dp[i-1][j]\n            if j >= arr[i-1]:\n                dp[i][j] = dp[i][j] or dp[i-1][j-arr[i-1]]\n    \n    return dp[n][k]\n\ndef g(arr = [1, 2, 3, 4, 5], k = 10):\n    return arr\n\nassert f(g())\n", "emb": null, "idx_generation": 318, "target_skills": [0, 0, 1, 1, 0, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"Check if there exists a subsequence in the given array that sums up to k.\"\"\"\n    n = len(arr)\n    dp = [[False] * (k+1) for _ in range(n+1)]\n    dp[0][0] = True\n\n    for i in range(1, n+1):\n        for j in range(k+1):\n            dp[i][j] = dp[i-1][j]\n            if j >= arr[i-1]:\n                dp[i][j] = dp[i][j] or dp[i-1][j-arr[i-1]]\n    \n    return dp[n][k]", "solution_func": "def g(arr = [1, 2, 3, 4, 5], k = 10):\n    return arr", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct pairs that sum up to zero.\n\n    Example:\n    nums = [1, -1, 2, -2, 3, -3]\n\n    Output:\n    3\n\n    Explanation:\n    The distinct pairs that sum up to zero are (1, -1), (2, -2), and (3, -3).\n    \"\"\"\n    count = 0\n    num_set = set(nums)\n\n    for num in num_set:\n        if -num in num_set:\n            count += 1\n\n    return count\n\ndef g(nums=[1, -1, 2, -2, 3, -3]):\n    return nums\n\nassert f(g()) == 3\n", "emb": null, "idx_generation": 319, "target_skills": [0, 1, 1, 0, 1, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct pairs that sum up to zero.\n\n    Example:\n    nums = [1, -1, 2, -2, 3, -3]\n\n    Output:\n    3\n\n    Explanation:\n    The distinct pairs that sum up to zero are (1, -1), (2, -2), and (3, -3).\n    \"\"\"\n    count = 0\n    num_set = set(nums)\n\n    for num in num_set:\n        if -num in num_set:\n            count += 1\n\n    return count", "solution_func": "def g(nums=[1, -1, 2, -2, 3, -3]):\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> str:\n    \"\"\"\n    Given a list of words, return the longest word that can be formed by concatenating other words in the list.\n\n    Example:\n    words = [\"cat\", \"banana\", \"dog\", \"fruit\", \"apple\", \"catdog\"]\n\n    Output:\n    \"catdog\"\n\n    Explanation:\n    The longest word that can be formed by concatenating other words in the list is \"catdog\".\n    \"\"\"\n    word_set = set(words)\n    longest_word = \"\"\n\n    for word in words:\n        word_set.remove(word)\n        if is_concatenated_word(word, word_set):\n            if len(word) > len(longest_word):\n                longest_word = word\n        word_set.add(word)\n\n    return longest_word\n\ndef is_concatenated_word(word: str, word_set: set) -> bool:\n    if word in word_set:\n        return True\n\n    for i in range(1, len(word)):\n        if word[:i] in word_set and is_concatenated_word(word[i:], word_set):\n            return True\n\n    return False\n\ndef g(words=[\"cat\", \"banana\", \"dog\", \"fruit\", \"apple\", \"catdog\"]):\n    return words\n\nassert f(g()) == \"catdog\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 319, "target_skills": [1, 0, 1, 1, 0, 0, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> str:\n    \"\"\"\n    Given a list of words, return the longest word that can be formed by concatenating other words in the list.\n\n    Example:\n    words = [\"cat\", \"banana\", \"dog\", \"fruit\", \"apple\", \"catdog\"]\n\n    Output:\n    \"catdog\"\n\n    Explanation:\n    The longest word that can be formed by concatenating other words in the list is \"catdog\".\n    \"\"\"\n    word_set = set(words)\n    longest_word = \"\"\n\n    for word in words:\n        word_set.remove(word)\n        if is_concatenated_word(word, word_set):\n            if len(word) > len(longest_word):\n                longest_word = word\n        word_set.add(word)\n\n    return longest_word\n\ndef is_concatenated_word(word: str, word_set: set) -> bool:\n    if word in word_set:\n        return True\n\n    for i in range(1, len(word)):\n        if word[:i] in word_set and is_concatenated_word(word[i:], word_set):\n            return True\n\n    return False", "solution_func": "def g(words=[\"cat\", \"banana\", \"dog\", \"fruit\", \"apple\", \"catdog\"]):\n    return words", "map_ix": [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum sum of a non-adjacent subsequence.\n\n    Example:\n    nums = [2, 4, 6, 8, 10]\n\n    Output:\n    18\n\n    Explanation:\n    The maximum sum of a non-adjacent subsequence is 18, which can be achieved by selecting the numbers 4, 8, and 6.\n    \"\"\"\n    if len(nums) == 0:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n\n    max_sum = max(nums[0], nums[1])\n    prev_sum = nums[0]\n\n    for i in range(2, len(nums)):\n        curr_sum = max(prev_sum + nums[i], max_sum)\n        prev_sum = max_sum\n        max_sum = curr_sum\n\n    return max_sum\n\ndef g(nums=[2, 4, 6, 8, 10]):\n    return nums\n\nassert f(g()) == 18\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 319, "target_skills": [1, 1, 0, 1, 1, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum sum of a non-adjacent subsequence.\n\n    Example:\n    nums = [2, 4, 6, 8, 10]\n\n    Output:\n    18\n\n    Explanation:\n    The maximum sum of a non-adjacent subsequence is 18, which can be achieved by selecting the numbers 4, 8, and 6.\n    \"\"\"\n    if len(nums) == 0:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n\n    max_sum = max(nums[0], nums[1])\n    prev_sum = nums[0]\n\n    for i in range(2, len(nums)):\n        curr_sum = max(prev_sum + nums[i], max_sum)\n        prev_sum = max_sum\n        max_sum = curr_sum\n\n    return max_sum", "solution_func": "def g(nums=[2, 4, 6, 8, 10]):\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if a given list of integers is a permutation of the first n natural numbers.\"\"\"\n    nums.sort()\n    for i in range(len(nums)):\n        if nums[i] != i + 1:\n            return False\n    return True\n\ndef g():\n    return [3, 1, 2]\nassert f(g())\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 319, "target_skills": [1, 0, 1, 0, 1, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if a given list of integers is a permutation of the first n natural numbers.\"\"\"\n    nums.sort()\n    for i in range(len(nums)):\n        if nums[i] != i + 1:\n            return False\n    return True", "solution_func": "def g():\n    return [3, 1, 2]", "map_ix": [1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Optional\n\nclass Node:\n    def __init__(self, val: int):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef f(root: Optional[Node]) -> List[int]:\n    \"\"\"Perform an in-order traversal of a binary tree and return the values in a list.\"\"\"\n    result = []\n    stack = []\n    curr = root\n    while curr or stack:\n        while curr:\n            stack.append(curr)\n            curr = curr.left\n        curr = stack.pop()\n        result.append(curr.val)\n        curr = curr.right\n    return result\n\ndef g():\n    root = Node(4)\n    root.left = Node(2)\n    root.right = Node(6)\n    root.left.left = Node(1)\n    root.left.right = Node(3)\n    root.right.left = Node(5)\n    root.right.right = Node(7)\n    return root\n\nassert f(g()) == [1, 2, 3, 4, 5, 6, 7]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 319, "target_skills": [0, 0, 1, 1, 1, 0, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List, Optional\n\nclass Node:\n    def __init__(self, val: int):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef f(root: Optional[Node]) -> List[int]:\n    \"\"\"Perform an in-order traversal of a binary tree and return the values in a list.\"\"\"\n    result = []\n    stack = []\n    curr = root\n    while curr or stack:\n        while curr:\n            stack.append(curr)\n            curr = curr.left\n        curr = stack.pop()\n        result.append(curr.val)\n        curr = curr.right\n    return result", "solution_func": "def g():\n    root = Node(4)\n    root.left = Node(2)\n    root.right = Node(6)\n    root.left.left = Node(1)\n    root.left.right = Node(3)\n    root.right.left = Node(5)\n    root.right.right = Node(7)\n    return root", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the sum of the first n natural numbers using the formula S = (n * (n + 1)) // 2.\"\"\"\n    return (n * (n + 1)) // 2\n\ndef g():\n    return 10\n\nassert f(g()) == 55\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 319, "target_skills": [1, 1, 0, 1, 0, 1, 1, 1, 1, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the sum of the first n natural numbers using the formula S = (n * (n + 1)) // 2.\"\"\"\n    return (n * (n + 1)) // 2", "solution_func": "def g():\n    return 10", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list.\n    If the target value is not found, return -1.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 4\n\n    Output:\n    3\n\n    Explanation:\n    The target value 4 is found at index 3 in the list.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g():\n    return ([1, 2, 3, 4, 5, 6], 4)\n\nassert f(*g()) == 3\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 319, "target_skills": [0, 0, 0, 0, 1, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list.\n    If the target value is not found, return -1.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 4\n\n    Output:\n    3\n\n    Explanation:\n    The target value 4 is found at index 3 in the list.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1", "solution_func": "def g():\n    return ([1, 2, 3, 4, 5, 6], 4)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, compute the sum of all positive integers less than or equal to n.\n\n    Example:\n    n = 5\n\n    Output:\n    15\n\n    Explanation:\n    The sum of all positive integers less than or equal to 5 is 1 + 2 + 3 + 4 + 5 = 15.\n    \"\"\"\n    return n * (n + 1) // 2\n\ndef g():\n    return 5\n\nassert f(g()) == 15\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 319, "target_skills": [1, 1, 1, 0, 0, 1, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, compute the sum of all positive integers less than or equal to n.\n\n    Example:\n    n = 5\n\n    Output:\n    15\n\n    Explanation:\n    The sum of all positive integers less than or equal to 5 is 1 + 2 + 3 + 4 + 5 = 15.\n    \"\"\"\n    return n * (n + 1) // 2", "solution_func": "def g():\n    return 5", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    20\n\n    Explanation:\n    The maximum product of any two numbers in the list is 4 * 5 = 20.\n    \"\"\"\n    max_product = float('-inf')\n    \n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n    \n    return max_product\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 20\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 319, "target_skills": [1, 0, 0, 1, 0, 0, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    20\n\n    Explanation:\n    The maximum product of any two numbers in the list is 4 * 5 = 20.\n    \"\"\"\n    max_product = float('-inf')\n    \n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n    \n    return max_product", "solution_func": "def g():\n    return [1, 2, 3, 4, 5]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers, determine if there exists two numbers in the array such that their sum is equal to the target.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr = [2, 4, 7, 11, 15], target = 9):\n    return arr, target\n\nassert f(g()[0], g()[1])\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 319, "target_skills": [1, 0, 1, 1, 0, 0, 0, 1, 1, 0], "problem_func": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers, determine if there exists two numbers in the array such that their sum is equal to the target.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False", "solution_func": "def g(arr = [2, 4, 7, 11, 15], target = 9):\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if the list is in non-decreasing order.\n\n    Sample Input:\n    arr = [1, 2, 3, 4, 5]\n\n    Sample Output:\n    True\n\n    Explanation:\n    The list [1, 2, 3, 4, 5] is in non-decreasing order.\n    \"\"\"\n    return all(arr[i] <= arr[i+1] for i in range(len(arr)-1))\n\ndef g(arr = [1, 2, 3, 4, 5]):\n    return arr\n\nassert f(g())\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 320, "target_skills": [1, 1, 0, 1, 0, 0, 1, 0, 1, 1], "problem_func": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if the list is in non-decreasing order.\n\n    Sample Input:\n    arr = [1, 2, 3, 4, 5]\n\n    Sample Output:\n    True\n\n    Explanation:\n    The list [1, 2, 3, 4, 5] is in non-decreasing order.\n    \"\"\"\n    return all(arr[i] <= arr[i+1] for i in range(len(arr)-1))", "solution_func": "def g(arr = [1, 2, 3, 4, 5]):\n    return arr", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import Tuple\n\ndef f(grid: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Given a grid of integers, find the position of the number that occurs the most frequently.\n    Return the row and column indices of the position.\n\n    Sample Input:\n    grid = [\n        [1, 2, 3],\n        [4, 2, 1],\n        [2, 3, 2]\n    ]\n\n    Sample Output:\n    (1, 0)\n\n    Explanation:\n    The number 2 occurs the most frequently in the grid, and its position is at row 1, column 0.\n    \"\"\"\n    count = {}\n    max_count = 0\n    max_position = (0, 0)\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] not in count:\n                count[grid[i][j]] = 0\n            count[grid[i][j]] += 1\n            if count[grid[i][j]] > max_count:\n                max_count = count[grid[i][j]]\n                max_position = (i, j)\n\n    return max_position\n\ndef g(grid = [[1, 2, 3], [4, 2, 1], [2, 3, 2]]):\n    return grid\n\nassert f(g()) == (1, 0)\n", "emb": null, "idx_generation": 320, "target_skills": [0, 1, 1, 0, 0, 1, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import Tuple\n\ndef f(grid: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Given a grid of integers, find the position of the number that occurs the most frequently.\n    Return the row and column indices of the position.\n\n    Sample Input:\n    grid = [\n        [1, 2, 3],\n        [4, 2, 1],\n        [2, 3, 2]\n    ]\n\n    Sample Output:\n    (1, 0)\n\n    Explanation:\n    The number 2 occurs the most frequently in the grid, and its position is at row 1, column 0.\n    \"\"\"\n    count = {}\n    max_count = 0\n    max_position = (0, 0)\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] not in count:\n                count[grid[i][j]] = 0\n            count[grid[i][j]] += 1\n            if count[grid[i][j]] > max_count:\n                max_count = count[grid[i][j]]\n                max_position = (i, j)\n\n    return max_position", "solution_func": "def g(grid = [[1, 2, 3], [4, 2, 1], [2, 3, 2]]):\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, find the number of ways to choose k elements from a set of n elements.\n\n    Sample Input:\n    n = 5\n    k = 3\n\n    Sample Output:\n    10\n\n    Explanation:\n    There are 10 ways to choose 3 elements from a set of 5 elements: (1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5), (1, 4, 5), (2, 3, 4), (2, 3, 5), (2, 4, 5), (3, 4, 5).\n    \"\"\"\n    def factorial(n: int) -> int:\n        if n == 0 or n == 1:\n            return 1\n        return n * factorial(n-1)\n\n    return factorial(n) // (factorial(k) * factorial(n-k))\n\ndef g(n = 5, k = 3):\n    return n, k\n\nassert f(*g()) == 10\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 320, "target_skills": [0, 0, 0, 0, 0, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, find the number of ways to choose k elements from a set of n elements.\n\n    Sample Input:\n    n = 5\n    k = 3\n\n    Sample Output:\n    10\n\n    Explanation:\n    There are 10 ways to choose 3 elements from a set of 5 elements: (1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5), (1, 4, 5), (2, 3, 4), (2, 3, 5), (2, 4, 5), (3, 4, 5).\n    \"\"\"\n    def factorial(n: int) -> int:\n        if n == 0 or n == 1:\n            return 1\n        return n * factorial(n-1)\n\n    return factorial(n) // (factorial(k) * factorial(n-k))", "solution_func": "def g(n = 5, k = 3):\n    return n, k", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers arr, find the maximum sum of a subarray with the constraint that no two numbers in the subarray are adjacent.\n\n    Example:\n    arr = [4, 1, 1, 9, 1]\n\n    Output:\n    13\n\n    Explanation:\n    The maximum sum can be obtained by selecting the subarray [4, 9].\n    \"\"\"\n\n    if not arr:\n        return 0\n\n    n = len(arr)\n    if n == 1:\n        return arr[0]\n\n    dp = [0] * n\n    dp[0] = arr[0]\n    dp[1] = max(arr[0], arr[1])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + arr[i])\n\n    return dp[n-1]\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate an array of integers.\n    \"\"\"\n    return [4, 1, 1, 9, 1]\n\nassert f(g()) == 13\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 320, "target_skills": [0, 1, 1, 1, 0, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers arr, find the maximum sum of a subarray with the constraint that no two numbers in the subarray are adjacent.\n\n    Example:\n    arr = [4, 1, 1, 9, 1]\n\n    Output:\n    13\n\n    Explanation:\n    The maximum sum can be obtained by selecting the subarray [4, 9].\n    \"\"\"\n\n    if not arr:\n        return 0\n\n    n = len(arr)\n    if n == 1:\n        return arr[0]\n\n    dp = [0] * n\n    dp[0] = arr[0]\n    dp[1] = max(arr[0], arr[1])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + arr[i])\n\n    return dp[n-1]", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate an array of integers.\n    \"\"\"\n    return [4, 1, 1, 9, 1]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int:\n    \"\"\"\n    Given a grid of integers, find the shortest path from the start cell to the end cell.\n    The grid contains obstacles represented by 1 and empty cells represented by 0.\n    The path can only move up, down, left, or right, and cannot pass through obstacles.\n\n    Example:\n    grid = [\n        [0, 0, 1, 0],\n        [0, 0, 0, 0],\n        [0, 1, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = (0, 0)\n    end = (3, 3)\n\n    Output:\n    6\n\n    Explanation:\n    The shortest path from (0, 0) to (3, 3) is: (0, 0) -> (1, 0) -> (2, 0) -> (2, 1) -> (2, 2) -> (2, 3) -> (3, 3).\n    The total distance is 6.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    queue = [(start[0], start[1], 0)]\n    visited = set()\n\n    while queue:\n        row, col, distance = queue.pop(0)\n\n        if (row, col) == end:\n            return distance\n\n        for dr, dc in directions:\n            new_row = row + dr\n            new_col = col + dc\n\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 0 and (new_row, new_col) not in visited:\n                queue.append((new_row, new_col, distance + 1))\n                visited.add((new_row, new_col))\n\n    return -1\n\ndef g() -> Tuple[List[List[int]], Tuple[int, int], Tuple[int, int]]:\n    \"\"\"\n    Generate a grid of integers, start and end positions.\n    \"\"\"\n    grid = [\n        [0, 0, 1, 0],\n        [0, 0, 0, 0],\n        [0, 1, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = (0, 0)\n    end = (3, 3)\n    return grid, start, end\n\nassert f(*g()) == 6\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0], "idx_generation": 320, "target_skills": [0, 0, 0, 0, 1, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int:\n    \"\"\"\n    Given a grid of integers, find the shortest path from the start cell to the end cell.\n    The grid contains obstacles represented by 1 and empty cells represented by 0.\n    The path can only move up, down, left, or right, and cannot pass through obstacles.\n\n    Example:\n    grid = [\n        [0, 0, 1, 0],\n        [0, 0, 0, 0],\n        [0, 1, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = (0, 0)\n    end = (3, 3)\n\n    Output:\n    6\n\n    Explanation:\n    The shortest path from (0, 0) to (3, 3) is: (0, 0) -> (1, 0) -> (2, 0) -> (2, 1) -> (2, 2) -> (2, 3) -> (3, 3).\n    The total distance is 6.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    queue = [(start[0], start[1], 0)]\n    visited = set()\n\n    while queue:\n        row, col, distance = queue.pop(0)\n\n        if (row, col) == end:\n            return distance\n\n        for dr, dc in directions:\n            new_row = row + dr\n            new_col = col + dc\n\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 0 and (new_row, new_col) not in visited:\n                queue.append((new_row, new_col, distance + 1))\n                visited.add((new_row, new_col))\n\n    return -1", "solution_func": "def g() -> Tuple[List[List[int]], Tuple[int, int], Tuple[int, int]]:\n    \"\"\"\n    Generate a grid of integers, start and end positions.\n    \"\"\"\n    grid = [\n        [0, 0, 1, 0],\n        [0, 0, 0, 0],\n        [0, 1, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = (0, 0)\n    end = (3, 3)\n    return grid, start, end", "map_ix": [0, 0, 1, 0, 0, 0, 1, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the length of the longest substring that contains at most two distinct characters.\n\n    Example:\n    s = \"eceba\"\n\n    Output:\n    3\n\n    Explanation:\n    The longest substring with at most two distinct characters is \"ece\".\n    \"\"\"\n\n    if len(s) < 3:\n        return len(s)\n\n    max_length = 2\n    left = 0\n    right = 0\n    char_map = {}\n\n    while right < len(s):\n        char_map[s[right]] = right\n        right += 1\n\n        if len(char_map) == 3:\n            # remove the leftmost character\n            del_idx = min(char_map.values())\n            del char_map[s[del_idx]]\n            left = del_idx + 1\n\n        max_length = max(max_length, right - left)\n\n    return max_length\n\ndef g():\n    s = \"eceba\"\n    return s\n\nassert f(g()) == 3\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 320, "target_skills": [1, 1, 1, 1, 0, 0, 1, 0, 1, 0], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the length of the longest substring that contains at most two distinct characters.\n\n    Example:\n    s = \"eceba\"\n\n    Output:\n    3\n\n    Explanation:\n    The longest substring with at most two distinct characters is \"ece\".\n    \"\"\"\n\n    if len(s) < 3:\n        return len(s)\n\n    max_length = 2\n    left = 0\n    right = 0\n    char_map = {}\n\n    while right < len(s):\n        char_map[s[right]] = right\n        right += 1\n\n        if len(char_map) == 3:\n            # remove the leftmost character\n            del_idx = min(char_map.values())\n            del char_map[s[del_idx]]\n            left = del_idx + 1\n\n        max_length = max(max_length, right - left)\n\n    return max_length", "solution_func": "def g():\n    s = \"eceba\"\n    return s", "map_ix": [0, 1, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome.\n\n    Example:\n    string = \"racecar\"\n\n    The function should return True, since \"racecar\" is a palindrome.\n\n    Note: A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n    \"\"\"\n    return string == string[::-1]\n\ndef g(string = \"racecar\"):\n    return string\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 320, "target_skills": [1, 0, 0, 0, 1, 1, 1, 0, 0, 1], "problem_func": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome.\n\n    Example:\n    string = \"racecar\"\n\n    The function should return True, since \"racecar\" is a palindrome.\n\n    Note: A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n    \"\"\"\n    return string == string[::-1]", "solution_func": "def g(string = \"racecar\"):\n    return string", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the nth Fibonacci number.\n\n    Example:\n    n = 5\n\n    The function should return 3, since the 5th Fibonacci number is 3.\n\n    Note: The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones, usually starting with 0 and 1.\n    \"\"\"\n    if n <= 1:\n        return n\n    else:\n        return f(n-1) + f(n-2)\n\ndef g(n = 5):\n    return n\n\nassert f(g()) == 3\n", "emb": null, "idx_generation": 320, "target_skills": [0, 1, 1, 0, 1, 0, 1, 0, 0, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the nth Fibonacci number.\n\n    Example:\n    n = 5\n\n    The function should return 3, since the 5th Fibonacci number is 3.\n\n    Note: The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones, usually starting with 0 and 1.\n    \"\"\"\n    if n <= 1:\n        return n\n    else:\n        return f(n-1) + f(n-2)", "solution_func": "def g(n = 5):\n    return n", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target sum, find two numbers in the list that add up to the target sum.\n    Return the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The function should return [0, 1], since nums[0] + nums[1] = 2 + 7 = 9.\n    \"\"\"\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    return []\n\ndef g(nums = [2, 7, 11, 15], target = 9):\n    return [nums, target]\n\nassert f(*g()) == [0, 1]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 320, "target_skills": [0, 0, 0, 0, 1, 1, 1, 0, 0, 1], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target sum, find two numbers in the list that add up to the target sum.\n    Return the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The function should return [0, 1], since nums[0] + nums[1] = 2 + 7 = 9.\n    \"\"\"\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    return []", "solution_func": "def g(nums = [2, 7, 11, 15], target = 9):\n    return [nums, target]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two positive integers n and m, calculate the number of unique paths from the top-left corner to the bottom-right corner of an n x m grid.\n\n    Example:\n    n = 3\n    m = 3\n\n    Output:\n    6\n\n    Explanation:\n    There are 6 unique paths from the top-left corner to the bottom-right corner of a 3 x 3 grid.\n\n    Hint: Use dynamic programming to store the number of paths for each grid cell.\n    \"\"\"\n\n    dp = [[1] * m] * n\n\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[n-1][m-1]\n\ndef g(n=3, m=3):\n    return n, m\n\nassert f(*g()) == 6\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 320, "target_skills": [0, 0, 1, 1, 1, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import *\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two positive integers n and m, calculate the number of unique paths from the top-left corner to the bottom-right corner of an n x m grid.\n\n    Example:\n    n = 3\n    m = 3\n\n    Output:\n    6\n\n    Explanation:\n    There are 6 unique paths from the top-left corner to the bottom-right corner of a 3 x 3 grid.\n\n    Hint: Use dynamic programming to store the number of paths for each grid cell.\n    \"\"\"\n\n    dp = [[1] * m] * n\n\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[n-1][m-1]", "solution_func": "def g(n=3, m=3):\n    return n, m", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Check if the given list of integers is sorted in non-decreasing order.\n    \"\"\"\n    return all(arr[i] <= arr[i+1] for i in range(len(arr)-1))\n\ndef g(arr: List[int]) -> List[int]:\n    \"\"\"\n    Sort the given list of integers in non-decreasing order.\n    \"\"\"\n    return sorted(arr)\n\nassert f(g([4, 2, 7, 1, 9, 5]))\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 321, "target_skills": [1, 0, 0, 0, 1, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Check if the given list of integers is sorted in non-decreasing order.\n    \"\"\"\n    return all(arr[i] <= arr[i+1] for i in range(len(arr)-1))", "solution_func": "def g(arr: List[int]) -> List[int]:\n    \"\"\"\n    Sort the given list of integers in non-decreasing order.\n    \"\"\"\n    return sorted(arr)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if the given string is a palindrome and the characters are arranged in a grid pattern.\n    \"\"\"\n    n = len(s)\n    if n % 2 != 0:\n        return False\n    \n    mid = n // 2\n    left = s[:mid]\n    right = s[mid:][::-1]\n    \n    return left == right\n\ndef g(s: str) -> str:\n    \"\"\"\n    Create a string by concatenating the given string with its reverse.\n    \"\"\"\n    return s + s[::-1]\n\nassert f(g(\"abracadabra\"))\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 321, "target_skills": [1, 1, 1, 1, 0, 1, 1, 0, 1, 0], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if the given string is a palindrome and the characters are arranged in a grid pattern.\n    \"\"\"\n    n = len(s)\n    if n % 2 != 0:\n        return False\n    \n    mid = n // 2\n    left = s[:mid]\n    right = s[mid:][::-1]\n    \n    return left == right", "solution_func": "def g(s: str) -> str:\n    \"\"\"\n    Create a string by concatenating the given string with its reverse.\n    \"\"\"\n    return s + s[::-1]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Find the minimum number of steps required to reach the target value from the start of the array.\n    Each step involves adding or subtracting a number from the current value.\n    \"\"\"\n    n = len(arr)\n    dp = [float('inf')] * (target + 1)\n    dp[0] = 0\n\n    for i in range(1, target + 1):\n        for j in range(n):\n            if i - arr[j] >= 0:\n                dp[i] = min(dp[i], dp[i-arr[j]] + 1)\n    \n    return dp[target]\n\ndef g(arr: List[int], target: int) -> Tuple[List[int], int]:\n    \"\"\"\n    Return the array and target value to find the minimum number of steps required to reach the target.\n    \"\"\"\n    return arr, target\n\nassert f(*g([1, 2, 5], 11)) == 3\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 321, "target_skills": [0, 0, 0, 0, 1, 1, 1, 1, 1, 1], "problem_func": "from typing import*\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Find the minimum number of steps required to reach the target value from the start of the array.\n    Each step involves adding or subtracting a number from the current value.\n    \"\"\"\n    n = len(arr)\n    dp = [float('inf')] * (target + 1)\n    dp[0] = 0\n\n    for i in range(1, target + 1):\n        for j in range(n):\n            if i - arr[j] >= 0:\n                dp[i] = min(dp[i], dp[i-arr[j]] + 1)\n    \n    return dp[target]", "solution_func": "def g(arr: List[int], target: int) -> Tuple[List[int], int]:\n    \"\"\"\n    Return the array and target value to find the minimum number of steps required to reach the target.\n    \"\"\"\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target number, find the number of occurrences of the target number in the list.\n\n    Example:\n    nums = [1, 1, 2, 2, 2, 3]\n    target = 2\n    The target number 2 appears 3 times in the list.\n\n    Return the count of occurrences of the target number.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            count = 1\n            i = mid - 1\n            while i >= 0 and nums[i] == target:\n                count += 1\n                i -= 1\n                \n            j = mid + 1\n            while j < len(nums) and nums[j] == target:\n                count += 1\n                j += 1\n            \n            return count\n        \n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return 0\n\ndef g():\n    return [[1, 1, 2, 2, 2, 3], 2]\n\nassert f(*g()) == 3\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 321, "target_skills": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target number, find the number of occurrences of the target number in the list.\n\n    Example:\n    nums = [1, 1, 2, 2, 2, 3]\n    target = 2\n    The target number 2 appears 3 times in the list.\n\n    Return the count of occurrences of the target number.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            count = 1\n            i = mid - 1\n            while i >= 0 and nums[i] == target:\n                count += 1\n                i -= 1\n                \n            j = mid + 1\n            while j < len(nums) and nums[j] == target:\n                count += 1\n                j += 1\n            \n            return count\n        \n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return 0", "solution_func": "def g():\n    return [[1, 1, 2, 2, 2, 3], 2]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list containing only the words that can be formed by rearranging the letters of other words in the list.\n\n    Example:\n    words = [\"cat\", \"tac\", \"dog\", \"god\", \"act\"]\n    The words \"cat\", \"tac\" and \"act\" can be formed by rearranging the letters of other words in the list.\n\n    Return the list of words that can be formed by rearranging the letters of other words.\n    \"\"\"\n    word_dict = {}\n    \n    for word in words:\n        sorted_word = \"\".join(sorted(word))\n        if sorted_word in word_dict:\n            word_dict[sorted_word].append(word)\n        else:\n            word_dict[sorted_word] = [word]\n    \n    result = []\n    for word_list in word_dict.values():\n        if len(word_list) > 1:\n            result.extend(word_list)\n    \n    return result\n\ndef g():\n    return [[\"cat\", \"tac\", \"dog\", \"god\", \"act\"]]\n\nassert f(*g()) == [\"cat\", \"tac\", \"act\"]\n", "emb": null, "idx_generation": 321, "target_skills": [1, 0, 1, 0, 0, 0, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list containing only the words that can be formed by rearranging the letters of other words in the list.\n\n    Example:\n    words = [\"cat\", \"tac\", \"dog\", \"god\", \"act\"]\n    The words \"cat\", \"tac\" and \"act\" can be formed by rearranging the letters of other words in the list.\n\n    Return the list of words that can be formed by rearranging the letters of other words.\n    \"\"\"\n    word_dict = {}\n    \n    for word in words:\n        sorted_word = \"\".join(sorted(word))\n        if sorted_word in word_dict:\n            word_dict[sorted_word].append(word)\n        else:\n            word_dict[sorted_word] = [word]\n    \n    result = []\n    for word_list in word_dict.values():\n        if len(word_list) > 1:\n            result.extend(word_list)\n    \n    return result", "solution_func": "def g():\n    return [[\"cat\", \"tac\", \"dog\", \"god\", \"act\"]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the size of the largest square of 1s in the grid.\n\n    Example:\n    grid = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n\n    The largest square of 1s in the grid has a size of 2x2.\n\n    Return the size of the largest square of 1s in the grid.\n    \"\"\"\n    if not grid:\n        return 0\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n    max_square_size = 0\n    \n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            if grid[i - 1][j - 1] == 1:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                max_square_size = max(max_square_size, dp[i][j])\n    \n    return max_square_size * max_square_size\n\ndef g():\n    return [[[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]]\n\nassert f(*g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 321, "target_skills": [0, 0, 0, 0, 1, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the size of the largest square of 1s in the grid.\n\n    Example:\n    grid = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n\n    The largest square of 1s in the grid has a size of 2x2.\n\n    Return the size of the largest square of 1s in the grid.\n    \"\"\"\n    if not grid:\n        return 0\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n    max_square_size = 0\n    \n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            if grid[i - 1][j - 1] == 1:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                max_square_size = max(max_square_size, dp[i][j])\n    \n    return max_square_size * max_square_size", "solution_func": "def g():\n    return [[[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]]", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two numbers in the list.\n\n    Parameters:\n    nums (List[int]): A list of integers.\n\n    Returns:\n    int: The maximum XOR value of any two numbers in the list.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n    return max_xor\n\ndef g(nums=[3, 10, 5, 25, 2, 8]):\n    return nums\n\nassert f(g()) == 28\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 321, "target_skills": [1, 1, 0, 1, 0, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two numbers in the list.\n\n    Parameters:\n    nums (List[int]): A list of integers.\n\n    Returns:\n    int: The maximum XOR value of any two numbers in the list.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n    return max_xor", "solution_func": "def g(nums=[3, 10, 5, 25, 2, 8]):\n    return nums", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if they are isomorphic.\n\n    Two strings are isomorphic if the characters in s can be replaced to get t.\n\n    All occurrences of a character must be replaced with another character while preserving\n    the order of characters. No two characters may be replaced with the same character.\n\n    Parameters:\n    s (str): The first string.\n    t (str): The second string.\n\n    Returns:\n    bool: True if s and t are isomorphic, False otherwise.\n    \"\"\"\n    if len(s) != len(t):\n        return False\n\n    s_to_t = {}\n    t_to_s = {}\n\n    for i in range(len(s)):\n        if s[i] in s_to_t:\n            if s_to_t[s[i]] != t[i]:\n                return False\n        else:\n            s_to_t[s[i]] = t[i]\n\n        if t[i] in t_to_s:\n            if t_to_s[t[i]] != s[i]:\n                return False\n        else:\n            t_to_s[t[i]] = s[i]\n\n    return True\n\ndef g(s=\"egg\", t=\"add\"):\n    return s, t\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 321, "target_skills": [0, 1, 0, 1, 1, 1, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if they are isomorphic.\n\n    Two strings are isomorphic if the characters in s can be replaced to get t.\n\n    All occurrences of a character must be replaced with another character while preserving\n    the order of characters. No two characters may be replaced with the same character.\n\n    Parameters:\n    s (str): The first string.\n    t (str): The second string.\n\n    Returns:\n    bool: True if s and t are isomorphic, False otherwise.\n    \"\"\"\n    if len(s) != len(t):\n        return False\n\n    s_to_t = {}\n    t_to_s = {}\n\n    for i in range(len(s)):\n        if s[i] in s_to_t:\n            if s_to_t[s[i]] != t[i]:\n                return False\n        else:\n            s_to_t[s[i]] = t[i]\n\n        if t[i] in t_to_s:\n            if t_to_s[t[i]] != s[i]:\n                return False\n        else:\n            t_to_s[t[i]] = s[i]\n\n    return True", "solution_func": "def g(s=\"egg\", t=\"add\"):\n    return s, t", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(prices: List[int]) -> int:\n    \"\"\"\n    Given an array prices representing the stock prices of a company in chronological order, \n    find the maximum profit you can make from one transaction (i.e., buy one and sell one share of the stock).\n\n    You must buy before you sell.\n\n    Parameters:\n    prices (List[int]): A list of integers representing the stock prices.\n\n    Returns:\n    int: The maximum profit you can make from one transaction.\n    \"\"\"\n    if len(prices) < 2:\n        return 0\n\n    max_profit = 0\n    min_price = prices[0]\n\n    for i in range(1, len(prices)):\n        min_price = min(min_price, prices[i])\n        max_profit = max(max_profit, prices[i] - min_price)\n\n    return max_profit\n\ndef g(prices=[7, 1, 5, 3, 6, 4]):\n    return prices\n\nassert f(g()) == 5\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 321, "target_skills": [1, 1, 0, 0, 1, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(prices: List[int]) -> int:\n    \"\"\"\n    Given an array prices representing the stock prices of a company in chronological order, \n    find the maximum profit you can make from one transaction (i.e., buy one and sell one share of the stock).\n\n    You must buy before you sell.\n\n    Parameters:\n    prices (List[int]): A list of integers representing the stock prices.\n\n    Returns:\n    int: The maximum profit you can make from one transaction.\n    \"\"\"\n    if len(prices) < 2:\n        return 0\n\n    max_profit = 0\n    min_price = prices[0]\n\n    for i in range(1, len(prices)):\n        min_price = min(min_price, prices[i])\n        max_profit = max(max_profit, prices[i] - min_price)\n\n    return max_profit", "solution_func": "def g(prices=[7, 1, 5, 3, 6, 4]):\n    return prices", "map_ix": [1, 1, 0, 1, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a power of 2.\n\n    Parameters:\n    n (int): The input integer.\n\n    Returns:\n    bool: True if n is a power of 2, False otherwise.\n    \"\"\"\n    if n == 0:\n        return False\n\n    return n & (n - 1) == 0\n\ndef g() -> int:\n    \"\"\"\n    Generate an integer that is a power of 2.\n\n    Returns:\n    int: An integer that is a power of 2.\n    \"\"\"\n    return 16\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 321, "target_skills": [0, 1, 0, 1, 0, 1, 0, 0, 1, 0], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a power of 2.\n\n    Parameters:\n    n (int): The input integer.\n\n    Returns:\n    bool: True if n is a power of 2, False otherwise.\n    \"\"\"\n    if n == 0:\n        return False\n\n    return n & (n - 1) == 0", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate an integer that is a power of 2.\n\n    Returns:\n    int: An integer that is a power of 2.\n    \"\"\"\n    return 16", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR value between two numbers in the array.\n    \"\"\"\n    maxXOR = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixSet = set()\n        for num in nums:\n            prefixSet.add(num & mask)\n        \n        maxXORCandidate = maxXOR | (1 << i)\n        for prefix in prefixSet:\n            if prefix ^ maxXORCandidate in prefixSet:\n                maxXOR = maxXORCandidate\n                break\n    \n    return maxXOR\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 322, "target_skills": [1, 0, 1, 0, 1, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR value between two numbers in the array.\n    \"\"\"\n    maxXOR = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixSet = set()\n        for num in nums:\n            prefixSet.add(num & mask)\n        \n        maxXORCandidate = maxXOR | (1 << i)\n        for prefix in prefixSet:\n            if prefix ^ maxXORCandidate in prefixSet:\n                maxXOR = maxXORCandidate\n                break\n    \n    return maxXOR", "solution_func": "def g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, find the minimum spanning tree (MST) weight.\n    \"\"\"\n    n = len(graph)\n    \n    parent = [-1] * n\n    key = [float('inf')] * n\n    key[0] = 0\n    mstSet = [False] * n\n    \n    for _ in range(n):\n        u = -1\n        for i in range(n):\n            if not mstSet[i] and (u == -1 or key[i] < key[u]):\n                u = i\n        \n        mstSet[u] = True\n        \n        for v in range(n):\n            if graph[u][v] != 0 and not mstSet[v] and graph[u][v] < key[v]:\n                parent[v] = u\n                key[v] = graph[u][v]\n    \n    mstWeight = 0\n    for i in range(1, n):\n        mstWeight += graph[i][parent[i]]\n    \n    return mstWeight\n\ndef g() -> List[List[int]]:\n    graph = [\n        [0, 2, 0, 6, 0],\n        [2, 0, 3, 8, 5],\n        [0, 3, 0, 0, 7],\n        [6, 8, 0, 0, 9],\n        [0, 5, 7, 9, 0],\n    ]\n    return graph\n\nassert f(g()) == 16\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 322, "target_skills": [1, 1, 0, 1, 0, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, find the minimum spanning tree (MST) weight.\n    \"\"\"\n    n = len(graph)\n    \n    parent = [-1] * n\n    key = [float('inf')] * n\n    key[0] = 0\n    mstSet = [False] * n\n    \n    for _ in range(n):\n        u = -1\n        for i in range(n):\n            if not mstSet[i] and (u == -1 or key[i] < key[u]):\n                u = i\n        \n        mstSet[u] = True\n        \n        for v in range(n):\n            if graph[u][v] != 0 and not mstSet[v] and graph[u][v] < key[v]:\n                parent[v] = u\n                key[v] = graph[u][v]\n    \n    mstWeight = 0\n    for i in range(1, n):\n        mstWeight += graph[i][parent[i]]\n    \n    return mstWeight", "solution_func": "def g() -> List[List[int]]:\n    graph = [\n        [0, 2, 0, 6, 0],\n        [2, 0, 3, 8, 5],\n        [0, 3, 0, 0, 7],\n        [6, 8, 0, 0, 9],\n        [0, 5, 7, 9, 0],\n    ]\n    return graph", "map_ix": [1, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers, return the array with the two single numbers that appear only once.\n    \"\"\"\n    xor = 0\n    for num in nums:\n        xor ^= num\n    \n    diffBit = xor & (-xor)\n    \n    num1 = 0\n    num2 = 0\n    \n    for num in nums:\n        if num & diffBit:\n            num1 ^= num\n        else:\n            num2 ^= num\n    \n    return [num1, num2]\n\ndef g() -> List[int]:\n    nums = [1, 2, 1, 3, 2, 5]\n    return nums\n\nassert f(g()) == [3, 5]\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 322, "target_skills": [1, 0, 1, 1, 1, 0, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers, return the array with the two single numbers that appear only once.\n    \"\"\"\n    xor = 0\n    for num in nums:\n        xor ^= num\n    \n    diffBit = xor & (-xor)\n    \n    num1 = 0\n    num2 = 0\n    \n    for num in nums:\n        if num & diffBit:\n            num1 ^= num\n        else:\n            num2 ^= num\n    \n    return [num1, num2]", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 1, 3, 2, 5]\n    return nums", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3])\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 60\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 322, "target_skills": [0, 0, 1, 0, 0, 0, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3])", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [1, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, count the number of distinct substrings that can be formed from s.\n    \"\"\"\n\n    n = len(s)\n    substrings = set()\n    for i in range(n):\n        for j in range(i+1, n+1):\n            substrings.add(s[i:j])\n    \n    return len(substrings)\n\ndef g():\n    s = \"abc\"\n    return s\n    \nassert f(g()) == 6\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 322, "target_skills": [1, 1, 1, 0, 1, 1, 1, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, count the number of distinct substrings that can be formed from s.\n    \"\"\"\n\n    n = len(s)\n    substrings = set()\n    for i in range(n):\n        for j in range(i+1, n+1):\n            substrings.add(s[i:j])\n    \n    return len(substrings)", "solution_func": "def g():\n    s = \"abc\"\n    return s", "map_ix": [0, 1, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the nth Fibonacci number.\n    \"\"\"\n\n    if n <= 1:\n        return n\n    \n    fib = [0] * (n+1)\n    fib[1] = 1\n\n    for i in range(2, n+1):\n        fib[i] = fib[i-1] + fib[i-2]\n\n    return fib[n]\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 5\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 322, "target_skills": [0, 0, 0, 1, 1, 1, 0, 0, 0, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the nth Fibonacci number.\n    \"\"\"\n\n    if n <= 1:\n        return n\n    \n    fib = [0] * (n+1)\n    fib[1] = 1\n\n    for i in range(2, n+1):\n        fib[i] = fib[i-1] + fib[i-2]\n\n    return fib[n]", "solution_func": "def g(n=5):\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Find the second largest number in a given list of integers.\n    \"\"\"\n    largest = float('-inf')\n    second_largest = float('-inf')\n    for num in nums:\n        if num > largest:\n            second_largest = largest\n            largest = num\n        elif num > second_largest and num < largest:\n            second_largest = num\n    return second_largest\n\ndef g() -> List[int]:\n    return [10, 5, 8, 20, 15, 7, 12]\n\nassert f(g()) == 15\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 322, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Find the second largest number in a given list of integers.\n    \"\"\"\n    largest = float('-inf')\n    second_largest = float('-inf')\n    for num in nums:\n        if num > largest:\n            second_largest = largest\n            largest = num\n        elif num > second_largest and num < largest:\n            second_largest = num\n    return second_largest", "solution_func": "def g() -> List[int]:\n    return [10, 5, 8, 20, 15, 7, 12]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the sum of the first n Fibonacci numbers.\n    \"\"\"\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    fib_sum = 1\n    prev = 1\n    curr = 1\n    for i in range(2, n):\n        fib = prev + curr\n        fib_sum += fib\n        prev = curr\n        curr = fib\n    return fib_sum\n\ndef g() -> int:\n    return 5\n\nassert f(g()) == 12\n", "emb": null, "idx_generation": 322, "target_skills": [0, 0, 0, 0, 1, 1, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the sum of the first n Fibonacci numbers.\n    \"\"\"\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    fib_sum = 1\n    prev = 1\n    curr = 1\n    for i in range(2, n):\n        fib = prev + curr\n        fib_sum += fib\n        prev = curr\n        curr = fib\n    return fib_sum", "solution_func": "def g() -> int:\n    return 5", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Find the indices of two numbers in a given list that add up to the target.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [0, 1]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 322, "target_skills": [1, 1, 0, 0, 0, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Find the indices of two numbers in a given list that add up to the target.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    return ([2, 7, 11, 15], 9)", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(adj_list: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given an adjacency list representing a directed graph, check if there is a valid path from the start node to the end node.\n    \"\"\"\n    def dfs(node, visited):\n        if node == end:\n            return True\n        \n        visited.add(node)\n        \n        for neighbor in adj_list[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited):\n                    return True\n        \n        return False\n    \n    visited = set()\n    return dfs(start, visited)\n\ndef g() -> Tuple[List[List[int]], int, int]:\n    \"\"\"\n    Generate an adjacency list, start node, and end node for the puzzle.\n    \"\"\"\n    adj_list = [[1, 2], [3], [4], [2], []]\n    start = 0\n    end = 4\n    return adj_list, start, end\n\nassert f(g()[0], g()[1], g()[2]) == True\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 322, "target_skills": [1, 0, 0, 1, 0, 1, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(adj_list: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given an adjacency list representing a directed graph, check if there is a valid path from the start node to the end node.\n    \"\"\"\n    def dfs(node, visited):\n        if node == end:\n            return True\n        \n        visited.add(node)\n        \n        for neighbor in adj_list[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited):\n                    return True\n        \n        return False\n    \n    visited = set()\n    return dfs(start, visited)", "solution_func": "def g() -> Tuple[List[List[int]], int, int]:\n    \"\"\"\n    Generate an adjacency list, start node, and end node for the puzzle.\n    \"\"\"\n    adj_list = [[1, 2], [3], [4], [2], []]\n    start = 0\n    end = 4\n    return adj_list, start, end", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of ways to climb a staircase by taking either 1 or 2 steps at a time.\n\n    Example:\n    n = 4\n\n    Output:\n    5\n\n    Explanation:\n    There are 5 ways to climb a staircase of height 4:\n    - 1 step + 1 step + 1 step + 1 step\n    - 2 steps + 1 step + 1 step\n    - 1 step + 2 steps + 1 step\n    - 1 step + 1 step + 2 steps\n    - 2 steps + 2 steps\n\n    Hint: Use dynamic programming to keep track of the number of ways to reach each step, starting from the base cases of 1 step and 2 steps.\n    \"\"\"\n\n    if n <= 2:\n        return n\n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\ndef g(n=4):\n    return n\n\nassert f(g()) == True\n\n", "emb": null, "idx_generation": 323, "target_skills": [0, 1, 1, 1, 1, 1, 1, 1, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of ways to climb a staircase by taking either 1 or 2 steps at a time.\n\n    Example:\n    n = 4\n\n    Output:\n    5\n\n    Explanation:\n    There are 5 ways to climb a staircase of height 4:\n    - 1 step + 1 step + 1 step + 1 step\n    - 2 steps + 1 step + 1 step\n    - 1 step + 2 steps + 1 step\n    - 1 step + 1 step + 2 steps\n    - 2 steps + 2 steps\n\n    Hint: Use dynamic programming to keep track of the number of ways to reach each step, starting from the base cases of 1 step and 2 steps.\n    \"\"\"\n\n    if n <= 2:\n        return n\n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]", "solution_func": "def g(n=4):\n    return n", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, count the number of connected components in the graph.\n\n    Example:\n    graph = [\n        [1, 2],\n        [0],\n        [0],\n        [4],\n        [3]\n    ]\n\n    Output:\n    2\n\n    Explanation:\n    The graph has 2 connected components: [0, 1, 2] and [3, 4].\n\n    Hint: Use depth-first search (DFS) or breadth-first search (BFS) to traverse the graph and count the number of connected components.\n    \"\"\"\n\n    def dfs(node):\n        visited[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n\n    n = len(graph)\n    visited = [False] * n\n    count = 0\n\n    for node in range(n):\n        if not visited[node]:\n            count += 1\n            dfs(node)\n\n    return count\n\ndef g():\n    return [\n        [1, 2],\n        [0],\n        [0],\n        [4],\n        [3]\n    ]\n\nassert f(g()) == True\n\n", "emb": null, "idx_generation": 323, "target_skills": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, count the number of connected components in the graph.\n\n    Example:\n    graph = [\n        [1, 2],\n        [0],\n        [0],\n        [4],\n        [3]\n    ]\n\n    Output:\n    2\n\n    Explanation:\n    The graph has 2 connected components: [0, 1, 2] and [3, 4].\n\n    Hint: Use depth-first search (DFS) or breadth-first search (BFS) to traverse the graph and count the number of connected components.\n    \"\"\"\n\n    def dfs(node):\n        visited[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n\n    n = len(graph)\n    visited = [False] * n\n    count = 0\n\n    for node in range(n):\n        if not visited[node]:\n            count += 1\n            dfs(node)\n\n    return count", "solution_func": "def g():\n    return [\n        [1, 2],\n        [0],\n        [0],\n        [4],\n        [3]\n    ]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(num1: int, num2: int) -> int:\n    \"\"\"\n    Given two integers num1 and num2, calculate the sum of their absolute differences.\n\n    Example:\n    num1 = 5\n    num2 = 3\n\n    Output:\n    4\n\n    Explanation:\n    The sum of the absolute differences is |5 - 3| + |3 - 5| = 4.\n\n    Hint: Use the absolute value function to calculate the absolute difference between two numbers.\n    \"\"\"\n\n    return abs(num1 - num2) + abs(num2 - num1)\n\ndef g(num1=5, num2=3):\n    return num1, num2\n\nassert f(*g()) == True\n\n", "emb": null, "idx_generation": 323, "target_skills": [1, 0, 0, 0, 0, 0, 1, 0, 1, 0], "problem_func": "from typing import*\ndef f(num1: int, num2: int) -> int:\n    \"\"\"\n    Given two integers num1 and num2, calculate the sum of their absolute differences.\n\n    Example:\n    num1 = 5\n    num2 = 3\n\n    Output:\n    4\n\n    Explanation:\n    The sum of the absolute differences is |5 - 3| + |3 - 5| = 4.\n\n    Hint: Use the absolute value function to calculate the absolute difference between two numbers.\n    \"\"\"\n\n    return abs(num1 - num2) + abs(num2 - num1)", "solution_func": "def g(num1=5, num2=3):\n    return num1, num2", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28 (the maximum XOR value is obtained by 5 XOR 25)\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor_val = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor_val)\n\n    return max_xor\n\ndef g(nums: List[int] = [3, 10, 5, 25, 2, 8]):\n    return nums\n\nassert f(*g()) == 28\n\n", "emb": null, "idx_generation": 323, "target_skills": [1, 0, 1, 1, 0, 1, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28 (the maximum XOR value is obtained by 5 XOR 25)\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor_val = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor_val)\n\n    return max_xor", "solution_func": "def g(nums: List[int] = [3, 10, 5, 25, 2, 8]):\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, convert it to \"leet\" speak by replacing certain characters with their corresponding replacements.\n\n    Example:\n    s = \"hello world\"\n\n    Output:\n    \"h3ll0 w0rld\"\n    \"\"\"\n\n    replacements = {\n        'a': '4',\n        'e': '3',\n        'i': '1',\n        'o': '0',\n        's': '5',\n        't': '7'\n    }\n\n    leet_speak = \"\"\n\n    for char in s:\n        if char.lower() in replacements:\n            leet_speak += replacements[char.lower()]\n        else:\n            leet_speak += char\n\n    return leet_speak\n\ndef g(s: str = \"hello world\"):\n    return s\n\nassert f(*g()) == \"h3ll0 w0rld\"\n\n", "emb": null, "idx_generation": 323, "target_skills": [0, 1, 0, 0, 1, 0, 0, 0, 0, 1], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, convert it to \"leet\" speak by replacing certain characters with their corresponding replacements.\n\n    Example:\n    s = \"hello world\"\n\n    Output:\n    \"h3ll0 w0rld\"\n    \"\"\"\n\n    replacements = {\n        'a': '4',\n        'e': '3',\n        'i': '1',\n        'o': '0',\n        's': '5',\n        't': '7'\n    }\n\n    leet_speak = \"\"\n\n    for char in s:\n        if char.lower() in replacements:\n            leet_speak += replacements[char.lower()]\n        else:\n            leet_speak += char\n\n    return leet_speak", "solution_func": "def g(s: str = \"hello world\"):\n    return s", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of words in the string.\n\n    Example:\n    s = \"Hello World\"\n\n    Output:\n    \"World Hello\"\n    \"\"\"\n\n    words = s.split()\n    reversed_s = \" \".join(reversed(words))\n\n    return reversed_s\n\ndef g(s: str = \"Hello World\"):\n    return s\n\nassert f(*g()) == \"World Hello\"\n\n", "emb": null, "idx_generation": 323, "target_skills": [1, 1, 1, 0, 1, 1, 1, 1, 1, 1], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of words in the string.\n\n    Example:\n    s = \"Hello World\"\n\n    Output:\n    \"World Hello\"\n    \"\"\"\n\n    words = s.split()\n    reversed_s = \" \".join(reversed(words))\n\n    return reversed_s", "solution_func": "def g(s: str = \"Hello World\"):\n    return s", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the shortest path from the top-left corner to the bottom-right corner.\n    Each cell in the grid represents the cost of moving to that cell. You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The shortest path from the top-left corner (1) to the bottom-right corner (1) is 1 -> 3 -> 1 -> 1 -> 1, with a total cost of 7.\n\n    Hint: Use dynamic programming to store the minimum cost for each cell.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g(grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(*g()) == 7\n", "emb": null, "idx_generation": 323, "target_skills": [0, 0, 0, 0, 1, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the shortest path from the top-left corner to the bottom-right corner.\n    Each cell in the grid represents the cost of moving to that cell. You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The shortest path from the top-left corner (1) to the bottom-right corner (1) is 1 -> 3 -> 1 -> 1 -> 1, with a total cost of 7.\n\n    Hint: Use dynamic programming to store the minimum cost for each cell.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g(grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters representing a maze, determine the minimum number of steps required to reach the exit.\n    The grid contains the following characters:\n    - 'S' represents the starting position\n    - 'E' represents the exit\n    - '#' represents a wall that cannot be passed\n    - '.' represents an empty space that can be traversed\n\n    You can only move up, down, left, or right from one cell to another.\n\n    Example:\n    grid = [\n        ['S', '.', '#', '#', '.', '.'],\n        ['.', '#', '#', '.', '#', '.'],\n        ['.', '#', '#', '.', '#', 'E'],\n        ['.', '.', '.', '.', '.', '.']\n    ]\n\n    Output:\n    10\n\n    Explanation:\n    The minimum number of steps required to reach the exit from the starting position is 10.\n\n    Hint: Use breadth-first search (BFS) to explore all possible paths and find the shortest path.\n    \"\"\"\n\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    start = None\n    m = len(grid)\n    n = len(grid[0])\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'S':\n                start = (i, j)\n                break\n\n    queue = [(start, 0)]\n    visited = set(start)\n\n    while queue:\n        (x, y), steps = queue.pop(0)\n\n        if grid[x][y] == 'E':\n            return steps\n\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n\n            if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != '#' and (nx, ny) not in visited:\n                queue.append(((nx, ny), steps + 1))\n                visited.add((nx, ny))\n\n    return -1\n\ndef g(grid = [['S', '.', '#', '#', '.', '.'], ['.', '#', '#', '.', '#', '.'], ['.', '#', '#', '.', '#', 'E'], ['.', '.', '.', '.', '.', '.']]):\n    return grid\n\nassert f(*g()) == 10\n", "emb": null, "idx_generation": 323, "target_skills": [0, 1, 1, 1, 0, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters representing a maze, determine the minimum number of steps required to reach the exit.\n    The grid contains the following characters:\n    - 'S' represents the starting position\n    - 'E' represents the exit\n    - '#' represents a wall that cannot be passed\n    - '.' represents an empty space that can be traversed\n\n    You can only move up, down, left, or right from one cell to another.\n\n    Example:\n    grid = [\n        ['S', '.', '#', '#', '.', '.'],\n        ['.', '#', '#', '.', '#', '.'],\n        ['.', '#', '#', '.', '#', 'E'],\n        ['.', '.', '.', '.', '.', '.']\n    ]\n\n    Output:\n    10\n\n    Explanation:\n    The minimum number of steps required to reach the exit from the starting position is 10.\n\n    Hint: Use breadth-first search (BFS) to explore all possible paths and find the shortest path.\n    \"\"\"\n\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    start = None\n    m = len(grid)\n    n = len(grid[0])\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'S':\n                start = (i, j)\n                break\n\n    queue = [(start, 0)]\n    visited = set(start)\n\n    while queue:\n        (x, y), steps = queue.pop(0)\n\n        if grid[x][y] == 'E':\n            return steps\n\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n\n            if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != '#' and (nx, ny) not in visited:\n                queue.append(((nx, ny), steps + 1))\n                visited.add((nx, ny))\n\n    return -1", "solution_func": "def g(grid = [['S', '.', '#', '#', '.', '.'], ['.', '#', '#', '.', '#', '.'], ['.', '#', '#', '.', '#', 'E'], ['.', '.', '.', '.', '.', '.']]):\n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    Each cell in the grid represents the value of that cell. You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    29\n\n    Explanation:\n    The maximum sum of a path from the top-left corner (1) to the bottom-right corner (9) is 1 -> 2 -> 3 -> 6 -> 9, with a total sum of 29.\n\n    Hint: Use dynamic programming to store the maximum sum for each cell.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g(grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return grid\n\nassert f(*g()) == 29\n", "emb": null, "idx_generation": 323, "target_skills": [1, 0, 0, 0, 1, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    Each cell in the grid represents the value of that cell. You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    29\n\n    Explanation:\n    The maximum sum of a path from the top-left corner (1) to the bottom-right corner (9) is 1 -> 2 -> 3 -> 6 -> 9, with a total sum of 29.\n\n    Hint: Use dynamic programming to store the maximum sum for each cell.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g(grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target if it is present in the list.\n    If the target is not present, return -1.\n\n    Args:\n    - nums: The sorted list of integers.\n    - target: The target value to search for.\n\n    Returns:\n    - The index of the target if it is present in the list, -1 otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target\n\nassert f(*g()) == 2\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 323, "target_skills": [0, 1, 0, 0, 1, 0, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target if it is present in the list.\n    If the target is not present, return -1.\n\n    Args:\n    - nums: The sorted list of integers.\n    - target: The target value to search for.\n\n    Returns:\n    - The index of the target if it is present in the list, -1 otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if it is a palindrome list.\n    Return True if the list is a palindrome, False otherwise.\n    \"\"\"\n    return nums == nums[::-1]\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 2, 1]\n    return nums\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 324, "target_skills": [1, 1, 0, 0, 0, 1, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if it is a palindrome list.\n    Return True if the list is a palindrome, False otherwise.\n    \"\"\"\n    return nums == nums[::-1]", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 2, 1]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique paths from the top-left corner to the bottom-right corner of a grid with dimensions n x n.\n    You can only move down or right at any point in time.\n    \"\"\"\n    def unique_paths_helper(x: int, y: int, n: int) -> int:\n        if x == n-1 or y == n-1:\n            return 1\n        return unique_paths_helper(x+1, y, n) + unique_paths_helper(x, y+1, n)\n    \n    return unique_paths_helper(0, 0, n)\n\ndef g() -> int:\n    n = 3\n    return n\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 324, "target_skills": [0, 1, 1, 1, 1, 0, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique paths from the top-left corner to the bottom-right corner of a grid with dimensions n x n.\n    You can only move down or right at any point in time.\n    \"\"\"\n    def unique_paths_helper(x: int, y: int, n: int) -> int:\n        if x == n-1 or y == n-1:\n            return 1\n        return unique_paths_helper(x+1, y, n) + unique_paths_helper(x, y+1, n)\n    \n    return unique_paths_helper(0, 0, n)", "solution_func": "def g() -> int:\n    n = 3\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth number in the Fibonacci sequence.\n    The Fibonacci sequence is defined as follows:\n    F(0) = 0\n    F(1) = 1\n    F(n) = F(n-1) + F(n-2) for n > 1\n    \"\"\"\n    def fibonacci(n: int, memo: List[int]) -> int:\n        if n == 0 or n == 1:\n            return n\n        if memo[n] != -1:\n            return memo[n]\n        memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)\n        return memo[n]\n    \n    memo = [-1] * (n+1)\n    return fibonacci(n, memo)\n\ndef g() -> int:\n    n = 5\n    return n\n\nassert f(g()) == 5\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 324, "target_skills": [0, 0, 0, 0, 1, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth number in the Fibonacci sequence.\n    The Fibonacci sequence is defined as follows:\n    F(0) = 0\n    F(1) = 1\n    F(n) = F(n-1) + F(n-2) for n > 1\n    \"\"\"\n    def fibonacci(n: int, memo: List[int]) -> int:\n        if n == 0 or n == 1:\n            return n\n        if memo[n] != -1:\n            return memo[n]\n        memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)\n        return memo[n]\n    \n    memo = [-1] * (n+1)\n    return fibonacci(n, memo)", "solution_func": "def g() -> int:\n    n = 5\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two positive integers n and m, find the number of ways to arrange n distinct objects into m identical boxes.\n\n    Sample Input:\n    n = 5\n    m = 3\n\n    Sample Output:\n    6\n    \"\"\"\n    if m == 0:\n        return 0\n    elif n == 0 or m == 1:\n        return 1\n    else:\n        return f(n-1, m-1) + f(n-1, m)\n\ndef g(n=5, m=3):\n    return n, m\n\nassert f(*g()) == 6\n", "emb": null, "idx_generation": 324, "target_skills": [0, 0, 1, 1, 1, 1, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two positive integers n and m, find the number of ways to arrange n distinct objects into m identical boxes.\n\n    Sample Input:\n    n = 5\n    m = 3\n\n    Sample Output:\n    6\n    \"\"\"\n    if m == 0:\n        return 0\n    elif n == 0 or m == 1:\n        return 1\n    else:\n        return f(n-1, m-1) + f(n-1, m)", "solution_func": "def g(n=5, m=3):\n    return n, m", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the length of the longest path consisting of only 1s.\n    A path can only move horizontally or vertically to adjacent cells with value 1.\n\n    Sample Input:\n    grid = [\n        [1, 1, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 0, 0, 1],\n        [0, 1, 1, 1, 1],\n        [1, 1, 1, 0, 0]\n    ]\n\n    Sample Output:\n    6\n    \"\"\"\n    max_length = 0\n\n    def dfs(i, j, length):\n        nonlocal max_length\n\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0:\n            return\n\n        max_length = max(max_length, length)\n        grid[i][j] = 0\n\n        dfs(i+1, j, length+1)\n        dfs(i-1, j, length+1)\n        dfs(i, j+1, length+1)\n        dfs(i, j-1, length+1)\n\n        grid[i][j] = 1\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                dfs(i, j, 1)\n\n    return max_length\n\ndef g():\n    grid = [\n        [1, 1, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 0, 0, 1],\n        [0, 1, 1, 1, 1],\n        [1, 1, 1, 0, 0]\n    ]\n    return grid\n\nassert f(g()) == 6\n", "emb": null, "idx_generation": 324, "target_skills": [0, 0, 1, 0, 0, 0, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the length of the longest path consisting of only 1s.\n    A path can only move horizontally or vertically to adjacent cells with value 1.\n\n    Sample Input:\n    grid = [\n        [1, 1, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 0, 0, 1],\n        [0, 1, 1, 1, 1],\n        [1, 1, 1, 0, 0]\n    ]\n\n    Sample Output:\n    6\n    \"\"\"\n    max_length = 0\n\n    def dfs(i, j, length):\n        nonlocal max_length\n\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0:\n            return\n\n        max_length = max(max_length, length)\n        grid[i][j] = 0\n\n        dfs(i+1, j, length+1)\n        dfs(i-1, j, length+1)\n        dfs(i, j+1, length+1)\n        dfs(i, j-1, length+1)\n\n        grid[i][j] = 1\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                dfs(i, j, 1)\n\n    return max_length", "solution_func": "def g():\n    grid = [\n        [1, 1, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 0, 0, 1],\n        [0, 1, 1, 1, 1],\n        [1, 1, 1, 0, 0]\n    ]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of positive integers, find the sum of the squares of the even numbers.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5, 6]\n\n    Sample Output:\n    56\n    \"\"\"\n    return sum([num**2 for num in nums if num % 2 == 0])\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6]\n    return nums\n\nassert f(g()) == 56\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 324, "target_skills": [1, 1, 1, 0, 0, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of positive integers, find the sum of the squares of the even numbers.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5, 6]\n\n    Sample Output:\n    56\n    \"\"\"\n    return sum([num**2 for num in nums if num % 2 == 0])", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5, 6]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of 0s and 1s, find the maximum number of connected 1s in the matrix.\n    Two 1s are considered connected if they are adjacent horizontally or vertically (not diagonally).\n    Return the maximum number of connected 1s.\n\n    Example:\n    matrix = [\n        [1, 0, 1, 1],\n        [1, 1, 0, 0],\n        [0, 1, 1, 1],\n        [0, 0, 0, 1]\n    ]\n\n    Output:\n    6\n\n    Explanation:\n    The maximum number of connected 1s is achieved by the group of 1s in the top-left corner and the group of 1s in the bottom-right corner, which gives a count of 6.\n    \"\"\"\n\n    def dfs(row: int, col: int) -> int:\n        if row < 0 or col < 0 or row >= len(matrix) or col >= len(matrix[0]) or matrix[row][col] != 1:\n            return 0\n        \n        count = 1\n        matrix[row][col] = 0\n\n        count += dfs(row+1, col)\n        count += dfs(row-1, col)\n        count += dfs(row, col+1)\n        count += dfs(row, col-1)\n\n        return count\n\n    max_count = 0\n\n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            if matrix[i][j] == 1:\n                count = dfs(i, j)\n                max_count = max(max_count, count)\n\n    return max_count\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix for the function f.\n    \"\"\"\n    return [\n        [1, 0, 1, 1],\n        [1, 1, 0, 0],\n        [0, 1, 1, 1],\n        [0, 0, 0, 1]\n    ]\n\nassert f(g()) == 6\n\n", "emb": null, "idx_generation": 324, "target_skills": [1, 1, 1, 0, 1, 1, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of 0s and 1s, find the maximum number of connected 1s in the matrix.\n    Two 1s are considered connected if they are adjacent horizontally or vertically (not diagonally).\n    Return the maximum number of connected 1s.\n\n    Example:\n    matrix = [\n        [1, 0, 1, 1],\n        [1, 1, 0, 0],\n        [0, 1, 1, 1],\n        [0, 0, 0, 1]\n    ]\n\n    Output:\n    6\n\n    Explanation:\n    The maximum number of connected 1s is achieved by the group of 1s in the top-left corner and the group of 1s in the bottom-right corner, which gives a count of 6.\n    \"\"\"\n\n    def dfs(row: int, col: int) -> int:\n        if row < 0 or col < 0 or row >= len(matrix) or col >= len(matrix[0]) or matrix[row][col] != 1:\n            return 0\n        \n        count = 1\n        matrix[row][col] = 0\n\n        count += dfs(row+1, col)\n        count += dfs(row-1, col)\n        count += dfs(row, col+1)\n        count += dfs(row, col-1)\n\n        return count\n\n    max_count = 0\n\n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            if matrix[i][j] == 1:\n                count = dfs(i, j)\n                max_count = max(max_count, count)\n\n    return max_count", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix for the function f.\n    \"\"\"\n    return [\n        [1, 0, 1, 1],\n        [1, 1, 0, 0],\n        [0, 1, 1, 1],\n        [0, 0, 0, 1]\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1 (2 and 7) add up to the target value of 9.\n    \"\"\"\n\n    complement_map = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complement_map:\n            return [complement_map[complement], i]\n        else:\n            complement_map[num] = i\n\n    return []\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for the function f.\n    \"\"\"\n    return [2, 7, 11, 15]\n\nassert f(g(), 9) == [0, 1]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 324, "target_skills": [1, 0, 1, 1, 1, 0, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1 (2 and 7) add up to the target value of 9.\n    \"\"\"\n\n    complement_map = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complement_map:\n            return [complement_map[complement], i]\n        else:\n            complement_map[num] = i\n\n    return []", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for the function f.\n    \"\"\"\n    return [2, 7, 11, 15]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum, which is the sum of a contiguous subarray with the largest sum.\n    Return the maximum subarray sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The contiguous subarray [4, -1, 2, 1] has the largest sum of 6.\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for the function f.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 324, "target_skills": [1, 1, 0, 1, 0, 0, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum, which is the sum of a contiguous subarray with the largest sum.\n    Return the maximum subarray sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The contiguous subarray [4, -1, 2, 1] has the largest sum of 6.\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for the function f.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> int:\n    \"\"\"\n    Given the root of a binary tree, return the sum of all left leaves.\n    A left leaf is a leaf node that has a left child.\n    \n    Example:\n    Input: root = [3,9,20,null,null,15,7]\n    Output: 24\n    Explanation: There are two left leaves in the binary tree, with values 9 and 15 respectively. The sum of these leaves is 24.\n    \"\"\"\n    if not root:\n        return 0\n    \n    def dfs(node: TreeNode, is_left: bool) -> int:\n        if not node:\n            return 0\n        if not node.left and not node.right and is_left:\n            return node.val\n        return dfs(node.left, True) + dfs(node.right, False)\n    \n    return dfs(root, False)\n\ndef g():\n    \"\"\"\n    Returns a sample binary tree.\n\n    The tree looks like this:\n\n            3\n           / \\\n          9  20\n            /  \\\n           15   7\n    \"\"\"\n    root = TreeNode(3)\n    root.left = TreeNode(9)\n    root.right = TreeNode(20)\n    root.right.left = TreeNode(15)\n    root.right.right = TreeNode(7)\n    return root\n\nassert f(g()) == 24\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 324, "target_skills": [1, 0, 1, 0, 1, 1, 1, 1, 0, 1], "problem_func": "from typing import*\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> int:\n    \"\"\"\n    Given the root of a binary tree, return the sum of all left leaves.\n    A left leaf is a leaf node that has a left child.\n    \n    Example:\n    Input: root = [3,9,20,null,null,15,7]\n    Output: 24\n    Explanation: There are two left leaves in the binary tree, with values 9 and 15 respectively. The sum of these leaves is 24.\n    \"\"\"\n    if not root:\n        return 0\n    \n    def dfs(node: TreeNode, is_left: bool) -> int:\n        if not node:\n            return 0\n        if not node.left and not node.right and is_left:\n            return node.val\n        return dfs(node.left, True) + dfs(node.right, False)\n    \n    return dfs(root, False)", "solution_func": "def g():\n    \"\"\"\n    Returns a sample binary tree.\n\n    The tree looks like this:\n\n            3\n           / \\\n          9  20\n            /  \\\n           15   7\n    \"\"\"\n    root = TreeNode(3)\n    root.left = TreeNode(9)\n    root.right = TreeNode(20)\n    root.right.left = TreeNode(15)\n    root.right.right = TreeNode(7)\n    return root", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, check if it is a magic square.\n    A magic square is a square matrix where the sum of each row, each column, and each diagonal is the same.\n    Return True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n\n    # Check rows\n    for i in range(n):\n        if sum(matrix[i]) != target_sum:\n            return False\n\n    # Check columns\n    for j in range(n):\n        if sum(row[j] for row in matrix) != target_sum:\n            return False\n\n    # Check diagonals\n    if sum(matrix[i][i] for i in range(n)) != target_sum:\n        return False\n    if sum(matrix[i][n-1-i] for i in range(n)) != target_sum:\n        return False\n\n    return True\n\ndef g(matrix=[[2, 7, 6], [9, 5, 1], [4, 3, 8]]):\n    return matrix\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 325, "target_skills": [0, 1, 1, 1, 0, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, check if it is a magic square.\n    A magic square is a square matrix where the sum of each row, each column, and each diagonal is the same.\n    Return True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n\n    # Check rows\n    for i in range(n):\n        if sum(matrix[i]) != target_sum:\n            return False\n\n    # Check columns\n    for j in range(n):\n        if sum(row[j] for row in matrix) != target_sum:\n            return False\n\n    # Check diagonals\n    if sum(matrix[i][i] for i in range(n)) != target_sum:\n        return False\n    if sum(matrix[i][n-1-i] for i in range(n)) != target_sum:\n        return False\n\n    return True", "solution_func": "def g(matrix=[[2, 7, 6], [9, 5, 1], [4, 3, 8]]):\n    return matrix", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency matrix, check if there is a path from start to end.\n    Return True if there is a path, False otherwise.\n    \"\"\"\n    visited = [False] * len(graph)\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if not visited[node]:\n            visited[node] = True\n            neighbors = [i for i, val in enumerate(graph[node]) if val == 1]\n            stack.extend(neighbors)\n\n    return False\n\ndef g(start=0, end=3):\n    graph = [[0, 1, 1, 0],\n             [1, 0, 0, 1],\n             [1, 0, 0, 0],\n             [0, 1, 0, 0]]\n    return graph, start, end\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 325, "target_skills": [1, 1, 1, 0, 0, 1, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency matrix, check if there is a path from start to end.\n    Return True if there is a path, False otherwise.\n    \"\"\"\n    visited = [False] * len(graph)\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if not visited[node]:\n            visited[node] = True\n            neighbors = [i for i, val in enumerate(graph[node]) if val == 1]\n            stack.extend(neighbors)\n\n    return False", "solution_func": "def g(start=0, end=3):\n    graph = [[0, 1, 1, 0],\n             [1, 0, 0, 1],\n             [1, 0, 0, 0],\n             [0, 1, 0, 0]]\n    return graph, start, end", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, check if it is a prime number.\n    Return True if n is prime, False otherwise.\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g(n=17):\n    return n\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 325, "target_skills": [1, 1, 1, 1, 1, 0, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, check if it is a prime number.\n    Return True if n is prime, False otherwise.\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "solution_func": "def g(n=17):\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(edges: List[Tuple[int, int]], n: int) -> int:\n    \"\"\"\n    Given a list of edges representing a directed graph and the number of nodes in the graph,\n    find the minimum number of edges to be reversed to make the graph strongly connected.\n    \"\"\"\n    def dfs(node: int, graph: List[List[int]], visited: List[bool]) -> None:\n        \"\"\"\n        Perform depth-first search on the graph to mark all reachable nodes.\n        \"\"\"\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, graph, visited)\n\n    graph = [[] for _ in range(n)]\n    reversed_graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n        graph[u].append(v)\n        reversed_graph[v].append(u)\n\n    visited = [False] * n\n\n    # Perform the first DFS to mark all reachable nodes from node 0\n    dfs(0, graph, visited)\n\n    # If all nodes are visited, the graph is already strongly connected\n    if all(visited):\n        return 0\n\n    # Perform the second DFS to mark all reachable nodes from node n-1 in the reversed graph\n    visited = [False] * n\n    dfs(n-1, reversed_graph, visited)\n\n    # Count the number of nodes that are not reachable from either node 0 or node n-1\n    count = sum([1 for v in visited if not v])\n\n    return count\n\ndef g() -> Tuple[List[Tuple[int, int]], int]:\n    \"\"\"\n    Return the input edges and number of nodes.\n    \"\"\"\n    edges = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)]\n    n = 5\n    return edges, n\n\nassert f(*g()) == 1\n", "emb": null, "idx_generation": 325, "target_skills": [0, 0, 1, 0, 1, 0, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(edges: List[Tuple[int, int]], n: int) -> int:\n    \"\"\"\n    Given a list of edges representing a directed graph and the number of nodes in the graph,\n    find the minimum number of edges to be reversed to make the graph strongly connected.\n    \"\"\"\n    def dfs(node: int, graph: List[List[int]], visited: List[bool]) -> None:\n        \"\"\"\n        Perform depth-first search on the graph to mark all reachable nodes.\n        \"\"\"\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, graph, visited)\n\n    graph = [[] for _ in range(n)]\n    reversed_graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n        graph[u].append(v)\n        reversed_graph[v].append(u)\n\n    visited = [False] * n\n\n    # Perform the first DFS to mark all reachable nodes from node 0\n    dfs(0, graph, visited)\n\n    # If all nodes are visited, the graph is already strongly connected\n    if all(visited):\n        return 0\n\n    # Perform the second DFS to mark all reachable nodes from node n-1 in the reversed graph\n    visited = [False] * n\n    dfs(n-1, reversed_graph, visited)\n\n    # Count the number of nodes that are not reachable from either node 0 or node n-1\n    count = sum([1 for v in visited if not v])\n\n    return count", "solution_func": "def g() -> Tuple[List[Tuple[int, int]], int]:\n    \"\"\"\n    Return the input edges and number of nodes.\n    \"\"\"\n    edges = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)]\n    n = 5\n    return edges, n", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, k: int) -> int:\n    \"\"\"\n    Given a string s and an integer k, find the number of substrings that contain exactly k distinct characters.\n    \"\"\"\n    count = 0\n    n = len(s)\n    distinct = set()\n\n    # Iterate over all possible substrings\n    for i in range(n):\n        for j in range(i, n):\n            distinct.clear()\n            for c in s[i:j+1]:\n                distinct.add(c)\n            if len(distinct) == k:\n                count += 1\n\n    return count\n\ndef g() -> Tuple[str, int]:\n    \"\"\"\n    Return the input string and integer.\n    \"\"\"\n    s = \"abacaba\"\n    k = 2\n    return s, k\n\nassert f(*g()) == 10\n", "emb": null, "idx_generation": 325, "target_skills": [0, 0, 0, 0, 1, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str, k: int) -> int:\n    \"\"\"\n    Given a string s and an integer k, find the number of substrings that contain exactly k distinct characters.\n    \"\"\"\n    count = 0\n    n = len(s)\n    distinct = set()\n\n    # Iterate over all possible substrings\n    for i in range(n):\n        for j in range(i, n):\n            distinct.clear()\n            for c in s[i:j+1]:\n                distinct.add(c)\n            if len(distinct) == k:\n                count += 1\n\n    return count", "solution_func": "def g() -> Tuple[str, int]:\n    \"\"\"\n    Return the input string and integer.\n    \"\"\"\n    s = \"abacaba\"\n    k = 2\n    return s, k", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, determine the number of connected components in the grid.\n    Two characters are connected if they are adjacent horizontally or vertically.\n    \"\"\"\n    def dfs(row: int, col: int, grid: List[List[str]], visited: List[List[bool]]) -> None:\n        \"\"\"\n        Perform depth-first search on the grid to mark all connected components.\n        \"\"\"\n        visited[row][col] = True\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        for dx, dy in directions:\n            new_row = row + dx\n            new_col = col + dy\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == grid[row][col] and not visited[new_row][new_col]:\n                dfs(new_row, new_col, grid, visited)\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    visited = [[False] * cols for _ in range(rows)]\n    count = 0\n\n    # Perform depth-first search on each unvisited cell\n    for i in range(rows):\n        for j in range(cols):\n            if not visited[i][j]:\n                dfs(i, j, grid, visited)\n                count += 1\n\n    return count\n\ndef g() -> List[List[str]]:\n    \"\"\"\n    Return the input grid.\n    \"\"\"\n    grid = [\n        ['A', 'A', 'B', 'C'],\n        ['A', 'B', 'B', 'C'],\n        ['D', 'C', 'C', 'D']\n    ]\n    return grid\n\nassert f(g()) == 3\n", "emb": null, "idx_generation": 325, "target_skills": [1, 0, 1, 1, 0, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, determine the number of connected components in the grid.\n    Two characters are connected if they are adjacent horizontally or vertically.\n    \"\"\"\n    def dfs(row: int, col: int, grid: List[List[str]], visited: List[List[bool]]) -> None:\n        \"\"\"\n        Perform depth-first search on the grid to mark all connected components.\n        \"\"\"\n        visited[row][col] = True\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        for dx, dy in directions:\n            new_row = row + dx\n            new_col = col + dy\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == grid[row][col] and not visited[new_row][new_col]:\n                dfs(new_row, new_col, grid, visited)\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    visited = [[False] * cols for _ in range(rows)]\n    count = 0\n\n    # Perform depth-first search on each unvisited cell\n    for i in range(rows):\n        for j in range(cols):\n            if not visited[i][j]:\n                dfs(i, j, grid, visited)\n                count += 1\n\n    return count", "solution_func": "def g() -> List[List[str]]:\n    \"\"\"\n    Return the input grid.\n    \"\"\"\n    grid = [\n        ['A', 'A', 'B', 'C'],\n        ['A', 'B', 'B', 'C'],\n        ['D', 'C', 'C', 'D']\n    ]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    60 (since 4 * 5 * 3 = 60)\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[n-1] * nums[n-2] * nums[n-3], nums[0] * nums[1] * nums[n-1])\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 60\n\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 325, "target_skills": [0, 0, 1, 1, 1, 0, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    60 (since 4 * 5 * 3 = 60)\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[n-1] * nums[n-2] * nums[n-3], nums[0] * nums[1] * nums[n-1])", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [1, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the number of distinct prime factors of n.\n\n    Example:\n    n = 24\n\n    Output:\n    2 (since 24 has two distinct prime factors: 2 and 3)\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    factors = set()\n    for i in range(2, n+1):\n        if n % i == 0 and is_prime(i):\n            factors.add(i)\n    \n    return len(factors)\n\ndef g(n=24):\n    return n\n\nassert f(g()) == 2\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 325, "target_skills": [1, 0, 0, 0, 0, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the number of distinct prime factors of n.\n\n    Example:\n    n = 24\n\n    Output:\n    2 (since 24 has two distinct prime factors: 2 and 3)\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    factors = set()\n    for i in range(2, n+1):\n        if n % i == 0 and is_prime(i):\n            factors.add(i)\n    \n    return len(factors)", "solution_func": "def g(n=24):\n    return n", "map_ix": [1, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, find the index of the target in the list using binary search.\n\n    Example:\n    nums = [-1, 0, 3, 5, 9, 12]\n    target = 9\n\n    Output:\n    4 (since the target element 9 is at index 4)\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g():\n    nums = [-1, 0, 3, 5, 9, 12]\n    target = 9\n    return nums, target\n\nassert f(*g()) == 4\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 325, "target_skills": [1, 1, 0, 1, 0, 1, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, find the index of the target in the list using binary search.\n\n    Example:\n    nums = [-1, 0, 3, 5, 9, 12]\n    target = 9\n\n    Output:\n    4 (since the target element 9 is at index 4)\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1", "solution_func": "def g():\n    nums = [-1, 0, 3, 5, 9, 12]\n    target = 9\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the number of unique paths from the top-left corner to the bottom-right corner.\n    You can only move down or right. Additionally, you cannot pass through cells containing 1s.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = 1 if grid[0][0] == 0 else 0\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] if grid[i][0] == 0 else 0\n    \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] if grid[0][j] == 0 else 0\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            if grid[i][j] == 0:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    return grid\n\nassert f(g()) == 2\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 325, "target_skills": [0, 0, 1, 0, 0, 0, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the number of unique paths from the top-left corner to the bottom-right corner.\n    You can only move down or right. Additionally, you cannot pass through cells containing 1s.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = 1 if grid[0][0] == 0 else 0\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] if grid[i][0] == 0 else 0\n    \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] if grid[0][j] == 0 else 0\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            if grid[i][j] == 0:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[rows-1][cols-1]", "solution_func": "def g() -> List[List[int]]:\n    grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the sum of all positive integers less than or equal to n that are divisible by either 3 or 5.\n\n    Example:\n    n = 10\n    The positive integers less than or equal to 10 that are divisible by either 3 or 5 are 3, 5, 6, 9, 10.\n    The sum of these numbers is 33.\n\n    Constraints:\n    - The input integer n will always be positive.\n    \"\"\"\n    return sum(i for i in range(1, n+1) if i % 3 == 0 or i % 5 == 0)\n\ndef g(n=10):\n    return n\n\nassert f(g()) == 33\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 326, "target_skills": [0, 0, 0, 1, 1, 1, 1, 1, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the sum of all positive integers less than or equal to n that are divisible by either 3 or 5.\n\n    Example:\n    n = 10\n    The positive integers less than or equal to 10 that are divisible by either 3 or 5 are 3, 5, 6, 9, 10.\n    The sum of these numbers is 33.\n\n    Constraints:\n    - The input integer n will always be positive.\n    \"\"\"\n    return sum(i for i in range(1, n+1) if i % 3 == 0 or i % 5 == 0)", "solution_func": "def g(n=10):\n    return n", "map_ix": [1, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n    The longest substring without repeating characters is \"abc\", which has a length of 3.\n\n    Constraints:\n    - The input string s will only contain lowercase English letters.\n    \"\"\"\n    max_length = 0\n    start = 0\n    char_map = {}\n    \n    for i, char in enumerate(s):\n        if char in char_map and start <= char_map[char]:\n            start = char_map[char] + 1\n        else:\n            max_length = max(max_length, i - start + 1)\n        \n        char_map[char] = i\n    \n    return max_length\n\ndef g(s=\"abcabcbb\"):\n    return s\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 326, "target_skills": [0, 1, 1, 1, 1, 1, 0, 1, 1, 1], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n    The longest substring without repeating characters is \"abc\", which has a length of 3.\n\n    Constraints:\n    - The input string s will only contain lowercase English letters.\n    \"\"\"\n    max_length = 0\n    start = 0\n    char_map = {}\n    \n    for i, char in enumerate(s):\n        if char in char_map and start <= char_map[char]:\n            start = char_map[char] + 1\n        else:\n            max_length = max(max_length, i - start + 1)\n        \n        char_map[char] = i\n    \n    return max_length", "solution_func": "def g(s=\"abcabcbb\"):\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Given an integer n, generate the Pascal's triangle up to the nth row.\n\n    Example:\n    n = 5\n    The Pascal's triangle up to the 5th row is:\n    [\n        [1],\n        [1, 1],\n        [1, 2, 1],\n        [1, 3, 3, 1],\n        [1, 4, 6, 4, 1]\n    ]\n\n    Constraints:\n    - The input integer n will always be non-negative.\n    \"\"\"\n    triangle = []\n    \n    for i in range(n):\n        row = [1] * (i+1)\n        \n        for j in range(1, i):\n            row[j] = triangle[i-1][j-1] + triangle[i-1][j]\n        \n        triangle.append(row)\n    \n    return triangle\n\ndef g(n=5):\n    return n\n\nassert f(g()) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n", "emb": [0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 326, "target_skills": [0, 0, 1, 1, 0, 0, 0, 1, 0, 1], "problem_func": "from typing import*\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Given an integer n, generate the Pascal's triangle up to the nth row.\n\n    Example:\n    n = 5\n    The Pascal's triangle up to the 5th row is:\n    [\n        [1],\n        [1, 1],\n        [1, 2, 1],\n        [1, 3, 3, 1],\n        [1, 4, 6, 4, 1]\n    ]\n\n    Constraints:\n    - The input integer n will always be non-negative.\n    \"\"\"\n    triangle = []\n    \n    for i in range(n):\n        row = [1] * (i+1)\n        \n        for j in range(1, i):\n            row[j] = triangle[i-1][j-1] + triangle[i-1][j]\n        \n        triangle.append(row)\n    \n    return triangle", "solution_func": "def g(n=5):\n    return n", "map_ix": [0, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a subset of the array with a sum equal to zero.\n    Return True if such a subset exists, otherwise return False.\n    \"\"\"\n    n = len(nums)\n    dp = [[False] * (n + 1) for _ in range(n + 1)]\n    \n    for i in range(n + 1):\n        dp[i][0] = True\n    \n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = dp[i - 1][j]\n            if nums[i - 1] <= j:\n                dp[i][j] |= dp[i - 1][j - nums[i - 1]]\n    \n    return dp[n][n]\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5, 6]):\n    \"\"\"\n    Generate a list of integers for the function f.\n    \"\"\"\n    return nums\n\nassert f(*g()) == False\n\n", "emb": null, "idx_generation": 326, "target_skills": [0, 0, 0, 1, 1, 0, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a subset of the array with a sum equal to zero.\n    Return True if such a subset exists, otherwise return False.\n    \"\"\"\n    n = len(nums)\n    dp = [[False] * (n + 1) for _ in range(n + 1)]\n    \n    for i in range(n + 1):\n        dp[i][0] = True\n    \n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = dp[i - 1][j]\n            if nums[i - 1] <= j:\n                dp[i][j] |= dp[i - 1][j - nums[i - 1]]\n    \n    return dp[n][n]", "solution_func": "def g(nums: List[int] = [1, 2, 3, 4, 5, 6]):\n    \"\"\"\n    Generate a list of integers for the function f.\n    \"\"\"\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    Return the maximum sum.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n        \n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n        \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = grid[i][j] + max(dp[i - 1][j], dp[i][j - 1])\n            \n    return dp[m - 1][n - 1]\n\ndef g(grid: List[List[int]] = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    \"\"\"\n    Generate a 2D grid of integers for the function f.\n    \"\"\"\n    return grid\n\nassert f(*g()) == 9\n\n", "emb": null, "idx_generation": 326, "target_skills": [1, 0, 0, 1, 1, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    Return the maximum sum.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n        \n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n        \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = grid[i][j] + max(dp[i - 1][j], dp[i][j - 1])\n            \n    return dp[m - 1][n - 1]", "solution_func": "def g(grid: List[List[int]] = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    \"\"\"\n    Generate a 2D grid of integers for the function f.\n    \"\"\"\n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\n    Return the number of unique paths.\n    \"\"\"\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][0] = 1\n        \n    for j in range(n):\n        dp[0][j] = 1\n        \n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n            \n    return dp[n - 1][n - 1]\n\ndef g(n: int = 3):\n    \"\"\"\n    Generate a positive integer for the function f.\n    \"\"\"\n    return n\n\nassert f(*g()) == 6\n\n", "emb": null, "idx_generation": 326, "target_skills": [1, 1, 0, 1, 1, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\n    Return the number of unique paths.\n    \"\"\"\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][0] = 1\n        \n    for j in range(n):\n        dp[0][j] = 1\n        \n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n            \n    return dp[n - 1][n - 1]", "solution_func": "def g(n: int = 3):\n    \"\"\"\n    Generate a positive integer for the function f.\n    \"\"\"\n    return n", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Given a list of integers nums, find if there exists a subset of nums that sums up to the target,\n    with at least k elements. Return True if such subset exists, otherwise return False.\n    \"\"\"\n    def subset_sum(nums: List[int], target: int, k: int) -> bool:\n        n = len(nums)\n        dp = [[False] * (target + 1) for _ in range(n + 1)]\n        dp[0][0] = True\n\n        for i in range(1, n + 1):\n            for j in range(target + 1):\n                dp[i][j] = dp[i - 1][j]\n                if j >= nums[i - 1]:\n                    dp[i][j] = dp[i][j] or dp[i - 1][j - nums[i - 1]]\n\n        count = 0\n        for i in range(1, n + 1):\n            if dp[i][target]:\n                count += 1\n                if count >= k:\n                    return True\n\n        return False\n\n    return subset_sum(nums, target, k)\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n    k = 3\n    return nums, target, k\n\nassert f(*g()) == True\n\n", "emb": null, "idx_generation": 326, "target_skills": [0, 0, 0, 0, 1, 1, 0, 0, 1, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Given a list of integers nums, find if there exists a subset of nums that sums up to the target,\n    with at least k elements. Return True if such subset exists, otherwise return False.\n    \"\"\"\n    def subset_sum(nums: List[int], target: int, k: int) -> bool:\n        n = len(nums)\n        dp = [[False] * (target + 1) for _ in range(n + 1)]\n        dp[0][0] = True\n\n        for i in range(1, n + 1):\n            for j in range(target + 1):\n                dp[i][j] = dp[i - 1][j]\n                if j >= nums[i - 1]:\n                    dp[i][j] = dp[i][j] or dp[i - 1][j - nums[i - 1]]\n\n        count = 0\n        for i in range(1, n + 1):\n            if dp[i][target]:\n                count += 1\n                if count >= k:\n                    return True\n\n        return False\n\n    return subset_sum(nums, target, k)", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n    k = 3\n    return nums, target, k", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find the maximum subarray sum and return the subarray with that sum.\n    \"\"\"\n    def max_subarray(nums: List[int]) -> List[int]:\n        n = len(nums)\n        max_sum = float('-inf')\n        curr_sum = 0\n        start = 0\n        end = 0\n\n        for i in range(n):\n            if curr_sum < 0:\n                curr_sum = nums[i]\n                start = i\n            else:\n                curr_sum += nums[i]\n\n            if curr_sum > max_sum:\n                max_sum = curr_sum\n                end = i\n\n        return nums[start:end+1]\n\n    return max_subarray(nums)\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == [4, -1, 2, 1]\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 326, "target_skills": [1, 0, 0, 0, 0, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find the maximum subarray sum and return the subarray with that sum.\n    \"\"\"\n    def max_subarray(nums: List[int]) -> List[int]:\n        n = len(nums)\n        max_sum = float('-inf')\n        curr_sum = 0\n        start = 0\n        end = 0\n\n        for i in range(n):\n            if curr_sum < 0:\n                curr_sum = nums[i]\n                start = i\n            else:\n                curr_sum += nums[i]\n\n            if curr_sum > max_sum:\n                max_sum = curr_sum\n                end = i\n\n        return nums[start:end+1]\n\n    return max_subarray(nums)", "solution_func": "def g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": [1, 1, 0, 1, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, find the number of ways to arrange k identical objects in n distinct boxes, \n    such that each box contains at most one object. Return the total number of arrangements.\n    \"\"\"\n    def arrange_objects(n: int, k: int) -> int:\n        if k > n:\n            return 0\n        \n        dp = [[0] * (k+1) for _ in range(n+1)]\n        \n        for i in range(n+1):\n            dp[i][0] = 1\n        \n        for i in range(1, n+1):\n            for j in range(1, k+1):\n                dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n        \n        return dp[n][k]\n\n    return arrange_objects(n, k)\n\ndef g():\n    n = 5\n    k = 3\n    return n, k\n\nassert f(*g()) == 10\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 326, "target_skills": [1, 1, 1, 1, 1, 1, 0, 1, 1, 1], "problem_func": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, find the number of ways to arrange k identical objects in n distinct boxes, \n    such that each box contains at most one object. Return the total number of arrangements.\n    \"\"\"\n    def arrange_objects(n: int, k: int) -> int:\n        if k > n:\n            return 0\n        \n        dp = [[0] * (k+1) for _ in range(n+1)]\n        \n        for i in range(n+1):\n            dp[i][0] = 1\n        \n        for i in range(1, n+1):\n            for j in range(1, k+1):\n                dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n        \n        return dp[n][k]\n\n    return arrange_objects(n, k)", "solution_func": "def g():\n    n = 5\n    k = 3\n    return n, k", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the sum of all the elements in the matrix that are divisible by 3 and have a bit count of 1.\n\n    Example:\n    matrix = [[1, 3, 5],\n              [7, 9, 10],\n              [12, 15, 18]]\n    \n    The elements that are divisible by 3 and have a bit count of 1 are 3, 9, 10, 12, and 18.\n    The sum of these elements is 52.\n    \"\"\"\n    count = 0\n    for row in matrix:\n        for num in row:\n            if num % 3 == 0 and bin(num).count('1') == 1:\n                count += num\n    return count\n\ndef g(matrix: List[List[int]] = [[1, 3, 5], [7, 9, 10], [12, 15, 18]]):\n    \"\"\"\n    Generate a matrix of integers for the function f.\n    \"\"\"\n    return matrix\n\nassert f(g()) == 52\n", "emb": null, "idx_generation": 326, "target_skills": [0, 1, 1, 0, 1, 0, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the sum of all the elements in the matrix that are divisible by 3 and have a bit count of 1.\n\n    Example:\n    matrix = [[1, 3, 5],\n              [7, 9, 10],\n              [12, 15, 18]]\n    \n    The elements that are divisible by 3 and have a bit count of 1 are 3, 9, 10, 12, and 18.\n    The sum of these elements is 52.\n    \"\"\"\n    count = 0\n    for row in matrix:\n        for num in row:\n            if num % 3 == 0 and bin(num).count('1') == 1:\n                count += num\n    return count", "solution_func": "def g(matrix: List[List[int]] = [[1, 3, 5], [7, 9, 10], [12, 15, 18]]):\n    \"\"\"\n    Generate a matrix of integers for the function f.\n    \"\"\"\n    return matrix", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if it is a magic square.\n\n    A magic square is a square matrix in which the sums of each row, each column, and both diagonals are the same.\n\n    Return True if the matrix is a magic square, False otherwise.\n\n    Example:\n    matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n\n    Output:\n    True\n\n    Explanation:\n    The sums of each row, each column, and both diagonals are all equal to 15.\n    \"\"\"\n\n    n = len(matrix)\n\n    # Calculate the target sum\n    target_sum = (n * (n**2 + 1)) // 2\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = sum(matrix[i][col] for i in range(n))\n        if col_sum != target_sum:\n            return False\n\n    # Check diagonal 1\n    diagonal1_sum = sum(matrix[i][i] for i in range(n))\n    if diagonal1_sum != target_sum:\n        return False\n\n    # Check diagonal 2\n    diagonal2_sum = sum(matrix[i][n-i-1] for i in range(n))\n    if diagonal2_sum != target_sum:\n        return False\n\n    return True\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a magic square matrix.\n\n    The matrix is a square matrix of size n x n, where n is an odd number.\n\n    Example:\n    n = 3\n\n    Output:\n    [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    \"\"\"\n\n    n = 3\n    magic_square = [[0] * n for _ in range(n)]\n\n    i = n // 2\n    j = n - 1\n\n    num = 1\n\n    while num <= n**2:\n        if i == -1 and j == n:\n            i = 0\n            j = n - 2\n        else:\n            if i < 0:\n                i = n - 1\n            if j == n:\n                j = 0\n\n        if magic_square[i][j]:\n            i += 1\n            j -= 2\n            continue\n        else:\n            magic_square[i][j] = num\n            num += 1\n\n        i -= 1\n        j += 1\n\n    return magic_square\n\nassert f(g())\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 327, "target_skills": [0, 0, 1, 1, 0, 0, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if it is a magic square.\n\n    A magic square is a square matrix in which the sums of each row, each column, and both diagonals are the same.\n\n    Return True if the matrix is a magic square, False otherwise.\n\n    Example:\n    matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n\n    Output:\n    True\n\n    Explanation:\n    The sums of each row, each column, and both diagonals are all equal to 15.\n    \"\"\"\n\n    n = len(matrix)\n\n    # Calculate the target sum\n    target_sum = (n * (n**2 + 1)) // 2\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = sum(matrix[i][col] for i in range(n))\n        if col_sum != target_sum:\n            return False\n\n    # Check diagonal 1\n    diagonal1_sum = sum(matrix[i][i] for i in range(n))\n    if diagonal1_sum != target_sum:\n        return False\n\n    # Check diagonal 2\n    diagonal2_sum = sum(matrix[i][n-i-1] for i in range(n))\n    if diagonal2_sum != target_sum:\n        return False\n\n    return True", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a magic square matrix.\n\n    The matrix is a square matrix of size n x n, where n is an odd number.\n\n    Example:\n    n = 3\n\n    Output:\n    [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    \"\"\"\n\n    n = 3\n    magic_square = [[0] * n for _ in range(n)]\n\n    i = n // 2\n    j = n - 1\n\n    num = 1\n\n    while num <= n**2:\n        if i == -1 and j == n:\n            i = 0\n            j = n - 2\n        else:\n            if i < 0:\n                i = n - 1\n            if j == n:\n                j = 0\n\n        if magic_square[i][j]:\n            i += 1\n            j -= 2\n            continue\n        else:\n            magic_square[i][j] = num\n            num += 1\n\n        i -= 1\n        j += 1\n\n    return magic_square", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and a target number, find two numbers in the array that add up to the target.\n\n    Return the indices of the two numbers as a list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1 (2 and 7) add up to the target number 9.\n    \"\"\"\n\n    num_dict = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate an array of integers and a target number.\n\n    The array contains distinct elements.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    ([2, 7, 11, 15], 9)\n    \"\"\"\n\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 327, "target_skills": [1, 1, 0, 1, 1, 1, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and a target number, find two numbers in the array that add up to the target.\n\n    Return the indices of the two numbers as a list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1 (2 and 7) add up to the target number 9.\n    \"\"\"\n\n    num_dict = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate an array of integers and a target number.\n\n    The array contains distinct elements.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    ([2, 7, 11, 15], 9)\n    \"\"\"\n\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers and a target number, find the number of subarrays whose sum is less than or equal to the target.\n\n    Return the count of such subarrays.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    Output:\n    7\n\n    Explanation:\n    There are 7 subarrays whose sum is less than or equal to the target:\n    [1], [2], [3], [4], [5], [1, 2], [2, 3]\n    \"\"\"\n\n    count = 0\n    n = len(nums)\n\n    for i in range(n):\n        curr_sum = 0\n        for j in range(i, n):\n            curr_sum += nums[j]\n            if curr_sum <= target:\n                count += 1\n            else:\n                break\n\n    return count\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate an array of integers and a target number.\n\n    The array contains positive integers.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    Output:\n    ([1, 2, 3, 4, 5], 7)\n    \"\"\"\n\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    return nums, target\n\nassert f(*g()) == 7\n", "emb": null, "idx_generation": 327, "target_skills": [1, 1, 0, 1, 1, 0, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers and a target number, find the number of subarrays whose sum is less than or equal to the target.\n\n    Return the count of such subarrays.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    Output:\n    7\n\n    Explanation:\n    There are 7 subarrays whose sum is less than or equal to the target:\n    [1], [2], [3], [4], [5], [1, 2], [2, 3]\n    \"\"\"\n\n    count = 0\n    n = len(nums)\n\n    for i in range(n):\n        curr_sum = 0\n        for j in range(i, n):\n            curr_sum += nums[j]\n            if curr_sum <= target:\n                count += 1\n            else:\n                break\n\n    return count", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate an array of integers and a target number.\n\n    The array contains positive integers.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    Output:\n    ([1, 2, 3, 4, 5], 7)\n    \"\"\"\n\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    return nums, target", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, count the number of distinct substrings that can be formed using the characters in s.\n\n    Example:\n    s = \"abc\"\n    Output: 6\n    Explanation: The distinct substrings that can be formed using the characters in s are: \"a\", \"ab\", \"abc\", \"b\", \"bc\", \"c\".\n\n    Hint: Use dynamic programming to keep track of the distinct substrings.\n    \"\"\"\n\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n        dp[i] = dp[i - 1] * 2 - dp[i - 1 - ord(s[i - 1]) + ord('a')]\n\n    return dp[n]\n\ndef g(s=\"abc\"):\n    return s\n\nassert f(g()) == 6\n", "emb": null, "idx_generation": 327, "target_skills": [1, 1, 1, 0, 1, 0, 1, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, count the number of distinct substrings that can be formed using the characters in s.\n\n    Example:\n    s = \"abc\"\n    Output: 6\n    Explanation: The distinct substrings that can be formed using the characters in s are: \"a\", \"ab\", \"abc\", \"b\", \"bc\", \"c\".\n\n    Hint: Use dynamic programming to keep track of the distinct substrings.\n    \"\"\"\n\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n        dp[i] = dp[i - 1] * 2 - dp[i - 1 - ord(s[i - 1]) + ord('a')]\n\n    return dp[n]", "solution_func": "def g(s=\"abc\"):\n    return s", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 5],\n        [2, 1, 4],\n        [1, 2, 3]\n    ]\n    Output: 9\n    Explanation: The minimum sum of a path is 1 + 2 + 1 + 2 + 3 = 9.\n\n    Hint: Use dynamic programming to keep track of the minimum sum of paths.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 3, 5],\n        [2, 1, 4],\n        [1, 2, 3]\n    ]\n    return grid\n\nassert f(g()) == 9\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 327, "target_skills": [1, 1, 1, 0, 1, 1, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 5],\n        [2, 1, 4],\n        [1, 2, 3]\n    ]\n    Output: 9\n    Explanation: The minimum sum of a path is 1 + 2 + 1 + 2 + 3 = 9.\n\n    Hint: Use dynamic programming to keep track of the minimum sum of paths.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g() -> List[List[int]]:\n    grid = [\n        [1, 3, 5],\n        [2, 1, 4],\n        [1, 2, 3]\n    ]\n    return grid", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target number, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in ascending order.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    Output: [1, 4]\n    Explanation: The two numbers that add up to 7 are 2 and 5, and their indices in the list are 1 and 4.\n\n    Hint: Use two pointers technique to find the two numbers.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g(nums=[1, 2, 3, 4, 5], target=7):\n    return nums, target\n\nassert f(*g()) == [1, 4]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 327, "target_skills": [0, 0, 1, 1, 0, 0, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target number, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in ascending order.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    Output: [1, 4]\n    Explanation: The two numbers that add up to 7 are 2 and 5, and their indices in the list are 1 and 4.\n\n    Hint: Use two pointers technique to find the two numbers.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g(nums=[1, 2, 3, 4, 5], target=7):\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters representing a maze, find the minimum number of steps required to reach the exit.\n\n    Args:\n    - grid: A 2D list of characters representing the maze. The grid contains 'S' (start), 'E' (exit), '.' (open path), and '#' (blocked path).\n\n    Returns:\n    - The minimum number of steps required to reach the exit.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    visited = set()\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                visited.add((i, j))\n\n    while queue:\n        x, y, steps = queue.pop(0)\n\n        if grid[x][y] == 'E':\n            return steps\n\n        for dx, dy in directions:\n            nx = x + dx\n            ny = y + dy\n\n            if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and grid[nx][ny] != '#':\n                queue.append((nx, ny, steps + 1))\n                visited.add((nx, ny))\n\n    return -1\n\ndef g():\n    grid = [\n        ['S', '.', '.', '#', '.', '.', '.'],\n        ['#', '#', '.', '#', '.', '#', '.'],\n        ['.', '.', '.', '.', '.', '.', '.'],\n        ['.', '#', '#', '#', '#', '#', '.'],\n        ['.', '.', '.', '.', '.', '.', 'E']\n    ]\n    return grid\n\nassert f(g()) == 10\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 327, "target_skills": [0, 0, 0, 0, 1, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters representing a maze, find the minimum number of steps required to reach the exit.\n\n    Args:\n    - grid: A 2D list of characters representing the maze. The grid contains 'S' (start), 'E' (exit), '.' (open path), and '#' (blocked path).\n\n    Returns:\n    - The minimum number of steps required to reach the exit.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    visited = set()\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                visited.add((i, j))\n\n    while queue:\n        x, y, steps = queue.pop(0)\n\n        if grid[x][y] == 'E':\n            return steps\n\n        for dx, dy in directions:\n            nx = x + dx\n            ny = y + dy\n\n            if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and grid[nx][ny] != '#':\n                queue.append((nx, ny, steps + 1))\n                visited.add((nx, ny))\n\n    return -1", "solution_func": "def g():\n    grid = [\n        ['S', '.', '.', '#', '.', '.', '.'],\n        ['#', '#', '.', '#', '.', '#', '.'],\n        ['.', '.', '.', '.', '.', '.', '.'],\n        ['.', '#', '#', '#', '#', '#', '.'],\n        ['.', '.', '.', '.', '.', '.', 'E']\n    ]\n    return grid", "map_ix": [0, 0, 1, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all numbers that are divisible by 3 or 5.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The sum of all numbers that are divisible by 3 or 5.\n    \"\"\"\n    total = 0\n\n    for num in nums:\n        if num % 3 == 0 or num % 5 == 0:\n            total += num\n\n    return total\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return nums\n\nassert f(g()) == 33\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 327, "target_skills": [1, 1, 0, 0, 0, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all numbers that are divisible by 3 or 5.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The sum of all numbers that are divisible by 3 or 5.\n    \"\"\"\n    total = 0\n\n    for num in nums:\n        if num % 3 == 0 or num % 5 == 0:\n            total += num\n\n    return total", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers representing elevations, find the minimum number of steps required to go from the top-left corner to the bottom-right corner, only moving down or right.\n\n    Args:\n    - grid: A 2D list of integers representing the grid.\n\n    Returns:\n    - The minimum number of steps required to reach the bottom-right corner.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 327, "target_skills": [1, 1, 0, 1, 1, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers representing elevations, find the minimum number of steps required to go from the top-left corner to the bottom-right corner, only moving down or right.\n\n    Args:\n    - grid: A 2D list of integers representing the grid.\n\n    Returns:\n    - The minimum number of steps required to reach the bottom-right corner.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]", "solution_func": "def g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find two numbers that add up to a target value.\n\n    Args:\n    - nums: A sorted list of integers.\n    - target: The target value.\n\n    Returns:\n    - A list of two numbers that add up to the target value.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [nums[left], nums[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [3, 6]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 327, "target_skills": [0, 1, 1, 1, 1, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find two numbers that add up to a target value.\n\n    Args:\n    - nums: A sorted list of integers.\n    - target: The target value.\n\n    Returns:\n    - A list of two numbers that add up to the target value.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [nums[left], nums[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 9\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum product of any two distinct numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    20\n\n    Explanation:\n    The maximum product is 4 * 5 = 20.\n    \"\"\"\n    nums.sort()\n    return nums[-1] * nums[-2]\n\ndef g(nums: List[int]):\n    return nums\n\nassert f(g([1, 2, 3, 4, 5])) == 20\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 328, "target_skills": [1, 1, 0, 1, 0, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum product of any two distinct numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    20\n\n    Explanation:\n    The maximum product is 4 * 5 = 20.\n    \"\"\"\n    nums.sort()\n    return nums[-1] * nums[-2]", "solution_func": "def g(nums: List[int]):\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, return a new list where each string is reversed and has all its vowels removed.\n\n    Example:\n    strings = [\"hello\", \"world\", \"python\"]\n\n    Output:\n    [\"llh\", \"wrld\", \"pythn\"]\n    \"\"\"\n    def reverse_string(string: str) -> str:\n        return string[::-1]\n\n    def remove_vowels(string: str) -> str:\n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        return ''.join([char for char in string if char not in vowels])\n\n    return [remove_vowels(reverse_string(string)) for string in strings]\n\ndef g(strings: List[str]):\n    return strings\n\nassert f(g([\"hello\", \"world\", \"python\"])) == [\"llh\", \"wrld\", \"pythn\"]\n\n", "emb": null, "idx_generation": 328, "target_skills": [0, 0, 1, 1, 1, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, return a new list where each string is reversed and has all its vowels removed.\n\n    Example:\n    strings = [\"hello\", \"world\", \"python\"]\n\n    Output:\n    [\"llh\", \"wrld\", \"pythn\"]\n    \"\"\"\n    def reverse_string(string: str) -> str:\n        return string[::-1]\n\n    def remove_vowels(string: str) -> str:\n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        return ''.join([char for char in string if char not in vowels])\n\n    return [remove_vowels(reverse_string(string)) for string in strings]", "solution_func": "def g(strings: List[str]):\n    return strings", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move right or down.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    1 + 4 + 7 + 8 + 9 = 29\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = matrix[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g(matrix: List[List[int]]):\n    return matrix\n\nassert f(g([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) == 29\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 328, "target_skills": [0, 0, 1, 0, 1, 1, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move right or down.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    1 + 4 + 7 + 8 + 9 = 29\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = matrix[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    return dp[rows-1][cols-1]", "solution_func": "def g(matrix: List[List[int]]):\n    return matrix", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a matrix of integers and a target value, determine whether the target is present in the matrix.\n    The matrix is sorted in non-decreasing order from left to right and top to bottom.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n    i, j = 0, n-1\n    while i < m and j >= 0:\n        if matrix[i][j] == target:\n            return True\n        elif matrix[i][j] < target:\n            i += 1\n        else:\n            j -= 1\n    return False\n\ndef g(matrix = [[1, 4, 7], [2, 5, 8], [3, 6, 9]], target = 5):\n    return matrix, target\n\nassert f(g())\n", "emb": null, "idx_generation": 328, "target_skills": [1, 1, 1, 0, 1, 1, 1, 0, 0, 1], "problem_func": "from typing import*\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a matrix of integers and a target value, determine whether the target is present in the matrix.\n    The matrix is sorted in non-decreasing order from left to right and top to bottom.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n    i, j = 0, n-1\n    while i < m and j >= 0:\n        if matrix[i][j] == target:\n            return True\n        elif matrix[i][j] < target:\n            i += 1\n        else:\n            j -= 1\n    return False", "solution_func": "def g(matrix = [[1, 4, 7], [2, 5, 8], [3, 6, 9]], target = 5):\n    return matrix, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a perfect square.\n    A perfect square is an integer that is the square of an integer.\n    \"\"\"\n    if n < 0:\n        return False\n    elif n == 0:\n        return True\n    else:\n        left, right = 1, n\n        while left <= right:\n            mid = (left + right) // 2\n            square = mid * mid\n            if square == n:\n                return True\n            elif square < n:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False\n\ndef g(n = 16):\n    return n\n\nassert f(g())\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 328, "target_skills": [0, 1, 0, 1, 0, 0, 0, 0, 0, 1], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a perfect square.\n    A perfect square is an integer that is the square of an integer.\n    \"\"\"\n    if n < 0:\n        return False\n    elif n == 0:\n        return True\n    else:\n        left, right = 1, n\n        while left <= right:\n            mid = (left + right) // 2\n            square = mid * mid\n            if square == n:\n                return True\n            elif square < n:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False", "solution_func": "def g(n = 16):\n    return n", "map_ix": [1, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(g1: List[List[int]], g2: List[List[int]]) -> bool:\n    \"\"\"\n    Given two directed graphs, determine if they have the same number of edges.\n    The graphs are represented as adjacency matrices.\n    \"\"\"\n    n1 = sum(len(row) for row in g1)\n    n2 = sum(len(row) for row in g2)\n    return n1 == n2\n\ndef g(g1 = [[0, 1], [1, 2], [2, 3], [3, 4], [2, 5]], g2 = [[0, 4], [1, 5], [4, 1], [1, 2], [2, 3]]):\n    return g1, g2\n\nassert f(g())\n", "emb": null, "idx_generation": 328, "target_skills": [1, 0, 0, 1, 0, 1, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(g1: List[List[int]], g2: List[List[int]]) -> bool:\n    \"\"\"\n    Given two directed graphs, determine if they have the same number of edges.\n    The graphs are represented as adjacency matrices.\n    \"\"\"\n    n1 = sum(len(row) for row in g1)\n    n2 = sum(len(row) for row in g2)\n    return n1 == n2", "solution_func": "def g(g1 = [[0, 1], [1, 2], [2, 3], [3, 4], [2, 5]], g2 = [[0, 4], [1, 5], [4, 1], [1, 2], [2, 3]]):\n    return g1, g2", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix 'graph', and two vertices 'start' and 'end', determine if there is a path from 'start' to 'end' in the graph.\n\n    Example:\n    graph = [[0, 1, 0, 0],\n             [0, 0, 1, 0],\n             [0, 0, 0, 1],\n             [0, 0, 0, 0]]\n    start = 0\n    end = 3\n\n    Output:\n    True (there is a path from vertex 0 to vertex 3: 0 -> 1 -> 2 -> 3)\n    \"\"\"\n    stack = [start]\n    visited = set()\n\n    while stack:\n        node = stack.pop()\n        visited.add(node)\n\n        if node == end:\n            return True\n\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] == 1 and neighbor not in visited:\n                stack.append(neighbor)\n\n    return False\n\ndef g():\n    graph = [[0, 1, 0, 0],\n             [0, 0, 1, 0],\n             [0, 0, 0, 1],\n             [0, 0, 0, 0]]\n    start = 0\n    end = 3\n    return (graph, start, end)\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 328, "target_skills": [0, 0, 0, 1, 1, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix 'graph', and two vertices 'start' and 'end', determine if there is a path from 'start' to 'end' in the graph.\n\n    Example:\n    graph = [[0, 1, 0, 0],\n             [0, 0, 1, 0],\n             [0, 0, 0, 1],\n             [0, 0, 0, 0]]\n    start = 0\n    end = 3\n\n    Output:\n    True (there is a path from vertex 0 to vertex 3: 0 -> 1 -> 2 -> 3)\n    \"\"\"\n    stack = [start]\n    visited = set()\n\n    while stack:\n        node = stack.pop()\n        visited.add(node)\n\n        if node == end:\n            return True\n\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] == 1 and neighbor not in visited:\n                stack.append(neighbor)\n\n    return False", "solution_func": "def g():\n    graph = [[0, 1, 0, 0],\n             [0, 0, 1, 0],\n             [0, 0, 0, 1],\n             [0, 0, 0, 0]]\n    start = 0\n    end = 3\n    return (graph, start, end)", "map_ix": [0, 0, 1, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Count the number of set bits (bits with a value of 1) in an integer 'n'.\n\n    Example:\n    n = 12\n\n    Output:\n    2 (the binary representation of 12 is 1100, which has 2 set bits)\n    \"\"\"\n    count = 0\n\n    while n > 0:\n        count += n & 1\n        n >>= 1\n\n    return count\n\ndef g():\n    n = 12\n    return n\n\nassert f(g()) == 2\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 328, "target_skills": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Count the number of set bits (bits with a value of 1) in an integer 'n'.\n\n    Example:\n    n = 12\n\n    Output:\n    2 (the binary representation of 12 is 1100, which has 2 set bits)\n    \"\"\"\n    count = 0\n\n    while n > 0:\n        count += n & 1\n        n >>= 1\n\n    return count", "solution_func": "def g():\n    n = 12\n    return n", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Reverse the words in a string 's', while preserving the order of the words and the spaces between them.\n\n    Example:\n    s = \"Hello World\"\n\n    Output:\n    \"World Hello\"\n    \"\"\"\n    words = s.split()\n    reversed_words = list(reversed(words))\n    reversed_s = \" \".join(reversed_words)\n\n    return reversed_s\n\ndef g():\n    s = \"Hello World\"\n    return s\n\nassert f(g()) == \"World Hello\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 328, "target_skills": [1, 1, 1, 0, 0, 1, 1, 1, 0, 1], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Reverse the words in a string 's', while preserving the order of the words and the spaces between them.\n\n    Example:\n    s = \"Hello World\"\n\n    Output:\n    \"World Hello\"\n    \"\"\"\n    words = s.split()\n    reversed_words = list(reversed(words))\n    reversed_s = \" \".join(reversed_words)\n\n    return reversed_s", "solution_func": "def g():\n    s = \"Hello World\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with the even numbers followed by the odd numbers, while maintaining the relative order of the even and odd numbers.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n    Output: [2, 4, 6, 1, 3, 5]\n    \"\"\"\n    even_nums = sorted([num for num in nums if num % 2 == 0])\n    odd_nums = sorted([num for num in nums if num % 2 != 0])\n    return even_nums + odd_nums\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"\n    Generate a list of integers with both even and odd numbers.\n    \"\"\"\n    return nums\n\nassert f(g()) == True", "emb": null, "idx_generation": 328, "target_skills": [0, 0, 1, 1, 1, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with the even numbers followed by the odd numbers, while maintaining the relative order of the even and odd numbers.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n    Output: [2, 4, 6, 1, 3, 5]\n    \"\"\"\n    even_nums = sorted([num for num in nums if num % 2 == 0])\n    odd_nums = sorted([num for num in nums if num % 2 != 0])\n    return even_nums + odd_nums", "solution_func": "def g(nums: List[int]) -> List[int]:\n    \"\"\"\n    Generate a list of integers with both even and odd numbers.\n    \"\"\"\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers and a target value, find the index of the target in the array.\n    If the target is not found, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output:\n    2\n\n    Explanation:\n    The target value 5 is found at index 2 in the array.\n    \"\"\"\n\n    def binary_search(nums: List[int], target: int, left: int, right: int) -> int:\n        if left > right:\n            return -1\n\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            return binary_search(nums, target, mid + 1, right)\n        else:\n            return binary_search(nums, target, left, mid - 1)\n\n    return binary_search(nums, target, 0, len(nums) - 1)\n\ndef g(nums=[1, 3, 5, 7, 9], target=5):\n    return nums, target\n\nassert f(*g()) == 2\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 329, "target_skills": [1, 0, 1, 0, 1, 1, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers and a target value, find the index of the target in the array.\n    If the target is not found, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output:\n    2\n\n    Explanation:\n    The target value 5 is found at index 2 in the array.\n    \"\"\"\n\n    def binary_search(nums: List[int], target: int, left: int, right: int) -> int:\n        if left > right:\n            return -1\n\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            return binary_search(nums, target, mid + 1, right)\n        else:\n            return binary_search(nums, target, left, mid - 1)\n\n    return binary_search(nums, target, 0, len(nums) - 1)", "solution_func": "def g(nums=[1, 3, 5, 7, 9], target=5):\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom collections import defaultdict\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, every element appears twice except for one.\n    Find that single number.\n\n    Example:\n    nums = [1, 2, 2, 3, 3]\n\n    Output:\n    1\n\n    Explanation:\n    The number 1 appears only once in the array.\n    \"\"\"\n\n    count = defaultdict(int)\n\n    for num in nums:\n        count[num] += 1\n\n    for num, freq in count.items():\n        if freq == 1:\n            return num\n\ndef g(nums=[1, 2, 2, 3, 3]):\n    return nums\n\nassert f(g()) == 1\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 329, "target_skills": [0, 0, 1, 0, 1, 1, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import *\nfrom collections import defaultdict\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, every element appears twice except for one.\n    Find that single number.\n\n    Example:\n    nums = [1, 2, 2, 3, 3]\n\n    Output:\n    1\n\n    Explanation:\n    The number 1 appears only once in the array.\n    \"\"\"\n\n    count = defaultdict(int)\n\n    for num in nums:\n        count[num] += 1\n\n    for num, freq in count.items():\n        if freq == 1:\n            return num", "solution_func": "def g(nums=[1, 2, 2, 3, 3]):\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.\n\n    Example:\n    s = \"hello world\"\n\n    Output:\n    \"olleh dlrow\"\n\n    Explanation:\n    The words \"hello\" and \"world\" are reversed, while the whitespace is preserved.\n    \"\"\"\n\n    words = s.split()\n    reversed_words = [word[::-1] for word in words]\n    return ' '.join(reversed_words)\n\ndef g(s=\"hello world\"):\n    return s\n\nassert f(g()) == \"olleh dlrow\"\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 329, "target_skills": [0, 0, 0, 1, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.\n\n    Example:\n    s = \"hello world\"\n\n    Output:\n    \"olleh dlrow\"\n\n    Explanation:\n    The words \"hello\" and \"world\" are reversed, while the whitespace is preserved.\n    \"\"\"\n\n    words = s.split()\n    reversed_words = [word[::-1] for word in words]\n    return ' '.join(reversed_words)", "solution_func": "def g(s=\"hello world\"):\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\nclass Node:\n    def __init__(self, val: int, children: List['Node'] = None):\n        self.val = val\n        self.children = children if children else []\n\ndef f(root: 'Node') -> int:\n    \"\"\"\n    Given the root of a tree, return the maximum depth of the tree.\n    The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n    Example:\n    root = Node(1, [Node(2, [Node(3), Node(4)]), Node(5)])\n\n                1\n               / \\\n              2   5\n             / \\\n            3   4\n\n    Output:\n    3 (the maximum depth is 3, as the longest path is 1 -> 2 -> 4)\n    \"\"\"\n    if not root:\n        return 0\n    \n    max_depth = 0\n    for child in root.children:\n        max_depth = max(max_depth, f(child))\n    \n    return max_depth + 1\n\ndef g() -> 'Node':\n    root = Node(1, [Node(2, [Node(3), Node(4)]), Node(5)])\n    return root\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 329, "target_skills": [1, 1, 1, 0, 1, 1, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\nclass Node:\n    def __init__(self, val: int, children: List['Node'] = None):\n        self.val = val\n        self.children = children if children else []\n\ndef f(root: 'Node') -> int:\n    \"\"\"\n    Given the root of a tree, return the maximum depth of the tree.\n    The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n    Example:\n    root = Node(1, [Node(2, [Node(3), Node(4)]), Node(5)])\n\n                1\n               / \\\n              2   5\n             / \\\n            3   4\n\n    Output:\n    3 (the maximum depth is 3, as the longest path is 1 -> 2 -> 4)\n    \"\"\"\n    if not root:\n        return 0\n    \n    max_depth = 0\n    for child in root.children:\n        max_depth = max(max_depth, f(child))\n    \n    return max_depth + 1", "solution_func": "def g() -> 'Node':\n    root = Node(1, [Node(2, [Node(3), Node(4)]), Node(5)])\n    return root", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest consecutive sequence of elements in the list.\n    A consecutive sequence is a sequence of elements in which each element appears exactly once and follows the previous element by a difference of 1.\n\n    Example:\n    nums = [100, 4, 200, 1, 3, 2]\n\n    Output:\n    4 (the longest consecutive sequence is [1, 2, 3, 4])\n    \"\"\"\n    if not nums:\n        return 0\n    \n    nums_set = set(nums)\n    max_length = 0\n    \n    for num in nums:\n        if num - 1 not in nums_set:\n            curr_num = num\n            curr_length = 1\n            \n            while curr_num + 1 in nums_set:\n                curr_num += 1\n                curr_length += 1\n            \n            max_length = max(max_length, curr_length)\n    \n    return max_length\n\ndef g() -> List[int]:\n    return [100, 4, 200, 1, 3, 2]\n\nassert f(g()) == 4\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 329, "target_skills": [0, 1, 0, 0, 1, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest consecutive sequence of elements in the list.\n    A consecutive sequence is a sequence of elements in which each element appears exactly once and follows the previous element by a difference of 1.\n\n    Example:\n    nums = [100, 4, 200, 1, 3, 2]\n\n    Output:\n    4 (the longest consecutive sequence is [1, 2, 3, 4])\n    \"\"\"\n    if not nums:\n        return 0\n    \n    nums_set = set(nums)\n    max_length = 0\n    \n    for num in nums:\n        if num - 1 not in nums_set:\n            curr_num = num\n            curr_length = 1\n            \n            while curr_num + 1 in nums_set:\n                curr_num += 1\n                curr_length += 1\n            \n            max_length = max(max_length, curr_length)\n    \n    return max_length", "solution_func": "def g() -> List[int]:\n    return [100, 4, 200, 1, 3, 2]", "map_ix": [1, 1, 0, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters representing a maze, find the minimum number of steps required to reach the target 'T' from the starting position 'S'.\n    The grid contains the following characters:\n    - 'S': starting position\n    - 'T': target position\n    - '.': empty cell\n    - '#': wall (cannot pass through)\n\n    You can only move up, down, left, or right from a given cell.\n    You cannot move diagonally or pass through walls.\n\n    Example:\n    grid = [\n        ['S', '.', '#', '#'],\n        ['#', '.', '.', '#'],\n        ['.', '#', '.', '.'],\n        ['#', '#', '.', 'T']\n    ]\n\n    Output:\n    6 (the minimum number of steps required is 6)\n\n    Explanation:\n    Start at position (0, 0).\n    Move right to (0, 1).\n    Move right to (0, 2).\n    Move down to (1, 2).\n    Move down to (2, 2).\n    Move right to (2, 3).\n    Reach the target at (3, 3).\n    \"\"\"\n    if not grid or not grid[0]:\n        return -1\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    \n    start = None\n    target = None\n    \n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'T':\n                target = (i, j)\n    \n    if not start or not target:\n        return -1\n    \n    visited = set()\n    queue = [(start, 0)]\n    \n    while queue:\n        curr_pos, steps = queue.pop(0)\n        i, j = curr_pos\n        \n        if curr_pos == target:\n            return steps\n        \n        if curr_pos in visited:\n            continue\n        \n        visited.add(curr_pos)\n        \n        if i > 0 and grid[i-1][j] != '#':\n            queue.append(((i-1, j), steps+1))\n        \n        if i < rows-1 and grid[i+1][j] != '#':\n            queue.append(((i+1, j), steps+1))\n        \n        if j > 0 and grid[i][j-1] != '#':\n            queue.append(((i, j-1), steps+1))\n        \n        if j < cols-1 and grid[i][j+1] != '#':\n            queue.append(((i, j+1), steps+1))\n    \n    return -1\n\ndef g() -> List[List[str]]:\n    return [\n        ['S', '.', '#', '#'],\n        ['#', '.', '.', '#'],\n        ['.', '#', '.', '.'],\n        ['#', '#', '.', 'T']\n    ]\n\nassert f(g()) == 6\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0], "idx_generation": 329, "target_skills": [1, 0, 1, 0, 1, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters representing a maze, find the minimum number of steps required to reach the target 'T' from the starting position 'S'.\n    The grid contains the following characters:\n    - 'S': starting position\n    - 'T': target position\n    - '.': empty cell\n    - '#': wall (cannot pass through)\n\n    You can only move up, down, left, or right from a given cell.\n    You cannot move diagonally or pass through walls.\n\n    Example:\n    grid = [\n        ['S', '.', '#', '#'],\n        ['#', '.', '.', '#'],\n        ['.', '#', '.', '.'],\n        ['#', '#', '.', 'T']\n    ]\n\n    Output:\n    6 (the minimum number of steps required is 6)\n\n    Explanation:\n    Start at position (0, 0).\n    Move right to (0, 1).\n    Move right to (0, 2).\n    Move down to (1, 2).\n    Move down to (2, 2).\n    Move right to (2, 3).\n    Reach the target at (3, 3).\n    \"\"\"\n    if not grid or not grid[0]:\n        return -1\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    \n    start = None\n    target = None\n    \n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'T':\n                target = (i, j)\n    \n    if not start or not target:\n        return -1\n    \n    visited = set()\n    queue = [(start, 0)]\n    \n    while queue:\n        curr_pos, steps = queue.pop(0)\n        i, j = curr_pos\n        \n        if curr_pos == target:\n            return steps\n        \n        if curr_pos in visited:\n            continue\n        \n        visited.add(curr_pos)\n        \n        if i > 0 and grid[i-1][j] != '#':\n            queue.append(((i-1, j), steps+1))\n        \n        if i < rows-1 and grid[i+1][j] != '#':\n            queue.append(((i+1, j), steps+1))\n        \n        if j > 0 and grid[i][j-1] != '#':\n            queue.append(((i, j-1), steps+1))\n        \n        if j < cols-1 and grid[i][j+1] != '#':\n            queue.append(((i, j+1), steps+1))\n    \n    return -1", "solution_func": "def g() -> List[List[str]]:\n    return [\n        ['S', '.', '#', '#'],\n        ['#', '.', '.', '#'],\n        ['.', '#', '.', '.'],\n        ['#', '#', '.', 'T']\n    ]", "map_ix": [1, 0, 1, 0, 0, 0, 1, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, calculate the sum of all even numbers in the list.\n\n    Args:\n    - nums: A list of integers\n\n    Returns:\n    - The sum of all even numbers in the list\n    \"\"\"\n    even_sum = 0\n    for num in nums:\n        if num % 2 == 0:\n            even_sum += num\n    return even_sum\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return nums\n\nassert f(g()) == 30\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 329, "target_skills": [1, 0, 1, 1, 0, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, calculate the sum of all even numbers in the list.\n\n    Args:\n    - nums: A list of integers\n\n    Returns:\n    - The sum of all even numbers in the list\n    \"\"\"\n    even_sum = 0\n    for num in nums:\n        if num % 2 == 0:\n            even_sum += num\n    return even_sum", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size n x n, where each cell contains either 0 or 1, determine the number of islands in the grid.\n    An island is formed by connecting adjacent cells horizontally or vertically (not diagonally) that contain a value of 1.\n\n    Args:\n    - n: An integer representing the size of the grid\n    - grid: A 2D list of integers representing the grid\n\n    Returns:\n    - The number of islands in the grid\n\n    Example:\n    n = 4, grid = [\n        [1, 1, 0, 0],\n        [0, 1, 0, 0],\n        [1, 0, 0, 1],\n        [0, 0, 1, 0]\n    ]\n    The grid has 4 islands, so the output should be 4.\n    \"\"\"\n    def dfs(i, j):\n        if i < 0 or i >= n or j < 0 or j >= n or grid[i][j] != 1:\n            return\n        grid[i][j] = -1\n        dfs(i+1, j)\n        dfs(i-1, j)\n        dfs(i, j+1)\n        dfs(i, j-1)\n\n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                count += 1\n                dfs(i, j)\n    return count\n\ndef g():\n    n = 4\n    grid = [\n        [1, 1, 0, 0],\n        [0, 1, 0, 0],\n        [1, 0, 0, 1],\n        [0, 0, 1, 0]\n    ]\n    return n, grid\n\nassert f(*g()) == 4\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0], "idx_generation": 329, "target_skills": [0, 1, 1, 1, 0, 1, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size n x n, where each cell contains either 0 or 1, determine the number of islands in the grid.\n    An island is formed by connecting adjacent cells horizontally or vertically (not diagonally) that contain a value of 1.\n\n    Args:\n    - n: An integer representing the size of the grid\n    - grid: A 2D list of integers representing the grid\n\n    Returns:\n    - The number of islands in the grid\n\n    Example:\n    n = 4, grid = [\n        [1, 1, 0, 0],\n        [0, 1, 0, 0],\n        [1, 0, 0, 1],\n        [0, 0, 1, 0]\n    ]\n    The grid has 4 islands, so the output should be 4.\n    \"\"\"\n    def dfs(i, j):\n        if i < 0 or i >= n or j < 0 or j >= n or grid[i][j] != 1:\n            return\n        grid[i][j] = -1\n        dfs(i+1, j)\n        dfs(i-1, j)\n        dfs(i, j+1)\n        dfs(i, j-1)\n\n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                count += 1\n                dfs(i, j)\n    return count", "solution_func": "def g():\n    n = 4\n    grid = [\n        [1, 1, 0, 0],\n        [0, 1, 0, 0],\n        [1, 0, 0, 1],\n        [0, 0, 1, 0]\n    ]\n    return n, grid", "map_ix": [0, 0, 1, 0, 0, 0, 1, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, determine the length of the longest substring without repeating characters.\n\n    Args:\n    - s: A string\n\n    Returns:\n    - The length of the longest substring without repeating characters\n\n    Example:\n    s = \"abcabcbb\"\n    The longest substring without repeating characters is \"abc\", so the output should be 3.\n    \"\"\"\n    max_len = 0\n    start = 0\n    char_dict = {}\n    for i, char in enumerate(s):\n        if char in char_dict and start <= char_dict[char]:\n            start = char_dict[char] + 1\n        else:\n            max_len = max(max_len, i - start + 1)\n        char_dict[char] = i\n    return max_len\n\ndef g():\n    s = \"abcabcbb\"\n    return s\n\nassert f(g()) == 3\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 329, "target_skills": [1, 0, 0, 0, 1, 1, 1, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, determine the length of the longest substring without repeating characters.\n\n    Args:\n    - s: A string\n\n    Returns:\n    - The length of the longest substring without repeating characters\n\n    Example:\n    s = \"abcabcbb\"\n    The longest substring without repeating characters is \"abc\", so the output should be 3.\n    \"\"\"\n    max_len = 0\n    start = 0\n    char_dict = {}\n    for i, char in enumerate(s):\n        if char in char_dict and start <= char_dict[char]:\n            start = char_dict[char] + 1\n        else:\n            max_len = max(max_len, i - start + 1)\n        char_dict[char] = i\n    return max_len", "solution_func": "def g():\n    s = \"abcabcbb\"\n    return s", "map_ix": [1, 1, 0, 1, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the missing number in the range from 0 to n.\n    The list does not contain any duplicates.\n\n    Example:\n    Input: [9, 6, 4, 2, 3, 5, 7, 0, 1]\n    Output: 8\n    Explanation: The missing number in the range from 0 to 9 is 8.\n    \"\"\"\n\n    # Sort the list in ascending order\n    nums.sort()\n\n    # Check if 0 is missing as the first element\n    if nums[0] != 0:\n        return 0\n\n    # Check if n is missing as the last element\n    if nums[-1] != len(nums):\n        return len(nums)\n\n    # Iterate through the sorted list and find the missing number\n    for i in range(1, len(nums)):\n        if nums[i] - nums[i-1] != 1:\n            return nums[i-1] + 1\n\n    return -1\n\ndef g() -> List[int]:\n    return [9, 6, 4, 2, 3, 5, 7, 0, 1]\n\nassert f(g()) == 8\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 329, "target_skills": [1, 1, 1, 1, 0, 0, 0, 1, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the missing number in the range from 0 to n.\n    The list does not contain any duplicates.\n\n    Example:\n    Input: [9, 6, 4, 2, 3, 5, 7, 0, 1]\n    Output: 8\n    Explanation: The missing number in the range from 0 to 9 is 8.\n    \"\"\"\n\n    # Sort the list in ascending order\n    nums.sort()\n\n    # Check if 0 is missing as the first element\n    if nums[0] != 0:\n        return 0\n\n    # Check if n is missing as the last element\n    if nums[-1] != len(nums):\n        return len(nums)\n\n    # Iterate through the sorted list and find the missing number\n    for i in range(1, len(nums)):\n        if nums[i] - nums[i-1] != 1:\n            return nums[i-1] + 1\n\n    return -1", "solution_func": "def g() -> List[int]:\n    return [9, 6, 4, 2, 3, 5, 7, 0, 1]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Check if a given array contains a pair of elements whose sum is equal to the product of their indices.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] + arr[j] == i * j:\n                return True\n    return False\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate an array with random integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == False\n", "emb": null, "idx_generation": 330, "target_skills": [1, 0, 0, 1, 1, 1, 1, 1, 0, 0], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Check if a given array contains a pair of elements whose sum is equal to the product of their indices.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] + arr[j] == i * j:\n                return True\n    return False", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate an array with random integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]", "map_ix": null}, {"fitness": -Infinity, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the sum of all numbers in the grid that are surrounded by other numbers (left, right, top, bottom).\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    total = 0\n    for r in range(1, rows-1):\n        for c in range(1, cols-1):\n            if grid[r][c] != 0 and grid[r-1][c] != 0 and grid[r+1][c] != 0 and grid[r][c-1] != 0 and grid[r][c+1] != 0:\n                total += grid[r][c]\n\n    return total\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid with random numbers.\n    \"\"\"\n    return [[0, 0, 0, 0, 0],\n            [0, 1, 2, 3, 0],\n            [0, 4, 5, 6, 0],\n            [0, 7, 8, 9, 0],\n            [0, 0, 0, 0, 0]]\n\nassert f(g()) == 25\n", "emb": null, "idx_generation": 330, "target_skills": [0, 0, 0, 0, 1, 1, 1, 1, 1, 1], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the sum of all numbers in the grid that are surrounded by other numbers (left, right, top, bottom).\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    total = 0\n    for r in range(1, rows-1):\n        for c in range(1, cols-1):\n            if grid[r][c] != 0 and grid[r-1][c] != 0 and grid[r+1][c] != 0 and grid[r][c-1] != 0 and grid[r][c+1] != 0:\n                total += grid[r][c]\n\n    return total", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid with random numbers.\n    \"\"\"\n    return [[0, 0, 0, 0, 0],\n            [0, 1, 2, 3, 0],\n            [0, 4, 5, 6, 0],\n            [0, 7, 8, 9, 0],\n            [0, 0, 0, 0, 0]]", "map_ix": null}, {"fitness": 1.0, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid, find the maximum XOR value that can be obtained by performing XOR operation on two elements in the grid.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    max_xor = 0\n    for r1 in range(rows):\n        for c1 in range(cols):\n            for r2 in range(rows):\n                for c2 in range(cols):\n                    xor = grid[r1][c1] ^ grid[r2][c2]\n                    if xor > max_xor:\n                        max_xor = xor\n\n    return max_xor\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid with random numbers.\n    \"\"\"\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\nassert f(g()) == 15\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0], "idx_generation": 330, "target_skills": [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid, find the maximum XOR value that can be obtained by performing XOR operation on two elements in the grid.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    max_xor = 0\n    for r1 in range(rows):\n        for c1 in range(cols):\n            for r2 in range(rows):\n                for c2 in range(cols):\n                    xor = grid[r1][c1] ^ grid[r2][c2]\n                    if xor > max_xor:\n                        max_xor = xor\n\n    return max_xor", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid with random numbers.\n    \"\"\"\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]", "map_ix": [1, 1, 0, 1, 0, 1, 1, 1, 1, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\n\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if they are isomorphic.\n    Two strings are isomorphic if the characters in s can be replaced to get t.\n\n    Example:\n    Input: s = \"egg\", t = \"add\"\n    Output: True\n\n    Explanation: \"egg\" can be replaced by \"add\" to get t.\n\n    Input: s = \"foo\", t = \"bar\"\n    Output: False\n\n    Explanation: \"foo\" cannot be replaced by \"bar\" to get t.\n    \"\"\"\n    if len(s) != len(t):\n        return False\n\n    char_map = {}\n    used_chars = set()\n\n    for i in range(len(s)):\n        if s[i] not in char_map:\n            if t[i] in used_chars:\n                return False\n            char_map[s[i]] = t[i]\n            used_chars.add(t[i])\n        elif char_map[s[i]] != t[i]:\n            return False\n\n    return True\n\ndef g(s: str = \"egg\", t: str = \"add\"):\n    return (s, t)\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 330, "target_skills": [0, 0, 0, 1, 1, 0, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if they are isomorphic.\n    Two strings are isomorphic if the characters in s can be replaced to get t.\n\n    Example:\n    Input: s = \"egg\", t = \"add\"\n    Output: True\n\n    Explanation: \"egg\" can be replaced by \"add\" to get t.\n\n    Input: s = \"foo\", t = \"bar\"\n    Output: False\n\n    Explanation: \"foo\" cannot be replaced by \"bar\" to get t.\n    \"\"\"\n    if len(s) != len(t):\n        return False\n\n    char_map = {}\n    used_chars = set()\n\n    for i in range(len(s)):\n        if s[i] not in char_map:\n            if t[i] in used_chars:\n                return False\n            char_map[s[i]] = t[i]\n            used_chars.add(t[i])\n        elif char_map[s[i]] != t[i]:\n            return False\n\n    return True", "solution_func": "def g(s: str = \"egg\", t: str = \"add\"):\n    return (s, t)", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import *\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size m x n, find the number of distinct islands.\n    An island is considered to be a group of connected cells with the same value.\n\n    Example:\n    Input: grid = [[1, 1, 0, 0, 0],\n                   [1, 1, 0, 0, 0],\n                   [0, 0, 0, 1, 1],\n                   [0, 0, 0, 1, 1]]\n    Output: 3\n\n    Explanation: There are 3 distinct islands in the grid.\n\n    - Island 1: (0, 0), (0, 1), (1, 0), (1, 1)\n    - Island 2: (2, 3), (2, 4), (3, 3), (3, 4)\n    - Island 3: (2, 4), (3, 3), (3, 4)\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    visited = [[False] * n for _ in range(m)]\n    distinct_islands = set()\n\n    def dfs(i, j, path):\n        if i < 0 or i >= m or j < 0 or j >= n or visited[i][j] or grid[i][j] == 0:\n            return\n\n        visited[i][j] = True\n        path.append((i, j))\n\n        dfs(i+1, j, path)\n        dfs(i-1, j, path)\n        dfs(i, j+1, path)\n        dfs(i, j-1, path)\n\n    for i in range(m):\n        for j in range(n):\n            if not visited[i][j] and grid[i][j] == 1:\n                path = []\n                dfs(i, j, path)\n                distinct_islands.add(tuple(path))\n\n    return len(distinct_islands)\n\ndef g(grid: List[List[int]] = [[1, 1, 0, 0, 0],\n                               [1, 1, 0, 0, 0],\n                               [0, 0, 0, 1, 1],\n                               [0, 0, 0, 1, 1]]):\n    return (grid,)\n\nassert f(*g()) == 3\n", "emb": null, "idx_generation": 330, "target_skills": [1, 1, 0, 1, 1, 1, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size m x n, find the number of distinct islands.\n    An island is considered to be a group of connected cells with the same value.\n\n    Example:\n    Input: grid = [[1, 1, 0, 0, 0],\n                   [1, 1, 0, 0, 0],\n                   [0, 0, 0, 1, 1],\n                   [0, 0, 0, 1, 1]]\n    Output: 3\n\n    Explanation: There are 3 distinct islands in the grid.\n\n    - Island 1: (0, 0), (0, 1), (1, 0), (1, 1)\n    - Island 2: (2, 3), (2, 4), (3, 3), (3, 4)\n    - Island 3: (2, 4), (3, 3), (3, 4)\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    visited = [[False] * n for _ in range(m)]\n    distinct_islands = set()\n\n    def dfs(i, j, path):\n        if i < 0 or i >= m or j < 0 or j >= n or visited[i][j] or grid[i][j] == 0:\n            return\n\n        visited[i][j] = True\n        path.append((i, j))\n\n        dfs(i+1, j, path)\n        dfs(i-1, j, path)\n        dfs(i, j+1, path)\n        dfs(i, j-1, path)\n\n    for i in range(m):\n        for j in range(n):\n            if not visited[i][j] and grid[i][j] == 1:\n                path = []\n                dfs(i, j, path)\n                distinct_islands.add(tuple(path))\n\n    return len(distinct_islands)", "solution_func": "def g(grid: List[List[int]] = [[1, 1, 0, 0, 0],\n                               [1, 1, 0, 0, 0],\n                               [0, 0, 0, 1, 1],\n                               [0, 0, 0, 1, 1]]):\n    return (grid,)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the nth Fibonacci number.\n\n    Example:\n    Input: n = 6\n    Output: 8\n\n    Explanation: The 6th Fibonacci number is 8 (0, 1, 1, 2, 3, 5, 8).\n    \"\"\"\n    if n <= 1:\n        return n\n\n    fib = [0] * (n+1)\n    fib[1] = 1\n\n    for i in range(2, n+1):\n        fib[i] = fib[i-1] + fib[i-2]\n\n    return fib[n]\n\ndef g(n: int = 6):\n    return (n,)\n\nassert f(*g()) == 8\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 330, "target_skills": [1, 1, 1, 1, 1, 0, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the nth Fibonacci number.\n\n    Example:\n    Input: n = 6\n    Output: 8\n\n    Explanation: The 6th Fibonacci number is 8 (0, 1, 1, 2, 3, 5, 8).\n    \"\"\"\n    if n <= 1:\n        return n\n\n    fib = [0] * (n+1)\n    fib[1] = 1\n\n    for i in range(2, n+1):\n        fib[i] = fib[i-1] + fib[i-2]\n\n    return fib[n]", "solution_func": "def g(n: int = 6):\n    return (n,)", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> str:\n    \"\"\"\n    Given a positive integer n, return the nth term of the Look-and-say sequence.\n    The Look-and-say sequence starts with 1, and each subsequent term is formed by \"saying\" the previous term.\n    To \"say\" a term, count the number of consecutive digits and append the count followed by the digit.\n    \n    Sample Input:\n    n = 5\n    \n    Sample Output:\n    \"111221\"\n    \n    Explanation:\n    The Look-and-say sequence up to the 5th term is:\n    1\n    11\n    21\n    1211\n    111221\n    The 5th term is \"111221\".\n    \"\"\"\n    if n == 1:\n        return \"1\"\n    \n    prev_term = f(n-1)\n    count = 0\n    digit = prev_term[0]\n    result = \"\"\n    \n    for i in range(len(prev_term)):\n        if prev_term[i] == digit:\n            count += 1\n        else:\n            result += str(count) + digit\n            count = 1\n            digit = prev_term[i]\n    \n    result += str(count) + digit\n    return result\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == \"111221\"\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 330, "target_skills": [0, 1, 1, 1, 0, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> str:\n    \"\"\"\n    Given a positive integer n, return the nth term of the Look-and-say sequence.\n    The Look-and-say sequence starts with 1, and each subsequent term is formed by \"saying\" the previous term.\n    To \"say\" a term, count the number of consecutive digits and append the count followed by the digit.\n    \n    Sample Input:\n    n = 5\n    \n    Sample Output:\n    \"111221\"\n    \n    Explanation:\n    The Look-and-say sequence up to the 5th term is:\n    1\n    11\n    21\n    1211\n    111221\n    The 5th term is \"111221\".\n    \"\"\"\n    if n == 1:\n        return \"1\"\n    \n    prev_term = f(n-1)\n    count = 0\n    digit = prev_term[0]\n    result = \"\"\n    \n    for i in range(len(prev_term)):\n        if prev_term[i] == digit:\n            count += 1\n        else:\n            result += str(count) + digit\n            count = 1\n            digit = prev_term[i]\n    \n    result += str(count) + digit\n    return result", "solution_func": "def g():\n    n = 5\n    return n", "map_ix": [1, 1, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(adj_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix of a directed graph, determine if the graph contains a cycle or not.\n    Return True if the graph contains a cycle, and False otherwise.\n    \n    Sample Input:\n    adj_matrix = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 0, 0, 0]\n    ]\n    \n    Sample Output:\n    True\n    \n    Explanation:\n    The given adjacency matrix represents the following directed graph:\n    0 -> 1 -> 2 -> 3 -> 0\n    The graph contains a cycle, so the output is True.\n    \"\"\"\n    def dfs(node, visited, stack):\n        visited[node] = True\n        stack[node] = True\n        \n        for neighbor in range(len(adj_matrix)):\n            if adj_matrix[node][neighbor] == 1:\n                if not visited[neighbor]:\n                    if dfs(neighbor, visited, stack):\n                        return True\n                elif stack[neighbor]:\n                    return True\n        \n        stack[node] = False\n        return False\n    \n    num_nodes = len(adj_matrix)\n    visited = [False] * num_nodes\n    stack = [False] * num_nodes\n    \n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(node, visited, stack):\n                return True\n    \n    return False\n\ndef g():\n    adj_matrix = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 0, 0, 0]\n    ]\n    return adj_matrix\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 330, "target_skills": [0, 0, 1, 0, 1, 0, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(adj_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix of a directed graph, determine if the graph contains a cycle or not.\n    Return True if the graph contains a cycle, and False otherwise.\n    \n    Sample Input:\n    adj_matrix = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 0, 0, 0]\n    ]\n    \n    Sample Output:\n    True\n    \n    Explanation:\n    The given adjacency matrix represents the following directed graph:\n    0 -> 1 -> 2 -> 3 -> 0\n    The graph contains a cycle, so the output is True.\n    \"\"\"\n    def dfs(node, visited, stack):\n        visited[node] = True\n        stack[node] = True\n        \n        for neighbor in range(len(adj_matrix)):\n            if adj_matrix[node][neighbor] == 1:\n                if not visited[neighbor]:\n                    if dfs(neighbor, visited, stack):\n                        return True\n                elif stack[neighbor]:\n                    return True\n        \n        stack[node] = False\n        return False\n    \n    num_nodes = len(adj_matrix)\n    visited = [False] * num_nodes\n    stack = [False] * num_nodes\n    \n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(node, visited, stack):\n                return True\n    \n    return False", "solution_func": "def g():\n    adj_matrix = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 0, 0, 0]\n    ]\n    return adj_matrix", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(num1: int, num2: int) -> int:\n    \"\"\"\n    Given two positive integers num1 and num2, compute the greatest common divisor (GCD) of the two numbers.\n    The GCD is the largest positive integer that divides both num1 and num2 without leaving a remainder.\n    \n    Sample Input:\n    num1 = 24\n    num2 = 36\n    \n    Sample Output:\n    12\n    \n    Explanation:\n    The factors of 24 are 1, 2, 3, 4, 6, 8, 12, 24.\n    The factors of 36 are 1, 2, 3, 4, 6, 9, 12, 18, 36.\n    The largest common factor is 12, so the output is 12.\n    \"\"\"\n    while num2 != 0:\n        temp = num2\n        num2 = num1 % num2\n        num1 = temp\n    \n    return num1\n\ndef g():\n    num1 = 24\n    num2 = 36\n    return num1, num2\n\nassert f(*g()) == 12\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 330, "target_skills": [0, 0, 0, 0, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\ndef f(num1: int, num2: int) -> int:\n    \"\"\"\n    Given two positive integers num1 and num2, compute the greatest common divisor (GCD) of the two numbers.\n    The GCD is the largest positive integer that divides both num1 and num2 without leaving a remainder.\n    \n    Sample Input:\n    num1 = 24\n    num2 = 36\n    \n    Sample Output:\n    12\n    \n    Explanation:\n    The factors of 24 are 1, 2, 3, 4, 6, 8, 12, 24.\n    The factors of 36 are 1, 2, 3, 4, 6, 9, 12, 18, 36.\n    The largest common factor is 12, so the output is 12.\n    \"\"\"\n    while num2 != 0:\n        temp = num2\n        num2 = num1 % num2\n        num1 = temp\n    \n    return num1", "solution_func": "def g():\n    num1 = 24\n    num2 = 36\n    return num1, num2", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and an integer k, return True if there exists a subarray in nums that sums up to k,\n    otherwise return False.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    k = 9\n\n    Output:\n    True\n    \"\"\"\n    n = len(nums)\n    prefix_sum = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]\n\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            if prefix_sum[j] - prefix_sum[i] == k:\n                return True\n\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    k = 9\n    return nums, k\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 330, "target_skills": [0, 1, 1, 0, 1, 0, 1, 0, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and an integer k, return True if there exists a subarray in nums that sums up to k,\n    otherwise return False.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    k = 9\n\n    Output:\n    True\n    \"\"\"\n    n = len(nums)\n    prefix_sum = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]\n\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            if prefix_sum[j] - prefix_sum[i] == k:\n                return True\n\n    return False", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    k = 9\n    return nums, k", "map_ix": [1, 0, 1, 1, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, determine whether it is a prime number.\n\n    A prime number is a natural number greater than 1 that is not a product of two smaller natural numbers.\n\n    Return True if n is prime, False otherwise.\n\n    Example:\n    n = 7\n\n    Output:\n    True\n\n    Explanation:\n    7 is a prime number.\n    \"\"\"\n\n    if n <= 1:\n        return False\n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n\n    return True\n\ndef g(n=7):\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    return n\n\nassert f(g()) == True\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 331, "target_skills": [0, 0, 0, 1, 0, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, determine whether it is a prime number.\n\n    A prime number is a natural number greater than 1 that is not a product of two smaller natural numbers.\n\n    Return True if n is prime, False otherwise.\n\n    Example:\n    n = 7\n\n    Output:\n    True\n\n    Explanation:\n    7 is a prime number.\n    \"\"\"\n\n    if n <= 1:\n        return False\n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n\n    return True", "solution_func": "def g(n=7):\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    return n", "map_ix": [1, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of the words in the string.\n\n    A word is defined as a sequence of non-space characters.\n\n    Return the string with the words reversed.\n\n    Example:\n    s = \"Hello World\"\n\n    Output:\n    \"World Hello\"\n\n    Explanation:\n    The order of the words in the string is reversed.\n    \"\"\"\n\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)\n\ndef g(s=\"Hello World\"):\n    \"\"\"\n    Generate a string s.\n    \"\"\"\n    return s\n\nassert f(g()) == \"World Hello\"\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 331, "target_skills": [0, 1, 0, 1, 0, 0, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of the words in the string.\n\n    A word is defined as a sequence of non-space characters.\n\n    Return the string with the words reversed.\n\n    Example:\n    s = \"Hello World\"\n\n    Output:\n    \"World Hello\"\n\n    Explanation:\n    The order of the words in the string is reversed.\n    \"\"\"\n\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)", "solution_func": "def g(s=\"Hello World\"):\n    \"\"\"\n    Generate a string s.\n    \"\"\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import *\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the maximum sum of a subarray of size k in an array of integers.\n\n    Return the maximum sum.\n\n    Example:\n    n = 7\n\n    Output:\n    12\n\n    Explanation:\n    The maximum sum of a subarray of size 3 in the array [1, 2, 3, 4, 5, 6, 7] is 12 (4 + 5 + 6).\n    \"\"\"\n\n    arr = [i for i in range(1, n+1)]\n    k = 3\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for i in range(len(arr)):\n        current_sum += arr[i]\n        if i >= k - 1:\n            max_sum = max(max_sum, current_sum)\n            current_sum -= arr[i-k+1]\n\n    return max_sum\n\ndef g(n=7):\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    return n\n\nassert f(g()) == 12\n\n", "emb": null, "idx_generation": 331, "target_skills": [1, 1, 1, 0, 0, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the maximum sum of a subarray of size k in an array of integers.\n\n    Return the maximum sum.\n\n    Example:\n    n = 7\n\n    Output:\n    12\n\n    Explanation:\n    The maximum sum of a subarray of size 3 in the array [1, 2, 3, 4, 5, 6, 7] is 12 (4 + 5 + 6).\n    \"\"\"\n\n    arr = [i for i in range(1, n+1)]\n    k = 3\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for i in range(len(arr)):\n        current_sum += arr[i]\n        if i >= k - 1:\n            max_sum = max(max_sum, current_sum)\n            current_sum -= arr[i-k+1]\n\n    return max_sum", "solution_func": "def g(n=7):\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    return n", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the number of distinct subsequences that can be formed from s.\n    Return the number of distinct subsequences.\n    \"\"\"\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    last_occurrence = [-1] * 256\n\n    for i in range(1, n + 1):\n        dp[i] = 2 * dp[i - 1]\n        if last_occurrence[ord(s[i - 1])] != -1:\n            dp[i] -= dp[last_occurrence[ord(s[i - 1])]]\n        last_occurrence[ord(s[i - 1])] = i - 1\n\n    return dp[n]\n\ndef g() -> str:\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"abcabc\"\n\nassert f(g()) == 7\n", "emb": null, "idx_generation": 331, "target_skills": [0, 1, 1, 0, 1, 1, 0, 1, 1, 1], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the number of distinct subsequences that can be formed from s.\n    Return the number of distinct subsequences.\n    \"\"\"\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    last_occurrence = [-1] * 256\n\n    for i in range(1, n + 1):\n        dp[i] = 2 * dp[i - 1]\n        if last_occurrence[ord(s[i - 1])] != -1:\n            dp[i] -= dp[last_occurrence[ord(s[i - 1])]]\n        last_occurrence[ord(s[i - 1])] = i - 1\n\n    return dp[n]", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"abcabc\"", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of different ways to represent n as a sum of 1, 3, and 4.\n    Return the number of ways.\n    \"\"\"\n    if n <= 1:\n        return 1\n\n    if n == 2:\n        return 2\n\n    if n == 3:\n        return 4\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    dp[2] = 2\n    dp[3] = 4\n\n    for i in range(4, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 3] + dp[i - 4]\n\n    return dp[n]\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return 6\n\nassert f(g()) == 18\n", "emb": null, "idx_generation": 331, "target_skills": [0, 1, 0, 0, 1, 0, 0, 0, 1, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of different ways to represent n as a sum of 1, 3, and 4.\n    Return the number of ways.\n    \"\"\"\n    if n <= 1:\n        return 1\n\n    if n == 2:\n        return 2\n\n    if n == 3:\n        return 4\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    dp[2] = 2\n    dp[3] = 4\n\n    for i in range(4, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 3] + dp[i - 4]\n\n    return dp[n]", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return 6", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray with the constraint that no two numbers in the subarray are adjacent.\n    Return the maximum sum.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n\n    if n == 1:\n        return nums[0]\n\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n    return dp[n - 1]\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 9\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0], "idx_generation": 331, "target_skills": [1, 1, 0, 0, 1, 1, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray with the constraint that no two numbers in the subarray are adjacent.\n    Return the maximum sum.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n\n    if n == 1:\n        return nums[0]\n\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n    return dp[n - 1]", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 1]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(arr: List[int], target=10) -> bool:\n    \"\"\"\n    Given a sorted array of integers, determine if there exists two numbers in the array such that their sum is equal to the target.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(target = 10):\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return arr\n\nassert f(g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 331, "target_skills": [0, 0, 1, 1, 1, 1, 0, 0, 1, 0], "problem_func": "from typing import*\ndef f(arr: List[int], target=10) -> bool:\n    \"\"\"\n    Given a sorted array of integers, determine if there exists two numbers in the array such that their sum is equal to the target.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False", "solution_func": "def g(target = 10):\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return arr", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], target: str) -> List[str]:\n    \"\"\"\n    Given a list of words, return all the words that can be formed using the letters of the target word.\n    \"\"\"\n    target_count = {}\n    for char in target:\n        target_count[char] = target_count.get(char, 0) + 1\n    \n    result = []\n    for word in words:\n        word_count = {}\n        for char in word:\n            word_count[char] = word_count.get(char, 0) + 1\n        \n        is_possible = True\n        for char in target_count:\n            if char not in word_count or word_count[char] < target_count[char]:\n                is_possible = False\n                break\n        \n        if is_possible:\n            result.append(word)\n    \n    return result\n\ndef g(target = \"abc\"):\n    words = [\"abc\", \"def\", \"cba\", \"fed\", \"cab\"]\n    return words\n\nassert f(g()) == [\"abc\", \"cba\", \"cab\"]\n", "emb": null, "idx_generation": 331, "target_skills": [0, 0, 0, 1, 1, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], target: str) -> List[str]:\n    \"\"\"\n    Given a list of words, return all the words that can be formed using the letters of the target word.\n    \"\"\"\n    target_count = {}\n    for char in target:\n        target_count[char] = target_count.get(char, 0) + 1\n    \n    result = []\n    for word in words:\n        word_count = {}\n        for char in word:\n            word_count[char] = word_count.get(char, 0) + 1\n        \n        is_possible = True\n        for char in target_count:\n            if char not in word_count or word_count[char] < target_count[char]:\n                is_possible = False\n                break\n        \n        if is_possible:\n            result.append(word)\n    \n    return result", "solution_func": "def g(target = \"abc\"):\n    words = [\"abc\", \"def\", \"cba\", \"fed\", \"cab\"]\n    return words", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target number using binary search.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g(target = 7):\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return nums\n\nassert f(g()) == 6\n", "emb": null, "idx_generation": 331, "target_skills": [0, 1, 1, 0, 0, 1, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target number using binary search.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1", "solution_func": "def g(target = 7):\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "import itertools\nfrom typing import*\nfrom typing import *\nfrom itertools import permutations\n\ndef f(s: str, target: str) -> List[str]:\n    \"\"\"\n    Given a string s and a target string, find all permutations of s that contain the target string.\n\n    Example:\n    s = \"abc\"\n    target = \"ab\"\n\n    Output:\n    [\"ab\", \"ba\"]\n    \"\"\"\n    perms = [''.join(p) for p in permutations(s)]\n    result = [perm for perm in perms if target in perm]\n    return result\n\ndef g() -> Tuple[str, str]:\n    return (\"abc\", \"ab\")\n\nassert f(*g()) == [\"ab\", \"ba\"]\n", "emb": null, "idx_generation": 331, "target_skills": [0, 0, 1, 0, 0, 0, 1, 0, 1, 1], "problem_func": "import itertools\nfrom typing import*\nfrom typing import *\nfrom itertools import permutations\n\ndef f(s: str, target: str) -> List[str]:\n    \"\"\"\n    Given a string s and a target string, find all permutations of s that contain the target string.\n\n    Example:\n    s = \"abc\"\n    target = \"ab\"\n\n    Output:\n    [\"ab\", \"ba\"]\n    \"\"\"\n    perms = [''.join(p) for p in permutations(s)]\n    result = [perm for perm in perms if target in perm]\n    return result", "solution_func": "def g() -> Tuple[str, str]:\n    return (\"abc\", \"ab\")", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> int:\n    \"\"\"\n    Given a binary tree, find the maximum path sum.\n\n    A path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections.\n    The path must contain at least one node and does not need to go through the root.\n\n    Example:\n    Input: root = [1,2,3]\n         1\n        / \\\n       2   3\n    Output: 6\n    \"\"\"\n\n    def maxPathSumHelper(node: TreeNode) -> int:\n        nonlocal maxSum\n\n        if not node:\n            return 0\n\n        leftSum = max(maxPathSumHelper(node.left), 0)\n        rightSum = max(maxPathSumHelper(node.right), 0)\n\n        currentSum = node.val + leftSum + rightSum\n\n        maxSum = max(maxSum, currentSum)\n\n        return node.val + max(leftSum, rightSum)\n\n    maxSum = float('-inf')\n    maxPathSumHelper(root)\n\n    return maxSum\n\ndef g() -> TreeNode:\n    \"\"\"\n    Generate a binary tree with maximum path sum.\n    \"\"\"\n    # Creating the tree:\n    #      1\n    #     / \\\n    #    2   3\n    return TreeNode(1, TreeNode(2), TreeNode(3))\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 332, "target_skills": [0, 0, 1, 0, 0, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> int:\n    \"\"\"\n    Given a binary tree, find the maximum path sum.\n\n    A path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections.\n    The path must contain at least one node and does not need to go through the root.\n\n    Example:\n    Input: root = [1,2,3]\n         1\n        / \\\n       2   3\n    Output: 6\n    \"\"\"\n\n    def maxPathSumHelper(node: TreeNode) -> int:\n        nonlocal maxSum\n\n        if not node:\n            return 0\n\n        leftSum = max(maxPathSumHelper(node.left), 0)\n        rightSum = max(maxPathSumHelper(node.right), 0)\n\n        currentSum = node.val + leftSum + rightSum\n\n        maxSum = max(maxSum, currentSum)\n\n        return node.val + max(leftSum, rightSum)\n\n    maxSum = float('-inf')\n    maxPathSumHelper(root)\n\n    return maxSum", "solution_func": "def g() -> TreeNode:\n    \"\"\"\n    Generate a binary tree with maximum path sum.\n    \"\"\"\n    # Creating the tree:\n    #      1\n    #     / \\\n    #    2   3\n    return TreeNode(1, TreeNode(2), TreeNode(3))", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid consisting of 0s (representing water) and 1s (representing land), count the number of islands.\n\n    An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.\n    Assume all four edges of the grid are all surrounded by water.\n\n    Example:\n    Input:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    Output: 3\n    \"\"\"\n\n    def dfs(row: int, col: int):\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] == 0:\n            return\n\n        grid[row][col] = 0\n\n        dfs(row + 1, col)\n        dfs(row - 1, col)\n        dfs(row, col + 1)\n        dfs(row, col - 1)\n\n    islandCount = 0\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                islandCount += 1\n                dfs(i, j)\n\n    return islandCount\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a 2D grid with islands.\n    \"\"\"\n    # Creating the grid:\n    # 1 1 0 0 0\n    # 1 1 0 0 0\n    # 0 0 1 0 0\n    # 0 0 0 1 1\n    return [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 332, "target_skills": [1, 1, 1, 1, 1, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid consisting of 0s (representing water) and 1s (representing land), count the number of islands.\n\n    An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.\n    Assume all four edges of the grid are all surrounded by water.\n\n    Example:\n    Input:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    Output: 3\n    \"\"\"\n\n    def dfs(row: int, col: int):\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] == 0:\n            return\n\n        grid[row][col] = 0\n\n        dfs(row + 1, col)\n        dfs(row - 1, col)\n        dfs(row, col + 1)\n        dfs(row, col - 1)\n\n    islandCount = 0\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                islandCount += 1\n                dfs(i, j)\n\n    return islandCount", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a 2D grid with islands.\n    \"\"\"\n    # Creating the grid:\n    # 1 1 0 0 0\n    # 1 1 0 0 0\n    # 0 0 1 0 0\n    # 0 0 0 1 1\n    return [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, find the largest square containing only 1s and return its area.\n\n    Example:\n    Input:\n    grid = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n    Output: 4\n    \"\"\"\n\n    if len(grid) == 0 or len(grid[0]) == 0:\n        return 0\n\n    rows = len(grid)\n    cols = len(grid[0])\n    maxSquareSide = 0\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                if i == 0 or j == 0:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n\n                maxSquareSide = max(maxSquareSide, dp[i][j])\n\n    return maxSquareSide * maxSquareSide\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a 2D grid with the largest square of 1s.\n    \"\"\"\n    # Creating the grid:\n    # 1 0 1 0 0\n    # 1 0 1 1 1\n    # 1 1 1 1 1\n    # 1 0 0 1 0\n    return [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n\nassert f(g()) == 4\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 332, "target_skills": [0, 1, 1, 0, 1, 1, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, find the largest square containing only 1s and return its area.\n\n    Example:\n    Input:\n    grid = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n    Output: 4\n    \"\"\"\n\n    if len(grid) == 0 or len(grid[0]) == 0:\n        return 0\n\n    rows = len(grid)\n    cols = len(grid[0])\n    maxSquareSide = 0\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                if i == 0 or j == 0:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n\n                maxSquareSide = max(maxSquareSide, dp[i][j])\n\n    return maxSquareSide * maxSquareSide", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a 2D grid with the largest square of 1s.\n    \"\"\"\n    # Creating the grid:\n    # 1 0 1 0 0\n    # 1 0 1 1 1\n    # 1 1 1 1 1\n    # 1 0 0 1 0\n    return [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n\n    Example:\n    Input:\n    nums = [1, 3, 5, 7, 9, 11, 13]\n    target = 7\n\n    Output:\n    3\n    Explanation:\n    The target value 7 is located at index 3 in the list.\n\n    \"\"\"\n    def binary_search(nums: List[int], target: int, left: int, right: int) -> int:\n        if left > right:\n            return -1\n\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            return binary_search(nums, target, mid + 1, right)\n        else:\n            return binary_search(nums, target, left, mid - 1)\n\n    return binary_search(nums, target, 0, len(nums) - 1)\n\ndef g():\n    nums = [1, 3, 5, 7, 9, 11, 13]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 3\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 332, "target_skills": [1, 1, 1, 0, 1, 1, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n\n    Example:\n    Input:\n    nums = [1, 3, 5, 7, 9, 11, 13]\n    target = 7\n\n    Output:\n    3\n    Explanation:\n    The target value 7 is located at index 3 in the list.\n\n    \"\"\"\n    def binary_search(nums: List[int], target: int, left: int, right: int) -> int:\n        if left > right:\n            return -1\n\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            return binary_search(nums, target, mid + 1, right)\n        else:\n            return binary_search(nums, target, left, mid - 1)\n\n    return binary_search(nums, target, 0, len(nums) - 1)", "solution_func": "def g():\n    nums = [1, 3, 5, 7, 9, 11, 13]\n    target = 7\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two elements in the list.\n\n    Example:\n    Input:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value can be obtained by XORing 5 and 25, which results in 28.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor_val = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor_val)\n\n    return max_xor\n\ndef g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 332, "target_skills": [0, 1, 0, 1, 1, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two elements in the list.\n\n    Example:\n    Input:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value can be obtained by XORing 5 and 25, which results in 28.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor_val = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor_val)\n\n    return max_xor", "solution_func": "def g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency list, determine if there is a path from a given start node to a given end node.\n\n    Example:\n    Input:\n    graph = {1: [2, 3], 2: [4], 3: [5], 4: [5], 5: []}\n    start = 1\n    end = 5\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 1 to node 5 in the given graph.\n    \"\"\"\n\n    def dfs(graph: Dict[int, List[int]], node: int, end: int, visited: Set[int]) -> bool:\n        if node == end:\n            return True\n\n        visited.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(graph, neighbor, end, visited):\n                    return True\n\n        return False\n\n    return dfs(graph, start, end, set())\n\ndef g():\n    graph = {1: [2, 3], 2: [4], 3: [5], 4: [5], 5: []}\n    start = 1\n    end = 5\n    return graph, start, end\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 332, "target_skills": [0, 0, 0, 0, 1, 1, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency list, determine if there is a path from a given start node to a given end node.\n\n    Example:\n    Input:\n    graph = {1: [2, 3], 2: [4], 3: [5], 4: [5], 5: []}\n    start = 1\n    end = 5\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 1 to node 5 in the given graph.\n    \"\"\"\n\n    def dfs(graph: Dict[int, List[int]], node: int, end: int, visited: Set[int]) -> bool:\n        if node == end:\n            return True\n\n        visited.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(graph, neighbor, end, visited):\n                    return True\n\n        return False\n\n    return dfs(graph, start, end, set())", "solution_func": "def g():\n    graph = {1: [2, 3], 2: [4], 3: [5], 4: [5], 5: []}\n    start = 1\n    end = 5\n    return graph, start, end", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct pairs (i, j) where i < j and nums[i] + nums[j] is even.\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] + nums[j]) % 2 == 0:\n                count += 1\n    return count\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g()) == 15\n", "emb": null, "idx_generation": 332, "target_skills": [1, 1, 1, 1, 1, 0, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct pairs (i, j) where i < j and nums[i] + nums[j] is even.\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] + nums[j]) % 2 == 0:\n                count += 1\n    return count", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, convert each lowercase letter to uppercase and vice versa.\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.islower():\n            result += char.upper()\n        elif char.isupper():\n            result += char.lower()\n        else:\n            result += char\n    return result\n\ndef g() -> str:\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"Hello, World!\"\n\nassert f(g()) == \"hELLO, wORLD!\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 332, "target_skills": [0, 0, 0, 1, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, convert each lowercase letter to uppercase and vice versa.\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.islower():\n            result += char.upper()\n        elif char.isupper():\n            result += char.lower()\n        else:\n            result += char\n    return result", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"Hello, World!\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray with length at most k.\n    \"\"\"\n    n = len(nums)\n    max_sum = 0\n    current_sum = 0\n    start = 0\n    k = 3\n\n    for i in range(n):\n        current_sum += nums[i]\n        if i - start + 1 > k:\n            current_sum -= nums[start]\n            start += 1\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == 27\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 332, "target_skills": [1, 1, 1, 1, 0, 1, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray with length at most k.\n    \"\"\"\n    n = len(nums)\n    max_sum = 0\n    current_sum = 0\n    start = 0\n    k = 3\n\n    for i in range(n):\n        current_sum += nums[i]\n        if i - start + 1 > k:\n            current_sum -= nums[start]\n            start += 1\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers 'arr', check if it is a majority sorted array.\n    A majority sorted array is an array where more than half of the elements appear consecutively.\n    \n    Example:\n    arr = [1, 1, 2, 2, 2, 3, 3, 4, 4, 4, 4]\n    \n    Output:\n    True (since the number 4 appears consecutively more than half of the array)\n    \"\"\"\n    n = len(arr)\n    count = 1\n    for i in range(1, n):\n        if arr[i] == arr[i-1]:\n            count += 1\n            if count > n/2:\n                return True\n        else:\n            count = 1\n    return False\n\ndef g() -> List[int]:\n    return [1, 1, 2, 2, 2, 3, 3, 4, 4, 4, 4]\n\nassert f(g()) == True\n", "emb": null, "idx_generation": 332, "target_skills": [1, 0, 1, 0, 0, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers 'arr', check if it is a majority sorted array.\n    A majority sorted array is an array where more than half of the elements appear consecutively.\n    \n    Example:\n    arr = [1, 1, 2, 2, 2, 3, 3, 4, 4, 4, 4]\n    \n    Output:\n    True (since the number 4 appears consecutively more than half of the array)\n    \"\"\"\n    n = len(arr)\n    count = 1\n    for i in range(1, n):\n        if arr[i] == arr[i-1]:\n            count += 1\n            if count > n/2:\n                return True\n        else:\n            count = 1\n    return False", "solution_func": "def g() -> List[int]:\n    return [1, 1, 2, 2, 2, 3, 3, 4, 4, 4, 4]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers and a target value, find two numbers in the array that add up to the target.\n    Return the indices of the two numbers as a list, with the smaller index coming first.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n    \"\"\"\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g(nums: List[int] = [2, 7, 11, 15], target: int = 9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 333, "target_skills": [1, 1, 0, 0, 0, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers and a target value, find two numbers in the array that add up to the target.\n    Return the indices of the two numbers as a list, with the smaller index coming first.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n    \"\"\"\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g(nums: List[int] = [2, 7, 11, 15], target: int = 9):\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of prime numbers less than or equal to n.\n\n    Example:\n    n = 10\n\n    Output:\n    4\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2, n + 1):\n        if is_prime(i):\n            count += 1\n\n    return count\n\ndef g(n: int = 10):\n    return n\n\nassert f(g()) == 4\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 333, "target_skills": [1, 1, 0, 1, 1, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of prime numbers less than or equal to n.\n\n    Example:\n    n = 10\n\n    Output:\n    4\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2, n + 1):\n        if is_prime(i):\n            count += 1\n\n    return count", "solution_func": "def g(n: int = 10):\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of the words.\n\n    Example:\n    s = \"hello world\"\n\n    Output:\n    \"world hello\"\n    \"\"\"\n    words = s.split()\n    return ' '.join(words[::-1])\n\ndef g(s: str = \"hello world\"):\n    return s\n\nassert f(g()) == \"world hello\"\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 333, "target_skills": [1, 1, 0, 1, 1, 0, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of the words.\n\n    Example:\n    s = \"hello world\"\n\n    Output:\n    \"world hello\"\n    \"\"\"\n    words = s.split()\n    return ' '.join(words[::-1])", "solution_func": "def g(s: str = \"hello world\"):\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort them in ascending order.\n\n    Example:\n    nums = [3, 2, 1, 5, 4]\n\n    Output:\n    [1, 2, 3, 4, 5]\n\n    Hint: Use a sorting algorithm, such as bubble sort or merge sort, to rearrange the elements in the list.\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    return nums\n\ndef g() -> List[int]:\n    nums = [3, 2, 1, 5, 4]\n    return nums\n\nassert f(g()) == [1, 2, 3, 4, 5]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 333, "target_skills": [1, 0, 1, 0, 0, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort them in ascending order.\n\n    Example:\n    nums = [3, 2, 1, 5, 4]\n\n    Output:\n    [1, 2, 3, 4, 5]\n\n    Hint: Use a sorting algorithm, such as bubble sort or merge sort, to rearrange the elements in the list.\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    return nums", "solution_func": "def g() -> List[int]:\n    nums = [3, 2, 1, 5, 4]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> str:\n    \"\"\"\n    Given a positive integer n, return its binary representation as a string.\n\n    Example:\n    n = 10\n\n    Output:\n    \"1010\"\n\n    Hint: Use the built-in bin() function to convert the integer to binary format.\n    \"\"\"\n    return bin(n)[2:]\n\ndef g() -> int:\n    n = 10\n    return n\n\nassert f(g()) == \"1010\"\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 333, "target_skills": [0, 0, 0, 1, 1, 1, 0, 1, 1, 0], "problem_func": "from typing import*\ndef f(n: int) -> str:\n    \"\"\"\n    Given a positive integer n, return its binary representation as a string.\n\n    Example:\n    n = 10\n\n    Output:\n    \"1010\"\n\n    Hint: Use the built-in bin() function to convert the integer to binary format.\n    \"\"\"\n    return bin(n)[2:]", "solution_func": "def g() -> int:\n    n = 10\n    return n", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str]) -> str:\n    \"\"\"\n    Given a list of strings, concatenate them into a single string in alphabetical order.\n\n    Example:\n    strings = [\"c\", \"a\", \"b\"]\n\n    Output:\n    \"abc\"\n\n    Hint: Use the sorted() function to sort the strings in alphabetical order before concatenating them.\n    \"\"\"\n    return ''.join(sorted(strings))\n\ndef g() -> List[str]:\n    strings = [\"c\", \"a\", \"b\"]\n    return strings\n\nassert f(g()) == \"abc\"\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 333, "target_skills": [1, 0, 0, 1, 0, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str]) -> str:\n    \"\"\"\n    Given a list of strings, concatenate them into a single string in alphabetical order.\n\n    Example:\n    strings = [\"c\", \"a\", \"b\"]\n\n    Output:\n    \"abc\"\n\n    Hint: Use the sorted() function to sort the strings in alphabetical order before concatenating them.\n    \"\"\"\n    return ''.join(sorted(strings))", "solution_func": "def g() -> List[str]:\n    strings = [\"c\", \"a\", \"b\"]\n    return strings", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation: The numbers at indices 0 and 1 (2 and 7) add up to the target 9.\n\n    Hint: Use a dictionary to store the complement of each number as you iterate through the list.\n    \"\"\"\n    complement_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complement_map:\n            return [complement_map[complement], i]\n        complement_map[num] = i\n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 333, "target_skills": [0, 0, 1, 1, 0, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation: The numbers at indices 0 and 1 (2 and 7) add up to the target 9.\n\n    Hint: Use a dictionary to store the complement of each number as you iterate through the list.\n    \"\"\"\n    complement_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complement_map:\n            return [complement_map[complement], i]\n        complement_map[num] = i\n    return []", "solution_func": "def g(nums=[2, 7, 11, 15], target=9):\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "import math\nfrom typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of trailing zeros in n!.\n\n    Example:\n    Input: n = 5\n    Output: 1\n\n    Explanation: 5! = 120, which has 1 trailing zero.\n\n    Hint: The number of trailing zeros in n! is equal to the number of factors of 5 in n!.\n    \"\"\"\n    count = 0\n    power = 1\n    while n >= math.pow(5, power):\n        count += n // math.pow(5, power)\n        power += 1\n    return count\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 1\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 333, "target_skills": [0, 0, 0, 0, 1, 0, 1, 1, 1, 0], "problem_func": "import math\nfrom typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of trailing zeros in n!.\n\n    Example:\n    Input: n = 5\n    Output: 1\n\n    Explanation: 5! = 120, which has 1 trailing zero.\n\n    Hint: The number of trailing zeros in n! is equal to the number of factors of 5 in n!.\n    \"\"\"\n    count = 0\n    power = 1\n    while n >= math.pow(5, power):\n        count += n // math.pow(5, power)\n        power += 1\n    return count", "solution_func": "def g(n=5):\n    return n", "map_ix": [1, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation: The numbers at indices 0 and 1 (2 and 7) add up to the target 9.\n\n    Hint: Use two pointers, one starting from the beginning and the other starting from the end of the list.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        sum_two = nums[left] + nums[right]\n        if sum_two == target:\n            return [left, right]\n        elif sum_two < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 333, "target_skills": [0, 1, 0, 0, 0, 0, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation: The numbers at indices 0 and 1 (2 and 7) add up to the target 9.\n\n    Hint: Use two pointers, one starting from the beginning and the other starting from the end of the list.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        sum_two = nums[left] + nums[right]\n        if sum_two == target:\n            return [left, right]\n        elif sum_two < target:\n            left += 1\n        else:\n            right -= 1\n    return []", "solution_func": "def g(nums=[2, 7, 11, 15], target=9):\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers, check if there exists a subarray in the array that sums up to zero.\n\n    Return True if there exists a subarray that sums up to zero, False otherwise.\n\n    Example:\n    arr = [4, 2, -3, 1, 6]\n    \n    Output:\n    True\n\n    Explanation:\n    The subarray [2, -3, 1] sums up to zero.\n    \"\"\"\n\n    prefix_sum = set()\n    curr_sum = 0\n\n    for num in arr:\n        curr_sum += num\n\n        if curr_sum in prefix_sum or curr_sum == 0:\n            return True\n\n        prefix_sum.add(curr_sum)\n\n    return False\n\ndef g(arr=[4, 2, -3, 1, 6]):\n    return arr\n\nassert f(g())\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 333, "target_skills": [0, 1, 1, 0, 1, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers, check if there exists a subarray in the array that sums up to zero.\n\n    Return True if there exists a subarray that sums up to zero, False otherwise.\n\n    Example:\n    arr = [4, 2, -3, 1, 6]\n    \n    Output:\n    True\n\n    Explanation:\n    The subarray [2, -3, 1] sums up to zero.\n    \"\"\"\n\n    prefix_sum = set()\n    curr_sum = 0\n\n    for num in arr:\n        curr_sum += num\n\n        if curr_sum in prefix_sum or curr_sum == 0:\n            return True\n\n        prefix_sum.add(curr_sum)\n\n    return False", "solution_func": "def g(arr=[4, 2, -3, 1, 6]):\n    return arr", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(points: List[Tuple[int, int]]) -> bool:\n    \"\"\"\n    Convex Hull\n\n    Given a list of points on a 2D plane, determine if they form a convex hull.\n\n    Example:\n    points = [(0, 0), (1, 1), (1, 0), (2, 2)]\n    output: True\n    \"\"\"\n    def orientation(p1, p2, p3):\n        val = (p2[1] - p1[1]) * (p3[0] - p2[0]) - (p2[0] - p1[0]) * (p3[1] - p2[1])\n        if val == 0:\n            return 0\n        elif val > 0:\n            return 1\n        else:\n            return 2\n\n    n = len(points)\n    if n < 3:\n        return False\n\n    hull = []\n\n    l = 0\n    for i in range(1, n):\n        if points[i][0] < points[l][0]:\n            l = i\n\n    p = l\n    q = 0\n    while True:\n        hull.append(points[p])\n        q = (p + 1) % n\n\n        for i in range(n):\n            if orientation(points[p], points[i], points[q]) == 2:\n                q = i\n\n        p = q\n\n        if p == l:\n            break\n\n    return len(hull) == n\n\ndef g(points = [(0, 0), (1, 1), (1, 0), (2, 2)]):\n    return points\n\nassert f(g()) == True\n\n", "emb": null, "idx_generation": 334, "target_skills": [1, 0, 0, 1, 0, 0, 1, 0, 0, 1], "problem_func": "from typing import*\ndef f(points: List[Tuple[int, int]]) -> bool:\n    \"\"\"\n    Convex Hull\n\n    Given a list of points on a 2D plane, determine if they form a convex hull.\n\n    Example:\n    points = [(0, 0), (1, 1), (1, 0), (2, 2)]\n    output: True\n    \"\"\"\n    def orientation(p1, p2, p3):\n        val = (p2[1] - p1[1]) * (p3[0] - p2[0]) - (p2[0] - p1[0]) * (p3[1] - p2[1])\n        if val == 0:\n            return 0\n        elif val > 0:\n            return 1\n        else:\n            return 2\n\n    n = len(points)\n    if n < 3:\n        return False\n\n    hull = []\n\n    l = 0\n    for i in range(1, n):\n        if points[i][0] < points[l][0]:\n            l = i\n\n    p = l\n    q = 0\n    while True:\n        hull.append(points[p])\n        q = (p + 1) % n\n\n        for i in range(n):\n            if orientation(points[p], points[i], points[q]) == 2:\n                q = i\n\n        p = q\n\n        if p == l:\n            break\n\n    return len(hull) == n", "solution_func": "def g(points = [(0, 0), (1, 1), (1, 0), (2, 2)]):\n    return points", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Subarray Sum Equals K\n\n    Given an array of integers and an integer k, find the total number of continuous subarrays whose sum equals to k.\n\n    Example:\n    nums = [1, 1, 1]\n    target = 2\n    output: 2\n    \"\"\"\n    n = len(nums)\n    count = 0\n    for i in range(n):\n        sum = 0\n        for j in range(i, n):\n            sum += nums[j]\n            if sum == target:\n                count += 1\n    return count\n\ndef g(nums = [1, 1, 1], target = 2):\n    return nums, target\n\nassert f(*g()) == 2\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 334, "target_skills": [0, 1, 1, 1, 0, 1, 1, 1, 0, 1], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Subarray Sum Equals K\n\n    Given an array of integers and an integer k, find the total number of continuous subarrays whose sum equals to k.\n\n    Example:\n    nums = [1, 1, 1]\n    target = 2\n    output: 2\n    \"\"\"\n    n = len(nums)\n    count = 0\n    for i in range(n):\n        sum = 0\n        for j in range(i, n):\n            sum += nums[j]\n            if sum == target:\n                count += 1\n    return count", "solution_func": "def g(nums = [1, 1, 1], target = 2):\n    return nums, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Perfect Number\n\n    A perfect number is a positive integer that is equal to the sum of its proper divisors, excluding the number itself.\n    For example, 28 is a perfect number because its proper divisors are 1, 2, 4, 7, and 14, and 1 + 2 + 4 + 7 + 14 = 28.\n\n    Given an integer n, determine if it is a perfect number.\n\n    Example:\n    n = 28\n    output: True\n    \"\"\"\n    if n <= 0:\n        return False\n\n    divisors = [1]\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n\n    return sum(divisors) == n\n\ndef g(n = 28):\n    return n\n\nassert f(g()) == True\n\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 334, "target_skills": [1, 1, 1, 1, 0, 1, 1, 0, 1, 0], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Perfect Number\n\n    A perfect number is a positive integer that is equal to the sum of its proper divisors, excluding the number itself.\n    For example, 28 is a perfect number because its proper divisors are 1, 2, 4, 7, and 14, and 1 + 2 + 4 + 7 + 14 = 28.\n\n    Given an integer n, determine if it is a perfect number.\n\n    Example:\n    n = 28\n    output: True\n    \"\"\"\n    if n <= 0:\n        return False\n\n    divisors = [1]\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n\n    return sum(divisors) == n", "solution_func": "def g(n = 28):\n    return n", "map_ix": [1, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the number of combinations of elements in the list that add up to the target value.\n\n    Example:\n    Input:\n    nums = [1, 2, 3]\n    target = 4\n\n    Output:\n    4\n\n    Explanation:\n    There are 4 combinations of elements in the list [1, 2, 3] that add up to the target value 4:\n    [1, 1, 1, 1]\n    [1, 1, 2]\n    [1, 3]\n    [2, 2]\n    \"\"\"\n\n    def countCombinations(nums: List[int], target: int, index: int, memo: List[int]) -> int:\n        if target == 0:\n            return 1\n\n        if index >= len(nums) or target < 0:\n            return 0\n\n        if memo[index][target] != -1:\n            return memo[index][target]\n\n        count = countCombinations(nums, target - nums[index], index, memo) + countCombinations(nums, target, index + 1, memo)\n        memo[index][target] = count\n\n        return count\n\n    memo = [[-1] * (target + 1) for _ in range(len(nums))]\n    return countCombinations(nums, target, 0, memo)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return ([1, 2, 3], 4)\n\nassert f(*g()) == 4\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 334, "target_skills": [1, 0, 0, 1, 1, 1, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the number of combinations of elements in the list that add up to the target value.\n\n    Example:\n    Input:\n    nums = [1, 2, 3]\n    target = 4\n\n    Output:\n    4\n\n    Explanation:\n    There are 4 combinations of elements in the list [1, 2, 3] that add up to the target value 4:\n    [1, 1, 1, 1]\n    [1, 1, 2]\n    [1, 3]\n    [2, 2]\n    \"\"\"\n\n    def countCombinations(nums: List[int], target: int, index: int, memo: List[int]) -> int:\n        if target == 0:\n            return 1\n\n        if index >= len(nums) or target < 0:\n            return 0\n\n        if memo[index][target] != -1:\n            return memo[index][target]\n\n        count = countCombinations(nums, target - nums[index], index, memo) + countCombinations(nums, target, index + 1, memo)\n        memo[index][target] = count\n\n        return count\n\n    memo = [[-1] * (target + 1) for _ in range(len(nums))]\n    return countCombinations(nums, target, 0, memo)", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return ([1, 2, 3], 4)", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a valid palindrome after removing at most one character.\n\n    Example:\n    Input:\n    s = \"racecar\"\n\n    Output:\n    True\n\n    Explanation:\n    The string \"racecar\" is a valid palindrome.\n\n    Input:\n    s = \"abca\"\n\n    Output:\n    True\n\n    Explanation:\n    The string \"abca\" is a valid palindrome after removing the character 'b'.\n    \"\"\"\n\n    def isPalindrome(s: str, left: int, right: int, remove: int) -> bool:\n        while left < right:\n            if s[left] != s[right]:\n                if remove == 0:\n                    return False\n                return isPalindrome(s, left + 1, right, remove - 1) or isPalindrome(s, left, right - 1, remove - 1)\n            left += 1\n            right -= 1\n\n        return True\n\n    return isPalindrome(s, 0, len(s) - 1, 1)\n\ndef g() -> str:\n    \"\"\"\n    Generate a valid palindrome string after removing at most one character.\n    \"\"\"\n    return \"abca\"\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 334, "target_skills": [1, 1, 0, 0, 0, 0, 0, 0, 1, 1], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a valid palindrome after removing at most one character.\n\n    Example:\n    Input:\n    s = \"racecar\"\n\n    Output:\n    True\n\n    Explanation:\n    The string \"racecar\" is a valid palindrome.\n\n    Input:\n    s = \"abca\"\n\n    Output:\n    True\n\n    Explanation:\n    The string \"abca\" is a valid palindrome after removing the character 'b'.\n    \"\"\"\n\n    def isPalindrome(s: str, left: int, right: int, remove: int) -> bool:\n        while left < right:\n            if s[left] != s[right]:\n                if remove == 0:\n                    return False\n                return isPalindrome(s, left + 1, right, remove - 1) or isPalindrome(s, left, right - 1, remove - 1)\n            left += 1\n            right -= 1\n\n        return True\n\n    return isPalindrome(s, 0, len(s) - 1, 1)", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate a valid palindrome string after removing at most one character.\n    \"\"\"\n    return \"abca\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[Tuple[int, int]]) -> List[List[int]]:\n    \"\"\"\n    Given the number of nodes and a list of edges between nodes, construct and return an adjacency list representing a tree.\n\n    Example:\n    Input:\n    n = 5\n    edges = [(0, 1), (0, 2), (0, 3), (2, 4)]\n\n    Output:\n    [[1, 2, 3], [0], [0, 4], [0], [2]]\n\n    Explanation:\n    The input represents a tree with 5 nodes and the following edges:\n    0 - 1\n    | \\\n    2  3\n    |\n    4\n\n    The output is the adjacency list representation of the tree.\n    \"\"\"\n\n    def buildTree(n: int, edges: List[Tuple[int, int]]) -> List[List[int]]:\n        adj_list = [[] for _ in range(n)]\n\n        for u, v in edges:\n            adj_list[u].append(v)\n            adj_list[v].append(u)\n\n        return adj_list\n\n    return buildTree(n, edges)\n\ndef g() -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Generate the number of nodes and a list of edges between nodes.\n    \"\"\"\n    return (5, [(0, 1), (0, 2), (0, 3), (2, 4)])\n\nassert f(*g()) == [[1, 2, 3], [0], [0, 4], [0], [2]]\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 334, "target_skills": [0, 1, 1, 1, 0, 1, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[Tuple[int, int]]) -> List[List[int]]:\n    \"\"\"\n    Given the number of nodes and a list of edges between nodes, construct and return an adjacency list representing a tree.\n\n    Example:\n    Input:\n    n = 5\n    edges = [(0, 1), (0, 2), (0, 3), (2, 4)]\n\n    Output:\n    [[1, 2, 3], [0], [0, 4], [0], [2]]\n\n    Explanation:\n    The input represents a tree with 5 nodes and the following edges:\n    0 - 1\n    | \\\n    2  3\n    |\n    4\n\n    The output is the adjacency list representation of the tree.\n    \"\"\"\n\n    def buildTree(n: int, edges: List[Tuple[int, int]]) -> List[List[int]]:\n        adj_list = [[] for _ in range(n)]\n\n        for u, v in edges:\n            adj_list[u].append(v)\n            adj_list[v].append(u)\n\n        return adj_list\n\n    return buildTree(n, edges)", "solution_func": "def g() -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Generate the number of nodes and a list of edges between nodes.\n    \"\"\"\n    return (5, [(0, 1), (0, 2), (0, 3), (2, 4)])", "map_ix": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0's and 1's, find the number of islands. An island is surrounded by water and is formed by connecting \n    adjacent lands horizontally or vertically. Assume grid is a square grid.\n    \n    Example:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1],\n        [0, 0, 0, 1, 1]\n    ]\n    output: 3\n    Explanation: There are 3 islands in the grid.\n    \"\"\"\n\n    def dfs(i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[i]) or grid[i][j] != 1:\n            return\n\n        grid[i][j] = -1\n\n        dfs(i - 1, j)\n        dfs(i + 1, j)\n        dfs(i, j - 1)\n        dfs(i, j + 1)\n\n    num_islands = 0\n\n    for i in range(len(grid)):\n        for j in range(len(grid[i])):\n            if grid[i][j] == 1:\n                dfs(i, j)\n                num_islands += 1\n\n    return num_islands\n\ndef g(grid=[[1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1], [0, 0, 0, 1, 1]]):\n    return grid\n\nassert f(g()) == 3\n", "emb": null, "idx_generation": 334, "target_skills": [1, 1, 1, 1, 0, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0's and 1's, find the number of islands. An island is surrounded by water and is formed by connecting \n    adjacent lands horizontally or vertically. Assume grid is a square grid.\n    \n    Example:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1],\n        [0, 0, 0, 1, 1]\n    ]\n    output: 3\n    Explanation: There are 3 islands in the grid.\n    \"\"\"\n\n    def dfs(i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[i]) or grid[i][j] != 1:\n            return\n\n        grid[i][j] = -1\n\n        dfs(i - 1, j)\n        dfs(i + 1, j)\n        dfs(i, j - 1)\n        dfs(i, j + 1)\n\n    num_islands = 0\n\n    for i in range(len(grid)):\n        for j in range(len(grid[i])):\n            if grid[i][j] == 1:\n                dfs(i, j)\n                num_islands += 1\n\n    return num_islands", "solution_func": "def g(grid=[[1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1], [0, 0, 0, 1, 1]]):\n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique combinations that add up to a target number. Each number in the list\n    can be used multiple times.\n    \n    Example:\n    nums = [1, 2, 3]\n    target = 4\n    output: 7\n    Explanation: There are 7 unique combinations that add up to 4: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2], [1, 3], [3, 1]\n    \"\"\"\n    \n    def backtrack(remaining, combination):\n        if remaining == 0:\n            combinations.append(combination)\n            return\n        elif remaining < 0:\n            return\n        \n        for num in nums:\n            backtrack(remaining - num, combination + [num])\n    \n    combinations = []\n    backtrack(target, [])\n    \n    return len(combinations)\n\ndef g(nums=[1, 2, 3], target=4):\n    return nums\n\nassert f(g()) == 7\n", "emb": null, "idx_generation": 334, "target_skills": [1, 0, 1, 1, 0, 0, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique combinations that add up to a target number. Each number in the list\n    can be used multiple times.\n    \n    Example:\n    nums = [1, 2, 3]\n    target = 4\n    output: 7\n    Explanation: There are 7 unique combinations that add up to 4: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2], [1, 3], [3, 1]\n    \"\"\"\n    \n    def backtrack(remaining, combination):\n        if remaining == 0:\n            combinations.append(combination)\n            return\n        elif remaining < 0:\n            return\n        \n        for num in nums:\n            backtrack(remaining - num, combination + [num])\n    \n    combinations = []\n    backtrack(target, [])\n    \n    return len(combinations)", "solution_func": "def g(nums=[1, 2, 3], target=4):\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner. You can only\n    move down or right at any point in time.\n    \n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    output: 8\n    Explanation: The maximum sum of a path from the top-left corner to the bottom-right corner is 8: 1 -> 3 -> 5 -> 2 -> 1\n    \"\"\"\n    \n    if not grid:\n        return 0\n    \n    n = len(grid)\n    m = len(grid[0])\n    \n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n    for j in range(1, m):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[n-1][m-1]\n\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(g()) == 8\n", "emb": null, "idx_generation": 334, "target_skills": [1, 1, 1, 0, 0, 1, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner. You can only\n    move down or right at any point in time.\n    \n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    output: 8\n    Explanation: The maximum sum of a path from the top-left corner to the bottom-right corner is 8: 1 -> 3 -> 5 -> 2 -> 1\n    \"\"\"\n    \n    if not grid:\n        return 0\n    \n    n = len(grid)\n    m = len(grid[0])\n    \n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n    for j in range(1, m):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[n-1][m-1]", "solution_func": "def g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in the list that sum up to the target.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [2, 7]\n\n    Explanation:\n    The numbers 2 and 7 sum up to the target 9.\n    \"\"\"\n\n    num_set = set()\n    for num in nums:\n        if target - num in num_set:\n            return [target - num, num]\n        num_set.add(num)\n    \n    return []\n\ndef g() -> (List[int], int):\n    \"\"\"\n    Generate a list of integers and a target integer for the function f.\n    \"\"\"\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [2, 7]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 334, "target_skills": [1, 1, 0, 0, 0, 0, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in the list that sum up to the target.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [2, 7]\n\n    Explanation:\n    The numbers 2 and 7 sum up to the target 9.\n    \"\"\"\n\n    num_set = set()\n    for num in nums:\n        if target - num in num_set:\n            return [target - num, num]\n        num_set.add(num)\n    \n    return []", "solution_func": "def g() -> (List[int], int):\n    \"\"\"\n    Generate a list of integers and a target integer for the function f.\n    \"\"\"\n    return [2, 7, 11, 15], 9", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the maximum sum of a path from the top-left cell to the bottom-right cell in the grid.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[rows-1][cols-1]\n\ndef g():\n    \"\"\"Generate a grid with random numbers.\"\"\"\n    import random\n    grid = [[random.randint(1, 100) for _ in range(5)] for _ in range(5)]\n    return grid\n\ngrid = g()\nprint(f(grid))\n\nassert f(g()) == True", "emb": null, "idx_generation": 335, "target_skills": [0, 0, 1, 0, 0, 1, 1, 1, 1, 1], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the maximum sum of a path from the top-left cell to the bottom-right cell in the grid.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[rows-1][cols-1]", "solution_func": "def g():\n    \"\"\"Generate a grid with random numbers.\"\"\"\n    import random\n    grid = [[random.randint(1, 100) for _ in range(5)] for _ in range(5)]\n    return grid\n\ngrid = g()\nprint(f(grid))", "map_ix": null}, {"fitness": -Infinity, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the minimum number of steps required to reach the bottom-right cell from the top-left cell in the grid.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[float('inf')] * cols for _ in range(rows)]\n    dp[0][0] = 0\n    for i in range(rows):\n        for j in range(cols):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j])\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j])\n    return dp[rows-1][cols-1]\n\ndef g():\n    \"\"\"Generate a grid with random numbers.\"\"\"\n    import random\n    grid = [[random.randint(1, 10) for _ in range(5)] for _ in range(5)]\n    return grid\n\ngrid = g()\nprint(f(grid))\n\nassert f(g()) == True", "emb": null, "idx_generation": 335, "target_skills": [0, 1, 1, 0, 0, 0, 0, 0, 0, 0], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the minimum number of steps required to reach the bottom-right cell from the top-left cell in the grid.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[float('inf')] * cols for _ in range(rows)]\n    dp[0][0] = 0\n    for i in range(rows):\n        for j in range(cols):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j])\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j])\n    return dp[rows-1][cols-1]", "solution_func": "def g():\n    \"\"\"Generate a grid with random numbers.\"\"\"\n    import random\n    grid = [[random.randint(1, 10) for _ in range(5)] for _ in range(5)]\n    return grid\n\ngrid = g()\nprint(f(grid))", "map_ix": null}, {"fitness": -Infinity, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum product of any two distinct numbers in the list.\"\"\"\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n    return max_product\n\ndef g():\n    \"\"\"Generate a list of random numbers.\"\"\"\n    import random\n    nums = [random.randint(1, 100) for _ in range(10)]\n    return nums\n\nnums = g()\nprint(f(nums))\n\nassert f(g()) == True", "emb": null, "idx_generation": 335, "target_skills": [1, 1, 1, 1, 0, 1, 1, 0, 0, 0], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum product of any two distinct numbers in the list.\"\"\"\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n    return max_product", "solution_func": "def g():\n    \"\"\"Generate a list of random numbers.\"\"\"\n    import random\n    nums = [random.randint(1, 100) for _ in range(10)]\n    return nums\n\nnums = g()\nprint(f(nums))", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters representing a map, find the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.\n\n    Example:\n    Input:\n    grid = [\n        ['1', '1', '0', '0', '0'],\n        ['1', '1', '0', '0', '0'],\n        ['0', '0', '1', '0', '0'],\n        ['0', '0', '0', '1', '1'],\n    ]\n\n    Output:\n    3\n\n    Explanation:\n    In this example, there are 3 islands, represented by the '1' characters. The first island is formed by the top left '1's, the second island is formed by the bottom right '1's, and the third island is formed by the bottom right '1'.\n    \"\"\"\n\n    def dfs(grid, row, col):\n        if row < 0 or col < 0 or row >= len(grid) or col >= len(grid[0]) or grid[row][col] == '0':\n            return\n        grid[row][col] = '0'\n        dfs(grid, row+1, col)\n        dfs(grid, row-1, col)\n        dfs(grid, row, col+1)\n        dfs(grid, row, col-1)\n\n    n = len(grid)\n    m = len(grid[0])\n    count = 0\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '1':\n                count += 1\n                dfs(grid, i, j)\n\n    return count\n\ndef g():\n    grid = [\n        ['1', '1', '0', '0', '0'],\n        ['1', '1', '0', '0', '0'],\n        ['0', '0', '1', '0', '0'],\n        ['0', '0', '0', '1', '1'],\n    ]\n    return (grid,)\n\nassert f(*g()) == 3\n\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 335, "target_skills": [1, 0, 0, 0, 0, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters representing a map, find the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.\n\n    Example:\n    Input:\n    grid = [\n        ['1', '1', '0', '0', '0'],\n        ['1', '1', '0', '0', '0'],\n        ['0', '0', '1', '0', '0'],\n        ['0', '0', '0', '1', '1'],\n    ]\n\n    Output:\n    3\n\n    Explanation:\n    In this example, there are 3 islands, represented by the '1' characters. The first island is formed by the top left '1's, the second island is formed by the bottom right '1's, and the third island is formed by the bottom right '1'.\n    \"\"\"\n\n    def dfs(grid, row, col):\n        if row < 0 or col < 0 or row >= len(grid) or col >= len(grid[0]) or grid[row][col] == '0':\n            return\n        grid[row][col] = '0'\n        dfs(grid, row+1, col)\n        dfs(grid, row-1, col)\n        dfs(grid, row, col+1)\n        dfs(grid, row, col-1)\n\n    n = len(grid)\n    m = len(grid[0])\n    count = 0\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '1':\n                count += 1\n                dfs(grid, i, j)\n\n    return count", "solution_func": "def g():\n    grid = [\n        ['1', '1', '0', '0', '0'],\n        ['1', '1', '0', '0', '0'],\n        ['0', '0', '1', '0', '0'],\n        ['0', '0', '0', '1', '1'],\n    ]\n    return (grid,)", "map_ix": [1, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, determine if the graph is bipartite.\n\n    Example:\n    Input:\n    graph = [\n        [1, 3],\n        [0, 2],\n        [1, 3],\n        [0, 2],\n    ]\n\n    Output:\n    True\n\n    Explanation:\n    In this example, the graph can be divided into two sets: {0, 2} and {1, 3}, where no two nodes within the same set are connected by an edge.\n    \"\"\"\n\n    def dfs(node, color):\n        if node in color:\n            return color[node]\n        color[node] = 1\n        for neighbor in graph[node]:\n            if dfs(neighbor, color) == color[node]:\n                return False\n        return True\n\n    n = len(graph)\n    color = {}\n\n    for node in range(n):\n        if node not in color:\n            if not dfs(node, color):\n                return False\n\n    return True\n\ndef g():\n    graph = [\n        [1, 3],\n        [0, 2],\n        [1, 3],\n        [0, 2],\n    ]\n    return (graph,)\n\nassert f(*g()) == True\n\n", "emb": null, "idx_generation": 335, "target_skills": [0, 1, 1, 1, 1, 0, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, determine if the graph is bipartite.\n\n    Example:\n    Input:\n    graph = [\n        [1, 3],\n        [0, 2],\n        [1, 3],\n        [0, 2],\n    ]\n\n    Output:\n    True\n\n    Explanation:\n    In this example, the graph can be divided into two sets: {0, 2} and {1, 3}, where no two nodes within the same set are connected by an edge.\n    \"\"\"\n\n    def dfs(node, color):\n        if node in color:\n            return color[node]\n        color[node] = 1\n        for neighbor in graph[node]:\n            if dfs(neighbor, color) == color[node]:\n                return False\n        return True\n\n    n = len(graph)\n    color = {}\n\n    for node in range(n):\n        if node not in color:\n            if not dfs(node, color):\n                return False\n\n    return True", "solution_func": "def g():\n    graph = [\n        [1, 3],\n        [0, 2],\n        [1, 3],\n        [0, 2],\n    ]\n    return (graph,)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency list, determine if there is a path between two nodes.\n\n    Example:\n    Input:\n    graph = [\n        [1, 2],\n        [2, 3],\n        [3, 4],\n        [4],\n        []\n    ]\n    start = 0\n    end = 4\n\n    Output:\n    True\n\n    Explanation:\n    In this example, there is a path from node 0 to node 4: 0 -> 1 -> 2 -> 3 -> 4.\n    \"\"\"\n\n    def dfs(node, visited):\n        if node == end:\n            return True\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited):\n                    return True\n        return False\n\n    n = len(graph)\n    visited = [False] * n\n\n    return dfs(start, visited)\n\ndef g():\n    graph = [\n        [1, 2],\n        [2, 3],\n        [3, 4],\n        [4],\n        []\n    ]\n    start = 0\n    end = 4\n    return (graph, start, end)\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 335, "target_skills": [0, 0, 1, 1, 1, 1, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency list, determine if there is a path between two nodes.\n\n    Example:\n    Input:\n    graph = [\n        [1, 2],\n        [2, 3],\n        [3, 4],\n        [4],\n        []\n    ]\n    start = 0\n    end = 4\n\n    Output:\n    True\n\n    Explanation:\n    In this example, there is a path from node 0 to node 4: 0 -> 1 -> 2 -> 3 -> 4.\n    \"\"\"\n\n    def dfs(node, visited):\n        if node == end:\n            return True\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited):\n                    return True\n        return False\n\n    n = len(graph)\n    visited = [False] * n\n\n    return dfs(start, visited)", "solution_func": "def g():\n    graph = [\n        [1, 2],\n        [2, 3],\n        [3, 4],\n        [4],\n        []\n    ]\n    start = 0\n    end = 4\n    return (graph, start, end)", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target number, determine if there are three integers in nums that sum up to the target.\n    \"\"\"\n    for i in range(len(nums)-2):\n        left = i + 1\n        right = len(nums) - 1\n        while left < right:\n            curr_sum = nums[i] + nums[left] + nums[right]\n            if curr_sum == target:\n                return True\n            elif curr_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 9\n    return nums, target\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 335, "target_skills": [1, 1, 0, 0, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target number, determine if there are three integers in nums that sum up to the target.\n    \"\"\"\n    for i in range(len(nums)-2):\n        left = i + 1\n        right = len(nums) - 1\n        while left < right:\n            curr_sum = nums[i] + nums[left] + nums[right]\n            if curr_sum == target:\n                return True\n            elif curr_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 9\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the sum of all positive integers less than or equal to n that are divisible by 3 or 5.\n    \"\"\"\n    return sum(i for i in range(1, n+1) if i % 3 == 0 or i % 5 == 0)\n\ndef g():\n    n = 20\n    return n\n\nassert f(g()) == 98\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 335, "target_skills": [1, 0, 1, 1, 1, 0, 0, 0, 1, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the sum of all positive integers less than or equal to n that are divisible by 3 or 5.\n    \"\"\"\n    return sum(i for i in range(1, n+1) if i % 3 == 0 or i % 5 == 0)", "solution_func": "def g():\n    n = 20\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return a new list where each element is the product of all the elements in nums except the current element.\n    \"\"\"\n    n = len(nums)\n    result = [1] * n\n    left_product = 1\n    right_product = 1\n    for i in range(n):\n        result[i] *= left_product\n        left_product *= nums[i]\n        result[n-1-i] *= right_product\n        right_product *= nums[n-1-i]\n    return result\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == [120, 60, 40, 30, 24]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 335, "target_skills": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return a new list where each element is the product of all the elements in nums except the current element.\n    \"\"\"\n    n = len(nums)\n    result = [1] * n\n    left_product = 1\n    right_product = 1\n    for i in range(n):\n        result[i] *= left_product\n        left_product *= nums[i]\n        result[n-1-i] *= right_product\n        right_product *= nums[n-1-i]\n    return result", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers, find three numbers in the array that add up to a given target number.\n    \"\"\"\n    for i in range(len(arr)-2):\n        left = i + 1\n        right = len(arr) - 1\n        while left < right:\n            if arr[i] + arr[left] + arr[right] == target:\n                return True\n            elif arr[i] + arr[left] + arr[right] < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g(target: int = 15):\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g(), target=15) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 335, "target_skills": [1, 0, 0, 1, 0, 0, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers, find three numbers in the array that add up to a given target number.\n    \"\"\"\n    for i in range(len(arr)-2):\n        left = i + 1\n        right = len(arr) - 1\n        while left < right:\n            if arr[i] + arr[left] + arr[right] == target:\n                return True\n            elif arr[i] + arr[left] + arr[right] < target:\n                left += 1\n            else:\n                right -= 1\n    return False", "solution_func": "def g(target: int = 15):\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target element.\n    If the target is not found in the list, return -1.\n\n    Example:\n    nums = [2, 4, 6, 8, 10]\n    target = 6\n\n    Output:\n    2\n\n    Explanation:\n    The target element 6 is found at index 2 in the list.\n\n    Hint: Use binary search algorithm to efficiently find the target element.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(nums=[2, 4, 6, 8, 10], target=6):\n    return nums, target\n\nassert f(*g()) == 2\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 336, "target_skills": [1, 0, 0, 0, 1, 0, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target element.\n    If the target is not found in the list, return -1.\n\n    Example:\n    nums = [2, 4, 6, 8, 10]\n    target = 6\n\n    Output:\n    2\n\n    Explanation:\n    The target element 6 is found at index 2 in the list.\n\n    Hint: Use binary search algorithm to efficiently find the target element.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g(nums=[2, 4, 6, 8, 10], target=6):\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a pair of numbers that\n    when combined using bitwise XOR operation, results in the target number.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n\n    Output:\n    True\n\n    Explanation:\n    The pair (2, 4) when combined using XOR operation results in 6.\n\n    Hint: Use a set to store the complement of each number and check if the complement exists in the set.\n    \"\"\"\n\n    complements = set()\n\n    for num in nums:\n        complement = target ^ num\n\n        if complement in complements:\n            return True\n\n        complements.add(num)\n\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5], target=6):\n    return nums, target\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 336, "target_skills": [0, 1, 0, 1, 1, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a pair of numbers that\n    when combined using bitwise XOR operation, results in the target number.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n\n    Output:\n    True\n\n    Explanation:\n    The pair (2, 4) when combined using XOR operation results in 6.\n\n    Hint: Use a set to store the complement of each number and check if the complement exists in the set.\n    \"\"\"\n\n    complements = set()\n\n    for num in nums:\n        complement = target ^ num\n\n        if complement in complements:\n            return True\n\n        complements.add(num)\n\n    return False", "solution_func": "def g(nums=[1, 2, 3, 4, 5], target=6):\n    return nums, target", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in non-decreasing order\n    using the bubble sort algorithm.\n\n    Example:\n    nums = [5, 2, 8, 1, 3]\n\n    Output:\n    [1, 2, 3, 5, 8]\n\n    Explanation:\n    The list is sorted in non-decreasing order.\n\n    Hint: Compare adjacent elements and swap them if they are in the wrong order.\n    \"\"\"\n\n    n = len(nums)\n\n    for i in range(n - 1):\n        for j in range(n - i - 1):\n            if nums[j] > nums[j + 1]:\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n\n    return nums\n\ndef g(nums=[5, 2, 8, 1, 3]):\n    return nums\n\nassert f(g()) == [1, 2, 3, 5, 8]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 336, "target_skills": [0, 1, 1, 0, 0, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in non-decreasing order\n    using the bubble sort algorithm.\n\n    Example:\n    nums = [5, 2, 8, 1, 3]\n\n    Output:\n    [1, 2, 3, 5, 8]\n\n    Explanation:\n    The list is sorted in non-decreasing order.\n\n    Hint: Compare adjacent elements and swap them if they are in the wrong order.\n    \"\"\"\n\n    n = len(nums)\n\n    for i in range(n - 1):\n        for j in range(n - i - 1):\n            if nums[j] > nums[j + 1]:\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n\n    return nums", "solution_func": "def g(nums=[5, 2, 8, 1, 3]):\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the value of n choose k.\n\n    Sample Input:\n    n = 5\n    k = 2\n\n    Sample Output:\n    10\n    \"\"\"\n    if k == 0 or k == n:\n        return 1\n    \n    if k > n:\n        return 0\n    \n    dp = [[0] * (k+1) for _ in range(n+1)]\n    \n    for i in range(n+1):\n        dp[i][0] = 1\n    \n    for i in range(1, n+1):\n        for j in range(1, min(i+1, k+1)):\n            dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n    \n    return dp[n][k]\n\n\ndef g(n=5, k=2):\n    return n, k\n\n\nassert f(*g()) == 10\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 336, "target_skills": [0, 0, 1, 0, 1, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the value of n choose k.\n\n    Sample Input:\n    n = 5\n    k = 2\n\n    Sample Output:\n    10\n    \"\"\"\n    if k == 0 or k == n:\n        return 1\n    \n    if k > n:\n        return 0\n    \n    dp = [[0] * (k+1) for _ in range(n+1)]\n    \n    for i in range(n+1):\n        dp[i][0] = 1\n    \n    for i in range(1, n+1):\n        for j in range(1, min(i+1, k+1)):\n            dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n    \n    return dp[n][k]", "solution_func": "def g(n=5, k=2):\n    return n, k", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum subarray XOR value.\n\n    Sample Input:\n    nums = [5, 25, 10, 2, 8, 30]\n\n    Sample Output:\n    29\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    \n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n        \n        for num in nums:\n            prefix_set.add(num & mask)\n        \n        temp = max_xor | (1 << i)\n        for prefix in prefix_set:\n            if temp ^ prefix in prefix_set:\n                max_xor = temp\n                break\n    \n    return max_xor\n\n\ndef g(nums=[5, 25, 10, 2, 8, 30]):\n    return nums\n\n\nassert f(*g()) == 29\n", "emb": null, "idx_generation": 336, "target_skills": [1, 0, 1, 0, 0, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum subarray XOR value.\n\n    Sample Input:\n    nums = [5, 25, 10, 2, 8, 30]\n\n    Sample Output:\n    29\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    \n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n        \n        for num in nums:\n            prefix_set.add(num & mask)\n        \n        temp = max_xor | (1 << i)\n        for prefix in prefix_set:\n            if temp ^ prefix in prefix_set:\n                max_xor = temp\n                break\n    \n    return max_xor", "solution_func": "def g(nums=[5, 25, 10, 2, 8, 30]):\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of trailing zeros in n!.\n\n    Sample Input:\n    n = 10\n\n    Sample Output:\n    2\n    \"\"\"\n    count = 0\n    i = 5\n    \n    while n // i >= 1:\n        count += n // i\n        i *= 5\n    \n    return count\n\n\ndef g(n=10):\n    return n\n\n\nassert f(*g()) == 2\n", "emb": null, "idx_generation": 336, "target_skills": [0, 1, 1, 0, 1, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of trailing zeros in n!.\n\n    Sample Input:\n    n = 10\n\n    Sample Output:\n    2\n    \"\"\"\n    count = 0\n    i = 5\n    \n    while n // i >= 1:\n        count += n // i\n        i *= 5\n    \n    return count", "solution_func": "def g(n=10):\n    return n", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, k: int) -> int:\n    \"\"\"\n    Given three integers n, m, and k, calculate the number of ways to arrange n objects in m bins such that each bin contains at least k objects.\n\n    Example:\n    n = 5\n    m = 3\n    k = 2\n    Output:\n    10\n\n    Hint: Use combinatorial analysis to calculate the number of ways to distribute the objects among the bins while satisfying the condition.\n    \"\"\"\n\n    def factorial(n: int) -> int:\n        if n == 0 or n == 1:\n            return 1\n        return n * factorial(n - 1)\n\n    if n < m * k:\n        return 0\n\n    numerator = factorial(n)\n    denominator = factorial(k) ** m\n\n    return numerator // denominator\n\ndef g(n: int = 5, m: int = 3, k: int = 2) -> int:\n    return n\n\nassert f(g(), g(), g()) == 10\n", "emb": null, "idx_generation": 336, "target_skills": [0, 1, 1, 1, 0, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, k: int) -> int:\n    \"\"\"\n    Given three integers n, m, and k, calculate the number of ways to arrange n objects in m bins such that each bin contains at least k objects.\n\n    Example:\n    n = 5\n    m = 3\n    k = 2\n    Output:\n    10\n\n    Hint: Use combinatorial analysis to calculate the number of ways to distribute the objects among the bins while satisfying the condition.\n    \"\"\"\n\n    def factorial(n: int) -> int:\n        if n == 0 or n == 1:\n            return 1\n        return n * factorial(n - 1)\n\n    if n < m * k:\n        return 0\n\n    numerator = factorial(n)\n    denominator = factorial(k) ** m\n\n    return numerator // denominator", "solution_func": "def g(n: int = 5, m: int = 3, k: int = 2) -> int:\n    return n", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the length of the longest path such that each element in the path is strictly increasing.\n\n    Example:\n    grid = [[1, 3, 5],\n            [2, 4, 6],\n            [8, 9, 7]]\n    Output:\n    5\n\n    Hint: Use dynamic programming to store the longest path length at each position in the grid.\n    \"\"\"\n\n    def dfs(i: int, j: int, grid: List[List[int]], dp: List[List[int]]) -> int:\n        if dp[i][j] != 0:\n            return dp[i][j]\n\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        longest_path = 1\n\n        for dx, dy in directions:\n            x, y = i + dx, j + dy\n            if x >= 0 and x < len(grid) and y >= 0 and y < len(grid[0]) and grid[x][y] > grid[i][j]:\n                longest_path = max(longest_path, 1 + dfs(x, y, grid, dp))\n\n        dp[i][j] = longest_path\n        return longest_path\n\n    if len(grid) == 0:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    longest_path = 1\n\n    for i in range(m):\n        for j in range(n):\n            longest_path = max(longest_path, dfs(i, j, grid, dp))\n\n    return longest_path\n\ndef g() -> List[List[int]]:\n    return [[1, 3, 5], [2, 4, 6], [8, 9, 7]]\n\nassert f(g()) == 5\n", "emb": null, "idx_generation": 336, "target_skills": [1, 1, 1, 0, 1, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the length of the longest path such that each element in the path is strictly increasing.\n\n    Example:\n    grid = [[1, 3, 5],\n            [2, 4, 6],\n            [8, 9, 7]]\n    Output:\n    5\n\n    Hint: Use dynamic programming to store the longest path length at each position in the grid.\n    \"\"\"\n\n    def dfs(i: int, j: int, grid: List[List[int]], dp: List[List[int]]) -> int:\n        if dp[i][j] != 0:\n            return dp[i][j]\n\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        longest_path = 1\n\n        for dx, dy in directions:\n            x, y = i + dx, j + dy\n            if x >= 0 and x < len(grid) and y >= 0 and y < len(grid[0]) and grid[x][y] > grid[i][j]:\n                longest_path = max(longest_path, 1 + dfs(x, y, grid, dp))\n\n        dp[i][j] = longest_path\n        return longest_path\n\n    if len(grid) == 0:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    longest_path = 1\n\n    for i in range(m):\n        for j in range(n):\n            longest_path = max(longest_path, dfs(i, j, grid, dp))\n\n    return longest_path", "solution_func": "def g() -> List[List[int]]:\n    return [[1, 3, 5], [2, 4, 6], [8, 9, 7]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if the parentheses in the given string are balanced.\n\n    Example:\n    s = \"((())())\"\n    Output:\n    True\n\n    Hint: Use a stack to keep track of the opening parentheses and check if the closing parentheses match the top of the stack.\n    \"\"\"\n\n    stack = []\n\n    for char in s:\n        if char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if len(stack) == 0:\n                return False\n            stack.pop()\n\n    return len(stack) == 0\n\ndef g() -> str:\n    return \"((())())\"\n\nassert f(g())\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 336, "target_skills": [1, 1, 0, 1, 1, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if the parentheses in the given string are balanced.\n\n    Example:\n    s = \"((())())\"\n    Output:\n    True\n\n    Hint: Use a stack to keep track of the opening parentheses and check if the closing parentheses match the top of the stack.\n    \"\"\"\n\n    stack = []\n\n    for char in s:\n        if char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if len(stack) == 0:\n                return False\n            stack.pop()\n\n    return len(stack) == 0", "solution_func": "def g() -> str:\n    return \"((())())\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(graph: List[List[int]], start: int, end: int, k: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix and two nodes start and end,\n    determine if there is a path from start to end that contains exactly k edges.\n    Return True if such a path exists, False otherwise.\n\n    Example:\n    graph = [[0, 1, 1, 0],\n             [0, 0, 0, 1],\n             [0, 1, 0, 0],\n             [0, 0, 0, 0]]\n\n    start = 0\n    end = 3\n    k = 2\n\n    Output:\n    True (since there is a path from 0 to 3 that contains exactly 2 edges: 0 -> 1 -> 3)\n    \"\"\"\n    def dfs(node: int, edges: int) -> bool:\n        if node == end and edges == k:\n            return True\n        if edges > k:\n            return False\n        for neighbor in graph[node]:\n            if neighbor == 1:\n                if dfs(neighbor, edges + 1):\n                    return True\n        return False\n    \n    return dfs(start, 0)\n\ndef g():\n    graph = [[0, 1, 1, 0],\n             [0, 0, 0, 1],\n             [0, 1, 0, 0],\n             [0, 0, 0, 0]]\n    start = 0\n    end = 3\n    k = 2\n    return graph, start, end, k\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 336, "target_skills": [0, 0, 1, 1, 0, 1, 1, 1, 0, 1], "problem_func": "from typing import*\ndef f(graph: List[List[int]], start: int, end: int, k: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix and two nodes start and end,\n    determine if there is a path from start to end that contains exactly k edges.\n    Return True if such a path exists, False otherwise.\n\n    Example:\n    graph = [[0, 1, 1, 0],\n             [0, 0, 0, 1],\n             [0, 1, 0, 0],\n             [0, 0, 0, 0]]\n\n    start = 0\n    end = 3\n    k = 2\n\n    Output:\n    True (since there is a path from 0 to 3 that contains exactly 2 edges: 0 -> 1 -> 3)\n    \"\"\"\n    def dfs(node: int, edges: int) -> bool:\n        if node == end and edges == k:\n            return True\n        if edges > k:\n            return False\n        for neighbor in graph[node]:\n            if neighbor == 1:\n                if dfs(neighbor, edges + 1):\n                    return True\n        return False\n    \n    return dfs(start, 0)", "solution_func": "def g():\n    graph = [[0, 1, 1, 0],\n             [0, 0, 0, 1],\n             [0, 1, 0, 0],\n             [0, 0, 0, 0]]\n    start = 0\n    end = 3\n    k = 2\n    return graph, start, end, k", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find two numbers that add up to the target.\n\n    Return a list of two numbers that add up to the target.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [2, 7]\n\n    Explanation:\n    The two numbers that add up to 9 are 2 and 7.\n    \"\"\"\n    def two_sum(nums, target):\n        left = 0\n        right = len(nums) - 1\n\n        while left < right:\n            current_sum = nums[left] + nums[right]\n            if current_sum == target:\n                return [nums[left], nums[right]]\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n        \n        return []\n\n    nums.sort()\n    return two_sum(nums, target)\n\ndef g(nums=[15, 2, 11, 7], target=9):\n    return nums, target\n\nassert f(*g()) == [2, 7]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 337, "target_skills": [1, 0, 0, 0, 0, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find two numbers that add up to the target.\n\n    Return a list of two numbers that add up to the target.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [2, 7]\n\n    Explanation:\n    The two numbers that add up to 9 are 2 and 7.\n    \"\"\"\n    def two_sum(nums, target):\n        left = 0\n        right = len(nums) - 1\n\n        while left < right:\n            current_sum = nums[left] + nums[right]\n            if current_sum == target:\n                return [nums[left], nums[right]]\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n        \n        return []\n\n    nums.sort()\n    return two_sum(nums, target)", "solution_func": "def g(nums=[15, 2, 11, 7], target=9):\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort them in ascending order using the bubble sort algorithm.\n\n    Return the sorted list.\n\n    Example:\n    nums = [5, 3, 8, 2, 1]\n\n    Output:\n    [1, 2, 3, 5, 8]\n\n    Explanation:\n    The sorted list in ascending order is [1, 2, 3, 5, 8].\n    \"\"\"\n    def bubble_sort(nums):\n        n = len(nums)\n        for i in range(n):\n            for j in range(0, n-i-1):\n                if nums[j] > nums[j+1]:\n                    nums[j], nums[j+1] = nums[j+1], nums[j]\n        \n        return nums\n\n    return bubble_sort(nums)\n\ndef g(nums=[5, 3, 8, 2, 1]):\n    return nums\n\nassert f(g()) == [1, 2, 3, 5, 8]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 337, "target_skills": [0, 0, 0, 1, 1, 1, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort them in ascending order using the bubble sort algorithm.\n\n    Return the sorted list.\n\n    Example:\n    nums = [5, 3, 8, 2, 1]\n\n    Output:\n    [1, 2, 3, 5, 8]\n\n    Explanation:\n    The sorted list in ascending order is [1, 2, 3, 5, 8].\n    \"\"\"\n    def bubble_sort(nums):\n        n = len(nums)\n        for i in range(n):\n            for j in range(0, n-i-1):\n                if nums[j] > nums[j+1]:\n                    nums[j], nums[j+1] = nums[j+1], nums[j]\n        \n        return nums\n\n    return bubble_sort(nums)", "solution_func": "def g(nums=[5, 3, 8, 2, 1]):\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, check if a target number exists in the list using binary search.\n\n    Return True if the target number is found, False otherwise.\n\n    Example:\n    nums = [1, 2, 3, 5, 8]\n    target = 5\n\n    Output:\n    True\n\n    Explanation:\n    The target number 5 exists in the list.\n    \"\"\"\n    def binary_search(nums, target):\n        left = 0\n        right = len(nums) - 1\n\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False\n\n    return binary_search(nums, target)\n\ndef g(nums=[1, 2, 3, 5, 8], target=5):\n    return nums, target\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 337, "target_skills": [1, 1, 0, 0, 1, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, check if a target number exists in the list using binary search.\n\n    Return True if the target number is found, False otherwise.\n\n    Example:\n    nums = [1, 2, 3, 5, 8]\n    target = 5\n\n    Output:\n    True\n\n    Explanation:\n    The target number 5 exists in the list.\n    \"\"\"\n    def binary_search(nums, target):\n        left = 0\n        right = len(nums) - 1\n\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False\n\n    return binary_search(nums, target)", "solution_func": "def g(nums=[1, 2, 3, 5, 8], target=5):\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    60\n\n    Explanation:\n    The maximum product is achieved by multiplying 4 * 5 * 3 = 60.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return (nums,)\n\nassert f(*g()) == 60\n\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 337, "target_skills": [0, 0, 1, 0, 1, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    60\n\n    Explanation:\n    The maximum product is achieved by multiplying 4 * 5 * 3 = 60.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return (nums,)", "map_ix": [1, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if they are isomorphic.\n    Two strings are isomorphic if the characters in s can be replaced to get t.\n\n    Example:\n    s = \"egg\"\n    t = \"add\"\n\n    Output:\n    True\n\n    Explanation:\n    'e' can be replaced with 'a' and 'g' can be replaced with 'd' to get the string 'add'.\n    \"\"\"\n    if len(s) != len(t):\n        return False\n\n    s_to_t = {}\n    t_to_s = {}\n\n    for i in range(len(s)):\n        if s[i] in s_to_t and s_to_t[s[i]] != t[i]:\n            return False\n        if t[i] in t_to_s and t_to_s[t[i]] != s[i]:\n            return False\n        s_to_t[s[i]] = t[i]\n        t_to_s[t[i]] = s[i]\n\n    return True\n\ndef g():\n    s = \"egg\"\n    t = \"add\"\n    return (s, t)\n\nassert f(*g()) == True\n\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 337, "target_skills": [1, 0, 0, 0, 1, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if they are isomorphic.\n    Two strings are isomorphic if the characters in s can be replaced to get t.\n\n    Example:\n    s = \"egg\"\n    t = \"add\"\n\n    Output:\n    True\n\n    Explanation:\n    'e' can be replaced with 'a' and 'g' can be replaced with 'd' to get the string 'add'.\n    \"\"\"\n    if len(s) != len(t):\n        return False\n\n    s_to_t = {}\n    t_to_s = {}\n\n    for i in range(len(s)):\n        if s[i] in s_to_t and s_to_t[s[i]] != t[i]:\n            return False\n        if t[i] in t_to_s and t_to_s[t[i]] != s[i]:\n            return False\n        s_to_t[s[i]] = t[i]\n        t_to_s[t[i]] = s[i]\n\n    return True", "solution_func": "def g():\n    s = \"egg\"\n    t = \"add\"\n    return (s, t)", "map_ix": [1, 0, 1, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subsequence with the constraint that no two numbers in the\n    selected subsequence should be adjacent to each other.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    9\n\n    Explanation:\n    The maximum sum is achieved by selecting the subsequence [2, 4, 5] with a sum of 9.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    if n == 1:\n        return nums[0]\n    if n == 2:\n        return max(nums[0], nums[1])\n\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n\n    return dp[n-1]\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return (nums,)\n\nassert f(*g()) == 9\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 337, "target_skills": [0, 0, 0, 1, 0, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subsequence with the constraint that no two numbers in the\n    selected subsequence should be adjacent to each other.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    9\n\n    Explanation:\n    The maximum sum is achieved by selecting the subsequence [2, 4, 5] with a sum of 9.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    if n == 1:\n        return nums[0]\n    if n == 2:\n        return max(nums[0], nums[1])\n\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n\n    return dp[n-1]", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return (nums,)", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Find the number of inversions in a given list.\n    An inversion occurs when two elements in the list are out of order with respect to their indices.\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] > nums[j]:\n                count += 1\n    return count\n\ndef g():\n    nums = [7, 2, 4, 8, 1, 6, 3, 5]\n    return (nums,)\n\nassert f(*g()) == 20\n", "emb": null, "idx_generation": 337, "target_skills": [1, 1, 0, 1, 1, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Find the number of inversions in a given list.\n    An inversion occurs when two elements in the list are out of order with respect to their indices.\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] > nums[j]:\n                count += 1\n    return count", "solution_func": "def g():\n    nums = [7, 2, 4, 8, 1, 6, 3, 5]\n    return (nums,)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Count the number of set bits (1s) in the binary representation of a given integer.\n    \"\"\"\n    count = 0\n    while n != 0:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g():\n    n = 42\n    return (n,)\n\nassert f(*g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 337, "target_skills": [1, 1, 0, 0, 0, 0, 0, 0, 1, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Count the number of set bits (1s) in the binary representation of a given integer.\n    \"\"\"\n    count = 0\n    while n != 0:\n        count += n & 1\n        n >>= 1\n    return count", "solution_func": "def g():\n    n = 42\n    return (n,)", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Find the length of the longest increasing subsequence in a given list of numbers.\n    \"\"\"\n    def dp(i):\n        if i == 0:\n            return 1\n        max_length = 1\n        for j in range(i):\n            if nums[i] > nums[j]:\n                max_length = max(max_length, dp(j) + 1)\n        return max_length\n    \n    longest_length = 0\n    for i in range(len(nums)):\n        longest_length = max(longest_length, dp(i))\n    return longest_length\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return (nums,)\n\nassert f(*g()) == 4\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 337, "target_skills": [0, 0, 0, 1, 1, 0, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Find the length of the longest increasing subsequence in a given list of numbers.\n    \"\"\"\n    def dp(i):\n        if i == 0:\n            return 1\n        max_length = 1\n        for j in range(i):\n            if nums[i] > nums[j]:\n                max_length = max(max_length, dp(j) + 1)\n        return max_length\n    \n    longest_length = 0\n    for i in range(len(nums)):\n        longest_length = max(longest_length, dp(i))\n    return longest_length", "solution_func": "def g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return (nums,)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> bool:\n    \"\"\"\n    Given the root of a binary tree, determine if it is a valid binary search tree (BST).\n\n    A valid BST is defined as follows:\n        - The left subtree of a node contains only nodes with keys less than the node's key.\n        - The right subtree of a node contains only nodes with keys greater than the node's key.\n        - Both the left and right subtrees must also be binary search trees.\n\n    Return True if the given binary tree is a valid BST, otherwise return False.\n\n    Example:\n    Input:\n        2\n       / \\\n      1   3\n    Output:\n        True\n\n    Hint: Perform a depth-first search (DFS) and check the validity of each node's value.\n    \"\"\"\n\n    def validate_bst(node: TreeNode, min_val=float('-inf'), max_val=float('inf')) -> bool:\n        if not node:\n            return True\n        if node.val <= min_val or node.val >= max_val:\n            return False\n        return validate_bst(node.left, min_val, node.val) and validate_bst(node.right, node.val, max_val)\n\n    return validate_bst(root)\n\n\ndef g() -> TreeNode:\n    root = TreeNode(2)\n    root.left = TreeNode(1)\n    root.right = TreeNode(3)\n    return root\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 337, "target_skills": [1, 1, 1, 1, 0, 1, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> bool:\n    \"\"\"\n    Given the root of a binary tree, determine if it is a valid binary search tree (BST).\n\n    A valid BST is defined as follows:\n        - The left subtree of a node contains only nodes with keys less than the node's key.\n        - The right subtree of a node contains only nodes with keys greater than the node's key.\n        - Both the left and right subtrees must also be binary search trees.\n\n    Return True if the given binary tree is a valid BST, otherwise return False.\n\n    Example:\n    Input:\n        2\n       / \\\n      1   3\n    Output:\n        True\n\n    Hint: Perform a depth-first search (DFS) and check the validity of each node's value.\n    \"\"\"\n\n    def validate_bst(node: TreeNode, min_val=float('-inf'), max_val=float('inf')) -> bool:\n        if not node:\n            return True\n        if node.val <= min_val or node.val >= max_val:\n            return False\n        return validate_bst(node.left, min_val, node.val) and validate_bst(node.right, node.val, max_val)\n\n    return validate_bst(root)", "solution_func": "def g() -> TreeNode:\n    root = TreeNode(2)\n    root.left = TreeNode(1)\n    root.right = TreeNode(3)\n    return root", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nimport collections\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency list, check if it contains a cycle.\n\n    Example:\n    graph = [[1, 2], [2, 3], [3], []]\n\n    Output:\n    False\n\n    Explanation:\n    The graph does not contain any cycles.\n    \"\"\"\n    def dfs(node, visited, parent):\n        visited[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, node):\n                    return True\n            elif neighbor != parent:\n                return True\n        \n        return False\n    \n    visited = [False] * len(graph)\n    \n    for node in range(len(graph)):\n        if not visited[node]:\n            if dfs(node, visited, -1):\n                return True\n    \n    return False\n\ndef g(graph: List[List[int]] = [[1, 2], [2, 3], [3], []]):\n    return (graph,)\n\nassert f(*g()) == False\n", "emb": null, "idx_generation": 338, "target_skills": [0, 0, 1, 1, 1, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nimport collections\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency list, check if it contains a cycle.\n\n    Example:\n    graph = [[1, 2], [2, 3], [3], []]\n\n    Output:\n    False\n\n    Explanation:\n    The graph does not contain any cycles.\n    \"\"\"\n    def dfs(node, visited, parent):\n        visited[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, node):\n                    return True\n            elif neighbor != parent:\n                return True\n        \n        return False\n    \n    visited = [False] * len(graph)\n    \n    for node in range(len(graph)):\n        if not visited[node]:\n            if dfs(node, visited, -1):\n                return True\n    \n    return False", "solution_func": "def g(graph: List[List[int]] = [[1, 2], [2, 3], [3], []]):\n    return (graph,)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nimport math\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of the first n natural numbers.\n\n    Example:\n    n = 5\n\n    Output:\n    15\n\n    Explanation:\n    The sum of the first 5 natural numbers is 1 + 2 + 3 + 4 + 5 = 15.\n    \"\"\"\n    return n * (n + 1) // 2\n\ndef g(n: int = 5):\n    return (n,)\n\nassert f(*g()) == 15\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 338, "target_skills": [0, 1, 0, 0, 1, 0, 0, 1, 1, 0], "problem_func": "from typing import*\nimport math\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of the first n natural numbers.\n\n    Example:\n    n = 5\n\n    Output:\n    15\n\n    Explanation:\n    The sum of the first 5 natural numbers is 1 + 2 + 3 + 4 + 5 = 15.\n    \"\"\"\n    return n * (n + 1) // 2", "solution_func": "def g(n: int = 5):\n    return (n,)", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Given a grid of characters, flip the characters within each cell horizontally.\n\n    Example:\n    grid = [[\"A\", \"B\", \"C\"], [\"D\", \"E\", \"F\"], [\"G\", \"H\", \"I\"]]\n\n    Output:\n    [[\"C\", \"B\", \"A\"], [\"F\", \"E\", \"D\"], [\"I\", \"H\", \"G\"]]\n\n    Explanation:\n    The characters in each cell are flipped horizontally.\n    \"\"\"\n    for row in grid:\n        row.reverse()\n    \n    return grid\n\ndef g(grid: List[List[str]] = [[\"A\", \"B\", \"C\"], [\"D\", \"E\", \"F\"], [\"G\", \"H\", \"I\"]]):\n    return (grid,)\n\nassert f(*g()) == [[\"C\", \"B\", \"A\"], [\"F\", \"E\", \"D\"], [\"I\", \"H\", \"G\"]]\n", "emb": null, "idx_generation": 338, "target_skills": [0, 1, 1, 0, 0, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Given a grid of characters, flip the characters within each cell horizontally.\n\n    Example:\n    grid = [[\"A\", \"B\", \"C\"], [\"D\", \"E\", \"F\"], [\"G\", \"H\", \"I\"]]\n\n    Output:\n    [[\"C\", \"B\", \"A\"], [\"F\", \"E\", \"D\"], [\"I\", \"H\", \"G\"]]\n\n    Explanation:\n    The characters in each cell are flipped horizontally.\n    \"\"\"\n    for row in grid:\n        row.reverse()\n    \n    return grid", "solution_func": "def g(grid: List[List[str]] = [[\"A\", \"B\", \"C\"], [\"D\", \"E\", \"F\"], [\"G\", \"H\", \"I\"]]):\n    return (grid,)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers 'nums' and a target integer 'target', \n    find the number of unique combinations that add up to the target.\n    Each number in 'nums' can be used multiple times.\n\n    Example:\n    nums = [1, 2, 3]\n    target = 4\n\n    Output:\n    7\n    \"\"\"\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i >= num:\n                dp[i] += dp[i - num]\n\n    return dp[target]\n\ndef g():\n    nums = [1, 2, 3]\n    target = 4\n    return nums, target\n\nassert f(*g()) == 7\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 338, "target_skills": [0, 0, 1, 0, 0, 1, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers 'nums' and a target integer 'target', \n    find the number of unique combinations that add up to the target.\n    Each number in 'nums' can be used multiple times.\n\n    Example:\n    nums = [1, 2, 3]\n    target = 4\n\n    Output:\n    7\n    \"\"\"\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i >= num:\n                dp[i] += dp[i - num]\n\n    return dp[target]", "solution_func": "def g():\n    nums = [1, 2, 3]\n    target = 4\n    return nums, target", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum XOR value of any two elements in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n    \"\"\"\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = set()\n\n        for num in nums:\n            prefixes.add(num & mask)\n\n        possible_xor = max_xor | (1 << i)\n\n        for prefix in prefixes:\n            if possible_xor ^ prefix in prefixes:\n                max_xor = possible_xor\n                break\n\n    return max_xor\n\ndef g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(*g()) == 28\n", "emb": null, "idx_generation": 338, "target_skills": [0, 0, 1, 0, 0, 1, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum XOR value of any two elements in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n    \"\"\"\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = set()\n\n        for num in nums:\n            prefixes.add(num & mask)\n\n        possible_xor = max_xor | (1 << i)\n\n        for prefix in prefixes:\n            if possible_xor ^ prefix in prefixes:\n                max_xor = possible_xor\n                break\n\n    return max_xor", "solution_func": "def g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[str]:\n    \"\"\"\n    Given an integer 'n', generate all valid parentheses combinations with 'n' pairs of parentheses.\n\n    Example:\n    n = 3\n\n    Output:\n    [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\n    \"\"\"\n    def backtrack(open_count: int, close_count: int, path: str):\n        if open_count == n and close_count == n:\n            result.append(path)\n            return\n        \n        if open_count < n:\n            backtrack(open_count + 1, close_count, path + \"(\")\n        \n        if open_count > close_count:\n            backtrack(open_count, close_count + 1, path + \")\")\n    \n    result = []\n    backtrack(0, 0, \"\")\n    return result\n\ndef g():\n    n = 3\n    return n\n\nassert f(*g()) == [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\n", "emb": null, "idx_generation": 338, "target_skills": [1, 0, 0, 0, 0, 0, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[str]:\n    \"\"\"\n    Given an integer 'n', generate all valid parentheses combinations with 'n' pairs of parentheses.\n\n    Example:\n    n = 3\n\n    Output:\n    [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\n    \"\"\"\n    def backtrack(open_count: int, close_count: int, path: str):\n        if open_count == n and close_count == n:\n            result.append(path)\n            return\n        \n        if open_count < n:\n            backtrack(open_count + 1, close_count, path + \"(\")\n        \n        if open_count > close_count:\n            backtrack(open_count, close_count + 1, path + \")\")\n    \n    result = []\n    backtrack(0, 0, \"\")\n    return result", "solution_func": "def g():\n    n = 3\n    return n", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the number of unique paths from the top-left corner to the bottom-right corner, \n    while only moving down or right.\n\n    Example:\n    Input:\n    grid = [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]\n\n    Output:\n    2\n\n    Explanation:\n    The grid represents a 3x3 matrix. The number 0 represents an empty cell, while the number 1 represents an obstacle.\n    There are 2 unique paths from the top-left corner to the bottom-right corner: [0, 0, 0, 0, 0] and [0, 0, 0, 0, 0].\n    \"\"\"\n\n    def countPaths(grid: List[List[int]], row: int, col: int, memo: List[List[int]]) -> int:\n        if row == len(grid) - 1 and col == len(grid[0]) - 1:\n            return 1\n\n        if row >= len(grid) or col >= len(grid[0]) or grid[row][col] == 1:\n            return 0\n\n        if memo[row][col] != -1:\n            return memo[row][col]\n\n        right = countPaths(grid, row, col + 1, memo)\n        down = countPaths(grid, row + 1, col, memo)\n\n        memo[row][col] = right + down\n\n        return memo[row][col]\n\n    memo = [[-1] * len(grid[0]) for _ in range(len(grid))]\n    return countPaths(grid, 0, 0, memo)\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of 0s and 1s.\n    \"\"\"\n    return [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]\n\nassert f(g()) == 2\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 338, "target_skills": [0, 0, 0, 1, 0, 1, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the number of unique paths from the top-left corner to the bottom-right corner, \n    while only moving down or right.\n\n    Example:\n    Input:\n    grid = [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]\n\n    Output:\n    2\n\n    Explanation:\n    The grid represents a 3x3 matrix. The number 0 represents an empty cell, while the number 1 represents an obstacle.\n    There are 2 unique paths from the top-left corner to the bottom-right corner: [0, 0, 0, 0, 0] and [0, 0, 0, 0, 0].\n    \"\"\"\n\n    def countPaths(grid: List[List[int]], row: int, col: int, memo: List[List[int]]) -> int:\n        if row == len(grid) - 1 and col == len(grid[0]) - 1:\n            return 1\n\n        if row >= len(grid) or col >= len(grid[0]) or grid[row][col] == 1:\n            return 0\n\n        if memo[row][col] != -1:\n            return memo[row][col]\n\n        right = countPaths(grid, row, col + 1, memo)\n        down = countPaths(grid, row + 1, col, memo)\n\n        memo[row][col] = right + down\n\n        return memo[row][col]\n\n    memo = [[-1] * len(grid[0]) for _ in range(len(grid))]\n    return countPaths(grid, 0, 0, memo)", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of 0s and 1s.\n    \"\"\"\n    return [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value k, find two distinct numbers in the list that add up to k.\n\n    Example:\n    Input:\n    nums = [2, 4, 6, 8, 10]\n    k = 14\n\n    Output:\n    [4, 10]\n\n    Explanation:\n    The numbers 4 and 10 add up to 14.\n    \"\"\"\n\n    def findPairs(nums: List[int], k: int, index: int, path: List[int], result: List[List[int]]) -> None:\n        if k == 0 and len(path) == 2:\n            result.append(path)\n            return\n\n        if index >= len(nums) or k < 0 or len(path) >= 2:\n            return\n\n        findPairs(nums, k - nums[index], index + 1, path + [nums[index]], result)\n        findPairs(nums, k, index + 1, path, result)\n\n    result = []\n    findPairs(nums, k, 0, [], result)\n    return result[0]\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return [2, 4, 6, 8, 10], 14\n\nassert f(*g()) == [4, 10]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 338, "target_skills": [1, 1, 1, 0, 1, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value k, find two distinct numbers in the list that add up to k.\n\n    Example:\n    Input:\n    nums = [2, 4, 6, 8, 10]\n    k = 14\n\n    Output:\n    [4, 10]\n\n    Explanation:\n    The numbers 4 and 10 add up to 14.\n    \"\"\"\n\n    def findPairs(nums: List[int], k: int, index: int, path: List[int], result: List[List[int]]) -> None:\n        if k == 0 and len(path) == 2:\n            result.append(path)\n            return\n\n        if index >= len(nums) or k < 0 or len(path) >= 2:\n            return\n\n        findPairs(nums, k - nums[index], index + 1, path + [nums[index]], result)\n        findPairs(nums, k, index + 1, path, result)\n\n    result = []\n    findPairs(nums, k, 0, [], result)\n    return result[0]", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return [2, 4, 6, 8, 10], 14", "map_ix": [1, 0, 0, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of words in the string.\n\n    Example:\n    Input:\n    s = \"hello world\"\n\n    Output:\n    \"world hello\"\n    \"\"\"\n\n    def reverseWords(s: str) -> str:\n        words = s.split()\n        return \" \".join(words[::-1])\n\n    return reverseWords(s)\n\ndef g() -> str:\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"hello world\"\n\nassert f(g()) == \"world hello\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 338, "target_skills": [1, 0, 1, 0, 0, 0, 0, 1, 0, 1], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of words in the string.\n\n    Example:\n    Input:\n    s = \"hello world\"\n\n    Output:\n    \"world hello\"\n    \"\"\"\n\n    def reverseWords(s: str) -> str:\n        words = s.split()\n        return \" \".join(words[::-1])\n\n    return reverseWords(s)", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"hello world\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given a number of nodes and a list of edges, determine if there is a cycle in the graph.\n    \"\"\"\n    def has_cycle(node, visited, parent, adj_list):\n        visited[node] = True\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                if has_cycle(neighbor, visited, node, adj_list):\n                    return True\n            elif parent != neighbor:\n                return True\n        return False\n\n    adj_list = [[] for _ in range(n)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    visited = [False] * n\n    for i in range(n):\n        if not visited[i]:\n            if has_cycle(i, visited, -1, adj_list):\n                return True\n    return False\n\ndef g() -> (int, List[List[int]]):\n    \"\"\"\n    Generate a graph with 4 nodes and 4 edges, with a cycle.\n    \"\"\"\n    return 4, [[0, 1], [1, 2], [2, 3], [3, 0]]\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 338, "target_skills": [0, 1, 0, 0, 1, 0, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given a number of nodes and a list of edges, determine if there is a cycle in the graph.\n    \"\"\"\n    def has_cycle(node, visited, parent, adj_list):\n        visited[node] = True\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                if has_cycle(neighbor, visited, node, adj_list):\n                    return True\n            elif parent != neighbor:\n                return True\n        return False\n\n    adj_list = [[] for _ in range(n)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    visited = [False] * n\n    for i in range(n):\n        if not visited[i]:\n            if has_cycle(i, visited, -1, adj_list):\n                return True\n    return False", "solution_func": "def g() -> (int, List[List[int]]):\n    \"\"\"\n    Generate a graph with 4 nodes and 4 edges, with a cycle.\n    \"\"\"\n    return 4, [[0, 1], [1, 2], [2, 3], [3, 0]]", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of inversions in the list.\n\n    Return the number of inversions.\n\n    Example:\n    nums = [1, 3, 2, 4, 5]\n\n    Output:\n    1\n\n    Explanation:\n    The only inversion in the list is (3, 2).\n    \"\"\"\n    def merge_sort(nums, count):\n        if len(nums) <= 1:\n            return nums, count\n        \n        mid = len(nums) // 2\n        left, count = merge_sort(nums[:mid], count)\n        right, count = merge_sort(nums[mid:], count)\n        \n        merged, count = merge(left, right, count)\n        \n        return merged, count\n    \n    def merge(left, right, count):\n        merged = []\n        i = j = 0\n        \n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                count += len(left) - i\n                j += 1\n        \n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        \n        return merged, count\n    \n    _, count = merge_sort(nums, 0)\n    return count\n\ndef g(nums=[1, 3, 2, 4, 5]):\n    return nums\n\nassert f(g()) == 1\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 339, "target_skills": [1, 1, 1, 0, 0, 1, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of inversions in the list.\n\n    Return the number of inversions.\n\n    Example:\n    nums = [1, 3, 2, 4, 5]\n\n    Output:\n    1\n\n    Explanation:\n    The only inversion in the list is (3, 2).\n    \"\"\"\n    def merge_sort(nums, count):\n        if len(nums) <= 1:\n            return nums, count\n        \n        mid = len(nums) // 2\n        left, count = merge_sort(nums[:mid], count)\n        right, count = merge_sort(nums[mid:], count)\n        \n        merged, count = merge(left, right, count)\n        \n        return merged, count\n    \n    def merge(left, right, count):\n        merged = []\n        i = j = 0\n        \n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                count += len(left) - i\n                j += 1\n        \n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        \n        return merged, count\n    \n    _, count = merge_sort(nums, 0)\n    return count", "solution_func": "def g(nums=[1, 3, 2, 4, 5]):\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], target: str) -> bool:\n    \"\"\"\n    Given a list of words and a target word,\n    determine if it is possible to form the target word by concatenating the words in the list.\n\n    Return True if it is possible, False otherwise.\n\n    Example:\n    words = [\"apple\", \"pen\", \"applepen\", \"pine\", \"pineapple\"]\n    target = \"pineapplepenapple\"\n\n    Output:\n    True\n\n    Explanation:\n    The target word can be formed by concatenating \"pineapple\", \"pen\", and \"apple\".\n    \"\"\"\n    def can_concatenate(words, target):\n        if not words:\n            return False\n        \n        if not target:\n            return True\n        \n        for word in words:\n            if target.startswith(word):\n                if can_concatenate(words, target[len(word):]):\n                    return True\n        \n        return False\n\n    return can_concatenate(words, target)\n\ndef g(words=[\"apple\", \"pen\", \"applepen\", \"pine\", \"pineapple\"], target=\"pineapplepenapple\"):\n    return words, target\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 339, "target_skills": [0, 1, 0, 0, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], target: str) -> bool:\n    \"\"\"\n    Given a list of words and a target word,\n    determine if it is possible to form the target word by concatenating the words in the list.\n\n    Return True if it is possible, False otherwise.\n\n    Example:\n    words = [\"apple\", \"pen\", \"applepen\", \"pine\", \"pineapple\"]\n    target = \"pineapplepenapple\"\n\n    Output:\n    True\n\n    Explanation:\n    The target word can be formed by concatenating \"pineapple\", \"pen\", and \"apple\".\n    \"\"\"\n    def can_concatenate(words, target):\n        if not words:\n            return False\n        \n        if not target:\n            return True\n        \n        for word in words:\n            if target.startswith(word):\n                if can_concatenate(words, target[len(word):]):\n                    return True\n        \n        return False\n\n    return can_concatenate(words, target)", "solution_func": "def g(words=[\"apple\", \"pen\", \"applepen\", \"pine\", \"pineapple\"], target=\"pineapplepenapple\"):\n    return words, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums1: List[int], nums2: List[int]) -> float:\n    \"\"\"\n    Given two sorted lists of integers, nums1 and nums2, \n    find the median element of the merged list.\n\n    Return the median element.\n\n    Example:\n    nums1 = [1, 3]\n    nums2 = [2]\n\n    Output:\n    2.0\n\n    Explanation:\n    The merged list is [1, 2, 3] and the median element is 2.0.\n    \"\"\"\n    def find_median(nums1, nums2):\n        merged = merge(nums1, nums2)\n        n = len(merged)\n        mid = n // 2\n        \n        if n % 2 == 0:\n            return (merged[mid - 1] + merged[mid]) / 2\n        else:\n            return merged[mid]\n\n    def merge(nums1, nums2):\n        merged = []\n        i = j = 0\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] <= nums2[j]:\n                merged.append(nums1[i])\n                i += 1\n            else:\n                merged.append(nums2[j])\n                j += 1\n        \n        merged.extend(nums1[i:])\n        merged.extend(nums2[j:])\n        \n        return merged\n\n    return find_median(nums1, nums2)\n\ndef g(nums1=[1, 3], nums2=[2]):\n    return nums1, nums2\n\nassert f(*g()) == 2.0\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 339, "target_skills": [1, 1, 1, 0, 1, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums1: List[int], nums2: List[int]) -> float:\n    \"\"\"\n    Given two sorted lists of integers, nums1 and nums2, \n    find the median element of the merged list.\n\n    Return the median element.\n\n    Example:\n    nums1 = [1, 3]\n    nums2 = [2]\n\n    Output:\n    2.0\n\n    Explanation:\n    The merged list is [1, 2, 3] and the median element is 2.0.\n    \"\"\"\n    def find_median(nums1, nums2):\n        merged = merge(nums1, nums2)\n        n = len(merged)\n        mid = n // 2\n        \n        if n % 2 == 0:\n            return (merged[mid - 1] + merged[mid]) / 2\n        else:\n            return merged[mid]\n\n    def merge(nums1, nums2):\n        merged = []\n        i = j = 0\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] <= nums2[j]:\n                merged.append(nums1[i])\n                i += 1\n            else:\n                merged.append(nums2[j])\n                j += 1\n        \n        merged.extend(nums1[i:])\n        merged.extend(nums2[j:])\n        \n        return merged\n\n    return find_median(nums1, nums2)", "solution_func": "def g(nums1=[1, 3], nums2=[2]):\n    return nums1, nums2", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, compute the number of unique ways to climb to the top\n    of a staircase with n steps. You can climb either 1 or 2 steps at a time.\n\n    Example:\n    n = 4\n\n    Output:\n    5\n\n    Explanation:\n    There are 5 unique ways to climb to the top of a staircase with 4 steps:\n    1. 1 step + 1 step + 1 step + 1 step\n    2. 1 step + 2 steps + 1 step\n    3. 2 steps + 1 step + 1 step\n    4. 1 step + 1 step + 2 steps\n    5. 2 steps + 2 steps\n    \"\"\"\n    if n <= 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\ndef g():\n    return 4\n\nassert f(g()) == 5\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 339, "target_skills": [0, 0, 0, 1, 0, 1, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, compute the number of unique ways to climb to the top\n    of a staircase with n steps. You can climb either 1 or 2 steps at a time.\n\n    Example:\n    n = 4\n\n    Output:\n    5\n\n    Explanation:\n    There are 5 unique ways to climb to the top of a staircase with 4 steps:\n    1. 1 step + 1 step + 1 step + 1 step\n    2. 1 step + 2 steps + 1 step\n    3. 2 steps + 1 step + 1 step\n    4. 1 step + 1 step + 2 steps\n    5. 2 steps + 2 steps\n    \"\"\"\n    if n <= 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]", "solution_func": "def g():\n    return 4", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, count the number of set bits (1s) in its binary representation.\n\n    Example:\n    n = 10\n\n    Output:\n    2\n\n    Explanation:\n    The binary representation of 10 is 1010, which contains 2 set bits.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g():\n    return 10\n\nassert f(g()) == 2\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 339, "target_skills": [0, 0, 0, 0, 1, 1, 1, 1, 0, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, count the number of set bits (1s) in its binary representation.\n\n    Example:\n    n = 10\n\n    Output:\n    2\n\n    Explanation:\n    The binary representation of 10 is 1010, which contains 2 set bits.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count", "solution_func": "def g():\n    return 10", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"\n    Given a string s and a target string, check if target is a substring of s.\n\n    Example:\n    s = \"hello world\"\n    target = \"world\"\n\n    Output:\n    True\n\n    Explanation:\n    The target string \"world\" is a substring of the string \"hello world\".\n    \"\"\"\n    return target in s\n\ndef g(s: str, target: str) -> str:\n    \"\"\"\n    Concatenate the given string with itself.\n    \"\"\"\n    return s + s\n\nassert f(g(\"hello world\", \"world\"), \"world\")\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 339, "target_skills": [1, 1, 1, 0, 1, 0, 1, 0, 1, 1], "problem_func": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"\n    Given a string s and a target string, check if target is a substring of s.\n\n    Example:\n    s = \"hello world\"\n    target = \"world\"\n\n    Output:\n    True\n\n    Explanation:\n    The target string \"world\" is a substring of the string \"hello world\".\n    \"\"\"\n    return target in s", "solution_func": "def g(s: str, target: str) -> str:\n    \"\"\"\n    Concatenate the given string with itself.\n    \"\"\"\n    return s + s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a pair of numbers in the list such that their sum is even and their product is odd.\n\n    Example:\n    Input:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    True\n    Explanation:\n    The pair (1, 4) has a sum of 5, which is odd, and a product of 4, which is even.\n\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    \n    for num in nums:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    return even_count > 0 and odd_count > 0\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 339, "target_skills": [1, 1, 1, 1, 1, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a pair of numbers in the list such that their sum is even and their product is odd.\n\n    Example:\n    Input:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    True\n    Explanation:\n    The pair (1, 4) has a sum of 5, which is odd, and a product of 4, which is even.\n\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    \n    for num in nums:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    return even_count > 0 and odd_count > 0", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3, 4, 5]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(s: str) -> List[str]:\n    \"\"\"\n    Given a string s, return a list of all possible substrings of s that are palindromes.\n\n    Example:\n    Input:\n    s = \"ababa\"\n\n    Output:\n    [\"a\", \"aba\", \"ababa\", \"b\", \"bab\"]\n\n    Explanation:\n    The substrings \"a\", \"aba\", \"ababa\", \"b\", and \"bab\" are all palindromes.\n\n    \"\"\"\n    def is_palindrome(substring: str) -> bool:\n        return substring == substring[::-1]\n    \n    n = len(s)\n    substrings = []\n    \n    for i in range(n):\n        for j in range(i+1, n+1):\n            substring = s[i:j]\n            if is_palindrome(substring):\n                substrings.append(substring)\n    \n    return substrings\n\ndef g() -> str:\n    return \"ababa\"\n\nassert f(g()) == [\"a\", \"aba\", \"ababa\", \"b\", \"bab\"]\n\n", "emb": null, "idx_generation": 339, "target_skills": [1, 1, 0, 1, 0, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(s: str) -> List[str]:\n    \"\"\"\n    Given a string s, return a list of all possible substrings of s that are palindromes.\n\n    Example:\n    Input:\n    s = \"ababa\"\n\n    Output:\n    [\"a\", \"aba\", \"ababa\", \"b\", \"bab\"]\n\n    Explanation:\n    The substrings \"a\", \"aba\", \"ababa\", \"b\", and \"bab\" are all palindromes.\n\n    \"\"\"\n    def is_palindrome(substring: str) -> bool:\n        return substring == substring[::-1]\n    \n    n = len(s)\n    substrings = []\n    \n    for i in range(n):\n        for j in range(i+1, n+1):\n            substring = s[i:j]\n            if is_palindrome(substring):\n                substrings.append(substring)\n    \n    return substrings", "solution_func": "def g() -> str:\n    return \"ababa\"", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, return the indices of two numbers from the list such that they add up to the target value.\n\n    Example:\n    Input:\n    nums = [2, 7, 11, 15], target = 9\n\n    Output:\n    [0, 1]\n    Explanation:\n    The numbers at indices 0 and 1 (2 and 7) add up to 9.\n\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        if nums[left] + nums[right] == target:\n            return [left, right]\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g(nums: List[int] = [2, 7, 11, 15], target: int = 9) -> Tuple[List[int], int]:\n    return (nums, target)\n\nassert f(*g()) == [0, 1]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 339, "target_skills": [0, 0, 1, 1, 0, 1, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, return the indices of two numbers from the list such that they add up to the target value.\n\n    Example:\n    Input:\n    nums = [2, 7, 11, 15], target = 9\n\n    Output:\n    [0, 1]\n    Explanation:\n    The numbers at indices 0 and 1 (2 and 7) add up to 9.\n\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        if nums[left] + nums[right] == target:\n            return [left, right]\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []", "solution_func": "def g(nums: List[int] = [2, 7, 11, 15], target: int = 9) -> Tuple[List[int], int]:\n    return (nums, target)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, k: int) -> int:\n    \"\"\"\n    Given a string s, count the number of distinct substrings of length k.\n    \"\"\"\n\n    def count_distinct_substrings(s, k):\n        distinct_substrings = set()\n        n = len(s)\n        for i in range(n - k + 1):\n            substring = s[i:i+k]\n            distinct_substrings.add(substring)\n        return len(distinct_substrings)\n\n    return count_distinct_substrings(s, k)\n\ndef g():\n    return (\"ababa\", 3)\n\nassert f(*g()) == 2\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 339, "target_skills": [0, 1, 0, 0, 1, 1, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str, k: int) -> int:\n    \"\"\"\n    Given a string s, count the number of distinct substrings of length k.\n    \"\"\"\n\n    def count_distinct_substrings(s, k):\n        distinct_substrings = set()\n        n = len(s)\n        for i in range(n - k + 1):\n            substring = s[i:i+k]\n            distinct_substrings.add(substring)\n        return len(distinct_substrings)\n\n    return count_distinct_substrings(s, k)", "solution_func": "def g():\n    return (\"ababa\", 3)", "map_ix": [0, 1, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, determine if there are two numbers in the list that add up to the target.\n    Return True if such numbers exist, otherwise return False.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    nums = [1, 3, 5, 7, 9]\n    target = 8\n    return nums, target\n\nassert f(*g()) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 340, "target_skills": [1, 0, 0, 1, 0, 0, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, determine if there are two numbers in the list that add up to the target.\n    Return True if such numbers exist, otherwise return False.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g():\n    nums = [1, 3, 5, 7, 9]\n    target = 8\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return a new list where each element is the product of all the elements in nums except the corresponding element.\n    The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer without overflowing.\n    You must write an algorithm that runs in O(n) time and without using the division operation.\n    \"\"\"\n\n    n = len(nums)\n    output = [1] * n\n    left_product = 1\n    right_product = 1\n\n    for i in range(n):\n        output[i] *= left_product\n        left_product *= nums[i]\n\n    for i in range(n - 1, -1, -1):\n        output[i] *= right_product\n        right_product *= nums[i]\n\n    return output\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == [120, 60, 40, 30, 24]\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 340, "target_skills": [0, 1, 1, 0, 0, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return a new list where each element is the product of all the elements in nums except the corresponding element.\n    The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer without overflowing.\n    You must write an algorithm that runs in O(n) time and without using the division operation.\n    \"\"\"\n\n    n = len(nums)\n    output = [1] * n\n    left_product = 1\n    right_product = 1\n\n    for i in range(n):\n        output[i] *= left_product\n        left_product *= nums[i]\n\n    for i in range(n - 1, -1, -1):\n        output[i] *= right_product\n        right_product *= nums[i]\n\n    return output", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of integer heights representing the height of bars in a bar chart, calculate the area of the largest rectangle that can be formed within the chart.\n    The width of each bar is 1.\n    \"\"\"\n\n    stack = []\n    max_area = 0\n    n = len(heights)\n\n    for i in range(n):\n        while stack and heights[i] < heights[stack[-1]]:\n            height = heights[stack.pop()]\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        stack.append(i)\n\n    while stack:\n        height = heights[stack.pop()]\n        width = n if not stack else n - stack[-1] - 1\n        max_area = max(max_area, height * width)\n\n    return max_area\n\ndef g():\n    heights = [2, 1, 5, 6, 2, 3]\n    return heights\n\nassert f(g()) == 10\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 340, "target_skills": [0, 1, 1, 0, 0, 1, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of integer heights representing the height of bars in a bar chart, calculate the area of the largest rectangle that can be formed within the chart.\n    The width of each bar is 1.\n    \"\"\"\n\n    stack = []\n    max_area = 0\n    n = len(heights)\n\n    for i in range(n):\n        while stack and heights[i] < heights[stack[-1]]:\n            height = heights[stack.pop()]\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        stack.append(i)\n\n    while stack:\n        height = heights[stack.pop()]\n        width = n if not stack else n - stack[-1] - 1\n        max_area = max(max_area, height * width)\n\n    return max_area", "solution_func": "def g():\n    heights = [2, 1, 5, 6, 2, 3]\n    return heights", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of subsequences that have a sum divisible by 3.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5]\n    Output: 7\n\n    Explanation:\n    The subsequences with a sum divisible by 3 are: [3], [1, 2], [2, 4], [1, 2, 4], [2, 3], [1, 2, 3], [3, 4]\n    \"\"\"\n\n    dp = [0] * 3\n    dp[0] = 1\n\n    for num in nums:\n        new_dp = dp.copy()\n        for i in range(3):\n            new_dp[(num + i) % 3] += dp[i]\n        dp = new_dp\n\n    return dp[0] - 1\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 7\n\n", "emb": null, "idx_generation": 340, "target_skills": [1, 1, 1, 0, 1, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of subsequences that have a sum divisible by 3.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5]\n    Output: 7\n\n    Explanation:\n    The subsequences with a sum divisible by 3 are: [3], [1, 2], [2, 4], [1, 2, 4], [2, 3], [1, 2, 3], [3, 4]\n    \"\"\"\n\n    dp = [0] * 3\n    dp[0] = 1\n\n    for num in nums:\n        new_dp = dp.copy()\n        for i in range(3):\n            new_dp[(num + i) % 3] += dp[i]\n        dp = new_dp\n\n    return dp[0] - 1", "solution_func": "def g():\n    return [1, 2, 3, 4, 5]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid graph represented as an adjacency matrix 'graph', find the number of connected components.\n\n    Example:\n    Input: graph = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\n    Output: 2\n\n    Explanation:\n    The grid can be visualized as:\n    1 1 0\n    1 1 0\n    0 0 1\n\n    There are two connected components: (0, 1, 3, 4) and (2).\n    \"\"\"\n\n    def dfs(node: int) -> None:\n        visited[node] = True\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                dfs(neighbor)\n\n    n = len(graph)\n    visited = [False] * n\n    count = 0\n\n    for node in range(n):\n        if not visited[node]:\n            dfs(node)\n            count += 1\n\n    return count\n\ndef g():\n    return [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\n\nassert f(g()) == 2\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 340, "target_skills": [1, 1, 1, 1, 1, 1, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid graph represented as an adjacency matrix 'graph', find the number of connected components.\n\n    Example:\n    Input: graph = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\n    Output: 2\n\n    Explanation:\n    The grid can be visualized as:\n    1 1 0\n    1 1 0\n    0 0 1\n\n    There are two connected components: (0, 1, 3, 4) and (2).\n    \"\"\"\n\n    def dfs(node: int) -> None:\n        visited[node] = True\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                dfs(neighbor)\n\n    n = len(graph)\n    visited = [False] * n\n    count = 0\n\n    for node in range(n):\n        if not visited[node]:\n            dfs(node)\n            count += 1\n\n    return count", "solution_func": "def g():\n    return [[1, 1, 0], [1, 1, 0], [0, 0, 1]]", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], pattern: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a pattern, find all words in the list that follow the same pattern as the given pattern.\n\n    Example:\n    Input: words = ['abc', 'def', 'ghi', 'jkl', 'mno'], pattern = 'aba'\n    Output: ['abc', 'def']\n\n    Explanation:\n    The pattern 'aba' matches the words 'abc' and 'def' because the first and third characters are the same.\n    \"\"\"\n\n    def match(word: str, pattern: str) -> bool:\n        if len(word) != len(pattern):\n            return False\n\n        mapping = {}\n        used = set()\n\n        for i in range(len(word)):\n            if pattern[i] not in mapping:\n                if word[i] in used:\n                    return False\n                mapping[pattern[i]] = word[i]\n                used.add(word[i])\n            else:\n                if mapping[pattern[i]] != word[i]:\n                    return False\n\n        return True\n\n    return [word for word in words if match(word, pattern)]\n\ndef g():\n    return (['abc', 'def', 'ghi', 'jkl', 'mno'], 'aba')\n\nassert f(*g()) == ['abc', 'def']\n\n", "emb": null, "idx_generation": 340, "target_skills": [1, 0, 0, 0, 0, 1, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], pattern: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a pattern, find all words in the list that follow the same pattern as the given pattern.\n\n    Example:\n    Input: words = ['abc', 'def', 'ghi', 'jkl', 'mno'], pattern = 'aba'\n    Output: ['abc', 'def']\n\n    Explanation:\n    The pattern 'aba' matches the words 'abc' and 'def' because the first and third characters are the same.\n    \"\"\"\n\n    def match(word: str, pattern: str) -> bool:\n        if len(word) != len(pattern):\n            return False\n\n        mapping = {}\n        used = set()\n\n        for i in range(len(word)):\n            if pattern[i] not in mapping:\n                if word[i] in used:\n                    return False\n                mapping[pattern[i]] = word[i]\n                used.add(word[i])\n            else:\n                if mapping[pattern[i]] != word[i]:\n                    return False\n\n        return True\n\n    return [word for word in words if match(word, pattern)]", "solution_func": "def g():\n    return (['abc', 'def', 'ghi', 'jkl', 'mno'], 'aba')", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, return all possible permutations of the numbers.\n\n    Example:\n    nums = [1, 2, 3]\n\n    Output:\n    [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n    Explanation:\n    The possible permutations of the numbers 1, 2, and 3 are [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n    \"\"\"\n    def backtrack(nums, path, res):\n        if not nums:\n            res.append(path)\n        for i in range(len(nums)):\n            backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n    \n    res = []\n    backtrack(nums, [], res)\n    return res\n\ndef g():\n    return [[1, 2, 3]]\n\nassert f(*g()) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 340, "target_skills": [1, 0, 1, 0, 1, 0, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, return all possible permutations of the numbers.\n\n    Example:\n    nums = [1, 2, 3]\n\n    Output:\n    [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n    Explanation:\n    The possible permutations of the numbers 1, 2, and 3 are [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n    \"\"\"\n    def backtrack(nums, path, res):\n        if not nums:\n            res.append(path)\n        for i in range(len(nums)):\n            backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n    \n    res = []\n    backtrack(nums, [], res)\n    return res", "solution_func": "def g():\n    return [[1, 2, 3]]", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, determine if the graph contains a cycle.\n\n    Example:\n    graph = [[1, 2], [2, 3], [3, 1]]\n\n    Output:\n    True\n\n    Explanation:\n    The graph contains a cycle: 1 -> 2 -> 3 -> 1.\n    \"\"\"\n    def dfs(node, visited, parent, graph):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, node, graph):\n                    return True\n            elif neighbor != parent:\n                return True\n        return False\n    \n    n = len(graph)\n    visited = [False] * n\n    for i in range(n):\n        if not visited[i]:\n            if dfs(i, visited, -1, graph):\n                return True\n    return False\n\ndef g():\n    return [[[1, 2], [2, 3], [3, 1]]]\n\nassert f(*g()) == True\n\n", "emb": null, "idx_generation": 340, "target_skills": [0, 1, 1, 1, 0, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, determine if the graph contains a cycle.\n\n    Example:\n    graph = [[1, 2], [2, 3], [3, 1]]\n\n    Output:\n    True\n\n    Explanation:\n    The graph contains a cycle: 1 -> 2 -> 3 -> 1.\n    \"\"\"\n    def dfs(node, visited, parent, graph):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, node, graph):\n                    return True\n            elif neighbor != parent:\n                return True\n        return False\n    \n    n = len(graph)\n    visited = [False] * n\n    for i in range(n):\n        if not visited[i]:\n            if dfs(i, visited, -1, graph):\n                return True\n    return False", "solution_func": "def g():\n    return [[[1, 2], [2, 3], [3, 1]]]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, check if it is a palindrome.\n\n    Example:\n    s = \"racecar\"\n\n    Output:\n    True\n\n    Explanation:\n    The string \"racecar\" is a palindrome.\n    \"\"\"\n    return s == s[::-1]\n\ndef g():\n    return \"racecar\"\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 340, "target_skills": [0, 0, 0, 1, 0, 0, 0, 1, 1, 1], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, check if it is a palindrome.\n\n    Example:\n    s = \"racecar\"\n\n    Output:\n    True\n\n    Explanation:\n    The string \"racecar\" is a palindrome.\n    \"\"\"\n    return s == s[::-1]", "solution_func": "def g():\n    return \"racecar\"", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers, find the number of elements that are greater than the target value.\n    Return the count of such elements.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 3\n\n    Output:\n    2\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] <= target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return len(arr) - left\n\ndef g() -> List[int]:\n    \"\"\"\n    Return a sorted array and a target value.\n    \"\"\"\n    return [1, 2, 3, 4, 5], 3\n\nassert f(*g()) == 2\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 340, "target_skills": [1, 0, 1, 1, 0, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers, find the number of elements that are greater than the target value.\n    Return the count of such elements.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 3\n\n    Output:\n    2\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] <= target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return len(arr) - left", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Return a sorted array and a target value.\n    \"\"\"\n    return [1, 2, 3, 4, 5], 3", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a pair of numbers whose sum is equal to a power of 2.\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(i+1, n):\n            if (nums[i] + nums[j]) & (nums[i] + nums[j] - 1) == 0:\n                return True\n    return False\n\ndef g():\n    nums = [1, 3, 4, 5, 7]\n    return nums\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 341, "target_skills": [0, 1, 0, 0, 1, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a pair of numbers whose sum is equal to a power of 2.\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(i+1, n):\n            if (nums[i] + nums[j]) & (nums[i] + nums[j] - 1) == 0:\n                return True\n    return False", "solution_func": "def g():\n    nums = [1, 3, 4, 5, 7]\n    return nums", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a pair of numbers whose product is a perfect square.\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(i+1, n):\n            if (nums[i] * nums[j]) ** 0.5 % 1 == 0:\n                return True\n    return False\n\ndef g():\n    nums = [2, 3, 4, 6, 8]\n    return nums\n\nassert f(g()) == True\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 341, "target_skills": [0, 1, 1, 1, 0, 1, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a pair of numbers whose product is a perfect square.\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(i+1, n):\n            if (nums[i] * nums[j]) ** 0.5 % 1 == 0:\n                return True\n    return False", "solution_func": "def g():\n    nums = [2, 3, 4, 6, 8]\n    return nums", "map_ix": [1, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a pair of numbers whose bitwise XOR is a power of 2.\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(i+1, n):\n            if (nums[i] ^ nums[j]) & ((nums[i] ^ nums[j]) - 1) == 0:\n                return True\n    return False\n\ndef g():\n    nums = [1, 2, 4, 8, 16]\n    return nums\n\nassert f(g()) == True\n", "emb": null, "idx_generation": 341, "target_skills": [1, 0, 1, 0, 1, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a pair of numbers whose bitwise XOR is a power of 2.\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(i+1, n):\n            if (nums[i] ^ nums[j]) & ((nums[i] ^ nums[j]) - 1) == 0:\n                return True\n    return False", "solution_func": "def g():\n    nums = [1, 2, 4, 8, 16]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, return the number of unique elements in the list.\n    \n    Example:\n    Input: nums = [1, 2, 2, 3, 3, 3]\n    Output: 3\n    \n    Explanation: The unique elements in the list are 1, 2, and 3.\n\n    Hint: Use a set to keep track of unique elements.\n    \"\"\"\n    unique_nums = set(nums)\n    return len(unique_nums)\n\ndef g(nums=[1, 2, 2, 3, 3, 3]):\n    return nums\n\nassert f(*g()) == 3\n\n", "emb": null, "idx_generation": 341, "target_skills": [0, 1, 1, 1, 0, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, return the number of unique elements in the list.\n    \n    Example:\n    Input: nums = [1, 2, 2, 3, 3, 3]\n    Output: 3\n    \n    Explanation: The unique elements in the list are 1, 2, and 3.\n\n    Hint: Use a set to keep track of unique elements.\n    \"\"\"\n    unique_nums = set(nums)\n    return len(unique_nums)", "solution_func": "def g(nums=[1, 2, 2, 3, 3, 3]):\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a subgrid where the subgrid is a rectangle with all sides parallel to the grid edges.\n    \n    Example:\n    Input: grid = [[1, 2, -3], [-4, 5, 6], [7, -8, 9]]\n    Output: 21\n    \n    Explanation: The maximum sum is obtained from the subgrid [[5, 6], [-8, 9]], which has a sum of 21.\n\n    Hint: Use dynamic programming to calculate the maximum sum for each subgrid.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    max_sum = float('-inf')\n    \n    for i in range(rows):\n        for j in range(cols):\n            for k in range(i, rows):\n                for l in range(j, cols):\n                    subgrid_sum = sum([grid[row][col] for row in range(i, k+1) for col in range(j, l+1)])\n                    max_sum = max(max_sum, subgrid_sum)\n    \n    return max_sum\n\ndef g(grid=[[1, 2, -3], [-4, 5, 6], [7, -8, 9]]):\n    return grid\n\nassert f(*g()) == 21\n\n", "emb": null, "idx_generation": 341, "target_skills": [1, 1, 1, 0, 0, 1, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a subgrid where the subgrid is a rectangle with all sides parallel to the grid edges.\n    \n    Example:\n    Input: grid = [[1, 2, -3], [-4, 5, 6], [7, -8, 9]]\n    Output: 21\n    \n    Explanation: The maximum sum is obtained from the subgrid [[5, 6], [-8, 9]], which has a sum of 21.\n\n    Hint: Use dynamic programming to calculate the maximum sum for each subgrid.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    max_sum = float('-inf')\n    \n    for i in range(rows):\n        for j in range(cols):\n            for k in range(i, rows):\n                for l in range(j, cols):\n                    subgrid_sum = sum([grid[row][col] for row in range(i, k+1) for col in range(j, l+1)])\n                    max_sum = max(max_sum, subgrid_sum)\n    \n    return max_sum", "solution_func": "def g(grid=[[1, 2, -3], [-4, 5, 6], [7, -8, 9]]):\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target integer, find the minimum number of operations required to make all elements in the list equal to the target.\n    Each operation involves either adding 1 or subtracting 1 from an element in the list.\n\n    Example:\n    Input: nums = [1, 2, 3], target = 2\n    Output: 2\n\n    Explanation: The minimum number of operations is achieved by subtracting 1 from the first element and adding 1 to the third element.\n\n    Hint: Calculate the difference between each element and the target, and then find the sum of the absolute differences.\n\n    \"\"\"\n    diff_sum = sum([abs(num - target) for num in nums])\n    return diff_sum\n\ndef g(nums=[1, 2, 3], target=2):\n    return nums, target\n\nassert f(*g()) == 2\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 341, "target_skills": [0, 1, 0, 1, 1, 0, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target integer, find the minimum number of operations required to make all elements in the list equal to the target.\n    Each operation involves either adding 1 or subtracting 1 from an element in the list.\n\n    Example:\n    Input: nums = [1, 2, 3], target = 2\n    Output: 2\n\n    Explanation: The minimum number of operations is achieved by subtracting 1 from the first element and adding 1 to the third element.\n\n    Hint: Calculate the difference between each element and the target, and then find the sum of the absolute differences.\n\n    \"\"\"\n    diff_sum = sum([abs(num - target) for num in nums])\n    return diff_sum", "solution_func": "def g(nums=[1, 2, 3], target=2):\n    return nums, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers and a target value, find two numbers in the array that add up to the target value.\n    Return their indices as a list in ascending order.\n\n    Example:\n    f([-2, 7, 11, 15], 9) returns [0, 1], as nums[0] + nums[1] = -2 + 7 = 5.\n\n    Note:\n    - You may assume that each input would have exactly one solution.\n    - You may not use the same element twice.\n    - The input array is sorted in ascending order.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\n\ndef g():\n    \"\"\"\n    Generate a sorted array of integers and a target value.\n    \"\"\"\n\n    return [-2, 7, 11, 15], 9\n\n\nassert f(*g()) == [0, 1]\n\n", "emb": null, "idx_generation": 341, "target_skills": [0, 0, 1, 1, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers and a target value, find two numbers in the array that add up to the target value.\n    Return their indices as a list in ascending order.\n\n    Example:\n    f([-2, 7, 11, 15], 9) returns [0, 1], as nums[0] + nums[1] = -2 + 7 = 5.\n\n    Note:\n    - You may assume that each input would have exactly one solution.\n    - You may not use the same element twice.\n    - The input array is sorted in ascending order.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g():\n    \"\"\"\n    Generate a sorted array of integers and a target value.\n    \"\"\"\n\n    return [-2, 7, 11, 15], 9", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, check if the graph is bipartite.\n\n    A graph is bipartite if it can be colored using two colors such that no two adjacent vertices have the same color.\n\n    Return True if the graph is bipartite, and False otherwise.\n\n    Example:\n    f([[1, 3], [0, 2], [1, 3], [0, 2]]) returns True, as the graph can be colored as follows:\n    - Vertices 0 and 2 are colored with color 0.\n    - Vertices 1 and 3 are colored with color 1.\n\n    Note:\n    - The graph will have at most 100 vertices.\n    - Each vertex's edges are not sorted in any specific order.\n    - The graph may not be connected.\n    \"\"\"\n\n    colors = [-1] * len(graph)\n\n    for node in range(len(graph)):\n        if colors[node] == -1:\n            if not dfs(graph, node, colors, 0):\n                return False\n\n    return True\n\n\ndef dfs(graph: List[List[int]], node: int, colors: List[int], color: int) -> bool:\n    \"\"\"\n    Perform a depth-first search to color the graph and check if it is bipartite.\n    \"\"\"\n\n    colors[node] = color\n\n    for neighbor in graph[node]:\n        if colors[neighbor] == color:\n            return False\n        if colors[neighbor] == -1 and not dfs(graph, neighbor, colors, 1 - color):\n            return False\n\n    return True\n\n\ndef g():\n    \"\"\"\n    Generate an undirected graph represented as an adjacency list.\n    \"\"\"\n\n    return [[1, 3], [0, 2], [1, 3], [0, 2]]\n\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 341, "target_skills": [0, 0, 0, 0, 1, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, check if the graph is bipartite.\n\n    A graph is bipartite if it can be colored using two colors such that no two adjacent vertices have the same color.\n\n    Return True if the graph is bipartite, and False otherwise.\n\n    Example:\n    f([[1, 3], [0, 2], [1, 3], [0, 2]]) returns True, as the graph can be colored as follows:\n    - Vertices 0 and 2 are colored with color 0.\n    - Vertices 1 and 3 are colored with color 1.\n\n    Note:\n    - The graph will have at most 100 vertices.\n    - Each vertex's edges are not sorted in any specific order.\n    - The graph may not be connected.\n    \"\"\"\n\n    colors = [-1] * len(graph)\n\n    for node in range(len(graph)):\n        if colors[node] == -1:\n            if not dfs(graph, node, colors, 0):\n                return False\n\n    return True\n\n\ndef dfs(graph: List[List[int]], node: int, colors: List[int], color: int) -> bool:\n    \"\"\"\n    Perform a depth-first search to color the graph and check if it is bipartite.\n    \"\"\"\n\n    colors[node] = color\n\n    for neighbor in graph[node]:\n        if colors[neighbor] == color:\n            return False\n        if colors[neighbor] == -1 and not dfs(graph, neighbor, colors, 1 - color):\n            return False\n\n    return True", "solution_func": "def g():\n    \"\"\"\n    Generate an undirected graph represented as an adjacency list.\n    \"\"\"\n\n    return [[1, 3], [0, 2], [1, 3], [0, 2]]", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the count of the total number of set bits in all numbers from 1 to n.\n\n    Example:\n    f(5) returns 7, as the set bits in the numbers from 1 to 5 are as follows:\n    - 1: 1\n    - 2: 10\n    - 3: 11\n    - 4: 100\n    - 5: 101\n    The total count of set bits is 7.\n\n    Note:\n    - 0 <= n <= 10^9\n    \"\"\"\n\n    if n == 0:\n        return 0\n\n    power_of_two = 1\n    count = 0\n\n    while power_of_two <= n:\n        count += (n // (2 * power_of_two)) * power_of_two\n        if n % (2 * power_of_two) >= power_of_two:\n            count += n % (2 * power_of_two) - power_of_two + 1\n        power_of_two *= 2\n\n    return count\n\n\ndef g():\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n\n    return 5\n\n\nassert f(g()) == 7\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 341, "target_skills": [1, 1, 0, 0, 0, 0, 1, 0, 1, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the count of the total number of set bits in all numbers from 1 to n.\n\n    Example:\n    f(5) returns 7, as the set bits in the numbers from 1 to 5 are as follows:\n    - 1: 1\n    - 2: 10\n    - 3: 11\n    - 4: 100\n    - 5: 101\n    The total count of set bits is 7.\n\n    Note:\n    - 0 <= n <= 10^9\n    \"\"\"\n\n    if n == 0:\n        return 0\n\n    power_of_two = 1\n    count = 0\n\n    while power_of_two <= n:\n        count += (n // (2 * power_of_two)) * power_of_two\n        if n % (2 * power_of_two) >= power_of_two:\n            count += n % (2 * power_of_two) - power_of_two + 1\n        power_of_two *= 2\n\n    return count", "solution_func": "def g():\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n\n    return 5", "map_ix": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of ways to arrange the numbers such that the sum of any two adjacent\n    numbers is a perfect square.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    3\n\n    Explanation:\n    There are 3 ways to arrange the numbers [1, 2, 3, 4] such that the sum of any two adjacent numbers is a perfect square:\n    1, 3, 2, 4\n    2, 4, 1, 3\n    3, 1, 4, 2\n    \"\"\"\n    def is_perfect_square(n: int) -> bool:\n        return int(n ** 0.5) ** 2 == n\n\n    def helper(nums: List[int], used: List[bool]) -> int:\n        if all(used):\n            return 1\n\n        count = 0\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n\n            if not used[i - 1] and not is_perfect_square(nums[i] + nums[i - 1]):\n                continue\n\n            used[i] = True\n            count += helper(nums, used)\n            used[i] = False\n\n        return count\n\n    return helper(nums, [False] * len(nums))\n\ndef g(nums: List[int] = [1, 2, 3, 4]):\n    return (nums,)\n\nassert f(*g()) == 3\n", "emb": null, "idx_generation": 341, "target_skills": [1, 0, 0, 1, 1, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of ways to arrange the numbers such that the sum of any two adjacent\n    numbers is a perfect square.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    3\n\n    Explanation:\n    There are 3 ways to arrange the numbers [1, 2, 3, 4] such that the sum of any two adjacent numbers is a perfect square:\n    1, 3, 2, 4\n    2, 4, 1, 3\n    3, 1, 4, 2\n    \"\"\"\n    def is_perfect_square(n: int) -> bool:\n        return int(n ** 0.5) ** 2 == n\n\n    def helper(nums: List[int], used: List[bool]) -> int:\n        if all(used):\n            return 1\n\n        count = 0\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n\n            if not used[i - 1] and not is_perfect_square(nums[i] + nums[i - 1]):\n                continue\n\n            used[i] = True\n            count += helper(nums, used)\n            used[i] = False\n\n        return count\n\n    return helper(nums, [False] * len(nums))", "solution_func": "def g(nums: List[int] = [1, 2, 3, 4]):\n    return (nums,)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the elements in the original list except the corresponding element.\n\n    Example:\n    Input: [1, 2, 3, 4]\n    Output: [24, 12, 8, 6]\n    Explanation: The product of all elements in the original list except 1 is 24, the product of all elements except 2 is 12, the product of all elements except 3 is 8, and the product of all elements except 4 is 6.\n    \"\"\"\n\n    n = len(nums)\n    left_prod = [1] * n\n    right_prod = [1] * n\n    result = [1] * n\n\n    for i in range(1, n):\n        left_prod[i] = left_prod[i-1] * nums[i-1]\n\n    for i in range(n-2, -1, -1):\n        right_prod[i] = right_prod[i+1] * nums[i+1]\n\n    for i in range(n):\n        result[i] = left_prod[i] * right_prod[i]\n\n    return result\n\ndef g():\n    return ([1, 2, 3, 4],)\n\nassert f(*g()) == [24, 12, 8, 6]\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0], "idx_generation": 342, "target_skills": [0, 1, 0, 0, 1, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the elements in the original list except the corresponding element.\n\n    Example:\n    Input: [1, 2, 3, 4]\n    Output: [24, 12, 8, 6]\n    Explanation: The product of all elements in the original list except 1 is 24, the product of all elements except 2 is 12, the product of all elements except 3 is 8, and the product of all elements except 4 is 6.\n    \"\"\"\n\n    n = len(nums)\n    left_prod = [1] * n\n    right_prod = [1] * n\n    result = [1] * n\n\n    for i in range(1, n):\n        left_prod[i] = left_prod[i-1] * nums[i-1]\n\n    for i in range(n-2, -1, -1):\n        right_prod[i] = right_prod[i+1] * nums[i+1]\n\n    for i in range(n):\n        result[i] = left_prod[i] * right_prod[i]\n\n    return result", "solution_func": "def g():\n    return ([1, 2, 3, 4],)", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 1, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the majority element (element that appears more than n/2 times, where n is the length of the list).\n\n    Example:\n    Input: [2, 2, 1, 1, 1, 2, 2]\n    Output: 2\n    Explanation: The majority element in the list is 2, as it appears more than n/2 times (where n is 7).\n    \"\"\"\n\n    count = 0\n    majority = None\n\n    for num in nums:\n        if count == 0:\n            majority = num\n        if num == majority:\n            count += 1\n        else:\n            count -= 1\n\n    return majority\n\ndef g():\n    return ([2, 2, 1, 1, 1, 2, 2],)\n\nassert f(*g()) == 2\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 342, "target_skills": [1, 0, 1, 0, 1, 0, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the majority element (element that appears more than n/2 times, where n is the length of the list).\n\n    Example:\n    Input: [2, 2, 1, 1, 1, 2, 2]\n    Output: 2\n    Explanation: The majority element in the list is 2, as it appears more than n/2 times (where n is 7).\n    \"\"\"\n\n    count = 0\n    majority = None\n\n    for num in nums:\n        if count == 0:\n            majority = num\n        if num == majority:\n            count += 1\n        else:\n            count -= 1\n\n    return majority", "solution_func": "def g():\n    return ([2, 2, 1, 1, 1, 2, 2],)", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 1s and 0s, find the maximum size of a square subgrid containing only 1s.\n\n    Example:\n    Input:\n    grid = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n    Output: 4\n    Explanation: The maximum size of a square subgrid containing only 1s is 4.\n\n    \"\"\"\n\n    if not grid:\n        return 0\n\n    rows = len(grid)\n    cols = len(grid[0])\n    max_size = 0\n    dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            if grid[i-1][j-1] == 1:\n                dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1\n                max_size = max(max_size, dp[i][j])\n\n    return max_size * max_size\n\ndef g():\n    return ([[1, 0, 1, 0, 0],\n             [1, 0, 1, 1, 1],\n             [1, 1, 1, 1, 1],\n             [1, 0, 0, 1, 0]],)\n\nassert f(*g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 342, "target_skills": [1, 1, 1, 1, 0, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 1s and 0s, find the maximum size of a square subgrid containing only 1s.\n\n    Example:\n    Input:\n    grid = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n    Output: 4\n    Explanation: The maximum size of a square subgrid containing only 1s is 4.\n\n    \"\"\"\n\n    if not grid:\n        return 0\n\n    rows = len(grid)\n    cols = len(grid[0])\n    max_size = 0\n    dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            if grid[i-1][j-1] == 1:\n                dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1\n                max_size = max(max_size, dp[i][j])\n\n    return max_size * max_size", "solution_func": "def g():\n    return ([[1, 0, 1, 0, 0],\n             [1, 0, 1, 1, 1],\n             [1, 1, 1, 1, 1],\n             [1, 0, 0, 1, 0]],)", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target number, determine if there are two numbers in nums such that their\n    sum equals to the target.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: True\n\n    Explanation: The sum of 2 and 7 equals to the target number 9.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return nums, target\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 342, "target_skills": [1, 0, 1, 0, 1, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target number, determine if there are two numbers in nums such that their\n    sum equals to the target.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: True\n\n    Explanation: The sum of 2 and 7 equals to the target number 9.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g(nums=[2, 7, 11, 15], target=9):\n    return nums, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(num1: int, num2: int) -> int:\n    \"\"\"\n    Given two integers num1 and num2, find the bitwise XOR of the two numbers.\n\n    Example:\n    Input: num1 = 5, num2 = 3\n    Output: 6\n\n    Explanation: The bitwise XOR of 5 and 3 is 6 (101 XOR 011 = 110).\n    \"\"\"\n    return num1 ^ num2\n\ndef g(num1=5, num2=3):\n    return num1, num2\n\nassert f(*g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 342, "target_skills": [1, 0, 1, 1, 0, 1, 0, 1, 1, 1], "problem_func": "from typing import*\ndef f(num1: int, num2: int) -> int:\n    \"\"\"\n    Given two integers num1 and num2, find the bitwise XOR of the two numbers.\n\n    Example:\n    Input: num1 = 5, num2 = 3\n    Output: 6\n\n    Explanation: The bitwise XOR of 5 and 3 is 6 (101 XOR 011 = 110).\n    \"\"\"\n    return num1 ^ num2", "solution_func": "def g(num1=5, num2=3):\n    return num1, num2", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target number, find the index of the target number in the list using binary search.\n\n    Example:\n    Input: nums = [1, 3, 5, 7, 9], target = 5\n    Output: 2\n\n    Explanation: The target number 5 is located at index 2 in the list.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(nums=[1, 3, 5, 7, 9], target=5):\n    return nums, target\n\nassert f(*g()) == 2\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 342, "target_skills": [1, 0, 0, 0, 1, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target number, find the index of the target number in the list using binary search.\n\n    Example:\n    Input: nums = [1, 3, 5, 7, 9], target = 5\n    Output: 2\n\n    Explanation: The target number 5 is located at index 2 in the list.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g(nums=[1, 3, 5, 7, 9], target=5):\n    return nums, target", "map_ix": [1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    return dp[m - 1][n - 1]\n\ndef g() -> List[List[int]]:\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 9\n", "emb": null, "idx_generation": 342, "target_skills": [0, 1, 0, 1, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    return dp[m - 1][n - 1]", "solution_func": "def g() -> List[List[int]]:\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all positive even numbers in the list, excluding multiples of 3.\n    \"\"\"\n    return sum(num for num in nums if num > 0 and num % 2 == 0 and num % 3 != 0)\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == 20\n", "emb": null, "idx_generation": 342, "target_skills": [1, 0, 0, 0, 0, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all positive even numbers in the list, excluding multiples of 3.\n    \"\"\"\n    return sum(num for num in nums if num > 0 and num % 2 == 0 and num % 3 != 0)", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in non-decreasing order using a stack.\n    \"\"\"\n    stack = []\n    for num in nums:\n        while stack and num < stack[-1]:\n            nums[stack.pop()] = num\n        stack.append(nums.index(num))\n    while stack:\n        nums[stack.pop()] = float('-inf')\n    return [num for num in nums if num != float('-inf')]\n\ndef g() -> List[int]:\n    return [5, 3, 8, 1, 2, 7, 4]\n\nassert f(g()) == [1, 2, 3, 4, 5, 7, 8]\n", "emb": null, "idx_generation": 342, "target_skills": [0, 1, 1, 1, 1, 0, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in non-decreasing order using a stack.\n    \"\"\"\n    stack = []\n    for num in nums:\n        while stack and num < stack[-1]:\n            nums[stack.pop()] = num\n        stack.append(nums.index(num))\n    while stack:\n        nums[stack.pop()] = float('-inf')\n    return [num for num in nums if num != float('-inf')]", "solution_func": "def g() -> List[int]:\n    return [5, 3, 8, 1, 2, 7, 4]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n    Return True if the maximum product is greater than or equal to 1000, else return False.\n    \"\"\"\n    arr.sort()\n    n = len(arr)\n    max_product = max(arr[n-1] * arr[n-2] * arr[n-3], arr[0] * arr[1] * arr[n-1])\n    return max_product >= 1000\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g())\n", "emb": null, "idx_generation": 342, "target_skills": [1, 1, 0, 1, 0, 1, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n    Return True if the maximum product is greater than or equal to 1000, else return False.\n    \"\"\"\n    arr.sort()\n    n = len(arr)\n    max_product = max(arr[n-1] * arr[n-2] * arr[n-3], arr[0] * arr[1] * arr[n-1])\n    return max_product >= 1000", "solution_func": "def g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n\n    Example:\n    Input:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 6\n\n    Output:\n    5\n    \"\"\"\n\n    def binary_search(nums: List[int], target: int, left: int, right: int) -> int:\n        if left > right:\n            return -1\n\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            return binary_search(nums, target, mid + 1, right)\n        else:\n            return binary_search(nums, target, left, mid - 1)\n\n    return binary_search(nums, target, 0, len(nums) - 1)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9], 6\n\nassert f(*g()) == 5\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 343, "target_skills": [1, 0, 0, 1, 1, 0, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n\n    Example:\n    Input:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 6\n\n    Output:\n    5\n    \"\"\"\n\n    def binary_search(nums: List[int], target: int, left: int, right: int) -> int:\n        if left > right:\n            return -1\n\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            return binary_search(nums, target, mid + 1, right)\n        else:\n            return binary_search(nums, target, left, mid - 1)\n\n    return binary_search(nums, target, 0, len(nums) - 1)", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9], 6", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"\n    Given a positive integer, count the number of set bits (1s) in its binary representation using recursion.\n\n    Example:\n    Input:\n    num = 10\n\n    Output:\n    2\n    \"\"\"\n\n    def count_set_bits(num: int) -> int:\n        if num == 0:\n            return 0\n        else:\n            return (num & 1) + count_set_bits(num >> 1)\n\n    return count_set_bits(num)\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return 10\n\nassert f(g()) == 2\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 343, "target_skills": [1, 1, 1, 1, 1, 0, 0, 1, 0, 1], "problem_func": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"\n    Given a positive integer, count the number of set bits (1s) in its binary representation using recursion.\n\n    Example:\n    Input:\n    num = 10\n\n    Output:\n    2\n    \"\"\"\n\n    def count_set_bits(num: int) -> int:\n        if num == 0:\n            return 0\n        else:\n            return (num & 1) + count_set_bits(num >> 1)\n\n    return count_set_bits(num)", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return 10", "map_ix": [0, 0, 0, 0, 1, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with the squares of each element, sorted in ascending order.\n\n    Example:\n    Input:\n    nums = [3, 1, 4, 2, 5]\n\n    Output:\n    [1, 4, 9, 16, 25]\n    \"\"\"\n\n    def merge_sort(nums: List[int]) -> List[int]:\n        if len(nums) <= 1:\n            return nums\n\n        mid = len(nums) // 2\n        left = merge_sort(nums[:mid])\n        right = merge_sort(nums[mid:])\n\n        return merge(left, right)\n\n    def merge(left: List[int], right: List[int]) -> List[int]:\n        merged = []\n        i, j = 0, 0\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n\n        return merged\n\n    squared_nums = [num ** 2 for num in nums]\n    return merge_sort(squared_nums)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [3, 1, 4, 2, 5]\n\nassert f(g()) == [1, 4, 9, 16, 25]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 343, "target_skills": [1, 1, 1, 0, 0, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with the squares of each element, sorted in ascending order.\n\n    Example:\n    Input:\n    nums = [3, 1, 4, 2, 5]\n\n    Output:\n    [1, 4, 9, 16, 25]\n    \"\"\"\n\n    def merge_sort(nums: List[int]) -> List[int]:\n        if len(nums) <= 1:\n            return nums\n\n        mid = len(nums) // 2\n        left = merge_sort(nums[:mid])\n        right = merge_sort(nums[mid:])\n\n        return merge(left, right)\n\n    def merge(left: List[int], right: List[int]) -> List[int]:\n        merged = []\n        i, j = 0, 0\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n\n        return merged\n\n    squared_nums = [num ** 2 for num in nums]\n    return merge_sort(squared_nums)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [3, 1, 4, 2, 5]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two integers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    12\n\n    Explanation:\n    The maximum product of two integers in the list is 3*4 = 12.\n    \"\"\"\n    nums.sort()\n    return nums[-2] * nums[-1]\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for the function f.\n    \"\"\"\n    return [1, 2, 3, 4]\n\nassert f(g()) == 12\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 343, "target_skills": [1, 1, 1, 1, 1, 1, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two integers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    12\n\n    Explanation:\n    The maximum product of two integers in the list is 3*4 = 12.\n    \"\"\"\n    nums.sort()\n    return nums[-2] * nums[-1]", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for the function f.\n    \"\"\"\n    return [1, 2, 3, 4]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representing a directed graph, find the length of the longest path in the graph.\n\n    Example:\n    graph = [[0, 1, 1, 0],\n             [0, 0, 1, 0],\n             [0, 0, 0, 1],\n             [0, 0, 0, 0]]\n\n    Output:\n    3\n\n    Explanation:\n    The longest path in the graph is 0 -> 2 -> 3, with a length of 3.\n    \"\"\"\n    def dfs(node: int, visited: List[bool], graph: List[List[int]]) -> int:\n        visited[node] = True\n        max_len = 1\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                max_len = max(max_len, 1 + dfs(neighbor, visited, graph))\n        visited[node] = False\n        return max_len\n\n    n = len(graph)\n    visited = [False] * n\n    max_len = 0\n    for node in range(n):\n        max_len = max(max_len, dfs(node, visited, graph))\n    return max_len\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate an adjacency matrix representing a directed graph for the function f.\n    \"\"\"\n    return [[0, 1, 1, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1],\n            [0, 0, 0, 0]]\n\nassert f(g()) == 3\n\n", "emb": null, "idx_generation": 343, "target_skills": [1, 0, 0, 1, 1, 1, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representing a directed graph, find the length of the longest path in the graph.\n\n    Example:\n    graph = [[0, 1, 1, 0],\n             [0, 0, 1, 0],\n             [0, 0, 0, 1],\n             [0, 0, 0, 0]]\n\n    Output:\n    3\n\n    Explanation:\n    The longest path in the graph is 0 -> 2 -> 3, with a length of 3.\n    \"\"\"\n    def dfs(node: int, visited: List[bool], graph: List[List[int]]) -> int:\n        visited[node] = True\n        max_len = 1\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                max_len = max(max_len, 1 + dfs(neighbor, visited, graph))\n        visited[node] = False\n        return max_len\n\n    n = len(graph)\n    visited = [False] * n\n    max_len = 0\n    for node in range(n):\n        max_len = max(max_len, dfs(node, visited, graph))\n    return max_len", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate an adjacency matrix representing a directed graph for the function f.\n    \"\"\"\n    return [[0, 1, 1, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1],\n            [0, 0, 0, 0]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers n and m, compute the value of n choose m (nCm), also known as the binomial coefficient.\n\n    Example:\n    n = 5\n    m = 2\n\n    Output:\n    10\n\n    Explanation:\n    The binomial coefficient 5C2 is equal to 5! / (2! * (5-2)!) = 10.\n    \"\"\"\n    def factorial(n: int) -> int:\n        if n == 0 or n == 1:\n            return 1\n        return n * factorial(n-1)\n\n    return factorial(n) // (factorial(m) * factorial(n-m))\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate two integers for the function f.\n    \"\"\"\n    return [5, 2]\n\nassert f(*g()) == 10\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 343, "target_skills": [1, 1, 0, 0, 1, 0, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers n and m, compute the value of n choose m (nCm), also known as the binomial coefficient.\n\n    Example:\n    n = 5\n    m = 2\n\n    Output:\n    10\n\n    Explanation:\n    The binomial coefficient 5C2 is equal to 5! / (2! * (5-2)!) = 10.\n    \"\"\"\n    def factorial(n: int) -> int:\n        if n == 0 or n == 1:\n            return 1\n        return n * factorial(n-1)\n\n    return factorial(n) // (factorial(m) * factorial(n-m))", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate two integers for the function f.\n    \"\"\"\n    return [5, 2]", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the second largest element in the array.\n    \n    Example:\n    arr = [5, 2, 8, 1, 3]\n    \n    Output:\n    5\n    \"\"\"\n    arr.sort()\n    return arr[-2]\n\ndef g() -> List[int]:\n    return [5, 2, 8, 1, 3]\n\nassert f(g()) == 5\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 343, "target_skills": [1, 0, 1, 0, 0, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the second largest element in the array.\n    \n    Example:\n    arr = [5, 2, 8, 1, 3]\n    \n    Output:\n    5\n    \"\"\"\n    arr.sort()\n    return arr[-2]", "solution_func": "def g() -> List[int]:\n    return [5, 2, 8, 1, 3]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> bool:\n    \"\"\"\n    Given a list of words, check if all the words have the same pattern of repeated characters.\n    A pattern of repeated characters is defined as a sequence of characters that repeats itself.\n    \n    Example:\n    words = [\"abb\", \"ccc\", \"ddd\"]\n    \n    Output:\n    True\n    \"\"\"\n    def get_pattern(word: str) -> str:\n        pattern = \"\"\n        count = 0\n        for i in range(len(word)):\n            if i > 0 and word[i] == word[i-1]:\n                count += 1\n            else:\n                pattern += str(count)\n                count = 1\n        pattern += str(count)\n        return pattern\n    \n    patterns = set()\n    for word in words:\n        pattern = get_pattern(word)\n        patterns.add(pattern)\n    \n    return len(patterns) == 1\n\ndef g() -> List[str]:\n    return [\"abb\", \"ccc\", \"ddd\"]\n\nassert f(g()) == True\n\n", "emb": null, "idx_generation": 343, "target_skills": [0, 0, 0, 1, 0, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> bool:\n    \"\"\"\n    Given a list of words, check if all the words have the same pattern of repeated characters.\n    A pattern of repeated characters is defined as a sequence of characters that repeats itself.\n    \n    Example:\n    words = [\"abb\", \"ccc\", \"ddd\"]\n    \n    Output:\n    True\n    \"\"\"\n    def get_pattern(word: str) -> str:\n        pattern = \"\"\n        count = 0\n        for i in range(len(word)):\n            if i > 0 and word[i] == word[i-1]:\n                count += 1\n            else:\n                pattern += str(count)\n                count = 1\n        pattern += str(count)\n        return pattern\n    \n    patterns = set()\n    for word in words:\n        pattern = get_pattern(word)\n        patterns.add(pattern)\n    \n    return len(patterns) == 1", "solution_func": "def g() -> List[str]:\n    return [\"abb\", \"ccc\", \"ddd\"]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers where each cell represents the number of gold coins in that cell,\n    find the maximum number of gold coins that can be collected starting from the top-left cell.\n    You can only move down or right.\n    \n    Example:\n    grid = [[1, 3, 1], [2, 1, 2], [4, 2, 1]]\n    \n    Output:\n    9\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g(grid = [[1, 3, 1], [2, 1, 2], [4, 2, 1]]):\n    return grid\n\nassert f(g()) == 9\n\n", "emb": null, "idx_generation": 343, "target_skills": [0, 0, 1, 0, 0, 0, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers where each cell represents the number of gold coins in that cell,\n    find the maximum number of gold coins that can be collected starting from the top-left cell.\n    You can only move down or right.\n    \n    Example:\n    grid = [[1, 3, 1], [2, 1, 2], [4, 2, 1]]\n    \n    Output:\n    9\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]", "solution_func": "def g(grid = [[1, 3, 1], [2, 1, 2], [4, 2, 1]]):\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if the list is palindrome or not.\n    \"\"\"\n    return arr == arr[::-1]\n\ndef g():\n    arr = [1, 2, 3, 4, 3, 2, 1]\n    return arr\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 343, "target_skills": [1, 1, 0, 0, 0, 0, 0, 1, 0, 1], "problem_func": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if the list is palindrome or not.\n    \"\"\"\n    return arr == arr[::-1]", "solution_func": "def g():\n    arr = [1, 2, 3, 4, 3, 2, 1]\n    return arr", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target integer, return True if there exists a pair of integers in the list whose sum is equal to the target, and False otherwise.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    return [1, 2, 3, 4, 5], 9\n\nassert f(*g()) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 344, "target_skills": [1, 0, 1, 0, 1, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target integer, return True if there exists a pair of integers in the list whose sum is equal to the target, and False otherwise.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False", "solution_func": "def g() -> Tuple[List[int], int]:\n    return [1, 2, 3, 4, 5], 9", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, return the list sorted in lexicographical order.\n\n    Example:\n    words = [\"banana\", \"apple\", \"cherry\", \"date\"]\n    \n    Output:\n    [\"apple\", \"banana\", \"cherry\", \"date\"]\n\n    Hint: Use the sorted() function with the appropriate key parameter.\n    \"\"\"\n    return sorted(words)\n\ndef g() -> List[str]:\n    return [\"banana\", \"apple\", \"cherry\", \"date\"]\n\nassert f(g()) == [\"apple\", \"banana\", \"cherry\", \"date\"]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 344, "target_skills": [0, 0, 1, 0, 1, 1, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, return the list sorted in lexicographical order.\n\n    Example:\n    words = [\"banana\", \"apple\", \"cherry\", \"date\"]\n    \n    Output:\n    [\"apple\", \"banana\", \"cherry\", \"date\"]\n\n    Hint: Use the sorted() function with the appropriate key parameter.\n    \"\"\"\n    return sorted(words)", "solution_func": "def g() -> List[str]:\n    return [\"banana\", \"apple\", \"cherry\", \"date\"]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, rotate the matrix 90 degrees clockwise.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    \n    Output:\n    [[7, 4, 1],\n     [8, 5, 2],\n     [9, 6, 3]]\n\n    Hint: Use the zip() function to transpose the matrix, and then reverse each row.\n    \"\"\"\n    return [list(row)[::-1] for row in zip(*matrix)]\n\ndef g() -> List[List[int]]:\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 344, "target_skills": [1, 1, 0, 1, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, rotate the matrix 90 degrees clockwise.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    \n    Output:\n    [[7, 4, 1],\n     [8, 5, 2],\n     [9, 6, 3]]\n\n    Hint: Use the zip() function to transpose the matrix, and then reverse each row.\n    \"\"\"\n    return [list(row)[::-1] for row in zip(*matrix)]", "solution_func": "def g() -> List[List[int]]:\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix, rotate it 90 degrees clockwise.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n\n    Output:\n    [[7, 4, 1],\n     [8, 5, 2],\n     [9, 6, 3]]\n    \"\"\"\n\n    def rotate(matrix):\n        n = len(matrix)\n        for i in range(n // 2):\n            for j in range(i, n - i - 1):\n                temp = matrix[i][j]\n                matrix[i][j] = matrix[n - j - 1][i]\n                matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n                matrix[j][n - i - 1] = temp\n        return matrix\n\n    return rotate(matrix)\n\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n", "emb": null, "idx_generation": 344, "target_skills": [0, 0, 0, 1, 0, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix, rotate it 90 degrees clockwise.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n\n    Output:\n    [[7, 4, 1],\n     [8, 5, 2],\n     [9, 6, 3]]\n    \"\"\"\n\n    def rotate(matrix):\n        n = len(matrix)\n        for i in range(n // 2):\n            for j in range(i, n - i - 1):\n                temp = matrix[i][j]\n                matrix[i][j] = matrix[n - j - 1][i]\n                matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n                matrix[j][n - i - 1] = temp\n        return matrix\n\n    return rotate(matrix)", "solution_func": "def g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> List[str]:\n    \"\"\"\n    Generate all possible valid combinations of n pairs of parentheses.\n\n    Example:\n    n = 3\n\n    Output:\n    [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\n    \"\"\"\n\n    def generate_parentheses(n):\n        result = []\n        generate(\"\", n, n, result)\n        return result\n\n    def generate(current, left, right, result):\n        if left == 0 and right == 0:\n            result.append(current)\n            return\n\n        if left > 0:\n            generate(current + \"(\", left - 1, right, result)\n        if right > left:\n            generate(current + \")\", left, right - 1, result)\n\n    return generate_parentheses(n)\n\ndef g(n=3):\n    return n\n\nassert f(g()) == [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 344, "target_skills": [0, 1, 1, 0, 1, 0, 1, 0, 1, 0], "problem_func": "from typing import*\ndef f(n: int) -> List[str]:\n    \"\"\"\n    Generate all possible valid combinations of n pairs of parentheses.\n\n    Example:\n    n = 3\n\n    Output:\n    [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\n    \"\"\"\n\n    def generate_parentheses(n):\n        result = []\n        generate(\"\", n, n, result)\n        return result\n\n    def generate(current, left, right, result):\n        if left == 0 and right == 0:\n            result.append(current)\n            return\n\n        if left > 0:\n            generate(current + \"(\", left - 1, right, result)\n        if right > left:\n            generate(current + \")\", left, right - 1, result)\n\n    return generate_parentheses(n)", "solution_func": "def g(n=3):\n    return n", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a set of distinct integers, nums, return all possible subsets (the power set).\n\n    Example:\n    nums = [1, 2, 3]\n\n    Output:\n    [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]\n    \"\"\"\n\n    def subsets(nums):\n        result = []\n        backtrack(nums, [], result, 0)\n        return result\n\n    def backtrack(nums, current, result, start):\n        result.append(current[:])\n\n        for i in range(start, len(nums)):\n            current.append(nums[i])\n            backtrack(nums, current, result, i + 1)\n            current.pop()\n\n    return subsets(nums)\n\ndef g(nums=[1, 2, 3]):\n    return nums\n\nassert f(g()) == [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]\n", "emb": null, "idx_generation": 344, "target_skills": [0, 0, 1, 0, 1, 0, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a set of distinct integers, nums, return all possible subsets (the power set).\n\n    Example:\n    nums = [1, 2, 3]\n\n    Output:\n    [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]\n    \"\"\"\n\n    def subsets(nums):\n        result = []\n        backtrack(nums, [], result, 0)\n        return result\n\n    def backtrack(nums, current, result, start):\n        result.append(current[:])\n\n        for i in range(start, len(nums)):\n            current.append(nums[i])\n            backtrack(nums, current, result, i + 1)\n            current.pop()\n\n    return subsets(nums)", "solution_func": "def g(nums=[1, 2, 3]):\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "import math\nfrom typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all positive integers less than n that are divisible by 3 or 5.\n\n    Example:\n    n = 10\n\n    Output:\n    23\n\n    Explanation:\n    The positive integers less than 10 that are divisible by 3 or 5 are: 3, 5, 6, and 9. Their sum is 23.\n\n    Hint: Use mathematical foundations, sorting, and searching to find the numbers divisible by 3 or 5 and calculate their sum.\n    \"\"\"\n    numbers = [x for x in range(1, n) if x % 3 == 0 or x % 5 == 0]\n    return sum(numbers)\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    n = 10\n    return n\n\nassert f(g()) == 23\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 344, "target_skills": [1, 1, 1, 0, 0, 0, 0, 0, 0, 1], "problem_func": "import math\nfrom typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all positive integers less than n that are divisible by 3 or 5.\n\n    Example:\n    n = 10\n\n    Output:\n    23\n\n    Explanation:\n    The positive integers less than 10 that are divisible by 3 or 5 are: 3, 5, 6, and 9. Their sum is 23.\n\n    Hint: Use mathematical foundations, sorting, and searching to find the numbers divisible by 3 or 5 and calculate their sum.\n    \"\"\"\n    numbers = [x for x in range(1, n) if x % 3 == 0 or x % 5 == 0]\n    return sum(numbers)", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    n = 10\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str, x: int) -> str:\n    \"\"\"\n    Given a string s and an integer x, perform the following operations:\n    - Convert the string s to a binary representation.\n    - Perform a bitwise XOR operation between the binary representation and the integer x.\n    - Convert the resulting binary representation back to a string.\n\n    Example:\n    s = \"Hello\"\n    x = 10\n\n    Output:\n    \"K\\\\x06\\\\x07\\\\x07\\\\x1a\"\n\n    Explanation:\n    The binary representation of \"Hello\" is \"01001000 01100101 01101100 01101100 01101111\".\n    Performing a bitwise XOR operation between the binary representation and the integer 10 results in \"00001010 00001111 00001100 00001100 00001101\".\n    Converting the resulting binary representation back to a string gives the output \"K\\\\x06\\\\x07\\\\x07\\\\x1a\".\n\n    Hint: Use bit manipulation, string manipulation, and bitwise XOR operation to perform the required operations.\n    \"\"\"\n    binary = ''.join(format(ord(c), '08b') for c in s)\n    xor_result = int(binary, 2) ^ x\n    result = ''.join(chr(int(xor_result[i:i+8], 2)) for i in range(0, len(xor_result), 8))\n    return result\n\ndef g() -> Tuple[str, int]:\n    \"\"\"\n    Generate a string s and an integer x.\n    \"\"\"\n    s = \"Hello\"\n    x = 10\n    return s, x\n\nassert f(*g()) == \"K\\x06\\x07\\x07\\x1a\"\n", "emb": null, "idx_generation": 344, "target_skills": [0, 0, 1, 0, 1, 0, 1, 1, 1, 0], "problem_func": "from typing import*\ndef f(s: str, x: int) -> str:\n    \"\"\"\n    Given a string s and an integer x, perform the following operations:\n    - Convert the string s to a binary representation.\n    - Perform a bitwise XOR operation between the binary representation and the integer x.\n    - Convert the resulting binary representation back to a string.\n\n    Example:\n    s = \"Hello\"\n    x = 10\n\n    Output:\n    \"K\\\\x06\\\\x07\\\\x07\\\\x1a\"\n\n    Explanation:\n    The binary representation of \"Hello\" is \"01001000 01100101 01101100 01101100 01101111\".\n    Performing a bitwise XOR operation between the binary representation and the integer 10 results in \"00001010 00001111 00001100 00001100 00001101\".\n    Converting the resulting binary representation back to a string gives the output \"K\\\\x06\\\\x07\\\\x07\\\\x1a\".\n\n    Hint: Use bit manipulation, string manipulation, and bitwise XOR operation to perform the required operations.\n    \"\"\"\n    binary = ''.join(format(ord(c), '08b') for c in s)\n    xor_result = int(binary, 2) ^ x\n    result = ''.join(chr(int(xor_result[i:i+8], 2)) for i in range(0, len(xor_result), 8))\n    return result", "solution_func": "def g() -> Tuple[str, int]:\n    \"\"\"\n    Generate a string s and an integer x.\n    \"\"\"\n    s = \"Hello\"\n    x = 10\n    return s, x", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid represented as a list of lists of integers, find the minimum number of steps required to reach the bottom-right cell from the top-left cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum number of steps required to reach the bottom-right cell from the top-left cell is 7: 1 -> 3 -> 1 -> 1 -> 1 -> 2 -> 1.\n\n    Hint: Use sorting and searching, and solve the problem as a grid problem by finding the shortest path from the top-left cell to the bottom-right cell.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid represented as a list of lists of integers.\n    \"\"\"\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 344, "target_skills": [0, 1, 0, 0, 1, 1, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid represented as a list of lists of integers, find the minimum number of steps required to reach the bottom-right cell from the top-left cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum number of steps required to reach the bottom-right cell from the top-left cell is 7: 1 -> 3 -> 1 -> 1 -> 1 -> 2 -> 1.\n\n    Hint: Use sorting and searching, and solve the problem as a grid problem by finding the shortest path from the top-left cell to the bottom-right cell.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid represented as a list of lists of integers.\n    \"\"\"\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a perfect square.\n\n    Example:\n    n = 16\n\n    Output:\n    True\n\n    Explanation:\n    16 is a perfect square because it can be expressed as 4^2.\n    \"\"\"\n\n    def is_perfect_square(n):\n        return int(n ** 0.5) ** 2 == n\n\n    return is_perfect_square(n)\n\ndef g():\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    return 16\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 344, "target_skills": [1, 1, 0, 1, 0, 1, 0, 0, 0, 1], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a perfect square.\n\n    Example:\n    n = 16\n\n    Output:\n    True\n\n    Explanation:\n    16 is a perfect square because it can be expressed as 4^2.\n    \"\"\"\n\n    def is_perfect_square(n):\n        return int(n ** 0.5) ** 2 == n\n\n    return is_perfect_square(n)", "solution_func": "def g():\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    return 16", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nimport heapq\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return the k smallest elements in ascending order.\n\n    Example:\n    nums = [4, 2, 7, 1, 5]\n    k = 3\n\n    The k smallest elements are [1, 2, 4], so the output should be [1, 2, 4].\n    \"\"\"\n    heap = []\n    for num in nums:\n        heapq.heappush(heap, num)\n    \n    result = []\n    for _ in range(k):\n        result.append(heapq.heappop(heap))\n    \n    return result\n\ndef g():\n    nums = [4, 2, 7, 1, 5]\n    k = 3\n    return nums, k\n\nassert f(*g()) == [1, 2, 4]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 345, "target_skills": [1, 1, 1, 0, 0, 0, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import *\nimport heapq\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return the k smallest elements in ascending order.\n\n    Example:\n    nums = [4, 2, 7, 1, 5]\n    k = 3\n\n    The k smallest elements are [1, 2, 4], so the output should be [1, 2, 4].\n    \"\"\"\n    heap = []\n    for num in nums:\n        heapq.heappush(heap, num)\n    \n    result = []\n    for _ in range(k):\n        result.append(heapq.heappop(heap))\n    \n    return result", "solution_func": "def g():\n    nums = [4, 2, 7, 1, 5]\n    k = 3\n    return nums, k", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import *\nimport math\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the sum of the absolute differences between each element and the median of the list.\n\n    Example:\n    nums = [1, 4, 6, 8, 2]\n\n    The median is 4, and the absolute differences are |1-4| + |4-4| + |6-4| + |8-4| + |2-4| = 14.\n    So, the output should be 14.\n    \"\"\"\n    nums.sort()\n    median = nums[math.ceil(len(nums) / 2) - 1]\n    \n    result = 0\n    for num in nums:\n        result += abs(num - median)\n    \n    return result\n\ndef g():\n    nums = [1, 4, 6, 8, 2]\n    return nums\n\nassert f(*g()) == 14\n", "emb": null, "idx_generation": 345, "target_skills": [1, 0, 0, 1, 1, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import *\nimport math\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the sum of the absolute differences between each element and the median of the list.\n\n    Example:\n    nums = [1, 4, 6, 8, 2]\n\n    The median is 4, and the absolute differences are |1-4| + |4-4| + |6-4| + |8-4| + |2-4| = 14.\n    So, the output should be 14.\n    \"\"\"\n    nums.sort()\n    median = nums[math.ceil(len(nums) / 2) - 1]\n    \n    result = 0\n    for num in nums:\n        result += abs(num - median)\n    \n    return result", "solution_func": "def g():\n    nums = [1, 4, 6, 8, 2]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import *\nimport collections\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest subarray with an equal number of 0s and 1s.\n\n    Example:\n    nums = [0, 1, 0, 1, 1, 0, 0]\n\n    The longest subarray with an equal number of 0s and 1s is [0, 1, 0, 1, 1, 0], which has a length of 6.\n    So, the output should be 6.\n    \"\"\"\n    count = 0\n    max_length = 0\n    count_dict = collections.defaultdict(int)\n    count_dict[0] = -1\n    \n    for i, num in enumerate(nums):\n        if num == 0:\n            count -= 1\n        else:\n            count += 1\n        \n        if count in count_dict:\n            max_length = max(max_length, i - count_dict[count])\n        else:\n            count_dict[count] = i\n    \n    return max_length\n\ndef g():\n    nums = [0, 1, 0, 1, 1, 0, 0]\n    return nums\n\nassert f(*g()) == 6\n", "emb": null, "idx_generation": 345, "target_skills": [0, 1, 0, 0, 1, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import *\nimport collections\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest subarray with an equal number of 0s and 1s.\n\n    Example:\n    nums = [0, 1, 0, 1, 1, 0, 0]\n\n    The longest subarray with an equal number of 0s and 1s is [0, 1, 0, 1, 1, 0], which has a length of 6.\n    So, the output should be 6.\n    \"\"\"\n    count = 0\n    max_length = 0\n    count_dict = collections.defaultdict(int)\n    count_dict[0] = -1\n    \n    for i, num in enumerate(nums):\n        if num == 0:\n            count -= 1\n        else:\n            count += 1\n        \n        if count in count_dict:\n            max_length = max(max_length, i - count_dict[count])\n        else:\n            count_dict[count] = i\n    \n    return max_length", "solution_func": "def g():\n    nums = [0, 1, 0, 1, 1, 0, 0]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(arr: List[int], target: int) -> Tuple[int, int]:\n    \"\"\"\n    Given an array of integers and a target number, find two numbers in the array that add up to the target.\n    Return the indices of the two numbers as a tuple.\n    \"\"\"\n    num_dict = {}\n    \n    for i, num in enumerate(arr):\n        complement = target - num\n        if complement in num_dict:\n            return (num_dict[complement], i)\n        num_dict[num] = i\n    \n    return ()\n\ndef g(arr=[2, 7, 11, 15], target=9):\n    return (arr, target)\n\nassert f(*g()) == (0, 1)\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 345, "target_skills": [0, 0, 1, 0, 0, 0, 0, 1, 0, 1], "problem_func": "from typing import*\n\ndef f(arr: List[int], target: int) -> Tuple[int, int]:\n    \"\"\"\n    Given an array of integers and a target number, find two numbers in the array that add up to the target.\n    Return the indices of the two numbers as a tuple.\n    \"\"\"\n    num_dict = {}\n    \n    for i, num in enumerate(arr):\n        complement = target - num\n        if complement in num_dict:\n            return (num_dict[complement], i)\n        num_dict[num] = i\n    \n    return ()", "solution_func": "def g(arr=[2, 7, 11, 15], target=9):\n    return (arr, target)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(num: int) -> int:\n    \"\"\"\n    Given a positive integer, determine the number of bits required to represent it in binary form.\n    \"\"\"\n    binary_str = bin(num)[2:]\n    return len(binary_str)\n\ndef g(num=10):\n    return num\n\nassert f(g()) == 4\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 345, "target_skills": [1, 1, 1, 1, 0, 0, 1, 0, 0, 0], "problem_func": "from typing import*\n\ndef f(num: int) -> int:\n    \"\"\"\n    Given a positive integer, determine the number of bits required to represent it in binary form.\n    \"\"\"\n    binary_str = bin(num)[2:]\n    return len(binary_str)", "solution_func": "def g(num=10):\n    return num", "map_ix": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string containing only parentheses, brackets, and curly braces, \n    determine if the input string is valid or not. The string is considered valid if:\n    1. Open brackets must be closed by the same type of brackets.\n    2. Open brackets must be closed in the correct order.\n    \n    Return True if the string is valid, False otherwise.\n    \"\"\"\n    stack = []\n    brackets = {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\n    \n    for char in s:\n        if char in brackets:\n            stack.append(char)\n        elif char in brackets.values():\n            if not stack:\n                return False\n            if brackets[stack.pop()] != char:\n                return False\n    \n    return not stack\n\ndef g(s=\"([]){}\"):\n    return s\n\nassert f(g()) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 345, "target_skills": [0, 0, 1, 1, 1, 0, 1, 0, 1, 0], "problem_func": "from typing import*\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string containing only parentheses, brackets, and curly braces, \n    determine if the input string is valid or not. The string is considered valid if:\n    1. Open brackets must be closed by the same type of brackets.\n    2. Open brackets must be closed in the correct order.\n    \n    Return True if the string is valid, False otherwise.\n    \"\"\"\n    stack = []\n    brackets = {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\n    \n    for char in s:\n        if char in brackets:\n            stack.append(char)\n        elif char in brackets.values():\n            if not stack:\n                return False\n            if brackets[stack.pop()] != char:\n                return False\n    \n    return not stack", "solution_func": "def g(s=\"([]){}\"):\n    return s", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of 0s and 1s, determine if it is possible to reach the bottom-right cell from the top-left cell\n    by only moving downwards or rightwards. The cells containing 0 represent obstacles that cannot be crossed.\n\n    Sample input:\n    matrix = [\n        [1, 0, 0],\n        [1, 1, 1],\n        [0, 0, 1]\n    ]\n\n    Sample output:\n    True\n\n    Explanation: It is possible to reach the bottom-right cell (matrix[2][2]) by moving downwards and rightwards.\n    \"\"\"\n    rows = len(matrix)\n    if rows == 0:\n        return False\n    cols = len(matrix[0])\n    if cols == 0:\n        return False\n\n    dp = [[False] * cols for _ in range(rows)]\n    dp[0][0] = True\n\n    for i in range(rows):\n        for j in range(cols):\n            if matrix[i][j] == 1:\n                if i > 0:\n                    dp[i][j] |= dp[i-1][j]\n                if j > 0:\n                    dp[i][j] |= dp[i][j-1]\n\n    return dp[rows-1][cols-1]\n\ndef g(matrix=[[1, 0, 0], [1, 1, 1], [0, 0, 1]]):\n    return matrix\n\nassert f(g()) == True\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 345, "target_skills": [0, 0, 0, 1, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of 0s and 1s, determine if it is possible to reach the bottom-right cell from the top-left cell\n    by only moving downwards or rightwards. The cells containing 0 represent obstacles that cannot be crossed.\n\n    Sample input:\n    matrix = [\n        [1, 0, 0],\n        [1, 1, 1],\n        [0, 0, 1]\n    ]\n\n    Sample output:\n    True\n\n    Explanation: It is possible to reach the bottom-right cell (matrix[2][2]) by moving downwards and rightwards.\n    \"\"\"\n    rows = len(matrix)\n    if rows == 0:\n        return False\n    cols = len(matrix[0])\n    if cols == 0:\n        return False\n\n    dp = [[False] * cols for _ in range(rows)]\n    dp[0][0] = True\n\n    for i in range(rows):\n        for j in range(cols):\n            if matrix[i][j] == 1:\n                if i > 0:\n                    dp[i][j] |= dp[i-1][j]\n                if j > 0:\n                    dp[i][j] |= dp[i][j-1]\n\n    return dp[rows-1][cols-1]", "solution_func": "def g(matrix=[[1, 0, 0], [1, 1, 1], [0, 0, 1]]):\n    return matrix", "map_ix": [1, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is possible to represent it as a sum of distinct powers of 2.\n\n    Sample input:\n    n = 10\n\n    Sample output:\n    True\n\n    Explanation: 10 can be represented as 2^1 + 2^3 = 2 + 8 = 10.\n    \"\"\"\n    powers = set()\n    for i in range(32):\n        powers.add(1 << i)\n    return any(n >= p and (n - p) in powers for p in powers)\n\ndef g(n=10):\n    return n\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 345, "target_skills": [0, 0, 0, 1, 1, 1, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is possible to represent it as a sum of distinct powers of 2.\n\n    Sample input:\n    n = 10\n\n    Sample output:\n    True\n\n    Explanation: 10 can be represented as 2^1 + 2^3 = 2 + 8 = 10.\n    \"\"\"\n    powers = set()\n    for i in range(32):\n        powers.add(1 << i)\n    return any(n >= p and (n - p) in powers for p in powers)", "solution_func": "def g(n=10):\n    return n", "map_ix": [0, 0, 0, 1, 1, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of integers, determine if it is possible to reach the bottom-right cell from the top-left cell\n    by only moving downwards, rightwards, or diagonally.\n    The cells containing 0 represent obstacles that cannot be crossed.\n\n    Sample input:\n    grid = [\n        [1, 0, 0],\n        [1, 1, 1],\n        [0, 0, 1]\n    ]\n\n    Sample output:\n    True\n\n    Explanation: It is possible to reach the bottom-right cell (grid[2][2]) by moving downwards, rightwards, and diagonally.\n    \"\"\"\n    rows = len(grid)\n    if rows == 0:\n        return False\n    cols = len(grid[0])\n    if cols == 0:\n        return False\n\n    dp = [[False] * cols for _ in range(rows)]\n    dp[0][0] = True\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                if i > 0:\n                    dp[i][j] |= dp[i-1][j]\n                if j > 0:\n                    dp[i][j] |= dp[i][j-1]\n                if i > 0 and j > 0:\n                    dp[i][j] |= dp[i-1][j-1]\n\n    return dp[rows-1][cols-1]\n\ndef g(grid=[[1, 0, 0], [1, 1, 1], [0, 0, 1]]):\n    return grid\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 345, "target_skills": [0, 1, 1, 0, 0, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of integers, determine if it is possible to reach the bottom-right cell from the top-left cell\n    by only moving downwards, rightwards, or diagonally.\n    The cells containing 0 represent obstacles that cannot be crossed.\n\n    Sample input:\n    grid = [\n        [1, 0, 0],\n        [1, 1, 1],\n        [0, 0, 1]\n    ]\n\n    Sample output:\n    True\n\n    Explanation: It is possible to reach the bottom-right cell (grid[2][2]) by moving downwards, rightwards, and diagonally.\n    \"\"\"\n    rows = len(grid)\n    if rows == 0:\n        return False\n    cols = len(grid[0])\n    if cols == 0:\n        return False\n\n    dp = [[False] * cols for _ in range(rows)]\n    dp[0][0] = True\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                if i > 0:\n                    dp[i][j] |= dp[i-1][j]\n                if j > 0:\n                    dp[i][j] |= dp[i][j-1]\n                if i > 0 and j > 0:\n                    dp[i][j] |= dp[i-1][j-1]\n\n    return dp[rows-1][cols-1]", "solution_func": "def g(grid=[[1, 0, 0], [1, 1, 1], [0, 0, 1]]):\n    return grid", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[List[int]]) -> int:\n    \"\"\"\n    Given a binary tree represented as a list of lists, find the sum of all the elements in the tree.\n\n    Sample input:\n    arr = [[1], [2, 3], [4, 5, 6]]\n\n    Sample output:\n    21\n    \"\"\"\n    def dfs(node: int) -> int:\n        if node < len(arr):\n            return arr[node][0] + dfs(node*2 + 1) + dfs(node*2 + 2)\n        return 0\n    \n    return dfs(0)\n\ndef g():\n    return [[1], [2, 3], [4, 5, 6]]\n\nassert f(g()) == 21\n", "emb": null, "idx_generation": 345, "target_skills": [0, 0, 0, 0, 1, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[List[int]]) -> int:\n    \"\"\"\n    Given a binary tree represented as a list of lists, find the sum of all the elements in the tree.\n\n    Sample input:\n    arr = [[1], [2, 3], [4, 5, 6]]\n\n    Sample output:\n    21\n    \"\"\"\n    def dfs(node: int) -> int:\n        if node < len(arr):\n            return arr[node][0] + dfs(node*2 + 1) + dfs(node*2 + 2)\n        return 0\n    \n    return dfs(0)", "solution_func": "def g():\n    return [[1], [2, 3], [4, 5, 6]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> int:\n    \"\"\"\n    Given a binary tree, find the maximum path sum.\n    The path may start and end at any node in the tree.\n    \"\"\"\n    def maxPathSumHelper(node: TreeNode) -> int:\n        if not node:\n            return 0\n        \n        # Calculate the maximum path sum for the left and right subtrees\n        left_sum = maxPathSumHelper(node.left)\n        right_sum = maxPathSumHelper(node.right)\n        \n        # Calculate the maximum sum that includes the current node\n        max_sum = max(node.val, node.val + left_sum, node.val + right_sum)\n        \n        # Update the maximum path sum if a larger sum is found\n        f.max_sum = max(f.max_sum, max_sum, node.val + left_sum + right_sum)\n        \n        # Return the maximum sum that includes the current node\n        return max_sum\n    \n    # Initialize the maximum path sum to negative infinity\n    f.max_sum = float('-inf')\n    \n    # Call the helper function to calculate the maximum path sum\n    maxPathSumHelper(root)\n    \n    # Return the maximum path sum\n    return f.max_sum\n\ndef g():\n    \"\"\"\n    Create a binary tree for testing.\n    \"\"\"\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    \n    return root\n\nassert f(g()) == 18\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 346, "target_skills": [0, 0, 1, 0, 1, 0, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> int:\n    \"\"\"\n    Given a binary tree, find the maximum path sum.\n    The path may start and end at any node in the tree.\n    \"\"\"\n    def maxPathSumHelper(node: TreeNode) -> int:\n        if not node:\n            return 0\n        \n        # Calculate the maximum path sum for the left and right subtrees\n        left_sum = maxPathSumHelper(node.left)\n        right_sum = maxPathSumHelper(node.right)\n        \n        # Calculate the maximum sum that includes the current node\n        max_sum = max(node.val, node.val + left_sum, node.val + right_sum)\n        \n        # Update the maximum path sum if a larger sum is found\n        f.max_sum = max(f.max_sum, max_sum, node.val + left_sum + right_sum)\n        \n        # Return the maximum sum that includes the current node\n        return max_sum\n    \n    # Initialize the maximum path sum to negative infinity\n    f.max_sum = float('-inf')\n    \n    # Call the helper function to calculate the maximum path sum\n    maxPathSumHelper(root)\n    \n    # Return the maximum path sum\n    return f.max_sum", "solution_func": "def g():\n    \"\"\"\n    Create a binary tree for testing.\n    \"\"\"\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    \n    return root", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR of any two elements.\n    \"\"\"\n    max_xor = 0\n    \n    # Iterate through each bit position from left to right\n    for i in range(31, -1, -1):\n        max_xor <<= 1\n        prefixes = set()\n        \n        # Calculate the prefix of each number at the current bit position\n        for num in nums:\n            prefixes.add(num >> i)\n        \n        # Try to find a pair of numbers with different prefixes\n        for prefix in prefixes:\n            if (max_xor | 1) ^ prefix in prefixes:\n                max_xor |= 1\n                break\n    \n    return max_xor\n\ndef g():\n    \"\"\"\n    Generate a list of integers for testing.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 346, "target_skills": [0, 0, 0, 0, 1, 1, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR of any two elements.\n    \"\"\"\n    max_xor = 0\n    \n    # Iterate through each bit position from left to right\n    for i in range(31, -1, -1):\n        max_xor <<= 1\n        prefixes = set()\n        \n        # Calculate the prefix of each number at the current bit position\n        for num in nums:\n            prefixes.add(num >> i)\n        \n        # Try to find a pair of numbers with different prefixes\n        for prefix in prefixes:\n            if (max_xor | 1) ^ prefix in prefixes:\n                max_xor |= 1\n                break\n    \n    return max_xor", "solution_func": "def g():\n    \"\"\"\n    Generate a list of integers for testing.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[str]:\n    \"\"\"\n    Given an integer n, generate all possible valid parentheses combinations of length 2n.\n    \"\"\"\n    def generateParenthesesHelper(open_count: int, close_count: int, current: str, result: List[str]) -> None:\n        # Base case: all parentheses generated\n        if open_count == 0 and close_count == 0:\n            result.append(current)\n            return\n        \n        # Recursive case: generate parentheses with remaining counts\n        if open_count > 0:\n            generateParenthesesHelper(open_count - 1, close_count, current + '(', result)\n        if close_count > open_count:\n            generateParenthesesHelper(open_count, close_count - 1, current + ')', result)\n    \n    result = []\n    generateParenthesesHelper(n, n, '', result)\n    return result\n\ndef g():\n    \"\"\"\n    Generate an integer for testing.\n    \"\"\"\n    return 3\n\nassert f(g()) == ['((()))', '(()())', '(())()', '()(())', '()()()']\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 346, "target_skills": [1, 1, 0, 0, 1, 0, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[str]:\n    \"\"\"\n    Given an integer n, generate all possible valid parentheses combinations of length 2n.\n    \"\"\"\n    def generateParenthesesHelper(open_count: int, close_count: int, current: str, result: List[str]) -> None:\n        # Base case: all parentheses generated\n        if open_count == 0 and close_count == 0:\n            result.append(current)\n            return\n        \n        # Recursive case: generate parentheses with remaining counts\n        if open_count > 0:\n            generateParenthesesHelper(open_count - 1, close_count, current + '(', result)\n        if close_count > open_count:\n            generateParenthesesHelper(open_count, close_count - 1, current + ')', result)\n    \n    result = []\n    generateParenthesesHelper(n, n, '', result)\n    return result", "solution_func": "def g():\n    \"\"\"\n    Generate an integer for testing.\n    \"\"\"\n    return 3", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, check if it is a palindrome.\n    Return True if s is a palindrome, False otherwise.\n    \"\"\"\n    i = 0\n    j = len(s) - 1\n\n    while i < j:\n        if s[i] != s[j]:\n            return False\n        i += 1\n        j -= 1\n\n    return True\n\ndef g(s = \"racecar\"):\n    \"\"\"\n    Return the input string.\n    \"\"\"\n    return s\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 346, "target_skills": [0, 0, 1, 1, 1, 0, 0, 1, 1, 1], "problem_func": "from typing import*\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, check if it is a palindrome.\n    Return True if s is a palindrome, False otherwise.\n    \"\"\"\n    i = 0\n    j = len(s) - 1\n\n    while i < j:\n        if s[i] != s[j]:\n            return False\n        i += 1\n        j -= 1\n\n    return True", "solution_func": "def g(s = \"racecar\"):\n    \"\"\"\n    Return the input string.\n    \"\"\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the nth Fibonacci number.\n    Return the nth Fibonacci number.\n    \"\"\"\n    if n <= 1:\n        return n\n\n    prev = 0\n    curr = 1\n\n    for _ in range(2, n + 1):\n        prev, curr = curr, prev + curr\n\n    return curr\n\ndef g(n = 6):\n    \"\"\"\n    Return the input number.\n    \"\"\"\n    return n\n\nassert f(g()) == 8\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 346, "target_skills": [0, 0, 1, 0, 0, 0, 1, 1, 1, 0], "problem_func": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the nth Fibonacci number.\n    Return the nth Fibonacci number.\n    \"\"\"\n    if n <= 1:\n        return n\n\n    prev = 0\n    curr = 1\n\n    for _ in range(2, n + 1):\n        prev, curr = curr, prev + curr\n\n    return curr", "solution_func": "def g(n = 6):\n    \"\"\"\n    Return the input number.\n    \"\"\"\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two elements in the list.\n    Return the maximum XOR value.\n    \"\"\"\n    max_xor = 0\n\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            xor = arr[i] ^ arr[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor\n\ndef g(arr = [4, 6, 2, 8, 10]):\n    \"\"\"\n    Return the input array.\n    \"\"\"\n    return arr\n\nassert f(g()) == 14\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 346, "target_skills": [0, 0, 0, 0, 1, 1, 1, 0, 0, 1], "problem_func": "from typing import*\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two elements in the list.\n    Return the maximum XOR value.\n    \"\"\"\n    max_xor = 0\n\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            xor = arr[i] ^ arr[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor", "solution_func": "def g(arr = [4, 6, 2, 8, 10]):\n    \"\"\"\n    Return the input array.\n    \"\"\"\n    return arr", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers, find the index of the target element using binary search.\n    If the target is not found, return -1.\n    \"\"\"\n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    arr = [1, 3, 5, 7, 9, 11, 13]\n    target = 7\n    return arr, target\n\nassert f(*g()) == 3\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 346, "target_skills": [1, 1, 0, 1, 0, 0, 1, 0, 1, 0], "problem_func": "from typing import*\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers, find the index of the target element using binary search.\n    If the target is not found, return -1.\n    \"\"\"\n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1", "solution_func": "def g() -> Tuple[List[int], int]:\n    arr = [1, 3, 5, 7, 9, 11, 13]\n    target = 7\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, find the number of combinations of k elements from the range [1, n]\n    such that the sum of the elements is divisible by k.\n    \"\"\"\n    def backtrack(index: int, curr_sum: int, count: int) -> None:\n        nonlocal result\n\n        if index == n + 1:\n            if curr_sum % k == 0:\n                result += count\n            return\n\n        curr_sum %= k\n        backtrack(index + 1, curr_sum, count)\n        backtrack(index + 1, (curr_sum + index) % k, count + 1)\n\n    result = 0\n    backtrack(1, 0, 0)\n    return result\n\ndef g() -> Tuple[int, int]:\n    n = 5\n    k = 3\n    return n, k\n\nassert f(*g()) == 5\n", "emb": null, "idx_generation": 346, "target_skills": [1, 0, 1, 1, 1, 0, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, find the number of combinations of k elements from the range [1, n]\n    such that the sum of the elements is divisible by k.\n    \"\"\"\n    def backtrack(index: int, curr_sum: int, count: int) -> None:\n        nonlocal result\n\n        if index == n + 1:\n            if curr_sum % k == 0:\n                result += count\n            return\n\n        curr_sum %= k\n        backtrack(index + 1, curr_sum, count)\n        backtrack(index + 1, (curr_sum + index) % k, count + 1)\n\n    result = 0\n    backtrack(1, 0, 0)\n    return result", "solution_func": "def g() -> Tuple[int, int]:\n    n = 5\n    k = 3\n    return n, k", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the number of unique paths from (0, 0) to (n, n) in a grid,\n    where each cell can be either empty or blocked.\n    The robot can only move down or right.\n    \"\"\"\n    def backtrack(i: int, j: int) -> int:\n        if i == n and j == n:\n            return 1\n        if i > n or j > n or grid[i][j] == 'X':\n            return 0\n        return backtrack(i + 1, j) + backtrack(i, j + 1)\n\n    grid = [['O'] * (n + 1) for _ in range(n + 1)]\n    grid[1][1] = 'X'  # Block the starting cell\n    return backtrack(1, 1)\n\ndef g() -> int:\n    n = 3\n    return n\n\nassert f(g()) == 2\n", "emb": null, "idx_generation": 346, "target_skills": [1, 1, 1, 0, 0, 0, 0, 1, 0, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the number of unique paths from (0, 0) to (n, n) in a grid,\n    where each cell can be either empty or blocked.\n    The robot can only move down or right.\n    \"\"\"\n    def backtrack(i: int, j: int) -> int:\n        if i == n and j == n:\n            return 1\n        if i > n or j > n or grid[i][j] == 'X':\n            return 0\n        return backtrack(i + 1, j) + backtrack(i, j + 1)\n\n    grid = [['O'] * (n + 1) for _ in range(n + 1)]\n    grid[1][1] = 'X'  # Block the starting cell\n    return backtrack(1, 1)", "solution_func": "def g() -> int:\n    n = 3\n    return n", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> List[int]:\n    \"\"\"\n    Given the root of a binary tree, return the inorder traversal of its nodes' values.\n\n    Example:\n    Input: [1,null,2,3]\n       1\n        \\\n         2\n        /\n       3\n\n    Output: [1, 3, 2]\n    \"\"\"\n\n    def inorder(node: TreeNode, result: List[int]) -> None:\n        if node:\n            inorder(node.left, result)\n            result.append(node.val)\n            inorder(node.right, result)\n\n    result = []\n    inorder(root, result)\n    return result\n\ndef g() -> TreeNode:\n    \"\"\"\n    Generate a binary tree for the function f.\n    \"\"\"\n    node_1 = TreeNode(1)\n    node_2 = TreeNode(2)\n    node_3 = TreeNode(3)\n    node_1.right = node_2\n    node_2.left = node_3\n    return node_1\n\nassert f(g()) == [1, 3, 2]\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 346, "target_skills": [0, 1, 1, 1, 0, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> List[int]:\n    \"\"\"\n    Given the root of a binary tree, return the inorder traversal of its nodes' values.\n\n    Example:\n    Input: [1,null,2,3]\n       1\n        \\\n         2\n        /\n       3\n\n    Output: [1, 3, 2]\n    \"\"\"\n\n    def inorder(node: TreeNode, result: List[int]) -> None:\n        if node:\n            inorder(node.left, result)\n            result.append(node.val)\n            inorder(node.right, result)\n\n    result = []\n    inorder(root, result)\n    return result", "solution_func": "def g() -> TreeNode:\n    \"\"\"\n    Generate a binary tree for the function f.\n    \"\"\"\n    node_1 = TreeNode(1)\n    node_2 = TreeNode(2)\n    node_3 = TreeNode(3)\n    node_1.right = node_2\n    node_2.left = node_3\n    return node_1", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, use binary search to determine if the target number is present in the list.\n\n    Example:\n    f([1, 2, 3, 4, 5], 3) returns True.\n\n    Note:\n    - The input list will always be sorted in ascending order.\n    - The input list can contain duplicate numbers.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5], target: int = 3) -> bool:\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n\n    Example:\n    g() returns ([1, 2, 3, 4, 5], 3).\n\n    Note:\n    - The input list will always be sorted in ascending order.\n    - The input list can contain duplicate numbers.\n    \"\"\"\n\n    return nums, target\n\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 347, "target_skills": [1, 0, 0, 1, 1, 1, 0, 1, 0, 1], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, use binary search to determine if the target number is present in the list.\n\n    Example:\n    f([1, 2, 3, 4, 5], 3) returns True.\n\n    Note:\n    - The input list will always be sorted in ascending order.\n    - The input list can contain duplicate numbers.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False", "solution_func": "def g(nums: List[int] = [1, 2, 3, 4, 5], target: int = 3) -> bool:\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n\n    Example:\n    g() returns ([1, 2, 3, 4, 5], 3).\n\n    Note:\n    - The input list will always be sorted in ascending order.\n    - The input list can contain duplicate numbers.\n    \"\"\"\n\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of the words in the string.\n\n    Example:\n    f(\"Hello World\") returns \"World Hello\".\n\n    Note:\n    - Words in the string are separated by a single space.\n    - The input string may contain leading or trailing white spaces.\n    - Words in the string may contain punctuation and special characters.\n    \"\"\"\n\n    words = s.strip().split()\n    return ' '.join(reversed(words))\n\n\ndef g(s: str = \"Hello World\") -> str:\n    \"\"\"\n    Generate a string.\n\n    Example:\n    g() returns \"Hello World\".\n\n    Note:\n    - The input string may contain leading or trailing white spaces.\n    - Words in the string may contain punctuation and special characters.\n    \"\"\"\n\n    return s\n\n\nassert f(g()) == \"World Hello\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 347, "target_skills": [0, 1, 0, 1, 1, 1, 1, 0, 0, 1], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of the words in the string.\n\n    Example:\n    f(\"Hello World\") returns \"World Hello\".\n\n    Note:\n    - Words in the string are separated by a single space.\n    - The input string may contain leading or trailing white spaces.\n    - Words in the string may contain punctuation and special characters.\n    \"\"\"\n\n    words = s.strip().split()\n    return ' '.join(reversed(words))", "solution_func": "def g(s: str = \"Hello World\") -> str:\n    \"\"\"\n    Generate a string.\n\n    Example:\n    g() returns \"Hello World\".\n\n    Note:\n    - The input string may contain leading or trailing white spaces.\n    - Words in the string may contain punctuation and special characters.\n    \"\"\"\n\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the index of the target number in the list using linear search.\n\n    Example:\n    f([5, 2, 7, 3, 1], 7) returns 2.\n\n    Note:\n    - The input list can contain duplicate numbers.\n    \"\"\"\n\n    for i in range(len(nums)):\n        if nums[i] == target:\n            return i\n\n    return -1\n\n\ndef g(nums: List[int] = [5, 2, 7, 3, 1], target: int = 7) -> int:\n    \"\"\"\n    Generate a list of integers and a target number.\n\n    Example:\n    g() returns ([5, 2, 7, 3, 1], 7).\n\n    Note:\n    - The input list can contain duplicate numbers.\n    \"\"\"\n\n    return nums, target\n\n\nassert f(*g()) == 2\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 347, "target_skills": [1, 1, 1, 1, 1, 1, 0, 0, 1, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the index of the target number in the list using linear search.\n\n    Example:\n    f([5, 2, 7, 3, 1], 7) returns 2.\n\n    Note:\n    - The input list can contain duplicate numbers.\n    \"\"\"\n\n    for i in range(len(nums)):\n        if nums[i] == target:\n            return i\n\n    return -1", "solution_func": "def g(nums: List[int] = [5, 2, 7, 3, 1], target: int = 7) -> int:\n    \"\"\"\n    Generate a list of integers and a target number.\n\n    Example:\n    g() returns ([5, 2, 7, 3, 1], 7).\n\n    Note:\n    - The input list can contain duplicate numbers.\n    \"\"\"\n\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"Count the number of k-combinations from a set of n elements.\"\"\"\n    def factorial(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n-1)\n    \n    return factorial(n) // (factorial(k) * factorial(n-k))\n\ndef g(n=5, k=2):\n    return n, k\n\nassert f(g()) == 10\n", "emb": null, "idx_generation": 347, "target_skills": [0, 0, 0, 0, 1, 0, 0, 0, 1, 0], "problem_func": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"Count the number of k-combinations from a set of n elements.\"\"\"\n    def factorial(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n-1)\n    \n    return factorial(n) // (factorial(k) * factorial(n-k))", "solution_func": "def g(n=5, k=2):\n    return n, k", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str, k: int) -> str:\n    \"\"\"Perform k-bit left rotation on a string.\"\"\"\n    def left_rotate(s, k):\n        k = k % len(s)\n        return s[k:] + s[:k]\n    \n    return left_rotate(s, k)\n\ndef g(s=\"Python\", k=3):\n    return s, k\n\nassert f(g()) == \"honPyt\"\n", "emb": null, "idx_generation": 347, "target_skills": [1, 1, 1, 0, 0, 1, 1, 1, 1, 0], "problem_func": "from typing import*\ndef f(s: str, k: int) -> str:\n    \"\"\"Perform k-bit left rotation on a string.\"\"\"\n    def left_rotate(s, k):\n        k = k % len(s)\n        return s[k:] + s[:k]\n    \n    return left_rotate(s, k)", "solution_func": "def g(s=\"Python\", k=3):\n    return s, k", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the minimum number of moves to reach the target in a grid.\"\"\"\n    def bfs(grid, start, target):\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            node, steps = queue.pop(0)\n            if node == target:\n                return steps\n            visited.add(node)\n            for neighbor in get_neighbors(node, grid):\n                if neighbor not in visited:\n                    queue.append((neighbor, steps + 1))\n        return -1\n    \n    def get_neighbors(node, grid):\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        neighbors = []\n        for dx, dy in directions:\n            x = node[0] + dx\n            y = node[1] + dy\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] != 1:\n                neighbors.append((x, y))\n        return neighbors\n    \n    m = len(grid)\n    n = len(grid[0])\n    start = (0, 0)\n    target = (m-1, n-1)\n    return bfs(grid, start, target)\n\ndef g(grid=[[0, 0, 0, 0, 0],\n            [1, 1, 0, 1, 1],\n            [0, 0, 0, 0, 0],\n            [0, 1, 1, 1, 0],\n            [0, 0, 0, 0, 0]]):\n    return grid\n\nassert f(g()) == 10\n", "emb": null, "idx_generation": 347, "target_skills": [0, 0, 0, 0, 0, 1, 0, 0, 1, 0], "problem_func": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the minimum number of moves to reach the target in a grid.\"\"\"\n    def bfs(grid, start, target):\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            node, steps = queue.pop(0)\n            if node == target:\n                return steps\n            visited.add(node)\n            for neighbor in get_neighbors(node, grid):\n                if neighbor not in visited:\n                    queue.append((neighbor, steps + 1))\n        return -1\n    \n    def get_neighbors(node, grid):\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        neighbors = []\n        for dx, dy in directions:\n            x = node[0] + dx\n            y = node[1] + dy\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] != 1:\n                neighbors.append((x, y))\n        return neighbors\n    \n    m = len(grid)\n    n = len(grid[0])\n    start = (0, 0)\n    target = (m-1, n-1)\n    return bfs(grid, start, target)", "solution_func": "def g(grid=[[0, 0, 0, 0, 0],\n            [1, 1, 0, 1, 1],\n            [0, 0, 0, 0, 0],\n            [0, 1, 1, 1, 0],\n            [0, 0, 0, 0, 0]]):\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, sort the list in ascending order and return the sorted list.\n\n    Example:\n    Input: nums = [5, 2, 7, 1, 3]\n    Output: [1, 2, 3, 5, 7]\n\n    Hint: Use a sorting algorithm such as bubble sort, insertion sort, or merge sort.\n    \"\"\"\n\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr\n        mid = len(arr) // 2\n        left = merge_sort(arr[:mid])\n        right = merge_sort(arr[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        merged = []\n        i = j = 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n        while i < len(left):\n            merged.append(left[i])\n            i += 1\n        while j < len(right):\n            merged.append(right[j])\n            j += 1\n        return merged\n\n    return merge_sort(nums)\n\ndef g(nums=[5, 2, 7, 1, 3]):\n    return nums\n\nassert f(g()) == [1, 2, 3, 5, 7]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 347, "target_skills": [1, 1, 1, 1, 1, 1, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, sort the list in ascending order and return the sorted list.\n\n    Example:\n    Input: nums = [5, 2, 7, 1, 3]\n    Output: [1, 2, 3, 5, 7]\n\n    Hint: Use a sorting algorithm such as bubble sort, insertion sort, or merge sort.\n    \"\"\"\n\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr\n        mid = len(arr) // 2\n        left = merge_sort(arr[:mid])\n        right = merge_sort(arr[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        merged = []\n        i = j = 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n        while i < len(left):\n            merged.append(left[i])\n            i += 1\n        while j < len(right):\n            merged.append(right[j])\n            j += 1\n        return merged\n\n    return merge_sort(nums)", "solution_func": "def g(nums=[5, 2, 7, 1, 3]):\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "import math\nfrom typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of the first n Fibonacci numbers.\n\n    Example:\n    Input: n = 5\n    Output: 12\n\n    Explanation: The first 5 Fibonacci numbers are 0, 1, 1, 2, 3. Their sum is 0 + 1 + 1 + 2 + 3 = 7.\n\n    Hint: Use the mathematical formula for the sum of the first n Fibonacci numbers.\n    \"\"\"\n\n    def fibonacci_sum(n):\n        if n <= 0:\n            return 0\n        fib = [0, 1]\n        for i in range(2, n + 1):\n            fib.append(fib[i - 1] + fib[i - 2])\n        return sum(fib)\n\n    return fibonacci_sum(n)\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 12\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 347, "target_skills": [1, 0, 1, 1, 0, 0, 1, 1, 1, 1], "problem_func": "import math\nfrom typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of the first n Fibonacci numbers.\n\n    Example:\n    Input: n = 5\n    Output: 12\n\n    Explanation: The first 5 Fibonacci numbers are 0, 1, 1, 2, 3. Their sum is 0 + 1 + 1 + 2 + 3 = 7.\n\n    Hint: Use the mathematical formula for the sum of the first n Fibonacci numbers.\n    \"\"\"\n\n    def fibonacci_sum(n):\n        if n <= 0:\n            return 0\n        fib = [0, 1]\n        for i in range(2, n + 1):\n            fib.append(fib[i - 1] + fib[i - 2])\n        return sum(fib)\n\n    return fibonacci_sum(n)", "solution_func": "def g(n=5):\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters representing a word search puzzle, count the number of occurrences of a given word in the puzzle.\n    The word can be found horizontally, vertically, or diagonally (in all eight directions).\n\n    Example:\n    Input:\n    grid = [\n        ['A', 'B', 'C', 'E'],\n        ['S', 'F', 'C', 'S'],\n        ['A', 'D', 'E', 'E']\n    ]\n    word = \"ABCCED\"\n\n    Output: 1\n\n    Explanation: The word \"ABCCED\" can be found in the first row of the grid.\n\n    Hint: Use a depth-first search (DFS) algorithm to explore all possible paths in the grid.\n    \"\"\"\n\n    def word_search(grid, word):\n        if not grid or not grid[0]:\n            return 0\n        m, n = len(grid), len(grid[0])\n        count = 0\n        for i in range(m):\n            for j in range(n):\n                if dfs(grid, i, j, word, 0):\n                    count += 1\n        return count\n\n    def dfs(grid, i, j, word, k):\n        if k == len(word):\n            return True\n        m, n = len(grid), len(grid[0])\n        if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != word[k]:\n            return False\n        temp = grid[i][j]\n        grid[i][j] = '#'\n        found = dfs(grid, i - 1, j, word, k + 1) or dfs(grid, i + 1, j, word, k + 1) or dfs(grid, i, j - 1, word, k + 1) or dfs(grid, i, j + 1, word, k + 1) or dfs(grid, i - 1, j - 1, word, k + 1) or dfs(grid, i - 1, j + 1, word, k + 1) or dfs(grid, i + 1, j - 1, word, k + 1) or dfs(grid, i + 1, j + 1, word, k + 1)\n        grid[i][j] = temp\n        return found\n\n    return word_search(grid, word)\n\ndef g(grid=[['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], word=\"ABCCED\"):\n    return grid, word\n\nassert f(*g()) == 1\n", "emb": null, "idx_generation": 347, "target_skills": [1, 1, 0, 1, 1, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters representing a word search puzzle, count the number of occurrences of a given word in the puzzle.\n    The word can be found horizontally, vertically, or diagonally (in all eight directions).\n\n    Example:\n    Input:\n    grid = [\n        ['A', 'B', 'C', 'E'],\n        ['S', 'F', 'C', 'S'],\n        ['A', 'D', 'E', 'E']\n    ]\n    word = \"ABCCED\"\n\n    Output: 1\n\n    Explanation: The word \"ABCCED\" can be found in the first row of the grid.\n\n    Hint: Use a depth-first search (DFS) algorithm to explore all possible paths in the grid.\n    \"\"\"\n\n    def word_search(grid, word):\n        if not grid or not grid[0]:\n            return 0\n        m, n = len(grid), len(grid[0])\n        count = 0\n        for i in range(m):\n            for j in range(n):\n                if dfs(grid, i, j, word, 0):\n                    count += 1\n        return count\n\n    def dfs(grid, i, j, word, k):\n        if k == len(word):\n            return True\n        m, n = len(grid), len(grid[0])\n        if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != word[k]:\n            return False\n        temp = grid[i][j]\n        grid[i][j] = '#'\n        found = dfs(grid, i - 1, j, word, k + 1) or dfs(grid, i + 1, j, word, k + 1) or dfs(grid, i, j - 1, word, k + 1) or dfs(grid, i, j + 1, word, k + 1) or dfs(grid, i - 1, j - 1, word, k + 1) or dfs(grid, i - 1, j + 1, word, k + 1) or dfs(grid, i + 1, j - 1, word, k + 1) or dfs(grid, i + 1, j + 1, word, k + 1)\n        grid[i][j] = temp\n        return found\n\n    return word_search(grid, word)", "solution_func": "def g(grid=[['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], word=\"ABCCED\"):\n    return grid, word", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value of any two elements in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value can be obtained by XORing 5 and 25, which gives 28.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor_val = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor_val)\n\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 347, "target_skills": [1, 1, 1, 1, 1, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value of any two elements in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value can be obtained by XORing 5 and 25, which gives 28.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor_val = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor_val)\n\n    return max_xor", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix, find the maximum sum of a submatrix with dimensions m x n,\n    where m and n are positive integers.\n\n    Args:\n    - matrix: A 2D list of integers representing the matrix.\n\n    Returns:\n    - The maximum sum of a submatrix with dimensions m x n.\n    \"\"\"\n    def prefix_sum(matrix):\n        rows = len(matrix)\n        cols = len(matrix[0])\n\n        prefix_sum_matrix = [[0] * cols for _ in range(rows)]\n        prefix_sum_matrix[0][0] = matrix[0][0]\n\n        for i in range(1, rows):\n            prefix_sum_matrix[i][0] = prefix_sum_matrix[i-1][0] + matrix[i][0]\n\n        for j in range(1, cols):\n            prefix_sum_matrix[0][j] = prefix_sum_matrix[0][j-1] + matrix[0][j]\n\n        for i in range(1, rows):\n            for j in range(1, cols):\n                prefix_sum_matrix[i][j] = prefix_sum_matrix[i-1][j] + prefix_sum_matrix[i][j-1] - prefix_sum_matrix[i-1][j-1] + matrix[i][j]\n\n        return prefix_sum_matrix\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n    max_sum = float('-inf')\n\n    prefix_sum_matrix = prefix_sum(matrix)\n\n    for i in range(rows):\n        for j in range(cols):\n            for m in range(i, rows):\n                for n in range(j, cols):\n                    submatrix_sum = prefix_sum_matrix[m][n]\n\n                    if i > 0:\n                        submatrix_sum -= prefix_sum_matrix[i-1][n]\n\n                    if j > 0:\n                        submatrix_sum -= prefix_sum_matrix[m][j-1]\n\n                    if i > 0 and j > 0:\n                        submatrix_sum += prefix_sum_matrix[i-1][j-1]\n\n                    max_sum = max(max_sum, submatrix_sum)\n\n    return max_sum\n\ndef g() -> List[List[int]]:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == 45\n\n", "emb": [1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0], "idx_generation": 348, "target_skills": [1, 0, 1, 1, 1, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix, find the maximum sum of a submatrix with dimensions m x n,\n    where m and n are positive integers.\n\n    Args:\n    - matrix: A 2D list of integers representing the matrix.\n\n    Returns:\n    - The maximum sum of a submatrix with dimensions m x n.\n    \"\"\"\n    def prefix_sum(matrix):\n        rows = len(matrix)\n        cols = len(matrix[0])\n\n        prefix_sum_matrix = [[0] * cols for _ in range(rows)]\n        prefix_sum_matrix[0][0] = matrix[0][0]\n\n        for i in range(1, rows):\n            prefix_sum_matrix[i][0] = prefix_sum_matrix[i-1][0] + matrix[i][0]\n\n        for j in range(1, cols):\n            prefix_sum_matrix[0][j] = prefix_sum_matrix[0][j-1] + matrix[0][j]\n\n        for i in range(1, rows):\n            for j in range(1, cols):\n                prefix_sum_matrix[i][j] = prefix_sum_matrix[i-1][j] + prefix_sum_matrix[i][j-1] - prefix_sum_matrix[i-1][j-1] + matrix[i][j]\n\n        return prefix_sum_matrix\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n    max_sum = float('-inf')\n\n    prefix_sum_matrix = prefix_sum(matrix)\n\n    for i in range(rows):\n        for j in range(cols):\n            for m in range(i, rows):\n                for n in range(j, cols):\n                    submatrix_sum = prefix_sum_matrix[m][n]\n\n                    if i > 0:\n                        submatrix_sum -= prefix_sum_matrix[i-1][n]\n\n                    if j > 0:\n                        submatrix_sum -= prefix_sum_matrix[m][j-1]\n\n                    if i > 0 and j > 0:\n                        submatrix_sum += prefix_sum_matrix[i-1][j-1]\n\n                    max_sum = max(max_sum, submatrix_sum)\n\n    return max_sum", "solution_func": "def g() -> List[List[int]]:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix", "map_ix": [1, 1, 1, 1, 0, 1, 1, 1, 1, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the sum of all multiples of 3 or 5 below n.\n\n    Args:\n    - n: An integer.\n\n    Returns:\n    - The sum of all multiples of 3 or 5 below n.\n    \"\"\"\n    def sum_multiples(n, k):\n        m = (n - 1) // k\n        return k * m * (m + 1) // 2\n\n    sum_3 = sum_multiples(n, 3)\n    sum_5 = sum_multiples(n, 5)\n    sum_15 = sum_multiples(n, 15)\n\n    return sum_3 + sum_5 - sum_15\n\ndef g() -> int:\n    n = 1000\n    return n\n\nassert f(g()) == 233168\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 348, "target_skills": [0, 0, 0, 1, 0, 0, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the sum of all multiples of 3 or 5 below n.\n\n    Args:\n    - n: An integer.\n\n    Returns:\n    - The sum of all multiples of 3 or 5 below n.\n    \"\"\"\n    def sum_multiples(n, k):\n        m = (n - 1) // k\n        return k * m * (m + 1) // 2\n\n    sum_3 = sum_multiples(n, 3)\n    sum_5 = sum_multiples(n, 5)\n    sum_15 = sum_multiples(n, 15)\n\n    return sum_3 + sum_5 - sum_15", "solution_func": "def g() -> int:\n    n = 1000\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given an integer n, find the kth largest element in the range [1, n].\n\n    Args:\n    - n: An integer.\n    - k: An integer.\n\n    Returns:\n    - The kth largest element in the range [1, n].\n    \"\"\"\n    def count_bits(num):\n        count = 0\n\n        while num:\n            count += num & 1\n            num >>= 1\n\n        return count\n\n    def compare(x, y):\n        count_x = count_bits(x)\n        count_y = count_bits(y)\n\n        if count_x != count_y:\n            return count_x - count_y\n        else:\n            return x - y\n\n    nums = list(range(1, n+1))\n    nums.sort(key=lambda x: compare(x, k-1))\n\n    return nums[k-1]\n\ndef g() -> Tuple[int, int]:\n    n = 10\n    k = 4\n    return (n, k)\n\nassert f(*g()) == 8\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 348, "target_skills": [0, 0, 1, 0, 1, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given an integer n, find the kth largest element in the range [1, n].\n\n    Args:\n    - n: An integer.\n    - k: An integer.\n\n    Returns:\n    - The kth largest element in the range [1, n].\n    \"\"\"\n    def count_bits(num):\n        count = 0\n\n        while num:\n            count += num & 1\n            num >>= 1\n\n        return count\n\n    def compare(x, y):\n        count_x = count_bits(x)\n        count_y = count_bits(y)\n\n        if count_x != count_y:\n            return count_x - count_y\n        else:\n            return x - y\n\n    nums = list(range(1, n+1))\n    nums.sort(key=lambda x: compare(x, k-1))\n\n    return nums[k-1]", "solution_func": "def g() -> Tuple[int, int]:\n    n = 10\n    k = 4\n    return (n, k)", "map_ix": [1, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, m: int, target: int) -> bool:\n    \"\"\"\n    Given two integers n and m, determine if there exists a pair of integers (x, y) such that\n    1. x is a positive integer less than or equal to n\n    2. y is a positive integer less than or equal to m\n    3. x^2 + y^2 = target\n    \"\"\"\n    def helper(x, y):\n        if x ** 2 + y ** 2 == target:\n            return True\n        if x ** 2 + y ** 2 > target:\n            return False\n        return helper(x+1, y) or helper(x, y+1)\n    \n    return helper(1, 1)\n\ndef g(n=10, m=10, target=85):\n    return n, m, target\n\nassert f(g())\n", "emb": null, "idx_generation": 348, "target_skills": [1, 0, 1, 1, 1, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int, m: int, target: int) -> bool:\n    \"\"\"\n    Given two integers n and m, determine if there exists a pair of integers (x, y) such that\n    1. x is a positive integer less than or equal to n\n    2. y is a positive integer less than or equal to m\n    3. x^2 + y^2 = target\n    \"\"\"\n    def helper(x, y):\n        if x ** 2 + y ** 2 == target:\n            return True\n        if x ** 2 + y ** 2 > target:\n            return False\n        return helper(x+1, y) or helper(x, y+1)\n    \n    return helper(1, 1)", "solution_func": "def g(n=10, m=10, target=85):\n    return n, m, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a prime number.\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g(n=17):\n    return n\n\nassert f(g())\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 348, "target_skills": [1, 1, 1, 1, 0, 1, 1, 1, 1, 0], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a prime number.\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "solution_func": "def g(n=17):\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine the n-th Fibonacci number.\n    \"\"\"\n    if n <= 1:\n        return n\n    return f(n-1) + f(n-2)\n\ndef g(n=7):\n    return n\n\nassert f(g()) == 13\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 348, "target_skills": [1, 1, 0, 1, 1, 1, 0, 0, 1, 1], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine the n-th Fibonacci number.\n    \"\"\"\n    if n <= 1:\n        return n\n    return f(n-1) + f(n-2)", "solution_func": "def g(n=7):\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix and two nodes start and end,\n    check if there is a path from start to end in the graph.\n\n    Return True if a path exists, False otherwise.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 0 to node 3 in the graph.\n\n    Hint: Use depth-first search (DFS) or breadth-first search (BFS) algorithm to traverse the graph.\n    \"\"\"\n\n    def dfs(graph: List[List[int]], start: int, end: int, visited: List[bool]) -> bool:\n        if start == end:\n            return True\n        visited[start] = True\n        for neighbor in range(len(graph)):\n            if graph[start][neighbor] == 1 and not visited[neighbor]:\n                if dfs(graph, neighbor, end, visited):\n                    return True\n        return False\n\n    visited = [False] * len(graph)\n    return dfs(graph, start, end, visited)\n\ndef g() -> tuple:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n    return graph, start, end\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 348, "target_skills": [0, 0, 1, 1, 0, 0, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix and two nodes start and end,\n    check if there is a path from start to end in the graph.\n\n    Return True if a path exists, False otherwise.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 0 to node 3 in the graph.\n\n    Hint: Use depth-first search (DFS) or breadth-first search (BFS) algorithm to traverse the graph.\n    \"\"\"\n\n    def dfs(graph: List[List[int]], start: int, end: int, visited: List[bool]) -> bool:\n        if start == end:\n            return True\n        visited[start] = True\n        for neighbor in range(len(graph)):\n            if graph[start][neighbor] == 1 and not visited[neighbor]:\n                if dfs(graph, neighbor, end, visited):\n                    return True\n        return False\n\n    visited = [False] * len(graph)\n    return dfs(graph, start, end, visited)", "solution_func": "def g() -> tuple:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n    return graph, start, end", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"\n    Given an integer number num, return the number of set bits in its binary representation.\n\n    Example:\n    num = 10\n\n    Output:\n    2\n\n    Explanation:\n    The binary representation of 10 is 1010, which has 2 set bits.\n\n    Hint: Use the bitwise AND operation to check for set bits.\n    \"\"\"\n\n    count = 0\n    while num > 0:\n        if num & 1:\n            count += 1\n        num >>= 1\n    return count\n\ndef g(num=10):\n    return num\n\nassert f(g()) == 2\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 348, "target_skills": [1, 0, 0, 1, 0, 0, 1, 0, 0, 0], "problem_func": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"\n    Given an integer number num, return the number of set bits in its binary representation.\n\n    Example:\n    num = 10\n\n    Output:\n    2\n\n    Explanation:\n    The binary representation of 10 is 1010, which has 2 set bits.\n\n    Hint: Use the bitwise AND operation to check for set bits.\n    \"\"\"\n\n    count = 0\n    while num > 0:\n        if num & 1:\n            count += 1\n        num >>= 1\n    return count", "solution_func": "def g(num=10):\n    return num", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid consisting of 0s and 1s, where 0 represents an empty cell and 1 represents an obstacle,\n    find the length of the shortest path from the top-left corner to the bottom-right corner of the grid,\n    while only moving horizontally or vertically.\n\n    Return the length of the shortest path.\n\n    Example:\n    grid = [\n        [0, 1, 0, 0, 0],\n        [0, 1, 0, 1, 0],\n        [0, 0, 0, 0, 0],\n        [0, 1, 1, 1, 0],\n        [0, 0, 0, 0, 0]\n    ]\n\n    Output:\n    8\n\n    Explanation:\n    The shortest path from the top-left corner (0, 0) to the bottom-right corner (4, 4) is:\n    (0, 0) -> (1, 0) -> (2, 0) -> (2, 1) -> (2, 2) -> (3, 2) -> (4, 2) -> (4, 3) -> (4, 4),\n    which has a length of 8.\n\n    Hint: Use breadth-first search (BFS) algorithm to find the shortest path.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def bfs(grid: List[List[int]], start: tuple, end: tuple) -> int:\n        queue = [(start, 0)]\n        visited = set()\n        visited.add(start)\n        while queue:\n            curr, distance = queue.pop(0)\n            if curr == end:\n                return distance\n            for dx, dy in directions:\n                new_x = curr[0] + dx\n                new_y = curr[1] + dy\n                if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] == 0 and (new_x, new_y) not in visited:\n                    queue.append(((new_x, new_y), distance + 1))\n                    visited.add((new_x, new_y))\n        return -1\n\n    return bfs(grid, (0, 0), (rows - 1, cols - 1))\n\ndef g() -> List[List[int]]:\n    grid = [\n        [0, 1, 0, 0, 0],\n        [0, 1, 0, 1, 0],\n        [0, 0, 0, 0, 0],\n        [0, 1, 1, 1, 0],\n        [0, 0, 0, 0, 0]\n    ]\n    return grid\n\nassert f(g()) == 8\n\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 348, "target_skills": [0, 0, 0, 1, 1, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid consisting of 0s and 1s, where 0 represents an empty cell and 1 represents an obstacle,\n    find the length of the shortest path from the top-left corner to the bottom-right corner of the grid,\n    while only moving horizontally or vertically.\n\n    Return the length of the shortest path.\n\n    Example:\n    grid = [\n        [0, 1, 0, 0, 0],\n        [0, 1, 0, 1, 0],\n        [0, 0, 0, 0, 0],\n        [0, 1, 1, 1, 0],\n        [0, 0, 0, 0, 0]\n    ]\n\n    Output:\n    8\n\n    Explanation:\n    The shortest path from the top-left corner (0, 0) to the bottom-right corner (4, 4) is:\n    (0, 0) -> (1, 0) -> (2, 0) -> (2, 1) -> (2, 2) -> (3, 2) -> (4, 2) -> (4, 3) -> (4, 4),\n    which has a length of 8.\n\n    Hint: Use breadth-first search (BFS) algorithm to find the shortest path.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def bfs(grid: List[List[int]], start: tuple, end: tuple) -> int:\n        queue = [(start, 0)]\n        visited = set()\n        visited.add(start)\n        while queue:\n            curr, distance = queue.pop(0)\n            if curr == end:\n                return distance\n            for dx, dy in directions:\n                new_x = curr[0] + dx\n                new_y = curr[1] + dy\n                if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] == 0 and (new_x, new_y) not in visited:\n                    queue.append(((new_x, new_y), distance + 1))\n                    visited.add((new_x, new_y))\n        return -1\n\n    return bfs(grid, (0, 0), (rows - 1, cols - 1))", "solution_func": "def g() -> List[List[int]]:\n    grid = [\n        [0, 1, 0, 0, 0],\n        [0, 1, 0, 1, 0],\n        [0, 0, 0, 0, 0],\n        [0, 1, 1, 1, 0],\n        [0, 0, 0, 0, 0]\n    ]\n    return grid", "map_ix": [1, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum sum of a subarray with at most one element removed.\n\n    Example:\n    nums = [1, -2, 3, -4, 5]\n\n    Output:\n    6\n\n    Explanation:\n    By removing the element -4, the subarray [1, -2, 3, 5] has the maximum sum of 6.\n    \"\"\"\n\n    n = len(nums)\n    max_sum = float('-inf')\n\n    # Calculate the maximum sum of subarrays without removing any element\n    curr_sum = max_sum = nums[0]\n    for i in range(1, n):\n        curr_sum = max(nums[i], curr_sum + nums[i])\n        max_sum = max(max_sum, curr_sum)\n\n    # Calculate the maximum sum of subarrays by removing one element\n    prefix_sum = [0] * n\n    suffix_sum = [0] * n\n    prefix_sum[0] = nums[0]\n    suffix_sum[n-1] = nums[n-1]\n\n    for i in range(1, n):\n        prefix_sum[i] = max(nums[i], prefix_sum[i-1] + nums[i])\n        suffix_sum[n-1-i] = max(nums[n-1-i], suffix_sum[n-i] + nums[n-1-i])\n\n    for i in range(1, n-1):\n        max_sum = max(max_sum, prefix_sum[i-1] + suffix_sum[i+1])\n\n    return max_sum\n\ndef g():\n    nums = [1, -2, 3, -4, 5]\n    return nums\n\nassert f(g()) == 6\n", "emb": null, "idx_generation": 348, "target_skills": [0, 1, 0, 0, 0, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum sum of a subarray with at most one element removed.\n\n    Example:\n    nums = [1, -2, 3, -4, 5]\n\n    Output:\n    6\n\n    Explanation:\n    By removing the element -4, the subarray [1, -2, 3, 5] has the maximum sum of 6.\n    \"\"\"\n\n    n = len(nums)\n    max_sum = float('-inf')\n\n    # Calculate the maximum sum of subarrays without removing any element\n    curr_sum = max_sum = nums[0]\n    for i in range(1, n):\n        curr_sum = max(nums[i], curr_sum + nums[i])\n        max_sum = max(max_sum, curr_sum)\n\n    # Calculate the maximum sum of subarrays by removing one element\n    prefix_sum = [0] * n\n    suffix_sum = [0] * n\n    prefix_sum[0] = nums[0]\n    suffix_sum[n-1] = nums[n-1]\n\n    for i in range(1, n):\n        prefix_sum[i] = max(nums[i], prefix_sum[i-1] + nums[i])\n        suffix_sum[n-1-i] = max(nums[n-1-i], suffix_sum[n-i] + nums[n-1-i])\n\n    for i in range(1, n-1):\n        max_sum = max(max_sum, prefix_sum[i-1] + suffix_sum[i+1])\n\n    return max_sum", "solution_func": "def g():\n    nums = [1, -2, 3, -4, 5]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15], target = 9\n\n    Output:\n    [0, 1] (nums[0] + nums[1] = 2 + 7 = 9)\n    \"\"\"\n    complement = {}\n    for i, num in enumerate(nums):\n        if num in complement:\n            return [complement[num], i]\n        else:\n            complement[target - num] = i\n    return []\n\ndef g(nums: List[int] = [2, 7, 11, 15], target: int = 9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "idx_generation": 349, "target_skills": [0, 0, 0, 0, 1, 0, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15], target = 9\n\n    Output:\n    [0, 1] (nums[0] + nums[1] = 2 + 7 = 9)\n    \"\"\"\n    complement = {}\n    for i, num in enumerate(nums):\n        if num in complement:\n            return [complement[num], i]\n        else:\n            complement[target - num] = i\n    return []", "solution_func": "def g(nums: List[int] = [2, 7, 11, 15], target: int = 9):\n    return nums, target", "map_ix": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers and a value k, find the maximum XOR value of any two numbers in the list that is less than or equal to k.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8], k = 15\n\n    Output:\n    12 (3 XOR 10 = 12, which is less than or equal to 15)\n    \"\"\"\n    max_xor = 0\n    for num in nums:\n        max_xor = max(max_xor, num ^ k)\n    return max_xor\n\ndef g(nums: List[int] = [3, 10, 5, 25, 2, 8], k: int = 15):\n    return nums, k\n\nassert f(*g()) == 12\n", "emb": null, "idx_generation": 349, "target_skills": [1, 1, 0, 0, 0, 1, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers and a value k, find the maximum XOR value of any two numbers in the list that is less than or equal to k.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8], k = 15\n\n    Output:\n    12 (3 XOR 10 = 12, which is less than or equal to 15)\n    \"\"\"\n    max_xor = 0\n    for num in nums:\n        max_xor = max(max_xor, num ^ k)\n    return max_xor", "solution_func": "def g(nums: List[int] = [3, 10, 5, 25, 2, 8], k: int = 15):\n    return nums, k", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find the closest pair of numbers in the list whose sum is less than or equal to the target.\n    Return the pair of numbers.\n\n    Example:\n    nums = [1, 2, 3, 4, 5], target = 7\n\n    Output:\n    [2, 4] (2 + 4 = 6, which is less than or equal to 7)\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    closest_sum = float('-inf')\n    closest_pair = []\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum <= target:\n            if curr_sum > closest_sum:\n                closest_sum = curr_sum\n                closest_pair = [nums[left], nums[right]]\n            left += 1\n        else:\n            right -= 1\n    return closest_pair\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5], target: int = 7):\n    return nums, target\n\nassert f(*g()) == [2, 4]\n", "emb": null, "idx_generation": 349, "target_skills": [1, 1, 0, 1, 0, 1, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find the closest pair of numbers in the list whose sum is less than or equal to the target.\n    Return the pair of numbers.\n\n    Example:\n    nums = [1, 2, 3, 4, 5], target = 7\n\n    Output:\n    [2, 4] (2 + 4 = 6, which is less than or equal to 7)\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    closest_sum = float('-inf')\n    closest_pair = []\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum <= target:\n            if curr_sum > closest_sum:\n                closest_sum = curr_sum\n                closest_pair = [nums[left], nums[right]]\n            left += 1\n        else:\n            right -= 1\n    return closest_pair", "solution_func": "def g(nums: List[int] = [1, 2, 3, 4, 5], target: int = 7):\n    return nums, target", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a submatrix where the submatrix is formed by selecting a rectangle of cells from the original matrix.\n\n    Example:\n    matrix = [[1, 2, -3],\n              [-4, 5, 6],\n              [7, -8, 9]]\n    Output: 20\n\n    The maximum sum of a submatrix is obtained by selecting the cells [5, 6],\n    [7, -8], and [9], which gives a sum of 20.\n    \"\"\"\n\n    if not matrix or not matrix[0]:\n        return 0\n    \n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    prefix_sum = [[0] * (cols+1) for _ in range(rows+1)]\n    \n    for i in range(1, rows+1):\n        for j in range(1, cols+1):\n            prefix_sum[i][j] = prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1] + matrix[i-1][j-1]\n    \n    max_sum = float('-inf')\n    \n    for i in range(rows):\n        for j in range(cols):\n            for k in range(i+1, rows+1):\n                for l in range(j+1, cols+1):\n                    submatrix_sum = prefix_sum[k][l] - prefix_sum[i][l] - prefix_sum[k][j] + prefix_sum[i][j]\n                    max_sum = max(max_sum, submatrix_sum)\n    \n    return max_sum\n\ndef g():\n    matrix = [[1, 2, -3],\n              [-4, 5, 6],\n              [7, -8, 9]]\n    return matrix\n\nassert f(g()) == 20\n\n", "emb": null, "idx_generation": 349, "target_skills": [1, 1, 1, 0, 1, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a submatrix where the submatrix is formed by selecting a rectangle of cells from the original matrix.\n\n    Example:\n    matrix = [[1, 2, -3],\n              [-4, 5, 6],\n              [7, -8, 9]]\n    Output: 20\n\n    The maximum sum of a submatrix is obtained by selecting the cells [5, 6],\n    [7, -8], and [9], which gives a sum of 20.\n    \"\"\"\n\n    if not matrix or not matrix[0]:\n        return 0\n    \n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    prefix_sum = [[0] * (cols+1) for _ in range(rows+1)]\n    \n    for i in range(1, rows+1):\n        for j in range(1, cols+1):\n            prefix_sum[i][j] = prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1] + matrix[i-1][j-1]\n    \n    max_sum = float('-inf')\n    \n    for i in range(rows):\n        for j in range(cols):\n            for k in range(i+1, rows+1):\n                for l in range(j+1, cols+1):\n                    submatrix_sum = prefix_sum[k][l] - prefix_sum[i][l] - prefix_sum[k][j] + prefix_sum[i][j]\n                    max_sum = max(max_sum, submatrix_sum)\n    \n    return max_sum", "solution_func": "def g():\n    matrix = [[1, 2, -3],\n              [-4, 5, 6],\n              [7, -8, 9]]\n    return matrix", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> List[str]:\n    \"\"\"\n    Given a string s, return all possible substrings of s that are palindromes.\n\n    Example:\n    s = \"aab\"\n    Output: [\"a\", \"a\", \"b\", \"aa\"]\n\n    The palindromic substrings are \"a\", \"a\", \"b\", and \"aa\".\n    \"\"\"\n\n    def is_palindrome(substring):\n        return substring == substring[::-1]\n\n    substrings = []\n    \n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            substring = s[i:j]\n            if is_palindrome(substring):\n                substrings.append(substring)\n    \n    return substrings\n\ndef g():\n    s = \"aab\"\n    return s\n\nassert f(g()) == [\"a\", \"a\", \"b\", \"aa\"]\n\n", "emb": null, "idx_generation": 349, "target_skills": [0, 1, 0, 0, 0, 1, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> List[str]:\n    \"\"\"\n    Given a string s, return all possible substrings of s that are palindromes.\n\n    Example:\n    s = \"aab\"\n    Output: [\"a\", \"a\", \"b\", \"aa\"]\n\n    The palindromic substrings are \"a\", \"a\", \"b\", and \"aa\".\n    \"\"\"\n\n    def is_palindrome(substring):\n        return substring == substring[::-1]\n\n    substrings = []\n    \n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            substring = s[i:j]\n            if is_palindrome(substring):\n                substrings.append(substring)\n    \n    return substrings", "solution_func": "def g():\n    s = \"aab\"\n    return s", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the nth number in the Fibonacci sequence.\n\n    Example:\n    n = 6\n    Output: 8\n\n    The Fibonacci sequence is [0, 1, 1, 2, 3, 5, 8]. The 6th number is 8.\n    \"\"\"\n\n    if n <= 1:\n        return n\n    \n    fib = [0, 1]\n    \n    for i in range(2, n+1):\n        fib.append(fib[i-1] + fib[i-2])\n    \n    return fib[n]\n\ndef g():\n    n = 6\n    return n\n\nassert f(g()) == 8\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 349, "target_skills": [1, 1, 0, 1, 0, 0, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the nth number in the Fibonacci sequence.\n\n    Example:\n    n = 6\n    Output: 8\n\n    The Fibonacci sequence is [0, 1, 1, 2, 3, 5, 8]. The 6th number is 8.\n    \"\"\"\n\n    if n <= 1:\n        return n\n    \n    fib = [0, 1]\n    \n    for i in range(2, n+1):\n        fib.append(fib[i-1] + fib[i-2])\n    \n    return fib[n]", "solution_func": "def g():\n    n = 6\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, determine if there are two numbers in the list that sum up to the target.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    Sample Output:\n    True\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5], 7\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 349, "target_skills": [1, 0, 0, 1, 1, 1, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, determine if there are two numbers in the list that sum up to the target.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    Sample Output:\n    True\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g():\n    return [1, 2, 3, 4, 5], 7", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of all previous elements in the original list.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n\n    Sample Output:\n    [1, 3, 6, 10, 15]\n    \"\"\"\n\n    result = []\n    running_sum = 0\n\n    for num in nums:\n        running_sum += num\n        result.append(running_sum)\n\n    return result\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(*g()) == [1, 3, 6, 10, 15]\n", "emb": null, "idx_generation": 349, "target_skills": [1, 1, 0, 1, 1, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of all previous elements in the original list.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n\n    Sample Output:\n    [1, 3, 6, 10, 15]\n    \"\"\"\n\n    result = []\n    running_sum = 0\n\n    for num in nums:\n        running_sum += num\n        result.append(running_sum)\n\n    return result", "solution_func": "def g():\n    return [1, 2, 3, 4, 5]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, pattern: str) -> int:\n    \"\"\"\n    Given a string and a pattern, find the minimum number of characters to be replaced in the string to match the pattern.\n\n    Sample Input:\n    s = \"abcabc\"\n    pattern = \"ab\"\n\n    Sample Output:\n    2\n    \"\"\"\n\n    count = 0\n    i = 0\n\n    while i < len(s):\n        if s[i:i+len(pattern)] != pattern:\n            count += 1\n            i += len(pattern)\n        else:\n            i += 1\n\n    return count\n\ndef g():\n    return \"abcabc\", \"ab\"\n\nassert f(*g()) == 2\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 349, "target_skills": [0, 0, 0, 1, 1, 0, 0, 0, 1, 1], "problem_func": "from typing import*\ndef f(s: str, pattern: str) -> int:\n    \"\"\"\n    Given a string and a pattern, find the minimum number of characters to be replaced in the string to match the pattern.\n\n    Sample Input:\n    s = \"abcabc\"\n    pattern = \"ab\"\n\n    Sample Output:\n    2\n    \"\"\"\n\n    count = 0\n    i = 0\n\n    while i < len(s):\n        if s[i:i+len(pattern)] != pattern:\n            count += 1\n            i += len(pattern)\n        else:\n            i += 1\n\n    return count", "solution_func": "def g():\n    return \"abcabc\", \"ab\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of inversions in the list.\n    An inversion occurs when two elements at indices i and j in the list satisfy the condition nums[i] > nums[j] and i < j.\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] > nums[j]:\n                count += 1\n    return count\n\ndef g(nums=[5, 3, 2, 4, 1]):\n    return nums\n\nassert f(g()) == 8\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 349, "target_skills": [1, 0, 0, 1, 1, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of inversions in the list.\n    An inversion occurs when two elements at indices i and j in the list satisfy the condition nums[i] > nums[j] and i < j.\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] > nums[j]:\n                count += 1\n    return count", "solution_func": "def g(nums=[5, 3, 2, 4, 1]):\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the list.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation:\n    The sum of nums[0] and nums[1] is 2 + 7 = 9, which is the target value.\n    Therefore, the indices of the two numbers are [0, 1].\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g(nums: List[int] = [2, 7, 11, 15], target: int = 9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 350, "target_skills": [1, 1, 0, 0, 0, 1, 1, 1, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the list.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation:\n    The sum of nums[0] and nums[1] is 2 + 7 = 9, which is the target value.\n    Therefore, the indices of the two numbers are [0, 1].\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []", "solution_func": "def g(nums: List[int] = [2, 7, 11, 15], target: int = 9):\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the minimum path sum from the top-left corner to the bottom-right\n    corner. You can only move down or right at any point in time.\n\n    Example:\n    Input:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 7\n\n    Explanation:\n    The minimum path sum is 1 + 3 + 1 + 1 + 1 = 7.\n    \"\"\"\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g(grid: List[List[int]] = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(*g()) == 7\n", "emb": null, "idx_generation": 350, "target_skills": [0, 0, 0, 1, 0, 1, 1, 0, 1, 0], "problem_func": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the minimum path sum from the top-left corner to the bottom-right\n    corner. You can only move down or right at any point in time.\n\n    Example:\n    Input:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 7\n\n    Explanation:\n    The minimum path sum is 1 + 3 + 1 + 1 + 1 = 7.\n    \"\"\"\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g(grid: List[List[int]] = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given an array of non-negative integers, you are initially positioned at the first index of the array.\n    Each element in the array represents your maximum jump length at that position.\n    Determine if you are able to reach the last index.\n\n    Example:\n    Input: nums = [2, 3, 1, 1, 4]\n    Output: True\n\n    Explanation:\n    Jump 1 step from index 0 to 1, then 3 steps to the last index.\n    \"\"\"\n    if not nums:\n        return False\n\n    n = len(nums)\n    dp = [False] * n\n    dp[0] = True\n\n    for i in range(1, n):\n        for j in range(i):\n            if dp[j] and j + nums[j] >= i:\n                dp[i] = True\n                break\n\n    return dp[n-1]\n\ndef g(nums: List[int] = [2, 3, 1, 1, 4], target: int = 4):\n    return nums, target\n\nassert f(*g())\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 350, "target_skills": [0, 1, 1, 0, 0, 1, 0, 1, 1, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given an array of non-negative integers, you are initially positioned at the first index of the array.\n    Each element in the array represents your maximum jump length at that position.\n    Determine if you are able to reach the last index.\n\n    Example:\n    Input: nums = [2, 3, 1, 1, 4]\n    Output: True\n\n    Explanation:\n    Jump 1 step from index 0 to 1, then 3 steps to the last index.\n    \"\"\"\n    if not nums:\n        return False\n\n    n = len(nums)\n    dp = [False] * n\n    dp[0] = True\n\n    for i in range(1, n):\n        for j in range(i):\n            if dp[j] and j + nums[j] >= i:\n                dp[i] = True\n                break\n\n    return dp[n-1]", "solution_func": "def g(nums: List[int] = [2, 3, 1, 1, 4], target: int = 4):\n    return nums, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, k: int, words: List[str]) -> bool:\n    \"\"\"\n    Given a string s, an integer k, and a list of words, determine if it is possible to construct\n    the string s by concatenating k number of words from the list.\n\n    Sample Input:\n    s = \"leetcode\"\n    k = 3\n    words = [\"leet\", \"code\", \"is\", \"awesome\"]\n\n    Sample Output:\n    True\n    \"\"\"\n    def dfs(s: str, words: List[str], visited: List[bool], k: int) -> bool:\n        if len(s) == 0 and k == 0:\n            return True\n\n        for i in range(len(words)):\n            if not visited[i] and words[i] in s[:len(words[i])]:\n                visited[i] = True\n                if dfs(s[len(words[i]):], words, visited, k-1):\n                    return True\n                visited[i] = False\n        \n        return False\n    \n    visited = [False] * len(words)\n    return dfs(s, words, visited, k)\n\ndef g():\n    s = \"leetcode\"\n    k = 3\n    words = [\"leet\", \"code\", \"is\", \"awesome\"]\n    return s, k, words\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 350, "target_skills": [1, 0, 1, 1, 1, 1, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str, k: int, words: List[str]) -> bool:\n    \"\"\"\n    Given a string s, an integer k, and a list of words, determine if it is possible to construct\n    the string s by concatenating k number of words from the list.\n\n    Sample Input:\n    s = \"leetcode\"\n    k = 3\n    words = [\"leet\", \"code\", \"is\", \"awesome\"]\n\n    Sample Output:\n    True\n    \"\"\"\n    def dfs(s: str, words: List[str], visited: List[bool], k: int) -> bool:\n        if len(s) == 0 and k == 0:\n            return True\n\n        for i in range(len(words)):\n            if not visited[i] and words[i] in s[:len(words[i])]:\n                visited[i] = True\n                if dfs(s[len(words[i]):], words, visited, k-1):\n                    return True\n                visited[i] = False\n        \n        return False\n    \n    visited = [False] * len(words)\n    return dfs(s, words, visited, k)", "solution_func": "def g():\n    s = \"leetcode\"\n    k = 3\n    words = [\"leet\", \"code\", \"is\", \"awesome\"]\n    return s, k, words", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, nums: List[int]) -> int:\n    \"\"\"\n    Given an integer n and a list of integers, find the maximum sum of any contiguous subarray of size n.\n\n    Sample Input:\n    n = 3\n    nums = [1, -2, 3, 4, -8, 10]\n\n    Sample Output:\n    17\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for i in range(len(nums)):\n        curr_sum += nums[i]\n        if i >= n:\n            curr_sum -= nums[i-n]\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum\n\ndef g():\n    n = 3\n    nums = [1, -2, 3, 4, -8, 10]\n    return n, nums\n\nassert f(*g()) == 17\n", "emb": null, "idx_generation": 350, "target_skills": [0, 1, 0, 0, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, nums: List[int]) -> int:\n    \"\"\"\n    Given an integer n and a list of integers, find the maximum sum of any contiguous subarray of size n.\n\n    Sample Input:\n    n = 3\n    nums = [1, -2, 3, 4, -8, 10]\n\n    Sample Output:\n    17\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for i in range(len(nums)):\n        curr_sum += nums[i]\n        if i >= n:\n            curr_sum -= nums[i-n]\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum", "solution_func": "def g():\n    n = 3\n    nums = [1, -2, 3, 4, -8, 10]\n    return n, nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of any path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Sample Input:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\n    Sample Output:\n    12\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n\n    for i in range(1, m):\n        grid[i][0] += grid[i-1][0]\n    \n    for j in range(1, n):\n        grid[0][j] += grid[0][j-1]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            grid[i][j] += max(grid[i-1][j], grid[i][j-1])\n    \n    return grid[m-1][n-1]\n\ndef g():\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n    return grid\n\nassert f(*g()) == 12\n", "emb": null, "idx_generation": 350, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of any path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Sample Input:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\n    Sample Output:\n    12\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n\n    for i in range(1, m):\n        grid[i][0] += grid[i-1][0]\n    \n    for j in range(1, n):\n        grid[0][j] += grid[0][j-1]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            grid[i][j] += max(grid[i-1][j], grid[i][j-1])\n    \n    return grid[m-1][n-1]", "solution_func": "def g():\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(word: str, dictionary: List[str]) -> bool:\n    \"\"\"\n    Given a word and a dictionary, determine if it can be formed by concatenating words from the dictionary.\n    The same word in the dictionary may be reused multiple times.\n    Return True if the word can be formed, and False otherwise.\n    \"\"\"\n\n    def can_form_word(word, dictionary, memo):\n        if word in memo:\n            return memo[word]\n        \n        if word in dictionary:\n            memo[word] = True\n            return True\n        \n        for i in range(1, len(word)):\n            prefix = word[:i]\n            if prefix in dictionary and can_form_word(word[i:], dictionary, memo):\n                memo[word] = True\n                return True\n        \n        memo[word] = False\n        return False\n\n    return can_form_word(word, dictionary, {})\n\n\ndef g(word: str = \"leetcode\", dictionary: List[str] = [\"leet\", \"code\"]):\n    return word, dictionary\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 350, "target_skills": [0, 1, 1, 0, 0, 0, 1, 0, 1, 0], "problem_func": "from typing import*\n\ndef f(word: str, dictionary: List[str]) -> bool:\n    \"\"\"\n    Given a word and a dictionary, determine if it can be formed by concatenating words from the dictionary.\n    The same word in the dictionary may be reused multiple times.\n    Return True if the word can be formed, and False otherwise.\n    \"\"\"\n\n    def can_form_word(word, dictionary, memo):\n        if word in memo:\n            return memo[word]\n        \n        if word in dictionary:\n            memo[word] = True\n            return True\n        \n        for i in range(1, len(word)):\n            prefix = word[:i]\n            if prefix in dictionary and can_form_word(word[i:], dictionary, memo):\n                memo[word] = True\n                return True\n        \n        memo[word] = False\n        return False\n\n    return can_form_word(word, dictionary, {})", "solution_func": "def g(word: str = \"leetcode\", dictionary: List[str] = [\"leet\", \"code\"]):\n    return word, dictionary", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array of distinct integers nums and a target integer target, \n    return a list of all unique combinations of nums where the chosen numbers sum to target.\n    You may return the combinations in any order.\n    The same number may be chosen from nums an unlimited number of times.\n    Two combinations are unique if the frequency of at least one of the chosen numbers is different.\n    It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\n\n    Example:\n    Input: nums = [2,3,6,7], target = 7\n    Output: [[2,2,3],[7]]\n\n    Input: nums = [2,3,5], target = 8\n    Output: [[2,2,2,2],[2,3,3],[3,5]]\n    \"\"\"\n\n    def combination_sum(nums, target, path, result):\n        if target == 0:\n            result.append(path)\n            return\n        \n        if target < 0:\n            return\n        \n        for i in range(len(nums)):\n            num = nums[i]\n            combination_sum(nums[i:], target - num, path + [num], result)\n\n    result = []\n    combination_sum(nums, target, [], result)\n    return result\n\n\ndef g(nums: List[int] = [2, 3, 6, 7], target: int = 7):\n    return nums, target\n\nassert f(*g()) == [[2, 2, 3], [7]]\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 350, "target_skills": [1, 0, 0, 1, 1, 1, 1, 1, 1, 1], "problem_func": "from typing import*\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array of distinct integers nums and a target integer target, \n    return a list of all unique combinations of nums where the chosen numbers sum to target.\n    You may return the combinations in any order.\n    The same number may be chosen from nums an unlimited number of times.\n    Two combinations are unique if the frequency of at least one of the chosen numbers is different.\n    It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\n\n    Example:\n    Input: nums = [2,3,6,7], target = 7\n    Output: [[2,2,3],[7]]\n\n    Input: nums = [2,3,5], target = 8\n    Output: [[2,2,2,2],[2,3,3],[3,5]]\n    \"\"\"\n\n    def combination_sum(nums, target, path, result):\n        if target == 0:\n            result.append(path)\n            return\n        \n        if target < 0:\n            return\n        \n        for i in range(len(nums)):\n            num = nums[i]\n            combination_sum(nums[i:], target - num, path + [num], result)\n\n    result = []\n    combination_sum(nums, target, [], result)\n    return result", "solution_func": "def g(nums: List[int] = [2, 3, 6, 7], target: int = 7):\n    return nums, target", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a 2D grid of '1's (land) and '0's (water), count the number of islands.\n    An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.\n    You may assume all four edges of the grid are all surrounded by water.\n\n    Example:\n    Input:\n    grid = [\n        [\"1\",\"1\",\"1\",\"1\",\"0\"],\n        [\"1\",\"1\",\"0\",\"1\",\"0\"],\n        [\"1\",\"1\",\"0\",\"0\",\"0\"],\n        [\"0\",\"0\",\"0\",\"0\",\"0\"]\n    ]\n    Output: 1\n\n    Input:\n    grid = [\n        [\"1\",\"1\",\"0\",\"0\",\"0\"],\n        [\"1\",\"1\",\"0\",\"0\",\"0\"],\n        [\"0\",\"0\",\"1\",\"0\",\"0\"],\n        [\"0\",\"0\",\"0\",\"1\",\"1\"]\n    ]\n    Output: 3\n    \"\"\"\n\n    def dfs(grid, i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0':\n            return\n        \n        grid[i][j] = '0'\n        dfs(grid, i+1, j)\n        dfs(grid, i-1, j)\n        dfs(grid, i, j+1)\n        dfs(grid, i, j-1)\n\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == '1':\n                count += 1\n                dfs(grid, i, j)\n    \n    return count\n\n\ndef g(grid: List[List[str]] = [[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]):\n    return grid\n\nassert f(*g()) == 1\n\n", "emb": null, "idx_generation": 350, "target_skills": [0, 1, 1, 0, 1, 0, 0, 1, 0, 0], "problem_func": "from typing import*\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a 2D grid of '1's (land) and '0's (water), count the number of islands.\n    An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.\n    You may assume all four edges of the grid are all surrounded by water.\n\n    Example:\n    Input:\n    grid = [\n        [\"1\",\"1\",\"1\",\"1\",\"0\"],\n        [\"1\",\"1\",\"0\",\"1\",\"0\"],\n        [\"1\",\"1\",\"0\",\"0\",\"0\"],\n        [\"0\",\"0\",\"0\",\"0\",\"0\"]\n    ]\n    Output: 1\n\n    Input:\n    grid = [\n        [\"1\",\"1\",\"0\",\"0\",\"0\"],\n        [\"1\",\"1\",\"0\",\"0\",\"0\"],\n        [\"0\",\"0\",\"1\",\"0\",\"0\"],\n        [\"0\",\"0\",\"0\",\"1\",\"1\"]\n    ]\n    Output: 3\n    \"\"\"\n\n    def dfs(grid, i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0':\n            return\n        \n        grid[i][j] = '0'\n        dfs(grid, i+1, j)\n        dfs(grid, i-1, j)\n        dfs(grid, i, j+1)\n        dfs(grid, i, j-1)\n\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == '1':\n                count += 1\n                dfs(grid, i, j)\n    \n    return count", "solution_func": "def g(grid: List[List[str]] = [[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]):\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum subarray XOR.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    7\n\n    Explanation:\n    The maximum subarray XOR is achieved by selecting the subarray [3, 4] with XOR value of 7.\n\n    Hint: Use a Trie data structure to store the XOR values of subarrays.\n    \"\"\"\n\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n\n    def insert(num, root):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def findMaxXor(num, root):\n        node = root\n        xor = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if 1 - bit in node.children:\n                xor |= (1 << i)\n                node = node.children[1 - bit]\n            else:\n                node = node.children[bit]\n        return xor\n\n    root = TrieNode()\n    max_xor = 0\n    pre_xor = 0\n\n    for num in nums:\n        pre_xor ^= num\n        insert(pre_xor, root)\n        max_xor = max(max_xor, findMaxXor(pre_xor, root))\n\n    return max_xor\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return [nums]\n\nassert f(*g()) == 7\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0], "idx_generation": 350, "target_skills": [0, 1, 0, 1, 1, 0, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum subarray XOR.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    7\n\n    Explanation:\n    The maximum subarray XOR is achieved by selecting the subarray [3, 4] with XOR value of 7.\n\n    Hint: Use a Trie data structure to store the XOR values of subarrays.\n    \"\"\"\n\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n\n    def insert(num, root):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def findMaxXor(num, root):\n        node = root\n        xor = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if 1 - bit in node.children:\n                xor |= (1 << i)\n                node = node.children[1 - bit]\n            else:\n                node = node.children[bit]\n        return xor\n\n    root = TrieNode()\n    max_xor = 0\n    pre_xor = 0\n\n    for num in nums:\n        pre_xor ^= num\n        insert(pre_xor, root)\n        max_xor = max(max_xor, findMaxXor(pre_xor, root))\n\n    return max_xor", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return [nums]", "map_ix": [1, 0, 1, 0, 0, 0, 1, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique combinations of three numbers that sum up to zero.\n\n    Example:\n    nums = [-1, 0, 1, 2, -1, -4]\n\n    Output:\n    2\n\n    Explanation:\n    The unique combinations that sum up to zero are [-1, 0, 1] and [-1, -1, 2].\n\n    Hint: Use sorting and two-pointer technique to find the combinations.\n    \"\"\"\n    nums.sort()\n    count = 0\n    n = len(nums)\n    for i in range(n - 2):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        left = i + 1\n        right = n - 1\n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n            if total < 0:\n                left += 1\n            elif total > 0:\n                right -= 1\n            else:\n                count += 1\n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                left += 1\n                right -= 1\n    return count\n\ndef g(nums=[-1, 0, 1, 2, -1, -4]):\n    return nums\n\nassert f(g()) == 2\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 351, "target_skills": [1, 1, 0, 0, 1, 0, 0, 1, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique combinations of three numbers that sum up to zero.\n\n    Example:\n    nums = [-1, 0, 1, 2, -1, -4]\n\n    Output:\n    2\n\n    Explanation:\n    The unique combinations that sum up to zero are [-1, 0, 1] and [-1, -1, 2].\n\n    Hint: Use sorting and two-pointer technique to find the combinations.\n    \"\"\"\n    nums.sort()\n    count = 0\n    n = len(nums)\n    for i in range(n - 2):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        left = i + 1\n        right = n - 1\n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n            if total < 0:\n                left += 1\n            elif total > 0:\n                right -= 1\n            else:\n                count += 1\n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                left += 1\n                right -= 1\n    return count", "solution_func": "def g(nums=[-1, 0, 1, 2, -1, -4]):\n    return nums", "map_ix": [1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    Output:\n    4\n\n    Explanation:\n    The longest increasing subsequence is [2, 3, 7, 101].\n\n    Hint: Use dynamic programming to store the lengths of increasing subsequences.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g(nums=[10, 9, 2, 5, 3, 7, 101, 18]):\n    return nums\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 351, "target_skills": [0, 1, 1, 1, 1, 0, 0, 1, 1, 0], "problem_func": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    Output:\n    4\n\n    Explanation:\n    The longest increasing subsequence is [2, 3, 7, 101].\n\n    Hint: Use dynamic programming to store the lengths of increasing subsequences.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "solution_func": "def g(nums=[10, 9, 2, 5, 3, 7, 101, 18]):\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of subarrays with an odd sum.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    9\n\n    Explanation:\n    The subarrays with an odd sum are [1], [1, 2, 3], [1, 2, 3, 4, 5], [1, 2], [1, 2, 3, 4], [1, 2, 3, 4, 5], [3], [3, 4, 5], [5].\n\n    Hint: Use counting and prefix sum techniques to find the subarrays.\n    \"\"\"\n    count = 0\n    prefix_sum = 0\n    prefix_sum_count = [0] * 2\n    prefix_sum_count[prefix_sum % 2] += 1\n    for num in nums:\n        prefix_sum += num\n        count += prefix_sum_count[prefix_sum % 2]\n        prefix_sum_count[prefix_sum % 2] += 1\n    return count\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g()) == 9\n", "emb": null, "idx_generation": 351, "target_skills": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of subarrays with an odd sum.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    9\n\n    Explanation:\n    The subarrays with an odd sum are [1], [1, 2, 3], [1, 2, 3, 4, 5], [1, 2], [1, 2, 3, 4], [1, 2, 3, 4, 5], [3], [3, 4, 5], [5].\n\n    Hint: Use counting and prefix sum techniques to find the subarrays.\n    \"\"\"\n    count = 0\n    prefix_sum = 0\n    prefix_sum_count = [0] * 2\n    prefix_sum_count[prefix_sum % 2] += 1\n    for num in nums:\n        prefix_sum += num\n        count += prefix_sum_count[prefix_sum % 2]\n        prefix_sum_count[prefix_sum % 2] += 1\n    return count", "solution_func": "def g(nums=[1, 2, 3, 4, 5]):\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given an array of integers 'arr' and a target integer 'target', determine if there exists a subset of 'arr' that sums up to 'target'.\n\n    Return True if such subset exists, False otherwise.\n\n    Example:\n    arr = [1, 5, 3, 9, 2]\n    target = 8\n\n    Output:\n    True\n\n    Explanation:\n    The subset [1, 3, 2] sums up to the target 8.\n    \"\"\"\n\n    def subset_sum(arr, target, n):\n        if target == 0:\n            return True\n        if n == 0:\n            return False\n        if arr[n-1] > target:\n            return subset_sum(arr, target, n-1)\n        return subset_sum(arr, target, n-1) or subset_sum(arr, target-arr[n-1], n-1)\n\n    return subset_sum(arr, target, len(arr))\n\ndef g(arr=[1, 5, 3, 9, 2], target=8):\n    \"\"\"\n    Generate an array 'arr' and target integer 'target'.\n    \"\"\"\n    return arr, target\n\nassert f(*g()) == True\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 351, "target_skills": [1, 1, 0, 1, 0, 0, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given an array of integers 'arr' and a target integer 'target', determine if there exists a subset of 'arr' that sums up to 'target'.\n\n    Return True if such subset exists, False otherwise.\n\n    Example:\n    arr = [1, 5, 3, 9, 2]\n    target = 8\n\n    Output:\n    True\n\n    Explanation:\n    The subset [1, 3, 2] sums up to the target 8.\n    \"\"\"\n\n    def subset_sum(arr, target, n):\n        if target == 0:\n            return True\n        if n == 0:\n            return False\n        if arr[n-1] > target:\n            return subset_sum(arr, target, n-1)\n        return subset_sum(arr, target, n-1) or subset_sum(arr, target-arr[n-1], n-1)\n\n    return subset_sum(arr, target, len(arr))", "solution_func": "def g(arr=[1, 5, 3, 9, 2], target=8):\n    \"\"\"\n    Generate an array 'arr' and target integer 'target'.\n    \"\"\"\n    return arr, target", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers 'nums', determine if it can be partitioned into two subsets such that the sum of elements in both subsets is equal.\n\n    Return True if such partition exists, False otherwise.\n\n    Example:\n    nums = [1, 5, 11, 5]\n\n    Output:\n    True\n\n    Explanation:\n    The list can be partitioned into [1, 5, 5] and [11], where the sum of elements in both subsets is 11.\n    \"\"\"\n\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n\n    target_sum = total_sum // 2\n    n = len(nums)\n\n    dp = [[False] * (target_sum + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target_sum + 1):\n            if nums[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[n][target_sum]\n\ndef g(nums=[1, 5, 11, 5]):\n    \"\"\"\n    Generate a list of integers 'nums'.\n    \"\"\"\n    return nums\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 351, "target_skills": [0, 1, 0, 1, 0, 1, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers 'nums', determine if it can be partitioned into two subsets such that the sum of elements in both subsets is equal.\n\n    Return True if such partition exists, False otherwise.\n\n    Example:\n    nums = [1, 5, 11, 5]\n\n    Output:\n    True\n\n    Explanation:\n    The list can be partitioned into [1, 5, 5] and [11], where the sum of elements in both subsets is 11.\n    \"\"\"\n\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n\n    target_sum = total_sum // 2\n    n = len(nums)\n\n    dp = [[False] * (target_sum + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target_sum + 1):\n            if nums[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[n][target_sum]", "solution_func": "def g(nums=[1, 5, 11, 5]):\n    \"\"\"\n    Generate a list of integers 'nums'.\n    \"\"\"\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers 'matrix', determine if there exists a path from the top-left cell to the bottom-right cell, such that the sum of numbers along the path equals a given target.\n\n    Return True if such path exists, False otherwise.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    target = 17\n\n    Output:\n    True\n\n    Explanation:\n    The path from top-left to bottom-right that sums up to the target 17 is: 1 -> 4 -> 7 -> 8 -> 9.\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    def dfs(row, col, target):\n        if row < 0 or col < 0 or row >= rows or col >= cols:\n            return False\n        if matrix[row][col] == target:\n            return True\n        return dfs(row + 1, col, target - matrix[row][col]) or dfs(row, col + 1, target - matrix[row][col])\n\n    return dfs(0, 0, matrix[rows-1][cols-1])\n\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]], target=17):\n    \"\"\"\n    Generate a matrix of integers 'matrix' and target integer 'target'.\n    \"\"\"\n    return matrix, target\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 351, "target_skills": [1, 0, 1, 1, 1, 0, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers 'matrix', determine if there exists a path from the top-left cell to the bottom-right cell, such that the sum of numbers along the path equals a given target.\n\n    Return True if such path exists, False otherwise.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    target = 17\n\n    Output:\n    True\n\n    Explanation:\n    The path from top-left to bottom-right that sums up to the target 17 is: 1 -> 4 -> 7 -> 8 -> 9.\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    def dfs(row, col, target):\n        if row < 0 or col < 0 or row >= rows or col >= cols:\n            return False\n        if matrix[row][col] == target:\n            return True\n        return dfs(row + 1, col, target - matrix[row][col]) or dfs(row, col + 1, target - matrix[row][col])\n\n    return dfs(0, 0, matrix[rows-1][cols-1])", "solution_func": "def g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]], target=17):\n    \"\"\"\n    Generate a matrix of integers 'matrix' and target integer 'target'.\n    \"\"\"\n    return matrix, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list with all the words in reverse order.\n    \"\"\"\n    reversed_words = []\n    for word in words:\n        reversed_word = word[::-1]\n        reversed_words.append(reversed_word)\n    return reversed_words\n\ndef g():\n    words = ['hello', 'world', 'python']\n    return words\n\nassert f(g()) == ['olleh', 'dlrow', 'nohtyp']\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 351, "target_skills": [0, 0, 0, 1, 0, 1, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list with all the words in reverse order.\n    \"\"\"\n    reversed_words = []\n    for word in words:\n        reversed_word = word[::-1]\n        reversed_words.append(reversed_word)\n    return reversed_words", "solution_func": "def g():\n    words = ['hello', 'world', 'python']\n    return words", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Count the number of vowels (a, e, i, o, u) in a given string and return the count.\n    \"\"\"\n    count = 0\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    for char in s:\n        if char.lower() in vowels:\n            count += 1\n    return count\n\ndef g():\n    s = 'hello world'\n    return s\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 351, "target_skills": [0, 0, 0, 0, 1, 1, 1, 1, 0, 1], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Count the number of vowels (a, e, i, o, u) in a given string and return the count.\n    \"\"\"\n    count = 0\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    for char in s:\n        if char.lower() in vowels:\n            count += 1\n    return count", "solution_func": "def g():\n    s = 'hello world'\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if a given string is a palindrome.\n    Return True if the string is a palindrome, otherwise return False.\n    \"\"\"\n    reversed_s = s[::-1]\n    if s == reversed_s:\n        return True\n    else:\n        return False\n\ndef g():\n    s = 'racecar'\n    return s\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 351, "target_skills": [1, 1, 1, 1, 1, 1, 0, 1, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if a given string is a palindrome.\n    Return True if the string is a palindrome, otherwise return False.\n    \"\"\"\n    reversed_s = s[::-1]\n    if s == reversed_s:\n        return True\n    else:\n        return False", "solution_func": "def g():\n    s = 'racecar'\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list containing only the even numbers from the original list.\n    \"\"\"\n    return [num for num in nums if num % 2 == 0]\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == [2, 4, 6, 8, 10]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 351, "target_skills": [0, 1, 0, 0, 1, 0, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list containing only the even numbers from the original list.\n    \"\"\"\n    return [num for num in nums if num % 2 == 0]", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode, target: int) -> List[List[int]]:\n    \"\"\"\n    Given a binary tree and a target sum, find all paths in the tree that add up to the target sum.\n    Each path should be represented by a list of values from root to leaf.\n\n    Example:\n    Input:\n         1\n        / \\\n       2   3\n      / \\\n     4   5\n     \n    Target: 7\n\n    Output:\n    [[1, 2, 4], [1, 3, 3]]\n    \"\"\"\n    def dfs(node, curr_path, curr_sum, res):\n        if node is None:\n            return\n        curr_path.append(node.val)\n        curr_sum += node.val\n        \n        if curr_sum == target and node.left is None and node.right is None:\n            res.append(list(curr_path))\n        \n        dfs(node.left, curr_path, curr_sum, res)\n        dfs(node.right, curr_path, curr_sum, res)\n        \n        curr_path.pop()\n        curr_sum -= node.val\n    \n    res = []\n    dfs(root, [], 0, res)\n    return res\n\ndef g():\n    # Creating the binary tree from the example\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n\n    target = 7\n\n    return root, target\n\nassert f(*g()) == [[1, 2, 4], [1, 3, 3]]\n", "emb": null, "idx_generation": 352, "target_skills": [0, 0, 1, 0, 0, 0, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode, target: int) -> List[List[int]]:\n    \"\"\"\n    Given a binary tree and a target sum, find all paths in the tree that add up to the target sum.\n    Each path should be represented by a list of values from root to leaf.\n\n    Example:\n    Input:\n         1\n        / \\\n       2   3\n      / \\\n     4   5\n     \n    Target: 7\n\n    Output:\n    [[1, 2, 4], [1, 3, 3]]\n    \"\"\"\n    def dfs(node, curr_path, curr_sum, res):\n        if node is None:\n            return\n        curr_path.append(node.val)\n        curr_sum += node.val\n        \n        if curr_sum == target and node.left is None and node.right is None:\n            res.append(list(curr_path))\n        \n        dfs(node.left, curr_path, curr_sum, res)\n        dfs(node.right, curr_path, curr_sum, res)\n        \n        curr_path.pop()\n        curr_sum -= node.val\n    \n    res = []\n    dfs(root, [], 0, res)\n    return res", "solution_func": "def g():\n    # Creating the binary tree from the example\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n\n    target = 7\n\n    return root, target", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the length of the shortest path from the top left corner to the bottom right corner.\n    You can only move right or down.\n\n    Example:\n    Input:\n    [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output: 7\n    Explanation: The path with minimum sum is 1 -> 3 -> 1 -> 1 -> 1, which gives a sum of 7.\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    \n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, m):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[n-1][m-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    return grid\n\nassert f(*g()) == 7\n", "emb": null, "idx_generation": 352, "target_skills": [0, 1, 0, 1, 1, 0, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the length of the shortest path from the top left corner to the bottom right corner.\n    You can only move right or down.\n\n    Example:\n    Input:\n    [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output: 7\n    Explanation: The path with minimum sum is 1 -> 3 -> 1 -> 1 -> 1, which gives a sum of 7.\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    \n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, m):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[n-1][m-1]", "solution_func": "def g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed acyclic graph (DAG) represented as an adjacency list and two nodes, start and end, determine if\n    there exists a path from start to end in the graph.\n\n    Example:\n    Input:\n    graph = [\n        [1, 2],\n        [3],\n        [3],\n        []\n    ]\n    start = 0\n    end = 3\n\n    Output: True\n    Explanation: There is a path from node 0 to node 3: 0 -> 2 -> 3.\n    \"\"\"\n    visited = set()\n    \n    def dfs(node):\n        if node == end:\n            return True\n        \n        visited.add(node)\n        \n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n        \n        return False\n    \n    return dfs(start)\n\ndef g():\n    graph = [\n        [1, 2],\n        [3],\n        [3],\n        []\n    ]\n    start = 0\n    end = 3\n\n    return graph, start, end\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0], "idx_generation": 352, "target_skills": [0, 0, 1, 1, 1, 0, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed acyclic graph (DAG) represented as an adjacency list and two nodes, start and end, determine if\n    there exists a path from start to end in the graph.\n\n    Example:\n    Input:\n    graph = [\n        [1, 2],\n        [3],\n        [3],\n        []\n    ]\n    start = 0\n    end = 3\n\n    Output: True\n    Explanation: There is a path from node 0 to node 3: 0 -> 2 -> 3.\n    \"\"\"\n    visited = set()\n    \n    def dfs(node):\n        if node == end:\n            return True\n        \n        visited.add(node)\n        \n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n        \n        return False\n    \n    return dfs(start)", "solution_func": "def g():\n    graph = [\n        [1, 2],\n        [3],\n        [3],\n        []\n    ]\n    start = 0\n    end = 3\n\n    return graph, start, end", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 1]}, {"fitness": 1.0, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of trailing zeros in n!.\n\n    Example:\n    n = 5\n\n    Output:\n    1\n\n    Explanation:\n    5! = 5 * 4 * 3 * 2 * 1 = 120.\n    The number 120 has 1 trailing zero.\n    \"\"\"\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n    \n    return count\n\ndef g() -> int:\n    \"\"\"\n    Generate a random positive integer.\n    \"\"\"\n    return 20\n\nassert f(g()) == 4\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 352, "target_skills": [0, 1, 1, 1, 0, 1, 0, 1, 1, 0], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of trailing zeros in n!.\n\n    Example:\n    n = 5\n\n    Output:\n    1\n\n    Explanation:\n    5! = 5 * 4 * 3 * 2 * 1 = 120.\n    The number 120 has 1 trailing zero.\n    \"\"\"\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n    \n    return count", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a random positive integer.\n    \"\"\"\n    return 20", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, return a pair of distinct indices (i, j) such that\n    nums[i] + nums[j] is closest to the target. If there are multiple pairs with the same sum, return\n    the pair with the smallest absolute difference.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    Output:\n    (2, 3)\n\n    Explanation:\n    The pair (2, 3) has a sum of 3 + 4 = 7, which is the closest to the target 7.\n    \"\"\"\n    nums.sort()\n    closest_sum = float('inf')\n    pair = (0, 0)\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return (left, right)\n        \n        if abs(current_sum - target) < abs(closest_sum - target):\n            closest_sum = current_sum\n            pair = (left, right)\n        \n        if current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return pair\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a random list of integers and a random target number.\n    \"\"\"\n    return [1, 2, 3, 4, 5], 7\n\nassert f(*g()) == (2, 3)\n\n\n", "emb": null, "idx_generation": 352, "target_skills": [1, 1, 1, 0, 1, 0, 1, 1, 1, 0], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, return a pair of distinct indices (i, j) such that\n    nums[i] + nums[j] is closest to the target. If there are multiple pairs with the same sum, return\n    the pair with the smallest absolute difference.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    Output:\n    (2, 3)\n\n    Explanation:\n    The pair (2, 3) has a sum of 3 + 4 = 7, which is the closest to the target 7.\n    \"\"\"\n    nums.sort()\n    closest_sum = float('inf')\n    pair = (0, 0)\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return (left, right)\n        \n        if abs(current_sum - target) < abs(closest_sum - target):\n            closest_sum = current_sum\n            pair = (left, right)\n        \n        if current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return pair", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a random list of integers and a random target number.\n    \"\"\"\n    return [1, 2, 3, 4, 5], 7", "map_ix": null}, {"fitness": 1.0, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the count of total set bits in all numbers from 1 to n.\n\n    Example:\n    n = 5\n\n    Output:\n    7\n\n    Explanation:\n    The numbers from 1 to 5 (inclusive) are 1, 2, 3, 4, 5.\n    The binary representation of these numbers are 1, 10, 11, 100, 101.\n    The total count of set bits in these binary representations is 7.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        count += bin(i).count('1')\n    \n    return count\n\ndef g() -> int:\n    \"\"\"\n    Generate a random positive integer.\n    \"\"\"\n    return 10\n\nassert f(g()) == 17\n\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 352, "target_skills": [1, 1, 0, 0, 1, 1, 0, 1, 1, 1], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the count of total set bits in all numbers from 1 to n.\n\n    Example:\n    n = 5\n\n    Output:\n    7\n\n    Explanation:\n    The numbers from 1 to 5 (inclusive) are 1, 2, 3, 4, 5.\n    The binary representation of these numbers are 1, 10, 11, 100, 101.\n    The total count of set bits in these binary representations is 7.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        count += bin(i).count('1')\n    \n    return count", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a random positive integer.\n    \"\"\"\n    return 10", "map_ix": [1, 0, 0, 1, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all even Fibonacci numbers less than or equal to n.\n\n    Args:\n    - n: A positive integer.\n\n    Returns:\n    - The sum of all even Fibonacci numbers less than or equal to n.\n    \"\"\"\n    if n < 2:\n        return 0\n\n    fib_nums = [0, 1]\n    even_sum = 0\n\n    while fib_nums[-1] <= n:\n        if fib_nums[-1] % 2 == 0:\n            even_sum += fib_nums[-1]\n        fib_nums.append(fib_nums[-1] + fib_nums[-2])\n\n    return even_sum\n\ndef g(n=100):\n    return n\n\nassert f(g()) == 44\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 352, "target_skills": [1, 0, 0, 1, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all even Fibonacci numbers less than or equal to n.\n\n    Args:\n    - n: A positive integer.\n\n    Returns:\n    - The sum of all even Fibonacci numbers less than or equal to n.\n    \"\"\"\n    if n < 2:\n        return 0\n\n    fib_nums = [0, 1]\n    even_sum = 0\n\n    while fib_nums[-1] <= n:\n        if fib_nums[-1] % 2 == 0:\n            even_sum += fib_nums[-1]\n        fib_nums.append(fib_nums[-1] + fib_nums[-2])\n\n    return even_sum", "solution_func": "def g(n=100):\n    return n", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The maximum sum of any contiguous subarray in the list.\n    \"\"\"\n    if len(nums) == 0:\n        return 0\n\n    max_sum = nums[0]\n    current_sum = nums[0]\n\n    for i in range(1, len(nums)):\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g():\n    return [1, -2, 3, -4, 5, -6, 7, -8, 9, -10]\n\nassert f(g()) == 9\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 352, "target_skills": [0, 0, 0, 1, 1, 1, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The maximum sum of any contiguous subarray in the list.\n    \"\"\"\n    if len(nums) == 0:\n        return 0\n\n    max_sum = nums[0]\n    current_sum = nums[0]\n\n    for i in range(1, len(nums)):\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g():\n    return [1, -2, 3, -4, 5, -6, 7, -8, 9, -10]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of ways to climb to the top of a staircase.\n\n    Args:\n    - n: A positive integer.\n\n    Returns:\n    - The number of distinct ways to reach the top of the staircase.\n    \"\"\"\n    if n <= 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 8\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 352, "target_skills": [0, 1, 1, 1, 0, 0, 1, 1, 0, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of ways to climb to the top of a staircase.\n\n    Args:\n    - n: A positive integer.\n\n    Returns:\n    - The number of distinct ways to reach the top of the staircase.\n    \"\"\"\n    if n <= 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]", "solution_func": "def g(n=5):\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], target: str) -> bool:\n    \"\"\"\n    Given a list of words and a target word, determine if the target word can be formed by concatenating\n    any combination of words from the list. Each word in the list can be used multiple times.\n\n    Example:\n    words = [\"apple\", \"banana\", \"cat\"]\n    target = \"applebanana\"\n\n    Output:\n    True\n\n    Explanation:\n    The target word \"applebanana\" can be formed by concatenating \"apple\" and \"banana\" from the list.\n\n    Hint: Use recursion to try all possible combinations of words from the list. Start with an empty string\n    and try appending each word to the string. If the current string matches the target word, return True.\n    Otherwise, recursively call the function with the remaining part of the target word and the remaining words in the list.\n    \"\"\"\n\n    def helper(target: str, words: List[str]) -> bool:\n        if target == \"\":\n            return True\n\n        for word in words:\n            if target.startswith(word):\n                if helper(target[len(word):], words):\n                    return True\n\n        return False\n\n    return helper(target, words)\n\ndef g(words=[\"apple\", \"banana\", \"cat\"], target=\"applebanana\"):\n    return words, target\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 352, "target_skills": [1, 1, 0, 0, 1, 0, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], target: str) -> bool:\n    \"\"\"\n    Given a list of words and a target word, determine if the target word can be formed by concatenating\n    any combination of words from the list. Each word in the list can be used multiple times.\n\n    Example:\n    words = [\"apple\", \"banana\", \"cat\"]\n    target = \"applebanana\"\n\n    Output:\n    True\n\n    Explanation:\n    The target word \"applebanana\" can be formed by concatenating \"apple\" and \"banana\" from the list.\n\n    Hint: Use recursion to try all possible combinations of words from the list. Start with an empty string\n    and try appending each word to the string. If the current string matches the target word, return True.\n    Otherwise, recursively call the function with the remaining part of the target word and the remaining words in the list.\n    \"\"\"\n\n    def helper(target: str, words: List[str]) -> bool:\n        if target == \"\":\n            return True\n\n        for word in words:\n            if target.startswith(word):\n                if helper(target[len(word):], words):\n                    return True\n\n        return False\n\n    return helper(target, words)", "solution_func": "def g(words=[\"apple\", \"banana\", \"cat\"], target=\"applebanana\"):\n    return words, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target,\n    return indices of the two numbers such that they add up to target.\n\n    You may assume that each input would have exactly one solution,\n    and you may not use the same element twice.\n\n    You can return the answer in any order.\n    \"\"\"\n    numDict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in numDict:\n            return [numDict[complement], i]\n        numDict[num] = i\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a tuple containing a list of integers and a target number.\n    \"\"\"\n    nums = [2, 7, 11, 15]\n    target = 9\n    return (nums, target)\n\nassert f(*g()) == [0, 1]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 353, "target_skills": [1, 1, 1, 1, 1, 1, 0, 1, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target,\n    return indices of the two numbers such that they add up to target.\n\n    You may assume that each input would have exactly one solution,\n    and you may not use the same element twice.\n\n    You can return the answer in any order.\n    \"\"\"\n    numDict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in numDict:\n            return [numDict[complement], i]\n        numDict[num] = i\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a tuple containing a list of integers and a target number.\n    \"\"\"\n    nums = [2, 7, 11, 15]\n    target = 9\n    return (nums, target)", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Given two strings s1 and s2 of equal length, determine if they are isomorphic.\n\n    Two strings are isomorphic if the characters in s1 can be replaced to get s2.\n\n    All occurrences of a character must be replaced with another character\n    while preserving the order of characters. No two characters may map to the same character,\n    but a character may map to itself.\n\n    Example:\n    Input: s1 = \"egg\", s2 = \"add\"\n    Output: True\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n\n    map1 = {}\n    map2 = {}\n\n    for char1, char2 in zip(s1, s2):\n        if char1 not in map1 and char2 not in map2:\n            map1[char1] = char2\n            map2[char2] = char1\n        elif map1.get(char1) != char2 or map2.get(char2) != char1:\n            return False\n\n    return True\n\ndef g() -> Tuple[str, str]:\n    \"\"\"\n    Generate a tuple containing two strings of equal length.\n    \"\"\"\n    s1 = \"paper\"\n    s2 = \"title\"\n    return (s1, s2)\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 353, "target_skills": [1, 0, 1, 0, 1, 1, 0, 1, 0, 1], "problem_func": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Given two strings s1 and s2 of equal length, determine if they are isomorphic.\n\n    Two strings are isomorphic if the characters in s1 can be replaced to get s2.\n\n    All occurrences of a character must be replaced with another character\n    while preserving the order of characters. No two characters may map to the same character,\n    but a character may map to itself.\n\n    Example:\n    Input: s1 = \"egg\", s2 = \"add\"\n    Output: True\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n\n    map1 = {}\n    map2 = {}\n\n    for char1, char2 in zip(s1, s2):\n        if char1 not in map1 and char2 not in map2:\n            map1[char1] = char2\n            map2[char2] = char1\n        elif map1.get(char1) != char2 or map2.get(char2) != char1:\n            return False\n\n    return True", "solution_func": "def g() -> Tuple[str, str]:\n    \"\"\"\n    Generate a tuple containing two strings of equal length.\n    \"\"\"\n    s1 = \"paper\"\n    s2 = \"title\"\n    return (s1, s2)", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted (in non-decreasing order) array of distinct integers nums and a target value,\n    return the index where the target is found. If the target is not found, return the index where it would be if it were inserted in order.\n\n    You must write an algorithm with O(log n) runtime complexity.\n\n    Example:\n    Input: nums = [1,3,5,6], target = 5\n    Output: 2\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a tuple containing a sorted list of distinct integers and a target value.\n    \"\"\"\n    nums = [1, 3, 5, 6]\n    target = 5\n    return (nums, target)\n\nassert f(*g()) == 2\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 353, "target_skills": [1, 0, 0, 1, 1, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted (in non-decreasing order) array of distinct integers nums and a target value,\n    return the index where the target is found. If the target is not found, return the index where it would be if it were inserted in order.\n\n    You must write an algorithm with O(log n) runtime complexity.\n\n    Example:\n    Input: nums = [1,3,5,6], target = 5\n    Output: 2\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a tuple containing a sorted list of distinct integers and a target value.\n    \"\"\"\n    nums = [1, 3, 5, 6]\n    target = 5\n    return (nums, target)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if the list is sorted in non-decreasing order.\n\n    Sample Input:\n    arr = [1, 2, 3, 4, 5]\n\n    Sample Output:\n    True\n\n    Explanation: The list is sorted in non-decreasing order.\n\n    Hint: Iterate through the list and check if each element is greater than or equal to the previous element.\n    \"\"\"\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            return False\n    return True\n\ndef g(arr: List[int] = [1, 2, 3, 4, 5]) -> List[int]:\n    \"\"\"Generate a list of integers.\"\"\"\n    return arr\n\nassert f(g())\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 353, "target_skills": [0, 1, 0, 1, 1, 0, 1, 1, 1, 0], "problem_func": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if the list is sorted in non-decreasing order.\n\n    Sample Input:\n    arr = [1, 2, 3, 4, 5]\n\n    Sample Output:\n    True\n\n    Explanation: The list is sorted in non-decreasing order.\n\n    Hint: Iterate through the list and check if each element is greater than or equal to the previous element.\n    \"\"\"\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            return False\n    return True", "solution_func": "def g(arr: List[int] = [1, 2, 3, 4, 5]) -> List[int]:\n    \"\"\"Generate a list of integers.\"\"\"\n    return arr", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(adjacency_matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representing a directed graph, find the shortest path between two nodes.\n\n    Sample Input:\n    adjacency_matrix = [[0, 1, 0, 0],\n                        [0, 0, 1, 0],\n                        [0, 0, 0, 1],\n                        [0, 0, 0, 0]]\n\n    Sample Output:\n    3\n\n    Explanation: The shortest path from node 0 to node 3 is [0, 1, 2, 3].\n\n    Hint: Use a modified version of Breadth-First Search (BFS) to find the shortest path between two nodes in a graph.\n    \"\"\"\n    n = len(adjacency_matrix)\n    queue = [(0, [0])]\n    while queue:\n        node, path = queue.pop(0)\n        if node == n - 1:\n            return len(path) - 1\n        for neighbor, connected in enumerate(adjacency_matrix[node]):\n            if connected == 1 and neighbor not in path:\n                queue.append((neighbor, path + [neighbor]))\n    return -1\n\ndef g(adjacency_matrix: List[List[int]] = [[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [0, 0, 0, 0]]) -> List[List[int]]:\n    \"\"\"Generate an adjacency matrix representing a directed graph.\"\"\"\n    return adjacency_matrix\n\nassert f(g())\n", "emb": null, "idx_generation": 353, "target_skills": [1, 0, 0, 1, 0, 0, 1, 1, 0, 1], "problem_func": "from typing import*\ndef f(adjacency_matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representing a directed graph, find the shortest path between two nodes.\n\n    Sample Input:\n    adjacency_matrix = [[0, 1, 0, 0],\n                        [0, 0, 1, 0],\n                        [0, 0, 0, 1],\n                        [0, 0, 0, 0]]\n\n    Sample Output:\n    3\n\n    Explanation: The shortest path from node 0 to node 3 is [0, 1, 2, 3].\n\n    Hint: Use a modified version of Breadth-First Search (BFS) to find the shortest path between two nodes in a graph.\n    \"\"\"\n    n = len(adjacency_matrix)\n    queue = [(0, [0])]\n    while queue:\n        node, path = queue.pop(0)\n        if node == n - 1:\n            return len(path) - 1\n        for neighbor, connected in enumerate(adjacency_matrix[node]):\n            if connected == 1 and neighbor not in path:\n                queue.append((neighbor, path + [neighbor]))\n    return -1", "solution_func": "def g(adjacency_matrix: List[List[int]] = [[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [0, 0, 0, 0]]) -> List[List[int]]:\n    \"\"\"Generate an adjacency matrix representing a directed graph.\"\"\"\n    return adjacency_matrix", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(st: str) -> bool:\n    \"\"\"\n    Given a string, check if it is a palindrome.\n\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n\n    Sample Input:\n    st = \"racecar\"\n\n    Sample Output:\n    True\n\n    Explanation: The string is a palindrome.\n\n    Hint: Use recursion to check if the first and last characters of the string are equal, and recursively check the substring without the first and last characters.\n    \"\"\"\n    if len(st) <= 1:\n        return True\n    if st[0] != st[-1]:\n        return False\n    return f(st[1:-1])\n\ndef g(st: str = \"racecar\") -> str:\n    \"\"\"Generate a palindrome string.\"\"\"\n    return st\n\nassert f(g())\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 353, "target_skills": [0, 0, 1, 1, 1, 0, 1, 0, 0, 0], "problem_func": "from typing import*\ndef f(st: str) -> bool:\n    \"\"\"\n    Given a string, check if it is a palindrome.\n\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n\n    Sample Input:\n    st = \"racecar\"\n\n    Sample Output:\n    True\n\n    Explanation: The string is a palindrome.\n\n    Hint: Use recursion to check if the first and last characters of the string are equal, and recursively check the substring without the first and last characters.\n    \"\"\"\n    if len(st) <= 1:\n        return True\n    if st[0] != st[-1]:\n        return False\n    return f(st[1:-1])", "solution_func": "def g(st: str = \"racecar\") -> str:\n    \"\"\"Generate a palindrome string.\"\"\"\n    return st", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a pair of numbers in the list whose sum is equal to 10.\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == 10:\n            return True\n        elif current_sum < 10:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9]):\n    \"\"\"\n    Generate a list of integers such that there exists a pair of numbers whose sum is equal to 10.\n    \"\"\"\n    return nums\n\nassert f(g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 353, "target_skills": [1, 0, 1, 1, 0, 1, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a pair of numbers in the list whose sum is equal to 10.\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == 10:\n            return True\n        elif current_sum < 10:\n            left += 1\n        else:\n            right -= 1\n    \n    return False", "solution_func": "def g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9]):\n    \"\"\"\n    Generate a list of integers such that there exists a pair of numbers whose sum is equal to 10.\n    \"\"\"\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string of binary numbers, count the number of occurrences of the substring '11'.\n    \"\"\"\n    count = 0\n    i = 0\n    \n    while i < len(s) - 1:\n        if s[i:i+2] == '11':\n            count += 1\n            i += 2\n        else:\n            i += 1\n    \n    return count\n\ndef g(s='101101110111'):\n    \"\"\"\n    Generate a string of binary numbers such that there are multiple occurrences of the substring '11'.\n    \"\"\"\n    return s\n\nassert f(g()) > 0\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 353, "target_skills": [0, 1, 1, 1, 1, 1, 0, 0, 1, 1], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string of binary numbers, count the number of occurrences of the substring '11'.\n    \"\"\"\n    count = 0\n    i = 0\n    \n    while i < len(s) - 1:\n        if s[i:i+2] == '11':\n            count += 1\n            i += 2\n        else:\n            i += 1\n    \n    return count", "solution_func": "def g(s='101101110111'):\n    \"\"\"\n    Generate a string of binary numbers such that there are multiple occurrences of the substring '11'.\n    \"\"\"\n    return s", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, reverse the order of the elements using a stack.\n    \"\"\"\n    stack = []\n    for num in nums:\n        stack.append(num)\n    \n    reversed_nums = []\n    while stack:\n        reversed_nums.append(stack.pop())\n    \n    return reversed_nums\n\ndef g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9]):\n    \"\"\"\n    Generate a list of integers such that the order of the elements is reversed after using a stack.\n    \"\"\"\n    return nums\n\nassert f(g()) == [9, 8, 7, 6, 5, 4, 3, 2, 1]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 353, "target_skills": [1, 1, 1, 1, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, reverse the order of the elements using a stack.\n    \"\"\"\n    stack = []\n    for num in nums:\n        stack.append(num)\n    \n    reversed_nums = []\n    while stack:\n        reversed_nums.append(stack.pop())\n    \n    return reversed_nums", "solution_func": "def g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9]):\n    \"\"\"\n    Generate a list of integers such that the order of the elements is reversed after using a stack.\n    \"\"\"\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of trailing zeros in n!\n\n    Example:\n    f(5) returns 1, as 5! = 120, which has 1 trailing zero.\n\n    Note:\n    - The input integer n will be greater than or equal to 0.\n    \"\"\"\n\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n\n    return count\n\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer.\n\n    Example:\n    g() returns 5\n\n    Note:\n    - The generated integer will be greater than or equal to 0.\n    \"\"\"\n\n    return 5\n\n\nassert f(g()) == 1\n\n\n", "emb": [0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 353, "target_skills": [0, 1, 0, 1, 1, 1, 0, 1, 1, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of trailing zeros in n!\n\n    Example:\n    f(5) returns 1, as 5! = 120, which has 1 trailing zero.\n\n    Note:\n    - The input integer n will be greater than or equal to 0.\n    \"\"\"\n\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n\n    return count", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a positive integer.\n\n    Example:\n    g() returns 5\n\n    Note:\n    - The generated integer will be greater than or equal to 0.\n    \"\"\"\n\n    return 5", "map_ix": [0, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(expression: str) -> bool:\n    \"\"\"\n    Check if the given arithmetic expression is balanced.\n    A balanced expression has matching opening and closing parentheses/brackets.\n    \"\"\"\n    stack = []\n    for char in expression:\n        if char in ['(', '[', '{']:\n            stack.append(char)\n        elif char in [')', ']', '}']:\n            if not stack:\n                return False\n            if char == ')' and stack[-1] == '(':\n                stack.pop()\n            elif char == ']' and stack[-1] == '[':\n                stack.pop()\n            elif char == '}' and stack[-1] == '{':\n                stack.pop()\n            else:\n                return False\n\n    return len(stack) == 0\n\ndef g(expression: str) -> str:\n    \"\"\"\n    Remove all the spaces from the given arithmetic expression.\n    \"\"\"\n    return expression.replace(\" \", \"\")\n\nexpression = \"(1 + 2) * 3 - {4 / [5 - 6]}\"\nassert f(g(expression))\n", "emb": [1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 354, "target_skills": [0, 0, 0, 1, 0, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(expression: str) -> bool:\n    \"\"\"\n    Check if the given arithmetic expression is balanced.\n    A balanced expression has matching opening and closing parentheses/brackets.\n    \"\"\"\n    stack = []\n    for char in expression:\n        if char in ['(', '[', '{']:\n            stack.append(char)\n        elif char in [')', ']', '}']:\n            if not stack:\n                return False\n            if char == ')' and stack[-1] == '(':\n                stack.pop()\n            elif char == ']' and stack[-1] == '[':\n                stack.pop()\n            elif char == '}' and stack[-1] == '{':\n                stack.pop()\n            else:\n                return False\n\n    return len(stack) == 0", "solution_func": "def g(expression: str) -> str:\n    \"\"\"\n    Remove all the spaces from the given arithmetic expression.\n    \"\"\"\n    return expression.replace(\" \", \"\")\n\nexpression = \"(1 + 2) * 3 - {4 / [5 - 6]}\"", "map_ix": [1, 1, 1, 1, 0, 1, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> bool:\n    \"\"\"\n    Check if the given list of words can be chained together to form a circular word chain.\n    A circular word chain is formed by connecting the last character of one word to the first character of the next word.\n    \"\"\"\n    def dfs(word: str, visited: List[bool], count: int) -> bool:\n        if count == len(words):\n            return word[-1] == word[0]\n        \n        for i in range(len(words)):\n            if not visited[i] and word[-1] == words[i][0]:\n                visited[i] = True\n                if dfs(words[i], visited, count+1):\n                    return True\n                visited[i] = False\n        \n        return False\n\n    visited = [False] * len(words)\n    return dfs(words[0], visited, 1)\n\ndef g(words: List[str]) -> List[str]:\n    \"\"\"\n    Rearrange the given list of words such that they can form a circular word chain.\n    \"\"\"\n    def dfs(word: str, visited: List[bool], path: List[str]):\n        if len(path) == len(words):\n            if word[-1] == path[0][0]:\n                path.append(word)\n                return True\n            else:\n                return False\n        \n        for i in range(len(words)):\n            if not visited[i] and word[-1] == words[i][0]:\n                visited[i] = True\n                path.append(word)\n                if dfs(words[i], visited, path):\n                    return True\n                visited[i] = False\n                path.pop()\n        \n        return False\n\n    visited = [False] * len(words)\n    path = []\n    for i in range(len(words)):\n        visited[i] = True\n        if dfs(words[i], visited, path):\n            return path[::-1]\n        visited[i] = False\n\n    return []\n\nwords = [\"cat\", \"tiger\", \"rat\"]\nassert f(g(words))\n", "emb": null, "idx_generation": 354, "target_skills": [1, 1, 0, 0, 1, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> bool:\n    \"\"\"\n    Check if the given list of words can be chained together to form a circular word chain.\n    A circular word chain is formed by connecting the last character of one word to the first character of the next word.\n    \"\"\"\n    def dfs(word: str, visited: List[bool], count: int) -> bool:\n        if count == len(words):\n            return word[-1] == word[0]\n        \n        for i in range(len(words)):\n            if not visited[i] and word[-1] == words[i][0]:\n                visited[i] = True\n                if dfs(words[i], visited, count+1):\n                    return True\n                visited[i] = False\n        \n        return False\n\n    visited = [False] * len(words)\n    return dfs(words[0], visited, 1)", "solution_func": "def g(words: List[str]) -> List[str]:\n    \"\"\"\n    Rearrange the given list of words such that they can form a circular word chain.\n    \"\"\"\n    def dfs(word: str, visited: List[bool], path: List[str]):\n        if len(path) == len(words):\n            if word[-1] == path[0][0]:\n                path.append(word)\n                return True\n            else:\n                return False\n        \n        for i in range(len(words)):\n            if not visited[i] and word[-1] == words[i][0]:\n                visited[i] = True\n                path.append(word)\n                if dfs(words[i], visited, path):\n                    return True\n                visited[i] = False\n                path.pop()\n        \n        return False\n\n    visited = [False] * len(words)\n    path = []\n    for i in range(len(words)):\n        visited[i] = True\n        if dfs(words[i], visited, path):\n            return path[::-1]\n        visited[i] = False\n\n    return []\n\nwords = [\"cat\", \"tiger\", \"rat\"]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Find the maximum sum of a subarray in the given matrix.\n    A subarray is a contiguous subsequence of the array.\n    \"\"\"\n    def kadane(arr: List[int]) -> int:\n        max_sum = float('-inf')\n        current_sum = 0\n        for num in arr:\n            current_sum = max(num, current_sum + num)\n            max_sum = max(max_sum, current_sum)\n        return max_sum\n\n    max_sum = float('-inf')\n    rows = len(matrix)\n    cols = len(matrix[0])\n    for left in range(cols):\n        temp = [0] * rows\n        for right in range(left, cols):\n            for i in range(rows):\n                temp[i] += matrix[i][right]\n            max_sum = max(max_sum, kadane(temp))\n    \n    return max_sum\n\ndef g(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Rotate the given matrix by 90 degrees clockwise.\n    \"\"\"\n    return [list(reversed(row)) for row in zip(*matrix)]\n\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nassert f(g(matrix))\n", "emb": null, "idx_generation": 354, "target_skills": [0, 0, 1, 1, 0, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Find the maximum sum of a subarray in the given matrix.\n    A subarray is a contiguous subsequence of the array.\n    \"\"\"\n    def kadane(arr: List[int]) -> int:\n        max_sum = float('-inf')\n        current_sum = 0\n        for num in arr:\n            current_sum = max(num, current_sum + num)\n            max_sum = max(max_sum, current_sum)\n        return max_sum\n\n    max_sum = float('-inf')\n    rows = len(matrix)\n    cols = len(matrix[0])\n    for left in range(cols):\n        temp = [0] * rows\n        for right in range(left, cols):\n            for i in range(rows):\n                temp[i] += matrix[i][right]\n            max_sum = max(max_sum, kadane(temp))\n    \n    return max_sum", "solution_func": "def g(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Rotate the given matrix by 90 degrees clockwise.\n    \"\"\"\n    return [list(reversed(row)) for row in zip(*matrix)]\n\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a square matrix of integers, determine if it forms a magic square.\n    A magic square is a square matrix in which the sum of every row, column, and diagonal is the same.\n    Return True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n\n    # Check if all rows have the same sum\n    row_sum = sum(matrix[0])\n    for i in range(1, n):\n        if sum(matrix[i]) != row_sum:\n            return False\n\n    # Check if all columns have the same sum\n    for j in range(n):\n        col_sum = sum(matrix[i][j] for i in range(n))\n        if col_sum != row_sum:\n            return False\n\n    # Check if the diagonals have the same sum\n    diagonal_sum = sum(matrix[i][i] for i in range(n))\n    if diagonal_sum != row_sum:\n        return False\n\n    anti_diagonal_sum = sum(matrix[i][n-i-1] for i in range(n))\n    if anti_diagonal_sum != row_sum:\n        return False\n\n    return True\n\ndef g() -> List[List[int]]:\n    return [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n\nassert f(g()) == True\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], "idx_generation": 354, "target_skills": [0, 1, 0, 0, 1, 0, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a square matrix of integers, determine if it forms a magic square.\n    A magic square is a square matrix in which the sum of every row, column, and diagonal is the same.\n    Return True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n\n    # Check if all rows have the same sum\n    row_sum = sum(matrix[0])\n    for i in range(1, n):\n        if sum(matrix[i]) != row_sum:\n            return False\n\n    # Check if all columns have the same sum\n    for j in range(n):\n        col_sum = sum(matrix[i][j] for i in range(n))\n        if col_sum != row_sum:\n            return False\n\n    # Check if the diagonals have the same sum\n    diagonal_sum = sum(matrix[i][i] for i in range(n))\n    if diagonal_sum != row_sum:\n        return False\n\n    anti_diagonal_sum = sum(matrix[i][n-i-1] for i in range(n))\n    if anti_diagonal_sum != row_sum:\n        return False\n\n    return True", "solution_func": "def g() -> List[List[int]]:\n    return [[2, 7, 6], [9, 5, 1], [4, 3, 8]]", "map_ix": [1, 1, 0, 0, 0, 0, 1, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, return a list of all unique triplets that add up to zero.\n    Each triplet should be sorted in ascending order.\n    \"\"\"\n    nums.sort()\n    triplets = []\n    n = len(nums)\n\n    for i in range(n-2):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n\n        left = i + 1\n        right = n - 1\n\n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total == 0:\n                triplets.append([nums[i], nums[left], nums[right]])\n\n                while left < right and nums[left] == nums[left+1]:\n                    left += 1\n                while left < right and nums[right] == nums[right-1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n            elif total < 0:\n                left += 1\n            else:\n                right -= 1\n\n    return triplets\n\ndef g() -> List[int]:\n    return [-1, 0, 1, 2, -1, -4]\n\nassert f(g()) == [[-1, -1, 2], [-1, 0, 1]]\n\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 354, "target_skills": [1, 1, 1, 0, 0, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, return a list of all unique triplets that add up to zero.\n    Each triplet should be sorted in ascending order.\n    \"\"\"\n    nums.sort()\n    triplets = []\n    n = len(nums)\n\n    for i in range(n-2):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n\n        left = i + 1\n        right = n - 1\n\n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total == 0:\n                triplets.append([nums[i], nums[left], nums[right]])\n\n                while left < right and nums[left] == nums[left+1]:\n                    left += 1\n                while left < right and nums[right] == nums[right-1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n            elif total < 0:\n                left += 1\n            else:\n                right -= 1\n\n    return triplets", "solution_func": "def g() -> List[int]:\n    return [-1, 0, 1, 2, -1, -4]", "map_ix": [1, 0, 0, 1, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Generate all possible combinations of n pairs of parentheses.\n    Return a list of strings representing all valid combinations.\n    \"\"\"\n    def backtrack(s, left, right):\n        if len(s) == 2 * n:\n            combinations.append(s)\n            return\n\n        if left < n:\n            backtrack(s + \"(\", left + 1, right)\n        if right < left:\n            backtrack(s + \")\", left, right + 1)\n\n    combinations = []\n    backtrack(\"\", 0, 0)\n    return combinations\n\ndef g() -> int:\n    return 3\n\nassert f(g()) == [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 354, "target_skills": [0, 1, 0, 1, 1, 1, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Generate all possible combinations of n pairs of parentheses.\n    Return a list of strings representing all valid combinations.\n    \"\"\"\n    def backtrack(s, left, right):\n        if len(s) == 2 * n:\n            combinations.append(s)\n            return\n\n        if left < n:\n            backtrack(s + \"(\", left + 1, right)\n        if right < left:\n            backtrack(s + \")\", left, right + 1)\n\n    combinations = []\n    backtrack(\"\", 0, 0)\n    return combinations", "solution_func": "def g() -> int:\n    return 3", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with only the even numbers.\n\n    Example:\n    arr = [1, 2, 3, 4, 5, 6, 7, 8]\n    Output: [2, 4, 6, 8]\n    \"\"\"\n\n    result = []\n    for num in arr:\n        if num % 2 == 0:\n            result.append(num)\n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8]\n\nassert f(g()) == [2, 4, 6, 8]\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 354, "target_skills": [0, 0, 0, 0, 1, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with only the even numbers.\n\n    Example:\n    arr = [1, 2, 3, 4, 5, 6, 7, 8]\n    Output: [2, 4, 6, 8]\n    \"\"\"\n\n    result = []\n    for num in arr:\n        if num % 2 == 0:\n            result.append(num)\n    return result", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target integer, return True if there are two numbers in the list that sum up to the target.\n\n    Example:\n    arr = [2, 4, 6, 8]\n    target = 10\n    Output: True\n    \"\"\"\n\n    seen = set()\n    for num in arr:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate the input for the function f.\n    \"\"\"\n    return ([2, 4, 6, 8], 10)\n\nassert f(*g()) == True\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 354, "target_skills": [1, 0, 1, 1, 0, 1, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target integer, return True if there are two numbers in the list that sum up to the target.\n\n    Example:\n    arr = [2, 4, 6, 8]\n    target = 10\n    Output: True\n    \"\"\"\n\n    seen = set()\n    for num in arr:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate the input for the function f.\n    \"\"\"\n    return ([2, 4, 6, 8], 10)", "map_ix": [1, 1, 0, 0, 0, 1, 0, 0, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], pattern: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a pattern, return a new list of words that match the pattern.\n\n    Example:\n    words = [\"abc\", \"def\", \"ghi\", \"jkl\"]\n    pattern = \"aba\"\n    Output: [\"abc\"]\n\n    Explanation:\n    The pattern \"aba\" matches the word \"abc\" because the first and third letters are the same and the second letter is different.\n    \"\"\"\n\n    def matches_pattern(word: str, pattern: str) -> bool:\n        if len(word) != len(pattern):\n            return False\n\n        mapping = {}\n        for i in range(len(word)):\n            if word[i] not in mapping:\n                if pattern[i] in mapping.values():\n                    return False\n                mapping[word[i]] = pattern[i]\n            else:\n                if mapping[word[i]] != pattern[i]:\n                    return False\n\n        return True\n\n    result = []\n    for word in words:\n        if matches_pattern(word, pattern):\n            result.append(word)\n    return result\n\ndef g() -> Tuple[List[str], str]:\n    \"\"\"\n    Generate the input for the function f.\n    \"\"\"\n    return ([\"abc\", \"def\", \"ghi\", \"jkl\"], \"aba\")\n\nassert f(*g()) == [\"abc\"]\n\n", "emb": null, "idx_generation": 354, "target_skills": [1, 0, 0, 1, 0, 0, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], pattern: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a pattern, return a new list of words that match the pattern.\n\n    Example:\n    words = [\"abc\", \"def\", \"ghi\", \"jkl\"]\n    pattern = \"aba\"\n    Output: [\"abc\"]\n\n    Explanation:\n    The pattern \"aba\" matches the word \"abc\" because the first and third letters are the same and the second letter is different.\n    \"\"\"\n\n    def matches_pattern(word: str, pattern: str) -> bool:\n        if len(word) != len(pattern):\n            return False\n\n        mapping = {}\n        for i in range(len(word)):\n            if word[i] not in mapping:\n                if pattern[i] in mapping.values():\n                    return False\n                mapping[word[i]] = pattern[i]\n            else:\n                if mapping[word[i]] != pattern[i]:\n                    return False\n\n        return True\n\n    result = []\n    for word in words:\n        if matches_pattern(word, pattern):\n            result.append(word)\n    return result", "solution_func": "def g() -> Tuple[List[str], str]:\n    \"\"\"\n    Generate the input for the function f.\n    \"\"\"\n    return ([\"abc\", \"def\", \"ghi\", \"jkl\"], \"aba\")", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nimport math\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, return the number of distinct pairs (i, j) such that i < j and nums[i] XOR nums[j] is a perfect square.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    Output: 2\n    Explanation: The distinct pairs are (1, 3) and (3, 5), and their XOR values are 2 and 6, which are perfect squares.\n\n    nums = [2, 4, 6, 8, 10]\n    Output: 0\n    Explanation: There are no distinct pairs whose XOR value is a perfect square.\n\n    nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    Output: 14\n    Explanation: The distinct pairs are (0, 1), (0, 4), (1, 2), (1, 9), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9), (0, 3), (1, 8), and (4, 9), and their XOR values are 1, 4, 3, 8, 1, 7, 1, 3, 1, 15, 1, 2, 9, and 13, which are perfect squares.\n    \"\"\"\n    def is_perfect_square(num: int) -> bool:\n        sqrt = int(math.sqrt(num))\n        return sqrt * sqrt == num\n    \n    count = 0\n    xor_values = set()\n    \n    for num in nums:\n        for xor_val in xor_values:\n            if is_perfect_square(num ^ xor_val):\n                count += 1\n        \n        xor_values.add(num)\n    \n    return count\n\ndef g() -> List[int]:\n    nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    return [nums]\n\nassert f(*g()) == 14\n\n", "emb": null, "idx_generation": 354, "target_skills": [0, 1, 1, 1, 1, 1, 0, 1, 0, 1], "problem_func": "from typing import*\nimport math\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, return the number of distinct pairs (i, j) such that i < j and nums[i] XOR nums[j] is a perfect square.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    Output: 2\n    Explanation: The distinct pairs are (1, 3) and (3, 5), and their XOR values are 2 and 6, which are perfect squares.\n\n    nums = [2, 4, 6, 8, 10]\n    Output: 0\n    Explanation: There are no distinct pairs whose XOR value is a perfect square.\n\n    nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    Output: 14\n    Explanation: The distinct pairs are (0, 1), (0, 4), (1, 2), (1, 9), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9), (0, 3), (1, 8), and (4, 9), and their XOR values are 1, 4, 3, 8, 1, 7, 1, 3, 1, 15, 1, 2, 9, and 13, which are perfect squares.\n    \"\"\"\n    def is_perfect_square(num: int) -> bool:\n        sqrt = int(math.sqrt(num))\n        return sqrt * sqrt == num\n    \n    count = 0\n    xor_values = set()\n    \n    for num in nums:\n        for xor_val in xor_values:\n            if is_perfect_square(num ^ xor_val):\n                count += 1\n        \n        xor_values.add(num)\n    \n    return count", "solution_func": "def g() -> List[int]:\n    nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    return [nums]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n\n    Output:\n    True\n\n    Explanation:\n    2 + 5 = 7\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        sum = arr[left] + arr[right]\n\n        if sum == target:\n            return True\n        elif sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(arr=[1, 2, 3, 4, 5], target=7):\n    return arr, target\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 355, "target_skills": [1, 0, 1, 1, 0, 0, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n\n    Output:\n    True\n\n    Explanation:\n    2 + 5 = 7\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        sum = arr[left] + arr[right]\n\n        if sum == target:\n            return True\n        elif sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g(arr=[1, 2, 3, 4, 5], target=7):\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n\n    Example:\n    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g(arr=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return arr\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 355, "target_skills": [0, 0, 1, 1, 1, 1, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n\n    Example:\n    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g(arr=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return arr", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a prime number.\n\n    Example:\n    n = 7\n\n    Output:\n    True\n\n    Explanation:\n    7 is a prime number.\n    \"\"\"\n    if n <= 1:\n        return False\n\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n\n    return True\n\ndef g(n=7):\n    return n\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 355, "target_skills": [1, 1, 1, 0, 0, 0, 0, 1, 1, 0], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a prime number.\n\n    Example:\n    n = 7\n\n    Output:\n    True\n\n    Explanation:\n    7 is a prime number.\n    \"\"\"\n    if n <= 1:\n        return False\n\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n\n    return True", "solution_func": "def g(n=7):\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, obstacles: List[List[int]]) -> int:\n    \"\"\"\n    Given an integer n representing the size of a grid and a list of obstacles,\n    find the number of unique paths from the top-left cell to the bottom-right cell,\n    while avoiding the obstacles.\n    Return the number of unique paths.\n    \"\"\"\n    dp = [[0] * n for _ in range(n)]\n    dp[0][0] = 1\n\n    for i in range(n):\n        for j in range(n):\n            if [i, j] not in obstacles:\n                if i > 0:\n                    dp[i][j] += dp[i-1][j]\n                if j > 0:\n                    dp[i][j] += dp[i][j-1]\n\n    return dp[n-1][n-1]\n\ndef g():\n    n = 4\n    obstacles = [[1, 2], [2, 1]]\n    return (n, obstacles)\n\nassert f(*g()) == 3\n", "emb": null, "idx_generation": 355, "target_skills": [0, 1, 0, 0, 0, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, obstacles: List[List[int]]) -> int:\n    \"\"\"\n    Given an integer n representing the size of a grid and a list of obstacles,\n    find the number of unique paths from the top-left cell to the bottom-right cell,\n    while avoiding the obstacles.\n    Return the number of unique paths.\n    \"\"\"\n    dp = [[0] * n for _ in range(n)]\n    dp[0][0] = 1\n\n    for i in range(n):\n        for j in range(n):\n            if [i, j] not in obstacles:\n                if i > 0:\n                    dp[i][j] += dp[i-1][j]\n                if j > 0:\n                    dp[i][j] += dp[i][j-1]\n\n    return dp[n-1][n-1]", "solution_func": "def g():\n    n = 4\n    obstacles = [[1, 2], [2, 1]]\n    return (n, obstacles)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import Tuple\n\ndef f(n: int, m: int, k: int) -> Tuple[int, int]:\n    \"\"\"\n    Given three integers n, m, and k,\n    find the number of valid coordinates (x, y) within a grid of size n x m,\n    such that sum of digits of x + sum of digits of y is less than or equal to k.\n    Return the number of valid coordinates and the maximum sum of digits.\n    \"\"\"\n    def digit_sum(num):\n        return sum(int(d) for d in str(num))\n\n    count = 0\n    max_sum = 0\n\n    for i in range(n):\n        for j in range(m):\n            if digit_sum(i) + digit_sum(j) <= k:\n                count += 1\n                max_sum = max(max_sum, digit_sum(i) + digit_sum(j))\n\n    return count, max_sum\n\ndef g():\n    n = 5\n    m = 4\n    k = 8\n    return (n, m, k)\n\nassert f(*g()) == (17, 7)\n", "emb": null, "idx_generation": 355, "target_skills": [0, 1, 1, 0, 0, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import Tuple\n\ndef f(n: int, m: int, k: int) -> Tuple[int, int]:\n    \"\"\"\n    Given three integers n, m, and k,\n    find the number of valid coordinates (x, y) within a grid of size n x m,\n    such that sum of digits of x + sum of digits of y is less than or equal to k.\n    Return the number of valid coordinates and the maximum sum of digits.\n    \"\"\"\n    def digit_sum(num):\n        return sum(int(d) for d in str(num))\n\n    count = 0\n    max_sum = 0\n\n    for i in range(n):\n        for j in range(m):\n            if digit_sum(i) + digit_sum(j) <= k:\n                count += 1\n                max_sum = max(max_sum, digit_sum(i) + digit_sum(j))\n\n    return count, max_sum", "solution_func": "def g():\n    n = 5\n    m = 4\n    k = 8\n    return (n, m, k)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers,\n    find the maximum product of any two distinct numbers in the list.\n    Return the maximum product.\n    \"\"\"\n    max_product = float('-inf')\n\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            max_product = max(max_product, arr[i] * arr[j])\n\n    return max_product\n\ndef g():\n    return [2, 4, 6, 8, 10]\n\nassert f(g()) == 80\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 355, "target_skills": [1, 0, 0, 0, 0, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers,\n    find the maximum product of any two distinct numbers in the list.\n    Return the maximum product.\n    \"\"\"\n    max_product = float('-inf')\n\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            max_product = max(max_product, arr[i] * arr[j])\n\n    return max_product", "solution_func": "def g():\n    return [2, 4, 6, 8, 10]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums' and a target integer 'target', \n    find two numbers in 'nums' that add up to 'target' and return their indices.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 355, "target_skills": [1, 0, 1, 1, 0, 1, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums' and a target integer 'target', \n    find two numbers in 'nums' that add up to 'target' and return their indices.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []", "solution_func": "def g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer 'n', determine the number of combinations of valid parentheses pairs that can be formed with 'n' pairs of parentheses.\n\n    Example:\n    n = 3\n\n    Output:\n    5\n    \"\"\"\n    def backtrack(open_count, close_count):\n        if open_count == close_count == n:\n            return 1\n        if open_count > n or close_count > open_count:\n            return 0\n\n        return backtrack(open_count + 1, close_count) + backtrack(open_count, close_count + 1)\n\n    return backtrack(0, 0)\n\ndef g():\n    n = 3\n    return n\n\nassert f(g()) == 5\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 355, "target_skills": [1, 0, 1, 0, 1, 1, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer 'n', determine the number of combinations of valid parentheses pairs that can be formed with 'n' pairs of parentheses.\n\n    Example:\n    n = 3\n\n    Output:\n    5\n    \"\"\"\n    def backtrack(open_count, close_count):\n        if open_count == close_count == n:\n            return 1\n        if open_count > n or close_count > open_count:\n            return 0\n\n        return backtrack(open_count + 1, close_count) + backtrack(open_count, close_count + 1)\n\n    return backtrack(0, 0)", "solution_func": "def g():\n    n = 3\n    return n", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a matrix of integers 'matrix' and a target integer 'target', \n    determine if the target exists in the matrix.\n\n    The matrix is sorted row-wise and column-wise in non-decreasing order.\n\n    Example:\n    matrix = [\n        [1, 4, 7],\n        [2, 5, 8],\n        [3, 6, 9]\n    ]\n    target = 5\n\n    Output:\n    True\n    \"\"\"\n    rows = len(matrix)\n    if rows == 0:\n        return False\n    cols = len(matrix[0])\n\n    row = 0\n    col = cols - 1\n\n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n\n    return False\n\ndef g():\n    matrix = [\n        [1, 4, 7],\n        [2, 5, 8],\n        [3, 6, 9]\n    ]\n    target = 5\n    return matrix, target\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 355, "target_skills": [0, 1, 1, 0, 1, 1, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a matrix of integers 'matrix' and a target integer 'target', \n    determine if the target exists in the matrix.\n\n    The matrix is sorted row-wise and column-wise in non-decreasing order.\n\n    Example:\n    matrix = [\n        [1, 4, 7],\n        [2, 5, 8],\n        [3, 6, 9]\n    ]\n    target = 5\n\n    Output:\n    True\n    \"\"\"\n    rows = len(matrix)\n    if rows == 0:\n        return False\n    cols = len(matrix[0])\n\n    row = 0\n    col = cols - 1\n\n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n\n    return False", "solution_func": "def g():\n    matrix = [\n        [1, 4, 7],\n        [2, 5, 8],\n        [3, 6, 9]\n    ]\n    target = 5\n    return matrix, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique paths from the top-left corner to the bottom-right corner of a n x n grid.\n    You can only move either down or right at any point in time.\n\n    Example:\n    Input: 3\n    Output: 6\n\n    Explanation:\n    There are 6 possible paths to reach the bottom-right corner of a 3 x 3 grid.\n\n    Hint: Use dynamic programming to store the number of paths for each subgrid.\n    \"\"\"\n\n    def unique_paths_helper(i, j, n, memo):\n        if i == n - 1 and j == n - 1:\n            return 1\n        if i >= n or j >= n:\n            return 0\n        if memo[i][j] != -1:\n            return memo[i][j]\n        memo[i][j] = unique_paths_helper(i+1, j, n, memo) + unique_paths_helper(i, j+1, n, memo)\n        return memo[i][j]\n\n    memo = [[-1] * n for _ in range(n)]\n    return unique_paths_helper(0, 0, n, memo)\n\ndef g():\n    return 3\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 355, "target_skills": [0, 1, 0, 1, 0, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique paths from the top-left corner to the bottom-right corner of a n x n grid.\n    You can only move either down or right at any point in time.\n\n    Example:\n    Input: 3\n    Output: 6\n\n    Explanation:\n    There are 6 possible paths to reach the bottom-right corner of a 3 x 3 grid.\n\n    Hint: Use dynamic programming to store the number of paths for each subgrid.\n    \"\"\"\n\n    def unique_paths_helper(i, j, n, memo):\n        if i == n - 1 and j == n - 1:\n            return 1\n        if i >= n or j >= n:\n            return 0\n        if memo[i][j] != -1:\n            return memo[i][j]\n        memo[i][j] = unique_paths_helper(i+1, j, n, memo) + unique_paths_helper(i, j+1, n, memo)\n        return memo[i][j]\n\n    memo = [[-1] * n for _ in range(n)]\n    return unique_paths_helper(0, 0, n, memo)", "solution_func": "def g():\n    return 3", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the number of paths from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    matrix = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 7\n    Explanation: The possible paths are: 1 -> 3 -> 1 -> 1 -> 1, 1 -> 3 -> 5 -> 1, 1 -> 5 -> 1 -> 1 -> 1, 1 -> 5 -> 2 -> 1, 1 -> 1 -> 5 -> 1, 1 -> 1 -> 2 -> 1, 1 -> 1 -> 1 -> 1 -> 1.\n\n    Hint: Use dynamic programming to build the number of paths from each cell to the bottom-right corner.\n    \"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] * matrix[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] * matrix[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1] * matrix[i][j]\n\n    return dp[m-1][n-1]\n\ndef g():\n    matrix = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return matrix\n\nassert f(g()) == 7\n", "emb": null, "idx_generation": 356, "target_skills": [0, 1, 1, 1, 0, 0, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the number of paths from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    matrix = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 7\n    Explanation: The possible paths are: 1 -> 3 -> 1 -> 1 -> 1, 1 -> 3 -> 5 -> 1, 1 -> 5 -> 1 -> 1 -> 1, 1 -> 5 -> 2 -> 1, 1 -> 1 -> 5 -> 1, 1 -> 1 -> 2 -> 1, 1 -> 1 -> 1 -> 1 -> 1.\n\n    Hint: Use dynamic programming to build the number of paths from each cell to the bottom-right corner.\n    \"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] * matrix[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] * matrix[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1] * matrix[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g():\n    matrix = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return matrix", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the number of combinations that sum up to the target.\n    Each number in the list can be used multiple times.\n\n    Example:\n    nums = [1, 2, 3]\n    target = 4\n    Output: 7\n    Explanation: The possible combinations are: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [1, 3], [2, 1, 1], [2, 2], [3, 1].\n\n    Hint: Use dynamic programming to build the number of combinations for each target sum.\n    \"\"\"\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i - num >= 0:\n                dp[i] += dp[i - num]\n\n    return dp[target]\n\ndef g():\n    nums = [1, 2, 3]\n    target = 4\n    return nums, target\n\nassert f(*g()) == 7\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 356, "target_skills": [1, 0, 0, 0, 1, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the number of combinations that sum up to the target.\n    Each number in the list can be used multiple times.\n\n    Example:\n    nums = [1, 2, 3]\n    target = 4\n    Output: 7\n    Explanation: The possible combinations are: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [1, 3], [2, 1, 1], [2, 2], [3, 1].\n\n    Hint: Use dynamic programming to build the number of combinations for each target sum.\n    \"\"\"\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i - num >= 0:\n                dp[i] += dp[i - num]\n\n    return dp[target]", "solution_func": "def g():\n    nums = [1, 2, 3]\n    target = 4\n    return nums, target", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number k, find the number of subarrays with a sum divisible by k.\n\n    Example:\n    nums = [4, 5, 0, -2, -3, 1]\n    k = 5\n    Output: 7\n    Explanation: The subarrays with a sum divisible by 5 are: [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0, -2, -3], [5, 0, -2, -3, 1], [-2, -3].\n\n    Hint: Use dynamic programming to keep track of the cumulative sum and the count of remainders when divided by k.\n    \"\"\"\n    count = 0\n    prefix_sum = 0\n    remainders = [0] * k\n    remainders[0] = 1\n\n    for num in nums:\n        prefix_sum += num\n        remainder = prefix_sum % k\n        count += remainders[remainder]\n        remainders[remainder] += 1\n\n    return count\n\ndef g():\n    nums = [4, 5, 0, -2, -3, 1]\n    k = 5\n    return nums, k\n\nassert f(*g()) == 7\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 356, "target_skills": [1, 1, 0, 1, 1, 1, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number k, find the number of subarrays with a sum divisible by k.\n\n    Example:\n    nums = [4, 5, 0, -2, -3, 1]\n    k = 5\n    Output: 7\n    Explanation: The subarrays with a sum divisible by 5 are: [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0, -2, -3], [5, 0, -2, -3, 1], [-2, -3].\n\n    Hint: Use dynamic programming to keep track of the cumulative sum and the count of remainders when divided by k.\n    \"\"\"\n    count = 0\n    prefix_sum = 0\n    remainders = [0] * k\n    remainders[0] = 1\n\n    for num in nums:\n        prefix_sum += num\n        remainder = prefix_sum % k\n        count += remainders[remainder]\n        remainders[remainder] += 1\n\n    return count", "solution_func": "def g():\n    nums = [4, 5, 0, -2, -3, 1]\n    k = 5\n    return nums, k", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nimport math\nfrom typing import List, Tuple\n\ndef f(arr: List[int], target: int) -> Tuple[int, int]:\n    \"\"\"\n    Given a sorted list of distinct integers and a target integer, find two numbers in the list that sum up to the target.\n    Return the indices of the two numbers in the list.\n\n    Example:\n    arr = [-2, 3, 7, 12, 15]\n    target = 10\n\n    Output:\n    (1, 3)\n\n    Explanation:\n    The numbers 3 and 7 sum up to 10. Their indices in the list are 1 and 3.\n    \"\"\"\n    def binary_search(arr: List[int], target: int) -> int:\n        left = 0\n        right = len(arr) - 1\n\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == target:\n                return mid\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return -1\n\n    for i, num in enumerate(arr):\n        complement = target - num\n        index = binary_search(arr, complement)\n        if index != -1 and index != i:\n            return (i, index)\n\n    return (-1, -1)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of distinct integers and a target integer.\n    \"\"\"\n    return ([-2, 3, 7, 12, 15], 10)\n\nassert f(*g()) == (1, 3)\n", "emb": null, "idx_generation": 356, "target_skills": [1, 0, 0, 1, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nimport math\nfrom typing import List, Tuple\n\ndef f(arr: List[int], target: int) -> Tuple[int, int]:\n    \"\"\"\n    Given a sorted list of distinct integers and a target integer, find two numbers in the list that sum up to the target.\n    Return the indices of the two numbers in the list.\n\n    Example:\n    arr = [-2, 3, 7, 12, 15]\n    target = 10\n\n    Output:\n    (1, 3)\n\n    Explanation:\n    The numbers 3 and 7 sum up to 10. Their indices in the list are 1 and 3.\n    \"\"\"\n    def binary_search(arr: List[int], target: int) -> int:\n        left = 0\n        right = len(arr) - 1\n\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == target:\n                return mid\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return -1\n\n    for i, num in enumerate(arr):\n        complement = target - num\n        index = binary_search(arr, complement)\n        if index != -1 and index != i:\n            return (i, index)\n\n    return (-1, -1)", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of distinct integers and a target integer.\n    \"\"\"\n    return ([-2, 3, 7, 12, 15], 10)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nimport math\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 0 represents an obstacle and 1 represents an open path,\n    determine the maximum number of open paths a robot can take to reach the bottom-right cell from the top-left cell.\n    The robot can only move down or right.\n\n    Example:\n    grid = [\n        [1, 0, 0, 0],\n        [1, 1, 0, 1],\n        [0, 1, 1, 1],\n        [0, 0, 1, 1]\n    ]\n\n    Output:\n    6\n\n    Explanation:\n    The robot can take 6 different paths to reach the bottom-right cell:\n    - Right -> Right -> Down -> Down\n    - Right -> Down -> Right -> Down\n    - Right -> Down -> Down -> Right\n    - Down -> Right -> Right -> Down\n    - Down -> Right -> Down -> Right\n    - Down -> Down -> Right -> Right\n    \"\"\"\n\n    def dfs(grid: List[List[int]], row: int, col: int) -> int:\n        if row == len(grid) - 1 and col == len(grid[0]) - 1:\n            return 1\n\n        right_paths = 0\n        down_paths = 0\n\n        if col < len(grid[0]) - 1 and grid[row][col+1] == 1:\n            right_paths = dfs(grid, row, col+1)\n\n        if row < len(grid) - 1 and grid[row+1][col] == 1:\n            down_paths = dfs(grid, row+1, col)\n\n        return right_paths + down_paths\n\n    return dfs(grid, 0, 0)\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of 0s and 1s.\n    \"\"\"\n    return [\n        [1, 0, 0, 0],\n        [1, 1, 0, 1],\n        [0, 1, 1, 1],\n        [0, 0, 1, 1]\n    ]\n\nassert f(g()) == 6\n", "emb": null, "idx_generation": 356, "target_skills": [0, 0, 1, 1, 0, 0, 0, 1, 0, 1], "problem_func": "from typing import*\nimport math\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 0 represents an obstacle and 1 represents an open path,\n    determine the maximum number of open paths a robot can take to reach the bottom-right cell from the top-left cell.\n    The robot can only move down or right.\n\n    Example:\n    grid = [\n        [1, 0, 0, 0],\n        [1, 1, 0, 1],\n        [0, 1, 1, 1],\n        [0, 0, 1, 1]\n    ]\n\n    Output:\n    6\n\n    Explanation:\n    The robot can take 6 different paths to reach the bottom-right cell:\n    - Right -> Right -> Down -> Down\n    - Right -> Down -> Right -> Down\n    - Right -> Down -> Down -> Right\n    - Down -> Right -> Right -> Down\n    - Down -> Right -> Down -> Right\n    - Down -> Down -> Right -> Right\n    \"\"\"\n\n    def dfs(grid: List[List[int]], row: int, col: int) -> int:\n        if row == len(grid) - 1 and col == len(grid[0]) - 1:\n            return 1\n\n        right_paths = 0\n        down_paths = 0\n\n        if col < len(grid[0]) - 1 and grid[row][col+1] == 1:\n            right_paths = dfs(grid, row, col+1)\n\n        if row < len(grid) - 1 and grid[row+1][col] == 1:\n            down_paths = dfs(grid, row+1, col)\n\n        return right_paths + down_paths\n\n    return dfs(grid, 0, 0)", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of 0s and 1s.\n    \"\"\"\n    return [\n        [1, 0, 0, 0],\n        [1, 1, 0, 1],\n        [0, 1, 1, 1],\n        [0, 0, 1, 1]\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nimport math\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 0 represents an obstacle and 1 represents an open path,\n    find the length of the shortest path from the top-left cell to the bottom-right cell.\n    The robot can only move down or right.\n\n    Example:\n    grid = [\n        [1, 1, 1, 1],\n        [1, 0, 1, 0],\n        [1, 1, 1, 1],\n        [1, 1, 1, 1]\n    ]\n\n    Output:\n    6\n\n    Explanation:\n    The shortest path from the top-left cell to the bottom-right cell is:\n    Right -> Right -> Down -> Down -> Down -> Right\n    \"\"\"\n\n    def bfs(grid: List[List[int]]) -> int:\n        queue = [(0, 0, 0)]\n        visited = set()\n\n        while queue:\n            row, col, steps = queue.pop(0)\n\n            if row == len(grid) - 1 and col == len(grid[0]) - 1:\n                return steps\n\n            visited.add((row, col))\n\n            if col < len(grid[0]) - 1 and grid[row][col+1] == 1 and (row, col+1) not in visited:\n                queue.append((row, col+1, steps+1))\n\n            if row < len(grid) - 1 and grid[row+1][col] == 1 and (row+1, col) not in visited:\n                queue.append((row+1, col, steps+1))\n\n        return -1\n\n    return bfs(grid)\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of 0s and 1s.\n    \"\"\"\n    return [\n        [1, 1, 1, 1],\n        [1, 0, 1, 0],\n        [1, 1, 1, 1],\n        [1, 1, 1, 1]\n    ]\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0], "idx_generation": 356, "target_skills": [0, 1, 0, 0, 0, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nimport math\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 0 represents an obstacle and 1 represents an open path,\n    find the length of the shortest path from the top-left cell to the bottom-right cell.\n    The robot can only move down or right.\n\n    Example:\n    grid = [\n        [1, 1, 1, 1],\n        [1, 0, 1, 0],\n        [1, 1, 1, 1],\n        [1, 1, 1, 1]\n    ]\n\n    Output:\n    6\n\n    Explanation:\n    The shortest path from the top-left cell to the bottom-right cell is:\n    Right -> Right -> Down -> Down -> Down -> Right\n    \"\"\"\n\n    def bfs(grid: List[List[int]]) -> int:\n        queue = [(0, 0, 0)]\n        visited = set()\n\n        while queue:\n            row, col, steps = queue.pop(0)\n\n            if row == len(grid) - 1 and col == len(grid[0]) - 1:\n                return steps\n\n            visited.add((row, col))\n\n            if col < len(grid[0]) - 1 and grid[row][col+1] == 1 and (row, col+1) not in visited:\n                queue.append((row, col+1, steps+1))\n\n            if row < len(grid) - 1 and grid[row+1][col] == 1 and (row+1, col) not in visited:\n                queue.append((row+1, col, steps+1))\n\n        return -1\n\n    return bfs(grid)", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of 0s and 1s.\n    \"\"\"\n    return [\n        [1, 1, 1, 1],\n        [1, 0, 1, 0],\n        [1, 1, 1, 1],\n        [1, 1, 1, 1]\n    ]", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n\n    Example:\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 6\n\n    Output:\n    5\n\n    Explanation:\n    The target value 6 is at index 5 in the list.\n\n    Note: The input list will always be sorted in ascending order and will not contain duplicates.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 6\n    return arr, target\n\nassert f(*g()) == 5\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 356, "target_skills": [1, 1, 0, 0, 1, 0, 0, 1, 1, 0], "problem_func": "from typing import*\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n\n    Example:\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 6\n\n    Output:\n    5\n\n    Explanation:\n    The target value 6 is at index 5 in the list.\n\n    Note: The input list will always be sorted in ascending order and will not contain duplicates.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g():\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 6\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers representing a maze, find the minimum number of steps required to reach the bottom-right corner of the maze from the top-left corner. Each cell in the grid represents a room in the maze, where 0 represents an open room that can be traversed and 1 represents a blocked room that cannot be traversed.\n\n    Example:\n    grid = [\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 0, 1],\n        [1, 1, 0, 1, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 0, 1, 0]\n    ]\n\n    Output:\n    8\n\n    Explanation:\n    The minimum number of steps required to reach the bottom-right corner from the top-left corner is 8.\n\n    Constraints:\n    - The grid will always be a rectangular shape.\n    - The grid will always have at least one row and one column.\n    - The grid will only contain 0 and 1.\n    - The top-left corner of the grid will always be a 0.\n    - The bottom-right corner of the grid will always be a 0.\n    - It is guaranteed that there is a path from the top-left corner to the bottom-right corner of the grid.\n    \"\"\"\n\n    def dfs(i, j, steps):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 1:\n            return float('inf')\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\n            return steps\n\n        grid[i][j] = 1\n        min_steps = min(dfs(i+1, j, steps+1), dfs(i-1, j, steps+1), dfs(i, j+1, steps+1), dfs(i, j-1, steps+1))\n        grid[i][j] = 0\n\n        return min_steps\n\n    return dfs(0, 0, 0)\n\ndef g():\n    grid = [\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 0, 1],\n        [1, 1, 0, 1, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 0, 1, 0]\n    ]\n    return grid\n\nassert f(g()) == 8\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 356, "target_skills": [1, 1, 1, 0, 0, 0, 1, 1, 0, 0], "problem_func": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers representing a maze, find the minimum number of steps required to reach the bottom-right corner of the maze from the top-left corner. Each cell in the grid represents a room in the maze, where 0 represents an open room that can be traversed and 1 represents a blocked room that cannot be traversed.\n\n    Example:\n    grid = [\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 0, 1],\n        [1, 1, 0, 1, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 0, 1, 0]\n    ]\n\n    Output:\n    8\n\n    Explanation:\n    The minimum number of steps required to reach the bottom-right corner from the top-left corner is 8.\n\n    Constraints:\n    - The grid will always be a rectangular shape.\n    - The grid will always have at least one row and one column.\n    - The grid will only contain 0 and 1.\n    - The top-left corner of the grid will always be a 0.\n    - The bottom-right corner of the grid will always be a 0.\n    - It is guaranteed that there is a path from the top-left corner to the bottom-right corner of the grid.\n    \"\"\"\n\n    def dfs(i, j, steps):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 1:\n            return float('inf')\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\n            return steps\n\n        grid[i][j] = 1\n        min_steps = min(dfs(i+1, j, steps+1), dfs(i-1, j, steps+1), dfs(i, j+1, steps+1), dfs(i, j-1, steps+1))\n        grid[i][j] = 0\n\n        return min_steps\n\n    return dfs(0, 0, 0)", "solution_func": "def g():\n    grid = [\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 0, 1],\n        [1, 1, 0, 1, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 0, 1, 0]\n    ]\n    return grid", "map_ix": [0, 0, 1, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid. You can only move right or down at any point in time.\n\n    Example:\n    n = 3\n\n    Output:\n    6\n\n    Explanation:\n    There are 6 unique paths from the top-left corner to the bottom-right corner of a 3 x 3 grid.\n\n    Constraints:\n    - The input integer n will always be non-negative.\n    \"\"\"\n\n    def factorial(num):\n        if num == 0 or num == 1:\n            return 1\n        return num * factorial(num - 1)\n\n    return factorial(2 * n - 2) // (factorial(n - 1) * factorial(n - 1))\n\ndef g(n=3):\n    return n\n\nassert f(g()) == 6\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], "idx_generation": 356, "target_skills": [0, 1, 1, 1, 1, 1, 1, 1, 0, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid. You can only move right or down at any point in time.\n\n    Example:\n    n = 3\n\n    Output:\n    6\n\n    Explanation:\n    There are 6 unique paths from the top-left corner to the bottom-right corner of a 3 x 3 grid.\n\n    Constraints:\n    - The input integer n will always be non-negative.\n    \"\"\"\n\n    def factorial(num):\n        if num == 0 or num == 1:\n            return 1\n        return num * factorial(num - 1)\n\n    return factorial(2 * n - 2) // (factorial(n - 1) * factorial(n - 1))", "solution_func": "def g(n=3):\n    return n", "map_ix": [0, 1, 0, 0, 0, 0, 1, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all numbers from 1 to n that are multiples of either 3 or 5.\n\n    Sample Input:\n    n = 10\n\n    Sample Output:\n    33\n\n    Explanation:\n    The numbers from 1 to 10 that are multiples of either 3 or 5 are: 3, 5, 6, and 9.\n    The sum of these numbers is 3 + 5 + 6 + 9 = 23.\n    \"\"\"\n\n    def calculate_sum(n: int) -> int:\n        total_sum = 0\n        for i in range(1, n+1):\n            if i % 3 == 0 or i % 5 == 0:\n                total_sum += i\n        return total_sum\n\n    return calculate_sum(n)\n\ndef g(n: int = 10) -> int:\n    return n\n\nassert f(g()) == 33\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 356, "target_skills": [1, 1, 0, 1, 0, 0, 0, 0, 1, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all numbers from 1 to n that are multiples of either 3 or 5.\n\n    Sample Input:\n    n = 10\n\n    Sample Output:\n    33\n\n    Explanation:\n    The numbers from 1 to 10 that are multiples of either 3 or 5 are: 3, 5, 6, and 9.\n    The sum of these numbers is 3 + 5 + 6 + 9 = 23.\n    \"\"\"\n\n    def calculate_sum(n: int) -> int:\n        total_sum = 0\n        for i in range(1, n+1):\n            if i % 3 == 0 or i % 5 == 0:\n                total_sum += i\n        return total_sum\n\n    return calculate_sum(n)", "solution_func": "def g(n: int = 10) -> int:\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers, find the index of the first occurrence of a target element.\n    If the target is not found, return -1.\n    \"\"\"\n    low = 0\n    high = len(nums) - 1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        \n        if nums[mid] == target:\n            if mid == 0 or nums[mid - 1] != target:\n                return mid\n            else:\n                high = mid - 1\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return -1\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 5, 6, 6, 6, 7]\n    target = 6\n    return (nums, target)\n\nassert f(*g()) == 6\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 357, "target_skills": [1, 1, 1, 1, 0, 1, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers, find the index of the first occurrence of a target element.\n    If the target is not found, return -1.\n    \"\"\"\n    low = 0\n    high = len(nums) - 1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        \n        if nums[mid] == target:\n            if mid == 0 or nums[mid - 1] != target:\n                return mid\n            else:\n                high = mid - 1\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return -1", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5, 5, 6, 6, 6, 7]\n    target = 6\n    return (nums, target)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(string: str) -> int:\n    \"\"\"\n    Given a string, count the number of distinct substrings that can be formed from the string.\n    \"\"\"\n    distinct_substrings = set()\n    \n    for i in range(len(string)):\n        for j in range(i+1, len(string)+1):\n            distinct_substrings.add(string[i:j])\n    \n    return len(distinct_substrings)\n\ndef g():\n    string = \"abc\"\n    return string\n\nassert f(g()) == 6\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 357, "target_skills": [0, 1, 0, 1, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\ndef f(string: str) -> int:\n    \"\"\"\n    Given a string, count the number of distinct substrings that can be formed from the string.\n    \"\"\"\n    distinct_substrings = set()\n    \n    for i in range(len(string)):\n        for j in range(i+1, len(string)+1):\n            distinct_substrings.add(string[i:j])\n    \n    return len(distinct_substrings)", "solution_func": "def g():\n    string = \"abc\"\n    return string", "map_ix": [0, 1, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an undirected graph, find the number of connected components.\n    \"\"\"\n    def dfs(node, visited):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited)\n    \n    n = len(graph)\n    visited = [False] * n\n    count = 0\n    \n    for i in range(n):\n        if not visited[i]:\n            dfs(i, visited)\n            count += 1\n    \n    return count\n\ndef g():\n    graph = [[1, 2], [0, 2], [0, 1], [3], [4], [5], [6], [7], [8], [9]]\n    return graph\n\nassert f(g()) == 3\n", "emb": null, "idx_generation": 357, "target_skills": [1, 1, 1, 1, 1, 1, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an undirected graph, find the number of connected components.\n    \"\"\"\n    def dfs(node, visited):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited)\n    \n    n = len(graph)\n    visited = [False] * n\n    count = 0\n    \n    for i in range(n):\n        if not visited[i]:\n            dfs(i, visited)\n            count += 1\n    \n    return count", "solution_func": "def g():\n    graph = [[1, 2], [0, 2], [0, 1], [3], [4], [5], [6], [7], [8], [9]]\n    return graph", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a prime number.\n\n    Args:\n    - n: The integer to be checked.\n\n    Returns:\n    - True if n is a prime number, False otherwise.\n\n    Example:\n    f(7)\n\n    Output:\n    True\n\n    Explanation:\n    7 is a prime number.\n    \"\"\"\n\n    if n <= 1:\n        return False\n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n\n    return True\n\ndef g() -> int:\n    \"\"\"\n    Generate an integer.\n\n    Returns:\n    - The generated integer.\n\n    Example:\n    g() returns 7\n    \"\"\"\n\n    return 7\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 357, "target_skills": [0, 1, 0, 0, 1, 0, 0, 0, 1, 0], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a prime number.\n\n    Args:\n    - n: The integer to be checked.\n\n    Returns:\n    - True if n is a prime number, False otherwise.\n\n    Example:\n    f(7)\n\n    Output:\n    True\n\n    Explanation:\n    7 is a prime number.\n    \"\"\"\n\n    if n <= 1:\n        return False\n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n\n    return True", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate an integer.\n\n    Returns:\n    - The generated integer.\n\n    Example:\n    g() returns 7\n    \"\"\"\n\n    return 7", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> List[int]:\n    \"\"\"\n    Given a string s, return a list of indices representing the starting positions of each occurrence of the substring \"ab\" in s.\n\n    Args:\n    - s: The input string.\n\n    Returns:\n    - A list of starting positions of each occurrence of \"ab\" in s.\n\n    Example:\n    f(\"abababa\")\n\n    Output:\n    [0, 2, 4]\n\n    Explanation:\n    The substring \"ab\" occurs at positions 0, 2, and 4 in the string \"abababa\".\n    \"\"\"\n\n    indices = []\n    i = 0\n\n    while i < len(s):\n        if s[i:i+2] == \"ab\":\n            indices.append(i)\n            i += 2\n        else:\n            i += 1\n\n    return indices\n\ndef g() -> str:\n    \"\"\"\n    Generate a string.\n\n    Returns:\n    - The generated string.\n\n    Example:\n    g() returns \"abababa\"\n    \"\"\"\n\n    return \"abababa\"\n\nassert f(g()) == [0, 2, 4]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 357, "target_skills": [1, 1, 0, 0, 0, 0, 0, 1, 0, 1], "problem_func": "from typing import*\ndef f(s: str) -> List[int]:\n    \"\"\"\n    Given a string s, return a list of indices representing the starting positions of each occurrence of the substring \"ab\" in s.\n\n    Args:\n    - s: The input string.\n\n    Returns:\n    - A list of starting positions of each occurrence of \"ab\" in s.\n\n    Example:\n    f(\"abababa\")\n\n    Output:\n    [0, 2, 4]\n\n    Explanation:\n    The substring \"ab\" occurs at positions 0, 2, and 4 in the string \"abababa\".\n    \"\"\"\n\n    indices = []\n    i = 0\n\n    while i < len(s):\n        if s[i:i+2] == \"ab\":\n            indices.append(i)\n            i += 2\n        else:\n            i += 1\n\n    return indices", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate a string.\n\n    Returns:\n    - The generated string.\n\n    Example:\n    g() returns \"abababa\"\n    \"\"\"\n\n    return \"abababa\"", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the shortest path from the top-left corner to the bottom-right corner,\n    moving only right or down. Each cell in the grid represents the cost of moving to that cell.\n    Return the minimum cost to reach the bottom-right corner.\n\n    Args:\n    - grid: A 2D list of integers representing the grid.\n\n    Returns:\n    - The minimum cost to reach the bottom-right corner.\n\n    Example:\n    f([[1, 3, 1],\n       [1, 5, 1],\n       [4, 2, 1]])\n\n    Output:\n    7\n\n    Explanation:\n    The minimum cost path is 1 -> 3 -> 1 -> 1 -> 1, with a total cost of 7.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    # Initialize the first column\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    # Initialize the first row\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    # Calculate the minimum cost for each cell\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[-1][-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid.\n\n    Returns:\n    - The generated grid.\n\n    Example:\n    g() returns [[1, 3, 1],\n                 [1, 5, 1],\n                 [4, 2, 1]]\n    \"\"\"\n\n    return [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\nassert f(g()) == 7\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 357, "target_skills": [1, 0, 1, 1, 1, 0, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the shortest path from the top-left corner to the bottom-right corner,\n    moving only right or down. Each cell in the grid represents the cost of moving to that cell.\n    Return the minimum cost to reach the bottom-right corner.\n\n    Args:\n    - grid: A 2D list of integers representing the grid.\n\n    Returns:\n    - The minimum cost to reach the bottom-right corner.\n\n    Example:\n    f([[1, 3, 1],\n       [1, 5, 1],\n       [4, 2, 1]])\n\n    Output:\n    7\n\n    Explanation:\n    The minimum cost path is 1 -> 3 -> 1 -> 1 -> 1, with a total cost of 7.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    # Initialize the first column\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    # Initialize the first row\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    # Calculate the minimum cost for each cell\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[-1][-1]", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid.\n\n    Returns:\n    - The generated grid.\n\n    Example:\n    g() returns [[1, 3, 1],\n                 [1, 5, 1],\n                 [4, 2, 1]]\n    \"\"\"\n\n    return [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target in the list using binary search.\n    If the target is not found, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g():\n    return [1, 3, 5, 7, 9], 5\n\nassert f(*g()) == 2\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 357, "target_skills": [0, 1, 0, 0, 0, 1, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target in the list using binary search.\n    If the target is not found, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1", "solution_func": "def g():\n    return [1, 3, 5, 7, 9], 5", "map_ix": [1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, rotate the matrix 90 degrees clockwise.\n    \"\"\"\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n    \n    return matrix\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(*g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n\n", "emb": null, "idx_generation": 357, "target_skills": [0, 1, 1, 0, 1, 1, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, rotate the matrix 90 degrees clockwise.\n    \"\"\"\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n    \n    return matrix", "solution_func": "def g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, words: List[str]) -> int:\n    \"\"\"\n    Given an integer n and a list of words, find the number of words that have length greater than or equal to n.\n    \"\"\"\n    count = 0\n    for word in words:\n        if len(word) >= n:\n            count += 1\n    \n    return count\n\ndef g():\n    return 5, [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"]\n\nassert f(*g()) == 3\n\n", "emb": null, "idx_generation": 357, "target_skills": [0, 1, 0, 0, 0, 0, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, words: List[str]) -> int:\n    \"\"\"\n    Given an integer n and a list of words, find the number of words that have length greater than or equal to n.\n    \"\"\"\n    count = 0\n    for word in words:\n        if len(word) >= n:\n            count += 1\n    \n    return count", "solution_func": "def g():\n    return 5, [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, count the number of subarrays with an odd number of elements that have a sum greater than or equal to the average of the entire array.\n\n    Args:\n    - nums: The list of integers.\n\n    Returns:\n    - The number of subarrays with an odd number of elements that have a sum greater than or equal to the average of the entire array.\n    \"\"\"\n    count = 0\n    average = sum(nums) / len(nums)\n\n    for i in range(len(nums)):\n        for j in range(i, len(nums), 2):\n            subarray = nums[i:j+1]\n            if sum(subarray) >= average:\n                count += 1\n\n    return count\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 6\n", "emb": null, "idx_generation": 357, "target_skills": [1, 0, 0, 0, 1, 1, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, count the number of subarrays with an odd number of elements that have a sum greater than or equal to the average of the entire array.\n\n    Args:\n    - nums: The list of integers.\n\n    Returns:\n    - The number of subarrays with an odd number of elements that have a sum greater than or equal to the average of the entire array.\n    \"\"\"\n    count = 0\n    average = sum(nums) / len(nums)\n\n    for i in range(len(nums)):\n        for j in range(i, len(nums), 2):\n            subarray = nums[i:j+1]\n            if sum(subarray) >= average:\n                count += 1\n\n    return count", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, find the length of the longest path that can be formed by connecting adjacent characters.\n    The path can only be formed by moving up, down, left, or right from one character to another.\n    \n    Example:\n    grid = [\n        [\"A\", \"B\", \"C\"],\n        [\"D\", \"E\", \"F\"],\n        [\"G\", \"H\", \"I\"]\n    ]\n    \n    Output:\n    9 (the longest path can be formed by connecting 'A' -> 'B' -> 'C' -> 'F' -> 'I' -> 'H' -> 'G' -> 'D' -> 'E')\n    \"\"\"\n    if not grid:\n        return 0\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    \n    def dfs(row: int, col: int, path_len: int) -> int:\n        path_len += 1\n        \n        # Mark the current cell as visited\n        temp = grid[row][col]\n        grid[row][col] = \"#\"\n        \n        # Explore the neighboring cells\n        max_path_len = path_len\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        for dx, dy in directions:\n            new_row, new_col = row + dx, col + dy\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] != \"#\":\n                max_path_len = max(max_path_len, dfs(new_row, new_col, path_len))\n        \n        # Restore the cell value\n        grid[row][col] = temp\n        \n        return max_path_len\n    \n    longest_path = 0\n    for row in range(rows):\n        for col in range(cols):\n            if grid[row][col] != \"#\":\n                longest_path = max(longest_path, dfs(row, col, 0))\n    \n    return longest_path\n\ndef g():\n    grid = [\n        [\"A\", \"B\", \"C\"],\n        [\"D\", \"E\", \"F\"],\n        [\"G\", \"H\", \"I\"]\n    ]\n    return grid\n\nassert f(g()) == 9\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 358, "target_skills": [1, 0, 0, 0, 0, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, find the length of the longest path that can be formed by connecting adjacent characters.\n    The path can only be formed by moving up, down, left, or right from one character to another.\n    \n    Example:\n    grid = [\n        [\"A\", \"B\", \"C\"],\n        [\"D\", \"E\", \"F\"],\n        [\"G\", \"H\", \"I\"]\n    ]\n    \n    Output:\n    9 (the longest path can be formed by connecting 'A' -> 'B' -> 'C' -> 'F' -> 'I' -> 'H' -> 'G' -> 'D' -> 'E')\n    \"\"\"\n    if not grid:\n        return 0\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    \n    def dfs(row: int, col: int, path_len: int) -> int:\n        path_len += 1\n        \n        # Mark the current cell as visited\n        temp = grid[row][col]\n        grid[row][col] = \"#\"\n        \n        # Explore the neighboring cells\n        max_path_len = path_len\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        for dx, dy in directions:\n            new_row, new_col = row + dx, col + dy\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] != \"#\":\n                max_path_len = max(max_path_len, dfs(new_row, new_col, path_len))\n        \n        # Restore the cell value\n        grid[row][col] = temp\n        \n        return max_path_len\n    \n    longest_path = 0\n    for row in range(rows):\n        for col in range(cols):\n            if grid[row][col] != \"#\":\n                longest_path = max(longest_path, dfs(row, col, 0))\n    \n    return longest_path", "solution_func": "def g():\n    grid = [\n        [\"A\", \"B\", \"C\"],\n        [\"D\", \"E\", \"F\"],\n        [\"G\", \"H\", \"I\"]\n    ]\n    return grid", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in ascending order.\n    \n    Example:\n    nums = [2, 5, 7, 11, 15]\n    target = 9\n    \n    Output:\n    [0, 2] (2 + 7 = 9)\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g():\n    nums = [2, 5, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 2]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 358, "target_skills": [0, 0, 1, 1, 0, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in ascending order.\n    \n    Example:\n    nums = [2, 5, 7, 11, 15]\n    target = 9\n    \n    Output:\n    [0, 2] (2 + 7 = 9)\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []", "solution_func": "def g():\n    nums = [2, 5, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the length of the shortest path from the top-left cell to the bottom-right cell.\n    You can only move down or right at each step.\n    \n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    \n    Output:\n    7 (the shortest path is 1 -> 3 -> 1 -> 1 -> 1)\n    \"\"\"\n    if not grid:\n        return 0\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    \n    dp[0][0] = grid[0][0]\n    \n    # Fill the first row\n    for col in range(1, cols):\n        dp[0][col] = dp[0][col-1] + grid[0][col]\n    \n    # Fill the first column\n    for row in range(1, rows):\n        dp[row][0] = dp[row-1][0] + grid[row][0]\n    \n    # Fill the remaining cells\n    for row in range(1, rows):\n        for col in range(1, cols):\n            dp[row][col] = min(dp[row-1][col], dp[row][col-1]) + grid[row][col]\n    \n    return dp[rows-1][cols-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 358, "target_skills": [0, 1, 1, 1, 0, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the length of the shortest path from the top-left cell to the bottom-right cell.\n    You can only move down or right at each step.\n    \n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    \n    Output:\n    7 (the shortest path is 1 -> 3 -> 1 -> 1 -> 1)\n    \"\"\"\n    if not grid:\n        return 0\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    \n    dp[0][0] = grid[0][0]\n    \n    # Fill the first row\n    for col in range(1, cols):\n        dp[0][col] = dp[0][col-1] + grid[0][col]\n    \n    # Fill the first column\n    for row in range(1, rows):\n        dp[row][0] = dp[row-1][0] + grid[row][0]\n    \n    # Fill the remaining cells\n    for row in range(1, rows):\n        for col in range(1, cols):\n            dp[row][col] = min(dp[row-1][col], dp[row][col-1]) + grid[row][col]\n    \n    return dp[rows-1][cols-1]", "solution_func": "def g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": [1, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of integers, determine if there exists a path from the top-left corner to the bottom-right corner,\n    where the sum of the numbers along the path is divisible by 3.\n    \"\"\"\n    def dfs(i, j, curr_sum):\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\n            return curr_sum % 3 == 0\n        if i < len(grid) - 1 and dfs(i + 1, j, curr_sum + grid[i + 1][j]):\n            return True\n        if j < len(grid[0]) - 1 and dfs(i, j + 1, curr_sum + grid[i][j + 1]):\n            return True\n        return False\n\n    return dfs(0, 0, grid[0][0]) if grid else False\n\ndef g(grid: List[List[int]] = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return grid\n\nassert f(g())\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 358, "target_skills": [0, 0, 0, 0, 0, 1, 0, 1, 0, 0], "problem_func": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of integers, determine if there exists a path from the top-left corner to the bottom-right corner,\n    where the sum of the numbers along the path is divisible by 3.\n    \"\"\"\n    def dfs(i, j, curr_sum):\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\n            return curr_sum % 3 == 0\n        if i < len(grid) - 1 and dfs(i + 1, j, curr_sum + grid[i + 1][j]):\n            return True\n        if j < len(grid[0]) - 1 and dfs(i, j + 1, curr_sum + grid[i][j + 1]):\n            return True\n        return False\n\n    return dfs(0, 0, grid[0][0]) if grid else False", "solution_func": "def g(grid: List[List[int]] = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n    \"\"\"\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g(nums: List[int] = [4, 2, 9, 7, 5, 8, 11, 3, 1]):\n    return nums\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 358, "target_skills": [1, 1, 1, 0, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n    \"\"\"\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "solution_func": "def g(nums: List[int] = [4, 2, 9, 7, 5, 8, 11, 3, 1]):\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n    \"\"\"\n    def fibonacci(n, memo={}):\n        if n in memo:\n            return memo[n]\n        if n <= 2:\n            return 1\n        memo[n] = fibonacci(n - 1) + fibonacci(n - 2)\n        return memo[n]\n\n    return fibonacci(n)\n\ndef g(n: int = 6):\n    return n\n\nassert f(g()) == 8\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 358, "target_skills": [0, 0, 0, 0, 0, 0, 1, 0, 1, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n    \"\"\"\n    def fibonacci(n, memo={}):\n        if n in memo:\n            return memo[n]\n        if n <= 2:\n            return 1\n        memo[n] = fibonacci(n - 1) + fibonacci(n - 2)\n        return memo[n]\n\n    return fibonacci(n)", "solution_func": "def g(n: int = 6):\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "import math\nfrom typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if a string s is a palindrome and contains a valid mathematical expression.\n\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n    A valid mathematical expression contains only digits, arithmetic operators (+, -, *, /), and balanced parentheses.\n    \"\"\"\n\n    # Check if s is a palindrome\n    if s != s[::-1]:\n        return False\n\n    # Check if s contains a valid mathematical expression\n    stack = []\n    for char in s:\n        if char.isdigit() or char in \"+-*/\":\n            stack.append(char)\n        elif char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if not stack:\n                return False\n            stack.pop()\n    if stack:\n        return False\n\n    return True\n\ndef g(s: str = \"12321\"):\n    \"\"\"\n    Generate a palindrome string that contains a valid mathematical expression.\n    \"\"\"\n    return s\n\nassert f(g()) == True\n", "emb": null, "idx_generation": 358, "target_skills": [1, 1, 1, 1, 1, 1, 0, 1, 0, 0], "problem_func": "import math\nfrom typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if a string s is a palindrome and contains a valid mathematical expression.\n\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n    A valid mathematical expression contains only digits, arithmetic operators (+, -, *, /), and balanced parentheses.\n    \"\"\"\n\n    # Check if s is a palindrome\n    if s != s[::-1]:\n        return False\n\n    # Check if s contains a valid mathematical expression\n    stack = []\n    for char in s:\n        if char.isdigit() or char in \"+-*/\":\n            stack.append(char)\n        elif char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if not stack:\n                return False\n            stack.pop()\n    if stack:\n        return False\n\n    return True", "solution_func": "def g(s: str = \"12321\"):\n    \"\"\"\n    Generate a palindrome string that contains a valid mathematical expression.\n    \"\"\"\n    return s", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"\n    Check if a string s can be formed by concatenating words from a given list of words.\n\n    The words can be concatenated in any order and any word can be used multiple times.\n    \"\"\"\n\n    # Create a dictionary to store the frequency of each word\n    word_freq = {}\n    for word in words:\n        if word in word_freq:\n            word_freq[word] += 1\n        else:\n            word_freq[word] = 1\n\n    # Check if s can be formed by concatenating words\n    stack = [(\"\", s)]\n    while stack:\n        prefix, remaining = stack.pop()\n        if remaining == \"\":\n            return True\n        for word in words:\n            if remaining.startswith(word):\n                new_prefix = prefix + word\n                new_remaining = remaining[len(word):]\n                if word_freq[word] > 1:\n                    stack.append((new_prefix, new_remaining))\n                else:\n                    stack.append((new_prefix, new_remaining))\n\n    return False\n\ndef g(s: str = \"leetcode\", words: List[str] = [\"leet\", \"code\"]):\n    \"\"\"\n    Generate a string and a list of words that can form the string by concatenation.\n    \"\"\"\n    return s, words\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 358, "target_skills": [1, 1, 1, 1, 0, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"\n    Check if a string s can be formed by concatenating words from a given list of words.\n\n    The words can be concatenated in any order and any word can be used multiple times.\n    \"\"\"\n\n    # Create a dictionary to store the frequency of each word\n    word_freq = {}\n    for word in words:\n        if word in word_freq:\n            word_freq[word] += 1\n        else:\n            word_freq[word] = 1\n\n    # Check if s can be formed by concatenating words\n    stack = [(\"\", s)]\n    while stack:\n        prefix, remaining = stack.pop()\n        if remaining == \"\":\n            return True\n        for word in words:\n            if remaining.startswith(word):\n                new_prefix = prefix + word\n                new_remaining = remaining[len(word):]\n                if word_freq[word] > 1:\n                    stack.append((new_prefix, new_remaining))\n                else:\n                    stack.append((new_prefix, new_remaining))\n\n    return False", "solution_func": "def g(s: str = \"leetcode\", words: List[str] = [\"leet\", \"code\"]):\n    \"\"\"\n    Generate a string and a list of words that can form the string by concatenation.\n    \"\"\"\n    return s, words", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of the words in the string.\n\n    Words are separated by a single space and the string does not contain leading or trailing spaces.\n    \"\"\"\n\n    # Split the string into words\n    words = s.split()\n\n    # Reverse the order of the words\n    reversed_words = words[::-1]\n\n    # Join the reversed words with a space separator\n    reversed_string = \" \".join(reversed_words)\n\n    return reversed_string\n\ndef g(s: str = \"hello world\"):\n    \"\"\"\n    Generate a string with words in a specific order.\n    \"\"\"\n    return s\n\nassert f(g()) == \"world hello\"\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 358, "target_skills": [0, 1, 0, 0, 0, 1, 0, 1, 1, 0], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of the words in the string.\n\n    Words are separated by a single space and the string does not contain leading or trailing spaces.\n    \"\"\"\n\n    # Split the string into words\n    words = s.split()\n\n    # Reverse the order of the words\n    reversed_words = words[::-1]\n\n    # Join the reversed words with a space separator\n    reversed_string = \" \".join(reversed_words)\n\n    return reversed_string", "solution_func": "def g(s: str = \"hello world\"):\n    \"\"\"\n    Generate a string with words in a specific order.\n    \"\"\"\n    return s", "map_ix": [1, 1, 0, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if they are isomorphic.\n    Two strings are isomorphic if the characters in s can be replaced to get t.\n\n    The replacement must be one-to-one, meaning that each character in s must be replaced with a unique character in t, and vice versa.\n\n    Example:\n    Input: s = \"egg\", t = \"add\"\n    Output: True\n    \"\"\"\n\n    if len(s) != len(t):\n        return False\n\n    mapping_s = {}\n    mapping_t = {}\n\n    for i in range(len(s)):\n        if s[i] in mapping_s:\n            if mapping_s[s[i]] != t[i]:\n                return False\n        else:\n            mapping_s[s[i]] = t[i]\n\n        if t[i] in mapping_t:\n            if mapping_t[t[i]] != s[i]:\n                return False\n        else:\n            mapping_t[t[i]] = s[i]\n\n    return True\n\ndef g() -> Tuple[str, str]:\n    \"\"\"\n    Generate two isomorphic strings.\n    \"\"\"\n    return \"egg\", \"add\"\n\nassert f(*g())\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 358, "target_skills": [0, 1, 1, 0, 1, 1, 1, 1, 0, 0], "problem_func": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if they are isomorphic.\n    Two strings are isomorphic if the characters in s can be replaced to get t.\n\n    The replacement must be one-to-one, meaning that each character in s must be replaced with a unique character in t, and vice versa.\n\n    Example:\n    Input: s = \"egg\", t = \"add\"\n    Output: True\n    \"\"\"\n\n    if len(s) != len(t):\n        return False\n\n    mapping_s = {}\n    mapping_t = {}\n\n    for i in range(len(s)):\n        if s[i] in mapping_s:\n            if mapping_s[s[i]] != t[i]:\n                return False\n        else:\n            mapping_s[s[i]] = t[i]\n\n        if t[i] in mapping_t:\n            if mapping_t[t[i]] != s[i]:\n                return False\n        else:\n            mapping_t[t[i]] = s[i]\n\n    return True", "solution_func": "def g() -> Tuple[str, str]:\n    \"\"\"\n    Generate two isomorphic strings.\n    \"\"\"\n    return \"egg\", \"add\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Island Perimeter\n\n    Given a grid representing a 2D map of land and water, calculate the perimeter of the island present in the grid.\n    The grid is represented by a 2D list of 0s and 1s, where 0 represents water and 1 represents land.\n    The island is surrounded by water, and adjacent land cells are connected horizontally or vertically (not diagonally).\n    The perimeter is the total length of the boundary between the land and water cells.\n\n    Example:\n    grid = [\n        [0, 1, 0, 0],\n        [1, 1, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 0, 0]\n    ]\n    output: 16\n\n    Explanation:\n    In the above example, the island is represented by the 1s in the grid.\n    The perimeter is calculated by counting the number of edges between adjacent land and water cells.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    perimeter = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                perimeter += 4\n                if i > 0 and grid[i - 1][j] == 1:\n                    perimeter -= 2\n                if j > 0 and grid[i][j - 1] == 1:\n                    perimeter -= 2\n\n    return perimeter\n\ndef g(grid = [\n    [0, 1, 0, 0],\n    [1, 1, 1, 0],\n    [0, 1, 0, 0],\n    [1, 1, 0, 0]\n]):\n    return grid\n\nassert f(*g())\n", "emb": null, "idx_generation": 359, "target_skills": [1, 0, 1, 1, 1, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Island Perimeter\n\n    Given a grid representing a 2D map of land and water, calculate the perimeter of the island present in the grid.\n    The grid is represented by a 2D list of 0s and 1s, where 0 represents water and 1 represents land.\n    The island is surrounded by water, and adjacent land cells are connected horizontally or vertically (not diagonally).\n    The perimeter is the total length of the boundary between the land and water cells.\n\n    Example:\n    grid = [\n        [0, 1, 0, 0],\n        [1, 1, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 0, 0]\n    ]\n    output: 16\n\n    Explanation:\n    In the above example, the island is represented by the 1s in the grid.\n    The perimeter is calculated by counting the number of edges between adjacent land and water cells.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    perimeter = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                perimeter += 4\n                if i > 0 and grid[i - 1][j] == 1:\n                    perimeter -= 2\n                if j > 0 and grid[i][j - 1] == 1:\n                    perimeter -= 2\n\n    return perimeter", "solution_func": "def g(grid = [\n    [0, 1, 0, 0],\n    [1, 1, 1, 0],\n    [0, 1, 0, 0],\n    [1, 1, 0, 0]\n]):\n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> float:\n    \"\"\"\n    Maximum Area of Triangle\n\n    Given a list of points in a 2D plane, find the maximum possible area of a triangle formed by any three points from the list.\n    The area of a triangle can be calculated using the formula: (1/2) * base * height, where base is the length of the base of the triangle\n    and height is the perpendicular distance from the base to the opposite vertex.\n\n    Example:\n    points = [[0, 0], [0, 1], [1, 0], [0, 2], [2, 0]]\n    output: 2.0\n\n    Explanation:\n    In the above example, the maximum area of a triangle can be formed by the points [[0, 0], [0, 2], [2, 0]].\n    The base of the triangle is 2 and the height is 2, so the area is (1/2) * 2 * 2 = 2.\n    \"\"\"\n    max_area = 0\n\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            for k in range(j + 1, len(points)):\n                area = abs((points[i][0] * (points[j][1] - points[k][1]) +\n                            points[j][0] * (points[k][1] - points[i][1]) +\n                            points[k][0] * (points[i][1] - points[j][1])) / 2)\n\n                max_area = max(max_area, area)\n\n    return max_area\n\ndef g(points = [[0, 0], [0, 1], [1, 0], [0, 2], [2, 0]]):\n    return points\n\nassert f(*g())\n", "emb": null, "idx_generation": 359, "target_skills": [1, 1, 0, 1, 1, 1, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> float:\n    \"\"\"\n    Maximum Area of Triangle\n\n    Given a list of points in a 2D plane, find the maximum possible area of a triangle formed by any three points from the list.\n    The area of a triangle can be calculated using the formula: (1/2) * base * height, where base is the length of the base of the triangle\n    and height is the perpendicular distance from the base to the opposite vertex.\n\n    Example:\n    points = [[0, 0], [0, 1], [1, 0], [0, 2], [2, 0]]\n    output: 2.0\n\n    Explanation:\n    In the above example, the maximum area of a triangle can be formed by the points [[0, 0], [0, 2], [2, 0]].\n    The base of the triangle is 2 and the height is 2, so the area is (1/2) * 2 * 2 = 2.\n    \"\"\"\n    max_area = 0\n\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            for k in range(j + 1, len(points)):\n                area = abs((points[i][0] * (points[j][1] - points[k][1]) +\n                            points[j][0] * (points[k][1] - points[i][1]) +\n                            points[k][0] * (points[i][1] - points[j][1])) / 2)\n\n                max_area = max(max_area, area)\n\n    return max_area", "solution_func": "def g(points = [[0, 0], [0, 1], [1, 0], [0, 2], [2, 0]]):\n    return points", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Maximum Area of Rectangle in Grid\n\n    Given a grid of 0s and 1s, find the maximum area of a rectangle that can be formed using only 1s.\n    The rectangle must be aligned with the grid (horizontal or vertical sides) and can have any number of rows and columns.\n\n    Example:\n    grid = [\n        [1, 1, 0, 1],\n        [1, 1, 1, 1],\n        [1, 1, 1, 0],\n        [0, 1, 1, 1]\n    ]\n    output: 8\n\n    Explanation:\n    In the above example, the maximum area of a rectangle can be formed by the coordinates (0, 0), (0, 1), (1, 0), and (1, 1).\n    The rectangle has a height of 2 and a width of 2, so the area is 2 * 2 = 4.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    max_area = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                width = 0\n                height = 0\n\n                while j + width < cols and grid[i][j + width] == 1:\n                    width += 1\n\n                for k in range(i, rows):\n                    if all(grid[l][j:j + width] == [1] * width for l in range(i, k + 1)):\n                        height = k - i + 1\n\n                max_area = max(max_area, width * height)\n\n    return max_area\n\ndef g(grid = [\n    [1, 1, 0, 1],\n    [1, 1, 1, 1],\n    [1, 1, 1, 0],\n    [0, 1, 1, 1]\n]):\n    return grid\n\nassert f(*g())\n", "emb": null, "idx_generation": 359, "target_skills": [0, 1, 0, 0, 0, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Maximum Area of Rectangle in Grid\n\n    Given a grid of 0s and 1s, find the maximum area of a rectangle that can be formed using only 1s.\n    The rectangle must be aligned with the grid (horizontal or vertical sides) and can have any number of rows and columns.\n\n    Example:\n    grid = [\n        [1, 1, 0, 1],\n        [1, 1, 1, 1],\n        [1, 1, 1, 0],\n        [0, 1, 1, 1]\n    ]\n    output: 8\n\n    Explanation:\n    In the above example, the maximum area of a rectangle can be formed by the coordinates (0, 0), (0, 1), (1, 0), and (1, 1).\n    The rectangle has a height of 2 and a width of 2, so the area is 2 * 2 = 4.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    max_area = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                width = 0\n                height = 0\n\n                while j + width < cols and grid[i][j + width] == 1:\n                    width += 1\n\n                for k in range(i, rows):\n                    if all(grid[l][j:j + width] == [1] * width for l in range(i, k + 1)):\n                        height = k - i + 1\n\n                max_area = max(max_area, width * height)\n\n    return max_area", "solution_func": "def g(grid = [\n    [1, 1, 0, 1],\n    [1, 1, 1, 1],\n    [1, 1, 1, 0],\n    [0, 1, 1, 1]\n]):\n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray using the Kadane's algorithm.\n    \"\"\"\n    max_sum = nums[0]\n    current_sum = nums[0]\n    \n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef g():\n    return [1, -2, 3, 4, -5, 6, -7, 8]\n\nassert f(g()) == 14\n", "emb": null, "idx_generation": 359, "target_skills": [1, 0, 0, 0, 0, 1, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray using the Kadane's algorithm.\n    \"\"\"\n    max_sum = nums[0]\n    current_sum = nums[0]\n    \n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum", "solution_func": "def g():\n    return [1, -2, 3, 4, -5, 6, -7, 8]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of trailing zeros in n factorial.\n    \"\"\"\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n    return count\n\ndef g():\n    return 25\n\nassert f(g()) == 6\n", "emb": [0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 359, "target_skills": [1, 0, 0, 0, 0, 0, 0, 1, 1, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of trailing zeros in n factorial.\n    \"\"\"\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n    return count", "solution_func": "def g():\n    return 25", "map_ix": [0, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> List[int]:\n    \"\"\"\n    Given a string of numbers, calculate the product of each pair of consecutive digits and return the list of products.\n    \"\"\"\n    products = []\n    for i in range(len(s) - 1):\n        product = int(s[i]) * int(s[i+1])\n        products.append(product)\n    return products\n\ndef g():\n    return \"123456\"\n\nassert f(g()) == [2, 6, 12, 20, 30, 42]\n", "emb": null, "idx_generation": 359, "target_skills": [1, 1, 0, 1, 1, 1, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> List[int]:\n    \"\"\"\n    Given a string of numbers, calculate the product of each pair of consecutive digits and return the list of products.\n    \"\"\"\n    products = []\n    for i in range(len(s) - 1):\n        product = int(s[i]) * int(s[i+1])\n        products.append(product)\n    return products", "solution_func": "def g():\n    return \"123456\"", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(string: str, substr: str) -> int:\n    \"\"\"\n    Given a string and a substring, count the number of occurrences of the substring in the string.\n\n    Example:\n    string = \"ababa\"\n    substr = \"aba\"\n\n    Output:\n    2\n\n    Explanation:\n    The substring \"aba\" appears twice in the string \"ababa\".\n    \"\"\"\n    count = 0\n    start = 0\n    \n    while start < len(string):\n        index = string.find(substr, start)\n        if index == -1:\n            break\n        count += 1\n        start = index + 1\n    \n    return count\n\ndef g(string: str = \"ababa\", substr: str = \"aba\") -> int:\n    \"\"\"\n    Generate the input for the function f.\n    \"\"\"\n    return string, substr\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 359, "target_skills": [1, 0, 1, 0, 1, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(string: str, substr: str) -> int:\n    \"\"\"\n    Given a string and a substring, count the number of occurrences of the substring in the string.\n\n    Example:\n    string = \"ababa\"\n    substr = \"aba\"\n\n    Output:\n    2\n\n    Explanation:\n    The substring \"aba\" appears twice in the string \"ababa\".\n    \"\"\"\n    count = 0\n    start = 0\n    \n    while start < len(string):\n        index = string.find(substr, start)\n        if index == -1:\n            break\n        count += 1\n        start = index + 1\n    \n    return count", "solution_func": "def g(string: str = \"ababa\", substr: str = \"aba\") -> int:\n    \"\"\"\n    Generate the input for the function f.\n    \"\"\"\n    return string, substr", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray within the list.\n\n    Example:\n    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef g(arr: List[int] = [-2, 1, -3, 4, -1, 2, 1, -5, 4]) -> int:\n    \"\"\"\n    Generate the input for the function f.\n    \"\"\"\n    return arr\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 359, "target_skills": [0, 0, 1, 1, 0, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray within the list.\n\n    Example:\n    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum", "solution_func": "def g(arr: List[int] = [-2, 1, -3, 4, -1, 2, 1, -5, 4]) -> int:\n    \"\"\"\n    Generate the input for the function f.\n    \"\"\"\n    return arr", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of ways to reach the bottom-right corner of a grid\n    starting from the top-left corner. You can only move down or right.\n\n    Example:\n    n = 3\n\n    Output:\n    6\n\n    Explanation:\n    There are 6 possible paths to reach the bottom-right corner:\n    1. Right -> Right -> Down\n    2. Right -> Down -> Right\n    3. Down -> Right -> Right\n    4. Right -> Right -> Right\n    5. Down -> Down -> Right\n    6. Down -> Right -> Down\n    \"\"\"\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][0] = 1\n        dp[0][i] = 1\n    \n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[n-1][n-1]\n\ndef g(n: int = 3) -> int:\n    \"\"\"\n    Generate the input for the function f.\n    \"\"\"\n    return n\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 359, "target_skills": [1, 0, 1, 0, 0, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of ways to reach the bottom-right corner of a grid\n    starting from the top-left corner. You can only move down or right.\n\n    Example:\n    n = 3\n\n    Output:\n    6\n\n    Explanation:\n    There are 6 possible paths to reach the bottom-right corner:\n    1. Right -> Right -> Down\n    2. Right -> Down -> Right\n    3. Down -> Right -> Right\n    4. Right -> Right -> Right\n    5. Down -> Down -> Right\n    6. Down -> Right -> Down\n    \"\"\"\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][0] = 1\n        dp[0][i] = 1\n    \n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[n-1][n-1]", "solution_func": "def g(n: int = 3) -> int:\n    \"\"\"\n    Generate the input for the function f.\n    \"\"\"\n    return n", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the second smallest element in the list.\n\n    Sample input:\n    nums = [5, 2, 7, 9, 1, 3]\n\n    Sample output:\n    2\n    Explanation: The second smallest element in the list is 2.\n    \"\"\"\n    nums.sort()\n    return nums[1]\n\ndef g():\n    return [5, 2, 7, 9, 1, 3]\n\nassert f(g()) == 2\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 359, "target_skills": [1, 0, 0, 0, 0, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the second smallest element in the list.\n\n    Sample input:\n    nums = [5, 2, 7, 9, 1, 3]\n\n    Sample output:\n    2\n    Explanation: The second smallest element in the list is 2.\n    \"\"\"\n    nums.sort()\n    return nums[1]", "solution_func": "def g():\n    return [5, 2, 7, 9, 1, 3]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Find if there exists a sequence of length n such that the bitwise OR of any two elements is divisible by k.\"\"\"\n    if k == 1:\n        return True\n    if n < 2:\n        return False\n\n    def helper(seq, pos):\n        if pos == n:\n            return True\n        for i in range(1, k):\n            flag = True\n            for j in range(pos):\n                if (seq[j] | i) % k == 0:\n                    flag = False\n                    break\n            if flag:\n                seq[pos] = i\n                if helper(seq, pos+1):\n                    return True\n        return False\n\n    sequence = [0] * n\n    return helper(sequence, 0)\n\ndef g(n: int, k: int) -> int:\n    \"\"\"Generate a sequence of length n such that the bitwise OR of any two elements is divisible by k.\"\"\"\n    if k == 1:\n        return [0] * n\n    if n < 2:\n        return []\n\n    sequence = [0] * n\n    for i in range(1, k):\n        sequence[0] = i\n        if helper(sequence, 1):\n            return sequence\n    return []\n\nassert f(g(5, 3), 3)\n", "emb": null, "idx_generation": 360, "target_skills": [0, 1, 1, 1, 1, 0, 1, 1, 1, 0], "problem_func": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Find if there exists a sequence of length n such that the bitwise OR of any two elements is divisible by k.\"\"\"\n    if k == 1:\n        return True\n    if n < 2:\n        return False\n\n    def helper(seq, pos):\n        if pos == n:\n            return True\n        for i in range(1, k):\n            flag = True\n            for j in range(pos):\n                if (seq[j] | i) % k == 0:\n                    flag = False\n                    break\n            if flag:\n                seq[pos] = i\n                if helper(seq, pos+1):\n                    return True\n        return False\n\n    sequence = [0] * n\n    return helper(sequence, 0)", "solution_func": "def g(n: int, k: int) -> int:\n    \"\"\"Generate a sequence of length n such that the bitwise OR of any two elements is divisible by k.\"\"\"\n    if k == 1:\n        return [0] * n\n    if n < 2:\n        return []\n\n    sequence = [0] * n\n    for i in range(1, k):\n        sequence[0] = i\n        if helper(sequence, 1):\n            return sequence\n    return []", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"Check if a given graph with n nodes and edges is a valid tree.\"\"\"\n    if len(edges) != n-1:\n        return False\n    if n == 1:\n        return True\n\n    def dfs(node, visited):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited)\n\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = [False] * n\n    dfs(0, visited)\n    return all(visited)\n\ndef g(n: int, edges: List[List[int]]) -> List[List[int]]:\n    \"\"\"Generate a valid tree with n nodes and edges.\"\"\"\n    tree = []\n    for i in range(1, n):\n        tree.append([i-1, i])\n    return tree\n\nassert f(g(5, [[0, 1], [1, 2], [2, 3], [3, 4]]), 5)\n", "emb": null, "idx_generation": 360, "target_skills": [1, 1, 1, 0, 1, 0, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"Check if a given graph with n nodes and edges is a valid tree.\"\"\"\n    if len(edges) != n-1:\n        return False\n    if n == 1:\n        return True\n\n    def dfs(node, visited):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited)\n\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = [False] * n\n    dfs(0, visited)\n    return all(visited)", "solution_func": "def g(n: int, edges: List[List[int]]) -> List[List[int]]:\n    \"\"\"Generate a valid tree with n nodes and edges.\"\"\"\n    tree = []\n    for i in range(1, n):\n        tree.append([i-1, i])\n    return tree", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a given number is a perfect square.\"\"\"\n    if n < 0:\n        return False\n    if n == 0 or n == 1:\n        return True\n\n    left, right = 1, n\n    while left <= right:\n        mid = left + (right - left) // 2\n        if mid * mid == n:\n            return True\n        elif mid * mid < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef g(n: int) -> int:\n    \"\"\"Generate a perfect square number.\"\"\"\n    return n * n\n\nassert f(g(9))\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 360, "target_skills": [0, 1, 0, 0, 1, 0, 1, 1, 1, 1], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a given number is a perfect square.\"\"\"\n    if n < 0:\n        return False\n    if n == 0 or n == 1:\n        return True\n\n    left, right = 1, n\n    while left <= right:\n        mid = left + (right - left) // 2\n        if mid * mid == n:\n            return True\n        elif mid * mid < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False", "solution_func": "def g(n: int) -> int:\n    \"\"\"Generate a perfect square number.\"\"\"\n    return n * n", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of all the previous elements in the original list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    [1, 3, 6, 10, 15]\n    \"\"\"\n    result = []\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        result.append(current_sum)\n    return result\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [1, 3, 6, 10, 15]\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 360, "target_skills": [0, 1, 0, 1, 1, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of all the previous elements in the original list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    [1, 3, 6, 10, 15]\n    \"\"\"\n    result = []\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        result.append(current_sum)\n    return result", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3, 4, 5]", "map_ix": [1, 1, 0, 1, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the sum of the digits of its binary representation.\n\n    Example:\n    n = 10\n\n    Output:\n    2 (since the binary representation of 10 is 1010 and the sum of its digits is 2)\n    \"\"\"\n    binary = bin(n)[2:]\n    return sum(int(digit) for digit in binary)\n\ndef g() -> int:\n    return 10\n\nassert f(g()) == 2\n", "emb": [1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 360, "target_skills": [0, 0, 0, 0, 0, 1, 1, 0, 1, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the sum of the digits of its binary representation.\n\n    Example:\n    n = 10\n\n    Output:\n    2 (since the binary representation of 10 is 1010 and the sum of its digits is 2)\n    \"\"\"\n    binary = bin(n)[2:]\n    return sum(int(digit) for digit in binary)", "solution_func": "def g() -> int:\n    return 10", "map_ix": [1, 1, 0, 0, 1, 1, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representation of a directed acyclic graph, return the number of paths from the source node to the destination node.\n\n    Example:\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n\n    Output:\n    3 (since there are 3 paths from node 0 to node 3)\n\n    Note: The graph is represented as a 2D list, where graph[i][j] = 1 if there is an edge from node i to node j, and graph[i][j] = 0 otherwise.\n    \"\"\"\n    n = len(graph)\n    dp = [0] * n\n    dp[0] = 1\n    for i in range(1, n):\n        for j in range(i):\n            if graph[j][i] == 1:\n                dp[i] += dp[j]\n    return dp[-1]\n\ndef g() -> List[List[int]]:\n    return [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n\nassert f(g()) == 3\n", "emb": null, "idx_generation": 360, "target_skills": [1, 0, 1, 1, 0, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representation of a directed acyclic graph, return the number of paths from the source node to the destination node.\n\n    Example:\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n\n    Output:\n    3 (since there are 3 paths from node 0 to node 3)\n\n    Note: The graph is represented as a 2D list, where graph[i][j] = 1 if there is an edge from node i to node j, and graph[i][j] = 0 otherwise.\n    \"\"\"\n    n = len(graph)\n    dp = [0] * n\n    dp[0] = 1\n    for i in range(1, n):\n        for j in range(i):\n            if graph[j][i] == 1:\n                dp[i] += dp[j]\n    return dp[-1]", "solution_func": "def g() -> List[List[int]]:\n    return [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique pairs (a, b) such that a XOR b is equal to a given target.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n    target = 3\n\n    Sample Output:\n    2\n    \"\"\"\n    count = 0\n    seen = set()\n\n    for num in nums:\n        complement = num ^ target\n        \n        if complement in seen:\n            count += 1\n\n        seen.add(num)\n\n    return count\n\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 3\n    return nums, target\n\n\nassert f(*g()) == 2\n", "emb": null, "idx_generation": 360, "target_skills": [1, 1, 0, 1, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique pairs (a, b) such that a XOR b is equal to a given target.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n    target = 3\n\n    Sample Output:\n    2\n    \"\"\"\n    count = 0\n    seen = set()\n\n    for num in nums:\n        complement = num ^ target\n        \n        if complement in seen:\n            count += 1\n\n        seen.add(num)\n\n    return count", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    target = 3\n    return nums, target", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the minimum number of steps required to reach from the top-left corner to the bottom-right corner,\n    moving only down or right.\n\n    Sample Input:\n    grid = [\n        [0, 1, 1, 0],\n        [1, 0, 1, 1],\n        [0, 0, 0, 1],\n        [1, 1, 0, 0]\n    ]\n\n    Sample Output:\n    5\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[float('inf')] * (n + 1) for _ in range(m + 1)]\n    dp[m][n - 1] = dp[m - 1][n] = 0\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            dp[i][j] = min(dp[i + 1][j], dp[i][j + 1]) + grid[i][j]\n\n    return dp[0][0]\n\n\ndef g():\n    grid = [\n        [0, 1, 1, 0],\n        [1, 0, 1, 1],\n        [0, 0, 0, 1],\n        [1, 1, 0, 0]\n    ]\n    return grid\n\n\nassert f(*g()) == 5\n", "emb": null, "idx_generation": 360, "target_skills": [1, 0, 0, 0, 0, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the minimum number of steps required to reach from the top-left corner to the bottom-right corner,\n    moving only down or right.\n\n    Sample Input:\n    grid = [\n        [0, 1, 1, 0],\n        [1, 0, 1, 1],\n        [0, 0, 0, 1],\n        [1, 1, 0, 0]\n    ]\n\n    Sample Output:\n    5\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[float('inf')] * (n + 1) for _ in range(m + 1)]\n    dp[m][n - 1] = dp[m - 1][n] = 0\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            dp[i][j] = min(dp[i + 1][j], dp[i][j + 1]) + grid[i][j]\n\n    return dp[0][0]", "solution_func": "def g():\n    grid = [\n        [0, 1, 1, 0],\n        [1, 0, 1, 1],\n        [0, 0, 0, 1],\n        [1, 1, 0, 0]\n    ]\n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(prices: List[int]) -> int:\n    \"\"\"\n    Given an array of prices representing the stock prices of a company in consecutive days,\n    find the maximum profit that can be obtained by buying and selling the stock at most k times.\n\n    Sample Input:\n    prices = [3, 2, 6, 5, 0, 3]\n    k = 2\n\n    Sample Output:\n    7\n    \"\"\"\n    if len(prices) < 2:\n        return 0\n\n    k = 2\n    dp = [[0] * len(prices) for _ in range(k + 1)]\n\n    for i in range(1, k + 1):\n        max_diff = -prices[0]\n        for j in range(1, len(prices)):\n            dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)\n            max_diff = max(max_diff, dp[i - 1][j] - prices[j])\n\n    return dp[k][len(prices) - 1]\n\n\ndef g():\n    prices = [3, 2, 6, 5, 0, 3]\n    return prices\n\n\nassert f(*g()) == 7\n", "emb": null, "idx_generation": 360, "target_skills": [0, 1, 0, 1, 1, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(prices: List[int]) -> int:\n    \"\"\"\n    Given an array of prices representing the stock prices of a company in consecutive days,\n    find the maximum profit that can be obtained by buying and selling the stock at most k times.\n\n    Sample Input:\n    prices = [3, 2, 6, 5, 0, 3]\n    k = 2\n\n    Sample Output:\n    7\n    \"\"\"\n    if len(prices) < 2:\n        return 0\n\n    k = 2\n    dp = [[0] * len(prices) for _ in range(k + 1)]\n\n    for i in range(1, k + 1):\n        max_diff = -prices[0]\n        for j in range(1, len(prices)):\n            dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)\n            max_diff = max(max_diff, dp[i - 1][j] - prices[j])\n\n    return dp[k][len(prices) - 1]", "solution_func": "def g():\n    prices = [3, 2, 6, 5, 0, 3]\n    return prices", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if n is a perfect square\"\"\"\n    return int(n**0.5)**2 == n\ndef g():\n    return 25\nassert f(g())\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 360, "target_skills": [0, 1, 0, 0, 1, 1, 0, 0, 1, 1], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if n is a perfect square\"\"\"\n    return int(n**0.5)**2 == n", "solution_func": "def g():\n    return 25", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target integer, find the number of combinations of elements in nums that add up to the target.\n\n    Example:\n    Input: nums = [1, 2, 3], target = 4\n    Output: 4\n\n    Explanation: The possible combinations are [1, 1, 1, 1], [1, 1, 2], [1, 3], [2, 2].\n    \"\"\"\n    def backtrack(curr_sum, index):\n        if curr_sum == target:\n            return 1\n        if curr_sum > target or index >= len(nums):\n            return 0\n\n        count = 0\n        count += backtrack(curr_sum + nums[index], index)\n        count += backtrack(curr_sum, index + 1)\n\n        return count\n\n    return backtrack(0, 0)\n\ndef g(nums=[1, 2, 3], target=4):\n    return nums, target\n\nassert f(*g()) == 4\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 361, "target_skills": [0, 1, 0, 0, 0, 0, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target integer, find the number of combinations of elements in nums that add up to the target.\n\n    Example:\n    Input: nums = [1, 2, 3], target = 4\n    Output: 4\n\n    Explanation: The possible combinations are [1, 1, 1, 1], [1, 1, 2], [1, 3], [2, 2].\n    \"\"\"\n    def backtrack(curr_sum, index):\n        if curr_sum == target:\n            return 1\n        if curr_sum > target or index >= len(nums):\n            return 0\n\n        count = 0\n        count += backtrack(curr_sum + nums[index], index)\n        count += backtrack(curr_sum, index + 1)\n\n        return count\n\n    return backtrack(0, 0)", "solution_func": "def g(nums=[1, 2, 3], target=4):\n    return nums, target", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence.\n\n    Example:\n    Input: nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n    \"\"\"\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g(nums=[10, 9, 2, 5, 3, 7, 101, 18]):\n    return nums\n\nassert f(*g()) == 4\n\n", "emb": null, "idx_generation": 361, "target_skills": [1, 1, 0, 0, 1, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence.\n\n    Example:\n    Input: nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n    \"\"\"\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)", "solution_func": "def g(nums=[10, 9, 2, 5, 3, 7, 101, 18]):\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a subarray with the constraint that no two numbers in the subarray are adjacent.\n\n    Example:\n    Input: nums = [2, 1, 5, 6, 3]\n    Output: 10\n\n    Explanation: The maximum sum subarray without adjacent numbers is [2, 5, 3], therefore the sum is 10.\n    \"\"\"\n    if not nums:\n        return 0\n\n    prev_prev_sum = 0\n    prev_sum = nums[0]\n\n    for i in range(1, len(nums)):\n        curr_sum = max(prev_sum, prev_prev_sum + nums[i])\n        prev_prev_sum = prev_sum\n        prev_sum = curr_sum\n\n    return prev_sum\n\ndef g(nums=[2, 1, 5, 6, 3]):\n    return nums\n\nassert f(*g()) == 10\n\n", "emb": null, "idx_generation": 361, "target_skills": [1, 0, 0, 1, 1, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a subarray with the constraint that no two numbers in the subarray are adjacent.\n\n    Example:\n    Input: nums = [2, 1, 5, 6, 3]\n    Output: 10\n\n    Explanation: The maximum sum subarray without adjacent numbers is [2, 5, 3], therefore the sum is 10.\n    \"\"\"\n    if not nums:\n        return 0\n\n    prev_prev_sum = 0\n    prev_sum = nums[0]\n\n    for i in range(1, len(nums)):\n        curr_sum = max(prev_sum, prev_prev_sum + nums[i])\n        prev_prev_sum = prev_sum\n        prev_sum = curr_sum\n\n    return prev_sum", "solution_func": "def g(nums=[2, 1, 5, 6, 3]):\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nimport itertools\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product that can be obtained from a subset of the integers.\n    Return the maximum product.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    24\n\n    Explanation:\n    The maximum product can be obtained by multiplying 3 and 4, which gives a product of 12.\n    \"\"\"\n\n    def find_max_product(nums):\n        n = len(nums)\n        max_product = float('-inf')\n        for r in range(1, n+1):\n            subsets = itertools.combinations(nums, r)\n            for subset in subsets:\n                product = 1\n                for num in subset:\n                    product *= num\n                max_product = max(max_product, product)\n        return max_product\n\n    return find_max_product(nums)\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == 24\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 361, "target_skills": [1, 1, 0, 0, 1, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nimport itertools\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product that can be obtained from a subset of the integers.\n    Return the maximum product.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    24\n\n    Explanation:\n    The maximum product can be obtained by multiplying 3 and 4, which gives a product of 12.\n    \"\"\"\n\n    def find_max_product(nums):\n        n = len(nums)\n        max_product = float('-inf')\n        for r in range(1, n+1):\n            subsets = itertools.combinations(nums, r)\n            for subset in subsets:\n                product = 1\n                for num in subset:\n                    product *= num\n                max_product = max(max_product, product)\n        return max_product\n\n    return find_max_product(nums)", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4]\n    return nums", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome after removing at most one character.\n    Return True if the string is a palindrome after removal, False otherwise.\n\n    Example:\n    s = \"abca\"\n\n    Output:\n    True\n\n    Explanation:\n    Removing 'b' results in the string \"aca\", which is a palindrome.\n    \"\"\"\n\n    def is_palindrome(s, left, right):\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n\n    n = len(s)\n    left = 0\n    right = n - 1\n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s, left + 1, right) or is_palindrome(s, left, right - 1)\n        left += 1\n        right -= 1\n    return True\n\ndef g() -> str:\n    s = \"abca\"\n    return s\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 361, "target_skills": [0, 0, 0, 1, 0, 1, 1, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome after removing at most one character.\n    Return True if the string is a palindrome after removal, False otherwise.\n\n    Example:\n    s = \"abca\"\n\n    Output:\n    True\n\n    Explanation:\n    Removing 'b' results in the string \"aca\", which is a palindrome.\n    \"\"\"\n\n    def is_palindrome(s, left, right):\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n\n    n = len(s)\n    left = 0\n    right = n - 1\n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s, left + 1, right) or is_palindrome(s, left, right - 1)\n        left += 1\n        right -= 1\n    return True", "solution_func": "def g() -> str:\n    s = \"abca\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of all the elements except the\n    corresponding element in the original list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    [9, 8, 7, 6]\n\n    Explanation:\n    The sum of all the elements except 1 is 2 + 3 + 4 = 9.\n    The sum of all the elements except 2 is 1 + 3 + 4 = 8.\n    The sum of all the elements except 3 is 1 + 2 + 4 = 7.\n    The sum of all the elements except 4 is 1 + 2 + 3 = 6.\n    \"\"\"\n\n    total_sum = sum(nums)\n    n = len(nums)\n    new_nums = []\n    for num in nums:\n        new_nums.append(total_sum - num)\n    return new_nums\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == [9, 8, 7, 6]\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 361, "target_skills": [0, 1, 0, 1, 0, 1, 1, 1, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of all the elements except the\n    corresponding element in the original list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    [9, 8, 7, 6]\n\n    Explanation:\n    The sum of all the elements except 1 is 2 + 3 + 4 = 9.\n    The sum of all the elements except 2 is 1 + 3 + 4 = 8.\n    The sum of all the elements except 3 is 1 + 2 + 4 = 7.\n    The sum of all the elements except 4 is 1 + 2 + 3 = 6.\n    \"\"\"\n\n    total_sum = sum(nums)\n    n = len(nums)\n    new_nums = []\n    for num in nums:\n        new_nums.append(total_sum - num)\n    return new_nums", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4]\n    return nums", "map_ix": [1, 1, 0, 1, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray that contains only positive numbers.\n    Return 0 if there is no such subarray.\n\n    Example:\n    nums = [1, -2, 3, 4, -5, 2]\n\n    Output:\n    7\n\n    Explanation:\n    The subarray with the maximum sum that contains only positive numbers is [3, 4].\n\n    Hint: Use a sliding window approach to iterate through the list of numbers and keep track of the maximum sum.\n    \"\"\"\n    max_sum = 0\n    curr_sum = 0\n\n    for num in nums:\n        if num > 0:\n            curr_sum += num\n        else:\n            curr_sum = 0\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g(nums: List[int] = [1, -2, 3, 4, -5, 2]):\n    return nums\n\nassert f(g()) == 7\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 361, "target_skills": [1, 1, 0, 1, 0, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray that contains only positive numbers.\n    Return 0 if there is no such subarray.\n\n    Example:\n    nums = [1, -2, 3, 4, -5, 2]\n\n    Output:\n    7\n\n    Explanation:\n    The subarray with the maximum sum that contains only positive numbers is [3, 4].\n\n    Hint: Use a sliding window approach to iterate through the list of numbers and keep track of the maximum sum.\n    \"\"\"\n    max_sum = 0\n    curr_sum = 0\n\n    for num in nums:\n        if num > 0:\n            curr_sum += num\n        else:\n            curr_sum = 0\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum", "solution_func": "def g(nums: List[int] = [1, -2, 3, 4, -5, 2]):\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find two numbers that add up to a target value.\n    Return the indices of the two numbers in the original list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1 (2 and 7) add up to the target value of 9.\n\n    Hint: Use a two-pointer approach to iterate through the list and find the two numbers that add up to the target value.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g(nums: List[int] = [2, 7, 11, 15], target: int = 9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 361, "target_skills": [0, 0, 1, 1, 0, 0, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find two numbers that add up to a target value.\n    Return the indices of the two numbers in the original list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1 (2 and 7) add up to the target value of 9.\n\n    Hint: Use a two-pointer approach to iterate through the list and find the two numbers that add up to the target value.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g(nums: List[int] = [2, 7, 11, 15], target: int = 9):\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], pattern: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a pattern string, find all words that match the pattern.\n    A pattern consists of lowercase letters and wildcard characters ('?'), where each wildcard character can match any letter.\n    Return a list of words that match the pattern.\n\n    Example:\n    words = [\"cat\", \"bat\", \"rat\", \"hat\", \"pat\"]\n    pattern = \"c?t\"\n\n    Output:\n    [\"cat\", \"bat\"]\n\n    Explanation:\n    The pattern \"c?t\" matches the words \"cat\" and \"bat\".\n\n    Hint: Use string manipulation and pattern matching techniques to find the matching words.\n    \"\"\"\n    matching_words = []\n\n    for word in words:\n        if len(word) != len(pattern):\n            continue\n        \n        is_match = True\n        for i in range(len(word)):\n            if pattern[i] != '?' and pattern[i] != word[i]:\n                is_match = False\n                break\n        \n        if is_match:\n            matching_words.append(word)\n\n    return matching_words\n\ndef g(words: List[str] = [\"cat\", \"bat\", \"rat\", \"hat\", \"pat\"], pattern: str = \"c?t\"):\n    return words, pattern\n\nassert f(*g()) == [\"cat\", \"bat\"]\n\n", "emb": null, "idx_generation": 361, "target_skills": [1, 1, 1, 0, 1, 1, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], pattern: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a pattern string, find all words that match the pattern.\n    A pattern consists of lowercase letters and wildcard characters ('?'), where each wildcard character can match any letter.\n    Return a list of words that match the pattern.\n\n    Example:\n    words = [\"cat\", \"bat\", \"rat\", \"hat\", \"pat\"]\n    pattern = \"c?t\"\n\n    Output:\n    [\"cat\", \"bat\"]\n\n    Explanation:\n    The pattern \"c?t\" matches the words \"cat\" and \"bat\".\n\n    Hint: Use string manipulation and pattern matching techniques to find the matching words.\n    \"\"\"\n    matching_words = []\n\n    for word in words:\n        if len(word) != len(pattern):\n            continue\n        \n        is_match = True\n        for i in range(len(word)):\n            if pattern[i] != '?' and pattern[i] != word[i]:\n                is_match = False\n                break\n        \n        if is_match:\n            matching_words.append(word)\n\n    return matching_words", "solution_func": "def g(words: List[str] = [\"cat\", \"bat\", \"rat\", \"hat\", \"pat\"], pattern: str = \"c?t\"):\n    return words, pattern", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if the list is sorted in non-decreasing order.\n    \"\"\"\n    return arr == sorted(arr)\n\ndef g() -> List[int]:\n    arr = [1, 2, 3, 4, 5]\n    return arr\n\nassert f(g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 361, "target_skills": [0, 0, 0, 1, 0, 0, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if the list is sorted in non-decreasing order.\n    \"\"\"\n    return arr == sorted(arr)", "solution_func": "def g() -> List[int]:\n    arr = [1, 2, 3, 4, 5]\n    return arr", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Determine if there is a path from start to end in a directed graph.\n\n    The graph is represented as an adjacency matrix, where graph[i][j] = 1 indicates\n    a directed edge from node i to node j.\n\n    Returns True if there is a path from start to end, False otherwise.\n    \"\"\"\n    visited = [False] * len(graph)\n    return dfs(graph, start, end, visited)\n\ndef dfs(graph: List[List[int]], node: int, end: int, visited: List[bool]) -> bool:\n    # Base case: If the current node is the end node, return True\n    if node == end:\n        return True\n    \n    # Mark the current node as visited\n    visited[node] = True\n    \n    # Recursive case: Check if there is a path from the current node to the end node\n    for neighbor in range(len(graph)):\n        if graph[node][neighbor] == 1 and not visited[neighbor]:\n            if dfs(graph, neighbor, end, visited):\n                return True\n    \n    # If no path is found, return False\n    return False\n\ndef g():\n    graph = [\n        [0, 1, 0, 0, 1],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    start = 0\n    end = 4\n\n    return graph, start, end\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 362, "target_skills": [0, 0, 1, 0, 0, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Determine if there is a path from start to end in a directed graph.\n\n    The graph is represented as an adjacency matrix, where graph[i][j] = 1 indicates\n    a directed edge from node i to node j.\n\n    Returns True if there is a path from start to end, False otherwise.\n    \"\"\"\n    visited = [False] * len(graph)\n    return dfs(graph, start, end, visited)\n\ndef dfs(graph: List[List[int]], node: int, end: int, visited: List[bool]) -> bool:\n    # Base case: If the current node is the end node, return True\n    if node == end:\n        return True\n    \n    # Mark the current node as visited\n    visited[node] = True\n    \n    # Recursive case: Check if there is a path from the current node to the end node\n    for neighbor in range(len(graph)):\n        if graph[node][neighbor] == 1 and not visited[neighbor]:\n            if dfs(graph, neighbor, end, visited):\n                return True\n    \n    # If no path is found, return False\n    return False", "solution_func": "def g():\n    graph = [\n        [0, 1, 0, 0, 1],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    start = 0\n    end = 4\n\n    return graph, start, end", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a directed acyclic graph represented as an adjacency matrix,\n    return a topological ordering of the nodes.\n\n    The topological ordering is a linear ordering of the nodes such that\n    for every directed edge (u, v), node u comes before node v in the ordering.\n    \"\"\"\n    visited = [False] * len(graph)\n    ordering = []\n    \n    # Perform depth-first search on each unvisited node\n    for node in range(len(graph)):\n        if not visited[node]:\n            dfs(graph, node, visited, ordering)\n    \n    # Reverse the ordering to get the topological ordering\n    ordering.reverse()\n    return ordering\n\ndef dfs(graph: List[List[int]], node: int, visited: List[bool], ordering: List[int]):\n    # Mark the current node as visited\n    visited[node] = True\n    \n    # Recursive case: Visit all neighbors of the current node\n    for neighbor in range(len(graph)):\n        if graph[node][neighbor] == 1 and not visited[neighbor]:\n            dfs(graph, neighbor, visited, ordering)\n    \n    # Add the current node to the ordering\n    ordering.append(node)\n\ndef g():\n    graph = [\n        [0, 1, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 1, 1],\n        [0, 0, 0, 0, 1],\n        [0, 0, 0, 0, 0]\n    ]\n\n    return graph\n\nassert f(g()) == [4, 3, 2, 1, 0]\n\n", "emb": null, "idx_generation": 362, "target_skills": [0, 0, 1, 1, 1, 1, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a directed acyclic graph represented as an adjacency matrix,\n    return a topological ordering of the nodes.\n\n    The topological ordering is a linear ordering of the nodes such that\n    for every directed edge (u, v), node u comes before node v in the ordering.\n    \"\"\"\n    visited = [False] * len(graph)\n    ordering = []\n    \n    # Perform depth-first search on each unvisited node\n    for node in range(len(graph)):\n        if not visited[node]:\n            dfs(graph, node, visited, ordering)\n    \n    # Reverse the ordering to get the topological ordering\n    ordering.reverse()\n    return ordering\n\ndef dfs(graph: List[List[int]], node: int, visited: List[bool], ordering: List[int]):\n    # Mark the current node as visited\n    visited[node] = True\n    \n    # Recursive case: Visit all neighbors of the current node\n    for neighbor in range(len(graph)):\n        if graph[node][neighbor] == 1 and not visited[neighbor]:\n            dfs(graph, neighbor, visited, ordering)\n    \n    # Add the current node to the ordering\n    ordering.append(node)", "solution_func": "def g():\n    graph = [\n        [0, 1, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 1, 1],\n        [0, 0, 0, 0, 1],\n        [0, 0, 0, 0, 0]\n    ]\n\n    return graph", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(string: str) -> int:\n    \"\"\"\n    Given a string, return the length of the longest substring without repeating characters.\n\n    Example:\n    Input: \"abcabcbb\"\n    Output: 3 (the longest substring without repeating characters is \"abc\")\n\n    Input: \"bbbbb\"\n    Output: 1 (the longest substring without repeating characters is \"b\")\n    \"\"\"\n    if len(string) == 0:\n        return 0\n    \n    max_length = 0\n    start = 0\n    visited = {}\n    \n    for end in range(len(string)):\n        if string[end] in visited and visited[string[end]] >= start:\n            start = visited[string[end]] + 1\n        visited[string[end]] = end\n        max_length = max(max_length, end - start + 1)\n    \n    return max_length\n\ndef g(string: str = \"abcabcbb\"):\n    return string\n\nassert f(g()) == 3\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 362, "target_skills": [1, 0, 0, 1, 1, 1, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(string: str) -> int:\n    \"\"\"\n    Given a string, return the length of the longest substring without repeating characters.\n\n    Example:\n    Input: \"abcabcbb\"\n    Output: 3 (the longest substring without repeating characters is \"abc\")\n\n    Input: \"bbbbb\"\n    Output: 1 (the longest substring without repeating characters is \"b\")\n    \"\"\"\n    if len(string) == 0:\n        return 0\n    \n    max_length = 0\n    start = 0\n    visited = {}\n    \n    for end in range(len(string)):\n        if string[end] in visited and visited[string[end]] >= start:\n            start = visited[string[end]] + 1\n        visited[string[end]] = end\n        max_length = max(max_length, end - start + 1)\n    \n    return max_length", "solution_func": "def g(string: str = \"abcabcbb\"):\n    return string", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Determine if there is a path from the start node to the end node in a directed graph.\n    \"\"\"\n    visited = [False] * len(graph)\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if not visited[node]:\n            visited[node] = True\n            stack.extend(graph[node])\n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a directed graph with 5 nodes and random edges.\n    \"\"\"\n    return [[1, 2], [2, 3], [3, 4], [4, 0], [0, 1], [1, 3]]\n\nassert f(g(), 0, 4)\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 362, "target_skills": [0, 1, 1, 0, 1, 1, 1, 0, 0, 1], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Determine if there is a path from the start node to the end node in a directed graph.\n    \"\"\"\n    visited = [False] * len(graph)\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if not visited[node]:\n            visited[node] = True\n            stack.extend(graph[node])\n    return False", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a directed graph with 5 nodes and random edges.\n    \"\"\"\n    return [[1, 2], [2, 3], [3, 4], [4, 0], [0, 1], [1, 3]]", "map_ix": [0, 0, 1, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if they are isomorphic.\n\n    Two strings are isomorphic if the characters in s can be replaced to get t.\n\n    Example:\n    s = \"egg\", t = \"add\"\n\n    Output:\n    True\n\n    Explanation:\n    The characters 'e' and 'a' can be replaced with 'a' and 'd' respectively to get t.\n\n    \"\"\"\n    if len(s) != len(t):\n        return False\n\n    char_map = {}\n    used_chars = set()\n\n    for i in range(len(s)):\n        if s[i] in char_map:\n            if char_map[s[i]] != t[i]:\n                return False\n        else:\n            if t[i] in used_chars:\n                return False\n            char_map[s[i]] = t[i]\n            used_chars.add(t[i])\n\n    return True\n\ndef g() -> Tuple[str, str]:\n    \"\"\"\n    Generate two isomorphic strings.\n    \"\"\"\n    return (\"egg\", \"add\")\n\nassert f(*g())\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 362, "target_skills": [0, 0, 0, 0, 1, 0, 1, 0, 1, 1], "problem_func": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if they are isomorphic.\n\n    Two strings are isomorphic if the characters in s can be replaced to get t.\n\n    Example:\n    s = \"egg\", t = \"add\"\n\n    Output:\n    True\n\n    Explanation:\n    The characters 'e' and 'a' can be replaced with 'a' and 'd' respectively to get t.\n\n    \"\"\"\n    if len(s) != len(t):\n        return False\n\n    char_map = {}\n    used_chars = set()\n\n    for i in range(len(s)):\n        if s[i] in char_map:\n            if char_map[s[i]] != t[i]:\n                return False\n        else:\n            if t[i] in used_chars:\n                return False\n            char_map[s[i]] = t[i]\n            used_chars.add(t[i])\n\n    return True", "solution_func": "def g() -> Tuple[str, str]:\n    \"\"\"\n    Generate two isomorphic strings.\n    \"\"\"\n    return (\"egg\", \"add\")", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array nums, return the two numbers such that they add up to the target.\n\n    You may assume that each input would have exactly one solution and you may not use the same element twice.\n\n    Example:\n    nums = [2, 7, 11, 15], target = 9\n\n    Output:\n    [2, 7]\n\n    Explanation:\n    The sum of 2 and 7 is 9.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [nums[left], nums[right]]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted array and a target sum.\n    \"\"\"\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [2, 7]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 362, "target_skills": [0, 1, 0, 1, 1, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array nums, return the two numbers such that they add up to the target.\n\n    You may assume that each input would have exactly one solution and you may not use the same element twice.\n\n    Example:\n    nums = [2, 7, 11, 15], target = 9\n\n    Output:\n    [2, 7]\n\n    Explanation:\n    The sum of 2 and 7 is 9.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [nums[left], nums[right]]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted array and a target sum.\n    \"\"\"\n    return ([2, 7, 11, 15], 9)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists two numbers in the list whose sum is equal to the target.\"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(nums: List[int] = [5, 2, 7, 3, 1], target: int = 9) -> List[int]:\n    \"\"\"Generate a list of integers and a target number.\"\"\"\n    return nums, target\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 362, "target_skills": [0, 0, 1, 0, 0, 1, 1, 1, 0, 1], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists two numbers in the list whose sum is equal to the target.\"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False", "solution_func": "def g(nums: List[int] = [5, 2, 7, 3, 1], target: int = 9) -> List[int]:\n    \"\"\"Generate a list of integers and a target number.\"\"\"\n    return nums, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(string: str) -> str:\n    \"\"\"Reverse the order of words in a given string.\"\"\"\n    words = string.split()\n    reversed_words = words[::-1]\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string\n\ndef g(string: str = \"Hello, world!\") -> str:\n    \"\"\"Generate a string.\"\"\"\n    return string\n\nassert f(g()) == \"!world, Hello\"\n\n", "emb": null, "idx_generation": 362, "target_skills": [1, 1, 0, 1, 0, 1, 1, 0, 1, 1], "problem_func": "from typing import*\ndef f(string: str) -> str:\n    \"\"\"Reverse the order of words in a given string.\"\"\"\n    words = string.split()\n    reversed_words = words[::-1]\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "solution_func": "def g(string: str = \"Hello, world!\") -> str:\n    \"\"\"Generate a string.\"\"\"\n    return string", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum product of any two numbers in the list.\"\"\"\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n    \n    return max_product\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5]) -> List[int]:\n    \"\"\"Generate a list of integers.\"\"\"\n    return nums\n\nassert f(g()) == 20\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 362, "target_skills": [0, 1, 1, 0, 0, 0, 0, 1, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum product of any two numbers in the list.\"\"\"\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n    \n    return max_product", "solution_func": "def g(nums: List[int] = [1, 2, 3, 4, 5]) -> List[int]:\n    \"\"\"Generate a list of integers.\"\"\"\n    return nums", "map_ix": [1, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number,\n    check if there exists a pair of integers in the list\n    whose sum is equal to the target number.\n    Return True if such a pair exists, False otherwise.\n    \"\"\"\n    complements = set()\n    for num in nums:\n        complement = target - num\n        if complement in complements:\n            return True\n        complements.add(num)\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5, 6], target=9):\n    return nums, target\n\nassert f(*g()) == True\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 362, "target_skills": [1, 1, 0, 0, 0, 0, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number,\n    check if there exists a pair of integers in the list\n    whose sum is equal to the target number.\n    Return True if such a pair exists, False otherwise.\n    \"\"\"\n    complements = set()\n    for num in nums:\n        complement = target - num\n        if complement in complements:\n            return True\n        complements.add(num)\n    return False", "solution_func": "def g(nums=[1, 2, 3, 4, 5, 6], target=9):\n    return nums, target", "map_ix": [1, 1, 0, 0, 0, 1, 0, 0, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 5],\n        [2, 1, 4],\n        [3, 2, 1]\n    ]\n\n    Output:\n    12\n\n    Explanation:\n    The maximum sum path is 1 -> 3 -> 5 -> 4 -> 1 -> 2 -> 1, which gives a total sum of 12.\n\n    Hint: Use dynamic programming to store and update the maximum sum at each position in the grid.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Initialize a 2D dp grid to store the maximum sum at each position\n    dp = [[0] * cols for _ in range(rows)]\n\n    # Base case: the maximum sum at the top-left corner is the value at that position\n    dp[0][0] = grid[0][0]\n\n    # Fill in the dp grid\n    for i in range(rows):\n        for j in range(cols):\n            # Update the maximum sum at each position based on the maximum of the previous positions\n            if i > 0 and j > 0:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n            elif i > 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            elif j > 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n\n    # The maximum sum at the bottom-right corner is the solution\n    return dp[rows-1][cols-1]\n\ndef g():\n    return ([[1, 3, 5], [2, 1, 4], [3, 2, 1]])\n\nassert f(*g()) == 12\n", "emb": null, "idx_generation": 363, "target_skills": [0, 0, 1, 0, 0, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 5],\n        [2, 1, 4],\n        [3, 2, 1]\n    ]\n\n    Output:\n    12\n\n    Explanation:\n    The maximum sum path is 1 -> 3 -> 5 -> 4 -> 1 -> 2 -> 1, which gives a total sum of 12.\n\n    Hint: Use dynamic programming to store and update the maximum sum at each position in the grid.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Initialize a 2D dp grid to store the maximum sum at each position\n    dp = [[0] * cols for _ in range(rows)]\n\n    # Base case: the maximum sum at the top-left corner is the value at that position\n    dp[0][0] = grid[0][0]\n\n    # Fill in the dp grid\n    for i in range(rows):\n        for j in range(cols):\n            # Update the maximum sum at each position based on the maximum of the previous positions\n            if i > 0 and j > 0:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n            elif i > 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            elif j > 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n\n    # The maximum sum at the bottom-right corner is the solution\n    return dp[rows-1][cols-1]", "solution_func": "def g():\n    return ([[1, 3, 5], [2, 1, 4], [3, 2, 1]])", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(adj_list: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an adjacency list representation of an undirected graph, find the shortest path from the start node to the end node.\n\n    Example:\n    adj_list = [\n        [1, 2],\n        [0, 2, 3],\n        [0, 1, 3],\n        [1, 2]\n    ]\n    start = 0\n    end = 3\n\n    Output:\n    [0, 1, 3]\n\n    Explanation:\n    The shortest path from node 0 to node 3 is 0->1->3.\n\n    Hint: Use breadth-first search (BFS) to find the shortest path in an undirected graph.\n    \"\"\"\n\n    queue = [(start, [start])]  # Queue to store the current node and the path to that node\n\n    while queue:\n        node, path = queue.pop(0)\n\n        if node == end:\n            return path\n\n        for neighbor in adj_list[node]:\n            if neighbor not in path:\n                queue.append((neighbor, path + [neighbor]))\n\n    return []\n\ndef g():\n    return ([[1, 2], [0, 2, 3], [0, 1, 3], [1, 2]], 0, 3)\n\nassert f(*g()) == [0, 1, 3]\n", "emb": null, "idx_generation": 363, "target_skills": [1, 0, 1, 0, 1, 0, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(adj_list: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an adjacency list representation of an undirected graph, find the shortest path from the start node to the end node.\n\n    Example:\n    adj_list = [\n        [1, 2],\n        [0, 2, 3],\n        [0, 1, 3],\n        [1, 2]\n    ]\n    start = 0\n    end = 3\n\n    Output:\n    [0, 1, 3]\n\n    Explanation:\n    The shortest path from node 0 to node 3 is 0->1->3.\n\n    Hint: Use breadth-first search (BFS) to find the shortest path in an undirected graph.\n    \"\"\"\n\n    queue = [(start, [start])]  # Queue to store the current node and the path to that node\n\n    while queue:\n        node, path = queue.pop(0)\n\n        if node == end:\n            return path\n\n        for neighbor in adj_list[node]:\n            if neighbor not in path:\n                queue.append((neighbor, path + [neighbor]))\n\n    return []", "solution_func": "def g():\n    return ([[1, 2], [0, 2, 3], [0, 1, 3], [1, 2]], 0, 3)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> List[int]:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, find the longest path from the start node to the end node.\n\n    Example:\n    graph = [\n        [0, 1, 2, 0],\n        [0, 0, 0, 3],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n\n    Output:\n    [0, 2, 3]\n\n    Explanation:\n    The longest path from node 0 to node 3 is 0->2->3.\n\n    Hint: Use depth-first search (DFS) to find the longest path in a directed graph.\n    \"\"\"\n\n    def dfs(node, path):\n        nonlocal longest_path\n\n        if node == end:\n            if len(path) > len(longest_path):\n                longest_path = path\n            return\n\n        for i, weight in enumerate(graph[node]):\n            if weight > 0 and i not in path:\n                dfs(i, path + [i])\n\n    longest_path = []\n    dfs(start, [start])\n\n    return longest_path\n\ndef g():\n    return ([[0, 1, 2, 0], [0, 0, 0, 3], [0, 0, 0, 1], [0, 0, 0, 0]], 0, 3)\n\nassert f(*g()) == [0, 2, 3]\n", "emb": null, "idx_generation": 363, "target_skills": [0, 1, 0, 0, 1, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> List[int]:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, find the longest path from the start node to the end node.\n\n    Example:\n    graph = [\n        [0, 1, 2, 0],\n        [0, 0, 0, 3],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n\n    Output:\n    [0, 2, 3]\n\n    Explanation:\n    The longest path from node 0 to node 3 is 0->2->3.\n\n    Hint: Use depth-first search (DFS) to find the longest path in a directed graph.\n    \"\"\"\n\n    def dfs(node, path):\n        nonlocal longest_path\n\n        if node == end:\n            if len(path) > len(longest_path):\n                longest_path = path\n            return\n\n        for i, weight in enumerate(graph[node]):\n            if weight > 0 and i not in path:\n                dfs(i, path + [i])\n\n    longest_path = []\n    dfs(start, [start])\n\n    return longest_path", "solution_func": "def g():\n    return ([[0, 1, 2, 0], [0, 0, 0, 3], [0, 0, 0, 1], [0, 0, 0, 0]], 0, 3)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of distinct integers nums and a target value, return the index if the target is found.\n    If not, return the index where it would be if it were inserted in order.\n\n    Example:\n    nums = [1,3,5,6], target = 5\n    Output: 2\n\n    Explanation:\n    5 is found at index 2 in the array.\n\n    nums = [1,3,5,6], target = 2\n    Output: 1\n\n    Explanation:\n    2 is not found in the array, so it would be inserted at index 1.\n\n    \"\"\"\n\n    left = 0\n    right = len(nums)\n\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid\n\n    return left\n\ndef g() -> (List[int], int):\n    nums = [1, 3, 5, 6]\n    target = 5\n    return nums, target\n\nassert f(*g()) == 2\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 363, "target_skills": [1, 0, 1, 0, 1, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of distinct integers nums and a target value, return the index if the target is found.\n    If not, return the index where it would be if it were inserted in order.\n\n    Example:\n    nums = [1,3,5,6], target = 5\n    Output: 2\n\n    Explanation:\n    5 is found at index 2 in the array.\n\n    nums = [1,3,5,6], target = 2\n    Output: 1\n\n    Explanation:\n    2 is not found in the array, so it would be inserted at index 1.\n\n    \"\"\"\n\n    left = 0\n    right = len(nums)\n\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid\n\n    return left", "solution_func": "def g() -> (List[int], int):\n    nums = [1, 3, 5, 6]\n    target = 5\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"\n    Given an integer num, return the number of steps to reduce it to zero.\n    If the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it.\n    Repeat the process until the number is zero.\n\n    Example:\n    num = 14\n    Output: 6\n\n    Explanation:\n    Step 1: 14 is even, divide by 2 to get 7.\n    Step 2: 7 is odd, subtract 1 to get 6.\n    Step 3: 6 is even, divide by 2 to get 3.\n    Step 4: 3 is odd, subtract 1 to get 2.\n    Step 5: 2 is even, divide by 2 to get 1.\n    Step 6: 1 is odd, subtract 1 to get 0.\n\n    \"\"\"\n\n    steps = 0\n\n    while num != 0:\n        if num % 2 == 0:\n            num //= 2\n        else:\n            num -= 1\n        steps += 1\n\n    return steps\n\ndef g() -> int:\n    num = 14\n    return num\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 363, "target_skills": [0, 0, 1, 0, 1, 0, 1, 1, 1, 1], "problem_func": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"\n    Given an integer num, return the number of steps to reduce it to zero.\n    If the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it.\n    Repeat the process until the number is zero.\n\n    Example:\n    num = 14\n    Output: 6\n\n    Explanation:\n    Step 1: 14 is even, divide by 2 to get 7.\n    Step 2: 7 is odd, subtract 1 to get 6.\n    Step 3: 6 is even, divide by 2 to get 3.\n    Step 4: 3 is odd, subtract 1 to get 2.\n    Step 5: 2 is even, divide by 2 to get 1.\n    Step 6: 1 is odd, subtract 1 to get 0.\n\n    \"\"\"\n\n    steps = 0\n\n    while num != 0:\n        if num % 2 == 0:\n            num //= 2\n        else:\n            num -= 1\n        steps += 1\n\n    return steps", "solution_func": "def g() -> int:\n    num = 14\n    return num", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted (in ascending order) integer array nums of n elements and a target value,\n    write a function to search target in nums. If target exists, then return its index, otherwise return -1.\n\n    Example:\n    nums = [-1,0,3,5,9,12], target = 9\n    Output: 4\n\n    Explanation:\n    9 is found at index 4 in the array.\n\n    nums = [-1,0,3,5,9,12], target = 2\n    Output: -1\n\n    Explanation:\n    2 is not found in the array.\n\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> (List[int], int):\n    nums = [-1, 0, 3, 5, 9, 12]\n    target = 9\n    return nums, target\n\nassert f(*g()) == 4\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 363, "target_skills": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted (in ascending order) integer array nums of n elements and a target value,\n    write a function to search target in nums. If target exists, then return its index, otherwise return -1.\n\n    Example:\n    nums = [-1,0,3,5,9,12], target = 9\n    Output: 4\n\n    Explanation:\n    9 is found at index 4 in the array.\n\n    nums = [-1,0,3,5,9,12], target = 2\n    Output: -1\n\n    Explanation:\n    2 is not found in the array.\n\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g() -> (List[int], int):\n    nums = [-1, 0, 3, 5, 9, 12]\n    target = 9\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, count the number of distinct elements in the list.\n\n    Example:\n    nums = [1, 2, 3, 1, 2, 3, 4, 5]\n\n    Output:\n    5\n\n    Explanation:\n    There are 5 distinct elements in the list: 1, 2, 3, 4, 5.\n\n    Hint: Use a set to keep track of unique elements and return the length of the set.\n    \"\"\"\n    return len(set(nums))\n\ndef g():\n    nums = [1, 2, 3, 1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 5\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 363, "target_skills": [1, 1, 1, 0, 1, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, count the number of distinct elements in the list.\n\n    Example:\n    nums = [1, 2, 3, 1, 2, 3, 4, 5]\n\n    Output:\n    5\n\n    Explanation:\n    There are 5 distinct elements in the list: 1, 2, 3, 4, 5.\n\n    Hint: Use a set to keep track of unique elements and return the length of the set.\n    \"\"\"\n    return len(set(nums))", "solution_func": "def g():\n    nums = [1, 2, 3, 1, 2, 3, 4, 5]\n    return nums", "map_ix": [1, 1, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of set bits (1s) in its binary representation.\n\n    Example:\n    n = 10\n\n    Output:\n    2\n\n    Explanation:\n    The binary representation of 10 is 1010, which contains 2 set bits.\n\n    Hint: Use the bitwise AND operation to count the set bits.\n    \"\"\"\n    count = 0\n    while n > 0:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g():\n    n = 10\n    return n\n\nassert f(g()) == 2\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 363, "target_skills": [1, 0, 1, 1, 0, 1, 1, 0, 1, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of set bits (1s) in its binary representation.\n\n    Example:\n    n = 10\n\n    Output:\n    2\n\n    Explanation:\n    The binary representation of 10 is 1010, which contains 2 set bits.\n\n    Hint: Use the bitwise AND operation to count the set bits.\n    \"\"\"\n    count = 0\n    while n > 0:\n        count += n & 1\n        n >>= 1\n    return count", "solution_func": "def g():\n    n = 10\n    return n", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of words in the string while keeping the words themselves unchanged.\n\n    Example:\n    s = \"Hello World\"\n\n    Output:\n    \"World Hello\"\n\n    Explanation:\n    The words in the string are \"Hello\" and \"World\". Reversing the order of the words gives \"World Hello\".\n\n    Hint: Split the string into words, reverse the order of the words, and join them back into a string.\n    \"\"\"\n    words = s.split()\n    words.reverse()\n    return \" \".join(words)\n\ndef g():\n    s = \"Hello World\"\n    return s\n\nassert f(g()) == \"World Hello\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 363, "target_skills": [0, 0, 0, 0, 0, 1, 1, 1, 1, 1], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of words in the string while keeping the words themselves unchanged.\n\n    Example:\n    s = \"Hello World\"\n\n    Output:\n    \"World Hello\"\n\n    Explanation:\n    The words in the string are \"Hello\" and \"World\". Reversing the order of the words gives \"World Hello\".\n\n    Hint: Split the string into words, reverse the order of the words, and join them back into a string.\n    \"\"\"\n    words = s.split()\n    words.reverse()\n    return \" \".join(words)", "solution_func": "def g():\n    s = \"Hello World\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Determine if a given matrix is a magic square.\n\n    A magic square is a square matrix in which the sum of every row, column, and diagonal is the same.\n\n    Return True if the matrix is a magic square, False otherwise.\n\n    Example:\n    matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n\n    Output:\n    True\n\n    Hint: Calculate the sum of the first row and use it as a reference to check the sums of the other rows, columns, and diagonals.\n    \"\"\"\n\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = 0\n        for row in matrix:\n            col_sum += row[col]\n        if col_sum != target_sum:\n            return False\n\n    # Check diagonal from top left to bottom right\n    diagonal_sum = 0\n    for i in range(n):\n        diagonal_sum += matrix[i][i]\n    if diagonal_sum != target_sum:\n        return False\n\n    # Check diagonal from top right to bottom left\n    diagonal_sum = 0\n    for i in range(n):\n        diagonal_sum += matrix[i][n-i-1]\n    if diagonal_sum != target_sum:\n        return False\n\n    return True\n\ndef g():\n    matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    return matrix\n\nassert f(g()) == True\n", "emb": [1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0], "idx_generation": 363, "target_skills": [1, 0, 1, 1, 1, 0, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Determine if a given matrix is a magic square.\n\n    A magic square is a square matrix in which the sum of every row, column, and diagonal is the same.\n\n    Return True if the matrix is a magic square, False otherwise.\n\n    Example:\n    matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n\n    Output:\n    True\n\n    Hint: Calculate the sum of the first row and use it as a reference to check the sums of the other rows, columns, and diagonals.\n    \"\"\"\n\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = 0\n        for row in matrix:\n            col_sum += row[col]\n        if col_sum != target_sum:\n            return False\n\n    # Check diagonal from top left to bottom right\n    diagonal_sum = 0\n    for i in range(n):\n        diagonal_sum += matrix[i][i]\n    if diagonal_sum != target_sum:\n        return False\n\n    # Check diagonal from top right to bottom left\n    diagonal_sum = 0\n    for i in range(n):\n        diagonal_sum += matrix[i][n-i-1]\n    if diagonal_sum != target_sum:\n        return False\n\n    return True", "solution_func": "def g():\n    matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    return matrix", "map_ix": [1, 1, 1, 1, 0, 1, 1, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if the target value is present in the list using binary search algorithm.\n    \"\"\"\n    low = 0\n    high = len(nums) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False\n\ndef g() -> List[int]:\n    return [1, 3, 5, 7, 9, 11, 13, 15]\n\nassert f(g(), 9) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 364, "target_skills": [1, 0, 0, 1, 0, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if the target value is present in the list using binary search algorithm.\n    \"\"\"\n    low = 0\n    high = len(nums) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False", "solution_func": "def g() -> List[int]:\n    return [1, 3, 5, 7, 9, 11, 13, 15]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    The path can only move down or right.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 7\n", "emb": null, "idx_generation": 364, "target_skills": [1, 1, 0, 1, 1, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    The path can only move down or right.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[rows-1][cols-1]", "solution_func": "def g() -> List[List[int]]:\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum difference between any two elements in the list.\n    \"\"\"\n    if len(nums) < 2:\n        return 0\n    \n    min_num = float('inf')\n    max_diff = 0\n    \n    for num in nums:\n        min_num = min(min_num, num)\n        max_diff = max(max_diff, num - min_num)\n    \n    return max_diff\n\ndef g() -> List[int]:\n    return [7, 1, 5, 3, 6, 4]\n\nassert f(g()) == 5\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 364, "target_skills": [1, 0, 0, 0, 1, 1, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum difference between any two elements in the list.\n    \"\"\"\n    if len(nums) < 2:\n        return 0\n    \n    min_num = float('inf')\n    max_diff = 0\n    \n    for num in nums:\n        min_num = min(min_num, num)\n        max_diff = max(max_diff, num - min_num)\n    \n    return max_diff", "solution_func": "def g() -> List[int]:\n    return [7, 1, 5, 3, 6, 4]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of valid parentheses expressions of length n.\n    \"\"\"\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i - 1 - j]\n\n    return dp[n]\n\ndef g():\n    n = 3\n    return n\n\nassert f(g()) == 5\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 364, "target_skills": [0, 0, 0, 0, 0, 0, 1, 1, 1, 1], "problem_func": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of valid parentheses expressions of length n.\n    \"\"\"\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i - 1 - j]\n\n    return dp[n]", "solution_func": "def g():\n    n = 3\n    return n", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of the first n Fibonacci numbers.\n    \"\"\"\n\n    if n <= 0:\n        return 0\n\n    fib = [0] * (n + 1)\n    fib[1] = 1\n\n    for i in range(2, n + 1):\n        fib[i] = fib[i - 1] + fib[i - 2]\n\n    return sum(fib)\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == 12\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 364, "target_skills": [1, 1, 1, 0, 1, 1, 1, 0, 0, 0], "problem_func": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of the first n Fibonacci numbers.\n    \"\"\"\n\n    if n <= 0:\n        return 0\n\n    fib = [0] * (n + 1)\n    fib[1] = 1\n\n    for i in range(2, n + 1):\n        fib[i] = fib[i - 1] + fib[i - 2]\n\n    return sum(fib)", "solution_func": "def g():\n    n = 5\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and an integer target, find the maximum sum of a subsequence such that the sum is less than or equal to the target.\n    \"\"\"\n\n    nums.sort()\n    total = 0\n    count = 0\n\n    for num in nums:\n        total += num\n        if total > target:\n            break\n        count += 1\n\n    return count\n\ndef g():\n    nums = [1, 4, 5, 8, 10]\n    target = 9\n    return nums, target\n\nassert f(*g()) == 3\n\n", "emb": null, "idx_generation": 364, "target_skills": [0, 0, 1, 0, 0, 0, 0, 0, 0, 1], "problem_func": "from typing import*\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and an integer target, find the maximum sum of a subsequence such that the sum is less than or equal to the target.\n    \"\"\"\n\n    nums.sort()\n    total = 0\n    count = 0\n\n    for num in nums:\n        total += num\n        if total > target:\n            break\n        count += 1\n\n    return count", "solution_func": "def g():\n    nums = [1, 4, 5, 8, 10]\n    target = 9\n    return nums, target", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if the target can be achieved by performing bitwise OR operations on the elements of nums\"\"\"\n    return canBitwiseOR(nums, target, 0)\n\ndef canBitwiseOR(nums: List[int], target: int, index: int) -> bool:\n    if index == len(nums):\n        return target == 0\n    return canBitwiseOR(nums, target | nums[index], index + 1) or canBitwiseOR(nums, target, index + 1)\n\ndef g(nums=[1, 2, 3, 4], target=5):\n    return nums\n\nassert f(g()) == True\n", "emb": null, "idx_generation": 364, "target_skills": [1, 1, 0, 0, 1, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if the target can be achieved by performing bitwise OR operations on the elements of nums\"\"\"\n    return canBitwiseOR(nums, target, 0)\n\ndef canBitwiseOR(nums: List[int], target: int, index: int) -> bool:\n    if index == len(nums):\n        return target == 0\n    return canBitwiseOR(nums, target | nums[index], index + 1) or canBitwiseOR(nums, target, index + 1)", "solution_func": "def g(nums=[1, 2, 3, 4], target=5):\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the maximum sum of a subgrid within the given grid\"\"\"\n    maxSum = float('-inf')\n    rows = len(grid)\n    cols = len(grid[0])\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(i, rows):\n                for l in range(j, cols):\n                    subgridSum = getSubgridSum(grid, i, j, k, l)\n                    maxSum = max(maxSum, subgridSum)\n    return maxSum\n\ndef getSubgridSum(grid: List[List[int]], top: int, left: int, bottom: int, right: int) -> int:\n    subgridSum = 0\n    for i in range(top, bottom + 1):\n        for j in range(left, right + 1):\n            subgridSum += grid[i][j]\n    return subgridSum\n\ndef g(grid=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return grid\n\nassert f(g()) == 45\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 364, "target_skills": [1, 0, 1, 0, 0, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the maximum sum of a subgrid within the given grid\"\"\"\n    maxSum = float('-inf')\n    rows = len(grid)\n    cols = len(grid[0])\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(i, rows):\n                for l in range(j, cols):\n                    subgridSum = getSubgridSum(grid, i, j, k, l)\n                    maxSum = max(maxSum, subgridSum)\n    return maxSum\n\ndef getSubgridSum(grid: List[List[int]], top: int, left: int, bottom: int, right: int) -> int:\n    subgridSum = 0\n    for i in range(top, bottom + 1):\n        for j in range(left, right + 1):\n            subgridSum += grid[i][j]\n    return subgridSum", "solution_func": "def g(grid=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return grid", "map_ix": [1, 1, 0, 1, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int, words: List[str]) -> List[int]:\n    \"\"\"Find the indices of the k most frequent strings among the given words\"\"\"\n    wordCounts = {}\n    for word in words:\n        wordCounts[word] = wordCounts.get(word, 0) + 1\n    sortedWords = sorted(wordCounts.keys(), key=lambda x: (-wordCounts[x], x))\n    return [i for i, word in enumerate(sortedWords) if i < k]\n\ndef g(n=5, k=2, words=[\"apple\", \"banana\", \"apple\", \"orange\", \"banana\"]):\n    return n, k, words\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 364, "target_skills": [0, 1, 1, 1, 0, 1, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int, words: List[str]) -> List[int]:\n    \"\"\"Find the indices of the k most frequent strings among the given words\"\"\"\n    wordCounts = {}\n    for word in words:\n        wordCounts[word] = wordCounts.get(word, 0) + 1\n    sortedWords = sorted(wordCounts.keys(), key=lambda x: (-wordCounts[x], x))\n    return [i for i, word in enumerate(sortedWords) if i < k]", "solution_func": "def g(n=5, k=2, words=[\"apple\", \"banana\", \"apple\", \"orange\", \"banana\"]):\n    return n, k, words", "map_ix": [1, 1, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of integers, determine if it is a valid Sudoku solution.\n\n    Example:\n    grid = [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]\n\n    Output:\n    True\n\n    Explanation:\n    The above grid represents a valid Sudoku solution.\n    \"\"\"\n\n    def is_valid_row(grid: List[List[int]], row: int) -> bool:\n        seen = set()\n        for num in grid[row]:\n            if num != 0:\n                if num in seen:\n                    return False\n                seen.add(num)\n        return True\n\n    def is_valid_column(grid: List[List[int]], col: int) -> bool:\n        seen = set()\n        for row in range(9):\n            num = grid[row][col]\n            if num != 0:\n                if num in seen:\n                    return False\n                seen.add(num)\n        return True\n\n    def is_valid_box(grid: List[List[int]], start_row: int, start_col: int) -> bool:\n        seen = set()\n        for row in range(start_row, start_row + 3):\n            for col in range(start_col, start_col + 3):\n                num = grid[row][col]\n                if num != 0:\n                    if num in seen:\n                        return False\n                    seen.add(num)\n        return True\n\n    for row in range(9):\n        if not is_valid_row(grid, row):\n            return False\n\n    for col in range(9):\n        if not is_valid_column(grid, col):\n            return False\n\n    for start_row in range(0, 9, 3):\n        for start_col in range(0, 9, 3):\n            if not is_valid_box(grid, start_row, start_col):\n                return False\n\n    return True\n\n\ndef g() -> List[List[int]]:\n    return [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]\n\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 364, "target_skills": [1, 1, 0, 1, 0, 0, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of integers, determine if it is a valid Sudoku solution.\n\n    Example:\n    grid = [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]\n\n    Output:\n    True\n\n    Explanation:\n    The above grid represents a valid Sudoku solution.\n    \"\"\"\n\n    def is_valid_row(grid: List[List[int]], row: int) -> bool:\n        seen = set()\n        for num in grid[row]:\n            if num != 0:\n                if num in seen:\n                    return False\n                seen.add(num)\n        return True\n\n    def is_valid_column(grid: List[List[int]], col: int) -> bool:\n        seen = set()\n        for row in range(9):\n            num = grid[row][col]\n            if num != 0:\n                if num in seen:\n                    return False\n                seen.add(num)\n        return True\n\n    def is_valid_box(grid: List[List[int]], start_row: int, start_col: int) -> bool:\n        seen = set()\n        for row in range(start_row, start_row + 3):\n            for col in range(start_col, start_col + 3):\n                num = grid[row][col]\n                if num != 0:\n                    if num in seen:\n                        return False\n                    seen.add(num)\n        return True\n\n    for row in range(9):\n        if not is_valid_row(grid, row):\n            return False\n\n    for col in range(9):\n        if not is_valid_column(grid, col):\n            return False\n\n    for start_row in range(0, 9, 3):\n        for start_col in range(0, 9, 3):\n            if not is_valid_box(grid, start_row, start_col):\n                return False\n\n    return True", "solution_func": "def g() -> List[List[int]]:\n    return [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of arithmetic subsequences that can be formed from the list.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5]\n    Output: 7\n    Explanation:\n    The arithmetic subsequences that can be formed are: [1, 2], [2, 3], [3, 4], [4, 5], [1, 3], [2, 4], [3, 5].\n    Therefore, the number of arithmetic subsequences is 7.\n    \"\"\"\n    count = 0\n    n = len(nums)\n    dp = [{} for _ in range(n)]\n    \n    for i in range(1, n):\n        for j in range(i):\n            diff = nums[i] - nums[j]\n            count += dp[j].get(diff, 0)\n            dp[i][diff] = dp[i].get(diff, 0) + dp[j].get(diff, 0) + 1\n    \n    return count\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 7\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 365, "target_skills": [1, 1, 0, 1, 1, 0, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of arithmetic subsequences that can be formed from the list.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5]\n    Output: 7\n    Explanation:\n    The arithmetic subsequences that can be formed are: [1, 2], [2, 3], [3, 4], [4, 5], [1, 3], [2, 4], [3, 5].\n    Therefore, the number of arithmetic subsequences is 7.\n    \"\"\"\n    count = 0\n    n = len(nums)\n    dp = [{} for _ in range(n)]\n    \n    for i in range(1, n):\n        for j in range(i):\n            diff = nums[i] - nums[j]\n            count += dp[j].get(diff, 0)\n            dp[i][diff] = dp[i].get(diff, 0) + dp[j].get(diff, 0) + 1\n    \n    return count", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3, 4, 5]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the number of unique paths from the top-left to the bottom-right cell,\n    where you can only move down or right.\n\n    Example:\n    Input: grid = [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]\n    Output: 2\n    Explanation:\n    The unique paths are: [0, 0, 0, 0, 0], [0, 0, 0, 1, 0].\n    Therefore, the number of unique paths is 2.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1\n    \n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                continue\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n    \n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    return [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]\n\nassert f(g()) == 2\n\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 365, "target_skills": [1, 0, 0, 1, 0, 0, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the number of unique paths from the top-left to the bottom-right cell,\n    where you can only move down or right.\n\n    Example:\n    Input: grid = [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]\n    Output: 2\n    Explanation:\n    The unique paths are: [0, 0, 0, 0, 0], [0, 0, 0, 1, 0].\n    Therefore, the number of unique paths is 2.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1\n    \n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                continue\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n    \n    return dp[m-1][n-1]", "solution_func": "def g() -> List[List[int]]:\n    return [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]", "map_ix": [1, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(nums: List[int], target: int) -> Tuple[int, int]:\n    \"\"\"\n    Given a sorted array of integers and a target number, find two numbers in the array that sum up to the target.\n    Return the indices of the two numbers as a tuple.\n\n    Example:\n    Input: nums = [-2, -1, 0, 1, 2, 3, 4], target = 3\n    Output: (1, 5)\n    Explanation:\n    The sum of -1 and 4 is 3, which is the target number.\n    Therefore, the indices of these two numbers are (1, 5).\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return (left, right)\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return (-1, -1)\n\ndef g() -> Tuple[List[int], int]:\n    return ([-2, -1, 0, 1, 2, 3, 4], 3)\n\nassert f(*g()) == (1, 5)\n\n", "emb": null, "idx_generation": 365, "target_skills": [1, 0, 0, 1, 1, 0, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(nums: List[int], target: int) -> Tuple[int, int]:\n    \"\"\"\n    Given a sorted array of integers and a target number, find two numbers in the array that sum up to the target.\n    Return the indices of the two numbers as a tuple.\n\n    Example:\n    Input: nums = [-2, -1, 0, 1, 2, 3, 4], target = 3\n    Output: (1, 5)\n    Explanation:\n    The sum of -1 and 4 is 3, which is the target number.\n    Therefore, the indices of these two numbers are (1, 5).\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return (left, right)\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return (-1, -1)", "solution_func": "def g() -> Tuple[List[int], int]:\n    return ([-2, -1, 0, 1, 2, 3, 4], 3)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1 (2 and 7) add up to the target value 9.\n\n    Hint: Use the two-pointer technique to find the two numbers.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return nums\n\nassert f(g()) == [0, 1]\n\n", "emb": null, "idx_generation": 365, "target_skills": [1, 1, 1, 0, 0, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1 (2 and 7) add up to the target value 9.\n\n    Hint: Use the two-pointer technique to find the two numbers.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g(nums=[2, 7, 11, 15], target=9):\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all the even numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    Output:\n    30\n\n    Explanation:\n    The sum of the even numbers (2, 4, 6, 8, 10) in the list is 30.\n\n    Hint: Use list comprehension to filter the even numbers and then calculate the sum.\n    \"\"\"\n    return sum([num for num in nums if num % 2 == 0])\n\ndef g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]):\n    return nums\n\nassert f(g()) == 30\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0], "idx_generation": 365, "target_skills": [0, 1, 1, 1, 0, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all the even numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    Output:\n    30\n\n    Explanation:\n    The sum of the even numbers (2, 4, 6, 8, 10) in the list is 30.\n\n    Hint: Use list comprehension to filter the even numbers and then calculate the sum.\n    \"\"\"\n    return sum([num for num in nums if num % 2 == 0])", "solution_func": "def g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]):\n    return nums", "map_ix": [1, 1, 0, 1, 0, 1, 0, 1, 1, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [-10, -10, 1, 3, 2]\n\n    Output:\n    300\n\n    Explanation:\n    The maximum product of any three numbers (-10, -10, 3) in the list is 300.\n\n    Hint: Sort the list and consider the cases where the largest and smallest numbers are negative.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3])\n\ndef g(nums=[-10, -10, 1, 3, 2]):\n    return nums\n\nassert f(g()) == 300\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 365, "target_skills": [1, 1, 0, 1, 0, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [-10, -10, 1, 3, 2]\n\n    Output:\n    300\n\n    Explanation:\n    The maximum product of any three numbers (-10, -10, 3) in the list is 300.\n\n    Hint: Sort the list and consider the cases where the largest and smallest numbers are negative.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3])", "solution_func": "def g(nums=[-10, -10, 1, 3, 2]):\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers and a target value, find two numbers in the array that add up to the target.\n    Return the indices of the two numbers in a list.\n\n    Args:\n    - nums: A sorted list of integers.\n    - target: The target sum.\n\n    Returns:\n    - A list containing the indices of the two numbers that add up to the target.\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a tuple containing a sorted list of integers and a target value.\n    The target value should be the sum of two numbers in the list.\n    \"\"\"\n    nums = [1, 3, 5, 7, 9]\n    target = 10\n    return (nums, target)\n\nassert f(*g()) == [0, 3]\n", "emb": null, "idx_generation": 365, "target_skills": [0, 0, 0, 0, 1, 1, 0, 0, 1, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers and a target value, find two numbers in the array that add up to the target.\n    Return the indices of the two numbers in a list.\n\n    Args:\n    - nums: A sorted list of integers.\n    - target: The target sum.\n\n    Returns:\n    - A list containing the indices of the two numbers that add up to the target.\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a tuple containing a sorted list of integers and a target value.\n    The target value should be the sum of two numbers in the list.\n    \"\"\"\n    nums = [1, 3, 5, 7, 9]\n    target = 10\n    return (nums, target)", "map_ix": null}, {"fitness": 1.0, "program_str": "import random\nfrom typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the sum of all positive integers less than or equal to n.\n\n    Args:\n    - n: An integer.\n\n    Returns:\n    - The sum of all positive integers less than or equal to n.\n    \"\"\"\n    if n <= 0:\n        return 0\n    return (n * (n + 1)) // 2\n\ndef g() -> int:\n    \"\"\"\n    Generate a random positive integer.\n    \"\"\"\n    n = 10\n    return n\n\nassert f(g()) == 55\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 365, "target_skills": [0, 0, 1, 1, 1, 1, 0, 1, 0, 1], "problem_func": "import random\nfrom typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the sum of all positive integers less than or equal to n.\n\n    Args:\n    - n: An integer.\n\n    Returns:\n    - The sum of all positive integers less than or equal to n.\n    \"\"\"\n    if n <= 0:\n        return 0\n    return (n * (n + 1)) // 2", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a random positive integer.\n    \"\"\"\n    n = 10\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "import random\nfrom typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the Fibonacci number at the nth position.\n\n    Args:\n    - n: A positive integer.\n\n    Returns:\n    - The Fibonacci number at the nth position.\n    \"\"\"\n    if n <= 1:\n        return n\n    return f(n-1) + f(n-2)\n\ndef g() -> int:\n    \"\"\"\n    Generate a random positive integer.\n    \"\"\"\n    n = 5\n    return n\n\nassert f(g()) == 5\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 365, "target_skills": [0, 0, 1, 0, 0, 0, 1, 1, 1, 0], "problem_func": "import random\nfrom typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the Fibonacci number at the nth position.\n\n    Args:\n    - n: A positive integer.\n\n    Returns:\n    - The Fibonacci number at the nth position.\n    \"\"\"\n    if n <= 1:\n        return n\n    return f(n-1) + f(n-2)", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a random positive integer.\n    \"\"\"\n    n = 5\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique paths from the top-left corner to the bottom-right corner of a n x n grid.\n    You can only move down or right at any point in time.\n    \"\"\"\n    def unique_paths(i: int, j: int) -> int:\n        if i == n-1 and j == n-1:\n            return 1\n        if i >= n or j >= n:\n            return 0\n        return unique_paths(i+1, j) + unique_paths(i, j+1)\n\n    return unique_paths(0, 0)\n\ndef g(n=3):\n    return n\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 365, "target_skills": [1, 0, 0, 1, 1, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique paths from the top-left corner to the bottom-right corner of a n x n grid.\n    You can only move down or right at any point in time.\n    \"\"\"\n    def unique_paths(i: int, j: int) -> int:\n        if i == n-1 and j == n-1:\n            return 1\n        if i >= n or j >= n:\n            return 0\n        return unique_paths(i+1, j) + unique_paths(i, j+1)\n\n    return unique_paths(0, 0)", "solution_func": "def g(n=3):\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size n x m, count the number of paths from the top-left corner to the bottom-right corner.\n    You can only move down or right. The grid contains obstacles represented by 1, which cannot be traversed.\n    \"\"\"\n    if grid[0][0] == 1 or grid[n-1][m-1] == 1:\n        return 0\n    \n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = 1\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                continue\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n    \n    return dp[n-1][m-1]\n\ndef g() -> Tuple[int, int, List[List[int]]]:\n    \"\"\"\n    Generate a grid and its dimensions.\n    \"\"\"\n    n = 3\n    m = 3\n    grid = [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]\n    return n, m, grid\n\nassert f(*g()) == 2\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 366, "target_skills": [0, 1, 0, 0, 0, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size n x m, count the number of paths from the top-left corner to the bottom-right corner.\n    You can only move down or right. The grid contains obstacles represented by 1, which cannot be traversed.\n    \"\"\"\n    if grid[0][0] == 1 or grid[n-1][m-1] == 1:\n        return 0\n    \n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = 1\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                continue\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n    \n    return dp[n-1][m-1]", "solution_func": "def g() -> Tuple[int, int, List[List[int]]]:\n    \"\"\"\n    Generate a grid and its dimensions.\n    \"\"\"\n    n = 3\n    m = 3\n    grid = [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]\n    return n, m, grid", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size n x m, determine the minimum number of steps required to reach the bottom-right corner\n    from the top-left corner. Each step can be taken in any of the four cardinal directions (up, down, left, right).\n    \"\"\"\n    if grid[0][0] == 1 or grid[n-1][m-1] == 1:\n        return -1\n    \n    dp = [[float('inf')] * m for _ in range(n)]\n    dp[0][0] = 0\n    \n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    queue = [(0, 0)]\n    \n    while queue:\n        i, j = queue.pop(0)\n        \n        for di, dj in directions:\n            ni, nj = i + di, j + dj\n            \n            if ni >= 0 and ni < n and nj >= 0 and nj < m and grid[ni][nj] == 0 and dp[i][j] + 1 < dp[ni][nj]:\n                dp[ni][nj] = dp[i][j] + 1\n                queue.append((ni, nj))\n    \n    if dp[n-1][m-1] == float('inf'):\n        return -1\n    else:\n        return dp[n-1][m-1]\n\ndef g() -> Tuple[int, int, List[List[int]]]:\n    \"\"\"\n    Generate a grid and its dimensions.\n    \"\"\"\n    n = 3\n    m = 3\n    grid = [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]\n    return n, m, grid\n\nassert f(*g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 366, "target_skills": [1, 0, 1, 0, 0, 0, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size n x m, determine the minimum number of steps required to reach the bottom-right corner\n    from the top-left corner. Each step can be taken in any of the four cardinal directions (up, down, left, right).\n    \"\"\"\n    if grid[0][0] == 1 or grid[n-1][m-1] == 1:\n        return -1\n    \n    dp = [[float('inf')] * m for _ in range(n)]\n    dp[0][0] = 0\n    \n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    queue = [(0, 0)]\n    \n    while queue:\n        i, j = queue.pop(0)\n        \n        for di, dj in directions:\n            ni, nj = i + di, j + dj\n            \n            if ni >= 0 and ni < n and nj >= 0 and nj < m and grid[ni][nj] == 0 and dp[i][j] + 1 < dp[ni][nj]:\n                dp[ni][nj] = dp[i][j] + 1\n                queue.append((ni, nj))\n    \n    if dp[n-1][m-1] == float('inf'):\n        return -1\n    else:\n        return dp[n-1][m-1]", "solution_func": "def g() -> Tuple[int, int, List[List[int]]]:\n    \"\"\"\n    Generate a grid and its dimensions.\n    \"\"\"\n    n = 3\n    m = 3\n    grid = [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]\n    return n, m, grid", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size n x m, find the maximum sum of values along a path from the top-left corner to the bottom-right corner.\n    Each step can be taken in any of the four cardinal directions (up, down, left, right).\n    \"\"\"\n    if grid[0][0] == 1 or grid[n-1][m-1] == 1:\n        return -1\n    \n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = grid[0][0]\n    \n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    for i in range(n):\n        for j in range(m):\n            for di, dj in directions:\n                ni, nj = i + di, j + dj\n                \n                if ni >= 0 and ni < n and nj >= 0 and nj < m:\n                    dp[ni][nj] = max(dp[ni][nj], dp[i][j] + grid[ni][nj])\n    \n    return dp[n-1][m-1]\n\ndef g() -> Tuple[int, int, List[List[int]]]:\n    \"\"\"\n    Generate a grid and its dimensions.\n    \"\"\"\n    n = 3\n    m = 3\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return n, m, grid\n\nassert f(*g()) == 29\n", "emb": null, "idx_generation": 366, "target_skills": [0, 1, 1, 0, 0, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size n x m, find the maximum sum of values along a path from the top-left corner to the bottom-right corner.\n    Each step can be taken in any of the four cardinal directions (up, down, left, right).\n    \"\"\"\n    if grid[0][0] == 1 or grid[n-1][m-1] == 1:\n        return -1\n    \n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = grid[0][0]\n    \n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    for i in range(n):\n        for j in range(m):\n            for di, dj in directions:\n                ni, nj = i + di, j + dj\n                \n                if ni >= 0 and ni < n and nj >= 0 and nj < m:\n                    dp[ni][nj] = max(dp[ni][nj], dp[i][j] + grid[ni][nj])\n    \n    return dp[n-1][m-1]", "solution_func": "def g() -> Tuple[int, int, List[List[int]]]:\n    \"\"\"\n    Generate a grid and its dimensions.\n    \"\"\"\n    n = 3\n    m = 3\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return n, m, grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, find the index of the target in the list using binary search.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output:\n    2\n\n    Explanation:\n    The target 5 is located at index 2 in the sorted list.\n\n    Hint: Use binary search to find the index of the target.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target\n\nassert f(*g()) == 2\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 366, "target_skills": [1, 0, 0, 1, 0, 1, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, find the index of the target in the list using binary search.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output:\n    2\n\n    Explanation:\n    The target 5 is located at index 2 in the sorted list.\n\n    Hint: Use binary search to find the index of the target.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g():\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(adj_list: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given an adjacency list representing a directed graph and two nodes start and end, determine whether there is a path from start to end.\n\n    Example:\n    adj_list = [[1, 2], [3], [4], [], [5], []]\n    start = 0\n    end = 5\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 0 to node 5 in the directed graph.\n\n    Hint: Use depth-first search (DFS) to traverse the graph and check if there is a path from start to end.\n    \"\"\"\n\n    visited = [False] * len(adj_list)\n\n    def dfs(node):\n        if node == end:\n            return True\n\n        visited[node] = True\n\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n\n        return False\n\n    return dfs(start)\n\ndef g():\n    adj_list = [[1, 2], [3], [4], [], [5], []]\n    start = 0\n    end = 5\n    return adj_list, start, end\n\nassert f(*g()) == True\n\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 366, "target_skills": [1, 0, 1, 0, 0, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(adj_list: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given an adjacency list representing a directed graph and two nodes start and end, determine whether there is a path from start to end.\n\n    Example:\n    adj_list = [[1, 2], [3], [4], [], [5], []]\n    start = 0\n    end = 5\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 0 to node 5 in the directed graph.\n\n    Hint: Use depth-first search (DFS) to traverse the graph and check if there is a path from start to end.\n    \"\"\"\n\n    visited = [False] * len(adj_list)\n\n    def dfs(node):\n        if node == end:\n            return True\n\n        visited[node] = True\n\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n\n        return False\n\n    return dfs(start)", "solution_func": "def g():\n    adj_list = [[1, 2], [3], [4], [], [5], []]\n    start = 0\n    end = 5\n    return adj_list, start, end", "map_ix": [1, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return a new list containing the next greater element for each element in the input list.\n\n    Example:\n    nums = [4, 5, 2, 9, 1, 8, 7]\n    \n    Output:\n    [5, 9, 9, -1, 8, -1, -1]\n    \n    Explanation:\n    The next greater element for 4 is 5.\n    The next greater element for 5 is 9.\n    The next greater element for 2 is 9.\n    The next greater element for 9, 1, 8, and 7 does not exist, so they are represented as -1.\n\n    Hint: Use a stack to keep track of the elements in decreasing order. Iterate through the input list and for each element, pop elements from the stack until a greater element is found. Store the next greater element for each element in a new list.\n    \"\"\"\n\n    stack = []\n    result = [-1] * len(nums)\n\n    for i in range(len(nums)):\n        while stack and nums[i] > nums[stack[-1]]:\n            result[stack.pop()] = nums[i]\n        stack.append(i)\n\n    return result\n\ndef g():\n    nums = [4, 5, 2, 9, 1, 8, 7]\n    return nums\n\nassert f(*g()) == [5, 9, 9, -1, 8, -1, -1]\n\n", "emb": null, "idx_generation": 366, "target_skills": [0, 1, 1, 0, 0, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return a new list containing the next greater element for each element in the input list.\n\n    Example:\n    nums = [4, 5, 2, 9, 1, 8, 7]\n    \n    Output:\n    [5, 9, 9, -1, 8, -1, -1]\n    \n    Explanation:\n    The next greater element for 4 is 5.\n    The next greater element for 5 is 9.\n    The next greater element for 2 is 9.\n    The next greater element for 9, 1, 8, and 7 does not exist, so they are represented as -1.\n\n    Hint: Use a stack to keep track of the elements in decreasing order. Iterate through the input list and for each element, pop elements from the stack until a greater element is found. Store the next greater element for each element in a new list.\n    \"\"\"\n\n    stack = []\n    result = [-1] * len(nums)\n\n    for i in range(len(nums)):\n        while stack and nums[i] > nums[stack[-1]]:\n            result[stack.pop()] = nums[i]\n        stack.append(i)\n\n    return result", "solution_func": "def g():\n    nums = [4, 5, 2, 9, 1, 8, 7]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(matrix: List[List[int]], target: int, rows=3, cols=3) -> bool:\n    \"\"\"\n    Given a matrix of integers and a target number, determine if the target number can be obtained by traversing the matrix.\n    The target number can be obtained by starting at any cell in the matrix and moving to adjacent cells (up, down, left, or right),\n    summing the values along the path. Return True if the target number can be obtained, False otherwise.\n    \"\"\"\n    def dfs(i, j, target):\n        if target == 0:\n            return True\n        if i < 0 or i >= rows or j < 0 or j >= cols or matrix[i][j] == -1:\n            return False\n        temp = matrix[i][j]\n        matrix[i][j] = -1\n        found = dfs(i+1, j, target - temp) or dfs(i-1, j, target - temp) or dfs(i, j+1, target - temp) or dfs(i, j-1, target - temp)\n        matrix[i][j] = temp\n        return found\n\n    for i in range(rows):\n        for j in range(cols):\n            if dfs(i, j, target):\n                return True\n    return False\n\ndef g(matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], target = 15):\n    return matrix, target\n\nassert f(*g())\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 366, "target_skills": [0, 1, 0, 0, 1, 1, 0, 1, 1, 0], "problem_func": "from typing import*\ndef f(matrix: List[List[int]], target: int, rows=3, cols=3) -> bool:\n    \"\"\"\n    Given a matrix of integers and a target number, determine if the target number can be obtained by traversing the matrix.\n    The target number can be obtained by starting at any cell in the matrix and moving to adjacent cells (up, down, left, or right),\n    summing the values along the path. Return True if the target number can be obtained, False otherwise.\n    \"\"\"\n    def dfs(i, j, target):\n        if target == 0:\n            return True\n        if i < 0 or i >= rows or j < 0 or j >= cols or matrix[i][j] == -1:\n            return False\n        temp = matrix[i][j]\n        matrix[i][j] = -1\n        found = dfs(i+1, j, target - temp) or dfs(i-1, j, target - temp) or dfs(i, j+1, target - temp) or dfs(i, j-1, target - temp)\n        matrix[i][j] = temp\n        return found\n\n    for i in range(rows):\n        for j in range(cols):\n            if dfs(i, j, target):\n                return True\n    return False", "solution_func": "def g(matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], target = 15):\n    return matrix, target", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(grid: List[List[int]], target: int, rows=3, cols=3) -> bool:\n    \"\"\"\n    Given a grid of integers and a target number, determine if the target number can be obtained by traversing the grid.\n    The target number can be obtained by starting at any cell in the grid and moving to adjacent cells (up, down, left, or right),\n    summing the values along the path. Return True if the target number can be obtained, False otherwise.\n    \"\"\"\n    def dfs(i, j, target):\n        if target == 0:\n            return True\n        if i < 0 or i >= rows or j < 0 or j >= cols or grid[i][j] == -1:\n            return False\n        temp = grid[i][j]\n        grid[i][j] = -1\n        found = dfs(i+1, j, target - temp) or dfs(i-1, j, target - temp) or dfs(i, j+1, target - temp) or dfs(i, j-1, target - temp)\n        grid[i][j] = temp\n        return found\n\n    for i in range(rows):\n        for j in range(cols):\n            if dfs(i, j, target):\n                return True\n    return False\n\ndef g(grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], target = 15):\n    return grid, target\n\nassert f(*g())\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 366, "target_skills": [1, 1, 0, 1, 1, 1, 1, 1, 1, 1], "problem_func": "from typing import*\ndef f(grid: List[List[int]], target: int, rows=3, cols=3) -> bool:\n    \"\"\"\n    Given a grid of integers and a target number, determine if the target number can be obtained by traversing the grid.\n    The target number can be obtained by starting at any cell in the grid and moving to adjacent cells (up, down, left, or right),\n    summing the values along the path. Return True if the target number can be obtained, False otherwise.\n    \"\"\"\n    def dfs(i, j, target):\n        if target == 0:\n            return True\n        if i < 0 or i >= rows or j < 0 or j >= cols or grid[i][j] == -1:\n            return False\n        temp = grid[i][j]\n        grid[i][j] = -1\n        found = dfs(i+1, j, target - temp) or dfs(i-1, j, target - temp) or dfs(i, j+1, target - temp) or dfs(i, j-1, target - temp)\n        grid[i][j] = temp\n        return found\n\n    for i in range(rows):\n        for j in range(cols):\n            if dfs(i, j, target):\n                return True\n    return False", "solution_func": "def g(grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], target = 15):\n    return grid, target", "map_ix": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int], rows=3, cols=3) -> bool:\n    \"\"\"\n    Given a maze represented by a matrix of integers, determine if there exists a path from the start position to the end position.\n    The maze is represented by a matrix, where 0 represents a path and 1 represents a wall. You can only move up, down, left, or right,\n    and you cannot cross walls. Return True if a path exists, False otherwise.\n    \"\"\"\n    def dfs(i, j):\n        if i < 0 or i >= rows or j < 0 or j >= cols or maze[i][j] == 1:\n            return False\n        if i == end[0] and j == end[1]:\n            return True\n        maze[i][j] = 1\n        found = dfs(i+1, j) or dfs(i-1, j) or dfs(i, j+1) or dfs(i, j-1)\n        maze[i][j] = 0\n        return found\n\n    return dfs(start[0], start[1])\n\ndef g(maze = [[0, 1, 0], [0, 0, 1], [0, 1, 0]], start = (0, 0), end = (2, 2)):\n    return maze, start, end\n\nassert f(*g())\n", "emb": null, "idx_generation": 366, "target_skills": [0, 0, 1, 1, 0, 0, 1, 1, 0, 0], "problem_func": "from typing import*\ndef f(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int], rows=3, cols=3) -> bool:\n    \"\"\"\n    Given a maze represented by a matrix of integers, determine if there exists a path from the start position to the end position.\n    The maze is represented by a matrix, where 0 represents a path and 1 represents a wall. You can only move up, down, left, or right,\n    and you cannot cross walls. Return True if a path exists, False otherwise.\n    \"\"\"\n    def dfs(i, j):\n        if i < 0 or i >= rows or j < 0 or j >= cols or maze[i][j] == 1:\n            return False\n        if i == end[0] and j == end[1]:\n            return True\n        maze[i][j] = 1\n        found = dfs(i+1, j) or dfs(i-1, j) or dfs(i, j+1) or dfs(i, j-1)\n        maze[i][j] = 0\n        return found\n\n    return dfs(start[0], start[1])", "solution_func": "def g(maze = [[0, 1, 0], [0, 0, 1], [0, 1, 0]], start = (0, 0), end = (2, 2)):\n    return maze, start, end", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a subarray where the sum of all elements is even.\n\n    Return True if such a subarray exists, otherwise return False.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    True\n\n    Explanation:\n    The subarray [2, 3, 4] has a sum of 9, which is even.\n    \"\"\"\n\n    prefix_sum = 0\n\n    for num in nums:\n        prefix_sum += num\n\n        if prefix_sum % 2 == 0:\n            return True\n\n    return False\n\ndef g(nums: List[int]):\n    \"\"\"\n    Generate a list of integers where there exists a subarray with an even sum.\n    \"\"\"\n    return nums\n\nassert f(g([1, 2, 3, 4])) == True\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 366, "target_skills": [0, 1, 1, 1, 1, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a subarray where the sum of all elements is even.\n\n    Return True if such a subarray exists, otherwise return False.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    True\n\n    Explanation:\n    The subarray [2, 3, 4] has a sum of 9, which is even.\n    \"\"\"\n\n    prefix_sum = 0\n\n    for num in nums:\n        prefix_sum += num\n\n        if prefix_sum % 2 == 0:\n            return True\n\n    return False", "solution_func": "def g(nums: List[int]):\n    \"\"\"\n    Generate a list of integers where there exists a subarray with an even sum.\n    \"\"\"\n    return nums", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the sum of all the even numbers in the list.\n    \"\"\"\n    even_sum = 0\n    for num in nums:\n        if num % 2 == 0:\n            even_sum += num\n    return even_sum\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g()) == 20\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 367, "target_skills": [1, 0, 0, 1, 1, 1, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the sum of all the even numbers in the list.\n    \"\"\"\n    even_sum = 0\n    for num in nums:\n        if num % 2 == 0:\n            even_sum += num\n    return even_sum", "solution_func": "def g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(string: str) -> str:\n    \"\"\"\n    Given a string, convert all lowercase letters to uppercase and all uppercase letters to lowercase.\n    \"\"\"\n    result = \"\"\n    for char in string:\n        if char.islower():\n            result += char.upper()\n        else:\n            result += char.lower()\n    return result\n\ndef g():\n    return \"Hello World\"\n\nassert f(g()) == \"hELLO wORLD\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 367, "target_skills": [1, 1, 0, 1, 0, 1, 1, 1, 1, 1], "problem_func": "from typing import*\ndef f(string: str) -> str:\n    \"\"\"\n    Given a string, convert all lowercase letters to uppercase and all uppercase letters to lowercase.\n    \"\"\"\n    result = \"\"\n    for char in string:\n        if char.islower():\n            result += char.upper()\n        else:\n            result += char.lower()\n    return result", "solution_func": "def g():\n    return \"Hello World\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the sum of all the elements in the grid.\n    \"\"\"\n    total_sum = 0\n    for row in grid:\n        for num in row:\n            total_sum += num\n    return total_sum\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 45\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 367, "target_skills": [1, 0, 1, 0, 1, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the sum of all the elements in the grid.\n    \"\"\"\n    total_sum = 0\n    for row in grid:\n        for num in row:\n            total_sum += num\n    return total_sum", "solution_func": "def g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, return all possible subsets of the list.\n\n    Example:\n    nums = [1, 2, 3]\n\n    Output:\n    [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n\n    Hint: Use the concept of combinations to generate all possible subsets.\n    \"\"\"\n\n    def backtrack(start, curr_subset):\n        res.append(curr_subset[:])\n        for i in range(start, len(nums)):\n            curr_subset.append(nums[i])\n            backtrack(i + 1, curr_subset)\n            curr_subset.pop()\n\n    res = []\n    backtrack(0, [])\n    return res\n\ndef g(nums=[1, 2, 3]):\n    return (nums,)\n\nassert f(*g()) == [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n", "emb": null, "idx_generation": 367, "target_skills": [0, 1, 0, 1, 1, 1, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, return all possible subsets of the list.\n\n    Example:\n    nums = [1, 2, 3]\n\n    Output:\n    [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n\n    Hint: Use the concept of combinations to generate all possible subsets.\n    \"\"\"\n\n    def backtrack(start, curr_subset):\n        res.append(curr_subset[:])\n        for i in range(start, len(nums)):\n            curr_subset.append(nums[i])\n            backtrack(i + 1, curr_subset)\n            curr_subset.pop()\n\n    res = []\n    backtrack(0, [])\n    return res", "solution_func": "def g(nums=[1, 2, 3]):\n    return (nums,)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the shortest path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The shortest path is 1 -> 3 -> 1 -> 1 -> 1, with a total sum of 7.\n\n    Hint: Use dynamic programming to store the shortest paths to each cell.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[m - 1][n - 1]\n\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return (grid,)\n\nassert f(*g()) == 7\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 367, "target_skills": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the shortest path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The shortest path is 1 -> 3 -> 1 -> 1 -> 1, with a total sum of 7.\n\n    Hint: Use dynamic programming to store the shortest paths to each cell.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[m - 1][n - 1]", "solution_func": "def g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return (grid,)", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return the list sorted in non-decreasing order using the merge sort algorithm.\n\n    Example:\n    nums = [6, 3, 8, 2, 10]\n\n    Output:\n    [2, 3, 6, 8, 10]\n\n    Hint: Use recursion to divide the list into smaller subarrays and merge them back together in sorted order.\n    \"\"\"\n\n    def merge(left, right):\n        merged = []\n        i, j = 0, 0\n\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n\n        while i < len(left):\n            merged.append(left[i])\n            i += 1\n\n        while j < len(right):\n            merged.append(right[j])\n            j += 1\n\n        return merged\n\n    def merge_sort(nums):\n        if len(nums) <= 1:\n            return nums\n\n        mid = len(nums) // 2\n        left = merge_sort(nums[:mid])\n        right = merge_sort(nums[mid:])\n        return merge(left, right)\n\n    return merge_sort(nums)\n\ndef g(nums=[6, 3, 8, 2, 10]):\n    return (nums,)\n\nassert f(*g()) == [2, 3, 6, 8, 10]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 367, "target_skills": [0, 0, 0, 0, 0, 1, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return the list sorted in non-decreasing order using the merge sort algorithm.\n\n    Example:\n    nums = [6, 3, 8, 2, 10]\n\n    Output:\n    [2, 3, 6, 8, 10]\n\n    Hint: Use recursion to divide the list into smaller subarrays and merge them back together in sorted order.\n    \"\"\"\n\n    def merge(left, right):\n        merged = []\n        i, j = 0, 0\n\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n\n        while i < len(left):\n            merged.append(left[i])\n            i += 1\n\n        while j < len(right):\n            merged.append(right[j])\n            j += 1\n\n        return merged\n\n    def merge_sort(nums):\n        if len(nums) <= 1:\n            return nums\n\n        mid = len(nums) // 2\n        left = merge_sort(nums[:mid])\n        right = merge_sort(nums[mid:])\n        return merge(left, right)\n\n    return merge_sort(nums)", "solution_func": "def g(nums=[6, 3, 8, 2, 10]):\n    return (nums,)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], k: int) -> List[str]:\n    \"\"\"\n    Given a list of words and an integer k, return the k most frequent words in the list.\n    If two words have the same frequency, then the word with the lower alphabetical order comes first.\n    \"\"\"\n    word_count = {}\n    for word in words:\n        if word in word_count:\n            word_count[word] += 1\n        else:\n            word_count[word] = 1\n    \n    sorted_words = sorted(word_count.keys(), key=lambda x: (-word_count[x], x))\n    \n    return sorted_words[:k]\n\ndef g():\n    return ([\"apple\", \"banana\", \"cherry\", \"apple\", \"banana\", \"apple\"], 2)\n\nassert f(*g()) == [\"apple\", \"banana\"]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 367, "target_skills": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], k: int) -> List[str]:\n    \"\"\"\n    Given a list of words and an integer k, return the k most frequent words in the list.\n    If two words have the same frequency, then the word with the lower alphabetical order comes first.\n    \"\"\"\n    word_count = {}\n    for word in words:\n        if word in word_count:\n            word_count[word] += 1\n        else:\n            word_count[word] = 1\n    \n    sorted_words = sorted(word_count.keys(), key=lambda x: (-word_count[x], x))\n    \n    return sorted_words[:k]", "solution_func": "def g():\n    return ([\"apple\", \"banana\", \"cherry\", \"apple\", \"banana\", \"apple\"], 2)", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, determine if it is bipartite.\n    A graph is bipartite if its vertices can be divided into two disjoint sets such that every edge connects a vertex from one set to another set.\n    \"\"\"\n    n = len(graph)\n    color = [0] * n\n    \n    def dfs(node, c):\n        color[node] = c\n        for neighbor in range(n):\n            if graph[node][neighbor] and color[neighbor] == c:\n                return False\n            if graph[node][neighbor] and color[neighbor] == 0 and not dfs(neighbor, -c):\n                return False\n        return True\n    \n    for node in range(n):\n        if color[node] == 0 and not dfs(node, 1):\n            return False\n    \n    return True\n\ndef g():\n    return ([[0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0]])\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 367, "target_skills": [1, 0, 0, 1, 1, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, determine if it is bipartite.\n    A graph is bipartite if its vertices can be divided into two disjoint sets such that every edge connects a vertex from one set to another set.\n    \"\"\"\n    n = len(graph)\n    color = [0] * n\n    \n    def dfs(node, c):\n        color[node] = c\n        for neighbor in range(n):\n            if graph[node][neighbor] and color[neighbor] == c:\n                return False\n            if graph[node][neighbor] and color[neighbor] == 0 and not dfs(neighbor, -c):\n                return False\n        return True\n    \n    for node in range(n):\n        if color[node] == 0 and not dfs(node, 1):\n            return False\n    \n    return True", "solution_func": "def g():\n    return ([[0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0]])", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of 0s and 1s, find the largest square submatrix containing only 1s and return its area.\n    \"\"\"\n    if not matrix:\n        return 0\n    \n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    max_area = 0\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i - 1][j - 1] == 1:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                max_area = max(max_area, dp[i][j] ** 2)\n    \n    return max_area\n\ndef g():\n    return ([[1, 0, 1, 0, 0], [1, 1, 1, 1, 0], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [0, 0, 1, 1, 1]])\n\nassert f(*g()) == 9\n", "emb": null, "idx_generation": 367, "target_skills": [1, 1, 0, 0, 1, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of 0s and 1s, find the largest square submatrix containing only 1s and return its area.\n    \"\"\"\n    if not matrix:\n        return 0\n    \n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    max_area = 0\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i - 1][j - 1] == 1:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                max_area = max(max_area, dp[i][j] ** 2)\n    \n    return max_area", "solution_func": "def g():\n    return ([[1, 0, 1, 0, 0], [1, 1, 1, 1, 0], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [0, 0, 1, 1, 1]])", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of distinct prime numbers.\n\n    Example:\n    Input: nums = [2, 3, 5, 7, 8, 9, 11, 13]\n    Output: 6\n\n    Explanation:\n    The distinct prime numbers are 2, 3, 5, 7, 11, and 13.\n    \"\"\"\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    distinct_primes = set()\n    for num in nums:\n        if is_prime(num):\n            distinct_primes.add(num)\n    \n    return len(distinct_primes)\n\ndef g():\n    return [2, 3, 5, 7, 8, 9, 11, 13]\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 367, "target_skills": [0, 0, 1, 1, 1, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of distinct prime numbers.\n\n    Example:\n    Input: nums = [2, 3, 5, 7, 8, 9, 11, 13]\n    Output: 6\n\n    Explanation:\n    The distinct prime numbers are 2, 3, 5, 7, 11, and 13.\n    \"\"\"\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    distinct_primes = set()\n    for num in nums:\n        if is_prime(num):\n            distinct_primes.add(num)\n    \n    return len(distinct_primes)", "solution_func": "def g():\n    return [2, 3, 5, 7, 8, 9, 11, 13]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three elements in the list.\n\n    Return the maximum product.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    60\n\n    Explanation:\n    The maximum product of any three elements in the list is 4 * 5 * 3 = 60.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 60\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 368, "target_skills": [1, 0, 0, 1, 0, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three elements in the list.\n\n    Return the maximum product.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    60\n\n    Explanation:\n    The maximum product of any three elements in the list is 4 * 5 * 3 = 60.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])", "solution_func": "def g():\n    return [1, 2, 3, 4, 5]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any contiguous subarray in the list.\n\n    Return the maximum sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The contiguous subarray with the maximum sum is [4, -1, 2, 1], which has a sum of 6.\n    \"\"\"\n    n = len(nums)\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for i in range(n):\n        curr_sum += nums[i]\n        \n        if curr_sum > max_sum:\n            max_sum = curr_sum\n        \n        if curr_sum < 0:\n            curr_sum = 0\n    \n    return max_sum\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 368, "target_skills": [1, 0, 0, 1, 0, 1, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any contiguous subarray in the list.\n\n    Return the maximum sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The contiguous subarray with the maximum sum is [4, -1, 2, 1], which has a sum of 6.\n    \"\"\"\n    n = len(nums)\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for i in range(n):\n        curr_sum += nums[i]\n        \n        if curr_sum > max_sum:\n            max_sum = curr_sum\n        \n        if curr_sum < 0:\n            curr_sum = 0\n    \n    return max_sum", "solution_func": "def g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the factorial of n.\n\n    Example:\n    n = 5\n\n    Output:\n    120\n\n    Explanation:\n    The factorial of 5 is 5 * 4 * 3 * 2 * 1 = 120.\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n    \n    return n * f(n-1)\n\ndef g():\n    return 5\n\nassert f(g()) == 120\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 368, "target_skills": [1, 0, 1, 0, 1, 0, 1, 0, 1, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the factorial of n.\n\n    Example:\n    n = 5\n\n    Output:\n    120\n\n    Explanation:\n    The factorial of 5 is 5 * 4 * 3 * 2 * 1 = 120.\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n    \n    return n * f(n-1)", "solution_func": "def g():\n    return 5", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], x: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers arr and a target integer x,\n    determine if there are two numbers in the list that add up to x.\n    \n    Example:\n    arr = [1, 2, 3, 4, 5]\n    x = 7\n    \n    Output:\n    True (since 3 + 4 = 7)\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        if arr[left] + arr[right] == x:\n            return True\n        elif arr[left] + arr[right] < x:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target integer.\n    \"\"\"\n    arr = [1, 2, 3, 4, 5]\n    x = 7\n    return arr, x\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 368, "target_skills": [0, 0, 0, 1, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], x: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers arr and a target integer x,\n    determine if there are two numbers in the list that add up to x.\n    \n    Example:\n    arr = [1, 2, 3, 4, 5]\n    x = 7\n    \n    Output:\n    True (since 3 + 4 = 7)\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        if arr[left] + arr[right] == x:\n            return True\n        elif arr[left] + arr[right] < x:\n            left += 1\n        else:\n            right -= 1\n    \n    return False", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target integer.\n    \"\"\"\n    arr = [1, 2, 3, 4, 5]\n    x = 7\n    return arr, x", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n    \n    Example:\n    s = \"abcabcbb\"\n    \n    Output:\n    3 (since the longest substring without repeating characters is \"abc\")\n    \"\"\"\n    max_length = 0\n    start = 0\n    char_dict = {}\n    \n    for i in range(len(s)):\n        if s[i] in char_dict:\n            start = max(start, char_dict[s[i]] + 1)\n        char_dict[s[i]] = i\n        max_length = max(max_length, i - start + 1)\n    \n    return max_length\n\ndef g() -> str:\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"abcabcbb\"\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 368, "target_skills": [0, 0, 1, 1, 1, 1, 1, 1, 0, 1], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n    \n    Example:\n    s = \"abcabcbb\"\n    \n    Output:\n    3 (since the longest substring without repeating characters is \"abc\")\n    \"\"\"\n    max_length = 0\n    start = 0\n    char_dict = {}\n    \n    for i in range(len(s)):\n        if s[i] in char_dict:\n            start = max(start, char_dict[s[i]] + 1)\n        char_dict[s[i]] = i\n        max_length = max(max_length, i - start + 1)\n    \n    return max_length", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"abcabcbb\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of a subarray.\n\n    Example:\n    nums = [2, 3, -2, 4]\n\n    Output:\n    6 (since the maximum product is 2 * 3 = 6)\n    \"\"\"\n\n    def max_product(nums: List[int], idx: int, memo: Dict[int, int]) -> int:\n        if idx in memo:\n            return memo[idx]\n        if idx < 0:\n            return 1\n\n        max_product_1 = max_product(nums, idx - 1, memo) * nums[idx]\n        max_product_2 = max_product(nums, idx - 1, memo)\n\n        memo[idx] = max(max_product_1, max_product_2)\n        return memo[idx]\n\n    memo = {}\n    return max_product(nums, len(nums) - 1, memo)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    return [2, 3, -2, 4]\n\nassert f(g()) == 6\n", "emb": null, "idx_generation": 368, "target_skills": [0, 1, 0, 1, 0, 0, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of a subarray.\n\n    Example:\n    nums = [2, 3, -2, 4]\n\n    Output:\n    6 (since the maximum product is 2 * 3 = 6)\n    \"\"\"\n\n    def max_product(nums: List[int], idx: int, memo: Dict[int, int]) -> int:\n        if idx in memo:\n            return memo[idx]\n        if idx < 0:\n            return 1\n\n        max_product_1 = max_product(nums, idx - 1, memo) * nums[idx]\n        max_product_2 = max_product(nums, idx - 1, memo)\n\n        memo[idx] = max(max_product_1, max_product_2)\n        return memo[idx]\n\n    memo = {}\n    return max_product(nums, len(nums) - 1, memo)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    return [2, 3, -2, 4]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of distinct integers and a target value, return the index if the target is found.\n    If not, return the index where it would be if it were inserted in order.\n\n    Args:\n    - nums: A list of integers in ascending order.\n    - target: The target value.\n\n    Returns:\n    - The index of the target value in the list, or the index where it would be if inserted.\n\n    Example:\n    f([1, 3, 5, 6], 5) returns 2\n    f([1, 3, 5, 6], 2) returns 1\n    f([1, 3, 5, 6], 7) returns 4\n    f([1, 3, 5, 6], 0) returns 0\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left\n\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted array of distinct integers and a target value.\n\n    Returns:\n    - The generated array and target value.\n\n    Example:\n    g() returns ([1, 3, 5, 6], 5)\n    \"\"\"\n\n    return [1, 3, 5, 6], 5\n\nassert f(*g()) == 2\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 368, "target_skills": [0, 1, 1, 0, 1, 0, 1, 0, 1, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of distinct integers and a target value, return the index if the target is found.\n    If not, return the index where it would be if it were inserted in order.\n\n    Args:\n    - nums: A list of integers in ascending order.\n    - target: The target value.\n\n    Returns:\n    - The index of the target value in the list, or the index where it would be if inserted.\n\n    Example:\n    f([1, 3, 5, 6], 5) returns 2\n    f([1, 3, 5, 6], 2) returns 1\n    f([1, 3, 5, 6], 7) returns 4\n    f([1, 3, 5, 6], 0) returns 0\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted array of distinct integers and a target value.\n\n    Returns:\n    - The generated array and target value.\n\n    Example:\n    g() returns ([1, 3, 5, 6], 5)\n    \"\"\"\n\n    return [1, 3, 5, 6], 5", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef f(root: TreeNode) -> bool:\n    \"\"\"\n    Given the root of a binary tree, determine if it is a valid binary search tree (BST).\n    A valid BST is defined as follows:\n    - The left subtree of a node contains only nodes with keys less than the node's key.\n    - The right subtree of a node contains only nodes with keys greater than the node's key.\n    - Both the left and right subtrees must also be binary search trees.\n\n    Args:\n    - root: The root of the binary tree.\n\n    Returns:\n    - True if the binary tree is a valid BST, False otherwise.\n\n    Example:\n    f(TreeNode(2, TreeNode(1), TreeNode(3))) returns True\n    f(TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6)))) returns False\n    \"\"\"\n\n    def is_valid_bst(node, min_val, max_val):\n        if not node:\n            return True\n\n        if node.val <= min_val or node.val >= max_val:\n            return False\n\n        return is_valid_bst(node.left, min_val, node.val) and is_valid_bst(node.right, node.val, max_val)\n\n    return is_valid_bst(root, float('-inf'), float('inf'))\n\n\ndef g() -> TreeNode:\n    \"\"\"\n    Generate a binary tree.\n\n    Returns:\n    - The generated binary tree.\n\n    Example:\n    g() returns TreeNode(2, TreeNode(1), TreeNode(3))\n    \"\"\"\n\n    return TreeNode(2, TreeNode(1), TreeNode(3))\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 368, "target_skills": [0, 1, 1, 1, 0, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef f(root: TreeNode) -> bool:\n    \"\"\"\n    Given the root of a binary tree, determine if it is a valid binary search tree (BST).\n    A valid BST is defined as follows:\n    - The left subtree of a node contains only nodes with keys less than the node's key.\n    - The right subtree of a node contains only nodes with keys greater than the node's key.\n    - Both the left and right subtrees must also be binary search trees.\n\n    Args:\n    - root: The root of the binary tree.\n\n    Returns:\n    - True if the binary tree is a valid BST, False otherwise.\n\n    Example:\n    f(TreeNode(2, TreeNode(1), TreeNode(3))) returns True\n    f(TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6)))) returns False\n    \"\"\"\n\n    def is_valid_bst(node, min_val, max_val):\n        if not node:\n            return True\n\n        if node.val <= min_val or node.val >= max_val:\n            return False\n\n        return is_valid_bst(node.left, min_val, node.val) and is_valid_bst(node.right, node.val, max_val)\n\n    return is_valid_bst(root, float('-inf'), float('inf'))", "solution_func": "def g() -> TreeNode:\n    \"\"\"\n    Generate a binary tree.\n\n    Returns:\n    - The generated binary tree.\n\n    Example:\n    g() returns TreeNode(2, TreeNode(1), TreeNode(3))\n    \"\"\"\n\n    return TreeNode(2, TreeNode(1), TreeNode(3))", "map_ix": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the maximum sum of a subgrid with the constraints:\n    - The subgrid must be non-empty.\n    - The subgrid must be a rectangle.\n    - The sum of all the elements in the subgrid must be positive.\n\n    Args:\n    - grid: A 2D list of integers representing the grid.\n\n    Returns:\n    - The maximum sum of a subgrid.\n\n    Example:\n    f([[1, 2, -3],\n       [-4, 5, -6],\n       [7, -8, 9]])\n\n    Output:\n    11\n\n    Explanation:\n    The maximum sum subgrid is [[5, -6], [-8, 9]], with a sum of 11.\n    \"\"\"\n\n    n = len(grid)\n    m = len(grid[0])\n\n    max_sum = float('-inf')\n\n    for i in range(n):\n        for j in range(m):\n            for k in range(i, n):\n                for l in range(j, m):\n                    subgrid_sum = 0\n                    for x in range(i, k+1):\n                        for y in range(j, l+1):\n                            subgrid_sum += grid[x][y]\n                    if subgrid_sum > max_sum:\n                        max_sum = subgrid_sum\n\n    return max_sum\n\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid.\n\n    Returns:\n    - The generated grid.\n\n    Example:\n    g() returns [[1, 2, -3],\n                 [-4, 5, -6],\n                 [7, -8, 9]]\n    \"\"\"\n\n    return [[1, 2, -3],\n            [-4, 5, -6],\n            [7, -8, 9]]\n\nassert f(g()) == 11\n", "emb": null, "idx_generation": 368, "target_skills": [1, 0, 0, 0, 1, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the maximum sum of a subgrid with the constraints:\n    - The subgrid must be non-empty.\n    - The subgrid must be a rectangle.\n    - The sum of all the elements in the subgrid must be positive.\n\n    Args:\n    - grid: A 2D list of integers representing the grid.\n\n    Returns:\n    - The maximum sum of a subgrid.\n\n    Example:\n    f([[1, 2, -3],\n       [-4, 5, -6],\n       [7, -8, 9]])\n\n    Output:\n    11\n\n    Explanation:\n    The maximum sum subgrid is [[5, -6], [-8, 9]], with a sum of 11.\n    \"\"\"\n\n    n = len(grid)\n    m = len(grid[0])\n\n    max_sum = float('-inf')\n\n    for i in range(n):\n        for j in range(m):\n            for k in range(i, n):\n                for l in range(j, m):\n                    subgrid_sum = 0\n                    for x in range(i, k+1):\n                        for y in range(j, l+1):\n                            subgrid_sum += grid[x][y]\n                    if subgrid_sum > max_sum:\n                        max_sum = subgrid_sum\n\n    return max_sum", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid.\n\n    Returns:\n    - The generated grid.\n\n    Example:\n    g() returns [[1, 2, -3],\n                 [-4, 5, -6],\n                 [7, -8, 9]]\n    \"\"\"\n\n    return [[1, 2, -3],\n            [-4, 5, -6],\n            [7, -8, 9]]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the number of subarrays that have a sum equal to the target.\n    Return the count of such subarrays.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    Output:\n    2\n\n    Explanation:\n    The subarrays with a sum equal to 7 are [1, 2, 4] and [3, 4].\n    \"\"\"\n\n    count = 0\n    prefix_sum = 0\n    prefix_sum_count = {0: 1}\n\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum - target in prefix_sum_count:\n            count += prefix_sum_count[prefix_sum - target]\n        prefix_sum_count[prefix_sum] = prefix_sum_count.get(prefix_sum, 0) + 1\n\n    return count\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 2\n", "emb": null, "idx_generation": 368, "target_skills": [0, 1, 1, 0, 0, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the number of subarrays that have a sum equal to the target.\n    Return the count of such subarrays.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    Output:\n    2\n\n    Explanation:\n    The subarrays with a sum equal to 7 are [1, 2, 4] and [3, 4].\n    \"\"\"\n\n    count = 0\n    prefix_sum = 0\n    prefix_sum_count = {0: 1}\n\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum - target in prefix_sum_count:\n            count += prefix_sum_count[prefix_sum - target]\n        prefix_sum_count[prefix_sum] = prefix_sum_count.get(prefix_sum, 0) + 1\n\n    return count", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of pairs (i, j) such that i < j and nums[i] > 2*nums[j].\n\n    Example:\n    nums = [1, 3, 2, 4]\n\n    Output:\n    2\n\n    Explanation:\n    The pairs (1, 0) and (3, 2) satisfy the condition.\n\n    Hint: Use sorting and binary search to find the count of valid pairs.\n    \"\"\"\n\n    def binary_search(arr: List[int], target: int) -> int:\n        left = 0\n        right = len(arr) - 1\n        result = -1\n\n        while left <= right:\n            mid = (left + right) // 2\n\n            if arr[mid] > target:\n                result = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return result\n\n    nums.sort()\n    count = 0\n\n    for i in range(len(nums)):\n        count += i - binary_search(nums, 2 * nums[i]) - 1\n\n    return count\n\ndef g(nums=[1, 3, 2, 4]):\n    return nums\n\nassert f(g()) == 2\n", "emb": null, "idx_generation": 369, "target_skills": [1, 1, 1, 1, 0, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of pairs (i, j) such that i < j and nums[i] > 2*nums[j].\n\n    Example:\n    nums = [1, 3, 2, 4]\n\n    Output:\n    2\n\n    Explanation:\n    The pairs (1, 0) and (3, 2) satisfy the condition.\n\n    Hint: Use sorting and binary search to find the count of valid pairs.\n    \"\"\"\n\n    def binary_search(arr: List[int], target: int) -> int:\n        left = 0\n        right = len(arr) - 1\n        result = -1\n\n        while left <= right:\n            mid = (left + right) // 2\n\n            if arr[mid] > target:\n                result = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return result\n\n    nums.sort()\n    count = 0\n\n    for i in range(len(nums)):\n        count += i - binary_search(nums, 2 * nums[i]) - 1\n\n    return count", "solution_func": "def g(nums=[1, 3, 2, 4]):\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(adj_list: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency list representation of a directed graph, determine if there is a cycle in the graph.\n\n    Example:\n    adj_list = [[1], [2], [3], [0]]\n\n    Output:\n    True\n\n    Explanation:\n    The graph has a cycle: 0 -> 1 -> 2 -> 3 -> 0\n\n    Hint: Use depth-first search (DFS) to detect cycles in a graph.\n    \"\"\"\n\n    def dfs(node: int, visited: List[bool], recursion_stack: List[bool]) -> bool:\n        visited[node] = True\n        recursion_stack[node] = True\n\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, recursion_stack):\n                    return True\n            elif recursion_stack[neighbor]:\n                return True\n\n        recursion_stack[node] = False\n        return False\n\n    num_nodes = len(adj_list)\n    visited = [False] * num_nodes\n    recursion_stack = [False] * num_nodes\n\n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(node, visited, recursion_stack):\n                return True\n\n    return False\n\ndef g(adj_list=[[1], [2], [3], [0]]):\n    return adj_list\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 369, "target_skills": [0, 1, 1, 1, 1, 1, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(adj_list: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency list representation of a directed graph, determine if there is a cycle in the graph.\n\n    Example:\n    adj_list = [[1], [2], [3], [0]]\n\n    Output:\n    True\n\n    Explanation:\n    The graph has a cycle: 0 -> 1 -> 2 -> 3 -> 0\n\n    Hint: Use depth-first search (DFS) to detect cycles in a graph.\n    \"\"\"\n\n    def dfs(node: int, visited: List[bool], recursion_stack: List[bool]) -> bool:\n        visited[node] = True\n        recursion_stack[node] = True\n\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, recursion_stack):\n                    return True\n            elif recursion_stack[neighbor]:\n                return True\n\n        recursion_stack[node] = False\n        return False\n\n    num_nodes = len(adj_list)\n    visited = [False] * num_nodes\n    recursion_stack = [False] * num_nodes\n\n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(node, visited, recursion_stack):\n                return True\n\n    return False", "solution_func": "def g(adj_list=[[1], [2], [3], [0]]):\n    return adj_list", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, rounds: List[List[int]]) -> int:\n    \"\"\"\n    Given the number of players n and the rounds of a tournament, return the winner of the tournament.\n\n    Each round is represented by a list of two players [winner, loser]. The winner of each round advances to the next round.\n\n    Example:\n    n = 4\n    rounds = [[0, 1], [2, 3], [1, 2]]\n\n    Output:\n    1\n\n    Explanation:\n    The winner of the first round is player 1. The winner of the second round is player 2. The winner of the final round is player 1.\n\n    Hint: Use a stack or queue to simulate the tournament rounds.\n    \"\"\"\n\n    def simulate_tournament(num_players: int, tournament_rounds: List[List[int]]) -> int:\n        stack = list(range(num_players))\n\n        for winner, loser in tournament_rounds:\n            if winner in stack:\n                stack.remove(winner)\n            if loser in stack:\n                stack.remove(loser)\n\n        return stack[0]\n\n    return simulate_tournament(n, rounds)\n\ndef g(n=4, rounds=[[0, 1], [2, 3], [1, 2]]):\n    return n, rounds\n\nassert f(*g()) == 1\n", "emb": null, "idx_generation": 369, "target_skills": [0, 0, 1, 1, 0, 0, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, rounds: List[List[int]]) -> int:\n    \"\"\"\n    Given the number of players n and the rounds of a tournament, return the winner of the tournament.\n\n    Each round is represented by a list of two players [winner, loser]. The winner of each round advances to the next round.\n\n    Example:\n    n = 4\n    rounds = [[0, 1], [2, 3], [1, 2]]\n\n    Output:\n    1\n\n    Explanation:\n    The winner of the first round is player 1. The winner of the second round is player 2. The winner of the final round is player 1.\n\n    Hint: Use a stack or queue to simulate the tournament rounds.\n    \"\"\"\n\n    def simulate_tournament(num_players: int, tournament_rounds: List[List[int]]) -> int:\n        stack = list(range(num_players))\n\n        for winner, loser in tournament_rounds:\n            if winner in stack:\n                stack.remove(winner)\n            if loser in stack:\n                stack.remove(loser)\n\n        return stack[0]\n\n    return simulate_tournament(n, rounds)", "solution_func": "def g(n=4, rounds=[[0, 1], [2, 3], [1, 2]]):\n    return n, rounds", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the shortest path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    The shortest path is 1 -> 3 -> 1 -> 1 -> 1, which has a sum of 7.\n\n    Constraints:\n    - The grid will have at least one row and one column.\n    - Each element in the grid will be a non-negative integer.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 369, "target_skills": [1, 0, 1, 1, 1, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the shortest path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    The shortest path is 1 -> 3 -> 1 -> 1 -> 1, which has a sum of 7.\n\n    Constraints:\n    - The grid will have at least one row and one column.\n    - Each element in the grid will be a non-negative integer.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]", "solution_func": "def g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n    The longest substring without repeating characters is \"abc\", which has a length of 3.\n\n    Constraints:\n    - The input string s will consist of lowercase English letters only.\n    \"\"\"\n    start = 0\n    max_length = 0\n    char_map = {}\n    \n    for i in range(len(s)):\n        if s[i] in char_map and start <= char_map[s[i]]:\n            start = char_map[s[i]] + 1\n        else:\n            max_length = max(max_length, i - start + 1)\n        \n        char_map[s[i]] = i\n    \n    return max_length\n\ndef g():\n    s = \"abcabcbb\"\n    return s\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 369, "target_skills": [0, 1, 1, 0, 0, 1, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n    The longest substring without repeating characters is \"abc\", which has a length of 3.\n\n    Constraints:\n    - The input string s will consist of lowercase English letters only.\n    \"\"\"\n    start = 0\n    max_length = 0\n    char_map = {}\n    \n    for i in range(len(s)):\n        if s[i] in char_map and start <= char_map[s[i]]:\n            start = char_map[s[i]] + 1\n        else:\n            max_length = max(max_length, i - start + 1)\n        \n        char_map[s[i]] = i\n    \n    return max_length", "solution_func": "def g():\n    s = \"abcabcbb\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(prices: List[int]) -> int:\n    \"\"\"\n    Given a list of stock prices, find the maximum profit that can be obtained by buying and selling the stock.\n    You can only perform one transaction (i.e., buy one and sell one share of the stock).\n\n    Example:\n    prices = [7, 1, 5, 3, 6, 4]\n    The maximum profit that can be obtained is 5 (buy at 1 and sell at 6).\n\n    Constraints:\n    - The input list prices will have at least one element.\n    - Each element in the list prices will be a non-negative integer.\n    \"\"\"\n    max_profit = 0\n    min_price = float('inf')\n    \n    for price in prices:\n        min_price = min(min_price, price)\n        max_profit = max(max_profit, price - min_price)\n    \n    return max_profit\n\ndef g():\n    prices = [7, 1, 5, 3, 6, 4]\n    return prices\n\nassert f(g()) == 5\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 369, "target_skills": [0, 0, 0, 1, 1, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(prices: List[int]) -> int:\n    \"\"\"\n    Given a list of stock prices, find the maximum profit that can be obtained by buying and selling the stock.\n    You can only perform one transaction (i.e., buy one and sell one share of the stock).\n\n    Example:\n    prices = [7, 1, 5, 3, 6, 4]\n    The maximum profit that can be obtained is 5 (buy at 1 and sell at 6).\n\n    Constraints:\n    - The input list prices will have at least one element.\n    - Each element in the list prices will be a non-negative integer.\n    \"\"\"\n    max_profit = 0\n    min_price = float('inf')\n    \n    for price in prices:\n        min_price = min(min_price, price)\n        max_profit = max(max_profit, price - min_price)\n    \n    return max_profit", "solution_func": "def g():\n    prices = [7, 1, 5, 3, 6, 4]\n    return prices", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum product of any two distinct numbers in the list.\n    \n    Example:\n    nums = [1, 2, 3, 4, 5]\n    \n    Output:\n    20\n    \n    Explanation:\n    The maximum product can be achieved by multiplying 4 and 5, which gives 20.\n    \"\"\"\n    n = len(nums)\n    max_product = float('-inf')\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n    \n    return max_product\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5]):\n    return nums\n\nassert f(*g()) == 20\n\n", "emb": null, "idx_generation": 369, "target_skills": [0, 1, 0, 1, 0, 1, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum product of any two distinct numbers in the list.\n    \n    Example:\n    nums = [1, 2, 3, 4, 5]\n    \n    Output:\n    20\n    \n    Explanation:\n    The maximum product can be achieved by multiplying 4 and 5, which gives 20.\n    \"\"\"\n    n = len(nums)\n    max_product = float('-inf')\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n    \n    return max_product", "solution_func": "def g(nums: List[int] = [1, 2, 3, 4, 5]):\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum sum of any contiguous subarray within the list.\n    \n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    \n    Output:\n    6\n    \n    Explanation:\n    The maximum sum can be achieved by selecting the subarray [4, -1, 2, 1], which gives a sum of 6.\n    \"\"\"\n    n = len(nums)\n    max_sum = float('-inf')\n    \n    for i in range(n):\n        curr_sum = 0\n        for j in range(i, n):\n            curr_sum += nums[j]\n            max_sum = max(max_sum, curr_sum)\n    \n    return max_sum\n\ndef g(nums: List[int] = [-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\n\nassert f(*g()) == 6\n\n", "emb": null, "idx_generation": 369, "target_skills": [1, 0, 1, 1, 1, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum sum of any contiguous subarray within the list.\n    \n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    \n    Output:\n    6\n    \n    Explanation:\n    The maximum sum can be achieved by selecting the subarray [4, -1, 2, 1], which gives a sum of 6.\n    \"\"\"\n    n = len(nums)\n    max_sum = float('-inf')\n    \n    for i in range(n):\n        curr_sum = 0\n        for j in range(i, n):\n            curr_sum += nums[j]\n            max_sum = max(max_sum, curr_sum)\n    \n    return max_sum", "solution_func": "def g(nums: List[int] = [-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers 'nums' and an integer 'k', find the kth smallest element in the list.\n    \n    Example:\n    nums = [3, 7, 1, 4, 2, 8, 5]\n    k = 3\n    \n    Output:\n    3\n    \n    Explanation:\n    After sorting the list in ascending order, the third smallest element is 3.\n    \"\"\"\n    nums.sort()\n    return nums[k-1]\n\ndef g(nums: List[int] = [3, 7, 1, 4, 2, 8, 5], k: int = 3):\n    return nums, k\n\nassert f(*g()) == 3\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 369, "target_skills": [1, 0, 0, 1, 1, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers 'nums' and an integer 'k', find the kth smallest element in the list.\n    \n    Example:\n    nums = [3, 7, 1, 4, 2, 8, 5]\n    k = 3\n    \n    Output:\n    3\n    \n    Explanation:\n    After sorting the list in ascending order, the third smallest element is 3.\n    \"\"\"\n    nums.sort()\n    return nums[k-1]", "solution_func": "def g(nums: List[int] = [3, 7, 1, 4, 2, 8, 5], k: int = 3):\n    return nums, k", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and a target integer k, find all pairs that add up to k.\n\n    Args:\n    - nums: List of integers.\n    - k: Target integer.\n\n    Returns:\n    - List of pairs that add up to k.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    k = 6\n\n    Output:\n    [(1, 5), (2, 4)]\n    \"\"\"\n\n    pairs = []\n    complement_dict = {}\n\n    for num in nums:\n        complement = k - num\n\n        if num in complement_dict:\n            pairs.append((num, complement_dict[num]))\n        else:\n            complement_dict[complement] = num\n\n    return pairs\n\ndef g():\n    return ([1, 2, 3, 4, 5], 6)\n\nassert f(*g()) == [(1, 5), (2, 4)]\n\n", "emb": null, "idx_generation": 369, "target_skills": [0, 1, 1, 0, 1, 1, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and a target integer k, find all pairs that add up to k.\n\n    Args:\n    - nums: List of integers.\n    - k: Target integer.\n\n    Returns:\n    - List of pairs that add up to k.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    k = 6\n\n    Output:\n    [(1, 5), (2, 4)]\n    \"\"\"\n\n    pairs = []\n    complement_dict = {}\n\n    for num in nums:\n        complement = k - num\n\n        if num in complement_dict:\n            pairs.append((num, complement_dict[num]))\n        else:\n            complement_dict[complement] = num\n\n    return pairs", "solution_func": "def g():\n    return ([1, 2, 3, 4, 5], 6)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, count the number of ways to\n    obtain the target number by adding or subtracting the numbers in the list.\n    Return the count of possible ways.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    target = 5\n\n    Output:\n    3\n\n    Explanation:\n    There are 3 ways to obtain the target number 5:\n    1 + 2 + 3 - 4 = 5\n    1 + 2 - 3 + 4 = 5\n    -1 - 2 + 3 + 4 = 5\n    \"\"\"\n\n    def backtrack(index, current_sum):\n        if index == len(nums):\n            if current_sum == target:\n                return 1\n            else:\n                return 0\n        positive_ways = backtrack(index + 1, current_sum + nums[index])\n        negative_ways = backtrack(index + 1, current_sum - nums[index])\n        return positive_ways + negative_ways\n\n    return backtrack(0, 0)\n\ndef g():\n    nums = [1, 2, 3, 4]\n    target = 5\n    return nums, target\n\nassert f(*g()) == 3\n", "emb": null, "idx_generation": 370, "target_skills": [0, 1, 0, 1, 0, 1, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, count the number of ways to\n    obtain the target number by adding or subtracting the numbers in the list.\n    Return the count of possible ways.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    target = 5\n\n    Output:\n    3\n\n    Explanation:\n    There are 3 ways to obtain the target number 5:\n    1 + 2 + 3 - 4 = 5\n    1 + 2 - 3 + 4 = 5\n    -1 - 2 + 3 + 4 = 5\n    \"\"\"\n\n    def backtrack(index, current_sum):\n        if index == len(nums):\n            if current_sum == target:\n                return 1\n            else:\n                return 0\n        positive_ways = backtrack(index + 1, current_sum + nums[index])\n        negative_ways = backtrack(index + 1, current_sum - nums[index])\n        return positive_ways + negative_ways\n\n    return backtrack(0, 0)", "solution_func": "def g():\n    nums = [1, 2, 3, 4]\n    target = 5\n    return nums, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct\n    numbers in the list. Return the maximum product.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    20\n\n    Explanation:\n    The maximum product is 4 * 5 = 20.\n    \"\"\"\n\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n    return max_product\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 20\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 370, "target_skills": [0, 0, 0, 1, 0, 1, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct\n    numbers in the list. Return the maximum product.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    20\n\n    Explanation:\n    The maximum product is 4 * 5 = 20.\n    \"\"\"\n\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n    return max_product", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target number, find all combinations of numbers\n    in the list that add up to the target number. Each number can be used multiple times.\n    Return a list of all possible combinations.\n\n    Example:\n    nums = [2, 3, 6, 7]\n    target = 7\n\n    Output:\n    [[2, 2, 3], [7]]\n\n    Explanation:\n    There are 2 combinations that add up to the target number 7:\n    - 2 + 2 + 3 = 7\n    - 7 = 7\n    \"\"\"\n\n    def backtrack(current_combination, remaining):\n        if remaining == 0:\n            combinations.append(current_combination[:])\n            return\n        if remaining < 0:\n            return\n        for i in range(len(nums)):\n            current_combination.append(nums[i])\n            backtrack(current_combination, remaining - nums[i])\n            current_combination.pop()\n\n    combinations = []\n    backtrack([], target)\n    return combinations\n\ndef g():\n    nums = [2, 3, 6, 7]\n    target = 7\n    return nums, target\n\nassert f(*g()) == [[2, 2, 3], [7]]\n", "emb": null, "idx_generation": 370, "target_skills": [1, 0, 0, 1, 0, 1, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target number, find all combinations of numbers\n    in the list that add up to the target number. Each number can be used multiple times.\n    Return a list of all possible combinations.\n\n    Example:\n    nums = [2, 3, 6, 7]\n    target = 7\n\n    Output:\n    [[2, 2, 3], [7]]\n\n    Explanation:\n    There are 2 combinations that add up to the target number 7:\n    - 2 + 2 + 3 = 7\n    - 7 = 7\n    \"\"\"\n\n    def backtrack(current_combination, remaining):\n        if remaining == 0:\n            combinations.append(current_combination[:])\n            return\n        if remaining < 0:\n            return\n        for i in range(len(nums)):\n            current_combination.append(nums[i])\n            backtrack(current_combination, remaining - nums[i])\n            current_combination.pop()\n\n    combinations = []\n    backtrack([], target)\n    return combinations", "solution_func": "def g():\n    nums = [2, 3, 6, 7]\n    target = 7\n    return nums, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(expression: str) -> bool:\n    \"\"\"\n    Check if a given arithmetic expression is balanced or not. \n    The expression is considered balanced if every opening parenthesis has a corresponding closing parenthesis and they are properly nested.\n    \"\"\"\n    stack = []\n    opening = '({['\n    closing = ')}]'\n    for char in expression:\n        if char in opening:\n            stack.append(char)\n        elif char in closing:\n            if not stack:\n                return False\n            if closing.index(char) != opening.index(stack.pop()):\n                return False\n    return len(stack) == 0\n\ndef g(expression: str) -> str:\n    \"\"\"\n    Return the arithmetic expression to check if it is balanced or not.\n    \"\"\"\n    return expression\n\nassert f(g(\"3 + 5 * (2 - 4)\")) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 370, "target_skills": [1, 0, 0, 0, 0, 0, 1, 1, 1, 1], "problem_func": "from typing import*\ndef f(expression: str) -> bool:\n    \"\"\"\n    Check if a given arithmetic expression is balanced or not. \n    The expression is considered balanced if every opening parenthesis has a corresponding closing parenthesis and they are properly nested.\n    \"\"\"\n    stack = []\n    opening = '({['\n    closing = ')}]'\n    for char in expression:\n        if char in opening:\n            stack.append(char)\n        elif char in closing:\n            if not stack:\n                return False\n            if closing.index(char) != opening.index(stack.pop()):\n                return False\n    return len(stack) == 0", "solution_func": "def g(expression: str) -> str:\n    \"\"\"\n    Return the arithmetic expression to check if it is balanced or not.\n    \"\"\"\n    return expression", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Find the maximum sum of a subarray in a given array that is less than or equal to the target value.\n    \"\"\"\n    def dp(nums, target):\n        if target <= 0:\n            return 0\n        if not nums:\n            return float('-inf')\n        if nums[0] > target:\n            return dp(nums[1:], target)\n        return max(nums[0] + dp(nums[1:], target - nums[0]), dp(nums[1:], target))\n    \n    return dp(nums, target)\n\ndef g(nums: List[int], target: int) -> Tuple[List[int], int]:\n    \"\"\"\n    Return the array and target value to find the maximum sum of a subarray.\n    \"\"\"\n    return nums, target\n\nassert f(*g([1, 2, 3, 4, 5], 9)) == 9\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 370, "target_skills": [0, 1, 0, 0, 1, 1, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Find the maximum sum of a subarray in a given array that is less than or equal to the target value.\n    \"\"\"\n    def dp(nums, target):\n        if target <= 0:\n            return 0\n        if not nums:\n            return float('-inf')\n        if nums[0] > target:\n            return dp(nums[1:], target)\n        return max(nums[0] + dp(nums[1:], target - nums[0]), dp(nums[1:], target))\n    \n    return dp(nums, target)", "solution_func": "def g(nums: List[int], target: int) -> Tuple[List[int], int]:\n    \"\"\"\n    Return the array and target value to find the maximum sum of a subarray.\n    \"\"\"\n    return nums, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Reverse the order of words in a given string.\n    \"\"\"\n    words = s.split()\n    return ' '.join(words[::-1])\n\ndef g(s: str) -> str:\n    \"\"\"\n    Return the string to reverse the order of words.\n    \"\"\"\n    return s\n\nassert f(g(\"Hello World\")) == \"World Hello\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 370, "target_skills": [1, 1, 0, 0, 0, 1, 1, 0, 1, 1], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Reverse the order of words in a given string.\n    \"\"\"\n    words = s.split()\n    return ' '.join(words[::-1])", "solution_func": "def g(s: str) -> str:\n    \"\"\"\n    Return the string to reverse the order of words.\n    \"\"\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, check if there exists two numbers in the list that add up to the target.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        total = nums[left] + nums[right]\n        if total == target:\n            return True\n        elif total < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums: List[int], target: int):\n    nums.sort()\n    return nums, target\n\nassert f(*g())\n", "emb": null, "idx_generation": 370, "target_skills": [0, 1, 1, 0, 0, 0, 1, 1, 1, 1], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, check if there exists two numbers in the list that add up to the target.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        total = nums[left] + nums[right]\n        if total == target:\n            return True\n        elif total < target:\n            left += 1\n        else:\n            right -= 1\n    return False", "solution_func": "def g(nums: List[int], target: int):\n    nums.sort()\n    return nums, target", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a 2D matrix of integers sorted in both rows and columns, check if a target number exists in the matrix.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    row = 0\n    col = cols - 1\n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n    return False\n\ndef g(matrix: List[List[int]], target: int):\n    return matrix, target\n\nassert f(*g())\n", "emb": null, "idx_generation": 370, "target_skills": [0, 1, 1, 0, 0, 0, 0, 1, 1, 1], "problem_func": "from typing import*\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a 2D matrix of integers sorted in both rows and columns, check if a target number exists in the matrix.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    row = 0\n    col = cols - 1\n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n    return False", "solution_func": "def g(matrix: List[List[int]], target: int):\n    return matrix, target", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, check if t is an anagram of s.\n    \"\"\"\n    s_chars = {}\n    t_chars = {}\n    for char in s:\n        s_chars[char] = s_chars.get(char, 0) + 1\n    for char in t:\n        t_chars[char] = t_chars.get(char, 0) + 1\n    return s_chars == t_chars\n\ndef g(s: str, t: str):\n    return s, t\n\nassert f(*g())\n", "emb": null, "idx_generation": 370, "target_skills": [0, 0, 1, 0, 0, 0, 1, 0, 0, 1], "problem_func": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, check if t is an anagram of s.\n    \"\"\"\n    s_chars = {}\n    t_chars = {}\n    for char in s:\n        s_chars[char] = s_chars.get(char, 0) + 1\n    for char in t:\n        t_chars[char] = t_chars.get(char, 0) + 1\n    return s_chars == t_chars", "solution_func": "def g(s: str, t: str):\n    return s, t", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there exists two numbers in the list such that their sum is equal to a given target.\n    Return True if such pair exists, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        \n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    nums = [-2, 1, 3, 5, 7, 9]\n    target = 10\n    return nums, target\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 370, "target_skills": [0, 1, 0, 0, 0, 0, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there exists two numbers in the list such that their sum is equal to a given target.\n    Return True if such pair exists, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        \n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False", "solution_func": "def g():\n    nums = [-2, 1, 3, 5, 7, 9]\n    target = 10\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers and a target value, find two numbers in the array that add up to the target value.\n    Return the indices of the two numbers.\n\n    Example:\n    arr = [2, 4, 6, 8, 10]\n    target = 12\n\n    Output:\n    [1, 3]\n\n    Explanation:\n    The numbers at indices 1 and 3 (4 and 8) add up to the target value of 12.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g():\n    arr = [2, 4, 6, 8, 10]\n    target = 12\n    return arr, target\n\nassert f(*g()) == [1, 3]\n", "emb": null, "idx_generation": 371, "target_skills": [1, 1, 1, 0, 0, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers and a target value, find two numbers in the array that add up to the target value.\n    Return the indices of the two numbers.\n\n    Example:\n    arr = [2, 4, 6, 8, 10]\n    target = 12\n\n    Output:\n    [1, 3]\n\n    Explanation:\n    The numbers at indices 1 and 3 (4 and 8) add up to the target value of 12.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g():\n    arr = [2, 4, 6, 8, 10]\n    target = 12\n    return arr, target", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters representing a treasure map, determine the minimum number of steps needed to find the treasure.\n    You can only move up, down, left, or right, and you cannot move onto obstacles represented by '#'.\n\n    Example:\n    grid = [\n        ['#', '#', '#', '#', '#'],\n        ['#', '.', '.', '.', '#'],\n        ['#', '.', '#', '.', '#'],\n        ['#', '.', '.', '.', '#'],\n        ['#', '#', '#', '#', '#']\n    ]\n\n    Output:\n    8\n\n    Explanation:\n    The treasure is represented by '.' and the minimum number of steps needed to find it is 8.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    start_row = 0\n    start_col = 0\n\n    end_row = 0\n    end_col = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == '.':\n                end_row = i\n                end_col = j\n\n    queue = [(start_row, start_col, 0)]\n    visited = set([(start_row, start_col)])\n\n    while queue:\n        curr_row, curr_col, steps = queue.pop(0)\n\n        if curr_row == end_row and curr_col == end_col:\n            return steps\n\n        neighbors = [(curr_row - 1, curr_col), (curr_row + 1, curr_col), (curr_row, curr_col - 1), (curr_row, curr_col + 1)]\n\n        for neighbor_row, neighbor_col in neighbors:\n            if 0 <= neighbor_row < rows and 0 <= neighbor_col < cols and (neighbor_row, neighbor_col) not in visited and grid[neighbor_row][neighbor_col] != '#':\n                queue.append((neighbor_row, neighbor_col, steps + 1))\n                visited.add((neighbor_row, neighbor_col))\n\n    return -1\n\ndef g():\n    grid = [\n        ['#', '#', '#', '#', '#'],\n        ['#', '.', '.', '.', '#'],\n        ['#', '.', '#', '.', '#'],\n        ['#', '.', '.', '.', '#'],\n        ['#', '#', '#', '#', '#']\n    ]\n    return grid\n\nassert f(g()) == 8\n", "emb": null, "idx_generation": 371, "target_skills": [0, 0, 1, 0, 1, 0, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters representing a treasure map, determine the minimum number of steps needed to find the treasure.\n    You can only move up, down, left, or right, and you cannot move onto obstacles represented by '#'.\n\n    Example:\n    grid = [\n        ['#', '#', '#', '#', '#'],\n        ['#', '.', '.', '.', '#'],\n        ['#', '.', '#', '.', '#'],\n        ['#', '.', '.', '.', '#'],\n        ['#', '#', '#', '#', '#']\n    ]\n\n    Output:\n    8\n\n    Explanation:\n    The treasure is represented by '.' and the minimum number of steps needed to find it is 8.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    start_row = 0\n    start_col = 0\n\n    end_row = 0\n    end_col = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == '.':\n                end_row = i\n                end_col = j\n\n    queue = [(start_row, start_col, 0)]\n    visited = set([(start_row, start_col)])\n\n    while queue:\n        curr_row, curr_col, steps = queue.pop(0)\n\n        if curr_row == end_row and curr_col == end_col:\n            return steps\n\n        neighbors = [(curr_row - 1, curr_col), (curr_row + 1, curr_col), (curr_row, curr_col - 1), (curr_row, curr_col + 1)]\n\n        for neighbor_row, neighbor_col in neighbors:\n            if 0 <= neighbor_row < rows and 0 <= neighbor_col < cols and (neighbor_row, neighbor_col) not in visited and grid[neighbor_row][neighbor_col] != '#':\n                queue.append((neighbor_row, neighbor_col, steps + 1))\n                visited.add((neighbor_row, neighbor_col))\n\n    return -1", "solution_func": "def g():\n    grid = [\n        ['#', '#', '#', '#', '#'],\n        ['#', '.', '.', '.', '#'],\n        ['#', '.', '#', '.', '#'],\n        ['#', '.', '.', '.', '#'],\n        ['#', '#', '#', '#', '#']\n    ]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    20\n\n    Explanation:\n    The maximum product of any two numbers in the list is 4 * 5 = 20.\n    \"\"\"\n\n    max_product = float(\"-inf\")\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n\n    return max_product\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 20\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 371, "target_skills": [0, 0, 1, 0, 1, 0, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    20\n\n    Explanation:\n    The maximum product of any two numbers in the list is 4 * 5 = 20.\n    \"\"\"\n\n    max_product = float(\"-inf\")\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n\n    return max_product", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    Output:\n    4\n\n    Explanation:\n    The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[int]:\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 371, "target_skills": [0, 1, 1, 1, 1, 1, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    Output:\n    4\n\n    Explanation:\n    The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)", "solution_func": "def g() -> List[int]:\n    return [10, 9, 2, 5, 3, 7, 101, 18]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    You can return the answer in any order.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    nums[0] + nums[1] equals to 9, so the indices are 0 and 1.\n    \"\"\"\n\n    hashmap = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in hashmap:\n            return [hashmap[complement], i]\n        hashmap[num] = i\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [0, 1]\n\n", "emb": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "idx_generation": 371, "target_skills": [1, 1, 1, 0, 1, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    You can return the answer in any order.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    nums[0] + nums[1] equals to 9, so the indices are 0 and 1.\n    \"\"\"\n\n    hashmap = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in hashmap:\n            return [hashmap[complement], i]\n        hashmap[num] = i\n\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    return ([2, 7, 11, 15], 9)", "map_ix": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, find the length of the shortest path from the top-left corner to the bottom-right corner.\n    You can only move down or right in the grid.\n\n    Args:\n    - grid: A 2D list of 0s and 1s\n\n    Returns:\n    - The length of the shortest path\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n    return grid\n\nassert f(g()) == 7\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 371, "target_skills": [1, 1, 1, 0, 1, 0, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, find the length of the shortest path from the top-left corner to the bottom-right corner.\n    You can only move down or right in the grid.\n\n    Args:\n    - grid: A 2D list of 0s and 1s\n\n    Returns:\n    - The length of the shortest path\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g() -> List[List[int]]:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two numbers in the list.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The maximum product of any two numbers in the list.\n    \"\"\"\n    max_product = float('-inf')\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n\n    return max_product\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 20\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 371, "target_skills": [1, 1, 0, 1, 0, 1, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two numbers in the list.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The maximum product of any two numbers in the list.\n    \"\"\"\n    max_product = float('-inf')\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n\n    return max_product", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [1, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0's and 1's, find the shortest path from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1).\n    You can only move down or right at any point in time. The value 1 represents an obstacle that cannot be passed through.\n\n    Args:\n    - grid: A 2D grid of integers.\n\n    Returns:\n    - The length of the shortest path from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not grid or not grid[0]:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n\n    dp = [[float('inf') for _ in range(n)] for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(m):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j])\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j])\n\n    return dp[m-1][n-1]\n\ndef g():\n    grid = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [1, 0, 0, 0],\n        [0, 1, 1, 0]\n    ]\n    return grid\n\nassert f(g()) == 3\n\n", "emb": null, "idx_generation": 371, "target_skills": [1, 1, 1, 0, 0, 1, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0's and 1's, find the shortest path from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1).\n    You can only move down or right at any point in time. The value 1 represents an obstacle that cannot be passed through.\n\n    Args:\n    - grid: A 2D grid of integers.\n\n    Returns:\n    - The length of the shortest path from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not grid or not grid[0]:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n\n    dp = [[float('inf') for _ in range(n)] for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(m):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j])\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j])\n\n    return dp[m-1][n-1]", "solution_func": "def g():\n    grid = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [1, 0, 0, 0],\n        [0, 1, 1, 0]\n    ]\n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target integer, find the minimum number of operations required to make all numbers in the list equal to the target.\n    Each operation consists of adding or subtracting the same amount to all numbers in the list.\n\n    Args:\n    - nums: A list of integers.\n    - target: The target integer.\n\n    Returns:\n    - The minimum number of operations required to make all numbers in the list equal to the target.\n    \"\"\"\n    total_sum = sum(nums)\n    target_diff = abs(total_sum - target * len(nums))\n    return (target_diff + 1) // 2\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 10\n    return nums, target\n\nassert f(*g()) == 7\n\n", "emb": null, "idx_generation": 371, "target_skills": [1, 1, 0, 1, 0, 1, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target integer, find the minimum number of operations required to make all numbers in the list equal to the target.\n    Each operation consists of adding or subtracting the same amount to all numbers in the list.\n\n    Args:\n    - nums: A list of integers.\n    - target: The target integer.\n\n    Returns:\n    - The minimum number of operations required to make all numbers in the list equal to the target.\n    \"\"\"\n    total_sum = sum(nums)\n    target_diff = abs(total_sum - target * len(nums))\n    return (target_diff + 1) // 2", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    target = 10\n    return nums, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of ways to choose k items from a set of n items.\n    Return the count.\n\n    Example:\n    n = 5\n    k = 3\n\n    Output:\n    10\n    \"\"\"\n\n    def choose(n, k):\n        if k == 0 or k == n:\n            return 1\n        return choose(n-1, k-1) + choose(n-1, k)\n\n    return choose(n, k)\n\ndef g():\n    n = 5\n    k = 3\n    return n, k\n\nassert f(*g()) == 10\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 371, "target_skills": [1, 0, 0, 1, 1, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of ways to choose k items from a set of n items.\n    Return the count.\n\n    Example:\n    n = 5\n    k = 3\n\n    Output:\n    10\n    \"\"\"\n\n    def choose(n, k):\n        if k == 0 or k == n:\n            return 1\n        return choose(n-1, k-1) + choose(n-1, k)\n\n    return choose(n, k)", "solution_func": "def g():\n    n = 5\n    k = 3\n    return n, k", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix graph representation, determine if the graph contains a cycle.\n\n    Example:\n    Input: graph = [[0, 1, 0],\n                    [0, 0, 1],\n                    [1, 0, 0]]\n    Output: True\n\n    Explanation: The graph contains a cycle: 0 -> 1 -> 2 -> 0\n\n    Hint: Use depth-first search (DFS) to traverse the graph and detect cycles.\n    \"\"\"\n\n    def dfs(node, visited, stack):\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor]:\n                if not visited[neighbor]:\n                    if dfs(neighbor, visited, stack):\n                        return True\n                elif stack[neighbor]:\n                    return True\n\n        stack[node] = False\n        return False\n\n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n    stack = [False] * num_nodes\n\n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(node, visited, stack):\n                return True\n\n    return False\n\ndef g():\n    return [[0, 1, 0],\n            [0, 0, 1],\n            [1, 0, 0]]\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 372, "target_skills": [0, 0, 1, 0, 1, 1, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix graph representation, determine if the graph contains a cycle.\n\n    Example:\n    Input: graph = [[0, 1, 0],\n                    [0, 0, 1],\n                    [1, 0, 0]]\n    Output: True\n\n    Explanation: The graph contains a cycle: 0 -> 1 -> 2 -> 0\n\n    Hint: Use depth-first search (DFS) to traverse the graph and detect cycles.\n    \"\"\"\n\n    def dfs(node, visited, stack):\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor]:\n                if not visited[neighbor]:\n                    if dfs(neighbor, visited, stack):\n                        return True\n                elif stack[neighbor]:\n                    return True\n\n        stack[node] = False\n        return False\n\n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n    stack = [False] * num_nodes\n\n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(node, visited, stack):\n                return True\n\n    return False", "solution_func": "def g():\n    return [[0, 1, 0],\n            [0, 0, 1],\n            [1, 0, 0]]", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum you can obtain by starting at the top-left cell and moving only right or down to the bottom-right cell.\n\n    Example:\n    Input: grid = [[1, 3, 1],\n                    [1, 5, 1],\n                    [4, 2, 1]]\n    Output: 12\n\n    Explanation: The maximum sum path is 1 -> 3 -> 5 -> 2 -> 1, which gives a total sum of 12.\n\n    Hint: Use dynamic programming to store the maximum sum at each cell.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g():\n    return [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\nassert f(g()) == 12\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 372, "target_skills": [1, 1, 1, 0, 0, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum you can obtain by starting at the top-left cell and moving only right or down to the bottom-right cell.\n\n    Example:\n    Input: grid = [[1, 3, 1],\n                    [1, 5, 1],\n                    [4, 2, 1]]\n    Output: 12\n\n    Explanation: The maximum sum path is 1 -> 3 -> 5 -> 2 -> 1, which gives a total sum of 12.\n\n    Hint: Use dynamic programming to store the maximum sum at each cell.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]", "solution_func": "def g():\n    return [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]", "map_ix": [0, 0, 0, 1, 0, 0, 1, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return the longest word in the list that can be built one character at a time by other words in the list.\n\n    Example:\n    Input: words = [\"cat\", \"banana\", \"dog\", \"nana\", \"walk\", \"walker\", \"dogwalker\"]\n    Output: \"dogwalker\"\n\n    Explanation: \"dogwalker\" can be built by combining \"dog\" and \"walker\", both of which are in the list.\n\n    Hint: Use a trie data structure to efficiently store and search for words.\n    \"\"\"\n\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.is_word = False\n\n    def insert_word(word, root):\n        node = root\n\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n\n        node.is_word = True\n\n    def search_word(word, root):\n        node = root\n\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n\n        return node.is_word\n\n    root = TrieNode()\n\n    for word in words:\n        insert_word(word, root)\n\n    longest_word = \"\"\n\n    for word in words:\n        if len(word) > len(longest_word):\n            is_buildable = True\n\n            for i in range(1, len(word)):\n                prefix = word[:i]\n                if not search_word(prefix, root):\n                    is_buildable = False\n                    break\n\n            if is_buildable:\n                longest_word = word\n\n    return longest_word\n\ndef g():\n    return [\"cat\", \"banana\", \"dog\", \"nana\", \"walk\", \"walker\", \"dogwalker\"]\n\nassert f(g()) == \"dogwalker\"\n", "emb": null, "idx_generation": 372, "target_skills": [1, 0, 0, 1, 1, 0, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return the longest word in the list that can be built one character at a time by other words in the list.\n\n    Example:\n    Input: words = [\"cat\", \"banana\", \"dog\", \"nana\", \"walk\", \"walker\", \"dogwalker\"]\n    Output: \"dogwalker\"\n\n    Explanation: \"dogwalker\" can be built by combining \"dog\" and \"walker\", both of which are in the list.\n\n    Hint: Use a trie data structure to efficiently store and search for words.\n    \"\"\"\n\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.is_word = False\n\n    def insert_word(word, root):\n        node = root\n\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n\n        node.is_word = True\n\n    def search_word(word, root):\n        node = root\n\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n\n        return node.is_word\n\n    root = TrieNode()\n\n    for word in words:\n        insert_word(word, root)\n\n    longest_word = \"\"\n\n    for word in words:\n        if len(word) > len(longest_word):\n            is_buildable = True\n\n            for i in range(1, len(word)):\n                prefix = word[:i]\n                if not search_word(prefix, root):\n                    is_buildable = False\n                    break\n\n            if is_buildable:\n                longest_word = word\n\n    return longest_word", "solution_func": "def g():\n    return [\"cat\", \"banana\", \"dog\", \"nana\", \"walk\", \"walker\", \"dogwalker\"]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers, determine if there are two numbers in the array that add up to the target value.\n\n    Example:\n    arr = [2, 4, 6, 8, 10]\n    target = 14\n\n    Output:\n    True\n\n    Explanation:\n    There are two numbers in the array, 4 and 10, that add up to the target value of 14.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted array and a target value for the puzzle.\n    \"\"\"\n    arr = [1, 3, 5, 7, 9, 11]\n    target = 14\n    return arr, target\n\nassert f(g()[0], g()[1]) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 372, "target_skills": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers, determine if there are two numbers in the array that add up to the target value.\n\n    Example:\n    arr = [2, 4, 6, 8, 10]\n    target = 14\n\n    Output:\n    True\n\n    Explanation:\n    There are two numbers in the array, 4 and 10, that add up to the target value of 14.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted array and a target value for the puzzle.\n    \"\"\"\n    arr = [1, 3, 5, 7, 9, 11]\n    target = 14\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two positive integers n and k, calculate the number of k-combinations from a set of n elements.\n\n    Example:\n    n = 5\n    k = 3\n\n    Output:\n    10\n\n    Explanation:\n    There are 10 different combinations of 3 elements from a set of 5 elements.\n\n    Hint: Use the formula C(n, k) = n! / (k! * (n-k)!)\n    \"\"\"\n\n    def factorial(n: int) -> int:\n        if n == 0 or n == 1:\n            return 1\n        else:\n            return n * factorial(n - 1)\n\n    return factorial(n) // (factorial(k) * factorial(n - k))\n\ndef g() -> Tuple[int, int]:\n    \"\"\"\n    Generate values for n and k for the puzzle.\n    \"\"\"\n    n = 5\n    k = 3\n    return n, k\n\nassert f(g()[0], g()[1]) == 10\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 372, "target_skills": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two positive integers n and k, calculate the number of k-combinations from a set of n elements.\n\n    Example:\n    n = 5\n    k = 3\n\n    Output:\n    10\n\n    Explanation:\n    There are 10 different combinations of 3 elements from a set of 5 elements.\n\n    Hint: Use the formula C(n, k) = n! / (k! * (n-k)!)\n    \"\"\"\n\n    def factorial(n: int) -> int:\n        if n == 0 or n == 1:\n            return 1\n        else:\n            return n * factorial(n - 1)\n\n    return factorial(n) // (factorial(k) * factorial(n - k))", "solution_func": "def g() -> Tuple[int, int]:\n    \"\"\"\n    Generate values for n and k for the puzzle.\n    \"\"\"\n    n = 5\n    k = 3\n    return n, k", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(adj_list: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency list representing a directed acyclic graph (DAG), find the length of the longest path in the graph.\n\n    Example:\n    adj_list = [[1, 2], [3], [4], [], []]\n\n    Output:\n    3\n\n    Explanation:\n    The longest path in the graph is [0, 1, 3], with a length of 3.\n\n    Hint: Use dynamic programming to store the maximum path length for each node.\n    \"\"\"\n\n    def dfs(node: int) -> int:\n        if memo[node] != -1:\n            return memo[node]\n\n        max_length = 0\n\n        for neighbor in adj_list[node]:\n            max_length = max(max_length, dfs(neighbor) + 1)\n\n        memo[node] = max_length\n        return max_length\n\n    n = len(adj_list)\n    memo = [-1] * n\n\n    for i in range(n):\n        if memo[i] == -1:\n            dfs(i)\n\n    return max(memo)\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate an adjacency list for the puzzle.\n    \"\"\"\n    adj_list = [[1, 2], [3], [4], [], []]\n    return adj_list\n\nassert f(g()) == 3\n", "emb": null, "idx_generation": 372, "target_skills": [0, 0, 0, 1, 0, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(adj_list: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency list representing a directed acyclic graph (DAG), find the length of the longest path in the graph.\n\n    Example:\n    adj_list = [[1, 2], [3], [4], [], []]\n\n    Output:\n    3\n\n    Explanation:\n    The longest path in the graph is [0, 1, 3], with a length of 3.\n\n    Hint: Use dynamic programming to store the maximum path length for each node.\n    \"\"\"\n\n    def dfs(node: int) -> int:\n        if memo[node] != -1:\n            return memo[node]\n\n        max_length = 0\n\n        for neighbor in adj_list[node]:\n            max_length = max(max_length, dfs(neighbor) + 1)\n\n        memo[node] = max_length\n        return max_length\n\n    n = len(adj_list)\n    memo = [-1] * n\n\n    for i in range(n):\n        if memo[i] == -1:\n            dfs(i)\n\n    return max(memo)", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate an adjacency list for the puzzle.\n    \"\"\"\n    adj_list = [[1, 2], [3], [4], [], []]\n    return adj_list", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers 'nums' and a target value 'target',\n    determine if there are three numbers in 'nums' that sum up to the target value.\n    Return True if such numbers exist, otherwise return False.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7]\n    target = 9\n\n    Output:\n    True\n\n    Explanation:\n    The numbers 2, 3, and 4 in the list sum up to the target value 9.\n    \"\"\"\n\n    def two_sum(nums: List[int], target: int, start: int) -> bool:\n        left = start\n        right = len(nums) - 1\n        while left < right:\n            curr_sum = nums[left] + nums[right]\n            if curr_sum == target:\n                return True\n            elif curr_sum < target:\n                left += 1\n            else:\n                right -= 1\n        return False\n\n    nums.sort()\n    for i in range(len(nums) - 2):\n        if two_sum(nums, target - nums[i], i+1):\n            return True\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    return ([1, 2, 3, 4, 5, 6, 7], 9)\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 372, "target_skills": [0, 1, 1, 0, 1, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers 'nums' and a target value 'target',\n    determine if there are three numbers in 'nums' that sum up to the target value.\n    Return True if such numbers exist, otherwise return False.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7]\n    target = 9\n\n    Output:\n    True\n\n    Explanation:\n    The numbers 2, 3, and 4 in the list sum up to the target value 9.\n    \"\"\"\n\n    def two_sum(nums: List[int], target: int, start: int) -> bool:\n        left = start\n        right = len(nums) - 1\n        while left < right:\n            curr_sum = nums[left] + nums[right]\n            if curr_sum == target:\n                return True\n            elif curr_sum < target:\n                left += 1\n            else:\n                right -= 1\n        return False\n\n    nums.sort()\n    for i in range(len(nums) - 2):\n        if two_sum(nums, target - nums[i], i+1):\n            return True\n    return False", "solution_func": "def g() -> Tuple[List[int], int]:\n    return ([1, 2, 3, 4, 5, 6, 7], 9)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subarray.\n\n    Example:\n    nums = [1, 3, 2, 4, 7, 6, 8]\n\n    Output:\n    3\n\n    Explanation:\n    The longest increasing subarray is [2, 4, 7] of length 3.\n    \"\"\"\n\n    max_length = 0\n    curr_length = 1\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i-1]:\n            curr_length += 1\n        else:\n            max_length = max(max_length, curr_length)\n            curr_length = 1\n    max_length = max(max_length, curr_length)\n    return max_length\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    return [1, 3, 2, 4, 7, 6, 8]\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 372, "target_skills": [0, 0, 1, 1, 0, 0, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subarray.\n\n    Example:\n    nums = [1, 3, 2, 4, 7, 6, 8]\n\n    Output:\n    3\n\n    Explanation:\n    The longest increasing subarray is [2, 4, 7] of length 3.\n    \"\"\"\n\n    max_length = 0\n    curr_length = 1\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i-1]:\n            curr_length += 1\n        else:\n            max_length = max(max_length, curr_length)\n            curr_length = 1\n    max_length = max(max_length, curr_length)\n    return max_length", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    return [1, 3, 2, 4, 7, 6, 8]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the product of the maximum and minimum elements in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    5\n\n    Explanation:\n    The maximum element is 5 and the minimum element is 1, so the product is 5.\n    \"\"\"\n\n    max_num = float('-inf')\n    min_num = float('inf')\n\n    for num in nums:\n        max_num = max(max_num, num)\n        min_num = min(min_num, num)\n\n    return max_num * min_num\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 5\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 372, "target_skills": [1, 1, 0, 0, 0, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the product of the maximum and minimum elements in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    5\n\n    Explanation:\n    The maximum element is 5 and the minimum element is 1, so the product is 5.\n    \"\"\"\n\n    max_num = float('-inf')\n    min_num = float('inf')\n\n    for num in nums:\n        max_num = max(max_num, num)\n        min_num = min(min_num, num)\n\n    return max_num * min_num", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    return [1, 2, 3, 4, 5]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> List[int]:\n    \"\"\"\n    Given the root of a binary tree, return the inorder traversal of its nodes' values.\n    \"\"\"\n    result = []\n    stack = []\n    curr = root\n\n    while curr or stack:\n        while curr:\n            stack.append(curr)\n            curr = curr.left\n\n        curr = stack.pop()\n        result.append(curr.val)\n        curr = curr.right\n\n    return result\n\ndef g():\n    # Creating a binary tree\n    root = TreeNode(1)\n    root.right = TreeNode(2)\n    root.right.left = TreeNode(3)\n\n    return root\n\nassert f(g()) == [1, 3, 2]\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 372, "target_skills": [1, 0, 0, 0, 1, 1, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> List[int]:\n    \"\"\"\n    Given the root of a binary tree, return the inorder traversal of its nodes' values.\n    \"\"\"\n    result = []\n    stack = []\n    curr = root\n\n    while curr or stack:\n        while curr:\n            stack.append(curr)\n            curr = curr.left\n\n        curr = stack.pop()\n        result.append(curr.val)\n        curr = curr.right\n\n    return result", "solution_func": "def g():\n    # Creating a binary tree\n    root = TreeNode(1)\n    root.right = TreeNode(2)\n    root.right.left = TreeNode(3)\n\n    return root", "map_ix": [0, 0, 1, 0, 0, 1, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the sum of all the even numbers in the list.\n    \"\"\"\n    return sum(num for num in nums if num % 2 == 0)\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5, 6, 7, 8]\n\nassert f(g()) == 20\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 373, "target_skills": [0, 0, 0, 1, 0, 1, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the sum of all the even numbers in the list.\n    \"\"\"\n    return sum(num for num in nums if num % 2 == 0)", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3, 4, 5, 6, 7, 8]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of the words in the string.\n\n    Example:\n    Input: \"Hello World\"\n    Output: \"World Hello\"\n    \"\"\"\n    words = s.split()\n    return ' '.join(reversed(words))\n\ndef g() -> str:\n    return \"Hello World\"\n\nassert f(g()) == \"World Hello\"\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 373, "target_skills": [1, 1, 1, 1, 0, 1, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of the words in the string.\n\n    Example:\n    Input: \"Hello World\"\n    Output: \"World Hello\"\n    \"\"\"\n    words = s.split()\n    return ' '.join(reversed(words))", "solution_func": "def g() -> str:\n    return \"Hello World\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n\n    Example:\n    Input: \"abcabcbb\"\n    Output: 3\n    Explanation: The longest substring without repeating characters is \"abc\", which has a length of 3.\n    \"\"\"\n    max_length = 0\n    start = 0\n    char_dict = {}\n\n    for i in range(len(s)):\n        if s[i] in char_dict and start <= char_dict[s[i]]:\n            start = char_dict[s[i]] + 1\n        else:\n            max_length = max(max_length, i - start + 1)\n\n        char_dict[s[i]] = i\n\n    return max_length\n\ndef g() -> str:\n    return \"abcabcbb\"\n\nassert f(g()) == 3\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 373, "target_skills": [1, 1, 0, 0, 0, 0, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n\n    Example:\n    Input: \"abcabcbb\"\n    Output: 3\n    Explanation: The longest substring without repeating characters is \"abc\", which has a length of 3.\n    \"\"\"\n    max_length = 0\n    start = 0\n    char_dict = {}\n\n    for i in range(len(s)):\n        if s[i] in char_dict and start <= char_dict[s[i]]:\n            start = char_dict[s[i]] + 1\n        else:\n            max_length = max(max_length, i - start + 1)\n\n        char_dict[s[i]] = i\n\n    return max_length", "solution_func": "def g() -> str:\n    return \"abcabcbb\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(x: List[int], k: int, n: int) -> bool:\n    \"\"\"Check if there are exactly k elements in the list with value less than n.\"\"\"\n    count = sum(1 for num in x if num < n)\n    return count == k\n\ndef g(k=3, n=5):\n    return [1, 2, 3, 4, 5], k, n\n\nassert f(*g())\n", "emb": null, "idx_generation": 373, "target_skills": [0, 0, 1, 1, 1, 0, 1, 0, 0, 0], "problem_func": "from typing import*\ndef f(x: List[int], k: int, n: int) -> bool:\n    \"\"\"Check if there are exactly k elements in the list with value less than n.\"\"\"\n    count = sum(1 for num in x if num < n)\n    return count == k", "solution_func": "def g(k=3, n=5):\n    return [1, 2, 3, 4, 5], k, n", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Check if the target value is present in the matrix.\"\"\"\n    for row in matrix:\n        if target in row:\n            return True\n    return False\n\ndef g():\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    target = 5\n    return matrix, target\n\nassert f(*g())\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 373, "target_skills": [0, 1, 0, 0, 1, 1, 0, 1, 1, 1], "problem_func": "from typing import*\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Check if the target value is present in the matrix.\"\"\"\n    for row in matrix:\n        if target in row:\n            return True\n    return False", "solution_func": "def g():\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    target = 5\n    return matrix, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"Check if the string s contains exactly n uppercase letters.\"\"\"\n    count = sum(1 for char in s if char.isupper())\n    return count == n\n\ndef g(n=3):\n    s = \"HeLLoWorLD\"\n    return s, n\n\nassert f(*g())\n", "emb": null, "idx_generation": 373, "target_skills": [1, 0, 1, 1, 1, 0, 1, 1, 1, 1], "problem_func": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"Check if the string s contains exactly n uppercase letters.\"\"\"\n    count = sum(1 for char in s if char.isupper())\n    return count == n", "solution_func": "def g(n=3):\n    s = \"HeLLoWorLD\"\n    return s, n", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of inversions in the list.\n    An inversion occurs when two elements in the list are out of order.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The number of inversions in the list.\n    \"\"\"\n    def merge_sort(nums, start, end):\n        if start < end:\n            mid = (start + end) // 2\n            count = merge_sort(nums, start, mid)\n            count += merge_sort(nums, mid+1, end)\n            count += merge(nums, start, mid, end)\n            return count\n        else:\n            return 0\n\n    def merge(nums, start, mid, end):\n        count = 0\n        left = nums[start:mid+1]\n        right = nums[mid+1:end+1]\n        i = j = 0\n        k = start\n\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                nums[k] = left[i]\n                i += 1\n            else:\n                nums[k] = right[j]\n                j += 1\n                count += (mid - start + 1) - i\n            k += 1\n\n        while i < len(left):\n            nums[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            nums[k] = right[j]\n            j += 1\n            k += 1\n\n        return count\n\n    return merge_sort(nums, 0, len(nums)-1)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [4, 2, 1, 3, 5]\n\nassert f(g()) == 4\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 373, "target_skills": [1, 0, 0, 1, 0, 0, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of inversions in the list.\n    An inversion occurs when two elements in the list are out of order.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The number of inversions in the list.\n    \"\"\"\n    def merge_sort(nums, start, end):\n        if start < end:\n            mid = (start + end) // 2\n            count = merge_sort(nums, start, mid)\n            count += merge_sort(nums, mid+1, end)\n            count += merge(nums, start, mid, end)\n            return count\n        else:\n            return 0\n\n    def merge(nums, start, mid, end):\n        count = 0\n        left = nums[start:mid+1]\n        right = nums[mid+1:end+1]\n        i = j = 0\n        k = start\n\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                nums[k] = left[i]\n                i += 1\n            else:\n                nums[k] = right[j]\n                j += 1\n                count += (mid - start + 1) - i\n            k += 1\n\n        while i < len(left):\n            nums[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            nums[k] = right[j]\n            j += 1\n            k += 1\n\n        return count\n\n    return merge_sort(nums, 0, len(nums)-1)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [4, 2, 1, 3, 5]", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The length of the longest increasing subsequence.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 373, "target_skills": [0, 1, 0, 0, 1, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The length of the longest increasing subsequence.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [10, 9, 2, 5, 3, 7, 101, 18]", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the first missing positive integer.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The first missing positive integer.\n    \"\"\"\n    n = len(nums)\n\n    for i in range(n):\n        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n\n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n\n    return n + 1\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [3, 4, -1, 1]\n\nassert f(g()) == 2\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 373, "target_skills": [0, 1, 0, 1, 1, 0, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the first missing positive integer.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The first missing positive integer.\n    \"\"\"\n    n = len(nums)\n\n    for i in range(n):\n        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n\n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n\n    return n + 1", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [3, 4, -1, 1]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there is a path between start and end in a given graph.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g():\n    graph = {1: [2, 3], 2: [4], 3: [5], 4: [5], 5: []}\n    start = 1\n    end = 5\n    return graph\n\nassert f(g(), 1, 5) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 373, "target_skills": [1, 0, 1, 0, 0, 1, 0, 1, 1, 1], "problem_func": "from typing import*\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there is a path between start and end in a given graph.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False", "solution_func": "def g():\n    graph = {1: [2, 3], 2: [4], 3: [5], 4: [5], 5: []}\n    start = 1\n    end = 5\n    return graph", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find all pairs of numbers in the list\n    that add up to the target.\n\n    Return a list of tuples containing the pairs of numbers.\n\n    Sample Input:\n    nums = [2, 4, 6, 8, 10]\n    target = 12\n\n    Sample Output:\n    [(2, 10), (4, 8)]\n\n    Explanation:\n    The pairs of numbers (2, 10) and (4, 8) add up to the target number 12.\n    \"\"\"\n    pairs = []\n    nums.sort()\n\n    def find_pairs(start, end, curr_sum, path):\n        if curr_sum == target:\n            pairs.append(tuple(path))\n            return\n        elif curr_sum > target:\n            return\n\n        for i in range(start, end):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            find_pairs(i+1, end, curr_sum + nums[i], path + [nums[i]])\n\n    find_pairs(0, len(nums), 0, [])\n    return pairs\n\ndef g(nums=[2, 4, 6, 8, 10], target=12):\n    return nums, target\n\nassert f(*g()) == [(2, 10), (4, 8)]\n", "emb": null, "idx_generation": 374, "target_skills": [1, 1, 0, 0, 1, 1, 0, 1, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find all pairs of numbers in the list\n    that add up to the target.\n\n    Return a list of tuples containing the pairs of numbers.\n\n    Sample Input:\n    nums = [2, 4, 6, 8, 10]\n    target = 12\n\n    Sample Output:\n    [(2, 10), (4, 8)]\n\n    Explanation:\n    The pairs of numbers (2, 10) and (4, 8) add up to the target number 12.\n    \"\"\"\n    pairs = []\n    nums.sort()\n\n    def find_pairs(start, end, curr_sum, path):\n        if curr_sum == target:\n            pairs.append(tuple(path))\n            return\n        elif curr_sum > target:\n            return\n\n        for i in range(start, end):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            find_pairs(i+1, end, curr_sum + nums[i], path + [nums[i]])\n\n    find_pairs(0, len(nums), 0, [])\n    return pairs", "solution_func": "def g(nums=[2, 4, 6, 8, 10], target=12):\n    return nums, target", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, return the most common character in the string.\n    If there are multiple characters with the same highest frequency, return the character that appears first.\n\n    Sample Input:\n    s = \"abcccddddeef\"\n\n    Sample Output:\n    \"c\"\n\n    Explanation:\n    The character 'c' appears 3 times, which is the highest frequency among all characters.\n    \"\"\"\n\n    freq = {}\n    max_freq = 0\n    most_common = ''\n\n    for char in s:\n        freq[char] = freq.get(char, 0) + 1\n        if freq[char] > max_freq:\n            max_freq = freq[char]\n            most_common = char\n\n    return most_common\n\ndef g(s=\"abcccddddeef\"):\n    return s\n\nassert f(g()) == \"c\"\n", "emb": null, "idx_generation": 374, "target_skills": [1, 1, 1, 0, 0, 1, 0, 1, 0, 1], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, return the most common character in the string.\n    If there are multiple characters with the same highest frequency, return the character that appears first.\n\n    Sample Input:\n    s = \"abcccddddeef\"\n\n    Sample Output:\n    \"c\"\n\n    Explanation:\n    The character 'c' appears 3 times, which is the highest frequency among all characters.\n    \"\"\"\n\n    freq = {}\n    max_freq = 0\n    most_common = ''\n\n    for char in s:\n        freq[char] = freq.get(char, 0) + 1\n        if freq[char] > max_freq:\n            max_freq = freq[char]\n            most_common = char\n\n    return most_common", "solution_func": "def g(s=\"abcccddddeef\"):\n    return s", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n\n    Sample Input:\n    n = 6\n\n    Sample Output:\n    8\n\n    Explanation:\n    The 6th Fibonacci number is 8.\n    The Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, ...\n    \"\"\"\n\n    if n <= 1:\n        return n\n\n    fib = [0, 1]\n    for i in range(2, n+1):\n        fib.append(fib[i-1] + fib[i-2])\n\n    return fib[n]\n\ndef g(n=6):\n    return n\n\nassert f(g()) == 8\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 374, "target_skills": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n\n    Sample Input:\n    n = 6\n\n    Sample Output:\n    8\n\n    Explanation:\n    The 6th Fibonacci number is 8.\n    The Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, ...\n    \"\"\"\n\n    if n <= 1:\n        return n\n\n    fib = [0, 1]\n    for i in range(2, n+1):\n        fib.append(fib[i-1] + fib[i-2])\n\n    return fib[n]", "solution_func": "def g(n=6):\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray.\n\n    Example:\n    nums = [1, -2, 3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    10 (the maximum sum is obtained from the subarray [3, 4, -1, 2, 1])\n    \"\"\"\n    if not nums:\n        return 0\n    \n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef g():\n    nums = [1, -2, 3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 10\n", "emb": null, "idx_generation": 374, "target_skills": [1, 1, 0, 0, 1, 0, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray.\n\n    Example:\n    nums = [1, -2, 3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    10 (the maximum sum is obtained from the subarray [3, 4, -1, 2, 1])\n    \"\"\"\n    if not nums:\n        return 0\n    \n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum", "solution_func": "def g():\n    nums = [1, -2, 3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, return the longest palindromic substring.\n\n    Example:\n    s = \"babad\"\n\n    Output:\n    \"bab\" (or \"aba\")\n    \"\"\"\n    if not s:\n        return \"\"\n    \n    longest_palindrome = \"\"\n    \n    def expand_from_center(left: int, right: int) -> str:\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left+1:right]\n    \n    for i in range(len(s)):\n        palindrome_odd = expand_from_center(i, i)\n        palindrome_even = expand_from_center(i, i+1)\n        \n        longest_palindrome = max(longest_palindrome, palindrome_odd, palindrome_even, key=len)\n    \n    return longest_palindrome\n\ndef g():\n    s = \"babad\"\n    return s\n\nassert f(g()) == \"bab\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 374, "target_skills": [0, 1, 0, 1, 0, 0, 0, 0, 1, 0], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, return the longest palindromic substring.\n\n    Example:\n    s = \"babad\"\n\n    Output:\n    \"bab\" (or \"aba\")\n    \"\"\"\n    if not s:\n        return \"\"\n    \n    longest_palindrome = \"\"\n    \n    def expand_from_center(left: int, right: int) -> str:\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left+1:right]\n    \n    for i in range(len(s)):\n        palindrome_odd = expand_from_center(i, i)\n        palindrome_even = expand_from_center(i, i+1)\n        \n        longest_palindrome = max(longest_palindrome, palindrome_odd, palindrome_even, key=len)\n    \n    return longest_palindrome", "solution_func": "def g():\n    s = \"babad\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there exists a subset of the list\n    whose sum is equal to the target value.\n\n    Example:\n    nums = [2, 3, 5, 6, 8, 10]\n    target = 9\n\n    Output:\n    True (the subset [2, 3, 4] has a sum of 9)\n    \"\"\"\n    def subset_sum(index: int, curr_sum: int) -> bool:\n        if curr_sum == target:\n            return True\n        if index >= len(nums) or curr_sum > target:\n            return False\n        \n        # Choose the current number\n        if subset_sum(index + 1, curr_sum + nums[index]):\n            return True\n        \n        # Do not choose the current number\n        if subset_sum(index + 1, curr_sum):\n            return True\n        \n        return False\n    \n    return subset_sum(0, 0)\n\ndef g():\n    nums = [2, 3, 5, 6, 8, 10]\n    target = 9\n    return nums, target\n\nassert f(*g()) == True\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 374, "target_skills": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there exists a subset of the list\n    whose sum is equal to the target value.\n\n    Example:\n    nums = [2, 3, 5, 6, 8, 10]\n    target = 9\n\n    Output:\n    True (the subset [2, 3, 4] has a sum of 9)\n    \"\"\"\n    def subset_sum(index: int, curr_sum: int) -> bool:\n        if curr_sum == target:\n            return True\n        if index >= len(nums) or curr_sum > target:\n            return False\n        \n        # Choose the current number\n        if subset_sum(index + 1, curr_sum + nums[index]):\n            return True\n        \n        # Do not choose the current number\n        if subset_sum(index + 1, curr_sum):\n            return True\n        \n        return False\n    \n    return subset_sum(0, 0)", "solution_func": "def g():\n    nums = [2, 3, 5, 6, 8, 10]\n    target = 9\n    return nums, target", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The maximum sum path is 1 -> 3 -> 1 -> 1 -> 1, which gives a total sum of 7.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Initialize the dp table\n    dp = [[0] * cols for _ in range(rows)]\n\n    # Fill in the dp table\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g():\n    \"\"\"\n    Generate a grid of integers for testing.\n    \"\"\"\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n\n", "emb": null, "idx_generation": 374, "target_skills": [1, 1, 1, 1, 0, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The maximum sum path is 1 -> 3 -> 1 -> 1 -> 1, which gives a total sum of 7.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Initialize the dp table\n    dp = [[0] * cols for _ in range(rows)]\n\n    # Fill in the dp table\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]", "solution_func": "def g():\n    \"\"\"\n    Generate a grid of integers for testing.\n    \"\"\"\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum number of steps required to reach the bottom-right cell from the top-left cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum number of steps required is 7, which is the length of the shortest path: 1 -> 3 -> 1 -> 1 -> 1.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Initialize the dp table\n    dp = [[0] * cols for _ in range(rows)]\n\n    # Fill in the dp table\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g():\n    \"\"\"\n    Generate a grid of integers for testing.\n    \"\"\"\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 374, "target_skills": [1, 1, 0, 1, 0, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum number of steps required to reach the bottom-right cell from the top-left cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum number of steps required is 7, which is the length of the shortest path: 1 -> 3 -> 1 -> 1 -> 1.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Initialize the dp table\n    dp = [[0] * cols for _ in range(rows)]\n\n    # Fill in the dp table\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]", "solution_func": "def g():\n    \"\"\"\n    Generate a grid of integers for testing.\n    \"\"\"\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, determine if there is a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 0, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    False\n\n    Explanation:\n    There is no path from the top-left cell to the bottom-right cell, as there is a 0 in the middle row.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Initialize the dp table\n    dp = [[False] * cols for _ in range(rows)]\n\n    # Fill in the dp table\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = True\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] and grid[i][j] != 0\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] and grid[i][j] != 0\n            else:\n                dp[i][j] = (dp[i-1][j] or dp[i][j-1]) and grid[i][j] != 0\n\n    return dp[rows-1][cols-1]\n\ndef g():\n    \"\"\"\n    Generate a grid of integers for testing.\n    \"\"\"\n    return [\n        [1, 3, 1],\n        [1, 0, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == False\n\n", "emb": null, "idx_generation": 374, "target_skills": [0, 0, 0, 0, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, determine if there is a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 0, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    False\n\n    Explanation:\n    There is no path from the top-left cell to the bottom-right cell, as there is a 0 in the middle row.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Initialize the dp table\n    dp = [[False] * cols for _ in range(rows)]\n\n    # Fill in the dp table\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = True\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] and grid[i][j] != 0\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] and grid[i][j] != 0\n            else:\n                dp[i][j] = (dp[i-1][j] or dp[i][j-1]) and grid[i][j] != 0\n\n    return dp[rows-1][cols-1]", "solution_func": "def g():\n    \"\"\"\n    Generate a grid of integers for testing.\n    \"\"\"\n    return [\n        [1, 3, 1],\n        [1, 0, 1],\n        [4, 2, 1]\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, determine if there exists a pair of integers in the list\n    such that their sum is equal to the target.\n\n    Args:\n    - nums: A sorted list of integers.\n    - target: The target integer.\n\n    Returns:\n    - True if there exists a pair of integers in the list such that their sum is equal to the target, False otherwise.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    Output:\n    True\n\n    Explanation:\n    There exists a pair of integers in the list whose sum is equal to the target:\n    2 + 5 = 7.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5], target=7):\n    return nums, target\n\nassert f(*g()) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 374, "target_skills": [1, 0, 0, 0, 1, 1, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, determine if there exists a pair of integers in the list\n    such that their sum is equal to the target.\n\n    Args:\n    - nums: A sorted list of integers.\n    - target: The target integer.\n\n    Returns:\n    - True if there exists a pair of integers in the list such that their sum is equal to the target, False otherwise.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    Output:\n    True\n\n    Explanation:\n    There exists a pair of integers in the list whose sum is equal to the target:\n    2 + 5 = 7.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g(nums=[1, 2, 3, 4, 5], target=7):\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array arr of distinct integers and a target value, find the index of the target in the array.\n    If the target is not found, return -1.\n\n    Example:\n    arr = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]\n    target = 16\n\n    Output:\n    4 (since the target 16 is found at index 4 in the array)\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        \n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    arr = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]\n    target = 16\n    return arr, target\n\nassert f(*g()) == 4\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 375, "target_skills": [1, 0, 1, 0, 0, 0, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array arr of distinct integers and a target value, find the index of the target in the array.\n    If the target is not found, return -1.\n\n    Example:\n    arr = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]\n    target = 16\n\n    Output:\n    4 (since the target 16 is found at index 4 in the array)\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        \n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1", "solution_func": "def g() -> Tuple[List[int], int]:\n    arr = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]\n    target = 16\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, return the topological ordering of the graph.\n    If the graph contains a cycle, return an empty list.\n\n    Example:\n    graph = [[1, 2], [3], [3, 4], [4], []]\n\n    Output:\n    [0, 2, 1, 3, 4] (one possible topological ordering of the graph)\n    \"\"\"\n    n = len(graph)\n    visited = [False] * n\n    stack = []\n    \n    def dfs(node):\n        visited[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n        \n        stack.append(node)\n    \n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n    \n    return stack[::-1]\n\ndef g() -> List[List[int]]:\n    graph = [[1, 2], [3], [3, 4], [4], []]\n    return graph\n\nassert f(g()) == [0, 2, 1, 3, 4]\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 375, "target_skills": [1, 1, 0, 1, 1, 1, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, return the topological ordering of the graph.\n    If the graph contains a cycle, return an empty list.\n\n    Example:\n    graph = [[1, 2], [3], [3, 4], [4], []]\n\n    Output:\n    [0, 2, 1, 3, 4] (one possible topological ordering of the graph)\n    \"\"\"\n    n = len(graph)\n    visited = [False] * n\n    stack = []\n    \n    def dfs(node):\n        visited[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n        \n        stack.append(node)\n    \n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n    \n    return stack[::-1]", "solution_func": "def g() -> List[List[int]]:\n    graph = [[1, 2], [3], [3, 4], [4], []]\n    return graph", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n\n    Example:\n    n = 5\n\n    Output:\n    5 (since the 5th Fibonacci number is 5)\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    prev1 = 0\n    prev2 = 1\n    \n    for _ in range(2, n + 1):\n        curr = prev1 + prev2\n        prev1, prev2 = prev2, curr\n    \n    return prev2\n\ndef g() -> int:\n    n = 5\n    return n\n\nassert f(g()) == 5\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 375, "target_skills": [1, 0, 0, 1, 0, 0, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n\n    Example:\n    n = 5\n\n    Output:\n    5 (since the 5th Fibonacci number is 5)\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    prev1 = 0\n    prev2 = 1\n    \n    for _ in range(2, n + 1):\n        curr = prev1 + prev2\n        prev1, prev2 = prev2, curr\n    \n    return prev2", "solution_func": "def g() -> int:\n    n = 5\n    return n", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Sort an array of integers in descending order\"\"\"\n    return sorted(arr, reverse=True)\n\ndef g():\n    return [5, 2, 8, 1, 7]\n\nassert f(g()) == [8, 7, 5, 2, 1]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 375, "target_skills": [0, 1, 1, 1, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Sort an array of integers in descending order\"\"\"\n    return sorted(arr, reverse=True)", "solution_func": "def g():\n    return [5, 2, 8, 1, 7]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the maximum sum of a path in a grid, where each cell can be visited only once.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[rows-1][cols-1]\n\ndef g():\n    return [[1, 3, 2], [4, 2, 1], [2, 5, 4]]\n\nassert f(g()) == 15\n", "emb": null, "idx_generation": 375, "target_skills": [0, 1, 0, 0, 0, 0, 0, 0, 1, 0], "problem_func": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the maximum sum of a path in a grid, where each cell can be visited only once.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[rows-1][cols-1]", "solution_func": "def g():\n    return [[1, 3, 2], [4, 2, 1], [2, 5, 4]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, t: str) -> int:\n    \"\"\"Count the number of non-overlapping occurrences of string t in string s.\"\"\"\n    count = 0\n    i = 0\n    while i < len(s):\n        if s[i:i+len(t)] == t:\n            count += 1\n            i += len(t)\n        else:\n            i += 1\n    return count\n\ndef g():\n    return \"abababab\", \"ab\"\n\nassert f(*g()) == 4\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 375, "target_skills": [1, 1, 1, 1, 0, 0, 0, 0, 1, 0], "problem_func": "from typing import*\ndef f(s: str, t: str) -> int:\n    \"\"\"Count the number of non-overlapping occurrences of string t in string s.\"\"\"\n    count = 0\n    i = 0\n    while i < len(s):\n        if s[i:i+len(t)] == t:\n            count += 1\n            i += len(t)\n        else:\n            i += 1\n    return count", "solution_func": "def g():\n    return \"abababab\", \"ab\"", "map_ix": [0, 1, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(arr: list) -> bool:\n    \"\"\"\n    Given a list of integers, check if the list is sorted in non-decreasing order.\n\n    Example:\n    arr = [1, 2, 3, 5, 8]\n\n    Output:\n    True\n\n    Explanation:\n    The list is sorted in non-decreasing order.\n\n    Hint: Compare adjacent elements and check if they are in the correct order.\n    \"\"\"\n\n    for i in range(len(arr) - 1):\n        if arr[i] > arr[i + 1]:\n            return False\n\n    return True\n\ndef g(arr = [1, 2, 3, 5, 8]):\n    return arr\n\nassert f(g()) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 375, "target_skills": [0, 0, 0, 1, 1, 1, 0, 1, 0, 1], "problem_func": "from typing import*\ndef f(arr: list) -> bool:\n    \"\"\"\n    Given a list of integers, check if the list is sorted in non-decreasing order.\n\n    Example:\n    arr = [1, 2, 3, 5, 8]\n\n    Output:\n    True\n\n    Explanation:\n    The list is sorted in non-decreasing order.\n\n    Hint: Compare adjacent elements and check if they are in the correct order.\n    \"\"\"\n\n    for i in range(len(arr) - 1):\n        if arr[i] > arr[i + 1]:\n            return False\n\n    return True", "solution_func": "def g(arr = [1, 2, 3, 5, 8]):\n    return arr", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all positive integers less than or equal to n.\n\n    Example:\n    n = 5\n\n    Output:\n    15\n\n    Explanation:\n    The sum of all positive integers less than or equal to 5 is 1 + 2 + 3 + 4 + 5 = 15.\n\n    Hint: Use the formula for the sum of an arithmetic series.\n    \"\"\"\n\n    return n * (n + 1) // 2\n\ndef g(n = 5):\n    return n\n\nassert f(g()) == 15\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 375, "target_skills": [0, 0, 0, 0, 0, 1, 0, 0, 1, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all positive integers less than or equal to n.\n\n    Example:\n    n = 5\n\n    Output:\n    15\n\n    Explanation:\n    The sum of all positive integers less than or equal to 5 is 1 + 2 + 3 + 4 + 5 = 15.\n\n    Hint: Use the formula for the sum of an arithmetic series.\n    \"\"\"\n\n    return n * (n + 1) // 2", "solution_func": "def g(n = 5):\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the nth Fibonacci number.\n\n    Example:\n    n = 6\n\n    Output:\n    8\n\n    Explanation:\n    The 6th Fibonacci number is 8.\n\n    Hint: Use recursion and dynamic programming to calculate the nth Fibonacci number.\n    \"\"\"\n\n    if n <= 0:\n        return None\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    \n    fib = [0] * (n + 1)\n    fib[1] = 0\n    fib[2] = 1\n\n    for i in range(3, n + 1):\n        fib[i] = fib[i - 1] + fib[i - 2]\n\n    return fib[n]\n\ndef g(n = 6):\n    return n\n\nassert f(g()) == 8\n\n", "emb": null, "idx_generation": 375, "target_skills": [0, 0, 0, 1, 1, 0, 0, 0, 0, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the nth Fibonacci number.\n\n    Example:\n    n = 6\n\n    Output:\n    8\n\n    Explanation:\n    The 6th Fibonacci number is 8.\n\n    Hint: Use recursion and dynamic programming to calculate the nth Fibonacci number.\n    \"\"\"\n\n    if n <= 0:\n        return None\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    \n    fib = [0] * (n + 1)\n    fib[1] = 0\n    fib[2] = 1\n\n    for i in range(3, n + 1):\n        fib[i] = fib[i - 1] + fib[i - 2]\n\n    return fib[n]", "solution_func": "def g(n = 6):\n    return n", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the number of ways to choose k items from a set of n items.\n\n    Example:\n    n = 5\n    k = 3\n\n    Output:\n    10\n\n    Explanation:\n    There are 10 ways to choose 3 items from a set of 5 items: (1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5), (1, 4, 5), (2, 3, 4), (2, 3, 5), (2, 4, 5), (3, 4, 5)\n    \"\"\"\n\n    def factorial(n: int) -> int:\n        if n == 0 or n == 1:\n            return 1\n        else:\n            return n * factorial(n-1)\n\n    return factorial(n) // (factorial(k) * factorial(n-k))\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    return [5, 3]\n\nassert f(*g()) == 10\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 375, "target_skills": [0, 1, 0, 1, 1, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the number of ways to choose k items from a set of n items.\n\n    Example:\n    n = 5\n    k = 3\n\n    Output:\n    10\n\n    Explanation:\n    There are 10 ways to choose 3 items from a set of 5 items: (1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5), (1, 4, 5), (2, 3, 4), (2, 3, 5), (2, 4, 5), (3, 4, 5)\n    \"\"\"\n\n    def factorial(n: int) -> int:\n        if n == 0 or n == 1:\n            return 1\n        else:\n            return n * factorial(n-1)\n\n    return factorial(n) // (factorial(k) * factorial(n-k))", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    return [5, 3]", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix, return True if there exists a path from the top-left corner to the bottom-right corner,\n    where the sum of all elements in the path is divisible by 3.\n\n    Sample Input:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Sample Output:\n    True\n\n    Explanation:\n    The path [1, 2, 3, 6, 9] has a sum of 21, which is divisible by 3.\n    \"\"\"\n\n    def dfs(row: int, col: int, curr_sum: int) -> bool:\n        if row == len(matrix) - 1 and col == len(matrix[0]) - 1:\n            return curr_sum % 3 == 0\n\n        if row < len(matrix) - 1 and dfs(row + 1, col, curr_sum + matrix[row + 1][col]):\n            return True\n\n        if col < len(matrix[0]) - 1 and dfs(row, col + 1, curr_sum + matrix[row][col + 1]):\n            return True\n\n        return False\n\n    return dfs(0, 0, matrix[0][0])\n\n\ndef g(matrix: List[List[int]] = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) -> List[List[int]]:\n    return matrix\n\n\nassert f(g())\n", "emb": [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 376, "target_skills": [0, 1, 1, 0, 1, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix, return True if there exists a path from the top-left corner to the bottom-right corner,\n    where the sum of all elements in the path is divisible by 3.\n\n    Sample Input:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Sample Output:\n    True\n\n    Explanation:\n    The path [1, 2, 3, 6, 9] has a sum of 21, which is divisible by 3.\n    \"\"\"\n\n    def dfs(row: int, col: int, curr_sum: int) -> bool:\n        if row == len(matrix) - 1 and col == len(matrix[0]) - 1:\n            return curr_sum % 3 == 0\n\n        if row < len(matrix) - 1 and dfs(row + 1, col, curr_sum + matrix[row + 1][col]):\n            return True\n\n        if col < len(matrix[0]) - 1 and dfs(row, col + 1, curr_sum + matrix[row][col + 1]):\n            return True\n\n        return False\n\n    return dfs(0, 0, matrix[0][0])", "solution_func": "def g(matrix: List[List[int]] = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) -> List[List[int]]:\n    return matrix", "map_ix": [1, 1, 1, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, return the maximum XOR value between any two elements in the array.\n\n    Sample Input:\n    arr = [2, 5, 8]\n\n    Sample Output:\n    13\n\n    Explanation:\n    The maximum XOR value is achieved by XORing 5 and 8, which gives 13.\n    \"\"\"\n\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n\n        prefixes = set()\n        for num in arr:\n            prefixes.add(num & mask)\n\n        max_possible_xor = max_xor | (1 << i)\n\n        for prefix in prefixes:\n            if (prefix ^ max_possible_xor) in prefixes:\n                max_xor = max_possible_xor\n                break\n\n    return max_xor\n\n\ndef g(arr: List[int] = [2, 5, 8]) -> List[int]:\n    return arr\n\n\nassert f(g())\n", "emb": null, "idx_generation": 376, "target_skills": [0, 1, 0, 0, 1, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, return the maximum XOR value between any two elements in the array.\n\n    Sample Input:\n    arr = [2, 5, 8]\n\n    Sample Output:\n    13\n\n    Explanation:\n    The maximum XOR value is achieved by XORing 5 and 8, which gives 13.\n    \"\"\"\n\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n\n        prefixes = set()\n        for num in arr:\n            prefixes.add(num & mask)\n\n        max_possible_xor = max_xor | (1 << i)\n\n        for prefix in prefixes:\n            if (prefix ^ max_possible_xor) in prefixes:\n                max_xor = max_possible_xor\n                break\n\n    return max_xor", "solution_func": "def g(arr: List[int] = [2, 5, 8]) -> List[int]:\n    return arr", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid, return the minimum number of steps required to reach the bottom-right cell from the top-left cell,\n    where each step can only be taken to a neighboring cell that shares a common side.\n\n    Sample Input:\n    grid = [\n        [1, 1, 1, 1],\n        [0, 1, 0, 1],\n        [1, 1, 9, 1]\n    ]\n\n    Sample Output:\n    3\n\n    Explanation:\n    The minimum number of steps can be achieved by following the path: (0, 0) -> (1, 0) -> (2, 0) -> (2, 1) -> (2, 2),\n    which takes 3 steps.\n    \"\"\"\n\n    n = len(grid)\n    m = len(grid[0])\n\n    queue = [(0, 0, 0)]\n    visited = set()\n\n    while queue:\n        x, y, steps = queue.pop(0)\n\n        if x == n - 1 and y == m - 1:\n            return steps\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx = x + dx\n            ny = y + dy\n\n            if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] != 0 and (nx, ny) not in visited:\n                queue.append((nx, ny, steps + 1))\n                visited.add((nx, ny))\n\n    return -1\n\n\ndef g(grid: List[List[int]] = [[1, 1, 1, 1], [0, 1, 0, 1], [1, 1, 9, 1]]) -> List[List[int]]:\n    return grid\n\n\nassert f(g())\n", "emb": null, "idx_generation": 376, "target_skills": [1, 1, 1, 1, 0, 1, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid, return the minimum number of steps required to reach the bottom-right cell from the top-left cell,\n    where each step can only be taken to a neighboring cell that shares a common side.\n\n    Sample Input:\n    grid = [\n        [1, 1, 1, 1],\n        [0, 1, 0, 1],\n        [1, 1, 9, 1]\n    ]\n\n    Sample Output:\n    3\n\n    Explanation:\n    The minimum number of steps can be achieved by following the path: (0, 0) -> (1, 0) -> (2, 0) -> (2, 1) -> (2, 2),\n    which takes 3 steps.\n    \"\"\"\n\n    n = len(grid)\n    m = len(grid[0])\n\n    queue = [(0, 0, 0)]\n    visited = set()\n\n    while queue:\n        x, y, steps = queue.pop(0)\n\n        if x == n - 1 and y == m - 1:\n            return steps\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx = x + dx\n            ny = y + dy\n\n            if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] != 0 and (nx, ny) not in visited:\n                queue.append((nx, ny, steps + 1))\n                visited.add((nx, ny))\n\n    return -1", "solution_func": "def g(grid: List[List[int]] = [[1, 1, 1, 1], [0, 1, 0, 1], [1, 1, 9, 1]]) -> List[List[int]]:\n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Generate all combinations of k numbers out of the range 1 to n.\n\n    Example:\n    n = 4, k = 2\n\n    Output:\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n\n    Explanation:\n    The function generates all combinations of 2 numbers out of the range 1 to 4.\n    \"\"\"\n\n    def backtrack(nums: List[int], start: int, k: int, curr_combo: List[int], result: List[List[int]]) -> None:\n        if k == 0:\n            result.append(curr_combo[:])\n            return\n        for i in range(start, len(nums)):\n            curr_combo.append(nums[i])\n            backtrack(nums, i + 1, k - 1, curr_combo, result)\n            curr_combo.pop()\n\n    nums = [i for i in range(1, n + 1)]\n    result = []\n    backtrack(nums, 0, k, [], result)\n    return result\n\ndef g() -> Tuple[int, int]:\n    \"\"\"\n    Generate random values for n and k.\n    \"\"\"\n    import random\n    n = random.randint(1, 10)\n    k = random.randint(1, n)\n    return n, k\n\nn, k = g()\nassert f(*g()) == True\n\n", "emb": null, "idx_generation": 376, "target_skills": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Generate all combinations of k numbers out of the range 1 to n.\n\n    Example:\n    n = 4, k = 2\n\n    Output:\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n\n    Explanation:\n    The function generates all combinations of 2 numbers out of the range 1 to 4.\n    \"\"\"\n\n    def backtrack(nums: List[int], start: int, k: int, curr_combo: List[int], result: List[List[int]]) -> None:\n        if k == 0:\n            result.append(curr_combo[:])\n            return\n        for i in range(start, len(nums)):\n            curr_combo.append(nums[i])\n            backtrack(nums, i + 1, k - 1, curr_combo, result)\n            curr_combo.pop()\n\n    nums = [i for i in range(1, n + 1)]\n    result = []\n    backtrack(nums, 0, k, [], result)\n    return result", "solution_func": "def g() -> Tuple[int, int]:\n    \"\"\"\n    Generate random values for n and k.\n    \"\"\"\n    import random\n    n = random.randint(1, 10)\n    k = random.randint(1, n)\n    return n, k\n\nn, k = g()", "map_ix": null}, {"fitness": -Infinity, "program_str": "import random\nfrom typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Count the number of prime numbers less than a given number n.\n\n    Example:\n    n = 10\n\n    Output:\n    4\n\n    Explanation:\n    There are 4 prime numbers less than 10, which are 2, 3, 5, and 7.\n    \"\"\"\n\n    def is_prime(num: int) -> bool:\n        if num <= 1:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count\n\ndef g() -> int:\n    \"\"\"\n    Generate a random value for n.\n    \"\"\"\n    import random\n    n = random.randint(1, 100)\n    return n\n\nn = g()\nassert f(g()) == True\n\n", "emb": null, "idx_generation": 376, "target_skills": [0, 1, 0, 1, 1, 1, 0, 1, 0, 0], "problem_func": "import random\nfrom typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Count the number of prime numbers less than a given number n.\n\n    Example:\n    n = 10\n\n    Output:\n    4\n\n    Explanation:\n    There are 4 prime numbers less than 10, which are 2, 3, 5, and 7.\n    \"\"\"\n\n    def is_prime(num: int) -> bool:\n        if num <= 1:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a random value for n.\n    \"\"\"\n    import random\n    n = random.randint(1, 100)\n    return n\n\nn = g()", "map_ix": null}, {"fitness": -Infinity, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a grid of integers, return the sum of each row.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    [6, 15, 24]\n\n    Explanation:\n    The function calculates the sum of each row in the grid.\n    \"\"\"\n\n    row_sums = []\n    for row in grid:\n        row_sum = sum(row)\n        row_sums.append(row_sum)\n    return row_sums\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a random grid.\n    \"\"\"\n    import random\n    grid = [[random.randint(1, 10) for _ in range(3)] for _ in range(3)]\n    return grid\n\ngrid = g()\nassert f(g()) == True\n\n", "emb": null, "idx_generation": 376, "target_skills": [0, 0, 0, 0, 1, 1, 0, 1, 1, 0], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a grid of integers, return the sum of each row.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    [6, 15, 24]\n\n    Explanation:\n    The function calculates the sum of each row in the grid.\n    \"\"\"\n\n    row_sums = []\n    for row in grid:\n        row_sum = sum(row)\n        row_sums.append(row_sum)\n    return row_sums", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a random grid.\n    \"\"\"\n    import random\n    grid = [[random.randint(1, 10) for _ in range(3)] for _ in range(3)]\n    return grid\n\ngrid = g()", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the numbers in ascending order using bubble sort algorithm.\n\n    Example:\n    nums = [5, 2, 9, 1, 3]\n\n    Output:\n    [1, 2, 3, 5, 9]\n\n    Hint: Use nested loops to compare adjacent elements and swap them if necessary.\n    \"\"\"\n    n = len(nums)\n    for i in range(n - 1):\n        for j in range(n - 1 - i):\n            if nums[j] > nums[j + 1]:\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n    return nums\n\ndef g(nums=[5, 2, 9, 1, 3]):\n    return (nums,)\n\nassert f(*g()) == [1, 2, 3, 5, 9]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 376, "target_skills": [0, 1, 0, 1, 0, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the numbers in ascending order using bubble sort algorithm.\n\n    Example:\n    nums = [5, 2, 9, 1, 3]\n\n    Output:\n    [1, 2, 3, 5, 9]\n\n    Hint: Use nested loops to compare adjacent elements and swap them if necessary.\n    \"\"\"\n    n = len(nums)\n    for i in range(n - 1):\n        for j in range(n - 1 - i):\n            if nums[j] > nums[j + 1]:\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n    return nums", "solution_func": "def g(nums=[5, 2, 9, 1, 3]):\n    return (nums,)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, calculate the sum of all elements.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    45\n\n    Hint: Use recursion to iterate through all elements of the matrix and add them to the sum.\n    \"\"\"\n    def recursive_sum(matrix: List[List[int]], i: int, j: int) -> int:\n        if i >= len(matrix) or j >= len(matrix[0]):\n            return 0\n        return matrix[i][j] + recursive_sum(matrix, i + 1 if j + 1 >= len(matrix[0]) else i, (j + 1) % len(matrix[0]))\n\n    return recursive_sum(matrix, 0, 0)\n\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return (matrix,)\n\nassert f(*g()) == 45\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 376, "target_skills": [0, 1, 0, 0, 0, 0, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, calculate the sum of all elements.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    45\n\n    Hint: Use recursion to iterate through all elements of the matrix and add them to the sum.\n    \"\"\"\n    def recursive_sum(matrix: List[List[int]], i: int, j: int) -> int:\n        if i >= len(matrix) or j >= len(matrix[0]):\n            return 0\n        return matrix[i][j] + recursive_sum(matrix, i + 1 if j + 1 >= len(matrix[0]) else i, (j + 1) % len(matrix[0]))\n\n    return recursive_sum(matrix, 0, 0)", "solution_func": "def g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return (matrix,)", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(string: str, chars: List[str]) -> int:\n    \"\"\"\n    Given a string and a list of characters, count the number of occurrences of each character in the string.\n\n    Example:\n    string = \"hello\"\n    chars = [\"l\", \"o\"]\n\n    Output:\n    2\n\n    Hint: Use a dictionary to store the count of each character and iterate through the string to update the counts.\n    \"\"\"\n    count = {}\n    for char in string:\n        if char in chars:\n            count[char] = count.get(char, 0) + 1\n    return sum(count.values())\n\ndef g(string=\"hello\", chars=[\"l\", \"o\"]):\n    return (string, chars)\n\nassert f(*g()) == 2\n", "emb": null, "idx_generation": 376, "target_skills": [0, 1, 0, 1, 1, 0, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(string: str, chars: List[str]) -> int:\n    \"\"\"\n    Given a string and a list of characters, count the number of occurrences of each character in the string.\n\n    Example:\n    string = \"hello\"\n    chars = [\"l\", \"o\"]\n\n    Output:\n    2\n\n    Hint: Use a dictionary to store the count of each character and iterate through the string to update the counts.\n    \"\"\"\n    count = {}\n    for char in string:\n        if char in chars:\n            count[char] = count.get(char, 0) + 1\n    return sum(count.values())", "solution_func": "def g(string=\"hello\", chars=[\"l\", \"o\"]):\n    return (string, chars)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, calculate the sum of the even numbers in the list.\n    \"\"\"\n    even_sum = 0\n    for num in nums:\n        if num % 2 == 0:\n            even_sum += num\n    return even_sum\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return nums\n\nassert f(*g()) == 30\n", "emb": null, "idx_generation": 376, "target_skills": [1, 1, 0, 1, 0, 0, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, calculate the sum of the even numbers in the list.\n    \"\"\"\n    even_sum = 0\n    for num in nums:\n        if num % 2 == 0:\n            even_sum += num\n    return even_sum", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of numbers, find the sum of the numbers in the largest square subgrid where the sum of each row and column is equal.\n\n    Example:\n    Input: grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    Output: 18\n    Explanation: The largest square subgrid with equal row and column sums is [[5, 6], [8, 9]] with a sum of 18.\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n\n    # Calculate the prefix sums for each row and column\n    row_sums = [[0] * (m + 1) for _ in range(n + 1)]\n    col_sums = [[0] * (m + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            row_sums[i][j] = row_sums[i][j - 1] + grid[i - 1][j - 1]\n            col_sums[i][j] = col_sums[i - 1][j] + grid[i - 1][j - 1]\n\n    # Find the largest square subgrid with equal row and column sums\n    max_size = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            size = min(row_sums[i][j], col_sums[i][j])\n            while size > max_size:\n                if row_sums[i][j - size] - row_sums[i][j - size - size] == size and col_sums[i - size][j] - col_sums[i - size - size][j] == size:\n                    max_size = size\n                size -= 1\n\n    return max_size * max_size\n\ndef g() -> List[List[int]]:\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return grid\n\nassert f(g()) == 18\n", "emb": null, "idx_generation": 377, "target_skills": [0, 0, 0, 0, 0, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of numbers, find the sum of the numbers in the largest square subgrid where the sum of each row and column is equal.\n\n    Example:\n    Input: grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    Output: 18\n    Explanation: The largest square subgrid with equal row and column sums is [[5, 6], [8, 9]] with a sum of 18.\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n\n    # Calculate the prefix sums for each row and column\n    row_sums = [[0] * (m + 1) for _ in range(n + 1)]\n    col_sums = [[0] * (m + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            row_sums[i][j] = row_sums[i][j - 1] + grid[i - 1][j - 1]\n            col_sums[i][j] = col_sums[i - 1][j] + grid[i - 1][j - 1]\n\n    # Find the largest square subgrid with equal row and column sums\n    max_size = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            size = min(row_sums[i][j], col_sums[i][j])\n            while size > max_size:\n                if row_sums[i][j - size] - row_sums[i][j - size - size] == size and col_sums[i - size][j] - col_sums[i - size - size][j] == size:\n                    max_size = size\n                size -= 1\n\n    return max_size * max_size", "solution_func": "def g() -> List[List[int]]:\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(matrix: List[List[int]], target: int) -> Tuple[int, int]:\n    \"\"\"\n    Given a matrix of integers and a target value, find the position (row and column indices) of the target value in the matrix.\n\n    Example:\n    Input: matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], target = 5\n    Output: (1, 1)\n    Explanation: The target value 5 is located at position (1, 1) in the matrix.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    # Perform a modified BFS using a queue\n    queue = [(0, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    visited[0][0] = True\n\n    while queue:\n        curr_row, curr_col = queue.pop(0)\n\n        if matrix[curr_row][curr_col] == target:\n            return curr_row, curr_col\n\n        # Explore adjacent cells\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_row = curr_row + dr\n            next_col = curr_col + dc\n\n            if 0 <= next_row < rows and 0 <= next_col < cols and not visited[next_row][next_col]:\n                queue.append((next_row, next_col))\n                visited[next_row][next_col] = True\n\n    return -1, -1\n\ndef g() -> Tuple[List[List[int]], int]:\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    target = 5\n    return matrix, target\n\nassert f(*g()) == (1, 1)\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 377, "target_skills": [0, 0, 1, 0, 0, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(matrix: List[List[int]], target: int) -> Tuple[int, int]:\n    \"\"\"\n    Given a matrix of integers and a target value, find the position (row and column indices) of the target value in the matrix.\n\n    Example:\n    Input: matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], target = 5\n    Output: (1, 1)\n    Explanation: The target value 5 is located at position (1, 1) in the matrix.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    # Perform a modified BFS using a queue\n    queue = [(0, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    visited[0][0] = True\n\n    while queue:\n        curr_row, curr_col = queue.pop(0)\n\n        if matrix[curr_row][curr_col] == target:\n            return curr_row, curr_col\n\n        # Explore adjacent cells\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_row = curr_row + dr\n            next_col = curr_col + dc\n\n            if 0 <= next_row < rows and 0 <= next_col < cols and not visited[next_row][next_col]:\n                queue.append((next_row, next_col))\n                visited[next_row][next_col] = True\n\n    return -1, -1", "solution_func": "def g() -> Tuple[List[List[int]], int]:\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    target = 5\n    return matrix, target", "map_ix": [0, 0, 1, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of heights, calculate the number of consecutive blocks for each height where all the blocks have a height greater than or equal to the current height.\n\n    Example:\n    Input: heights = [3, 5, 2, 4, 6, 1]\n    Output: [1, 2, 1, 3, 6, 1]\n    Explanation: The first height 3 has 1 consecutive block, the second height 5 has 2 consecutive blocks, and so on.\n    \"\"\"\n    n = len(heights)\n    result = [1] * n\n\n    # Calculate the number of consecutive blocks for each height\n    for i in range(n):\n        j = i - 1\n        while j >= 0 and heights[j] >= heights[i]:\n            result[i] += result[j]\n            j -= result[j]\n\n    return result\n\ndef g() -> List[int]:\n    heights = [3, 5, 2, 4, 6, 1]\n    return heights\n\nassert f(g()) == [1, 2, 1, 3, 6, 1]\n", "emb": null, "idx_generation": 377, "target_skills": [1, 1, 1, 1, 1, 1, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of heights, calculate the number of consecutive blocks for each height where all the blocks have a height greater than or equal to the current height.\n\n    Example:\n    Input: heights = [3, 5, 2, 4, 6, 1]\n    Output: [1, 2, 1, 3, 6, 1]\n    Explanation: The first height 3 has 1 consecutive block, the second height 5 has 2 consecutive blocks, and so on.\n    \"\"\"\n    n = len(heights)\n    result = [1] * n\n\n    # Calculate the number of consecutive blocks for each height\n    for i in range(n):\n        j = i - 1\n        while j >= 0 and heights[j] >= heights[i]:\n            result[i] += result[j]\n            j -= result[j]\n\n    return result", "solution_func": "def g() -> List[int]:\n    heights = [3, 5, 2, 4, 6, 1]\n    return heights", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(adjacency: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix of a directed graph, determine if there is a cycle in the graph.\n    Return True if there is a cycle, False otherwise.\n\n    Example:\n    Input: adjacency = [[0, 1, 0], [0, 0, 1], [1, 0, 0]]\n    Output: True\n\n    Explanation:\n    The given adjacency matrix represents the following directed graph:\n    0 -> 1 -> 2 -> 0\n    There is a cycle in the graph, so the output is True.\n    \"\"\"\n    stack = []\n    visited = set()\n\n    def dfs(node):\n        if node in visited:\n            return True\n\n        visited.add(node)\n        stack.append(node)\n\n        for neighbor in range(len(adjacency)):\n            if adjacency[node][neighbor] == 1 and dfs(neighbor):\n                return True\n\n        stack.remove(node)\n        return False\n\n    for node in range(len(adjacency)):\n        if node not in visited and dfs(node):\n            return True\n\n    return False\n\ndef g(adjacency = [[0, 1, 0], [0, 0, 1], [1, 0, 0]]):\n    return adjacency\n\nassert f(g())\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 377, "target_skills": [0, 1, 1, 0, 0, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(adjacency: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix of a directed graph, determine if there is a cycle in the graph.\n    Return True if there is a cycle, False otherwise.\n\n    Example:\n    Input: adjacency = [[0, 1, 0], [0, 0, 1], [1, 0, 0]]\n    Output: True\n\n    Explanation:\n    The given adjacency matrix represents the following directed graph:\n    0 -> 1 -> 2 -> 0\n    There is a cycle in the graph, so the output is True.\n    \"\"\"\n    stack = []\n    visited = set()\n\n    def dfs(node):\n        if node in visited:\n            return True\n\n        visited.add(node)\n        stack.append(node)\n\n        for neighbor in range(len(adjacency)):\n            if adjacency[node][neighbor] == 1 and dfs(neighbor):\n                return True\n\n        stack.remove(node)\n        return False\n\n    for node in range(len(adjacency)):\n        if node not in visited and dfs(node):\n            return True\n\n    return False", "solution_func": "def g(adjacency = [[0, 1, 0], [0, 0, 1], [1, 0, 0]]):\n    return adjacency", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string containing only characters '(', ')', '{', '}', '[' and ']',\n    determine if the input string is valid.\n\n    An input string is valid if:\n    1. Open brackets must be closed by the same type of brackets.\n    2. Open brackets must be closed in the correct order.\n\n    Return 1 if the string is valid, 0 otherwise.\n\n    Example:\n    Input: s = \"(([]))\"\n    Output: 1\n\n    Explanation:\n    The input string contains only valid brackets, so the output is 1.\n    \"\"\"\n    stack = []\n    brackets = {\n        ')': '(',\n        '}': '{',\n        ']': '['\n    }\n\n    for char in s:\n        if char in brackets.values():\n            stack.append(char)\n        elif char in brackets:\n            if not stack or brackets[char] != stack.pop():\n                return 0\n\n    return 1 if not stack else 0\n\ndef g(s = \"(([]))\"):\n    return s\n\nassert f(g())\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 377, "target_skills": [1, 0, 0, 1, 1, 1, 1, 1, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string containing only characters '(', ')', '{', '}', '[' and ']',\n    determine if the input string is valid.\n\n    An input string is valid if:\n    1. Open brackets must be closed by the same type of brackets.\n    2. Open brackets must be closed in the correct order.\n\n    Return 1 if the string is valid, 0 otherwise.\n\n    Example:\n    Input: s = \"(([]))\"\n    Output: 1\n\n    Explanation:\n    The input string contains only valid brackets, so the output is 1.\n    \"\"\"\n    stack = []\n    brackets = {\n        ')': '(',\n        '}': '{',\n        ']': '['\n    }\n\n    for char in s:\n        if char in brackets.values():\n            stack.append(char)\n        elif char in brackets:\n            if not stack or brackets[char] != stack.pop():\n                return 0\n\n    return 1 if not stack else 0", "solution_func": "def g(s = \"(([]))\"):\n    return s", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers 'nums' and an integer 'target',\n    find two numbers such that they add up to 'target'.\n\n    Return the indices of the two numbers in the array.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation:\n    The sum of nums[0] and nums[1] is 2 + 7 = 9, which is equal to the target.\n    The indices of the two numbers are 0 and 1.\n    \"\"\"\n    complement_map = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complement_map:\n            return [complement_map[complement], i]\n        complement_map[num] = i\n\n    return []\n\ndef g(nums = [2, 7, 11, 15], target = 9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0], "idx_generation": 377, "target_skills": [1, 0, 0, 0, 0, 1, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers 'nums' and an integer 'target',\n    find two numbers such that they add up to 'target'.\n\n    Return the indices of the two numbers in the array.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation:\n    The sum of nums[0] and nums[1] is 2 + 7 = 9, which is equal to the target.\n    The indices of the two numbers are 0 and 1.\n    \"\"\"\n    complement_map = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complement_map:\n            return [complement_map[complement], i]\n        complement_map[num] = i\n\n    return []", "solution_func": "def g(nums = [2, 7, 11, 15], target = 9):\n    return nums, target", "map_ix": [1, 1, 0, 1, 0, 1, 0, 1, 1, 1]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, sort the list in descending order based on the sum of the digits of each number.\n\n    Example:\n    nums = [123, 45, 67, 89, 12]\n\n    Output:\n    [123, 67, 45, 89, 12]\n\n    Explanation:\n    The sum of the digits of [123, 67, 45, 89, 12] are [6, 13, 9, 17, 3] respectively.\n    Therefore, the sorted list in descending order would be [123, 67, 45, 89, 12].\n    \"\"\"\n\n    def sum_of_digits(num: int) -> int:\n        \"\"\"\n        Calculate the sum of the digits of a number.\n        \"\"\"\n        total = 0\n        while num > 0:\n            total += num % 10\n            num //= 10\n        return total\n\n    nums.sort(key=sum_of_digits, reverse=True)\n    return nums\n\ndef g(nums: List[int]):\n    return nums\n\nassert f(g([123, 45, 67, 89, 12])) == [123, 67, 45, 89, 12]\n", "emb": null, "idx_generation": 377, "target_skills": [0, 1, 0, 0, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, sort the list in descending order based on the sum of the digits of each number.\n\n    Example:\n    nums = [123, 45, 67, 89, 12]\n\n    Output:\n    [123, 67, 45, 89, 12]\n\n    Explanation:\n    The sum of the digits of [123, 67, 45, 89, 12] are [6, 13, 9, 17, 3] respectively.\n    Therefore, the sorted list in descending order would be [123, 67, 45, 89, 12].\n    \"\"\"\n\n    def sum_of_digits(num: int) -> int:\n        \"\"\"\n        Calculate the sum of the digits of a number.\n        \"\"\"\n        total = 0\n        while num > 0:\n            total += num % 10\n            num //= 10\n        return total\n\n    nums.sort(key=sum_of_digits, reverse=True)\n    return nums", "solution_func": "def g(nums: List[int]):\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of ways to represent n as a sum of powers of 2.\n\n    Example:\n    n = 5\n\n    Output:\n    2\n\n    Explanation:\n    5 can be represented as the sum of powers of 2 in two ways: 2 + 2 + 1 and 4 + 1.\n    \"\"\"\n\n    def count_ways(n: int, i: int) -> int:\n        \"\"\"\n        Count the number of ways to represent n as a sum of powers of 2, starting from the i-th power of 2.\n        \"\"\"\n        if n == 0:\n            return 1\n\n        if n < 0 or i < 0:\n            return 0\n\n        return count_ways(n - (2 ** i), i - 1) + count_ways(n, i - 1)\n\n    return count_ways(n, n.bit_length() - 1)\n\ndef g(n: int):\n    return n\n\nassert f(g(5)) == 2\n", "emb": null, "idx_generation": 377, "target_skills": [0, 1, 0, 0, 0, 1, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of ways to represent n as a sum of powers of 2.\n\n    Example:\n    n = 5\n\n    Output:\n    2\n\n    Explanation:\n    5 can be represented as the sum of powers of 2 in two ways: 2 + 2 + 1 and 4 + 1.\n    \"\"\"\n\n    def count_ways(n: int, i: int) -> int:\n        \"\"\"\n        Count the number of ways to represent n as a sum of powers of 2, starting from the i-th power of 2.\n        \"\"\"\n        if n == 0:\n            return 1\n\n        if n < 0 or i < 0:\n            return 0\n\n        return count_ways(n - (2 ** i), i - 1) + count_ways(n, i - 1)\n\n    return count_ways(n, n.bit_length() - 1)", "solution_func": "def g(n: int):\n    return n", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid consisting of 0s and 1s, find the number of islands in the grid.\n    An island is a group of connected 1s formed by horizontally or vertically adjacent cells.\n\n    Example:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n\n    Output:\n    3\n\n    Explanation:\n    There are 3 islands in the grid.\n    \"\"\"\n\n    def dfs(row: int, col: int) -> None:\n        \"\"\"\n        Perform depth-first search (DFS) to mark the cells of an island as visited.\n        \"\"\"\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] != 1:\n            return\n\n        grid[row][col] = -1\n\n        dfs(row - 1, col)  # up\n        dfs(row + 1, col)  # down\n        dfs(row, col - 1)  # left\n        dfs(row, col + 1)  # right\n\n    count = 0\n\n    for row in range(len(grid)):\n        for col in range(len(grid[0])):\n            if grid[row][col] == 1:\n                dfs(row, col)\n                count += 1\n\n    return count\n\ndef g(grid: List[List[int]]):\n    return grid\n\nassert f(g([\n    [1, 1, 0, 0, 0],\n    [1, 1, 0, 0, 0],\n    [0, 0, 1, 0, 0],\n    [0, 0, 0, 1, 1]\n])) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 377, "target_skills": [1, 0, 0, 0, 1, 1, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid consisting of 0s and 1s, find the number of islands in the grid.\n    An island is a group of connected 1s formed by horizontally or vertically adjacent cells.\n\n    Example:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n\n    Output:\n    3\n\n    Explanation:\n    There are 3 islands in the grid.\n    \"\"\"\n\n    def dfs(row: int, col: int) -> None:\n        \"\"\"\n        Perform depth-first search (DFS) to mark the cells of an island as visited.\n        \"\"\"\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] != 1:\n            return\n\n        grid[row][col] = -1\n\n        dfs(row - 1, col)  # up\n        dfs(row + 1, col)  # down\n        dfs(row, col - 1)  # left\n        dfs(row, col + 1)  # right\n\n    count = 0\n\n    for row in range(len(grid)):\n        for col in range(len(grid[0])):\n            if grid[row][col] == 1:\n                dfs(row, col)\n                count += 1\n\n    return count", "solution_func": "def g(grid: List[List[int]]):\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if they are isomorphic.\n    Two strings are isomorphic if the characters in s can be replaced to get t.\n\n    Example:\n    s = \"egg\"\n    t = \"add\"\n\n    Output:\n    True\n\n    Explanation:\n    The character 'e' in s is replaced with 'a' in t, and the character 'g' in s is replaced with 'd' in t.\n    Therefore, the strings are isomorphic.\n    \"\"\"\n    if len(s) != len(t):\n        return False\n\n    mapping = {}\n    used_chars = set()\n\n    for i in range(len(s)):\n        if s[i] not in mapping:\n            if t[i] in used_chars:\n                return False\n            mapping[s[i]] = t[i]\n            used_chars.add(t[i])\n        else:\n            if mapping[s[i]] != t[i]:\n                return False\n\n    return True\n\ndef g():\n    s = \"egg\"\n    t = \"add\"\n    return s, t\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 377, "target_skills": [0, 1, 0, 1, 0, 1, 1, 1, 1, 0], "problem_func": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if they are isomorphic.\n    Two strings are isomorphic if the characters in s can be replaced to get t.\n\n    Example:\n    s = \"egg\"\n    t = \"add\"\n\n    Output:\n    True\n\n    Explanation:\n    The character 'e' in s is replaced with 'a' in t, and the character 'g' in s is replaced with 'd' in t.\n    Therefore, the strings are isomorphic.\n    \"\"\"\n    if len(s) != len(t):\n        return False\n\n    mapping = {}\n    used_chars = set()\n\n    for i in range(len(s)):\n        if s[i] not in mapping:\n            if t[i] in used_chars:\n                return False\n            mapping[s[i]] = t[i]\n            used_chars.add(t[i])\n        else:\n            if mapping[s[i]] != t[i]:\n                return False\n\n    return True", "solution_func": "def g():\n    s = \"egg\"\n    t = \"add\"\n    return s, t", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers 'arr' and a target integer 'target', find two numbers in the list that sum up to the target.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    arr = [2, 4, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 2]\n\n    Explanation:\n    The numbers at indices 0 and 2 ([2, 7]) sum up to 9.\n\n    Hint: Use two pointers to find the two numbers that sum up to the target.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g(arr=[2, 4, 7, 11, 15], target=9):\n    return arr, target\n\nassert f(*g()) == [0, 2]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 378, "target_skills": [1, 1, 0, 0, 1, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers 'arr' and a target integer 'target', find two numbers in the list that sum up to the target.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    arr = [2, 4, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 2]\n\n    Explanation:\n    The numbers at indices 0 and 2 ([2, 7]) sum up to 9.\n\n    Hint: Use two pointers to find the two numbers that sum up to the target.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g(arr=[2, 4, 7, 11, 15], target=9):\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer 'n', find the number of ways to arrange 'n' distinct objects in a row, subject to certain restrictions.\n    The restrictions are:\n    - The first object must be placed at one of the ends.\n    - The second object must be placed next to the first object.\n\n    Return the number of possible arrangements.\n\n    Example:\n    n = 3\n\n    Output:\n    2\n\n    Explanation:\n    The possible arrangements are: [1, 2, 3] and [3, 2, 1].\n\n    Hint: Use combinatorics to calculate the number of arrangements.\n    \"\"\"\n    if n <= 2:\n        return n\n\n    return 2\n\ndef g(n=3):\n    return n\n\nassert f(g()) == 2\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 378, "target_skills": [1, 1, 0, 0, 0, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer 'n', find the number of ways to arrange 'n' distinct objects in a row, subject to certain restrictions.\n    The restrictions are:\n    - The first object must be placed at one of the ends.\n    - The second object must be placed next to the first object.\n\n    Return the number of possible arrangements.\n\n    Example:\n    n = 3\n\n    Output:\n    2\n\n    Explanation:\n    The possible arrangements are: [1, 2, 3] and [3, 2, 1].\n\n    Hint: Use combinatorics to calculate the number of arrangements.\n    \"\"\"\n    if n <= 2:\n        return n\n\n    return 2", "solution_func": "def g(n=3):\n    return n", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums', find the next greater element for each element in the list.\n    The next greater element for an element x is the first greater element to its right in the list.\n    If there is no such element, consider it as -1.\n\n    Return a list of the next greater elements.\n\n    Example:\n    nums = [4, 5, 2, 25]\n\n    Output:\n    [5, 25, 25, -1]\n\n    Explanation:\n    For the element 4, the next greater element is 5.\n    For the element 5, the next greater element is 25.\n    For the element 2, there is no greater element to its right, so it is -1.\n    For the element 25, there is no greater element to its right, so it is -1.\n\n    Hint: Use a stack to keep track of the next greater elements.\n    \"\"\"\n    stack = []\n    result = [-1] * len(nums)\n\n    for i in range(len(nums)):\n        while stack and nums[i] > nums[stack[-1]]:\n            index = stack.pop()\n            result[index] = nums[i]\n        stack.append(i)\n\n    return result\n\ndef g(nums=[4, 5, 2, 25]):\n    return nums\n\nassert f(g()) == [5, 25, 25, -1]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 378, "target_skills": [1, 1, 1, 1, 1, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums', find the next greater element for each element in the list.\n    The next greater element for an element x is the first greater element to its right in the list.\n    If there is no such element, consider it as -1.\n\n    Return a list of the next greater elements.\n\n    Example:\n    nums = [4, 5, 2, 25]\n\n    Output:\n    [5, 25, 25, -1]\n\n    Explanation:\n    For the element 4, the next greater element is 5.\n    For the element 5, the next greater element is 25.\n    For the element 2, there is no greater element to its right, so it is -1.\n    For the element 25, there is no greater element to its right, so it is -1.\n\n    Hint: Use a stack to keep track of the next greater elements.\n    \"\"\"\n    stack = []\n    result = [-1] * len(nums)\n\n    for i in range(len(nums)):\n        while stack and nums[i] > nums[stack[-1]]:\n            index = stack.pop()\n            result[index] = nums[i]\n        stack.append(i)\n\n    return result", "solution_func": "def g(nums=[4, 5, 2, 25]):\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a contiguous subarray.\n\n    Sample Input:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Sample Output:\n    6\n    Explanation: The contiguous subarray [4, -1, 2, 1] has the maximum sum of 6.\n\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(current_sum + num, num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 378, "target_skills": [0, 0, 1, 0, 1, 1, 0, 0, 0, 1], "problem_func": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a contiguous subarray.\n\n    Sample Input:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Sample Output:\n    6\n    Explanation: The contiguous subarray [4, -1, 2, 1] has the maximum sum of 6.\n\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(current_sum + num, num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum", "solution_func": "def g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, calculate the number of unique paths from the top-left corner to the bottom-right corner of a n x n grid.\n    You can only move either down or right at any point in time.\n\n    Sample Input:\n    n = 3\n\n    Sample Output:\n    6\n    Explanation: In a 3x3 grid, there are 6 unique paths from the top-left corner to the bottom-right corner.\n\n    \"\"\"\n    def unique_paths_helper(i: int, j: int, memo: Dict[Tuple[int, int], int]) -> int:\n        if i == 0 or j == 0:\n            return 1\n        if (i, j) in memo:\n            return memo[(i, j)]\n        memo[(i, j)] = unique_paths_helper(i-1, j, memo) + unique_paths_helper(i, j-1, memo)\n        return memo[(i, j)]\n    \n    memo = {}\n    return unique_paths_helper(n-1, n-1, memo)\n\ndef g() -> int:\n    n = 3\n    return n\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 378, "target_skills": [1, 1, 0, 1, 0, 0, 0, 0, 0, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, calculate the number of unique paths from the top-left corner to the bottom-right corner of a n x n grid.\n    You can only move either down or right at any point in time.\n\n    Sample Input:\n    n = 3\n\n    Sample Output:\n    6\n    Explanation: In a 3x3 grid, there are 6 unique paths from the top-left corner to the bottom-right corner.\n\n    \"\"\"\n    def unique_paths_helper(i: int, j: int, memo: Dict[Tuple[int, int], int]) -> int:\n        if i == 0 or j == 0:\n            return 1\n        if (i, j) in memo:\n            return memo[(i, j)]\n        memo[(i, j)] = unique_paths_helper(i-1, j, memo) + unique_paths_helper(i, j-1, memo)\n        return memo[(i, j)]\n    \n    memo = {}\n    return unique_paths_helper(n-1, n-1, memo)", "solution_func": "def g() -> int:\n    n = 3\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find the next greater element for each element in the list.\n    The next greater element for an element x is the first greater element to its right, or -1 if there is no such element.\n\n    Sample Input:\n    nums = [4, 5, 2, 25]\n\n    Sample Output:\n    [5, 25, 25, -1]\n    Explanation: The next greater element for 4 is 5, for 5 is 25, for 2 is 25, and there is no greater element for 25.\n\n    \"\"\"\n    stack = []\n    result = [-1] * len(nums)\n    for i in range(len(nums)-1, -1, -1):\n        while stack and nums[i] >= stack[-1]:\n            stack.pop()\n        if stack:\n            result[i] = stack[-1]\n        stack.append(nums[i])\n    return result\n\ndef g() -> List[int]:\n    nums = [4, 5, 2, 25]\n    return nums\n\nassert f(g()) == [5, 25, 25, -1]\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 378, "target_skills": [0, 0, 1, 0, 0, 1, 1, 0, 0, 1], "problem_func": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find the next greater element for each element in the list.\n    The next greater element for an element x is the first greater element to its right, or -1 if there is no such element.\n\n    Sample Input:\n    nums = [4, 5, 2, 25]\n\n    Sample Output:\n    [5, 25, 25, -1]\n    Explanation: The next greater element for 4 is 5, for 5 is 25, for 2 is 25, and there is no greater element for 25.\n\n    \"\"\"\n    stack = []\n    result = [-1] * len(nums)\n    for i in range(len(nums)-1, -1, -1):\n        while stack and nums[i] >= stack[-1]:\n            stack.pop()\n        if stack:\n            result[i] = stack[-1]\n        stack.append(nums[i])\n    return result", "solution_func": "def g() -> List[int]:\n    nums = [4, 5, 2, 25]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a subarray whose sum is equal to the product of its elements.\n    \"\"\"\n    total_sum = sum(nums)\n\n    for i in range(len(nums)):\n        product = 1\n        for j in range(i, len(nums)):\n            product *= nums[j]\n            if product == total_sum:\n                return True\n\n    return False\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g())\n\n", "emb": null, "idx_generation": 378, "target_skills": [0, 1, 0, 0, 0, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a subarray whose sum is equal to the product of its elements.\n    \"\"\"\n    total_sum = sum(nums)\n\n    for i in range(len(nums)):\n        product = 1\n        for j in range(i, len(nums)):\n            product *= nums[j]\n            if product == total_sum:\n                return True\n\n    return False", "solution_func": "def g(nums: List[int] = [1, 2, 3, 4, 5]):\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(string: str) -> str:\n    \"\"\"\n    Given a string, find and return the longest substring that contains only unique characters.\n    \"\"\"\n    max_length = 0\n    start = 0\n    max_start = 0\n    char_map = {}\n\n    for i in range(len(string)):\n        if string[i] in char_map and start <= char_map[string[i]]:\n            start = char_map[string[i]] + 1\n        else:\n            if i - start + 1 > max_length:\n                max_length = i - start + 1\n                max_start = start\n        char_map[string[i]] = i\n\n    return string[max_start:max_start+max_length]\n\ndef g(string: str = \"abcabcbb\"):\n    return string\n\nassert f(g()) == \"abc\"\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 378, "target_skills": [1, 0, 0, 0, 1, 1, 1, 0, 0, 1], "problem_func": "from typing import*\ndef f(string: str) -> str:\n    \"\"\"\n    Given a string, find and return the longest substring that contains only unique characters.\n    \"\"\"\n    max_length = 0\n    start = 0\n    max_start = 0\n    char_map = {}\n\n    for i in range(len(string)):\n        if string[i] in char_map and start <= char_map[string[i]]:\n            start = char_map[string[i]] + 1\n        else:\n            if i - start + 1 > max_length:\n                max_length = i - start + 1\n                max_start = start\n        char_map[string[i]] = i\n\n    return string[max_start:max_start+max_length]", "solution_func": "def g(string: str = \"abcabcbb\"):\n    return string", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(words: List[str], pattern: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a pattern, find all words in the list that follow the same pattern as the given pattern.\n    A word follows the pattern if there is a one-to-one mapping of characters between the word and the pattern.\n    \"\"\"\n    def match_pattern(word: str, pattern: str) -> bool:\n        if len(word) != len(pattern):\n            return False\n\n        word_to_pattern = {}\n        pattern_to_word = {}\n\n        for i in range(len(word)):\n            if word[i] in word_to_pattern and word_to_pattern[word[i]] != pattern[i]:\n                return False\n            if pattern[i] in pattern_to_word and pattern_to_word[pattern[i]] != word[i]:\n                return False\n\n            word_to_pattern[word[i]] = pattern[i]\n            pattern_to_word[pattern[i]] = word[i]\n\n        return True\n\n    matched_words = []\n\n    for word in words:\n        if match_pattern(word, pattern):\n            matched_words.append(word)\n\n    return matched_words\n\ndef g(words: List[str] = [\"abc\", \"def\", \"ghi\", \"jkl\"], pattern: str = \"xyz\"):\n    return words, pattern\n\nassert f(*g()) == []\n\n", "emb": null, "idx_generation": 378, "target_skills": [1, 0, 0, 1, 1, 1, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(words: List[str], pattern: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a pattern, find all words in the list that follow the same pattern as the given pattern.\n    A word follows the pattern if there is a one-to-one mapping of characters between the word and the pattern.\n    \"\"\"\n    def match_pattern(word: str, pattern: str) -> bool:\n        if len(word) != len(pattern):\n            return False\n\n        word_to_pattern = {}\n        pattern_to_word = {}\n\n        for i in range(len(word)):\n            if word[i] in word_to_pattern and word_to_pattern[word[i]] != pattern[i]:\n                return False\n            if pattern[i] in pattern_to_word and pattern_to_word[pattern[i]] != word[i]:\n                return False\n\n            word_to_pattern[word[i]] = pattern[i]\n            pattern_to_word[pattern[i]] = word[i]\n\n        return True\n\n    matched_words = []\n\n    for word in words:\n        if match_pattern(word, pattern):\n            matched_words.append(word)\n\n    return matched_words", "solution_func": "def g(words: List[str] = [\"abc\", \"def\", \"ghi\", \"jkl\"], pattern: str = \"xyz\"):\n    return words, pattern", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\nclass Node:\n    def __init__(self, val: int):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef f(root: Node, target: int) -> bool:\n    \"\"\"\n    Given the root of a binary tree and a target number,\n    determine if there exists a path from the root to any leaf node\n    that sums up to the target.\n    \"\"\"\n    def dfs(node: Node, curr_sum: int) -> bool:\n        if not node:\n            return False\n        curr_sum += node.val\n        if not node.left and not node.right: # leaf node\n            return curr_sum == target\n        return dfs(node.left, curr_sum) or dfs(node.right, curr_sum)\n\n    return dfs(root, 0)\n\n\ndef g() -> Tuple[Node, int]:\n    \"\"\"\n    Generate a binary tree and a target number.\n    \"\"\"\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n    target = 9\n    return root, target\n\n\nassert f(*g()) == True\n\n", "emb": null, "idx_generation": 378, "target_skills": [1, 0, 1, 0, 0, 1, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\nclass Node:\n    def __init__(self, val: int):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef f(root: Node, target: int) -> bool:\n    \"\"\"\n    Given the root of a binary tree and a target number,\n    determine if there exists a path from the root to any leaf node\n    that sums up to the target.\n    \"\"\"\n    def dfs(node: Node, curr_sum: int) -> bool:\n        if not node:\n            return False\n        curr_sum += node.val\n        if not node.left and not node.right: # leaf node\n            return curr_sum == target\n        return dfs(node.left, curr_sum) or dfs(node.right, curr_sum)\n\n    return dfs(root, 0)", "solution_func": "def g() -> Tuple[Node, int]:\n    \"\"\"\n    Generate a binary tree and a target number.\n    \"\"\"\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n    target = 9\n    return root, target", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct pairs that sum up to a target value.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 6\n\n    Output:\n    2\n\n    Explanation:\n    The distinct pairs that sum up to the target value are (1, 5) and (2, 4).\n\n    Hint: Use a set to keep track of the complement of each element in the list.\n    \"\"\"\n\n    count = 0\n    complements = set()\n    for num in arr:\n        complement = target - num\n        if complement in complements:\n            count += 1\n        complements.add(num)\n    return count\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 2\n", "emb": null, "idx_generation": 379, "target_skills": [0, 1, 0, 0, 0, 1, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct pairs that sum up to a target value.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 6\n\n    Output:\n    2\n\n    Explanation:\n    The distinct pairs that sum up to the target value are (1, 5) and (2, 4).\n\n    Hint: Use a set to keep track of the complement of each element in the list.\n    \"\"\"\n\n    count = 0\n    complements = set()\n    for num in arr:\n        complement = target - num\n        if complement in complements:\n            count += 1\n        complements.add(num)\n    return count", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3, 4, 5]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome when only alphanumeric characters are considered.\n\n    Example:\n    s = \"A man, a plan, a canal: Panama\"\n\n    Output:\n    True\n\n    Explanation:\n    The string \"A man, a plan, a canal: Panama\" is a palindrome when only alphanumeric characters are considered.\n\n    Hint: Use two pointers to compare characters from the beginning and end of the string.\n    \"\"\"\n\n    left = 0\n    right = len(s) - 1\n\n    while left < right:\n        while left < right and not s[left].isalnum():\n            left += 1\n        while left < right and not s[right].isalnum():\n            right -= 1\n\n        if s[left].lower() != s[right].lower():\n            return False\n\n        left += 1\n        right -= 1\n\n    return True\n\ndef g() -> str:\n    return \"A man, a plan, a canal: Panama\"\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 379, "target_skills": [0, 0, 0, 0, 0, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome when only alphanumeric characters are considered.\n\n    Example:\n    s = \"A man, a plan, a canal: Panama\"\n\n    Output:\n    True\n\n    Explanation:\n    The string \"A man, a plan, a canal: Panama\" is a palindrome when only alphanumeric characters are considered.\n\n    Hint: Use two pointers to compare characters from the beginning and end of the string.\n    \"\"\"\n\n    left = 0\n    right = len(s) - 1\n\n    while left < right:\n        while left < right and not s[left].isalnum():\n            left += 1\n        while left < right and not s[right].isalnum():\n            right -= 1\n\n        if s[left].lower() != s[right].lower():\n            return False\n\n        left += 1\n        right -= 1\n\n    return True", "solution_func": "def g() -> str:\n    return \"A man, a plan, a canal: Panama\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The maximum sum of a path from the top-left corner to the bottom-right corner is 7 (1 + 3 + 1 + 1 + 1).\n\n    Hint: Use dynamic programming to keep track of the maximum sum at each position.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n", "emb": null, "idx_generation": 379, "target_skills": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The maximum sum of a path from the top-left corner to the bottom-right corner is 7 (1 + 3 + 1 + 1 + 1).\n\n    Hint: Use dynamic programming to keep track of the maximum sum at each position.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g() -> List[List[int]]:\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(s: str) -> int:\n    \"\"\"\n    Return the length of the longest valid parentheses substring in the given string.\n\n    Args:\n    - s: A string containing parentheses.\n\n    Returns:\n    - An integer representing the length of the longest valid parentheses substring.\n    \"\"\"\n    stack = [-1]\n    max_length = 0\n\n    for i in range(len(s)):\n        if s[i] == \"(\":\n            stack.append(i)\n        else:\n            stack.pop()\n            if stack:\n                max_length = max(max_length, i - stack[-1])\n            else:\n                stack.append(i)\n\n    return max_length\n\ndef g():\n    s = \"(()))()()())\"\n    return s\n\nassert f(g()) == 6\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 379, "target_skills": [0, 0, 1, 0, 0, 0, 1, 1, 1, 1], "problem_func": "from typing import*\n\ndef f(s: str) -> int:\n    \"\"\"\n    Return the length of the longest valid parentheses substring in the given string.\n\n    Args:\n    - s: A string containing parentheses.\n\n    Returns:\n    - An integer representing the length of the longest valid parentheses substring.\n    \"\"\"\n    stack = [-1]\n    max_length = 0\n\n    for i in range(len(s)):\n        if s[i] == \"(\":\n            stack.append(i)\n        else:\n            stack.pop()\n            if stack:\n                max_length = max(max_length, i - stack[-1])\n            else:\n                stack.append(i)\n\n    return max_length", "solution_func": "def g():\n    s = \"(()))()()())\"\n    return s", "map_ix": [1, 1, 0, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\n\ndef f(s: str) -> str:\n    \"\"\"\n    Remove the outermost parentheses of every primitive substring in the given string and return the modified string.\n\n    Args:\n    - s: A string containing parentheses.\n\n    Returns:\n    - A modified string with the outermost parentheses removed from every primitive substring.\n    \"\"\"\n    stack = []\n    result = \"\"\n\n    for i in range(len(s)):\n        if s[i] == \"(\":\n            stack.append(i)\n        else:\n            start = stack.pop()\n            if len(stack) == 0:\n                result += s[start+1:i]\n\n    return result\n\ndef g():\n    s = \"(()())(())\"\n    return s\n\nassert f(g()) == \"()()\"\n\n", "emb": null, "idx_generation": 379, "target_skills": [0, 1, 1, 0, 1, 1, 1, 1, 1, 0], "problem_func": "from typing import*\n\ndef f(s: str) -> str:\n    \"\"\"\n    Remove the outermost parentheses of every primitive substring in the given string and return the modified string.\n\n    Args:\n    - s: A string containing parentheses.\n\n    Returns:\n    - A modified string with the outermost parentheses removed from every primitive substring.\n    \"\"\"\n    stack = []\n    result = \"\"\n\n    for i in range(len(s)):\n        if s[i] == \"(\":\n            stack.append(i)\n        else:\n            start = stack.pop()\n            if len(stack) == 0:\n                result += s[start+1:i]\n\n    return result", "solution_func": "def g():\n    s = \"(()())(())\"\n    return s", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\n\ndef f(s: str) -> int:\n    \"\"\"\n    Return the minimum number of operations required to make the given string balanced.\n\n    Args:\n    - s: A string containing parentheses.\n\n    Returns:\n    - An integer representing the minimum number of operations required to make the string balanced.\n    \"\"\"\n    stack = []\n    operations = 0\n\n    for char in s:\n        if char == \"(\":\n            stack.append(char)\n        else:\n            if stack:\n                stack.pop()\n            else:\n                operations += 1\n\n    return operations + len(stack)\n\ndef g():\n    s = \"()())()()(\"\n    return s\n\nassert f(g()) == 4\n\n", "emb": null, "idx_generation": 379, "target_skills": [1, 0, 0, 0, 1, 0, 1, 1, 0, 1], "problem_func": "from typing import*\n\ndef f(s: str) -> int:\n    \"\"\"\n    Return the minimum number of operations required to make the given string balanced.\n\n    Args:\n    - s: A string containing parentheses.\n\n    Returns:\n    - An integer representing the minimum number of operations required to make the string balanced.\n    \"\"\"\n    stack = []\n    operations = 0\n\n    for char in s:\n        if char == \"(\":\n            stack.append(char)\n        else:\n            if stack:\n                stack.pop()\n            else:\n                operations += 1\n\n    return operations + len(stack)", "solution_func": "def g():\n    s = \"()())()()(\"\n    return s", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer 'n', return the number of ways to climb a staircase of 'n' steps.\n    You can climb either 1 or 2 steps at a time.\n    \n    Example:\n    n = 4\n    \n    Output:\n    5\n    \n    Explanation:\n    There are 5 ways to climb a staircase of 4 steps:\n    - 1 -> 1 -> 1 -> 1\n    - 1 -> 1 -> 2\n    - 1 -> 2 -> 1\n    - 2 -> 1 -> 1\n    - 2 -> 2\n    \"\"\"\n    if n <= 2:\n        return n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n + 1):\n        dp[i] = dp[i-1] + dp[i-2]\n    return dp[n]\n\ndef g(n: int = 4):\n    return n\n\nassert f(*g()) == 5\n", "emb": null, "idx_generation": 379, "target_skills": [0, 0, 0, 1, 0, 1, 1, 1, 0, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer 'n', return the number of ways to climb a staircase of 'n' steps.\n    You can climb either 1 or 2 steps at a time.\n    \n    Example:\n    n = 4\n    \n    Output:\n    5\n    \n    Explanation:\n    There are 5 ways to climb a staircase of 4 steps:\n    - 1 -> 1 -> 1 -> 1\n    - 1 -> 1 -> 2\n    - 1 -> 2 -> 1\n    - 2 -> 1 -> 1\n    - 2 -> 2\n    \"\"\"\n    if n <= 2:\n        return n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n + 1):\n        dp[i] = dp[i-1] + dp[i-2]\n    return dp[n]", "solution_func": "def g(n: int = 4):\n    return n", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer 'n', return the number of unique paths to reach the bottom right corner of a 'n x n' grid\n    starting from the top left corner. You can only move down or right.\n    \n    Example:\n    n = 3\n    \n    Output:\n    6\n    \n    Explanation:\n    There are 6 unique paths to reach the bottom right corner of a 3x3 grid:\n    - Right -> Right -> Down -> Down\n    - Right -> Down -> Right -> Down\n    - Right -> Down -> Down -> Right\n    - Down -> Right -> Right -> Down\n    - Down -> Right -> Down -> Right\n    - Down -> Down -> Right -> Right\n    \"\"\"\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][0] = 1\n        dp[0][i] = 1\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    return dp[n-1][n-1]\n\ndef g(n: int = 3):\n    return n\n\nassert f(*g()) == 6\n", "emb": null, "idx_generation": 379, "target_skills": [1, 1, 1, 1, 1, 0, 0, 1, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer 'n', return the number of unique paths to reach the bottom right corner of a 'n x n' grid\n    starting from the top left corner. You can only move down or right.\n    \n    Example:\n    n = 3\n    \n    Output:\n    6\n    \n    Explanation:\n    There are 6 unique paths to reach the bottom right corner of a 3x3 grid:\n    - Right -> Right -> Down -> Down\n    - Right -> Down -> Right -> Down\n    - Right -> Down -> Down -> Right\n    - Down -> Right -> Right -> Down\n    - Down -> Right -> Down -> Right\n    - Down -> Down -> Right -> Right\n    \"\"\"\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][0] = 1\n        dp[0][i] = 1\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    return dp[n-1][n-1]", "solution_func": "def g(n: int = 3):\n    return n", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer 'n', return the number of unique BSTs (binary search trees) that can be constructed\n    with 'n' nodes labeled from 1 to n.\n    \n    Example:\n    n = 3\n    \n    Output:\n    5\n    \n    Explanation:\n    There are 5 unique BSTs that can be constructed with 3 nodes:\n    \n        1         3     3      2      1\n         \\       /     /      / \\      \\\n          3     2     1      1   3      2\n         /     /       \\                 \\\n        2     1         2                 3\n    \"\"\"\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(1, i + 1):\n            dp[i] += dp[j - 1] * dp[i - j]\n    return dp[n]\n\ndef g(n: int = 3):\n    return n\n\nassert f(*g()) == 5\n", "emb": null, "idx_generation": 379, "target_skills": [1, 0, 0, 0, 0, 0, 1, 0, 0, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer 'n', return the number of unique BSTs (binary search trees) that can be constructed\n    with 'n' nodes labeled from 1 to n.\n    \n    Example:\n    n = 3\n    \n    Output:\n    5\n    \n    Explanation:\n    There are 5 unique BSTs that can be constructed with 3 nodes:\n    \n        1         3     3      2      1\n         \\       /     /      / \\      \\\n          3     2     1      1   3      2\n         /     /       \\                 \\\n        2     1         2                 3\n    \"\"\"\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(1, i + 1):\n            dp[i] += dp[j - 1] * dp[i - j]\n    return dp[n]", "solution_func": "def g(n: int = 3):\n    return n", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> List[int]:\n    \"\"\"\n    Given a graph represented as an adjacency matrix and two nodes, find a path from the start node to the end node.\n\n    Args:\n    - graph: The adjacency matrix representing the graph.\n    - start: The starting node.\n    - end: The ending node.\n\n    Returns:\n    - A list of nodes representing the path from the start node to the end node.\n    \"\"\"\n    visited = set()\n    path = []\n\n    def dfs(node):\n        visited.add(node)\n        path.append(node)\n\n        if node == end:\n            return True\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n\n        path.pop()\n        return False\n\n    dfs(start)\n    return path\n\ndef g() -> Tuple[List[List[int]], int, int]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    graph = [[0, 1, 1, 0],\n             [1, 0, 0, 1],\n             [1, 0, 0, 1],\n             [0, 1, 1, 0]]\n\n    start = 0\n    end = 3\n\n    return graph, start, end\n\nassert f(*g()) == [0, 1, 3]\n", "emb": null, "idx_generation": 379, "target_skills": [1, 1, 1, 1, 1, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> List[int]:\n    \"\"\"\n    Given a graph represented as an adjacency matrix and two nodes, find a path from the start node to the end node.\n\n    Args:\n    - graph: The adjacency matrix representing the graph.\n    - start: The starting node.\n    - end: The ending node.\n\n    Returns:\n    - A list of nodes representing the path from the start node to the end node.\n    \"\"\"\n    visited = set()\n    path = []\n\n    def dfs(node):\n        visited.add(node)\n        path.append(node)\n\n        if node == end:\n            return True\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n\n        path.pop()\n        return False\n\n    dfs(start)\n    return path", "solution_func": "def g() -> Tuple[List[List[int]], int, int]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    graph = [[0, 1, 1, 0],\n             [1, 0, 0, 1],\n             [1, 0, 0, 1],\n             [0, 1, 1, 0]]\n\n    start = 0\n    end = 3\n\n    return graph, start, end", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Grid Paths\n\n    Given a grid of size n x n, starting from the top-left corner, you can only move right or down.\n    Find the number of unique paths to reach the bottom-right corner from the top-left corner.\n\n    Example:\n    n = 3\n    output: 6\n    Explanation: There are 6 unique paths to reach the bottom-right corner:\n    R -> R -> D -> D\n    R -> D -> R -> D\n    R -> D -> D -> R\n    D -> R -> R -> D\n    D -> R -> D -> R\n    D -> D -> R -> R\n    \"\"\"\n    def count_paths(i: int, j: int, n: int) -> int:\n        if i == n-1 and j == n-1:\n            return 1\n        if i >= n or j >= n:\n            return 0\n        return count_paths(i+1, j, n) + count_paths(i, j+1, n)\n\n    return count_paths(0, 0, len(arr))\n\ndef g(n = 3):\n    return [1] * n\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 380, "target_skills": [1, 1, 0, 1, 0, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Grid Paths\n\n    Given a grid of size n x n, starting from the top-left corner, you can only move right or down.\n    Find the number of unique paths to reach the bottom-right corner from the top-left corner.\n\n    Example:\n    n = 3\n    output: 6\n    Explanation: There are 6 unique paths to reach the bottom-right corner:\n    R -> R -> D -> D\n    R -> D -> R -> D\n    R -> D -> D -> R\n    D -> R -> R -> D\n    D -> R -> D -> R\n    D -> D -> R -> R\n    \"\"\"\n    def count_paths(i: int, j: int, n: int) -> int:\n        if i == n-1 and j == n-1:\n            return 1\n        if i >= n or j >= n:\n            return 0\n        return count_paths(i+1, j, n) + count_paths(i, j+1, n)\n\n    return count_paths(0, 0, len(arr))", "solution_func": "def g(n = 3):\n    return [1] * n", "map_ix": [0, 0, 1, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> float:\n    \"\"\"\n    Harmonic Series\n\n    The harmonic series is the sum of the reciprocals of the positive integers.\n    The n-th harmonic number can be represented by the formula: Hn = 1/1 + 1/2 + 1/3 + ... + 1/n.\n\n    Given an integer n, calculate the n-th harmonic number.\n\n    Example:\n    n = 5\n    output: 2.283333333333333\n    \"\"\"\n    def harmonic(n: int) -> float:\n        if n == 1:\n            return 1\n        return 1/n + harmonic(n-1)\n\n    return harmonic(n)\n\ndef g(n = 5):\n    return n\n\nassert f(g()) == 2.283333333333333\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 380, "target_skills": [1, 1, 1, 1, 0, 0, 1, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> float:\n    \"\"\"\n    Harmonic Series\n\n    The harmonic series is the sum of the reciprocals of the positive integers.\n    The n-th harmonic number can be represented by the formula: Hn = 1/1 + 1/2 + 1/3 + ... + 1/n.\n\n    Given an integer n, calculate the n-th harmonic number.\n\n    Example:\n    n = 5\n    output: 2.283333333333333\n    \"\"\"\n    def harmonic(n: int) -> float:\n        if n == 1:\n            return 1\n        return 1/n + harmonic(n-1)\n\n    return harmonic(n)", "solution_func": "def g(n = 5):\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Maximum Subarray Sum\n\n    Given an array of integers, find the maximum sum of any contiguous subarray.\n\n    Example:\n    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    output: 6\n    Explanation: The contiguous subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n    def max_subarray_sum(arr: List[int]) -> int:\n        max_sum = float('-inf')\n        curr_sum = 0\n        for num in arr:\n            curr_sum = max(curr_sum + num, num)\n            max_sum = max(max_sum, curr_sum)\n        return max_sum\n\n    return max_subarray_sum(arr)\n\ndef g() -> List[int]:\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 380, "target_skills": [1, 1, 1, 0, 1, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Maximum Subarray Sum\n\n    Given an array of integers, find the maximum sum of any contiguous subarray.\n\n    Example:\n    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    output: 6\n    Explanation: The contiguous subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n    def max_subarray_sum(arr: List[int]) -> int:\n        max_sum = float('-inf')\n        curr_sum = 0\n        for num in arr:\n            curr_sum = max(curr_sum + num, num)\n            max_sum = max(max_sum, curr_sum)\n        return max_sum\n\n    return max_subarray_sum(arr)", "solution_func": "def g() -> List[int]:\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value, determine if there exists a pair of elements in the array whose sum is equal to the target value.\n    \n    Example:\n    arr = [1, 2, 3, 4, 5, 6]\n    target = 8\n    \n    Output:\n    True\n    \n    Explanation:\n    There exists a pair of elements in the array [2, 6] whose sum is equal to the target value 8.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5, 6]\n    target = 8\n    return arr, target\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 380, "target_skills": [0, 1, 1, 1, 0, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value, determine if there exists a pair of elements in the array whose sum is equal to the target value.\n    \n    Example:\n    arr = [1, 2, 3, 4, 5, 6]\n    target = 8\n    \n    Output:\n    True\n    \n    Explanation:\n    There exists a pair of elements in the array [2, 6] whose sum is equal to the target value 8.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False", "solution_func": "def g():\n    arr = [1, 2, 3, 4, 5, 6]\n    target = 8\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the number of ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n    \n    Example:\n    n = 3\n    \n    Output:\n    3\n    \n    Explanation:\n    There are 3 ways to climb to the top of a staircase with 3 steps: [1, 1, 1], [1, 2], [2, 1].\n    \"\"\"\n    if n <= 2:\n        return n\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    \n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    \n    return dp[n]\n\ndef g():\n    n = 3\n    return n\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 380, "target_skills": [1, 1, 0, 0, 1, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the number of ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n    \n    Example:\n    n = 3\n    \n    Output:\n    3\n    \n    Explanation:\n    There are 3 ways to climb to the top of a staircase with 3 steps: [1, 1, 1], [1, 2], [2, 1].\n    \"\"\"\n    if n <= 2:\n        return n\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    \n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    \n    return dp[n]", "solution_func": "def g():\n    n = 3\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(adj_list: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given an adjacency list representation of a graph and two nodes start and end, determine if there exists a path from start to end.\n    \n    Example:\n    adj_list = [[1, 2], [3], [4], [5], [], []]\n    start = 0\n    end = 5\n    \n    Output:\n    True\n    \n    Explanation:\n    There exists a path from node 0 to node 5 in the graph.\n    \"\"\"\n    visited = [False] * len(adj_list)\n    stack = [start]\n    \n    while stack:\n        node = stack.pop()\n        visited[node] = True\n        \n        if node == end:\n            return True\n        \n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                stack.append(neighbor)\n    \n    return False\n\ndef g():\n    adj_list = [[1, 2], [3], [4], [5], [], []]\n    start = 0\n    end = 5\n    return adj_list, start, end\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 380, "target_skills": [1, 1, 1, 1, 1, 0, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(adj_list: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given an adjacency list representation of a graph and two nodes start and end, determine if there exists a path from start to end.\n    \n    Example:\n    adj_list = [[1, 2], [3], [4], [5], [], []]\n    start = 0\n    end = 5\n    \n    Output:\n    True\n    \n    Explanation:\n    There exists a path from node 0 to node 5 in the graph.\n    \"\"\"\n    visited = [False] * len(adj_list)\n    stack = [start]\n    \n    while stack:\n        node = stack.pop()\n        visited[node] = True\n        \n        if node == end:\n            return True\n        \n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                stack.append(neighbor)\n    \n    return False", "solution_func": "def g():\n    adj_list = [[1, 2], [3], [4], [5], [], []]\n    start = 0\n    end = 5\n    return adj_list, start, end", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target number, determine if the target number is present in the array using binary search.\n    Return True if the target number is found, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\ndef g(arr = [1, 2, 3, 4, 5], target = 3):\n    \"\"\"\n    Return the input array and target number.\n    \"\"\"\n    return arr, target\n\nassert f(*g())\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 380, "target_skills": [1, 0, 0, 1, 0, 0, 1, 1, 1, 1], "problem_func": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target number, determine if the target number is present in the array using binary search.\n    Return True if the target number is found, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False", "solution_func": "def g(arr = [1, 2, 3, 4, 5], target = 3):\n    \"\"\"\n    Return the input array and target number.\n    \"\"\"\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the value of the k-th bit in the binary representation of n.\n    The least significant bit is at position 0.\n    \"\"\"\n    return (n >> k) & 1\n\ndef g(n = 10, k = 2):\n    \"\"\"\n    Return the input integers.\n    \"\"\"\n    return n, k\n\nassert f(*g()) == 1\n", "emb": null, "idx_generation": 380, "target_skills": [1, 0, 1, 1, 1, 0, 0, 1, 0, 0], "problem_func": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the value of the k-th bit in the binary representation of n.\n    The least significant bit is at position 0.\n    \"\"\"\n    return (n >> k) & 1", "solution_func": "def g(n = 10, k = 2):\n    \"\"\"\n    Return the input integers.\n    \"\"\"\n    return n, k", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nclass Stack:\n    def __init__(self):\n        self.stack = []\n\n    def push(self, val: int) -> None:\n        \"\"\"\n        Pushes the given value onto the stack.\n        \"\"\"\n        self.stack.append(val)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes and returns the topmost value from the stack.\n        \"\"\"\n        return self.stack.pop()\n\n    def top(self) -> int:\n        \"\"\"\n        Returns the topmost value from the stack without removing it.\n        \"\"\"\n        return self.stack[-1]\n\n    def is_empty(self) -> bool:\n        \"\"\"\n        Returns True if the stack is empty, False otherwise.\n        \"\"\"\n        return len(self.stack) == 0\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome by using a stack.\n    Return True if s is a palindrome, False otherwise.\n    \"\"\"\n    stack = Stack()\n    for c in s:\n        stack.push(c)\n\n    reversed_s = \"\"\n    while not stack.is_empty():\n        reversed_s += stack.pop()\n\n    return s == reversed_s\n\ndef g(s = \"madam\"):\n    \"\"\"\n    Return the input string.\n    \"\"\"\n    return s\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 380, "target_skills": [1, 0, 0, 1, 1, 1, 0, 0, 0, 0], "problem_func": "from typing import*\nclass Stack:\n    def __init__(self):\n        self.stack = []\n\n    def push(self, val: int) -> None:\n        \"\"\"\n        Pushes the given value onto the stack.\n        \"\"\"\n        self.stack.append(val)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes and returns the topmost value from the stack.\n        \"\"\"\n        return self.stack.pop()\n\n    def top(self) -> int:\n        \"\"\"\n        Returns the topmost value from the stack without removing it.\n        \"\"\"\n        return self.stack[-1]\n\n    def is_empty(self) -> bool:\n        \"\"\"\n        Returns True if the stack is empty, False otherwise.\n        \"\"\"\n        return len(self.stack) == 0\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome by using a stack.\n    Return True if s is a palindrome, False otherwise.\n    \"\"\"\n    stack = Stack()\n    for c in s:\n        stack.push(c)\n\n    reversed_s = \"\"\n    while not stack.is_empty():\n        reversed_s += stack.pop()\n\n    return s == reversed_s", "solution_func": "def g(s = \"madam\"):\n    \"\"\"\n    Return the input string.\n    \"\"\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Given an integer n and a positive integer k, generate all possible permutations of k numbers out of the range [1, n].\n\n    Example:\n    n = 4\n    k = 2\n\n    Output:\n    [[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 4], [3, 1], [3, 2], [3, 4], [4, 1], [4, 2], [4, 3]]\n\n    Hint: Use recursion and a backtracking approach to generate all permutations.\n    \"\"\"\n\n    def backtrack(curr_perm):\n        if len(curr_perm) == k:\n            result.append(curr_perm[:])\n            return\n        \n        for num in range(1, n + 1):\n            if num not in curr_perm:\n                curr_perm.append(num)\n                backtrack(curr_perm)\n                curr_perm.pop()\n\n    result = []\n    backtrack([])\n    return result\n\ndef g():\n    return (4, 2)\n\nassert f(*g()) == [[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 4], [3, 1], [3, 2], [3, 4], [4, 1], [4, 2], [4, 3]]\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 380, "target_skills": [0, 1, 0, 0, 0, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Given an integer n and a positive integer k, generate all possible permutations of k numbers out of the range [1, n].\n\n    Example:\n    n = 4\n    k = 2\n\n    Output:\n    [[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 4], [3, 1], [3, 2], [3, 4], [4, 1], [4, 2], [4, 3]]\n\n    Hint: Use recursion and a backtracking approach to generate all permutations.\n    \"\"\"\n\n    def backtrack(curr_perm):\n        if len(curr_perm) == k:\n            result.append(curr_perm[:])\n            return\n        \n        for num in range(1, n + 1):\n            if num not in curr_perm:\n                curr_perm.append(num)\n                backtrack(curr_perm)\n                curr_perm.pop()\n\n    result = []\n    backtrack([])\n    return result", "solution_func": "def g():\n    return (4, 2)", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target number using binary search.\n    If the target number is not found in the list, return -1.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7]\n    target = 4\n\n    Output:\n    3\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5, 6, 7]\n    target = 4\n    return nums\n\nassert f(g()) == 3\n\n", "emb": null, "idx_generation": 381, "target_skills": [1, 1, 1, 0, 1, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target number using binary search.\n    If the target number is not found in the list, return -1.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7]\n    target = 4\n\n    Output:\n    3\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5, 6, 7]\n    target = 4\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of valid paths from the top-left corner to the bottom-right corner\n    of an n x n grid. You can only move down or right.\n\n    Example:\n    n = 3\n\n    Output:\n    6\n\n    Explanation:\n    There are 6 valid paths:\n    - Right -> Right -> Down\n    - Right -> Down -> Right\n    - Down -> Right -> Right\n    - Right -> Down -> Down\n    - Down -> Right -> Down\n    - Down -> Down -> Right\n    \"\"\"\n\n    def count_paths(x: int, y: int) -> int:\n        if x == n-1 and y == n-1:\n            return 1\n        if x >= n or y >= n:\n            return 0\n        return count_paths(x+1, y) + count_paths(x, y+1)\n\n    return count_paths(0, 0)\n\ndef g() -> int:\n    n = 3\n    return n\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 381, "target_skills": [0, 0, 0, 1, 1, 0, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of valid paths from the top-left corner to the bottom-right corner\n    of an n x n grid. You can only move down or right.\n\n    Example:\n    n = 3\n\n    Output:\n    6\n\n    Explanation:\n    There are 6 valid paths:\n    - Right -> Right -> Down\n    - Right -> Down -> Right\n    - Down -> Right -> Right\n    - Right -> Down -> Down\n    - Down -> Right -> Down\n    - Down -> Down -> Right\n    \"\"\"\n\n    def count_paths(x: int, y: int) -> int:\n        if x == n-1 and y == n-1:\n            return 1\n        if x >= n or y >= n:\n            return 0\n        return count_paths(x+1, y) + count_paths(x, y+1)\n\n    return count_paths(0, 0)", "solution_func": "def g() -> int:\n    n = 3\n    return n", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the number of ways to add or subtract the elements in the list\n    to obtain the target number.\n\n    Example:\n    nums = [1, 1, 1, 1, 1]\n    target = 3\n\n    Output:\n    5\n\n    Explanation:\n    There are 5 ways to obtain the target number:\n    - 1 + 1 + 1\n    - 1 + 1 - 1 + 1\n    - 1 - 1 + 1 + 1\n    - 1 - 1 - 1 + 1 + 1\n    - 1 - 1 - 1 - 1 + 1 + 1\n    \"\"\"\n\n    def count_ways(index: int, current_sum: int) -> int:\n        if index == len(nums):\n            if current_sum == target:\n                return 1\n            else:\n                return 0\n        return count_ways(index+1, current_sum + nums[index]) + count_ways(index+1, current_sum - nums[index])\n\n    return count_ways(0, 0)\n\ndef g() -> List[int]:\n    nums = [1, 1, 1, 1, 1]\n    target = 3\n    return (nums, target)\n\nassert f(*g()) == 5\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 381, "target_skills": [1, 1, 1, 0, 0, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the number of ways to add or subtract the elements in the list\n    to obtain the target number.\n\n    Example:\n    nums = [1, 1, 1, 1, 1]\n    target = 3\n\n    Output:\n    5\n\n    Explanation:\n    There are 5 ways to obtain the target number:\n    - 1 + 1 + 1\n    - 1 + 1 - 1 + 1\n    - 1 - 1 + 1 + 1\n    - 1 - 1 - 1 + 1 + 1\n    - 1 - 1 - 1 - 1 + 1 + 1\n    \"\"\"\n\n    def count_ways(index: int, current_sum: int) -> int:\n        if index == len(nums):\n            if current_sum == target:\n                return 1\n            else:\n                return 0\n        return count_ways(index+1, current_sum + nums[index]) + count_ways(index+1, current_sum - nums[index])\n\n    return count_ways(0, 0)", "solution_func": "def g() -> List[int]:\n    nums = [1, 1, 1, 1, 1]\n    target = 3\n    return (nums, target)", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list containing only the even numbers.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    Output: [2, 4, 6, 8, 10]\n    \"\"\"\n\n    return [x for x in nums if x % 2 == 0]\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]):\n    return nums\n\nassert f(g()) == [2, 4, 6, 8, 10]\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 381, "target_skills": [0, 1, 1, 0, 0, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list containing only the even numbers.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    Output: [2, 4, 6, 8, 10]\n    \"\"\"\n\n    return [x for x in nums if x % 2 == 0]", "solution_func": "def g(nums: List[int] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]):\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid filled with non-negative numbers, find the path from the top-left corner to the bottom-right corner\n    that minimizes the sum of all numbers along its path. You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 7\n    Explanation: The minimum sum path from top-left to bottom-right is 1 -> 3 -> 1 -> 1 -> 1, which sums up to 7.\n\n    Hint: Use dynamic programming to solve this problem.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g(grid: List[List[int]] = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(g()) == 7\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 381, "target_skills": [1, 1, 1, 1, 0, 1, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid filled with non-negative numbers, find the path from the top-left corner to the bottom-right corner\n    that minimizes the sum of all numbers along its path. You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 7\n    Explanation: The minimum sum path from top-left to bottom-right is 1 -> 3 -> 1 -> 1 -> 1, which sums up to 7.\n\n    Hint: Use dynamic programming to solve this problem.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g(grid: List[List[int]] = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\nclass Stack:\n    def __init__(self):\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x onto stack.\n        \"\"\"\n        self.stack.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element on top of the stack and returns that element.\n        \"\"\"\n        return self.stack.pop()\n\n    def top(self) -> int:\n        \"\"\"\n        Get the top element of the stack.\n        \"\"\"\n        return self.stack[-1]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the stack is empty.\n        \"\"\"\n        return len(self.stack) == 0\n\ndef f(operations: List[str], values: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a list of operations and their corresponding values, perform the operations on a stack and return the results.\n\n    Example:\n    operations = [\"push\", \"push\", \"pop\", \"push\", \"top\", \"empty\"]\n    values = [[1], [2], [], [3], [], []]\n    Output: [None, None, 2, None, 3, False]\n    Explanation: The operations and corresponding values are as follows:\n    - push(1) --> stack becomes [1]\n    - push(2) --> stack becomes [1, 2]\n    - pop() --> stack becomes [1] and returns 2\n    - push(3) --> stack becomes [1, 3]\n    - top() --> returns 3\n    - empty() --> returns False\n\n    Hint: Implement the stack using a list and perform the operations accordingly.\n    \"\"\"\n\n    stack = Stack()\n    results = []\n\n    for op, vals in zip(operations, values):\n        if op == \"push\":\n            stack.push(vals[0])\n            results.append(None)\n        elif op == \"pop\":\n            results.append(stack.pop())\n        elif op == \"top\":\n            results.append(stack.top())\n        elif op == \"empty\":\n            results.append(stack.empty())\n\n    return results\n\ndef g(operations: List[str] = [\"push\", \"push\", \"pop\", \"push\", \"top\", \"empty\"], values: List[List[int]] = [[1], [2], [], [3], [], []]):\n    return operations, values\n\nassert f(*g()) == [None, None, 2, None, 3, False]\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 381, "target_skills": [1, 1, 0, 1, 1, 0, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\nclass Stack:\n    def __init__(self):\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x onto stack.\n        \"\"\"\n        self.stack.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element on top of the stack and returns that element.\n        \"\"\"\n        return self.stack.pop()\n\n    def top(self) -> int:\n        \"\"\"\n        Get the top element of the stack.\n        \"\"\"\n        return self.stack[-1]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the stack is empty.\n        \"\"\"\n        return len(self.stack) == 0\n\ndef f(operations: List[str], values: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a list of operations and their corresponding values, perform the operations on a stack and return the results.\n\n    Example:\n    operations = [\"push\", \"push\", \"pop\", \"push\", \"top\", \"empty\"]\n    values = [[1], [2], [], [3], [], []]\n    Output: [None, None, 2, None, 3, False]\n    Explanation: The operations and corresponding values are as follows:\n    - push(1) --> stack becomes [1]\n    - push(2) --> stack becomes [1, 2]\n    - pop() --> stack becomes [1] and returns 2\n    - push(3) --> stack becomes [1, 3]\n    - top() --> returns 3\n    - empty() --> returns False\n\n    Hint: Implement the stack using a list and perform the operations accordingly.\n    \"\"\"\n\n    stack = Stack()\n    results = []\n\n    for op, vals in zip(operations, values):\n        if op == \"push\":\n            stack.push(vals[0])\n            results.append(None)\n        elif op == \"pop\":\n            results.append(stack.pop())\n        elif op == \"top\":\n            results.append(stack.top())\n        elif op == \"empty\":\n            results.append(stack.empty())\n\n    return results", "solution_func": "def g(operations: List[str] = [\"push\", \"push\", \"pop\", \"push\", \"top\", \"empty\"], values: List[List[int]] = [[1], [2], [], [3], [], []]):\n    return operations, values", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import *\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum element in each row and return the sum of these maximum elements.\n\n    Example:\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n    Output:\n    18\n\n    Explanation:\n    The maximum elements in each row are 3, 6, and 9. The sum of these maximum elements is 18.\n\n    Hint: Use sorting to find the maximum element in each row.\n    \"\"\"\n\n    row_max = []\n    for row in matrix:\n        row.sort()\n        row_max.append(row[-1])\n\n    return sum(row_max)\n\ndef g() -> List[List[int]]:\n    matrix = [[3, 2, 1], [5, 6, 4], [8, 7, 9]]\n    return matrix\n\nassert f(g()) == 24\n\n", "emb": null, "idx_generation": 381, "target_skills": [1, 0, 1, 0, 1, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum element in each row and return the sum of these maximum elements.\n\n    Example:\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n    Output:\n    18\n\n    Explanation:\n    The maximum elements in each row are 3, 6, and 9. The sum of these maximum elements is 18.\n\n    Hint: Use sorting to find the maximum element in each row.\n    \"\"\"\n\n    row_max = []\n    for row in matrix:\n        row.sort()\n        row_max.append(row[-1])\n\n    return sum(row_max)", "solution_func": "def g() -> List[List[int]]:\n    matrix = [[3, 2, 1], [5, 6, 4], [8, 7, 9]]\n    return matrix", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\n\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, check if s is an anagram of t.\n\n    Example:\n    s = \"listen\"\n    t = \"silent\"\n\n    Output:\n    True\n\n    Explanation:\n    The characters in s can be rearranged to form t.\n\n    Hint: Use counting and combinatorics to check if two strings are anagrams.\n    \"\"\"\n\n    if len(s) != len(t):\n        return False\n\n    count_s = [0] * 26\n    count_t = [0] * 26\n\n    for char in s:\n        count_s[ord(char) - ord('a')] += 1\n\n    for char in t:\n        count_t[ord(char) - ord('a')] += 1\n\n    return count_s == count_t\n\ndef g() -> Tuple[str, str]:\n    s = \"listen\"\n    t = \"silent\"\n    return s, t\n\nassert f(*g()) == True\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 381, "target_skills": [0, 1, 1, 1, 0, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, check if s is an anagram of t.\n\n    Example:\n    s = \"listen\"\n    t = \"silent\"\n\n    Output:\n    True\n\n    Explanation:\n    The characters in s can be rearranged to form t.\n\n    Hint: Use counting and combinatorics to check if two strings are anagrams.\n    \"\"\"\n\n    if len(s) != len(t):\n        return False\n\n    count_s = [0] * 26\n    count_t = [0] * 26\n\n    for char in s:\n        count_s[ord(char) - ord('a')] += 1\n\n    for char in t:\n        count_t[ord(char) - ord('a')] += 1\n\n    return count_s == count_t", "solution_func": "def g() -> Tuple[str, str]:\n    s = \"listen\"\n    t = \"silent\"\n    return s, t", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import *\n\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> int:\n    \"\"\"\n    Given a directed graph represented as an adjacency list, find the minimum cost from start to end using dynamic programming.\n\n    Example:\n    graph = {0: [(1, 5), (2, 3)], 1: [(3, 2)], 2: [(4, 1)], 3: [], 4: []}\n    start = 0\n    end = 4\n\n    Output:\n    6\n\n    Explanation:\n    The minimum cost path from start to end is 0 -> 2 -> 4, with a total cost of 6.\n\n    Hint: Use dynamic programming to find the minimum cost path.\n    \"\"\"\n\n    dp = [float('inf')] * len(graph)\n    dp[start] = 0\n\n    def dfs(node):\n        if dp[node] != float('inf'):\n            return dp[node]\n        \n        for neighbor, cost in graph[node]:\n            dp[node] = min(dp[node], cost + dfs(neighbor))\n        \n        return dp[node]\n\n    dfs(start)\n    return dp[end]\n\ndef g() -> Tuple[Dict[int, List[Tuple[int, int]]], int, int]:\n    graph = {0: [(1, 5), (2, 3)], 1: [(3, 2)], 2: [(4, 1)], 3: [], 4: []}\n    start = 0\n    end = 4\n    return graph, start, end\n\nassert f(*g()) == 6\n\n", "emb": null, "idx_generation": 381, "target_skills": [0, 1, 1, 1, 1, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> int:\n    \"\"\"\n    Given a directed graph represented as an adjacency list, find the minimum cost from start to end using dynamic programming.\n\n    Example:\n    graph = {0: [(1, 5), (2, 3)], 1: [(3, 2)], 2: [(4, 1)], 3: [], 4: []}\n    start = 0\n    end = 4\n\n    Output:\n    6\n\n    Explanation:\n    The minimum cost path from start to end is 0 -> 2 -> 4, with a total cost of 6.\n\n    Hint: Use dynamic programming to find the minimum cost path.\n    \"\"\"\n\n    dp = [float('inf')] * len(graph)\n    dp[start] = 0\n\n    def dfs(node):\n        if dp[node] != float('inf'):\n            return dp[node]\n        \n        for neighbor, cost in graph[node]:\n            dp[node] = min(dp[node], cost + dfs(neighbor))\n        \n        return dp[node]\n\n    dfs(start)\n    return dp[end]", "solution_func": "def g() -> Tuple[Dict[int, List[Tuple[int, int]]], int, int]:\n    graph = {0: [(1, 5), (2, 3)], 1: [(3, 2)], 2: [(4, 1)], 3: [], 4: []}\n    start = 0\n    end = 4\n    return graph, start, end", "map_ix": null}, {"fitness": -Infinity, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix,\n    count the number of cycles in the graph.\n\n    Note: A cycle is a path that starts and ends at the same vertex,\n    and does not visit any other vertex more than once.\n\n    Sample Input:\n    graph = [[0, 1, 0, 0],\n             [1, 0, 1, 1],\n             [0, 1, 0, 1],\n             [0, 1, 1, 0]]\n\n    Sample Output:\n    3\n    \"\"\"\n    def dfs(node, visited, parent):\n        visited[node] = True\n        count = 0\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1:\n                if not visited[neighbor]:\n                    count += dfs(neighbor, visited, node)\n                elif visited[neighbor] and neighbor != parent:\n                    count += 1\n        return count\n\n    n = len(graph)\n    visited = [False] * n\n    cycles = 0\n\n    for node in range(n):\n        if not visited[node]:\n            cycles += dfs(node, visited, -1)\n\n    return cycles\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a random undirected graph as an adjacency matrix.\n    \"\"\"\n    return [[0, 1, 0, 0],\n            [1, 0, 1, 1],\n            [0, 1, 0, 1],\n            [0, 1, 1, 0]]\n\nassert f(g()) == 3\n\n", "emb": null, "idx_generation": 381, "target_skills": [1, 1, 1, 1, 1, 0, 1, 0, 1, 0], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix,\n    count the number of cycles in the graph.\n\n    Note: A cycle is a path that starts and ends at the same vertex,\n    and does not visit any other vertex more than once.\n\n    Sample Input:\n    graph = [[0, 1, 0, 0],\n             [1, 0, 1, 1],\n             [0, 1, 0, 1],\n             [0, 1, 1, 0]]\n\n    Sample Output:\n    3\n    \"\"\"\n    def dfs(node, visited, parent):\n        visited[node] = True\n        count = 0\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1:\n                if not visited[neighbor]:\n                    count += dfs(neighbor, visited, node)\n                elif visited[neighbor] and neighbor != parent:\n                    count += 1\n        return count\n\n    n = len(graph)\n    visited = [False] * n\n    cycles = 0\n\n    for node in range(n):\n        if not visited[node]:\n            cycles += dfs(node, visited, -1)\n\n    return cycles", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a random undirected graph as an adjacency matrix.\n    \"\"\"\n    return [[0, 1, 0, 0],\n            [1, 0, 1, 1],\n            [0, 1, 0, 1],\n            [0, 1, 1, 0]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target element using linear search.\n    If the target element is not found, return -1.\n    \"\"\"\n    for i in range(len(nums)):\n        if nums[i] == target:\n            return i\n    return -1\n\ndef g():\n    nums = [4, 5, 2, 1, 7]\n    target = 2\n    return nums, target\n\nassert f(*g()) == 2\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 382, "target_skills": [1, 0, 0, 0, 0, 1, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target element using linear search.\n    If the target element is not found, return -1.\n    \"\"\"\n    for i in range(len(nums)):\n        if nums[i] == target:\n            return i\n    return -1", "solution_func": "def g():\n    nums = [4, 5, 2, 1, 7]\n    target = 2\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of words in it.\n    \"\"\"\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)\n\ndef g():\n    s = \"Hello World!\"\n    return s\n\nassert f(g()) == \"World! Hello\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 382, "target_skills": [0, 0, 1, 0, 0, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of words in it.\n    \"\"\"\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)", "solution_func": "def g():\n    s = \"Hello World!\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid, count the number of islands.\n    An island is represented by 1s and is surrounded by water (0s).\n    \"\"\"\n    def dfs(grid, i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:\n            return\n        grid[i][j] = 0\n        dfs(grid, i+1, j)\n        dfs(grid, i-1, j)\n        dfs(grid, i, j+1)\n        dfs(grid, i, j-1)\n    \n    if not grid:\n        return 0\n    \n    m, n = len(grid), len(grid[0])\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                dfs(grid, i, j)\n                count += 1\n    \n    return count\n\ndef g():\n    grid = [\n        [1, 1, 0, 0, 0],\n        [0, 1, 0, 0, 1],\n        [1, 0, 0, 1, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    return grid\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0], "idx_generation": 382, "target_skills": [1, 1, 0, 0, 1, 0, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid, count the number of islands.\n    An island is represented by 1s and is surrounded by water (0s).\n    \"\"\"\n    def dfs(grid, i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:\n            return\n        grid[i][j] = 0\n        dfs(grid, i+1, j)\n        dfs(grid, i-1, j)\n        dfs(grid, i, j+1)\n        dfs(grid, i, j-1)\n    \n    if not grid:\n        return 0\n    \n    m, n = len(grid), len(grid[0])\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                dfs(grid, i, j)\n                count += 1\n    \n    return count", "solution_func": "def g():\n    grid = [\n        [1, 1, 0, 0, 0],\n        [0, 1, 0, 0, 1],\n        [1, 0, 0, 1, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    return grid", "map_ix": [0, 0, 1, 0, 0, 0, 1, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom collections import deque\n\ndef f(graph: Dict[int, List[int]], start: int, target: int) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency list and two nodes start and target,\n    determine if there is a path from start to target in the graph.\n\n    Return True if there is a path, False otherwise.\n\n    Example:\n    graph = {\n        0: [1, 2],\n        1: [3, 4],\n        2: [5],\n        3: [],\n        4: [],\n        5: []\n    }\n    start = 0\n    target = 4\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 0 to node 4 in the graph.\n\n    Hint: Use depth-first search (DFS) or breadth-first search (BFS) to traverse the graph and check for a path.\n    \"\"\"\n\n    visited = set()\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n        if node == target:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n\n    return False\n\ndef g():\n    graph = {\n        0: [1, 2],\n        1: [3, 4],\n        2: [5],\n        3: [],\n        4: [],\n        5: []\n    }\n    start = 0\n    target = 4\n    return graph, start, target\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 382, "target_skills": [0, 1, 0, 1, 1, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom collections import deque\n\ndef f(graph: Dict[int, List[int]], start: int, target: int) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency list and two nodes start and target,\n    determine if there is a path from start to target in the graph.\n\n    Return True if there is a path, False otherwise.\n\n    Example:\n    graph = {\n        0: [1, 2],\n        1: [3, 4],\n        2: [5],\n        3: [],\n        4: [],\n        5: []\n    }\n    start = 0\n    target = 4\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 0 to node 4 in the graph.\n\n    Hint: Use depth-first search (DFS) or breadth-first search (BFS) to traverse the graph and check for a path.\n    \"\"\"\n\n    visited = set()\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n        if node == target:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n\n    return False", "solution_func": "def g():\n    graph = {\n        0: [1, 2],\n        1: [3, 4],\n        2: [5],\n        3: [],\n        4: [],\n        5: []\n    }\n    start = 0\n    target = 4\n    return graph, start, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom collections import deque\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse each word in the string while maintaining the order of the words.\n\n    Return the reversed string.\n\n    Example:\n    s = \"Hello World\"\n\n    Output:\n    \"olleH dlroW\"\n\n    Explanation:\n    Each word in the string is reversed while maintaining the order of the words.\n\n    Hint: Split the string into words, reverse each word, and then join the reversed words back into a string.\n    \"\"\"\n\n    words = s.split()\n    reversed_words = [word[::-1] for word in words]\n    reversed_string = ' '.join(reversed_words)\n\n    return reversed_string\n\ndef g():\n    s = \"Hello World\"\n    return s\n\nassert f(g()) == \"olleH dlroW\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 382, "target_skills": [0, 0, 1, 1, 1, 1, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom collections import deque\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse each word in the string while maintaining the order of the words.\n\n    Return the reversed string.\n\n    Example:\n    s = \"Hello World\"\n\n    Output:\n    \"olleH dlroW\"\n\n    Explanation:\n    Each word in the string is reversed while maintaining the order of the words.\n\n    Hint: Split the string into words, reverse each word, and then join the reversed words back into a string.\n    \"\"\"\n\n    words = s.split()\n    reversed_words = [word[::-1] for word in words]\n    reversed_string = ' '.join(reversed_words)\n\n    return reversed_string", "solution_func": "def g():\n    s = \"Hello World\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom collections import deque\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s containing only parentheses ( and ), determine if the parentheses are balanced.\n\n    Return True if the parentheses are balanced, False otherwise.\n\n    Example:\n    s = \"()()((()))\"\n\n    Output:\n    True\n\n    Explanation:\n    The parentheses in the string are balanced.\n\n    Hint: Use a stack to keep track of opening parentheses and pop them when a closing parenthesis is encountered. If the stack is empty at the end, the parentheses are balanced.\n    \"\"\"\n\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n\n    return len(stack) == 0\n\ndef g():\n    s = \"()()((()))\"\n    return s\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 382, "target_skills": [1, 0, 1, 0, 1, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom collections import deque\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s containing only parentheses ( and ), determine if the parentheses are balanced.\n\n    Return True if the parentheses are balanced, False otherwise.\n\n    Example:\n    s = \"()()((()))\"\n\n    Output:\n    True\n\n    Explanation:\n    The parentheses in the string are balanced.\n\n    Hint: Use a stack to keep track of opening parentheses and pop them when a closing parenthesis is encountered. If the stack is empty at the end, the parentheses are balanced.\n    \"\"\"\n\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n\n    return len(stack) == 0", "solution_func": "def g():\n    s = \"()()((()))\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers, find the number of occurrences of a target number in the array.\n\n    Example:\n    arr = [1, 2, 2, 3, 3, 3, 4, 5, 5]\n    target = 3\n\n    Output:\n    3\n\n    Explanation:\n    The target number 3 appears 3 times in the array.\n\n    Constraints:\n    - The array will be sorted in non-decreasing order.\n    \"\"\"\n\n    def binary_search_left(arr, target):\n        left = 0\n        right = len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n    def binary_search_right(arr, target):\n        left = 0\n        right = len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] <= target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return right\n\n    left_index = binary_search_left(arr, target)\n    right_index = binary_search_right(arr, target)\n\n    return right_index - left_index + 1\n\ndef g(arr=[1, 2, 2, 3, 3, 3, 4, 5, 5], target=3):\n    return arr, target\n\nassert f(g()) == 3\n", "emb": null, "idx_generation": 382, "target_skills": [1, 1, 1, 1, 1, 0, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers, find the number of occurrences of a target number in the array.\n\n    Example:\n    arr = [1, 2, 2, 3, 3, 3, 4, 5, 5]\n    target = 3\n\n    Output:\n    3\n\n    Explanation:\n    The target number 3 appears 3 times in the array.\n\n    Constraints:\n    - The array will be sorted in non-decreasing order.\n    \"\"\"\n\n    def binary_search_left(arr, target):\n        left = 0\n        right = len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n    def binary_search_right(arr, target):\n        left = 0\n        right = len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] <= target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return right\n\n    left_index = binary_search_left(arr, target)\n    right_index = binary_search_right(arr, target)\n\n    return right_index - left_index + 1", "solution_func": "def g(arr=[1, 2, 2, 3, 3, 3, 4, 5, 5], target=3):\n    return arr, target", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of ways to represent n as the sum of powers of 2.\n\n    Example:\n    n = 8\n\n    Output:\n    4\n\n    Explanation:\n    The number 8 can be represented as the sum of powers of 2 in 4 ways: 8, 4+4, 2+2+2+2, 1+1+1+1+1+1+1+1.\n\n    Constraints:\n    - The input integer n will always be non-negative.\n    \"\"\"\n\n    def count_ways(n):\n        if n == 0:\n            return 1\n        count = 0\n        power = 0\n        while 2**power <= n:\n            count += count_ways(n - 2**power)\n            power += 1\n        return count\n\n    return count_ways(n)\n\ndef g(n=8):\n    return n\n\nassert f(g()) == 4\n", "emb": null, "idx_generation": 382, "target_skills": [1, 1, 1, 0, 0, 1, 1, 1, 1, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of ways to represent n as the sum of powers of 2.\n\n    Example:\n    n = 8\n\n    Output:\n    4\n\n    Explanation:\n    The number 8 can be represented as the sum of powers of 2 in 4 ways: 8, 4+4, 2+2+2+2, 1+1+1+1+1+1+1+1.\n\n    Constraints:\n    - The input integer n will always be non-negative.\n    \"\"\"\n\n    def count_ways(n):\n        if n == 0:\n            return 1\n        count = 0\n        power = 0\n        while 2**power <= n:\n            count += count_ways(n - 2**power)\n            power += 1\n        return count\n\n    return count_ways(n)", "solution_func": "def g(n=8):\n    return n", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers, find the index of the target number using binary search.\n\n    Example:\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 5\n\n    Output:\n    4\n\n    Explanation:\n    The target number 5 is found at index 4 in the array.\n\n    Constraints:\n    - The array will be sorted in non-decreasing order.\n    \"\"\"\n\n    def binary_search(arr, target):\n        left = 0\n        right = len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == target:\n                return mid\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\n    return binary_search(arr, target)\n\ndef g(arr=[1, 2, 3, 4, 5, 6, 7, 8, 9], target=5):\n    return arr, target\n\nassert f(g()) == 4\n", "emb": null, "idx_generation": 382, "target_skills": [0, 0, 0, 1, 0, 0, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers, find the index of the target number using binary search.\n\n    Example:\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 5\n\n    Output:\n    4\n\n    Explanation:\n    The target number 5 is found at index 4 in the array.\n\n    Constraints:\n    - The array will be sorted in non-decreasing order.\n    \"\"\"\n\n    def binary_search(arr, target):\n        left = 0\n        right = len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == target:\n                return mid\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\n    return binary_search(arr, target)", "solution_func": "def g(arr=[1, 2, 3, 4, 5, 6, 7, 8, 9], target=5):\n    return arr, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a prime number.\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g() -> int:\n    return 17\n\nassert f(g())\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 382, "target_skills": [0, 1, 1, 1, 1, 0, 0, 0, 1, 1], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a prime number.\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "solution_func": "def g() -> int:\n    return 17", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell. You can only move down or right.\n\n    Args:\n    - grid: A 2D grid of integers.\n\n    Returns:\n    - The maximum sum of a path from the top-left cell to the bottom-right cell.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g(grid=[[1,3,1],[1,5,1],[4,2,1]]):\n    return grid\n\nassert f(g()) == 12\n\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 383, "target_skills": [0, 0, 1, 0, 1, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell. You can only move down or right.\n\n    Args:\n    - grid: A 2D grid of integers.\n\n    Returns:\n    - The maximum sum of a path from the top-left cell to the bottom-right cell.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]", "solution_func": "def g(grid=[[1,3,1],[1,5,1],[4,2,1]]):\n    return grid", "map_ix": [1, 0, 1, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers 'nums' and a target sum, find two numbers in the array that add up to the target and return their indices.\n\n    Args:\n    - nums: A list of integers.\n    - target: The target sum.\n\n    Returns:\n    - A list containing the indices of the two numbers that add up to the target sum.\n    \"\"\"\n    num_to_index = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_to_index:\n            return [num_to_index[complement], i]\n        num_to_index[num] = i\n\n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 383, "target_skills": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers 'nums' and a target sum, find two numbers in the array that add up to the target and return their indices.\n\n    Args:\n    - nums: A list of integers.\n    - target: The target sum.\n\n    Returns:\n    - A list containing the indices of the two numbers that add up to the target sum.\n    \"\"\"\n    num_to_index = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_to_index:\n            return [num_to_index[complement], i]\n        num_to_index[num] = i\n\n    return []", "solution_func": "def g(nums=[2, 7, 11, 15], target=9):\n    return nums, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum path sum from the top-left cell to the bottom-right cell. You can only move down or right.\n\n    Args:\n    - grid: A 2D grid of integers.\n\n    Returns:\n    - The minimum path sum from the top-left cell to the bottom-right cell.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g(grid=[[1,3,1],[1,5,1],[4,2,1]]):\n    return grid\n\nassert f(g()) == 7\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 383, "target_skills": [1, 0, 0, 0, 1, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum path sum from the top-left cell to the bottom-right cell. You can only move down or right.\n\n    Args:\n    - grid: A 2D grid of integers.\n\n    Returns:\n    - The minimum path sum from the top-left cell to the bottom-right cell.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]", "solution_func": "def g(grid=[[1,3,1],[1,5,1],[4,2,1]]):\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray within the list.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The maximum sum of a subarray within the list.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n\n    Explanation:\n    The subarray with the maximum sum is [4, -1, 2, 1], which sums up to 6.\n\n    Hint: Use dynamic programming to solve this problem.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    current_sum = nums[0]\n    max_sum = nums[0]\n\n    for i in range(1, len(nums)):\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 383, "target_skills": [0, 1, 1, 0, 0, 1, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray within the list.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The maximum sum of a subarray within the list.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n\n    Explanation:\n    The subarray with the maximum sum is [4, -1, 2, 1], which sums up to 6.\n\n    Hint: Use dynamic programming to solve this problem.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    current_sum = nums[0]\n    max_sum = nums[0]\n\n    for i in range(1, len(nums)):\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth number in the Fibonacci sequence.\n\n    Args:\n    - n: A positive integer.\n\n    Returns:\n    - The nth number in the Fibonacci sequence.\n\n    Example:\n    n = 6\n    Output: 8\n\n    Explanation:\n    The Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, ...\n    The 6th number in the sequence is 8.\n\n    Hint: Use recursion to solve this problem.\n    \"\"\"\n\n    if n <= 1:\n        return n\n\n    return f(n - 1) + f(n - 2)\n\ndef g() -> int:\n    n = 6\n    return n\n\nassert f(g()) == 8\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 383, "target_skills": [1, 0, 0, 0, 1, 0, 0, 1, 0, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth number in the Fibonacci sequence.\n\n    Args:\n    - n: A positive integer.\n\n    Returns:\n    - The nth number in the Fibonacci sequence.\n\n    Example:\n    n = 6\n    Output: 8\n\n    Explanation:\n    The Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, ...\n    The 6th number in the sequence is 8.\n\n    Hint: Use recursion to solve this problem.\n    \"\"\"\n\n    if n <= 1:\n        return n\n\n    return f(n - 1) + f(n - 2)", "solution_func": "def g() -> int:\n    n = 6\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the factorial of n.\n\n    Args:\n    - n: A positive integer.\n\n    Returns:\n    - The factorial of n.\n\n    Example:\n    n = 5\n    Output: 120\n\n    Explanation:\n    The factorial of 5 is 5 * 4 * 3 * 2 * 1 = 120.\n\n    Hint: Use recursion to solve this problem.\n    \"\"\"\n\n    if n == 0:\n        return 1\n\n    return n * f(n - 1)\n\ndef g() -> int:\n    n = 5\n    return n\n\nassert f(g()) == 120\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 383, "target_skills": [0, 0, 1, 0, 0, 1, 0, 0, 0, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the factorial of n.\n\n    Args:\n    - n: A positive integer.\n\n    Returns:\n    - The factorial of n.\n\n    Example:\n    n = 5\n    Output: 120\n\n    Explanation:\n    The factorial of 5 is 5 * 4 * 3 * 2 * 1 = 120.\n\n    Hint: Use recursion to solve this problem.\n    \"\"\"\n\n    if n == 0:\n        return 1\n\n    return n * f(n - 1)", "solution_func": "def g() -> int:\n    n = 5\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two integers in the list.\n    \"\"\"\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n    return max_product\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return (nums,)\n\nassert f(*g()) == 20\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 383, "target_skills": [0, 0, 0, 0, 1, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two integers in the list.\n    \"\"\"\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n    return max_product", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return (nums,)", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, find the length of the longest path of consecutive 1s.\n    The path can only move horizontally or vertically, and cannot move diagonally.\n    \"\"\"\n    def dfs(i, j, path_length):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:\n            return path_length\n        grid[i][j] = 0\n        return max(dfs(i+1, j, path_length+1),\n                   dfs(i-1, j, path_length+1),\n                   dfs(i, j+1, path_length+1),\n                   dfs(i, j-1, path_length+1))\n    \n    max_length = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                max_length = max(max_length, dfs(i, j, 0))\n    return max_length\n\ndef g():\n    grid = [[1, 1, 0, 0, 0],\n            [1, 1, 1, 1, 0],\n            [0, 0, 0, 1, 0],\n            [0, 0, 0, 1, 1]]\n    return (grid,)\n\nassert f(*g()) == 6\n\n", "emb": null, "idx_generation": 383, "target_skills": [0, 1, 1, 1, 1, 0, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, find the length of the longest path of consecutive 1s.\n    The path can only move horizontally or vertically, and cannot move diagonally.\n    \"\"\"\n    def dfs(i, j, path_length):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:\n            return path_length\n        grid[i][j] = 0\n        return max(dfs(i+1, j, path_length+1),\n                   dfs(i-1, j, path_length+1),\n                   dfs(i, j+1, path_length+1),\n                   dfs(i, j-1, path_length+1))\n    \n    max_length = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                max_length = max(max_length, dfs(i, j, 0))\n    return max_length", "solution_func": "def g():\n    grid = [[1, 1, 0, 0, 0],\n            [1, 1, 1, 1, 0],\n            [0, 0, 0, 1, 0],\n            [0, 0, 0, 1, 1]]\n    return (grid,)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of numbers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in a list.\n    \"\"\"\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return (nums, target)\n\nassert f(*g()) == [0, 1]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 383, "target_skills": [1, 1, 1, 0, 1, 1, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of numbers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in a list.\n    \"\"\"\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n    return []", "solution_func": "def g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return (nums, target)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the number of unique permutations of the list.\n\n    Example:\n    nums = [1, 2, 3]\n\n    Output:\n    6\n\n    Explanation:\n    The unique permutations of [1, 2, 3] are:\n    [1, 2, 3]\n    [1, 3, 2]\n    [2, 1, 3]\n    [2, 3, 1]\n    [3, 1, 2]\n    [3, 2, 1]\n    \"\"\"\n\n    def backtrack(nums: List[int], path: List[int], result: List[List[int]]) -> None:\n        if not nums:\n            result.append(path)\n            return\n\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            backtrack(nums[:i] + nums[i + 1:], path + [nums[i]], result)\n\n    result = []\n    nums.sort()\n    backtrack(nums, [], result)\n    return len(result)\n\ndef g() -> List[int]:\n    return [1, 2, 3]\n\nassert f(*g()) == 6\n", "emb": null, "idx_generation": 383, "target_skills": [1, 1, 1, 1, 0, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the number of unique permutations of the list.\n\n    Example:\n    nums = [1, 2, 3]\n\n    Output:\n    6\n\n    Explanation:\n    The unique permutations of [1, 2, 3] are:\n    [1, 2, 3]\n    [1, 3, 2]\n    [2, 1, 3]\n    [2, 3, 1]\n    [3, 1, 2]\n    [3, 2, 1]\n    \"\"\"\n\n    def backtrack(nums: List[int], path: List[int], result: List[List[int]]) -> None:\n        if not nums:\n            result.append(path)\n            return\n\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            backtrack(nums[:i] + nums[i + 1:], path + [nums[i]], result)\n\n    result = []\n    nums.sort()\n    backtrack(nums, [], result)\n    return len(result)", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Find the number of ways to arrange n identical balls into k distinct boxes, where each box can have any number of balls.\n\n    Example:\n    Input:\n    n = 5\n\n    Output:\n    15\n    Explanation:\n    The number of ways to arrange 5 identical balls into different boxes is 15, which can be represented as:\n    5 + 0 + 0 + 0 + 0\n    4 + 1 + 0 + 0 + 0\n    3 + 2 + 0 + 0 + 0\n    3 + 1 + 1 + 0 + 0\n    2 + 2 + 1 + 0 + 0\n    2 + 1 + 1 + 1 + 0\n    1 + 1 + 1 + 1 + 1\n    4 + 0 + 1 + 0 + 0\n    3 + 1 + 0 + 1 + 0\n    2 + 2 + 0 + 1 + 0\n    2 + 1 + 1 + 1 + 0\n    1 + 1 + 1 + 1 + 1\n    3 + 0 + 2 + 0 + 0\n    2 + 1 + 2 + 0 + 0\n    1 + 1 + 1 + 1 + 1\n\n    \"\"\"\n    def count_ways(n, k):\n        if n == 0 or k == 1:\n            return 1\n        elif k > n:\n            return count_ways(n, n)\n        else:\n            return count_ways(n, k - 1) + count_ways(n - k, k)\n    \n    return count_ways(n, n)\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == 15\n", "emb": null, "idx_generation": 384, "target_skills": [1, 1, 0, 0, 1, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Find the number of ways to arrange n identical balls into k distinct boxes, where each box can have any number of balls.\n\n    Example:\n    Input:\n    n = 5\n\n    Output:\n    15\n    Explanation:\n    The number of ways to arrange 5 identical balls into different boxes is 15, which can be represented as:\n    5 + 0 + 0 + 0 + 0\n    4 + 1 + 0 + 0 + 0\n    3 + 2 + 0 + 0 + 0\n    3 + 1 + 1 + 0 + 0\n    2 + 2 + 1 + 0 + 0\n    2 + 1 + 1 + 1 + 0\n    1 + 1 + 1 + 1 + 1\n    4 + 0 + 1 + 0 + 0\n    3 + 1 + 0 + 1 + 0\n    2 + 2 + 0 + 1 + 0\n    2 + 1 + 1 + 1 + 0\n    1 + 1 + 1 + 1 + 1\n    3 + 0 + 2 + 0 + 0\n    2 + 1 + 2 + 0 + 0\n    1 + 1 + 1 + 1 + 1\n\n    \"\"\"\n    def count_ways(n, k):\n        if n == 0 or k == 1:\n            return 1\n        elif k > n:\n            return count_ways(n, n)\n        else:\n            return count_ways(n, k - 1) + count_ways(n - k, k)\n    \n    return count_ways(n, n)", "solution_func": "def g():\n    n = 5\n    return n", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Find the minimum number of moves required to move from the top-left corner to the bottom-right corner of a grid, given that each cell contains a non-negative integer representing the cost to move to that cell.\n\n    Example:\n    Input:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n    Explanation:\n    The minimum number of moves required to move from the top-left corner (1) to the bottom-right corner (1) is 7, following the path: 1 -> 3 -> 1 -> 1 -> 1.\n\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[float('inf')] * (n + 1) for _ in range(m + 1)]\n    dp[m][n - 1] = 0\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            dp[i][j] = min(dp[i + 1][j], dp[i][j + 1]) + grid[i][j]\n\n    return dp[0][0]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 384, "target_skills": [1, 1, 1, 0, 0, 1, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Find the minimum number of moves required to move from the top-left corner to the bottom-right corner of a grid, given that each cell contains a non-negative integer representing the cost to move to that cell.\n\n    Example:\n    Input:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n    Explanation:\n    The minimum number of moves required to move from the top-left corner (1) to the bottom-right corner (1) is 7, following the path: 1 -> 3 -> 1 -> 1 -> 1.\n\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[float('inf')] * (n + 1) for _ in range(m + 1)]\n    dp[m][n - 1] = 0\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            dp[i][j] = min(dp[i + 1][j], dp[i][j + 1]) + grid[i][j]\n\n    return dp[0][0]", "solution_func": "def g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": [0, 0, 0, 1, 0, 0, 1, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Find the maximum subarray sum, considering that the array can be circular (the last element is connected to the first element).\n\n    Example:\n    Input:\n    nums = [2, -1, 3, -4, 5]\n\n    Output:\n    10\n    Explanation:\n    The maximum subarray sum is obtained by selecting the subarray [3, -4, 5] which has a sum of 4 + 5 = 10.\n\n    \"\"\"\n    def kadane(arr):\n        max_sum = float('-inf')\n        curr_sum = 0\n\n        for num in arr:\n            curr_sum = max(num, curr_sum + num)\n            max_sum = max(max_sum, curr_sum)\n\n        return max_sum\n\n    total_sum = sum(nums)\n    max_subarray_sum = max(kadane(nums), total_sum + kadane([-num for num in nums[1:]]))\n\n    return max_subarray_sum\n\ndef g():\n    nums = [2, -1, 3, -4, 5]\n    return nums\n\nassert f(g()) == 10\n", "emb": null, "idx_generation": 384, "target_skills": [1, 1, 1, 0, 1, 0, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Find the maximum subarray sum, considering that the array can be circular (the last element is connected to the first element).\n\n    Example:\n    Input:\n    nums = [2, -1, 3, -4, 5]\n\n    Output:\n    10\n    Explanation:\n    The maximum subarray sum is obtained by selecting the subarray [3, -4, 5] which has a sum of 4 + 5 = 10.\n\n    \"\"\"\n    def kadane(arr):\n        max_sum = float('-inf')\n        curr_sum = 0\n\n        for num in arr:\n            curr_sum = max(num, curr_sum + num)\n            max_sum = max(max_sum, curr_sum)\n\n        return max_sum\n\n    total_sum = sum(nums)\n    max_subarray_sum = max(kadane(nums), total_sum + kadane([-num for num in nums[1:]]))\n\n    return max_subarray_sum", "solution_func": "def g():\n    nums = [2, -1, 3, -4, 5]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray within the list.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The maximum sum of a subarray within the list.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g():\n    nums = [1, -2, 3, -4, 5]\n    return nums\n\nassert f(g()) == 6\n", "emb": null, "idx_generation": 384, "target_skills": [1, 1, 1, 1, 1, 1, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray within the list.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The maximum sum of a subarray within the list.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g():\n    nums = [1, -2, 3, -4, 5]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, check if t is an anagram of s.\n\n    Args:\n    - s: A string.\n    - t: A string.\n\n    Returns:\n    - True if t is an anagram of s, False otherwise.\n    \"\"\"\n    if len(s) != len(t):\n        return False\n\n    count = [0] * 26\n\n    for i in range(len(s)):\n        count[ord(s[i]) - ord('a')] += 1\n        count[ord(t[i]) - ord('a')] -= 1\n\n    for c in count:\n        if c != 0:\n            return False\n\n    return True\n\ndef g(s: str, t: str):\n    return s, t[::-1]\n\nassert f(*g(\"anagram\", \"nagaram\"))\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 384, "target_skills": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, check if t is an anagram of s.\n\n    Args:\n    - s: A string.\n    - t: A string.\n\n    Returns:\n    - True if t is an anagram of s, False otherwise.\n    \"\"\"\n    if len(s) != len(t):\n        return False\n\n    count = [0] * 26\n\n    for i in range(len(s)):\n        count[ord(s[i]) - ord('a')] += 1\n        count[ord(t[i]) - ord('a')] -= 1\n\n    for c in count:\n        if c != 0:\n            return False\n\n    return True", "solution_func": "def g(s: str, t: str):\n    return s, t[::-1]", "map_ix": [1, 1, 0, 1, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n\n    Args:\n    - nums: A list of integers.\n    - target: The target value.\n\n    Returns:\n    - The product of the two numbers that add up to the target.\n    \"\"\"\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return num * complement\n        seen[num] = i\n    return -1\n\ndef g():\n    nums = [2, 3, 4, 5, 6]\n    target = 9\n    return nums, target\n\nassert f(*g()) == 20\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 384, "target_skills": [0, 0, 0, 0, 0, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n\n    Args:\n    - nums: A list of integers.\n    - target: The target value.\n\n    Returns:\n    - The product of the two numbers that add up to the target.\n    \"\"\"\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return num * complement\n        seen[num] = i\n    return -1", "solution_func": "def g():\n    nums = [2, 3, 4, 5, 6]\n    target = 9\n    return nums, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of the bitwise XOR of all pairs of numbers in the list.\n\n    Example:\n    nums = [1, 2, 3]\n\n    Output:\n    2 (1^2 + 1^3 + 2^3 = 2)\n    \"\"\"\n    n = len(nums)\n    xor_sum = 0\n\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum += nums[i] ^ nums[j]\n\n    return xor_sum\n\ndef g():\n    \"\"\"\n    Generate a list of random integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 28\n", "emb": null, "idx_generation": 384, "target_skills": [0, 1, 0, 0, 0, 0, 1, 1, 0, 1], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of the bitwise XOR of all pairs of numbers in the list.\n\n    Example:\n    nums = [1, 2, 3]\n\n    Output:\n    2 (1^2 + 1^3 + 2^3 = 2)\n    \"\"\"\n    n = len(nums)\n    xor_sum = 0\n\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum += nums[i] ^ nums[j]\n\n    return xor_sum", "solution_func": "def g():\n    \"\"\"\n    Generate a list of random integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]", "map_ix": null}, {"fitness": 1.0, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum of values along a path from the top-left corner to the bottom-right corner.\n\n    Example:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\n    Output:\n    7 (1 + 3 + 1 + 1 + 1 = 7)\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g():\n    \"\"\"\n    Generate a grid of random integers.\n    \"\"\"\n    return [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\nassert f(g()) == 7\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0], "idx_generation": 384, "target_skills": [1, 1, 0, 0, 0, 1, 0, 0, 0, 1], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum of values along a path from the top-left corner to the bottom-right corner.\n\n    Example:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\n    Output:\n    7 (1 + 3 + 1 + 1 + 1 = 7)\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g():\n    \"\"\"\n    Generate a grid of random integers.\n    \"\"\"\n    return [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]", "map_ix": [0, 0, 0, 1, 0, 0, 1, 1, 0, 1]}, {"fitness": 1.0, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that sum up to the target value.\n    Return the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1] (nums[0] + nums[1] = 2 + 7 = 9)\n    \"\"\"\n    num_dict = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []\n\ndef g():\n    \"\"\"\n    Generate a list of random integers.\n    \"\"\"\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [0, 1]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 384, "target_skills": [1, 1, 1, 0, 0, 0, 1, 0, 0, 0], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that sum up to the target value.\n    Return the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1] (nums[0] + nums[1] = 2 + 7 = 9)\n    \"\"\"\n    num_dict = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []", "solution_func": "def g():\n    \"\"\"\n    Generate a list of random integers.\n    \"\"\"\n    return ([2, 7, 11, 15], 9)", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7 (1 + 3 + 1 + 1 + 1)\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n\n\n", "emb": null, "idx_generation": 384, "target_skills": [1, 0, 1, 1, 1, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7 (1 + 3 + 1 + 1 + 1)\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]", "solution_func": "def g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(adj_list: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given an adjacency list representing a directed graph, determine if there is a path from a start node to an end node.\n\n    Example:\n    adj_list = [[1, 2], [2], [3], [0, 4], [2]]\n\n    start = 0\n    end = 3\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 0 to node 3: 0 -> 2 -> 3.\n    \"\"\"\n    visited = set()\n    return dfs(adj_list, start, end, visited)\n\ndef dfs(adj_list: List[List[int]], curr: int, end: int, visited: set) -> bool:\n    if curr == end:\n        return True\n    \n    visited.add(curr)\n    \n    for neighbor in adj_list[curr]:\n        if neighbor not in visited:\n            if dfs(adj_list, neighbor, end, visited):\n                return True\n    \n    return False\n\ndef g() -> Tuple[List[List[int]], int, int]:\n    adj_list = [[1, 2], [2], [3], [0, 4], [2]]\n    start = 0\n    end = 3\n    \n    return adj_list, start, end\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 385, "target_skills": [0, 0, 1, 1, 0, 1, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(adj_list: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given an adjacency list representing a directed graph, determine if there is a path from a start node to an end node.\n\n    Example:\n    adj_list = [[1, 2], [2], [3], [0, 4], [2]]\n\n    start = 0\n    end = 3\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 0 to node 3: 0 -> 2 -> 3.\n    \"\"\"\n    visited = set()\n    return dfs(adj_list, start, end, visited)\n\ndef dfs(adj_list: List[List[int]], curr: int, end: int, visited: set) -> bool:\n    if curr == end:\n        return True\n    \n    visited.add(curr)\n    \n    for neighbor in adj_list[curr]:\n        if neighbor not in visited:\n            if dfs(adj_list, neighbor, end, visited):\n                return True\n    \n    return False", "solution_func": "def g() -> Tuple[List[List[int]], int, int]:\n    adj_list = [[1, 2], [2], [3], [0, 4], [2]]\n    start = 0\n    end = 3\n    \n    return adj_list, start, end", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the sum of all multiples of 3 or 5 below n.\n\n    Example:\n    n = 10\n\n    Output:\n    23\n\n    Explanation:\n    The multiples of 3 or 5 below 10 are: 3, 5, 6, 9. Their sum is 23.\n    \"\"\"\n    total = 0\n    \n    for i in range(n):\n        if i % 3 == 0 or i % 5 == 0:\n            total += i\n    \n    return total\n\ndef g() -> int:\n    n = 10\n    return n\n\nassert f(g()) == 23\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 385, "target_skills": [0, 0, 1, 1, 1, 1, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the sum of all multiples of 3 or 5 below n.\n\n    Example:\n    n = 10\n\n    Output:\n    23\n\n    Explanation:\n    The multiples of 3 or 5 below 10 are: 3, 5, 6, 9. Their sum is 23.\n    \"\"\"\n    total = 0\n    \n    for i in range(n):\n        if i % 3 == 0 or i % 5 == 0:\n            total += i\n    \n    return total", "solution_func": "def g() -> int:\n    n = 10\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of strings representing a maze, find the minimum number of steps required to reach the target.\n\n    Example:\n    grid = [\n        ['S', '.', '.', '#', '.', '.', '.'],\n        ['.', '#', '.', '.', '.', '#', '.'],\n        ['.', '#', '.', '.', '.', '.', '.'],\n        ['.', '.', '#', '#', '.', '.', '.'],\n        ['#', '.', '#', 'T', '.', '#', '.'],\n    ]\n\n    Output:\n    10\n\n    Explanation:\n    The minimum number of steps required to reach the target ('T') from the start ('S') is 10.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    start = None\n    target = None\n    \n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'T':\n                target = (i, j)\n    \n    return dfs(grid, start, target, 0)\n\ndef dfs(grid: List[List[str]], curr: Tuple[int, int], target: Tuple[int, int], steps: int) -> int:\n    if curr == target:\n        return steps\n    \n    x, y = curr\n    grid[x][y] = '#'  # Mark current position as visited\n    \n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    min_steps = float('inf')\n    \n    for dx, dy in directions:\n        nx, ny = x + dx, y + dy\n        \n        if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] != '#':\n            min_steps = min(min_steps, dfs(grid, (nx, ny), target, steps + 1))\n    \n    grid[x][y] = '.'  # Reset current position\n    \n    return min_steps\n\ndef g() -> List[List[str]]:\n    grid = [\n        ['S', '.', '.', '#', '.', '.', '.'],\n        ['.', '#', '.', '.', '.', '#', '.'],\n        ['.', '#', '.', '.', '.', '.', '.'],\n        ['.', '.', '#', '#', '.', '.', '.'],\n        ['#', '.', '#', 'T', '.', '#', '.'],\n    ]\n    \n    return grid\n\nassert f(g()) == 10\n\n", "emb": null, "idx_generation": 385, "target_skills": [0, 1, 1, 0, 0, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of strings representing a maze, find the minimum number of steps required to reach the target.\n\n    Example:\n    grid = [\n        ['S', '.', '.', '#', '.', '.', '.'],\n        ['.', '#', '.', '.', '.', '#', '.'],\n        ['.', '#', '.', '.', '.', '.', '.'],\n        ['.', '.', '#', '#', '.', '.', '.'],\n        ['#', '.', '#', 'T', '.', '#', '.'],\n    ]\n\n    Output:\n    10\n\n    Explanation:\n    The minimum number of steps required to reach the target ('T') from the start ('S') is 10.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    start = None\n    target = None\n    \n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'T':\n                target = (i, j)\n    \n    return dfs(grid, start, target, 0)\n\ndef dfs(grid: List[List[str]], curr: Tuple[int, int], target: Tuple[int, int], steps: int) -> int:\n    if curr == target:\n        return steps\n    \n    x, y = curr\n    grid[x][y] = '#'  # Mark current position as visited\n    \n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    min_steps = float('inf')\n    \n    for dx, dy in directions:\n        nx, ny = x + dx, y + dy\n        \n        if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] != '#':\n            min_steps = min(min_steps, dfs(grid, (nx, ny), target, steps + 1))\n    \n    grid[x][y] = '.'  # Reset current position\n    \n    return min_steps", "solution_func": "def g() -> List[List[str]]:\n    grid = [\n        ['S', '.', '.', '#', '.', '.', '.'],\n        ['.', '#', '.', '.', '.', '#', '.'],\n        ['.', '#', '.', '.', '.', '.', '.'],\n        ['.', '.', '#', '#', '.', '.', '.'],\n        ['#', '.', '#', 'T', '.', '#', '.'],\n    ]\n    \n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph, check if it is bipartite.\n    \"\"\"\n    visited = {}\n    for node in range(len(graph)):\n        if node not in visited:\n            if not dfs(graph, node, 0, visited):\n                return False\n    return True\n\ndef dfs(graph: List[List[int]], node: int, color: int, visited: dict) -> bool:\n    \"\"\"\n    Depth-first search to check if a graph is bipartite.\n    \"\"\"\n    visited[node] = color\n    for neighbor in graph[node]:\n        if neighbor in visited:\n            if visited[neighbor] == color:\n                return False\n        else:\n            if not dfs(graph, neighbor, 1-color, visited):\n                return False\n    return True\n\ndef g(graph: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Generate an undirected graph that is bipartite. Return the generated graph.\n    \"\"\"\n    return graph\n\nassert f(g([[1,3],[0,2],[1,3],[0,2]])) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 385, "target_skills": [1, 0, 0, 1, 0, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph, check if it is bipartite.\n    \"\"\"\n    visited = {}\n    for node in range(len(graph)):\n        if node not in visited:\n            if not dfs(graph, node, 0, visited):\n                return False\n    return True\n\ndef dfs(graph: List[List[int]], node: int, color: int, visited: dict) -> bool:\n    \"\"\"\n    Depth-first search to check if a graph is bipartite.\n    \"\"\"\n    visited[node] = color\n    for neighbor in graph[node]:\n        if neighbor in visited:\n            if visited[neighbor] == color:\n                return False\n        else:\n            if not dfs(graph, neighbor, 1-color, visited):\n                return False\n    return True", "solution_func": "def g(graph: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Generate an undirected graph that is bipartite. Return the generated graph.\n    \"\"\"\n    return graph", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, return the count of the occurrence of 1 as a digit in all the numbers from 0 to n (inclusive).\n    \"\"\"\n    count = 0\n    for num in range(n+1):\n        count += str(num).count('1')\n    return count\n\ndef g(n: int) -> int:\n    \"\"\"\n    Generate a non-negative integer. Return the generated integer.\n    \"\"\"\n    return n\n\nassert f(g(15)) == 8\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 385, "target_skills": [1, 1, 1, 0, 1, 0, 0, 0, 1, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, return the count of the occurrence of 1 as a digit in all the numbers from 0 to n (inclusive).\n    \"\"\"\n    count = 0\n    for num in range(n+1):\n        count += str(num).count('1')\n    return count", "solution_func": "def g(n: int) -> int:\n    \"\"\"\n    Generate a non-negative integer. Return the generated integer.\n    \"\"\"\n    return n", "map_ix": [0, 1, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an integer array nums, find the single number that appears only once. All other numbers appear twice.\n    \"\"\"\n    single_number = 0\n    for num in nums:\n        single_number ^= num\n    return single_number\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"\n    Generate an integer array where all numbers appear twice, except for one number that appears only once. Return the generated array.\n    \"\"\"\n    generated_nums = []\n    for num in nums:\n        generated_nums.append(num)\n        generated_nums.append(num)\n    return generated_nums\n\nassert f(g([2,2,1,3,3])) == 1\n", "emb": null, "idx_generation": 385, "target_skills": [1, 1, 0, 1, 0, 0, 0, 1, 1, 1], "problem_func": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an integer array nums, find the single number that appears only once. All other numbers appear twice.\n    \"\"\"\n    single_number = 0\n    for num in nums:\n        single_number ^= num\n    return single_number", "solution_func": "def g(nums: List[int]) -> List[int]:\n    \"\"\"\n    Generate an integer array where all numbers appear twice, except for one number that appears only once. Return the generated array.\n    \"\"\"\n    generated_nums = []\n    for num in nums:\n        generated_nums.append(num)\n        generated_nums.append(num)\n    return generated_nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of ways to arrange k items out of n, considering that the order matters.\n    \"\"\"\n    def factorial(num):\n        if num == 0 or num == 1:\n            return 1\n        else:\n            return num * factorial(num - 1)\n    \n    return factorial(n) // factorial(n - k)\n\ndef g(n=5, k=3):\n    \"\"\"\n    Generate two integers n and k such that there exists a valid number of ways to arrange k items out of n.\n    \"\"\"\n    return n, k\n\nassert f(*g()) == 60\n\n", "emb": [0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 385, "target_skills": [0, 1, 1, 1, 0, 1, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of ways to arrange k items out of n, considering that the order matters.\n    \"\"\"\n    def factorial(num):\n        if num == 0 or num == 1:\n            return 1\n        else:\n            return num * factorial(num - 1)\n    \n    return factorial(n) // factorial(n - k)", "solution_func": "def g(n=5, k=3):\n    \"\"\"\n    Generate two integers n and k such that there exists a valid number of ways to arrange k items out of n.\n    \"\"\"\n    return n, k", "map_ix": [0, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, determine if the graph is cyclic.\n    \"\"\"\n    def is_cyclic(node, visited, parent):\n        visited[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if is_cyclic(neighbor, visited, node):\n                    return True\n            elif parent != neighbor:\n                return True\n        \n        return False\n    \n    visited = [False] * len(graph)\n    \n    for node in range(len(graph)):\n        if not visited[node]:\n            if is_cyclic(node, visited, -1):\n                return True\n    \n    return False\n\ndef g(graph=[[1,2],[0,2],[0,1]]):\n    \"\"\"\n    Generate an undirected graph represented as an adjacency list.\n    \"\"\"\n    return graph\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 385, "target_skills": [1, 1, 1, 0, 0, 0, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, determine if the graph is cyclic.\n    \"\"\"\n    def is_cyclic(node, visited, parent):\n        visited[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if is_cyclic(neighbor, visited, node):\n                    return True\n            elif parent != neighbor:\n                return True\n        \n        return False\n    \n    visited = [False] * len(graph)\n    \n    for node in range(len(graph)):\n        if not visited[node]:\n            if is_cyclic(node, visited, -1):\n                return True\n    \n    return False", "solution_func": "def g(graph=[[1,2],[0,2],[0,1]]):\n    \"\"\"\n    Generate an undirected graph represented as an adjacency list.\n    \"\"\"\n    return graph", "map_ix": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of the words in the string.\n    \"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    reversed_string = \" \".join(reversed_words)\n    \n    return reversed_string\n\ndef g(s=\"Hello World\"):\n    \"\"\"\n    Generate a string that can be reversed by reversing the order of the words.\n    \"\"\"\n    return s\n\nassert f(*g()) == \"World Hello\"\n\n", "emb": null, "idx_generation": 385, "target_skills": [1, 0, 1, 0, 1, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of the words in the string.\n    \"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    reversed_string = \" \".join(reversed_words)\n    \n    return reversed_string", "solution_func": "def g(s=\"Hello World\"):\n    \"\"\"\n    Generate a string that can be reversed by reversing the order of the words.\n    \"\"\"\n    return s", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of the maximum subarray.\n\n    Args:\n    nums (List[int]): A list of integers.\n\n    Returns:\n    int: The sum of the maximum subarray.\n\n    Example:\n    Input:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n\n    n = len(nums)\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for i in range(n):\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for finding the maximum subarray sum.\n    \"\"\"\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 385, "target_skills": [0, 0, 0, 0, 0, 1, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of the maximum subarray.\n\n    Args:\n    nums (List[int]): A list of integers.\n\n    Returns:\n    int: The sum of the maximum subarray.\n\n    Example:\n    Input:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n\n    n = len(nums)\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for i in range(n):\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for finding the maximum subarray sum.\n    \"\"\"\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> bool:\n    \"\"\"\n    Given a list of words, check if all the words can be arranged in a crossword puzzle.\n    A crossword puzzle is a square or rectangular grid of white and black squares, which are arranged in such a way that the letters in the white squares form words, which can be read both horizontally and vertically.\n\n    Return True if all the words can be arranged in a crossword puzzle, False otherwise.\n\n    Example:\n    words = [\"DOG\", \"CAT\", \"FISH\", \"BIRD\"]\n\n    Output:\n    True\n\n    Explanation:\n    The words can be arranged in the following crossword puzzle:\n    D O G\n    O     A\n    G     T\n          H\n          I\n          S\n    B I R D\n    \"\"\"\n\n    # Create a grid with empty cells\n    grid = [[' ' for _ in range(len(max(words, key=len))))] * len(words)\n\n    # Place the first word horizontally in the middle row\n    row = len(words) // 2\n    col = (len(grid[0]) - len(words[0])) // 2\n    for i in range(len(words[0])):\n        grid[row][col + i] = words[0][i]\n\n    # Place the remaining words vertically\n    for i in range(1, len(words)):\n        word = words[i]\n        row = (len(grid) - len(word)) // 2\n        col = (len(grid[0]) - len(word)) // 2\n        for j in range(len(word)):\n            grid[row + j][col] = word[j]\n\n    # Check if all the cells are filled with letters\n    for row in grid:\n        if ' ' in row:\n            return False\n\n    return True\n\ndef g(words: List[str] = [\"DOG\", \"CAT\", \"FISH\", \"BIRD\"]):\n    return words\n\nassert f(g())\n\n", "emb": null, "idx_generation": 386, "target_skills": [0, 1, 0, 0, 0, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> bool:\n    \"\"\"\n    Given a list of words, check if all the words can be arranged in a crossword puzzle.\n    A crossword puzzle is a square or rectangular grid of white and black squares, which are arranged in such a way that the letters in the white squares form words, which can be read both horizontally and vertically.\n\n    Return True if all the words can be arranged in a crossword puzzle, False otherwise.\n\n    Example:\n    words = [\"DOG\", \"CAT\", \"FISH\", \"BIRD\"]\n\n    Output:\n    True\n\n    Explanation:\n    The words can be arranged in the following crossword puzzle:\n    D O G\n    O     A\n    G     T\n          H\n          I\n          S\n    B I R D\n    \"\"\"\n\n    # Create a grid with empty cells\n    grid = [[' ' for _ in range(len(max(words, key=len))))] * len(words)\n\n    # Place the first word horizontally in the middle row\n    row = len(words) // 2\n    col = (len(grid[0]) - len(words[0])) // 2\n    for i in range(len(words[0])):\n        grid[row][col + i] = words[0][i]\n\n    # Place the remaining words vertically\n    for i in range(1, len(words)):\n        word = words[i]\n        row = (len(grid) - len(word)) // 2\n        col = (len(grid[0]) - len(word)) // 2\n        for j in range(len(word)):\n            grid[row + j][col] = word[j]\n\n    # Check if all the cells are filled with letters\n    for row in grid:\n        if ' ' in row:\n            return False\n\n    return True", "solution_func": "def g(words: List[str] = [\"DOG\", \"CAT\", \"FISH\", \"BIRD\"]):\n    return words", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, check if it can be formed by concatenating words from a list of words.\n    The words can be concatenated in any order and any number of times.\n\n    Return True if the string s can be formed by concatenating words from the list, False otherwise.\n\n    Example:\n    s = \"applebananaorange\"\n\n    Output:\n    True\n\n    Explanation:\n    The string s can be formed by concatenating the words \"apple\", \"banana\", and \"orange\".\n    \"\"\"\n\n    def can_form_string(s, words):\n        if s == \"\":\n            return True\n\n        for word in words:\n            if s.startswith(word) and can_form_string(s[len(word):], words):\n                return True\n\n        return False\n\n    words = ['apple', 'banana', 'orange']\n    return can_form_string(s, words)\n\ndef g(s: str = \"applebananaorange\"):\n    return s\n\nassert f(g())\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 386, "target_skills": [0, 1, 0, 0, 0, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, check if it can be formed by concatenating words from a list of words.\n    The words can be concatenated in any order and any number of times.\n\n    Return True if the string s can be formed by concatenating words from the list, False otherwise.\n\n    Example:\n    s = \"applebananaorange\"\n\n    Output:\n    True\n\n    Explanation:\n    The string s can be formed by concatenating the words \"apple\", \"banana\", and \"orange\".\n    \"\"\"\n\n    def can_form_string(s, words):\n        if s == \"\":\n            return True\n\n        for word in words:\n            if s.startswith(word) and can_form_string(s[len(word):], words):\n                return True\n\n        return False\n\n    words = ['apple', 'banana', 'orange']\n    return can_form_string(s, words)", "solution_func": "def g(s: str = \"applebananaorange\"):\n    return s", "map_ix": [0, 1, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the sum of all elements in the grid, using a stack.\n\n    Return the sum of all elements in the grid.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    Output:\n    45\n\n    Explanation:\n    The sum of all elements in the grid is 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45.\n    \"\"\"\n\n    stack = []\n    for row in grid:\n        for num in row:\n            stack.append(num)\n\n    total_sum = 0\n    while stack:\n        total_sum += stack.pop()\n\n    return total_sum\n\ndef g(grid: List[List[int]] = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return grid\n\nassert f(g()) == 45\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 386, "target_skills": [0, 0, 1, 1, 1, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the sum of all elements in the grid, using a stack.\n\n    Return the sum of all elements in the grid.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    Output:\n    45\n\n    Explanation:\n    The sum of all elements in the grid is 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45.\n    \"\"\"\n\n    stack = []\n    for row in grid:\n        for num in row:\n            stack.append(num)\n\n    total_sum = 0\n    while stack:\n        total_sum += stack.pop()\n\n    return total_sum", "solution_func": "def g(grid: List[List[int]] = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> List[List[int]]:\n    \"\"\"\n    Given two integers n and m, generate a matrix of size n x m where each element is the product of its row number and column number.\n\n    Example:\n    n = 3, m = 4\n\n    Output:\n    [[0, 0, 0, 0],\n     [0, 1, 2, 3],\n     [0, 2, 4, 6]]\n\n    Explanation:\n    The matrix is generated as follows:\n    - The first row and first column contain all zeros.\n    - Each element in the matrix is the product of its row number and column number.\n\n    Hint: Use nested loops to iterate over the rows and columns of the matrix.\n    \"\"\"\n\n    matrix = []\n\n    for i in range(n):\n        row = []\n        for j in range(m):\n            row.append(i * j)\n        matrix.append(row)\n\n    return matrix\n\ndef g() -> List[int]:\n    n = 3\n    m = 4\n    return n, m\n\nassert f(*g()) == [[0, 0, 0, 0], [0, 1, 2, 3], [0, 2, 4, 6]]\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0], "idx_generation": 386, "target_skills": [1, 1, 1, 0, 1, 1, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> List[List[int]]:\n    \"\"\"\n    Given two integers n and m, generate a matrix of size n x m where each element is the product of its row number and column number.\n\n    Example:\n    n = 3, m = 4\n\n    Output:\n    [[0, 0, 0, 0],\n     [0, 1, 2, 3],\n     [0, 2, 4, 6]]\n\n    Explanation:\n    The matrix is generated as follows:\n    - The first row and first column contain all zeros.\n    - Each element in the matrix is the product of its row number and column number.\n\n    Hint: Use nested loops to iterate over the rows and columns of the matrix.\n    \"\"\"\n\n    matrix = []\n\n    for i in range(n):\n        row = []\n        for j in range(m):\n            row.append(i * j)\n        matrix.append(row)\n\n    return matrix", "solution_func": "def g() -> List[int]:\n    n = 3\n    m = 4\n    return n, m", "map_ix": [1, 1, 0, 1, 0, 1, 1, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a subgrid where the subgrid is a rectangular region within the grid.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    Output:\n    45\n\n    Explanation:\n    The maximum sum is obtained from the subgrid [[5, 6], [8, 9]], which has a sum of 45.\n\n    Hint: Use dynamic programming to calculate the sum of subgrids efficiently.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Calculate the cumulative sum of each row\n    for i in range(rows):\n        for j in range(1, cols):\n            grid[i][j] += grid[i][j - 1]\n\n    max_sum = float('-inf')\n\n    # Calculate the sum of each subgrid\n    for left in range(cols):\n        for right in range(left, cols):\n            current_sum = 0\n            for row in range(rows):\n                if left > 0:\n                    current_sum += grid[row][right] - grid[row][left - 1]\n                else:\n                    current_sum += grid[row][right]\n                max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[List[int]]:\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 45\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 386, "target_skills": [1, 0, 1, 1, 0, 1, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a subgrid where the subgrid is a rectangular region within the grid.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    Output:\n    45\n\n    Explanation:\n    The maximum sum is obtained from the subgrid [[5, 6], [8, 9]], which has a sum of 45.\n\n    Hint: Use dynamic programming to calculate the sum of subgrids efficiently.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Calculate the cumulative sum of each row\n    for i in range(rows):\n        for j in range(1, cols):\n            grid[i][j] += grid[i][j - 1]\n\n    max_sum = float('-inf')\n\n    # Calculate the sum of each subgrid\n    for left in range(cols):\n        for right in range(left, cols):\n            current_sum = 0\n            for row in range(rows):\n                if left > 0:\n                    current_sum += grid[row][right] - grid[row][left - 1]\n                else:\n                    current_sum += grid[row][right]\n                max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g() -> List[List[int]]:\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum number of steps required to reach the bottom-right corner of the grid from the top-left corner.\n    You can only move down or right.\n\n    Example:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum number of steps required is 7 (1 -> 3 -> 1 -> 1 -> 1 -> 2 -> 1).\n\n    Hint: Use dynamic programming to calculate the minimum number of steps efficiently.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Calculate the cumulative sum of each row\n    for i in range(1, rows):\n        grid[i][0] += grid[i - 1][0]\n\n    # Calculate the cumulative sum of each column\n    for j in range(1, cols):\n        grid[0][j] += grid[0][j - 1]\n\n    # Calculate the minimum number of steps\n    for i in range(1, rows):\n        for j in range(1, cols):\n            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n\n    return grid[rows - 1][cols - 1]\n\ndef g() -> List[List[int]]:\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 7\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 386, "target_skills": [0, 1, 0, 1, 1, 0, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum number of steps required to reach the bottom-right corner of the grid from the top-left corner.\n    You can only move down or right.\n\n    Example:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum number of steps required is 7 (1 -> 3 -> 1 -> 1 -> 1 -> 2 -> 1).\n\n    Hint: Use dynamic programming to calculate the minimum number of steps efficiently.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Calculate the cumulative sum of each row\n    for i in range(1, rows):\n        grid[i][0] += grid[i - 1][0]\n\n    # Calculate the cumulative sum of each column\n    for j in range(1, cols):\n        grid[0][j] += grid[0][j - 1]\n\n    # Calculate the minimum number of steps\n    for i in range(1, rows):\n        for j in range(1, cols):\n            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n\n    return grid[rows - 1][cols - 1]", "solution_func": "def g() -> List[List[int]]:\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, determine if the graph contains any cycles.\n\n    Example:\n    graph = [[1, 2], [3], [3, 4], [4], []]\n\n    Output:\n    True (the graph contains cycles)\n    \"\"\"\n    n = len(graph)\n    visited = [False] * n\n    \n    def dfs(node, parent):\n        visited[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node):\n                    return True\n            elif neighbor != parent:\n                return True\n        \n        return False\n    \n    for i in range(n):\n        if not visited[i]:\n            if dfs(i, -1):\n                return True\n    \n    return False\n\ndef g() -> List[List[int]]:\n    graph = [[1, 2], [3], [3, 4], [4], []]\n    return graph\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 386, "target_skills": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, determine if the graph contains any cycles.\n\n    Example:\n    graph = [[1, 2], [3], [3, 4], [4], []]\n\n    Output:\n    True (the graph contains cycles)\n    \"\"\"\n    n = len(graph)\n    visited = [False] * n\n    \n    def dfs(node, parent):\n        visited[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node):\n                    return True\n            elif neighbor != parent:\n                return True\n        \n        return False\n    \n    for i in range(n):\n        if not visited[i]:\n            if dfs(i, -1):\n                return True\n    \n    return False", "solution_func": "def g() -> List[List[int]]:\n    graph = [[1, 2], [3], [3, 4], [4], []]\n    return graph", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of all the words in the string while maintaining the order of the characters within each word.\n\n    Example:\n    s = \"Hello World!\"\n\n    Output:\n    \"World! Hello\"\n    \"\"\"\n    words = s.split()\n    return ' '.join(words[::-1])\n\ndef g() -> str:\n    s = \"Hello World!\"\n    return s\n\nassert f(g()) == \"World! Hello\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 386, "target_skills": [1, 0, 1, 0, 0, 0, 0, 1, 0, 1], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of all the words in the string while maintaining the order of the characters within each word.\n\n    Example:\n    s = \"Hello World!\"\n\n    Output:\n    \"World! Hello\"\n    \"\"\"\n    words = s.split()\n    return ' '.join(words[::-1])", "solution_func": "def g() -> str:\n    s = \"Hello World!\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return the list in reverse order.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    [5, 4, 3, 2, 1]\n    \"\"\"\n    return nums[::-1]\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == [5, 4, 3, 2, 1]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 386, "target_skills": [1, 0, 1, 1, 1, 1, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return the list in reverse order.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    [5, 4, 3, 2, 1]\n    \"\"\"\n    return nums[::-1]", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the second smallest number.\n\n    Example:\n    nums = [5, 3, 1, 7, 2]\n\n    Output:\n    2\n\n    Explanation:\n    The second smallest number in the list is 2.\n\n    Hint: You can solve this problem by sorting the list and returning the second element.\n    \"\"\"\n\n    nums.sort()\n    return nums[1]\n\ndef g(nums=[5, 3, 1, 7, 2]):\n    return nums\n\nassert f(g()) == 2\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 386, "target_skills": [0, 1, 0, 0, 1, 0, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the second smallest number.\n\n    Example:\n    nums = [5, 3, 1, 7, 2]\n\n    Output:\n    2\n\n    Explanation:\n    The second smallest number in the list is 2.\n\n    Hint: You can solve this problem by sorting the list and returning the second element.\n    \"\"\"\n\n    nums.sort()\n    return nums[1]", "solution_func": "def g(nums=[5, 3, 1, 7, 2]):\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, check if the graph contains a cycle.\n\n    Args:\n    - graph: A list of lists, where each inner list represents the neighbors of a node.\n    \n    Returns:\n    - True if the graph contains a cycle, False otherwise.\n    \"\"\"\n    visited = set()\n    def dfs(node, parent):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, node):\n                    return True\n            elif neighbor != parent:\n                return True\n        return False\n    \n    for node in range(len(graph)):\n        if node not in visited:\n            if dfs(node, -1):\n                return True\n    return False\n\ndef g():\n    graph = [[1, 2], [0, 2], [0, 1, 3], [2, 4], [3]]\n    return graph\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 387, "target_skills": [1, 0, 1, 0, 1, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, check if the graph contains a cycle.\n\n    Args:\n    - graph: A list of lists, where each inner list represents the neighbors of a node.\n    \n    Returns:\n    - True if the graph contains a cycle, False otherwise.\n    \"\"\"\n    visited = set()\n    def dfs(node, parent):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, node):\n                    return True\n            elif neighbor != parent:\n                return True\n        return False\n    \n    for node in range(len(graph)):\n        if node not in visited:\n            if dfs(node, -1):\n                return True\n    return False", "solution_func": "def g():\n    graph = [[1, 2], [0, 2], [0, 1, 3], [2, 4], [3]]\n    return graph", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 1s and 0s, find the length of the largest island.\n\n    Args:\n    - grid: A list of lists, where each inner list represents a row in the grid.\n    \n    Returns:\n    - The length of the largest island in the grid.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    max_island = 0\n    \n    def dfs(row, col):\n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] != 1:\n            return 0\n        \n        grid[row][col] = -1\n        island_size = 1\n        \n        island_size += dfs(row+1, col)\n        island_size += dfs(row-1, col)\n        island_size += dfs(row, col+1)\n        island_size += dfs(row, col-1)\n        \n        return island_size\n    \n    for row in range(rows):\n        for col in range(cols):\n            if grid[row][col] == 1:\n                max_island = max(max_island, dfs(row, col))\n    \n    return max_island\n\ndef g():\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 0, 1, 1],\n        [0, 0, 0, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 387, "target_skills": [1, 1, 0, 1, 0, 1, 1, 1, 1, 0], "problem_func": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 1s and 0s, find the length of the largest island.\n\n    Args:\n    - grid: A list of lists, where each inner list represents a row in the grid.\n    \n    Returns:\n    - The length of the largest island in the grid.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    max_island = 0\n    \n    def dfs(row, col):\n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] != 1:\n            return 0\n        \n        grid[row][col] = -1\n        island_size = 1\n        \n        island_size += dfs(row+1, col)\n        island_size += dfs(row-1, col)\n        island_size += dfs(row, col+1)\n        island_size += dfs(row, col-1)\n        \n        return island_size\n    \n    for row in range(rows):\n        for col in range(cols):\n            if grid[row][col] == 1:\n                max_island = max(max_island, dfs(row, col))\n    \n    return max_island", "solution_func": "def g():\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 0, 1, 1],\n        [0, 0, 0, 1, 1]\n    ]\n    return grid", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\nclass Stack:\n    def __init__(self):\n        self.stack = []\n    \n    def push(self, x):\n        self.stack.append(x)\n    \n    def pop(self):\n        if not self.is_empty():\n            return self.stack.pop()\n        return None\n    \n    def is_empty(self):\n        return len(self.stack) == 0\n    \n    def top(self):\n        if not self.is_empty():\n            return self.stack[-1]\n        return None\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of heights representing a bar graph, find the largest rectangular area that can be formed\n    by a rectangle contained entirely within the bar graph.\n\n    Args:\n    - heights: A list of integers representing the heights of the bars in the graph.\n    \n    Returns:\n    - The area of the largest rectangle that can be formed.\n    \"\"\"\n    n = len(heights)\n    stack = Stack()\n    max_area = 0\n    i = 0\n    \n    while i < n:\n        if stack.is_empty() or heights[i] >= heights[stack.top()]:\n            stack.push(i)\n            i += 1\n        else:\n            top = stack.pop()\n            area = heights[top] * (i if stack.is_empty() else i - stack.top() - 1)\n            max_area = max(max_area, area)\n    \n    while not stack.is_empty():\n        top = stack.pop()\n        area = heights[top] * (i if stack.is_empty() else i - stack.top() - 1)\n        max_area = max(max_area, area)\n    \n    return max_area\n\ndef g():\n    heights = [2, 1, 5, 6, 2, 3]\n    return heights\n\nassert f(g()) == 10\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 387, "target_skills": [1, 0, 0, 1, 1, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\nclass Stack:\n    def __init__(self):\n        self.stack = []\n    \n    def push(self, x):\n        self.stack.append(x)\n    \n    def pop(self):\n        if not self.is_empty():\n            return self.stack.pop()\n        return None\n    \n    def is_empty(self):\n        return len(self.stack) == 0\n    \n    def top(self):\n        if not self.is_empty():\n            return self.stack[-1]\n        return None\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of heights representing a bar graph, find the largest rectangular area that can be formed\n    by a rectangle contained entirely within the bar graph.\n\n    Args:\n    - heights: A list of integers representing the heights of the bars in the graph.\n    \n    Returns:\n    - The area of the largest rectangle that can be formed.\n    \"\"\"\n    n = len(heights)\n    stack = Stack()\n    max_area = 0\n    i = 0\n    \n    while i < n:\n        if stack.is_empty() or heights[i] >= heights[stack.top()]:\n            stack.push(i)\n            i += 1\n        else:\n            top = stack.pop()\n            area = heights[top] * (i if stack.is_empty() else i - stack.top() - 1)\n            max_area = max(max_area, area)\n    \n    while not stack.is_empty():\n        top = stack.pop()\n        area = heights[top] * (i if stack.is_empty() else i - stack.top() - 1)\n        max_area = max(max_area, area)\n    \n    return max_area", "solution_func": "def g():\n    heights = [2, 1, 5, 6, 2, 3]\n    return heights", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any subarray where the sum is a perfect square.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n    output: 9\n\n    Explanation:\n    The subarray with the maximum sum that is a perfect square is [4, 5], and the sum is 9.\n    \"\"\"\n    def is_perfect_square(n):\n        sqrt = int(n ** 0.5)\n        return sqrt * sqrt == n\n\n    max_sum = 0\n    curr_sum = 0\n    for num in nums:\n        curr_sum += num\n        if is_perfect_square(curr_sum):\n            max_sum = max(max_sum, curr_sum)\n        elif curr_sum < 0:\n            curr_sum = 0\n\n    return max_sum\n\ndef g():\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g()) == 9\n", "emb": null, "idx_generation": 387, "target_skills": [0, 0, 0, 0, 0, 1, 0, 1, 0, 1], "problem_func": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any subarray where the sum is a perfect square.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n    output: 9\n\n    Explanation:\n    The subarray with the maximum sum that is a perfect square is [4, 5], and the sum is 9.\n    \"\"\"\n    def is_perfect_square(n):\n        sqrt = int(n ** 0.5)\n        return sqrt * sqrt == n\n\n    max_sum = 0\n    curr_sum = 0\n    for num in nums:\n        curr_sum += num\n        if is_perfect_square(curr_sum):\n            max_sum = max(max_sum, curr_sum)\n        elif curr_sum < 0:\n            curr_sum = 0\n\n    return max_sum", "solution_func": "def g():\n    return [1, 2, 3, 4, 5, 6]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid represented by a list of lists, find the number of islands.\n\n    An island is a group of connected 1s, where a cell is considered connected to its adjacent cells\n    horizontally or vertically. Cells connected diagonally are not considered connected.\n\n    Example:\n    grid = [[1, 1, 0, 0, 0],\n            [1, 1, 0, 0, 0],\n            [0, 0, 1, 0, 0],\n            [0, 0, 0, 1, 1]]\n    output: 3\n\n    Explanation:\n    There are 3 islands in the grid: one with 4 cells, one with 2 cells, and one with 2 cells.\n    \"\"\"\n    def dfs(grid, row, col):\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] != 1:\n            return\n        \n        grid[row][col] = -1\n        \n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        for dr, dc in directions:\n            new_row, new_col = row + dr, col + dc\n            dfs(grid, new_row, new_col)\n    \n    count = 0\n    for row in range(len(grid)):\n        for col in range(len(grid[0])):\n            if grid[row][col] == 1:\n                dfs(grid, row, col)\n                count += 1\n    \n    return count\n\ndef g():\n    return [[1, 1, 0, 0, 0],\n            [1, 1, 0, 0, 0],\n            [0, 0, 1, 0, 0],\n            [0, 0, 0, 1, 1]]\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 387, "target_skills": [1, 0, 1, 1, 0, 1, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid represented by a list of lists, find the number of islands.\n\n    An island is a group of connected 1s, where a cell is considered connected to its adjacent cells\n    horizontally or vertically. Cells connected diagonally are not considered connected.\n\n    Example:\n    grid = [[1, 1, 0, 0, 0],\n            [1, 1, 0, 0, 0],\n            [0, 0, 1, 0, 0],\n            [0, 0, 0, 1, 1]]\n    output: 3\n\n    Explanation:\n    There are 3 islands in the grid: one with 4 cells, one with 2 cells, and one with 2 cells.\n    \"\"\"\n    def dfs(grid, row, col):\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] != 1:\n            return\n        \n        grid[row][col] = -1\n        \n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        for dr, dc in directions:\n            new_row, new_col = row + dr, col + dc\n            dfs(grid, new_row, new_col)\n    \n    count = 0\n    for row in range(len(grid)):\n        for col in range(len(grid[0])):\n            if grid[row][col] == 1:\n                dfs(grid, row, col)\n                count += 1\n    \n    return count", "solution_func": "def g():\n    return [[1, 1, 0, 0, 0],\n            [1, 1, 0, 0, 0],\n            [0, 0, 1, 0, 0],\n            [0, 0, 0, 1, 1]]", "map_ix": [0, 0, 1, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Count the number of positive integers less than or equal to n that can be expressed as\n    the sum of two cubes of positive integers.\n\n    Example:\n    n = 10\n    output: 7\n\n    Explanation:\n    The positive integers less than or equal to 10 that can be expressed as the sum of two cubes\n    are: 1, 2, 8, 9, 10, which gives a total count of 5.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n ** (1/3)) + 1):\n        for j in range(i, int(n ** (1/3)) + 1):\n            num = i ** 3 + j ** 3\n            if num <= n:\n                count += 1\n    \n    return count\n\ndef g():\n    return 10\n\nassert f(g()) == 5\n", "emb": null, "idx_generation": 387, "target_skills": [0, 0, 0, 1, 0, 0, 0, 1, 0, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Count the number of positive integers less than or equal to n that can be expressed as\n    the sum of two cubes of positive integers.\n\n    Example:\n    n = 10\n    output: 7\n\n    Explanation:\n    The positive integers less than or equal to 10 that can be expressed as the sum of two cubes\n    are: 1, 2, 8, 9, 10, which gives a total count of 5.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n ** (1/3)) + 1):\n        for j in range(i, int(n ** (1/3)) + 1):\n            num = i ** 3 + j ** 3\n            if num <= n:\n                count += 1\n    \n    return count", "solution_func": "def g():\n    return 10", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two numbers in the list that sum up to the target.\n\n    Args:\n    - arr: A sorted list of integers.\n    - target: The target value.\n\n    Returns:\n    - True if there are two numbers in the list that sum up to the target, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    target = 9\n    return arr, target\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 387, "target_skills": [1, 1, 0, 0, 1, 0, 0, 1, 1, 0], "problem_func": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two numbers in the list that sum up to the target.\n\n    Args:\n    - arr: A sorted list of integers.\n    - target: The target value.\n\n    Returns:\n    - True if there are two numbers in the list that sum up to the target, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False", "solution_func": "def g():\n    arr = [1, 2, 3, 4, 5]\n    target = 9\n    return arr, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Generate a square grid of size n x n where each cell contains the bitwise XOR of its row and column indices.\n\n    Args:\n    - n: The size of the grid.\n\n    Returns:\n    - A 2D list representing the grid.\n    \"\"\"\n    grid = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            grid[i][j] = i ^ j\n    return grid\n\ndef g():\n    n = 4\n    return n\n\nassert f(g()) == [[0, 1, 2, 3], [1, 0, 3, 2], [2, 3, 0, 1], [3, 2, 1, 0]]\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 387, "target_skills": [1, 1, 1, 0, 0, 1, 0, 0, 1, 1], "problem_func": "from typing import*\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Generate a square grid of size n x n where each cell contains the bitwise XOR of its row and column indices.\n\n    Args:\n    - n: The size of the grid.\n\n    Returns:\n    - A 2D list representing the grid.\n    \"\"\"\n    grid = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            grid[i][j] = i ^ j\n    return grid", "solution_func": "def g():\n    n = 4\n    return n", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if a string is a valid palindrome after removing at most one character.\n\n    Args:\n    - s: A string.\n\n    Returns:\n    - True if the string is a valid palindrome after removing at most one character, False otherwise.\n    \"\"\"\n    i = 0\n    j = len(s) - 1\n    while i < j:\n        if s[i] != s[j]:\n            return is_palindrome(s, i + 1, j) or is_palindrome(s, i, j - 1)\n        i += 1\n        j -= 1\n    return True\n\ndef is_palindrome(s: str, i: int, j: int) -> bool:\n    while i < j:\n        if s[i] != s[j]:\n            return False\n        i += 1\n        j -= 1\n    return True\n\ndef g():\n    s = \"abca\"\n    return s\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 387, "target_skills": [1, 0, 1, 1, 0, 0, 0, 1, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if a string is a valid palindrome after removing at most one character.\n\n    Args:\n    - s: A string.\n\n    Returns:\n    - True if the string is a valid palindrome after removing at most one character, False otherwise.\n    \"\"\"\n    i = 0\n    j = len(s) - 1\n    while i < j:\n        if s[i] != s[j]:\n            return is_palindrome(s, i + 1, j) or is_palindrome(s, i, j - 1)\n        i += 1\n        j -= 1\n    return True\n\ndef is_palindrome(s: str, i: int, j: int) -> bool:\n    while i < j:\n        if s[i] != s[j]:\n            return False\n        i += 1\n        j -= 1\n    return True", "solution_func": "def g():\n    s = \"abca\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, wordDict: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a dictionary of words wordDict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.\n\n    Example:\n    s = \"leetcode\"\n    wordDict = [\"leet\", \"code\"]\n\n    Output:\n    True\n\n    Explanation:\n    The string \"leetcode\" can be segmented into \"leet\" and \"code\".\n\n    Hint: Use dynamic programming to keep track of whether a substring of s can be segmented into dictionary words. Iterate through the string and check if a substring starting from each index can be formed using the words in the dictionary.\n    \"\"\"\n\n    n = len(s)\n    dp = [False] * (n + 1)\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in wordDict:\n                dp[i] = True\n                break\n\n    return dp[n]\n\ndef g() -> Tuple[str, List[str]]:\n    s = \"leetcode\"\n    wordDict = [\"leet\", \"code\"]\n    return s, wordDict\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 387, "target_skills": [1, 0, 1, 1, 1, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str, wordDict: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a dictionary of words wordDict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.\n\n    Example:\n    s = \"leetcode\"\n    wordDict = [\"leet\", \"code\"]\n\n    Output:\n    True\n\n    Explanation:\n    The string \"leetcode\" can be segmented into \"leet\" and \"code\".\n\n    Hint: Use dynamic programming to keep track of whether a substring of s can be segmented into dictionary words. Iterate through the string and check if a substring starting from each index can be formed using the words in the dictionary.\n    \"\"\"\n\n    n = len(s)\n    dp = [False] * (n + 1)\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in wordDict:\n                dp[i] = True\n                break\n\n    return dp[n]", "solution_func": "def g() -> Tuple[str, List[str]]:\n    s = \"leetcode\"\n    wordDict = [\"leet\", \"code\"]\n    return s, wordDict", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, return the sum of all the elements in the matrix.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    45 (sum of all elements in the matrix)\n    \"\"\"\n    total_sum = 0\n    for row in matrix:\n        for num in row:\n            total_sum += num\n    return total_sum\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == 45\n\n", "emb": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "idx_generation": 388, "target_skills": [0, 0, 1, 1, 0, 0, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, return the sum of all the elements in the matrix.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    45 (sum of all elements in the matrix)\n    \"\"\"\n    total_sum = 0\n    for row in matrix:\n        for num in row:\n            total_sum += num\n    return total_sum", "solution_func": "def g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix", "map_ix": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters representing a maze, find the minimum number of steps required to reach the exit.\n    The grid is represented by a 2D list of characters, where 'S' represents the starting position, 'E' represents the exit, 'X' represents walls,\n    and '.' represents empty cells that can be traversed.\n\n    You can only move in four directions: up, down, left, and right.\n    Return the minimum number of steps required to reach the exit. If it is not possible to reach the exit, return -1.\n\n    Example:\n    grid = [\n        ['S', '.', '.', '.', '.'],\n        ['.', 'X', 'X', 'X', '.'],\n        ['.', '.', '.', '.', 'E']\n    ]\n\n    Output:\n    7 (minimum number of steps required to reach the exit)\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    start = None\n    exit = None\n\n    # Find the starting position and exit position\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'E':\n                exit = (i, j)\n\n    if not start or not exit:\n        return -1\n\n    # Perform breadth-first search to find the minimum number of steps\n    queue = [(start, 0)]\n    visited = set()\n\n    while queue:\n        position, steps = queue.pop(0)\n        row, col = position\n\n        if position == exit:\n            return steps\n\n        # Check all four directions\n        directions = [(row-1, col), (row+1, col), (row, col-1), (row, col+1)]\n        for direction in directions:\n            new_row, new_col = direction\n\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] != 'X' and (new_row, new_col) not in visited:\n                visited.add((new_row, new_col))\n                queue.append(((new_row, new_col), steps+1))\n\n    return -1\n\ndef g():\n    grid = [\n        ['S', '.', '.', '.', '.'],\n        ['.', 'X', 'X', 'X', '.'],\n        ['.', '.', '.', '.', 'E']\n    ]\n    return grid\n\nassert f(g()) == 7\n\n", "emb": null, "idx_generation": 388, "target_skills": [0, 0, 0, 0, 0, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters representing a maze, find the minimum number of steps required to reach the exit.\n    The grid is represented by a 2D list of characters, where 'S' represents the starting position, 'E' represents the exit, 'X' represents walls,\n    and '.' represents empty cells that can be traversed.\n\n    You can only move in four directions: up, down, left, and right.\n    Return the minimum number of steps required to reach the exit. If it is not possible to reach the exit, return -1.\n\n    Example:\n    grid = [\n        ['S', '.', '.', '.', '.'],\n        ['.', 'X', 'X', 'X', '.'],\n        ['.', '.', '.', '.', 'E']\n    ]\n\n    Output:\n    7 (minimum number of steps required to reach the exit)\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    start = None\n    exit = None\n\n    # Find the starting position and exit position\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'E':\n                exit = (i, j)\n\n    if not start or not exit:\n        return -1\n\n    # Perform breadth-first search to find the minimum number of steps\n    queue = [(start, 0)]\n    visited = set()\n\n    while queue:\n        position, steps = queue.pop(0)\n        row, col = position\n\n        if position == exit:\n            return steps\n\n        # Check all four directions\n        directions = [(row-1, col), (row+1, col), (row, col-1), (row, col+1)]\n        for direction in directions:\n            new_row, new_col = direction\n\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] != 'X' and (new_row, new_col) not in visited:\n                visited.add((new_row, new_col))\n                queue.append(((new_row, new_col), steps+1))\n\n    return -1", "solution_func": "def g():\n    grid = [\n        ['S', '.', '.', '.', '.'],\n        ['.', 'X', 'X', 'X', '.'],\n        ['.', '.', '.', '.', 'E']\n    ]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Given two integers n and k, generate all possible combinations of k numbers from 1 to n.\n\n    Example:\n    n = 4, k = 2\n\n    Output:\n    [\n        [1, 2],\n        [1, 3],\n        [1, 4],\n        [2, 3],\n        [2, 4],\n        [3, 4]\n    ]\n    \"\"\"\n    combinations = []\n    backtrack([], 1, n, k, combinations)\n    return combinations\n\ndef backtrack(current_combination, start, n, k, combinations):\n    if len(current_combination) == k:\n        combinations.append(current_combination[:])\n        return\n\n    for i in range(start, n+1):\n        current_combination.append(i)\n        backtrack(current_combination, i+1, n, k, combinations)\n        current_combination.pop()\n\ndef g():\n    n = 4\n    k = 2\n    return n, k\n\nassert f(*g()) == [\n    [1, 2],\n    [1, 3],\n    [1, 4],\n    [2, 3],\n    [2, 4],\n    [3, 4]\n]\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 388, "target_skills": [1, 1, 0, 1, 0, 0, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Given two integers n and k, generate all possible combinations of k numbers from 1 to n.\n\n    Example:\n    n = 4, k = 2\n\n    Output:\n    [\n        [1, 2],\n        [1, 3],\n        [1, 4],\n        [2, 3],\n        [2, 4],\n        [3, 4]\n    ]\n    \"\"\"\n    combinations = []\n    backtrack([], 1, n, k, combinations)\n    return combinations\n\ndef backtrack(current_combination, start, n, k, combinations):\n    if len(current_combination) == k:\n        combinations.append(current_combination[:])\n        return\n\n    for i in range(start, n+1):\n        current_combination.append(i)\n        backtrack(current_combination, i+1, n, k, combinations)\n        current_combination.pop()", "solution_func": "def g():\n    n = 4\n    k = 2\n    return n, k", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Count the number of islands in a grid, where 1 represents land and 0 represents water.\"\"\"\n    def dfs(grid, row, col):\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] != 1:\n            return\n        grid[row][col] = -1\n        dfs(grid, row+1, col)\n        dfs(grid, row-1, col)\n        dfs(grid, row, col+1)\n        dfs(grid, row, col-1)\n    \n    count = 0\n    for row in range(len(grid)):\n        for col in range(len(grid[0])):\n            if grid[row][col] == 1:\n                count += 1\n                dfs(grid, row, col)\n    \n    return count\n\ndef g(grid=[[1,1,0,0,0],\n            [1,1,0,0,0],\n            [0,0,1,0,0],\n            [0,0,0,1,1]]):\n    return grid\n\nassert f(g()) == 3\n", "emb": null, "idx_generation": 388, "target_skills": [1, 1, 1, 1, 0, 1, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Count the number of islands in a grid, where 1 represents land and 0 represents water.\"\"\"\n    def dfs(grid, row, col):\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] != 1:\n            return\n        grid[row][col] = -1\n        dfs(grid, row+1, col)\n        dfs(grid, row-1, col)\n        dfs(grid, row, col+1)\n        dfs(grid, row, col-1)\n    \n    count = 0\n    for row in range(len(grid)):\n        for col in range(len(grid[0])):\n            if grid[row][col] == 1:\n                count += 1\n                dfs(grid, row, col)\n    \n    return count", "solution_func": "def g(grid=[[1,1,0,0,0],\n            [1,1,0,0,0],\n            [0,0,1,0,0],\n            [0,0,0,1,1]]):\n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the shortest path from the top-left cell to the bottom-right cell in the grid.\"\"\"\n    queue = [(0, 0, 0)]  # (row, col, distance)\n    visited = set()\n    while queue:\n        row, col, distance = queue.pop(0)\n        if row == len(grid)-1 and col == len(grid[0])-1:\n            return distance\n        if (row, col) in visited:\n            continue\n        visited.add((row, col))\n        if row > 0 and grid[row-1][col] == 0:\n            queue.append((row-1, col, distance+1))\n        if row < len(grid)-1 and grid[row+1][col] == 0:\n            queue.append((row+1, col, distance+1))\n        if col > 0 and grid[row][col-1] == 0:\n            queue.append((row, col-1, distance+1))\n        if col < len(grid[0])-1 and grid[row][col+1] == 0:\n            queue.append((row, col+1, distance+1))\n    \n    return -1\n\ndef g(grid=[[0,0,0,0,0],\n            [1,1,1,1,0],\n            [0,0,0,0,0],\n            [0,1,1,1,1],\n            [0,0,0,0,0]]):\n    return grid\n\nassert f(g()) == 11\n", "emb": null, "idx_generation": 388, "target_skills": [0, 0, 0, 0, 1, 0, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the shortest path from the top-left cell to the bottom-right cell in the grid.\"\"\"\n    queue = [(0, 0, 0)]  # (row, col, distance)\n    visited = set()\n    while queue:\n        row, col, distance = queue.pop(0)\n        if row == len(grid)-1 and col == len(grid[0])-1:\n            return distance\n        if (row, col) in visited:\n            continue\n        visited.add((row, col))\n        if row > 0 and grid[row-1][col] == 0:\n            queue.append((row-1, col, distance+1))\n        if row < len(grid)-1 and grid[row+1][col] == 0:\n            queue.append((row+1, col, distance+1))\n        if col > 0 and grid[row][col-1] == 0:\n            queue.append((row, col-1, distance+1))\n        if col < len(grid[0])-1 and grid[row][col+1] == 0:\n            queue.append((row, col+1, distance+1))\n    \n    return -1", "solution_func": "def g(grid=[[0,0,0,0,0],\n            [1,1,1,1,0],\n            [0,0,0,0,0],\n            [0,1,1,1,1],\n            [0,0,0,0,0]]):\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if the grid can be filled with numbers from 1 to n, where each row and column must contain unique numbers.\"\"\"\n    n = len(grid)\n    for i in range(n):\n        row_set = set()\n        col_set = set()\n        for j in range(n):\n            if grid[i][j] in row_set or grid[j][i] in col_set:\n                return False\n            row_set.add(grid[i][j])\n            col_set.add(grid[j][i])\n    return True\n\ndef g(grid=[[1, 2, 3],\n            [2, 3, 1],\n            [3, 1, 2]]):\n    return grid\n\nassert f(g()) == True\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0], "idx_generation": 388, "target_skills": [1, 0, 1, 1, 0, 1, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if the grid can be filled with numbers from 1 to n, where each row and column must contain unique numbers.\"\"\"\n    n = len(grid)\n    for i in range(n):\n        row_set = set()\n        col_set = set()\n        for j in range(n):\n            if grid[i][j] in row_set or grid[j][i] in col_set:\n                return False\n            row_set.add(grid[i][j])\n            col_set.add(grid[j][i])\n    return True", "solution_func": "def g(grid=[[1, 2, 3],\n            [2, 3, 1],\n            [3, 1, 2]]):\n    return grid", "map_ix": [1, 1, 0, 0, 0, 1, 1, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int]) -> int:\n    \"\"\"\n    Given a list of numbers, find the maximum product of any three numbers in the list.\n\n    Example:\n    numbers = [1, 2, 3, 4, 5]\n\n    Output:\n    60 (since the maximum product is 4 * 5 * 3 = 60)\n    \"\"\"\n\n    numbers.sort()\n    return max(numbers[-1] * numbers[-2] * numbers[-3], numbers[0] * numbers[1] * numbers[-1])\n\ndef g(numbers: List[int] = [1, 2, 3, 4, 5]) -> List[int]:\n    \"\"\"\n    Generate a list of numbers.\n    \"\"\"\n    return numbers\n\nassert f(g()) == 60\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 388, "target_skills": [1, 1, 0, 1, 0, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int]) -> int:\n    \"\"\"\n    Given a list of numbers, find the maximum product of any three numbers in the list.\n\n    Example:\n    numbers = [1, 2, 3, 4, 5]\n\n    Output:\n    60 (since the maximum product is 4 * 5 * 3 = 60)\n    \"\"\"\n\n    numbers.sort()\n    return max(numbers[-1] * numbers[-2] * numbers[-3], numbers[0] * numbers[1] * numbers[-1])", "solution_func": "def g(numbers: List[int] = [1, 2, 3, 4, 5]) -> List[int]:\n    \"\"\"\n    Generate a list of numbers.\n    \"\"\"\n    return numbers", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of numbers and a target sum, find two numbers in the list that add up to the target sum.\n    Return the indices of the two numbers.\n\n    Example:\n    numbers = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1] (since numbers[0] + numbers[1] = 2 + 7 = 9)\n    \"\"\"\n\n    complement_map = {}\n    for i, num in enumerate(numbers):\n        complement = target - num\n        if complement in complement_map:\n            return [complement_map[complement], i]\n        complement_map[num] = i\n\n    return []\n\ndef g(numbers: List[int] = [2, 7, 11, 15], target: int = 9) -> List[int]:\n    \"\"\"\n    Generate a list of numbers and a target sum.\n    \"\"\"\n    return numbers, target\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 388, "target_skills": [0, 1, 0, 0, 1, 1, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of numbers and a target sum, find two numbers in the list that add up to the target sum.\n    Return the indices of the two numbers.\n\n    Example:\n    numbers = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1] (since numbers[0] + numbers[1] = 2 + 7 = 9)\n    \"\"\"\n\n    complement_map = {}\n    for i, num in enumerate(numbers):\n        complement = target - num\n        if complement in complement_map:\n            return [complement_map[complement], i]\n        complement_map[num] = i\n\n    return []", "solution_func": "def g(numbers: List[int] = [2, 7, 11, 15], target: int = 9) -> List[int]:\n    \"\"\"\n    Generate a list of numbers and a target sum.\n    \"\"\"\n    return numbers, target", "map_ix": [1, 1, 0, 1, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of numbers and an integer k, find the kth largest element in the list.\n\n    Example:\n    numbers = [3, 2, 1, 5, 6, 4]\n    k = 2\n\n    Output:\n    5 (since the 2nd largest element is 5)\n    \"\"\"\n\n    numbers.sort(reverse=True)\n    return numbers[k-1]\n\ndef g(numbers: List[int] = [3, 2, 1, 5, 6, 4], k: int = 2) -> List[int]:\n    \"\"\"\n    Generate a list of numbers and an integer k.\n    \"\"\"\n    return numbers, k\n\nassert f(*g()) == 5\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 388, "target_skills": [0, 0, 1, 0, 1, 1, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of numbers and an integer k, find the kth largest element in the list.\n\n    Example:\n    numbers = [3, 2, 1, 5, 6, 4]\n    k = 2\n\n    Output:\n    5 (since the 2nd largest element is 5)\n    \"\"\"\n\n    numbers.sort(reverse=True)\n    return numbers[k-1]", "solution_func": "def g(numbers: List[int] = [3, 2, 1, 5, 6, 4], k: int = 2) -> List[int]:\n    \"\"\"\n    Generate a list of numbers and an integer k.\n    \"\"\"\n    return numbers, k", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(numbers: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of numbers, sort the list in ascending order.\n\n    Example:\n    Input:\n    numbers = [4, 2, 6, 1, 3]\n\n    Output:\n    [1, 2, 3, 4, 6]\n    \"\"\"\n    numbers.sort()\n    return numbers\n\ndef g():\n    numbers = [4, 2, 6, 1, 3]\n    return numbers\n\nassert f(g()) == [1, 2, 3, 4, 6]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 388, "target_skills": [0, 0, 0, 1, 0, 1, 1, 0, 0, 0], "problem_func": "from typing import*\ndef f(numbers: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of numbers, sort the list in ascending order.\n\n    Example:\n    Input:\n    numbers = [4, 2, 6, 1, 3]\n\n    Output:\n    [1, 2, 3, 4, 6]\n    \"\"\"\n    numbers.sort()\n    return numbers", "solution_func": "def g():\n    numbers = [4, 2, 6, 1, 3]\n    return numbers", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers, check if the elements are in non-decreasing order.\n\n    Example:\n    arr = [1, 2, 2, 3, 4, 5]\n\n    Output:\n    True\n\n    Explanation:\n    The elements in the array are in non-decreasing order.\n\n    Hint: Use a loop to compare each element with its adjacent element.\n    \"\"\"\n\n    for i in range(len(arr) - 1):\n        if arr[i] > arr[i + 1]:\n            return False\n\n    return True\n\ndef g() -> List[int]:\n    return [1, 2, 2, 3, 4, 5]\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 389, "target_skills": [1, 1, 1, 1, 0, 0, 1, 1, 0, 0], "problem_func": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers, check if the elements are in non-decreasing order.\n\n    Example:\n    arr = [1, 2, 2, 3, 4, 5]\n\n    Output:\n    True\n\n    Explanation:\n    The elements in the array are in non-decreasing order.\n\n    Hint: Use a loop to compare each element with its adjacent element.\n    \"\"\"\n\n    for i in range(len(arr) - 1):\n        if arr[i] > arr[i + 1]:\n            return False\n\n    return True", "solution_func": "def g() -> List[int]:\n    return [1, 2, 2, 3, 4, 5]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the number of paths from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 1, 1],\n        [1, 2, 1],\n        [1, 1, 1]\n    ]\n\n    Output:\n    2\n\n    Explanation:\n    There are 2 possible paths: (0, 0) -> (0, 1) -> (0, 2) -> (1, 2) -> (2, 2) and (0, 0) -> (1, 0) -> (2, 0) -> (2, 1) -> (2, 2).\n\n    Hint: Use dynamic programming to store the number of paths for each cell.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 or j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[rows - 1][cols - 1]\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 1, 1],\n        [1, 2, 1],\n        [1, 1, 1]\n    ]\n\nassert f(*g()) == 2\n", "emb": null, "idx_generation": 389, "target_skills": [1, 0, 0, 0, 1, 0, 1, 1, 0, 0], "problem_func": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the number of paths from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 1, 1],\n        [1, 2, 1],\n        [1, 1, 1]\n    ]\n\n    Output:\n    2\n\n    Explanation:\n    There are 2 possible paths: (0, 0) -> (0, 1) -> (0, 2) -> (1, 2) -> (2, 2) and (0, 0) -> (1, 0) -> (2, 0) -> (2, 1) -> (2, 2).\n\n    Hint: Use dynamic programming to store the number of paths for each cell.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 or j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[rows - 1][cols - 1]", "solution_func": "def g() -> List[List[int]]:\n    return [\n        [1, 1, 1],\n        [1, 2, 1],\n        [1, 1, 1]\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nclass TreeNode:\n    def __init__(self, val: int):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef f(root: TreeNode, k: int) -> bool:\n    \"\"\"\n    Given the root of a binary search tree (BST) and an integer k, determine if there exists two elements in the BST such that their sum is equal to k.\n\n    Example:\n    root = TreeNode(5)\n    root.left = TreeNode(3)\n    root.right = TreeNode(6)\n    root.left.left = TreeNode(2)\n    root.left.right = TreeNode(4)\n    root.right.right = TreeNode(7)\n    k = 9\n\n    Output:\n    True\n\n    Explanation:\n    There exists two elements in the BST (2 and 7) that sum up to 9.\n\n    Hint: Use a set to store the difference between k and each node value in the tree.\n    \"\"\"\n\n    def dfs(node, target):\n        if not node:\n            return False\n        if target - node.val in seen:\n            return True\n        seen.add(node.val)\n        return dfs(node.left, target) or dfs(node.right, target)\n\n    seen = set()\n    return dfs(root, k)\n\ndef g() -> Tuple[TreeNode, int]:\n    root = TreeNode(5)\n    root.left = TreeNode(3)\n    root.right = TreeNode(6)\n    root.left.left = TreeNode(2)\n    root.left.right = TreeNode(4)\n    root.right.right = TreeNode(7)\n    k = 9\n    return root, k\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 389, "target_skills": [0, 1, 0, 1, 1, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nclass TreeNode:\n    def __init__(self, val: int):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef f(root: TreeNode, k: int) -> bool:\n    \"\"\"\n    Given the root of a binary search tree (BST) and an integer k, determine if there exists two elements in the BST such that their sum is equal to k.\n\n    Example:\n    root = TreeNode(5)\n    root.left = TreeNode(3)\n    root.right = TreeNode(6)\n    root.left.left = TreeNode(2)\n    root.left.right = TreeNode(4)\n    root.right.right = TreeNode(7)\n    k = 9\n\n    Output:\n    True\n\n    Explanation:\n    There exists two elements in the BST (2 and 7) that sum up to 9.\n\n    Hint: Use a set to store the difference between k and each node value in the tree.\n    \"\"\"\n\n    def dfs(node, target):\n        if not node:\n            return False\n        if target - node.val in seen:\n            return True\n        seen.add(node.val)\n        return dfs(node.left, target) or dfs(node.right, target)\n\n    seen = set()\n    return dfs(root, k)", "solution_func": "def g() -> Tuple[TreeNode, int]:\n    root = TreeNode(5)\n    root.left = TreeNode(3)\n    root.right = TreeNode(6)\n    root.left.left = TreeNode(2)\n    root.left.right = TreeNode(4)\n    root.right.right = TreeNode(7)\n    k = 9\n    return root, k", "map_ix": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in non-decreasing order using the bubble sort algorithm.\n    \"\"\"\n    n = len(nums)\n    \n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    \n    return nums\n\ndef g():\n    \"\"\"\n    Generate a list of integers for testing.\n    \"\"\"\n    return [9, 4, 7, 2, 1, 5]\n\nassert f(g()) == [1, 2, 4, 5, 7, 9]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 389, "target_skills": [0, 0, 1, 1, 1, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in non-decreasing order using the bubble sort algorithm.\n    \"\"\"\n    n = len(nums)\n    \n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    \n    return nums", "solution_func": "def g():\n    \"\"\"\n    Generate a list of integers for testing.\n    \"\"\"\n    return [9, 4, 7, 2, 1, 5]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size m x n, find the number of unique paths from the top-left corner to the bottom-right corner.\n    You can only move down or right at any point in time.\n\n    Example:\n    grid = [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1]\n    ]\n    The number of unique paths from the top-left corner to the bottom-right corner is 6.\n\n    Constraints:\n    - The grid will have at most 100 rows and 100 columns.\n    - Each cell in the grid will be either 0 or 1.\n    - The top-left and bottom-right cells will always be 1.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1\n    \n    for i in range(m):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n    \n    return dp[m-1][n-1]\n\ndef g():\n    \"\"\"\n    Generate a grid for testing.\n    \"\"\"\n    return [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1]\n    ]\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 389, "target_skills": [1, 0, 0, 1, 1, 0, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size m x n, find the number of unique paths from the top-left corner to the bottom-right corner.\n    You can only move down or right at any point in time.\n\n    Example:\n    grid = [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1]\n    ]\n    The number of unique paths from the top-left corner to the bottom-right corner is 6.\n\n    Constraints:\n    - The grid will have at most 100 rows and 100 columns.\n    - Each cell in the grid will be either 0 or 1.\n    - The top-left and bottom-right cells will always be 1.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1\n    \n    for i in range(m):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n    \n    return dp[m-1][n-1]", "solution_func": "def g():\n    \"\"\"\n    Generate a grid for testing.\n    \"\"\"\n    return [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1]\n    ]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    The maximum subarray sum is 6, which is obtained from the subarray [4, -1, 2, 1].\n\n    Constraints:\n    - The input list will always contain at least one integer.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef g():\n    \"\"\"\n    Generate a list of integers for testing.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 389, "target_skills": [1, 1, 1, 0, 0, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    The maximum subarray sum is 6, which is obtained from the subarray [4, -1, 2, 1].\n\n    Constraints:\n    - The input list will always contain at least one integer.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum", "solution_func": "def g():\n    \"\"\"\n    Generate a list of integers for testing.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "import math\nfrom typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a perfect square.\n\n    Return True if n is a perfect square, False otherwise.\n\n    Example:\n    n = 16\n\n    Output:\n    True\n\n    Explanation:\n    16 is a perfect square since 4^2 = 16.\n\n    Hint: Use the square root function and check if the result is an integer.\n    \"\"\"\n    import math\n    \n    root = math.sqrt(n)\n    return root.is_integer()\n\ndef g(n: int = 16) -> int:\n    \"\"\"\n    Generate an integer that is a perfect square.\n    \"\"\"\n    return n\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 389, "target_skills": [1, 1, 1, 1, 0, 0, 1, 0, 1, 0], "problem_func": "import math\nfrom typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a perfect square.\n\n    Return True if n is a perfect square, False otherwise.\n\n    Example:\n    n = 16\n\n    Output:\n    True\n\n    Explanation:\n    16 is a perfect square since 4^2 = 16.\n\n    Hint: Use the square root function and check if the result is an integer.\n    \"\"\"\n    import math\n    \n    root = math.sqrt(n)\n    return root.is_integer()", "solution_func": "def g(n: int = 16) -> int:\n    \"\"\"\n    Generate an integer that is a perfect square.\n    \"\"\"\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum path sum from the top left to the bottom right corner.\n\n    The minimum path sum is the sum of all the numbers along the path with the smallest sum.\n\n    Return the minimum path sum.\n\n    Example:\n    grid = [\n      [1,3,1],\n      [1,5,1],\n      [4,2,1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum path sum from the top left to the bottom right is 1 + 3 + 1 + 1 + 1 = 7.\n\n    Hint: Use dynamic programming to store the minimum path sum for each position in the grid.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n            \n    return dp[m-1][n-1]\n\ndef g(grid: List[List[int]] = [[1,3,1],[1,5,1],[4,2,1]]) -> List[List[int]]:\n    \"\"\"\n    Return the input grid.\n    \"\"\"\n    return grid\n\nassert f(*g()) == 7\n", "emb": null, "idx_generation": 389, "target_skills": [1, 0, 1, 1, 1, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum path sum from the top left to the bottom right corner.\n\n    The minimum path sum is the sum of all the numbers along the path with the smallest sum.\n\n    Return the minimum path sum.\n\n    Example:\n    grid = [\n      [1,3,1],\n      [1,5,1],\n      [4,2,1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum path sum from the top left to the bottom right is 1 + 3 + 1 + 1 + 1 = 7.\n\n    Hint: Use dynamic programming to store the minimum path sum for each position in the grid.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n            \n    return dp[m-1][n-1]", "solution_func": "def g(grid: List[List[int]] = [[1,3,1],[1,5,1],[4,2,1]]) -> List[List[int]]:\n    \"\"\"\n    Return the input grid.\n    \"\"\"\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the nth Fibonacci number.\n\n    Return the nth Fibonacci number.\n\n    Example:\n    n = 6\n\n    Output:\n    8\n\n    Explanation:\n    The 6th Fibonacci number is 8.\n\n    Hint: Use either recursion or dynamic programming to calculate the Fibonacci sequence.\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    a, b = 0, 1\n    \n    for _ in range(2, n+1):\n        a, b = b, a + b\n        \n    return b\n\ndef g(n: int = 6) -> int:\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    return n\n\nassert f(g()) == 8\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 389, "target_skills": [1, 1, 0, 1, 1, 1, 1, 0, 1, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the nth Fibonacci number.\n\n    Return the nth Fibonacci number.\n\n    Example:\n    n = 6\n\n    Output:\n    8\n\n    Explanation:\n    The 6th Fibonacci number is 8.\n\n    Hint: Use either recursion or dynamic programming to calculate the Fibonacci sequence.\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    a, b = 0, 1\n    \n    for _ in range(2, n+1):\n        a, b = b, a + b\n        \n    return b", "solution_func": "def g(n: int = 6) -> int:\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> int:\n    \"\"\"\n    Given the root of a binary tree, find the maximum path sum.\n\n    Args:\n    - root: The root of the binary tree.\n\n    Returns:\n    - The maximum path sum.\n    \"\"\"\n    max_sum = float('-inf')\n    \n    def max_path_sum(node):\n        nonlocal max_sum\n        if not node:\n            return 0\n        \n        left_sum = max(0, max_path_sum(node.left))\n        right_sum = max(0, max_path_sum(node.right))\n        \n        max_sum = max(max_sum, node.val + left_sum + right_sum)\n        \n        return node.val + max(left_sum, right_sum)\n    \n    max_path_sum(root)\n    \n    return max_sum\n\ndef g():\n    # Create a binary tree\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n\n    return root\n\nassert f(g()) == 11\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 389, "target_skills": [0, 1, 0, 1, 0, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> int:\n    \"\"\"\n    Given the root of a binary tree, find the maximum path sum.\n\n    Args:\n    - root: The root of the binary tree.\n\n    Returns:\n    - The maximum path sum.\n    \"\"\"\n    max_sum = float('-inf')\n    \n    def max_path_sum(node):\n        nonlocal max_sum\n        if not node:\n            return 0\n        \n        left_sum = max(0, max_path_sum(node.left))\n        right_sum = max(0, max_path_sum(node.right))\n        \n        max_sum = max(max_sum, node.val + left_sum + right_sum)\n        \n        return node.val + max(left_sum, right_sum)\n    \n    max_path_sum(root)\n    \n    return max_sum", "solution_func": "def g():\n    # Create a binary tree\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n\n    return root", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums):\n    \"\"\"\n    Given a list of integers, return the maximum element in the list.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The maximum element in the list.\n    \"\"\"\n    return max(nums)\n\ndef g():\n    nums = [5, 2, 9, 1, 7]\n    return nums\n\nassert f(g()) == 9\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 390, "target_skills": [1, 0, 1, 1, 1, 1, 1, 0, 1, 1], "problem_func": "from typing import*\ndef f(nums):\n    \"\"\"\n    Given a list of integers, return the maximum element in the list.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The maximum element in the list.\n    \"\"\"\n    return max(nums)", "solution_func": "def g():\n    nums = [5, 2, 9, 1, 7]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(grid):\n    \"\"\"\n    Given a 2D grid of characters, determine if it is a valid sudoku board.\n\n    Args:\n    - grid: A 2D list representing the sudoku board.\n\n    Returns:\n    - True if the board is valid, False otherwise.\n    \"\"\"\n    def is_valid_row(row):\n        count = [0] * 9\n        for num in row:\n            if num != \".\":\n                count[int(num) - 1] += 1\n                if count[int(num) - 1] > 1:\n                    return False\n        return True\n\n    def is_valid_col(col):\n        count = [0] * 9\n        for i in range(9):\n            num = grid[i][col]\n            if num != \".\":\n                count[int(num) - 1] += 1\n                if count[int(num) - 1] > 1:\n                    return False\n        return True\n\n    def is_valid_box(row, col):\n        count = [0] * 9\n        for i in range(row, row + 3):\n            for j in range(col, col + 3):\n                num = grid[i][j]\n                if num != \".\":\n                    count[int(num) - 1] += 1\n                    if count[int(num) - 1] > 1:\n                        return False\n        return True\n\n    for i in range(9):\n        if not is_valid_row(grid[i]):\n            return False\n        if not is_valid_col(i):\n            return False\n\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            if not is_valid_box(i, j):\n                return False\n\n    return True\n\ndef g():\n    grid = [\n        [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n        [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n        [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n        [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n        [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n        [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n        [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n        [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n        [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"],\n    ]\n    return grid\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 390, "target_skills": [1, 0, 0, 0, 0, 0, 1, 1, 0, 0], "problem_func": "from typing import*\ndef f(grid):\n    \"\"\"\n    Given a 2D grid of characters, determine if it is a valid sudoku board.\n\n    Args:\n    - grid: A 2D list representing the sudoku board.\n\n    Returns:\n    - True if the board is valid, False otherwise.\n    \"\"\"\n    def is_valid_row(row):\n        count = [0] * 9\n        for num in row:\n            if num != \".\":\n                count[int(num) - 1] += 1\n                if count[int(num) - 1] > 1:\n                    return False\n        return True\n\n    def is_valid_col(col):\n        count = [0] * 9\n        for i in range(9):\n            num = grid[i][col]\n            if num != \".\":\n                count[int(num) - 1] += 1\n                if count[int(num) - 1] > 1:\n                    return False\n        return True\n\n    def is_valid_box(row, col):\n        count = [0] * 9\n        for i in range(row, row + 3):\n            for j in range(col, col + 3):\n                num = grid[i][j]\n                if num != \".\":\n                    count[int(num) - 1] += 1\n                    if count[int(num) - 1] > 1:\n                        return False\n        return True\n\n    for i in range(9):\n        if not is_valid_row(grid[i]):\n            return False\n        if not is_valid_col(i):\n            return False\n\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            if not is_valid_box(i, j):\n                return False\n\n    return True", "solution_func": "def g():\n    grid = [\n        [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n        [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n        [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n        [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n        [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n        [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n        [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n        [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n        [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"],\n    ]\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(arr):\n    \"\"\"\n    Given an array of integers, find the longest subarray with equal number of 0s and 1s.\n\n    Args:\n    - arr: A list of integers.\n\n    Returns:\n    - The length of the longest subarray with equal number of 0s and 1s.\n    \"\"\"\n    count = 0\n    max_len = 0\n    count_dict = {0: -1}  # Initialize count_dict with count 0 at index -1\n    for i in range(len(arr)):\n        count += 1 if arr[i] == 1 else -1\n        if count in count_dict:\n            max_len = max(max_len, i - count_dict[count])\n        else:\n            count_dict[count] = i\n    return max_len\n\ndef g():\n    arr = [0, 1, 1, 0, 1, 0, 0]\n    return arr\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 390, "target_skills": [0, 1, 1, 0, 0, 0, 1, 1, 1, 0], "problem_func": "from typing import*\ndef f(arr):\n    \"\"\"\n    Given an array of integers, find the longest subarray with equal number of 0s and 1s.\n\n    Args:\n    - arr: A list of integers.\n\n    Returns:\n    - The length of the longest subarray with equal number of 0s and 1s.\n    \"\"\"\n    count = 0\n    max_len = 0\n    count_dict = {0: -1}  # Initialize count_dict with count 0 at index -1\n    for i in range(len(arr)):\n        count += 1 if arr[i] == 1 else -1\n        if count in count_dict:\n            max_len = max(max_len, i - count_dict[count])\n        else:\n            count_dict[count] = i\n    return max_len", "solution_func": "def g():\n    arr = [0, 1, 1, 0, 1, 0, 0]\n    return arr", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Check if there is a path from the top-left corner to the bottom-right corner of the grid, where each step can only go right or down.\n    Return True if there is a path, False otherwise.\n\n    Example:\n    grid = [\n        [1, 1, 1, 1],\n        [1, 0, 0, 1],\n        [1, 1, 1, 1]\n    ]\n    Output: True\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[False] * n for _ in range(m)]\n    dp[0][0] = True\n\n    for i in range(1, m):\n        if grid[i][0] == 1 and dp[i - 1][0]:\n            dp[i][0] = True\n\n    for j in range(1, n):\n        if grid[0][j] == 1 and dp[0][j - 1]:\n            dp[0][j] = True\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] == 1:\n                dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n\n    return dp[m - 1][n - 1]\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    return grid\n\nassert f(g([[1, 1, 1, 1], [1, 0, 0, 1], [1, 1, 1, 1]])) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 390, "target_skills": [0, 0, 1, 1, 1, 1, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Check if there is a path from the top-left corner to the bottom-right corner of the grid, where each step can only go right or down.\n    Return True if there is a path, False otherwise.\n\n    Example:\n    grid = [\n        [1, 1, 1, 1],\n        [1, 0, 0, 1],\n        [1, 1, 1, 1]\n    ]\n    Output: True\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[False] * n for _ in range(m)]\n    dp[0][0] = True\n\n    for i in range(1, m):\n        if grid[i][0] == 1 and dp[i - 1][0]:\n            dp[i][0] = True\n\n    for j in range(1, n):\n        if grid[0][j] == 1 and dp[0][j - 1]:\n            dp[0][j] = True\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] == 1:\n                dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n\n    return dp[m - 1][n - 1]", "solution_func": "def g(grid: List[List[int]]) -> List[List[int]]:\n    return grid", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]], k: int) -> List[List[int]]:\n    \"\"\"\n    Find the k closest points to the origin (0, 0) from a given list of points.\n    Return the list of k closest points.\n\n    Example:\n    points = [[1, 1], [2, 2], [3, 3], [4, 4], [5, 5]]\n    k = 3\n    Output: [[1, 1], [2, 2], [3, 3]]\n    \"\"\"\n    dist = lambda point: point[0] ** 2 + point[1] ** 2\n    return sorted(points, key=dist)[:k]\n\ndef g(points: List[List[int]], k: int) -> List[List[int]]:\n    return points, k\n\nassert f(g([[1, 1], [2, 2], [3, 3], [4, 4], [5, 5]], 3)) == [[1, 1], [2, 2], [3, 3]]\n", "emb": null, "idx_generation": 390, "target_skills": [0, 1, 0, 1, 0, 1, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]], k: int) -> List[List[int]]:\n    \"\"\"\n    Find the k closest points to the origin (0, 0) from a given list of points.\n    Return the list of k closest points.\n\n    Example:\n    points = [[1, 1], [2, 2], [3, 3], [4, 4], [5, 5]]\n    k = 3\n    Output: [[1, 1], [2, 2], [3, 3]]\n    \"\"\"\n    dist = lambda point: point[0] ** 2 + point[1] ** 2\n    return sorted(points, key=dist)[:k]", "solution_func": "def g(points: List[List[int]], k: int) -> List[List[int]]:\n    return points, k", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(board: List[List[str]]) -> bool:\n    \"\"\"\n    Check if a given Sudoku board is valid.\n    Return True if the board is valid, False otherwise.\n\n    Example:\n    board = [\n        [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n        [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n        [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n        [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n        [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n        [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n        [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n        [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n        [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"]\n    ]\n    Output: True\n    \"\"\"\n    rows = [set() for _ in range(9)]\n    cols = [set() for _ in range(9)]\n    boxes = [set() for _ in range(9)]\n\n    for i in range(9):\n        for j in range(9):\n            if board[i][j] != '.':\n                num = int(board[i][j])\n                box_index = (i // 3) * 3 + j // 3\n                if num in rows[i] or num in cols[j] or num in boxes[box_index]:\n                    return False\n                rows[i].add(num)\n                cols[j].add(num)\n                boxes[box_index].add(num)\n\n    return True\n\ndef g(board: List[List[str]]) -> List[List[str]]:\n    return board\n\nassert f(g([\n    [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n    [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n    [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n    [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n    [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n    [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n    [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n    [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n    [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"]\n])) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], "idx_generation": 390, "target_skills": [0, 1, 1, 0, 1, 1, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(board: List[List[str]]) -> bool:\n    \"\"\"\n    Check if a given Sudoku board is valid.\n    Return True if the board is valid, False otherwise.\n\n    Example:\n    board = [\n        [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n        [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n        [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n        [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n        [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n        [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n        [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n        [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n        [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"]\n    ]\n    Output: True\n    \"\"\"\n    rows = [set() for _ in range(9)]\n    cols = [set() for _ in range(9)]\n    boxes = [set() for _ in range(9)]\n\n    for i in range(9):\n        for j in range(9):\n            if board[i][j] != '.':\n                num = int(board[i][j])\n                box_index = (i // 3) * 3 + j // 3\n                if num in rows[i] or num in cols[j] or num in boxes[box_index]:\n                    return False\n                rows[i].add(num)\n                cols[j].add(num)\n                boxes[box_index].add(num)\n\n    return True", "solution_func": "def g(board: List[List[str]]) -> List[List[str]]:\n    return board", "map_ix": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], target: str) -> int:\n    \"\"\"\n    Given a list of words and a target word, find the number of unique paths to reach the target word from the first word. \n    You can only move to the next word if it is a valid transformation of the current word by changing exactly one letter.\n\n    Args:\n    - words: A list of words.\n    - target: The target word.\n\n    Returns:\n    - The number of unique paths to reach the target word from the first word.\n    \"\"\"\n    def dfs(word: str, target: str, visited: set) -> int:\n        if word == target:\n            return 1\n\n        count = 0\n        visited.add(word)\n\n        for i in range(len(word)):\n            for j in range(ord('a'), ord('z')+1):\n                new_word = word[:i] + chr(j) + word[i+1:]\n\n                if new_word in words and new_word not in visited:\n                    count += dfs(new_word, target, visited)\n\n        visited.remove(word)\n\n        return count\n\n    return dfs(words[0], target, set())\n\ndef g() -> List[str]:\n    return [\"cat\", \"cot\", \"dot\", \"dog\"]\n\nassert f(g(), \"dog\") == 3\n", "emb": null, "idx_generation": 390, "target_skills": [1, 0, 1, 0, 1, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], target: str) -> int:\n    \"\"\"\n    Given a list of words and a target word, find the number of unique paths to reach the target word from the first word. \n    You can only move to the next word if it is a valid transformation of the current word by changing exactly one letter.\n\n    Args:\n    - words: A list of words.\n    - target: The target word.\n\n    Returns:\n    - The number of unique paths to reach the target word from the first word.\n    \"\"\"\n    def dfs(word: str, target: str, visited: set) -> int:\n        if word == target:\n            return 1\n\n        count = 0\n        visited.add(word)\n\n        for i in range(len(word)):\n            for j in range(ord('a'), ord('z')+1):\n                new_word = word[:i] + chr(j) + word[i+1:]\n\n                if new_word in words and new_word not in visited:\n                    count += dfs(new_word, target, visited)\n\n        visited.remove(word)\n\n        return count\n\n    return dfs(words[0], target, set())", "solution_func": "def g() -> List[str]:\n    return [\"cat\", \"cot\", \"dot\", \"dog\"]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers where each cell represents the cost to move to that cell, find the minimum cost to reach the bottom-right cell from the top-left cell. \n    You can only move down or right.\n\n    Args:\n    - grid: A 2D grid of integers.\n\n    Returns:\n    - The minimum cost to reach the bottom-right cell from the top-left cell.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[float('inf')] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g(grid=[[1,3,1],[1,5,1],[4,2,1]]):\n    return grid\n\nassert f(g()) == 7\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 390, "target_skills": [1, 1, 0, 0, 1, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers where each cell represents the cost to move to that cell, find the minimum cost to reach the bottom-right cell from the top-left cell. \n    You can only move down or right.\n\n    Args:\n    - grid: A 2D grid of integers.\n\n    Returns:\n    - The minimum cost to reach the bottom-right cell from the top-left cell.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[float('inf')] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]", "solution_func": "def g(grid=[[1,3,1],[1,5,1],[4,2,1]]):\n    return grid", "map_ix": [0, 0, 0, 1, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, return all subsets of the list.\n\n    Example:\n    nums = [1, 2, 3]\n\n    Output:\n    [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n    \"\"\"\n\n    def backtrack(start: int, subset: List[int], subsets: List[List[int]]) -> None:\n        subsets.append(subset[:])\n\n        for i in range(start, len(nums)):\n            subset.append(nums[i])\n            backtrack(i+1, subset, subsets)\n            subset.pop()\n\n    subsets = []\n    backtrack(0, [], subsets)\n\n    return subsets\n\ndef g() -> List[int]:\n    return [1, 2, 3]\n\nassert f(g()) == [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 390, "target_skills": [1, 1, 0, 1, 1, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, return all subsets of the list.\n\n    Example:\n    nums = [1, 2, 3]\n\n    Output:\n    [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n    \"\"\"\n\n    def backtrack(start: int, subset: List[int], subsets: List[List[int]]) -> None:\n        subsets.append(subset[:])\n\n        for i in range(start, len(nums)):\n            subset.append(nums[i])\n            backtrack(i+1, subset, subsets)\n            subset.pop()\n\n    subsets = []\n    backtrack(0, [], subsets)\n\n    return subsets", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3]", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters representing a maze, find the minimum number of steps required to reach the goal.\n    The maze is represented by a 2D grid, where 'S' represents the starting position, 'G' represents the goal position,\n    '#' represents a wall that cannot be passed through, and '.' represents an empty space that can be traversed.\n\n    Sample Input:\n    grid = [\n        ['#', '#', '#', '#', '#', '#', '#', '#', '#'],\n        ['#', 'S', '#', '.', '.', '.', '#', '.', '#'],\n        ['#', '.', '#', '.', '#', '.', '#', '.', '#'],\n        ['#', '.', '#', '.', '#', '.', '#', '.', '#'],\n        ['#', '.', '.', '.', '.', '.', '.', '.', '#'],\n        ['#', '#', '#', '#', '#', '#', '#', 'G', '#']\n    ]\n\n    Sample Output:\n    8\n    \"\"\"\n    start = None\n    goal = None\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'G':\n                goal = (i, j)\n                \n    rows = len(grid)\n    cols = len(grid[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    def is_valid(x, y):\n        return 0 <= x < rows and 0 <= y < cols and grid[x][y] != '#'\n    \n    def dfs(x, y, steps):\n        if (x, y) == goal:\n            return steps\n        grid[x][y] = '#'  # mark current position as visited\n        min_steps = float('inf')\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if is_valid(nx, ny):\n                min_steps = min(min_steps, dfs(nx, ny, steps + 1))\n        grid[x][y] = '.'  # unmark current position\n        return min_steps\n    \n    return dfs(start[0], start[1], 0)\n\n\ndef g() -> List[List[str]]:\n    \"\"\"\n    Generate a random maze grid.\n    \"\"\"\n    return [\n        ['#', '#', '#', '#', '#', '#', '#', '#', '#'],\n        ['#', 'S', '#', '.', '.', '.', '#', '.', '#'],\n        ['#', '.', '#', '.', '#', '.', '#', '.', '#'],\n        ['#', '.', '#', '.', '#', '.', '#', '.', '#'],\n        ['#', '.', '.', '.', '.', '.', '.', '.', '#'],\n        ['#', '#', '#', '#', '#', '#', '#', 'G', '#']\n    ]\n\n\nassert f(g()) == 8\n\n", "emb": null, "idx_generation": 390, "target_skills": [0, 1, 0, 1, 1, 0, 0, 1, 0, 0], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters representing a maze, find the minimum number of steps required to reach the goal.\n    The maze is represented by a 2D grid, where 'S' represents the starting position, 'G' represents the goal position,\n    '#' represents a wall that cannot be passed through, and '.' represents an empty space that can be traversed.\n\n    Sample Input:\n    grid = [\n        ['#', '#', '#', '#', '#', '#', '#', '#', '#'],\n        ['#', 'S', '#', '.', '.', '.', '#', '.', '#'],\n        ['#', '.', '#', '.', '#', '.', '#', '.', '#'],\n        ['#', '.', '#', '.', '#', '.', '#', '.', '#'],\n        ['#', '.', '.', '.', '.', '.', '.', '.', '#'],\n        ['#', '#', '#', '#', '#', '#', '#', 'G', '#']\n    ]\n\n    Sample Output:\n    8\n    \"\"\"\n    start = None\n    goal = None\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'G':\n                goal = (i, j)\n                \n    rows = len(grid)\n    cols = len(grid[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    def is_valid(x, y):\n        return 0 <= x < rows and 0 <= y < cols and grid[x][y] != '#'\n    \n    def dfs(x, y, steps):\n        if (x, y) == goal:\n            return steps\n        grid[x][y] = '#'  # mark current position as visited\n        min_steps = float('inf')\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if is_valid(nx, ny):\n                min_steps = min(min_steps, dfs(nx, ny, steps + 1))\n        grid[x][y] = '.'  # unmark current position\n        return min_steps\n    \n    return dfs(start[0], start[1], 0)", "solution_func": "def g() -> List[List[str]]:\n    \"\"\"\n    Generate a random maze grid.\n    \"\"\"\n    return [\n        ['#', '#', '#', '#', '#', '#', '#', '#', '#'],\n        ['#', 'S', '#', '.', '.', '.', '#', '.', '#'],\n        ['#', '.', '#', '.', '#', '.', '#', '.', '#'],\n        ['#', '.', '#', '.', '#', '.', '#', '.', '#'],\n        ['#', '.', '.', '.', '.', '.', '.', '.', '#'],\n        ['#', '#', '#', '#', '#', '#', '#', 'G', '#']\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if n is a perfect square and a power of 2.\n    Return True if n is a perfect square and a power of 2, False otherwise.\n    \"\"\"\n\n    def is_perfect_square(num: int) -> bool:\n        if num < 0:\n            return False\n        sqrt = int(num ** 0.5)\n        return sqrt * sqrt == num\n\n    def is_power_of_two(num: int) -> bool:\n        if num < 0:\n            return False\n        return num & (num - 1) == 0\n\n    return is_perfect_square(n) and is_power_of_two(n)\n\ndef g() -> int:\n    return 16\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 391, "target_skills": [0, 0, 0, 1, 1, 1, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if n is a perfect square and a power of 2.\n    Return True if n is a perfect square and a power of 2, False otherwise.\n    \"\"\"\n\n    def is_perfect_square(num: int) -> bool:\n        if num < 0:\n            return False\n        sqrt = int(num ** 0.5)\n        return sqrt * sqrt == num\n\n    def is_power_of_two(num: int) -> bool:\n        if num < 0:\n            return False\n        return num & (num - 1) == 0\n\n    return is_perfect_square(n) and is_power_of_two(n)", "solution_func": "def g() -> int:\n    return 16", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Reverse the words in a given string.\n    Return the reversed string.\n\n    Example:\n    Input: \"Hello World\"\n    Output: \"World Hello\"\n    \"\"\"\n\n    words = s.split()\n    reversed_words = ' '.join(words[::-1])\n    return reversed_words\n\ndef g() -> str:\n    return \"Hello World\"\n\nassert f(g()) == \"World Hello\"\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 391, "target_skills": [0, 1, 1, 1, 0, 0, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Reverse the words in a given string.\n    Return the reversed string.\n\n    Example:\n    Input: \"Hello World\"\n    Output: \"World Hello\"\n    \"\"\"\n\n    words = s.split()\n    reversed_words = ' '.join(words[::-1])\n    return reversed_words", "solution_func": "def g() -> str:\n    return \"Hello World\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers, find the index of the target number using binary search.\n    If the target number is not found, return -1.\n\n    Example:\n    Input:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 6\n\n    Output: 5\n\n    Explanation: The target number 6 is found at index 5 in the list.\n    \"\"\"\n\n    def binary_search(nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return -1\n\n    return binary_search(nums, target)\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 6\n    return nums, target\n\nassert f(*g()) == 5\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 391, "target_skills": [1, 0, 1, 1, 1, 0, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers, find the index of the target number using binary search.\n    If the target number is not found, return -1.\n\n    Example:\n    Input:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 6\n\n    Output: 5\n\n    Explanation: The target number 6 is found at index 5 in the list.\n    \"\"\"\n\n    def binary_search(nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return -1\n\n    return binary_search(nums, target)", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 6\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums, determine if there exists a subsequence of length 3 that forms an arithmetic progression.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n\n    Output:\n    True\n\n    Explanation:\n    The subsequence [1, 3, 5] forms an arithmetic progression with a common difference of 2.\n    \"\"\"\n\n    def is_arithmetic(nums):\n        if len(nums) < 3:\n            return False\n\n        diff = nums[1] - nums[0]\n\n        for i in range(2, len(nums)):\n            if nums[i] - nums[i-1] != diff:\n                return False\n\n        return True\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                if is_arithmetic([nums[i], nums[j], nums[k]]):\n                    return True\n\n    return False\n\ndef g(nums=[1, 3, 5, 7, 9]):\n    return nums\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 391, "target_skills": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums, determine if there exists a subsequence of length 3 that forms an arithmetic progression.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n\n    Output:\n    True\n\n    Explanation:\n    The subsequence [1, 3, 5] forms an arithmetic progression with a common difference of 2.\n    \"\"\"\n\n    def is_arithmetic(nums):\n        if len(nums) < 3:\n            return False\n\n        diff = nums[1] - nums[0]\n\n        for i in range(2, len(nums)):\n            if nums[i] - nums[i-1] != diff:\n                return False\n\n        return True\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                if is_arithmetic([nums[i], nums[j], nums[k]]):\n                    return True\n\n    return False", "solution_func": "def g(nums=[1, 3, 5, 7, 9]):\n    return nums", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if it is a magic square.\n\n    A magic square is a square matrix of size n x n, where each row, column, and diagonal have the same sum.\n\n    Example:\n    matrix = [\n        [2, 7, 6],\n        [9, 5, 1],\n        [4, 3, 8]\n    ]\n\n    Output:\n    True\n\n    Explanation:\n    The matrix forms a magic square, where each row, column, and diagonal sums up to 15.\n    \"\"\"\n\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = sum(matrix[i][col] for i in range(n))\n        if col_sum != target_sum:\n            return False\n\n    # Check diagonals\n    diagonal_sum = sum(matrix[i][i] for i in range(n))\n    anti_diagonal_sum = sum(matrix[i][n-i-1] for i in range(n))\n    if diagonal_sum != target_sum or anti_diagonal_sum != target_sum:\n        return False\n\n    return True\n\ndef g(matrix=[[2, 7, 6], [9, 5, 1], [4, 3, 8]]):\n    return matrix\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 391, "target_skills": [0, 0, 0, 0, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if it is a magic square.\n\n    A magic square is a square matrix of size n x n, where each row, column, and diagonal have the same sum.\n\n    Example:\n    matrix = [\n        [2, 7, 6],\n        [9, 5, 1],\n        [4, 3, 8]\n    ]\n\n    Output:\n    True\n\n    Explanation:\n    The matrix forms a magic square, where each row, column, and diagonal sums up to 15.\n    \"\"\"\n\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = sum(matrix[i][col] for i in range(n))\n        if col_sum != target_sum:\n            return False\n\n    # Check diagonals\n    diagonal_sum = sum(matrix[i][i] for i in range(n))\n    anti_diagonal_sum = sum(matrix[i][n-i-1] for i in range(n))\n    if diagonal_sum != target_sum or anti_diagonal_sum != target_sum:\n        return False\n\n    return True", "solution_func": "def g(matrix=[[2, 7, 6], [9, 5, 1], [4, 3, 8]]):\n    return matrix", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target integer, determine if there exists a subset of nums that sums up to the target.\n\n    Example:\n    nums = [2, 4, 6, 8]\n    target = 10\n\n    Output:\n    True\n\n    Explanation:\n    The subset [2, 8] sums up to the target value of 10.\n    \"\"\"\n\n    def subset_sum(nums, target, index, curr_sum):\n        if curr_sum == target:\n            return True\n\n        if curr_sum > target or index >= len(nums):\n            return False\n\n        include = subset_sum(nums, target, index+1, curr_sum + nums[index])\n        exclude = subset_sum(nums, target, index+1, curr_sum)\n\n        return include or exclude\n\n    return subset_sum(nums, target, 0, 0)\n\ndef g(nums=[2, 4, 6, 8], target=10):\n    return nums, target\n\nassert f(*g()) == True\n\n", "emb": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 391, "target_skills": [1, 0, 1, 0, 1, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target integer, determine if there exists a subset of nums that sums up to the target.\n\n    Example:\n    nums = [2, 4, 6, 8]\n    target = 10\n\n    Output:\n    True\n\n    Explanation:\n    The subset [2, 8] sums up to the target value of 10.\n    \"\"\"\n\n    def subset_sum(nums, target, index, curr_sum):\n        if curr_sum == target:\n            return True\n\n        if curr_sum > target or index >= len(nums):\n            return False\n\n        include = subset_sum(nums, target, index+1, curr_sum + nums[index])\n        exclude = subset_sum(nums, target, index+1, curr_sum)\n\n        return include or exclude\n\n    return subset_sum(nums, target, 0, 0)", "solution_func": "def g(nums=[2, 4, 6, 8], target=10):\n    return nums, target", "map_ix": [1, 1, 1, 1, 1, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two numbers in the list.\n    \"\"\"\n    nums.sort()\n    return max(nums[-1] * nums[-2], nums[0] * nums[1])\n\ndef g():\n    return [5, 2, 3, 8, 9, 1]\n\nassert f(g()) == 72\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 391, "target_skills": [1, 1, 1, 0, 0, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two numbers in the list.\n    \"\"\"\n    nums.sort()\n    return max(nums[-1] * nums[-2], nums[0] * nums[1])", "solution_func": "def g():\n    return [5, 2, 3, 8, 9, 1]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of itself and all previous elements in the list.\n    \"\"\"\n    prefix_sum = [0] * len(nums)\n    prefix_sum[0] = nums[0]\n    for i in range(1, len(nums)):\n        prefix_sum[i] = prefix_sum[i-1] + nums[i]\n    return prefix_sum\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [1, 3, 6, 10, 15]\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 391, "target_skills": [1, 0, 1, 0, 0, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of itself and all previous elements in the list.\n    \"\"\"\n    prefix_sum = [0] * len(nums)\n    prefix_sum[0] = nums[0]\n    for i in range(1, len(nums)):\n        prefix_sum[i] = prefix_sum[i-1] + nums[i]\n    return prefix_sum", "solution_func": "def g():\n    return [1, 2, 3, 4, 5]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the number of combinations of elements in the list that add up to the target.\n    \"\"\"\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for num in nums:\n        for i in range(num, target + 1):\n            dp[i] += dp[i - num]\n\n    return dp[target]\n\ndef g():\n    return [1, 2, 3], 4\n\nassert f(*g()) == 4\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 391, "target_skills": [0, 0, 1, 0, 1, 0, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the number of combinations of elements in the list that add up to the target.\n    \"\"\"\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for num in nums:\n        for i in range(num, target + 1):\n            dp[i] += dp[i - num]\n\n    return dp[target]", "solution_func": "def g():\n    return [1, 2, 3], 4", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\nclass Node:\n    def __init__(self, val: int):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef f(root: Node) -> int:\n    \"\"\"\n    Given the root of a binary tree, find the maximum depth.\n\n    The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n    Example:\n    Input: root = [3,9,20,null,null,15,7]\n    Output: 3\n\n    Explanation: The maximum depth is 3, since the longest path from root node to any leaf node is 3.\n    \"\"\"\n    if not root:\n        return 0\n    return 1 + max(f(root.left), f(root.right))\n\ndef g(root: Node) -> Node:\n    node1 = Node(9)\n    node2 = Node(20)\n    node3 = Node(15)\n    node4 = Node(7)\n    root.left = node1\n    root.right = node2\n    node2.left = node3\n    node2.right = node4\n    return root\n\nroot = Node(3)\nassert f(g(root)) == 3\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 391, "target_skills": [0, 1, 0, 0, 1, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\nclass Node:\n    def __init__(self, val: int):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef f(root: Node) -> int:\n    \"\"\"\n    Given the root of a binary tree, find the maximum depth.\n\n    The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n    Example:\n    Input: root = [3,9,20,null,null,15,7]\n    Output: 3\n\n    Explanation: The maximum depth is 3, since the longest path from root node to any leaf node is 3.\n    \"\"\"\n    if not root:\n        return 0\n    return 1 + max(f(root.left), f(root.right))", "solution_func": "def g(root: Node) -> Node:\n    node1 = Node(9)\n    node2 = Node(20)\n    node3 = Node(15)\n    node4 = Node(7)\n    root.left = node1\n    root.right = node2\n    node2.left = node3\n    node2.right = node4\n    return root\n\nroot = Node(3)", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "import random\nfrom typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers, check if the array is sorted in non-decreasing order.\n\n    Return True if the array is sorted, False otherwise.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n\n    Output:\n    True\n\n    Explanation:\n    The array is sorted in non-decreasing order.\n    \"\"\"\n\n    def is_sorted(arr):\n        n = len(arr)\n        for i in range(1, n):\n            if arr[i] < arr[i-1]:\n                return False\n        return True\n\n    return is_sorted(arr)\n\ndef g(arr: List[int]):\n    \"\"\"\n    Generate an array of integers with random values.\n    \"\"\"\n    return arr\n\nassert f(g([1, 2, 3, 4, 5])) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 392, "target_skills": [1, 1, 0, 1, 0, 1, 0, 0, 0, 1], "problem_func": "import random\nfrom typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers, check if the array is sorted in non-decreasing order.\n\n    Return True if the array is sorted, False otherwise.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n\n    Output:\n    True\n\n    Explanation:\n    The array is sorted in non-decreasing order.\n    \"\"\"\n\n    def is_sorted(arr):\n        n = len(arr)\n        for i in range(1, n):\n            if arr[i] < arr[i-1]:\n                return False\n        return True\n\n    return is_sorted(arr)", "solution_func": "def g(arr: List[int]):\n    \"\"\"\n    Generate an array of integers with random values.\n    \"\"\"\n    return arr", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> str:\n    \"\"\"\n    Given an integer n, calculate the factorial of n and return it as a string.\n\n    Example:\n    n = 5\n\n    Output:\n    \"120\"\n\n    Explanation:\n    The factorial of 5 is 120.\n    \"\"\"\n\n    def factorial(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n-1)\n\n    return str(factorial(n))\n\ndef g(n: int):\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    return n\n\nassert f(g(5)) == \"120\"\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 392, "target_skills": [0, 0, 1, 1, 0, 1, 1, 0, 1, 0], "problem_func": "from typing import*\ndef f(n: int) -> str:\n    \"\"\"\n    Given an integer n, calculate the factorial of n and return it as a string.\n\n    Example:\n    n = 5\n\n    Output:\n    \"120\"\n\n    Explanation:\n    The factorial of 5 is 120.\n    \"\"\"\n\n    def factorial(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n-1)\n\n    return str(factorial(n))", "solution_func": "def g(n: int):\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the number of ways to choose k elements from a set of n elements.\n\n    Return the number of combinations.\n\n    Example:\n    n = 5\n    k = 3\n\n    Output:\n    10\n\n    Explanation:\n    There are 10 ways to choose 3 elements from a set of 5 elements.\n    \"\"\"\n\n    def combinations(n, k):\n        if k == 0 or n == k:\n            return 1\n        else:\n            return combinations(n-1, k-1) + combinations(n-1, k)\n\n    return combinations(n, k)\n\ndef g(n: int, k: int):\n    \"\"\"\n    Generate two integers n and k.\n    \"\"\"\n    return n, k\n\nassert f(*g(5, 3)) == 10\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 392, "target_skills": [1, 0, 0, 1, 1, 1, 0, 1, 1, 0], "problem_func": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the number of ways to choose k elements from a set of n elements.\n\n    Return the number of combinations.\n\n    Example:\n    n = 5\n    k = 3\n\n    Output:\n    10\n\n    Explanation:\n    There are 10 ways to choose 3 elements from a set of 5 elements.\n    \"\"\"\n\n    def combinations(n, k):\n        if k == 0 or n == k:\n            return 1\n        else:\n            return combinations(n-1, k-1) + combinations(n-1, k)\n\n    return combinations(n, k)", "solution_func": "def g(n: int, k: int):\n    \"\"\"\n    Generate two integers n and k.\n    \"\"\"\n    return n, k", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, path: List[int]) -> bool:\n    \"\"\"\n    Check if there is a path from the start node to the end node in the given graph.\n    \n    Arguments:\n    - graph: A 2D list representing the graph, where graph[i][j] = 1 if there is an edge between node i and node j, and 0 otherwise.\n    - start: The starting node.\n    - end: The end node.\n    - path: A list to keep track of the current path.\n    \n    Returns:\n    - True if there is a path from start to end, False otherwise.\n    \"\"\"\n\n    # Base case: If the start node is the end node, return True\n    if start == end:\n        return True\n    \n    # Mark the current node as visited by adding it to the path\n    path.append(start)\n    \n    # Check all the neighbors of the current node\n    for neighbor in range(len(graph[start])):\n        # If the neighbor is not visited and there is a connection between the current node and the neighbor,\n        # recursively call the function with the neighbor as the new start node\n        if neighbor not in path and graph[start][neighbor] == 1:\n            if f(graph, neighbor, end, path):\n                return True\n    \n    # If there is no path from the start node to the end node, remove the current node from the path\n    path.pop()\n    \n    return False\n\ndef g(graph = [[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]], start = 0, end = 3, path = []):\n    return f(graph, start, end, path)\n\nassert f(g())\n", "emb": null, "idx_generation": 392, "target_skills": [0, 1, 1, 1, 0, 0, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, path: List[int]) -> bool:\n    \"\"\"\n    Check if there is a path from the start node to the end node in the given graph.\n    \n    Arguments:\n    - graph: A 2D list representing the graph, where graph[i][j] = 1 if there is an edge between node i and node j, and 0 otherwise.\n    - start: The starting node.\n    - end: The end node.\n    - path: A list to keep track of the current path.\n    \n    Returns:\n    - True if there is a path from start to end, False otherwise.\n    \"\"\"\n\n    # Base case: If the start node is the end node, return True\n    if start == end:\n        return True\n    \n    # Mark the current node as visited by adding it to the path\n    path.append(start)\n    \n    # Check all the neighbors of the current node\n    for neighbor in range(len(graph[start])):\n        # If the neighbor is not visited and there is a connection between the current node and the neighbor,\n        # recursively call the function with the neighbor as the new start node\n        if neighbor not in path and graph[start][neighbor] == 1:\n            if f(graph, neighbor, end, path):\n                return True\n    \n    # If there is no path from the start node to the end node, remove the current node from the path\n    path.pop()\n    \n    return False", "solution_func": "def g(graph = [[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]], start = 0, end = 3, path = []):\n    return f(graph, start, end, path)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Check if the target number exists in the given matrix.\n    \n    Arguments:\n    - matrix: A 2D list of integers.\n    - target: The number to search for in the matrix.\n    \n    Returns:\n    - True if the target number exists in the matrix, False otherwise.\n    \"\"\"\n    \n    if not matrix or not matrix[0]:\n        return False\n    \n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    # Start searching from the top-right corner of the matrix\n    row = 0\n    col = cols - 1\n    \n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] > target:\n            col -= 1\n        else:\n            row += 1\n    \n    return False\n\ndef g(matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], target = 5):\n    return f(matrix, target)\n\nassert f(g())\n", "emb": null, "idx_generation": 392, "target_skills": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Check if the target number exists in the given matrix.\n    \n    Arguments:\n    - matrix: A 2D list of integers.\n    - target: The number to search for in the matrix.\n    \n    Returns:\n    - True if the target number exists in the matrix, False otherwise.\n    \"\"\"\n    \n    if not matrix or not matrix[0]:\n        return False\n    \n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    # Start searching from the top-right corner of the matrix\n    row = 0\n    col = cols - 1\n    \n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] > target:\n            col -= 1\n        else:\n            row += 1\n    \n    return False", "solution_func": "def g(matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], target = 5):\n    return f(matrix, target)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Find the minimum number of steps required to reach the target position from the starting position in the grid.\n    \n    Arguments:\n    - grid: A 2D list representing the grid, where each element is either 'O' (open) or 'X' (blocked).\n    \n    Returns:\n    - The minimum number of steps required to reach the target position from the starting position.\n    \"\"\"\n    \n    if not grid or not grid[0]:\n        return -1\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    \n    start = None\n    target = None\n    \n    # Find the starting position and the target position\n    for row in range(rows):\n        for col in range(cols):\n            if grid[row][col] == 'S':\n                start = (row, col)\n            elif grid[row][col] == 'T':\n                target = (row, col)\n    \n    if not start or not target:\n        return -1\n    \n    queue = [(start, 0)]\n    visited = set()\n    \n    while queue:\n        current, steps = queue.pop(0)\n        \n        if current == target:\n            return steps\n        \n        row, col = current\n        \n        # Check all possible directions: up, down, left, right\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        \n        for dr, dc in directions:\n            new_row = row + dr\n            new_col = col + dc\n            \n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] != 'X' and (new_row, new_col) not in visited:\n                visited.add((new_row, new_col))\n                queue.append(((new_row, new_col), steps + 1))\n    \n    return -1\n\ndef g(grid = [['S', 'O', 'O'], ['O', 'O', 'O'], ['O', 'O', 'T']]):\n    return f(grid)\n\nassert f(g()) == 2\n", "emb": null, "idx_generation": 392, "target_skills": [0, 0, 1, 0, 1, 1, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Find the minimum number of steps required to reach the target position from the starting position in the grid.\n    \n    Arguments:\n    - grid: A 2D list representing the grid, where each element is either 'O' (open) or 'X' (blocked).\n    \n    Returns:\n    - The minimum number of steps required to reach the target position from the starting position.\n    \"\"\"\n    \n    if not grid or not grid[0]:\n        return -1\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    \n    start = None\n    target = None\n    \n    # Find the starting position and the target position\n    for row in range(rows):\n        for col in range(cols):\n            if grid[row][col] == 'S':\n                start = (row, col)\n            elif grid[row][col] == 'T':\n                target = (row, col)\n    \n    if not start or not target:\n        return -1\n    \n    queue = [(start, 0)]\n    visited = set()\n    \n    while queue:\n        current, steps = queue.pop(0)\n        \n        if current == target:\n            return steps\n        \n        row, col = current\n        \n        # Check all possible directions: up, down, left, right\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        \n        for dr, dc in directions:\n            new_row = row + dr\n            new_col = col + dc\n            \n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] != 'X' and (new_row, new_col) not in visited:\n                visited.add((new_row, new_col))\n                queue.append(((new_row, new_col), steps + 1))\n    \n    return -1", "solution_func": "def g(grid = [['S', 'O', 'O'], ['O', 'O', 'O'], ['O', 'O', 'T']]):\n    return f(grid)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a pair of numbers in the list such that their sum is equal to the target.\n    Return True if such a pair exists, False otherwise.\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g() -> Tuple[List[int], int]:\n    return ([2, 4, 6, 8, 10], 12)\n\nassert f(*g())\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 392, "target_skills": [0, 1, 1, 0, 0, 0, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a pair of numbers in the list such that their sum is equal to the target.\n    Return True if such a pair exists, False otherwise.\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False", "solution_func": "def g() -> Tuple[List[int], int]:\n    return ([2, 4, 6, 8, 10], 12)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"\n    Given an integer, return the number of bits set to 1 in its binary representation.\n    \"\"\"\n    count = 0\n    while num > 0:\n        if num & 1:\n            count += 1\n        num >>= 1\n    return count\n\ndef g() -> int:\n    return 23\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 392, "target_skills": [0, 0, 0, 1, 0, 1, 1, 0, 0, 1], "problem_func": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"\n    Given an integer, return the number of bits set to 1 in its binary representation.\n    \"\"\"\n    count = 0\n    while num > 0:\n        if num & 1:\n            count += 1\n        num >>= 1\n    return count", "solution_func": "def g() -> int:\n    return 23", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of non-negative integers, find the maximum sum of a contiguous subarray.\n    Return the maximum sum.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for num in nums:\n        curr_sum = max(curr_sum + num, num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum\n\ndef g() -> List[int]:\n    return [1, -3, 2, 1, -1, 4, -2, 5]\n\nassert f(g()) == 9\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 392, "target_skills": [0, 1, 0, 0, 1, 0, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of non-negative integers, find the maximum sum of a contiguous subarray.\n    Return the maximum sum.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for num in nums:\n        curr_sum = max(curr_sum + num, num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum", "solution_func": "def g() -> List[int]:\n    return [1, -3, 2, 1, -1, 4, -2, 5]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the number of distinct pairs (a, b) such that a + b is divisible by 3.\n    Return the count of such pairs.\n\n    Example:\n    Input: [1, 2, 3, 4, 5, 6]\n    Output: 5\n    Explanation: The distinct pairs (1, 2), (2, 4), (1, 5), (3, 6), and (4, 5) have a sum divisible by 3.\n    \"\"\"\n\n    count = 0\n    remainder_count = [0] * 3\n\n    for num in arr:\n        remainder = num % 3\n        remainder_count[remainder] += 1\n\n    count += (remainder_count[0] * (remainder_count[0] - 1)) // 2  # Count pairs of numbers with remainder 0\n    count += remainder_count[1] * remainder_count[2]  # Count pairs of numbers with remainders 1 and 2\n\n    return count\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g()) == 5\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 392, "target_skills": [0, 0, 1, 1, 1, 1, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the number of distinct pairs (a, b) such that a + b is divisible by 3.\n    Return the count of such pairs.\n\n    Example:\n    Input: [1, 2, 3, 4, 5, 6]\n    Output: 5\n    Explanation: The distinct pairs (1, 2), (2, 4), (1, 5), (3, 6), and (4, 5) have a sum divisible by 3.\n    \"\"\"\n\n    count = 0\n    remainder_count = [0] * 3\n\n    for num in arr:\n        remainder = num % 3\n        remainder_count[remainder] += 1\n\n    count += (remainder_count[0] * (remainder_count[0] - 1)) // 2  # Count pairs of numbers with remainder 0\n    count += remainder_count[1] * remainder_count[2]  # Count pairs of numbers with remainders 1 and 2\n\n    return count", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3, 4, 5, 6]", "map_ix": [1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Example:\n    Input:\n    [1, 5, 2, 3]\n\n    Output:\n    15\n\n    Explanation:\n    The maximum product can be obtained by multiplying 5 and 3 (5 * 3 = 15).\n    \"\"\"\n\n    max_product = float('-inf')\n\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            product = arr[i] * arr[j]\n            max_product = max(max_product, product)\n\n    return max_product\n\ndef g(arr = [1, 5, 2, 3]):\n    return arr\n\nassert f(g()) == 15\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 393, "target_skills": [0, 0, 1, 1, 0, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Example:\n    Input:\n    [1, 5, 2, 3]\n\n    Output:\n    15\n\n    Explanation:\n    The maximum product can be obtained by multiplying 5 and 3 (5 * 3 = 15).\n    \"\"\"\n\n    max_product = float('-inf')\n\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            product = arr[i] * arr[j]\n            max_product = max(max_product, product)\n\n    return max_product", "solution_func": "def g(arr = [1, 5, 2, 3]):\n    return arr", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, find the area of the largest square containing only 1s.\n\n    Example:\n    Input:\n    [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n\n    Output:\n    4\n\n    Explanation:\n    The largest square containing only 1s has an area of 4 (2x2 square in the top-right corner).\n    \"\"\"\n\n    if not grid:\n        return 0\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    max_side = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                side = 1\n                while i+side < rows and j+side < cols:\n                    found_zero = False\n                    for k in range(i, i+side+1):\n                        if grid[k][j+side] == 0:\n                            found_zero = True\n                            break\n                    for k in range(j, j+side):\n                        if grid[i+side][k] == 0:\n                            found_zero = True\n                            break\n                    if found_zero:\n                        break\n                    side += 1\n                max_side = max(max_side, side)\n\n    return max_side * max_side\n\ndef g(grid = [\n    [1, 0, 1, 0, 0],\n    [1, 0, 1, 1, 1],\n    [1, 1, 1, 1, 1],\n    [1, 0, 0, 1, 0]\n]):\n    return grid\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], "idx_generation": 393, "target_skills": [0, 0, 0, 0, 1, 1, 1, 0, 1, 1], "problem_func": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, find the area of the largest square containing only 1s.\n\n    Example:\n    Input:\n    [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n\n    Output:\n    4\n\n    Explanation:\n    The largest square containing only 1s has an area of 4 (2x2 square in the top-right corner).\n    \"\"\"\n\n    if not grid:\n        return 0\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    max_side = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                side = 1\n                while i+side < rows and j+side < cols:\n                    found_zero = False\n                    for k in range(i, i+side+1):\n                        if grid[k][j+side] == 0:\n                            found_zero = True\n                            break\n                    for k in range(j, j+side):\n                        if grid[i+side][k] == 0:\n                            found_zero = True\n                            break\n                    if found_zero:\n                        break\n                    side += 1\n                max_side = max(max_side, side)\n\n    return max_side * max_side", "solution_func": "def g(grid = [\n    [1, 0, 1, 0, 0],\n    [1, 0, 1, 1, 1],\n    [1, 1, 1, 1, 1],\n    [1, 0, 0, 1, 0]\n]):\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    Input:\n    arr = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1 (2 and 7) add up to the target value 9.\n    \"\"\"\n\n    num_map = {}\n\n    for i, num in enumerate(arr):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n\n    return []\n\ndef g(arr = [2, 7, 11, 15], target = 9):\n    return arr, target\n\nassert f(*g()) == [0, 1]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 393, "target_skills": [0, 0, 1, 0, 1, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    Input:\n    arr = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1 (2 and 7) add up to the target value 9.\n    \"\"\"\n\n    num_map = {}\n\n    for i, num in enumerate(arr):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n\n    return []", "solution_func": "def g(arr = [2, 7, 11, 15], target = 9):\n    return arr, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a list of words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.\n\n    Sample Input:\n    s = \"leetcode\"\n    words = [\"leet\", \"code\"]\n\n    Sample Output:\n    True\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return False\n    \n    dp = [False] * (n+1)\n    dp[0] = True\n\n    for i in range(1, n+1):\n        for word in words:\n            if i >= len(word) and s[i-len(word):i] == word:\n                dp[i] = dp[i] or dp[i-len(word)]\n\n    return dp[n]\n\ndef g():\n    return [\"leetcode\", [\"leet\", \"code\"]]\n\nassert f(*g())\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 393, "target_skills": [1, 0, 0, 0, 0, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a list of words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.\n\n    Sample Input:\n    s = \"leetcode\"\n    words = [\"leet\", \"code\"]\n\n    Sample Output:\n    True\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return False\n    \n    dp = [False] * (n+1)\n    dp[0] = True\n\n    for i in range(1, n+1):\n        for word in words:\n            if i >= len(word) and s[i-len(word):i] == word:\n                dp[i] = dp[i] or dp[i-len(word)]\n\n    return dp[n]", "solution_func": "def g():\n    return [\"leetcode\", [\"leet\", \"code\"]]", "map_ix": [1, 1, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"\n    Given a positive integer num, calculate the sum of all numbers formed by the unique combinations of its digits.\n\n    Sample Input:\n    num = 123\n\n    Sample Output:\n    174\n    \"\"\"\n    def backtrack(num, path, used):\n        if len(path) == len(str(num)):\n            combinations.append(int(\"\".join(path)))\n            return\n\n        for i in range(len(str(num))):\n            if not used[i]:\n                used[i] = True\n                path.append(str(num)[i])\n                backtrack(num, path, used)\n                used[i] = False\n                path.pop()\n\n    combinations = []\n    used = [False] * len(str(num))\n    backtrack(num, [], used)\n    return sum(combinations)\n\ndef g():\n    return 123\n\nassert f(g()) == 174\n", "emb": null, "idx_generation": 393, "target_skills": [0, 0, 1, 1, 0, 1, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"\n    Given a positive integer num, calculate the sum of all numbers formed by the unique combinations of its digits.\n\n    Sample Input:\n    num = 123\n\n    Sample Output:\n    174\n    \"\"\"\n    def backtrack(num, path, used):\n        if len(path) == len(str(num)):\n            combinations.append(int(\"\".join(path)))\n            return\n\n        for i in range(len(str(num))):\n            if not used[i]:\n                used[i] = True\n                path.append(str(num)[i])\n                backtrack(num, path, used)\n                used[i] = False\n                path.pop()\n\n    combinations = []\n    used = [False] * len(str(num))\n    backtrack(num, [], used)\n    return sum(combinations)", "solution_func": "def g():\n    return 123", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum path from the top-left corner to the bottom-right corner, by moving only right or down.\n\n    Sample Input:\n    grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\n    Sample Output:\n    7\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 7\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 393, "target_skills": [1, 1, 0, 0, 0, 1, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum path from the top-left corner to the bottom-right corner, by moving only right or down.\n\n    Sample Input:\n    grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\n    Sample Output:\n    7\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]", "solution_func": "def g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of any path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    The maximum sum path is 1 -> 4 -> 7 -> 8 -> 9, which gives a sum of 29.\n\n    Return the maximum sum of any path.\n    \"\"\"\n    if not matrix:\n        return 0\n    \n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    \n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = matrix[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + matrix[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + matrix[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    \n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == 29\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 393, "target_skills": [1, 0, 1, 0, 0, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of any path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    The maximum sum path is 1 -> 4 -> 7 -> 8 -> 9, which gives a sum of 29.\n\n    Return the maximum sum of any path.\n    \"\"\"\n    if not matrix:\n        return 0\n    \n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    \n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = matrix[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + matrix[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + matrix[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    \n    return dp[rows-1][cols-1]", "solution_func": "def g() -> List[List[int]]:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n\n    Return the length of the longest increasing subsequence.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    n = len(nums)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 393, "target_skills": [0, 0, 0, 1, 0, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n\n    Return the length of the longest increasing subsequence.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    n = len(nums)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)", "solution_func": "def g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list containing only the words that can be formed by rearranging the letters \n    of other words in the list.\n\n    Example:\n    words = [\"cat\", \"tac\", \"dog\", \"god\", \"act\"]\n    The words \"cat\", \"tac\", and \"act\" can be formed by rearranging the letters of other words in the list.\n\n    Return the list of words that can be formed by rearranging the letters of other words.\n    \"\"\"\n    def count_chars(word):\n        char_count = [0] * 26\n        for char in word:\n            char_count[ord(char) - ord('a')] += 1\n        return tuple(char_count)\n    \n    word_counts = {}\n    result = []\n    \n    for word in words:\n        count = count_chars(word)\n        if count in word_counts:\n            word_counts[count].append(word)\n        else:\n            word_counts[count] = [word]\n    \n    for count, word_list in word_counts.items():\n        if len(word_list) > 1:\n            result.extend(word_list)\n    \n    return result\n\ndef g() -> List[str]:\n    words = [\"cat\", \"tac\", \"dog\", \"god\", \"act\"]\n    return words\n\nassert f(g()) == [\"cat\", \"tac\", \"act\"]\n\n", "emb": null, "idx_generation": 393, "target_skills": [0, 0, 0, 1, 0, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list containing only the words that can be formed by rearranging the letters \n    of other words in the list.\n\n    Example:\n    words = [\"cat\", \"tac\", \"dog\", \"god\", \"act\"]\n    The words \"cat\", \"tac\", and \"act\" can be formed by rearranging the letters of other words in the list.\n\n    Return the list of words that can be formed by rearranging the letters of other words.\n    \"\"\"\n    def count_chars(word):\n        char_count = [0] * 26\n        for char in word:\n            char_count[ord(char) - ord('a')] += 1\n        return tuple(char_count)\n    \n    word_counts = {}\n    result = []\n    \n    for word in words:\n        count = count_chars(word)\n        if count in word_counts:\n            word_counts[count].append(word)\n        else:\n            word_counts[count] = [word]\n    \n    for count, word_list in word_counts.items():\n        if len(word_list) > 1:\n            result.extend(word_list)\n    \n    return result", "solution_func": "def g() -> List[str]:\n    words = [\"cat\", \"tac\", \"dog\", \"god\", \"act\"]\n    return words", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a submatrix with dimensions n x m.\n    Return the maximum sum.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    max_sum = float('-inf')\n    \n    for i in range(rows):\n        for j in range(cols):\n            for n in range(i, rows):\n                for m in range(j, cols):\n                    submatrix_sum = 0\n                    for x in range(i, n+1):\n                        for y in range(j, m+1):\n                            submatrix_sum += matrix[x][y]\n                    max_sum = max(max_sum, submatrix_sum)\n    \n    return max_sum\n\ndef g():\n    matrix = [[1, 2, -1], [-4, -5, 6], [7, 8, -9]]\n    return matrix\n\nassert f(g()) == 21\n\n", "emb": null, "idx_generation": 393, "target_skills": [1, 0, 0, 0, 1, 1, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a submatrix with dimensions n x m.\n    Return the maximum sum.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    max_sum = float('-inf')\n    \n    for i in range(rows):\n        for j in range(cols):\n            for n in range(i, rows):\n                for m in range(j, cols):\n                    submatrix_sum = 0\n                    for x in range(i, n+1):\n                        for y in range(j, m+1):\n                            submatrix_sum += matrix[x][y]\n                    max_sum = max(max_sum, submatrix_sum)\n    \n    return max_sum", "solution_func": "def g():\n    matrix = [[1, 2, -1], [-4, -5, 6], [7, 8, -9]]\n    return matrix", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(s: str, k: int) -> List[str]:\n    \"\"\"\n    Given a string s and an integer k, generate all possible combinations of length k from the characters of s.\n\n    Example:\n    Input: s = \"abc\", k = 2\n    Output: [\"ab\", \"ac\", \"bc\"]\n\n    Explanation: The solution set contains all possible combinations of length 2 from the characters 'a', 'b', 'c'.\n    \"\"\"\n\n    def backtrack(combination: str, start: int):\n        if len(combination) == k:\n            result.append(combination)\n            return\n        for i in range(start, len(s)):\n            backtrack(combination + s[i], i + 1)\n\n    result = []\n    backtrack(\"\", 0)\n    return result\n\ndef g():\n    s = \"abc\"\n    k = 2\n    return s, k\n\nassert f(*g()) == [\"ab\", \"ac\", \"bc\"]\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 394, "target_skills": [0, 1, 1, 0, 1, 1, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(s: str, k: int) -> List[str]:\n    \"\"\"\n    Given a string s and an integer k, generate all possible combinations of length k from the characters of s.\n\n    Example:\n    Input: s = \"abc\", k = 2\n    Output: [\"ab\", \"ac\", \"bc\"]\n\n    Explanation: The solution set contains all possible combinations of length 2 from the characters 'a', 'b', 'c'.\n    \"\"\"\n\n    def backtrack(combination: str, start: int):\n        if len(combination) == k:\n            result.append(combination)\n            return\n        for i in range(start, len(s)):\n            backtrack(combination + s[i], i + 1)\n\n    result = []\n    backtrack(\"\", 0)\n    return result", "solution_func": "def g():\n    s = \"abc\"\n    k = 2\n    return s, k", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency list, determine if there is a path from start to end using only nodes with odd values.\n\n    Example:\n    Input: graph = [[1, 3], [0, 2, 4], [1, 3], [0, 2, 4], [1, 3]], start = 1, end = 4\n    Output: True\n\n    Explanation: The path [1, 2, 3, 4] uses only nodes with odd values.\n    \"\"\"\n\n    def dfs(node: int) -> bool:\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor % 2 == 1 and neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n        return False\n\n    visited = set()\n    return dfs(start)\n\ndef g():\n    graph = [[1, 3], [0, 2, 4], [1, 3], [0, 2, 4], [1, 3]]\n    start = 1\n    end = 4\n    return graph, start, end\n\nassert f(*g())\n", "emb": null, "idx_generation": 394, "target_skills": [0, 1, 1, 0, 0, 1, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency list, determine if there is a path from start to end using only nodes with odd values.\n\n    Example:\n    Input: graph = [[1, 3], [0, 2, 4], [1, 3], [0, 2, 4], [1, 3]], start = 1, end = 4\n    Output: True\n\n    Explanation: The path [1, 2, 3, 4] uses only nodes with odd values.\n    \"\"\"\n\n    def dfs(node: int) -> bool:\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor % 2 == 1 and neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n        return False\n\n    visited = set()\n    return dfs(start)", "solution_func": "def g():\n    graph = [[1, 3], [0, 2, 4], [1, 3], [0, 2, 4], [1, 3]]\n    start = 1\n    end = 4\n    return graph, start, end", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers nums and an integer target, find the maximum length of a subarray that sums up to the target.\n\n    Example:\n    Input: nums = [1, -1, 5, -2, 3], target = 3\n    Output: 4\n\n    Explanation: The subarray [1, -1, 5, -2] has a sum of 3 and is the longest subarray that sums up to the target.\n    \"\"\"\n\n    prefix_sum = {0: -1}\n    curr_sum = 0\n    max_length = 0\n    for i, num in enumerate(nums):\n        curr_sum += num\n        if curr_sum - target in prefix_sum:\n            max_length = max(max_length, i - prefix_sum[curr_sum - target])\n        if curr_sum not in prefix_sum:\n            prefix_sum[curr_sum] = i\n    return max_length\n\ndef g():\n    nums = [1, -1, 5, -2, 3]\n    target = 3\n    return nums, target\n\nassert f(*g()) == 4\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 394, "target_skills": [1, 1, 0, 1, 1, 1, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers nums and an integer target, find the maximum length of a subarray that sums up to the target.\n\n    Example:\n    Input: nums = [1, -1, 5, -2, 3], target = 3\n    Output: 4\n\n    Explanation: The subarray [1, -1, 5, -2] has a sum of 3 and is the longest subarray that sums up to the target.\n    \"\"\"\n\n    prefix_sum = {0: -1}\n    curr_sum = 0\n    max_length = 0\n    for i, num in enumerate(nums):\n        curr_sum += num\n        if curr_sum - target in prefix_sum:\n            max_length = max(max_length, i - prefix_sum[curr_sum - target])\n        if curr_sum not in prefix_sum:\n            prefix_sum[curr_sum] = i\n    return max_length", "solution_func": "def g():\n    nums = [1, -1, 5, -2, 3]\n    target = 3\n    return nums, target", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of distinct pairs (a, b) such that a + b = target, where target is a given integer.\n\n    Return the number of distinct pairs.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 6\n\n    Output:\n    2\n\n    Explanation:\n    The distinct pairs that sum up to 6 are (1, 5) and (2, 4).\n    \"\"\"\n    def count_pairs(arr, target):\n        count = 0\n        seen = set()\n        \n        for num in arr:\n            complement = target - num\n            if complement in seen:\n                count += 1\n            seen.add(num)\n        \n        return count\n\n    target = 6\n    return count_pairs(arr, target)\n\ndef g(arr=[1, 2, 3, 4, 5]):\n    return arr\n\nassert f(g()) == 2\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 394, "target_skills": [0, 0, 0, 1, 0, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of distinct pairs (a, b) such that a + b = target, where target is a given integer.\n\n    Return the number of distinct pairs.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 6\n\n    Output:\n    2\n\n    Explanation:\n    The distinct pairs that sum up to 6 are (1, 5) and (2, 4).\n    \"\"\"\n    def count_pairs(arr, target):\n        count = 0\n        seen = set()\n        \n        for num in arr:\n            complement = target - num\n            if complement in seen:\n                count += 1\n            seen.add(num)\n        \n        return count\n\n    target = 6\n    return count_pairs(arr, target)", "solution_func": "def g(arr=[1, 2, 3, 4, 5]):\n    return arr", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of distinct triplets (a, b, c) such that a + b + c = target, where target is a given integer.\n\n    Return the number of distinct triplets.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 6\n\n    Output:\n    1\n\n    Explanation:\n    The distinct triplets that sum up to 6 are (1, 2, 3).\n    \"\"\"\n    def count_triplets(arr, target):\n        count = 0\n        \n        for i in range(len(arr) - 2):\n            left = i + 1\n            right = len(arr) - 1\n            \n            while left < right:\n                current_sum = arr[i] + arr[left] + arr[right]\n                \n                if current_sum == target:\n                    count += 1\n                    left += 1\n                    right -= 1\n                elif current_sum < target:\n                    left += 1\n                else:\n                    right -= 1\n        \n        return count\n\n    target = 6\n    return count_triplets(arr, target)\n\ndef g(arr=[1, 2, 3, 4, 5]):\n    return arr\n\nassert f(g()) == 1\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 394, "target_skills": [1, 1, 0, 0, 1, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of distinct triplets (a, b, c) such that a + b + c = target, where target is a given integer.\n\n    Return the number of distinct triplets.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 6\n\n    Output:\n    1\n\n    Explanation:\n    The distinct triplets that sum up to 6 are (1, 2, 3).\n    \"\"\"\n    def count_triplets(arr, target):\n        count = 0\n        \n        for i in range(len(arr) - 2):\n            left = i + 1\n            right = len(arr) - 1\n            \n            while left < right:\n                current_sum = arr[i] + arr[left] + arr[right]\n                \n                if current_sum == target:\n                    count += 1\n                    left += 1\n                    right -= 1\n                elif current_sum < target:\n                    left += 1\n                else:\n                    right -= 1\n        \n        return count\n\n    target = 6\n    return count_triplets(arr, target)", "solution_func": "def g(arr=[1, 2, 3, 4, 5]):\n    return arr", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, reverse each word in the list.\n\n    Return the list of reversed words.\n\n    Example:\n    arr = [\"hello\", \"world\", \"python\"]\n\n    Output:\n    [\"olleh\", \"dlrow\", \"nohtyp\"]\n    \"\"\"\n    def reverse_words(arr):\n        reversed_arr = []\n        \n        for word in arr:\n            reversed_arr.append(word[::-1])\n        \n        return reversed_arr\n\n    return reverse_words(arr)\n\ndef g(arr=[\"hello\", \"world\", \"python\"]):\n    return arr\n\nassert f(g()) == [\"olleh\", \"dlrow\", \"nohtyp\"]\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 394, "target_skills": [1, 1, 0, 0, 0, 0, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, reverse each word in the list.\n\n    Return the list of reversed words.\n\n    Example:\n    arr = [\"hello\", \"world\", \"python\"]\n\n    Output:\n    [\"olleh\", \"dlrow\", \"nohtyp\"]\n    \"\"\"\n    def reverse_words(arr):\n        reversed_arr = []\n        \n        for word in arr:\n            reversed_arr.append(word[::-1])\n        \n        return reversed_arr\n\n    return reverse_words(arr)", "solution_func": "def g(arr=[\"hello\", \"world\", \"python\"]):\n    return arr", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation: The numbers at indices 0 and 1 (2 and 7) add up to the target 9.\n\n    Hint: Sort the list first and use two pointers, one at the beginning and one at the end, to find the pair that adds up to the target.\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return [left, right]\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 394, "target_skills": [0, 1, 0, 0, 1, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation: The numbers at indices 0 and 1 (2 and 7) add up to the target 9.\n\n    Hint: Sort the list first and use two pointers, one at the beginning and one at the end, to find the pair that adds up to the target.\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return [left, right]\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return []", "solution_func": "def g(nums=[2, 7, 11, 15], target=9):\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Determine the number of ways to climb to the top of a staircase with 'n' steps, where at each step you can either climb 1 or 2 steps.\n    The number of ways should be returned modulo 10^9 + 7.\n\n    Example:\n    Input: n = 3, k = 100\n    Output: 3\n\n    Explanation: There are 3 ways to climb to the top: [1, 1, 1], [1, 2], [2, 1].\n\n    Hint: Use dynamic programming to store the number of ways to reach each step.\n    \"\"\"\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = (dp[i - 1] + dp[i - 2]) % (10**9 + 7)\n    return dp[n]\n\ndef g(n=3, k=100):\n    return n, k\n\nassert f(*g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 394, "target_skills": [1, 0, 1, 0, 1, 1, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Determine the number of ways to climb to the top of a staircase with 'n' steps, where at each step you can either climb 1 or 2 steps.\n    The number of ways should be returned modulo 10^9 + 7.\n\n    Example:\n    Input: n = 3, k = 100\n    Output: 3\n\n    Explanation: There are 3 ways to climb to the top: [1, 1, 1], [1, 2], [2, 1].\n\n    Hint: Use dynamic programming to store the number of ways to reach each step.\n    \"\"\"\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = (dp[i - 1] + dp[i - 2]) % (10**9 + 7)\n    return dp[n]", "solution_func": "def g(n=3, k=100):\n    return n, k", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Determine if there exists a subarray in the list of integers nums that sums up to the target.\n    Return True if such subarray exists, otherwise return False.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5], target = 9\n    Output: True\n\n    Explanation: The subarray [2, 3, 4] sums up to the target 9.\n\n    Hint: Use a sliding window approach to keep track of the current sum of the subarray.\n    \"\"\"\n    left = 0\n    current_sum = 0\n    for right in range(len(nums)):\n        current_sum += nums[right]\n        while current_sum > target:\n            current_sum -= nums[left]\n            left += 1\n        if current_sum == target:\n            return True\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5], target=9):\n    return nums, target\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 394, "target_skills": [0, 0, 0, 1, 1, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Determine if there exists a subarray in the list of integers nums that sums up to the target.\n    Return True if such subarray exists, otherwise return False.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5], target = 9\n    Output: True\n\n    Explanation: The subarray [2, 3, 4] sums up to the target 9.\n\n    Hint: Use a sliding window approach to keep track of the current sum of the subarray.\n    \"\"\"\n    left = 0\n    current_sum = 0\n    for right in range(len(nums)):\n        current_sum += nums[right]\n        while current_sum > target:\n            current_sum -= nums[left]\n            left += 1\n        if current_sum == target:\n            return True\n    return False", "solution_func": "def g(nums=[1, 2, 3, 4, 5], target=9):\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if a given number is a prime number.\n\n    Sample Input:\n    n = 17\n\n    Sample Output:\n    True\n    \"\"\"\n    if n <= 1:\n        return False\n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n\n    return True\n\ndef g(n=17):\n    return n\n\nassert f(g())\n", "emb": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "idx_generation": 394, "target_skills": [1, 1, 1, 0, 1, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if a given number is a prime number.\n\n    Sample Input:\n    n = 17\n\n    Sample Output:\n    True\n    \"\"\"\n    if n <= 1:\n        return False\n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n\n    return True", "solution_func": "def g(n=17):\n    return n", "map_ix": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, return True if there exists a sublist in the list that sums up to zero.\n    \"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum in prefix_sums or prefix_sum == 0:\n            return True\n        prefix_sums.add(prefix_sum)\n    return False\n\ndef g(nums = [1, -2, 3, 4, -5]):\n    return nums\n\nassert f(g()) == True\n", "emb": [1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 395, "target_skills": [1, 1, 0, 1, 0, 0, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, return True if there exists a sublist in the list that sums up to zero.\n    \"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum in prefix_sums or prefix_sum == 0:\n            return True\n        prefix_sums.add(prefix_sum)\n    return False", "solution_func": "def g(nums = [1, -2, 3, 4, -5]):\n    return nums", "map_ix": [1, 0, 1, 1, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum sum of a contiguous subarray.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g(nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 395, "target_skills": [0, 0, 1, 0, 1, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum sum of a contiguous subarray.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum", "solution_func": "def g(nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n    \"\"\"\n    if n <= 1:\n        return n\n    fib = [0, 1]\n    for i in range(2, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2])\n    return fib[n]\n\ndef g(n = 6):\n    return n\n\nassert f(g()) == 8\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 395, "target_skills": [1, 0, 0, 0, 1, 1, 0, 0, 1, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n    \"\"\"\n    if n <= 1:\n        return n\n    fib = [0, 1]\n    for i in range(2, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2])\n    return fib[n]", "solution_func": "def g(n = 6):\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, determine if it contains a cycle.\n\n    Args:\n    - graph: The adjacency matrix representing the graph.\n\n    Returns:\n    - True if the graph contains a cycle, False otherwise.\n    \"\"\"\n    visited = [False] * len(graph)\n    for node in range(len(graph)):\n        if not visited[node]:\n            if is_cyclic(graph, node, visited, -1):\n                return True\n    return False\n\ndef is_cyclic(graph: List[List[int]], node: int, visited: List[bool], parent: int) -> bool:\n    visited[node] = True\n    for neighbor in range(len(graph)):\n        if graph[node][neighbor] == 1:\n            if not visited[neighbor]:\n                if is_cyclic(graph, neighbor, visited, node):\n                    return True\n            elif parent != neighbor:\n                return True\n    return False\n\ndef g():\n    graph = [\n        [0, 1, 0, 0],\n        [1, 0, 1, 1],\n        [0, 1, 0, 1],\n        [0, 1, 1, 0]\n    ]\n    return graph\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 395, "target_skills": [0, 1, 1, 0, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, determine if it contains a cycle.\n\n    Args:\n    - graph: The adjacency matrix representing the graph.\n\n    Returns:\n    - True if the graph contains a cycle, False otherwise.\n    \"\"\"\n    visited = [False] * len(graph)\n    for node in range(len(graph)):\n        if not visited[node]:\n            if is_cyclic(graph, node, visited, -1):\n                return True\n    return False\n\ndef is_cyclic(graph: List[List[int]], node: int, visited: List[bool], parent: int) -> bool:\n    visited[node] = True\n    for neighbor in range(len(graph)):\n        if graph[node][neighbor] == 1:\n            if not visited[neighbor]:\n                if is_cyclic(graph, neighbor, visited, node):\n                    return True\n            elif parent != neighbor:\n                return True\n    return False", "solution_func": "def g():\n    graph = [\n        [0, 1, 0, 0],\n        [1, 0, 1, 1],\n        [0, 1, 0, 1],\n        [0, 1, 1, 0]\n    ]\n    return graph", "map_ix": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the path with the maximum sum from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Args:\n    - grid: The grid of integers.\n\n    Returns:\n    - The maximum sum of the path.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[rows-1][cols-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 9\n", "emb": null, "idx_generation": 395, "target_skills": [1, 1, 1, 0, 0, 1, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the path with the maximum sum from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Args:\n    - grid: The grid of integers.\n\n    Returns:\n    - The maximum sum of the path.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[rows-1][cols-1]", "solution_func": "def g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, determine if it contains a Hamiltonian path.\n\n    Args:\n    - graph: The adjacency matrix representing the graph.\n\n    Returns:\n    - True if the graph contains a Hamiltonian path, False otherwise.\n    \"\"\"\n    n = len(graph)\n    for mask in range(1, 1 << n):\n        path = []\n        for node in range(n):\n            if mask & (1 << node):\n                path.append(node)\n        if is_hamiltonian(graph, path):\n            return True\n    return False\n\ndef is_hamiltonian(graph: List[List[int]], path: List[int]) -> bool:\n    for i in range(len(path) - 1):\n        if not graph[path[i]][path[i+1]]:\n            return False\n    return True\n\ndef g():\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 1],\n        [1, 0, 0, 1],\n        [1, 1, 0, 0]\n    ]\n    return graph\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 395, "target_skills": [1, 0, 0, 0, 0, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, determine if it contains a Hamiltonian path.\n\n    Args:\n    - graph: The adjacency matrix representing the graph.\n\n    Returns:\n    - True if the graph contains a Hamiltonian path, False otherwise.\n    \"\"\"\n    n = len(graph)\n    for mask in range(1, 1 << n):\n        path = []\n        for node in range(n):\n            if mask & (1 << node):\n                path.append(node)\n        if is_hamiltonian(graph, path):\n            return True\n    return False\n\ndef is_hamiltonian(graph: List[List[int]], path: List[int]) -> bool:\n    for i in range(len(path) - 1):\n        if not graph[path[i]][path[i+1]]:\n            return False\n    return True", "solution_func": "def g():\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 1],\n        [1, 0, 0, 1],\n        [1, 1, 0, 0]\n    ]\n    return graph", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if the target number is present in the array.\"\"\"\n    return target in arr\ndef g(arr: List[int], target: int):\n    return arr.index(target)\nassert f(g())\n", "emb": null, "idx_generation": 395, "target_skills": [0, 1, 0, 0, 0, 0, 1, 0, 1, 1], "problem_func": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if the target number is present in the array.\"\"\"\n    return target in arr", "solution_func": "def g(arr: List[int], target: int):\n    return arr.index(target)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"Check if the target string is a substring of s.\"\"\"\n    return target in s\ndef g(s: str, target: str):\n    return s.find(target)\nassert f(g())\n", "emb": null, "idx_generation": 395, "target_skills": [0, 1, 1, 1, 1, 1, 0, 1, 0, 0], "problem_func": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"Check if the target string is a substring of s.\"\"\"\n    return target in s", "solution_func": "def g(s: str, target: str):\n    return s.find(target)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if the target number is present in the array using binary search.\"\"\"\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\ndef g(arr: List[int], target: int):\n    return target\nassert f(g())\n", "emb": null, "idx_generation": 395, "target_skills": [0, 0, 1, 1, 0, 0, 0, 1, 0, 0], "problem_func": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if the target number is present in the array using binary search.\"\"\"\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False", "solution_func": "def g(arr: List[int], target: int):\n    return target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Example:\n    arr = [1, 2, 3, 4]\n\n    Output:\n    12\n\n    Explanation:\n    The maximum product is achieved by multiplying 3 and 4, which results in 12.\n    \"\"\"\n\n    max_product = float('-inf')\n\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            product = arr[i] * arr[j]\n            max_product = max(max_product, product)\n\n    return max_product\n\ndef g():\n    arr = [1, 2, 3, 4]\n    return arr\n\nassert f(g()) == 12\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0], "idx_generation": 395, "target_skills": [1, 1, 0, 1, 1, 1, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Example:\n    arr = [1, 2, 3, 4]\n\n    Output:\n    12\n\n    Explanation:\n    The maximum product is achieved by multiplying 3 and 4, which results in 12.\n    \"\"\"\n\n    max_product = float('-inf')\n\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            product = arr[i] * arr[j]\n            max_product = max(max_product, product)\n\n    return max_product", "solution_func": "def g():\n    arr = [1, 2, 3, 4]\n    return arr", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 1, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[int]:\n    \"\"\"\n    Given an integer n, return a list of the first n Fibonacci numbers.\n\n    Args:\n    - n: An integer, the number of Fibonacci numbers to return.\n\n    Returns:\n    - A list of the first n Fibonacci numbers.\n    \"\"\"\n    fib = [0, 1]\n    \n    for i in range(2, n):\n        fib.append(fib[i-1] + fib[i-2])\n    \n    return fib\n\ndef g() -> int:\n    n = 5\n    return n\n\nassert f(g()) == [0, 1, 1, 2, 3]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 396, "target_skills": [0, 1, 0, 1, 0, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[int]:\n    \"\"\"\n    Given an integer n, return a list of the first n Fibonacci numbers.\n\n    Args:\n    - n: An integer, the number of Fibonacci numbers to return.\n\n    Returns:\n    - A list of the first n Fibonacci numbers.\n    \"\"\"\n    fib = [0, 1]\n    \n    for i in range(2, n):\n        fib.append(fib[i-1] + fib[i-2])\n    \n    return fib", "solution_func": "def g() -> int:\n    n = 5\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[int]:\n    \"\"\"\n    Given an integer n, return a list of all prime numbers up to n.\n\n    Args:\n    - n: An integer, the upper limit to generate prime numbers.\n\n    Returns:\n    - A list of all prime numbers up to n.\n    \"\"\"\n    primes = []\n    \n    for num in range(2, n+1):\n        is_prime = True\n        \n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                is_prime = False\n                break\n        \n        if is_prime:\n            primes.append(num)\n    \n    return primes\n\ndef g() -> int:\n    n = 20\n    return n\n\nassert f(g()) == [2, 3, 5, 7, 11, 13, 17, 19]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 396, "target_skills": [1, 0, 0, 0, 1, 1, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[int]:\n    \"\"\"\n    Given an integer n, return a list of all prime numbers up to n.\n\n    Args:\n    - n: An integer, the upper limit to generate prime numbers.\n\n    Returns:\n    - A list of all prime numbers up to n.\n    \"\"\"\n    primes = []\n    \n    for num in range(2, n+1):\n        is_prime = True\n        \n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                is_prime = False\n                break\n        \n        if is_prime:\n            primes.append(num)\n    \n    return primes", "solution_func": "def g() -> int:\n    n = 20\n    return n", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, return True if s is a palindrome, False otherwise.\n\n    Args:\n    - s: A string to check for palindrome.\n\n    Returns:\n    - True if s is a palindrome, False otherwise.\n    \"\"\"\n    s = s.lower()\n    s = \"\".join(char for char in s if char.isalnum())\n    \n    return s == s[::-1]\n\ndef g() -> str:\n    s = \"A man, a plan, a canal: Panama\"\n    return s\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 396, "target_skills": [0, 1, 1, 0, 1, 0, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, return True if s is a palindrome, False otherwise.\n\n    Args:\n    - s: A string to check for palindrome.\n\n    Returns:\n    - True if s is a palindrome, False otherwise.\n    \"\"\"\n    s = s.lower()\n    s = \"\".join(char for char in s if char.isalnum())\n    \n    return s == s[::-1]", "solution_func": "def g() -> str:\n    s = \"A man, a plan, a canal: Panama\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, sort the list in non-decreasing order.\n\n    Args:\n    nums (List[int]): The list of integers to be sorted.\n\n    Returns:\n    List[int]: The sorted list of integers.\n    \"\"\"\n\n    def merge_sort(nums):\n        if len(nums) <= 1:\n            return nums\n\n        mid = len(nums) // 2\n        left = merge_sort(nums[:mid])\n        right = merge_sort(nums[mid:])\n\n        merged = merge(left, right)\n        return merged\n\n    def merge(left, right):\n        merged = []\n        i, j = 0, 0\n\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n\n        while i < len(left):\n            merged.append(left[i])\n            i += 1\n\n        while j < len(right):\n            merged.append(right[j])\n            j += 1\n\n        return merged\n\n    return merge_sort(nums)\n\ndef g(nums=[5, 2, 8, 1, 9, 3, 7]):\n    \"\"\"\n    Generate a list of integers for sorting.\n    \"\"\"\n    return (nums,)\n\nassert f(*g()) == [1, 2, 3, 5, 7, 8, 9]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 396, "target_skills": [0, 1, 1, 1, 0, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, sort the list in non-decreasing order.\n\n    Args:\n    nums (List[int]): The list of integers to be sorted.\n\n    Returns:\n    List[int]: The sorted list of integers.\n    \"\"\"\n\n    def merge_sort(nums):\n        if len(nums) <= 1:\n            return nums\n\n        mid = len(nums) // 2\n        left = merge_sort(nums[:mid])\n        right = merge_sort(nums[mid:])\n\n        merged = merge(left, right)\n        return merged\n\n    def merge(left, right):\n        merged = []\n        i, j = 0, 0\n\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n\n        while i < len(left):\n            merged.append(left[i])\n            i += 1\n\n        while j < len(right):\n            merged.append(right[j])\n            j += 1\n\n        return merged\n\n    return merge_sort(nums)", "solution_func": "def g(nums=[5, 2, 8, 1, 9, 3, 7]):\n    \"\"\"\n    Generate a list of integers for sorting.\n    \"\"\"\n    return (nums,)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the length of the longest substring without repeating characters.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    int: The length of the longest substring without repeating characters.\n    \"\"\"\n    n = len(s)\n    max_len = 0\n    start = 0\n    char_to_idx = {}\n\n    for i in range(n):\n        if s[i] in char_to_idx and start <= char_to_idx[s[i]]:\n            start = char_to_idx[s[i]] + 1\n        else:\n            max_len = max(max_len, i - start + 1)\n        char_to_idx[s[i]] = i\n\n    return max_len\n\ndef g(s=\"abcabcbb\"):\n    \"\"\"\n    Generate a string for finding the length of the longest substring without repeating characters.\n    \"\"\"\n    return (s,)\n\nassert f(*g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 396, "target_skills": [0, 1, 1, 1, 0, 0, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the length of the longest substring without repeating characters.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    int: The length of the longest substring without repeating characters.\n    \"\"\"\n    n = len(s)\n    max_len = 0\n    start = 0\n    char_to_idx = {}\n\n    for i in range(n):\n        if s[i] in char_to_idx and start <= char_to_idx[s[i]]:\n            start = char_to_idx[s[i]] + 1\n        else:\n            max_len = max(max_len, i - start + 1)\n        char_to_idx[s[i]] = i\n\n    return max_len", "solution_func": "def g(s=\"abcabcbb\"):\n    \"\"\"\n    Generate a string for finding the length of the longest substring without repeating characters.\n    \"\"\"\n    return (s,)", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum area of a rectangle formed by the height of the bars in the histogram.\n\n    Args:\n    nums (List[int]): The list of integers representing the heights of the bars.\n\n    Returns:\n    int: The maximum area of the rectangle.\n    \"\"\"\n    n = len(nums)\n    stack = []\n    max_area = 0\n    i = 0\n\n    while i < n:\n        if not stack or nums[i] >= nums[stack[-1]]:\n            stack.append(i)\n            i += 1\n        else:\n            top = stack.pop()\n            width = i if not stack else i - stack[-1] - 1\n            area = nums[top] * width\n            max_area = max(max_area, area)\n\n    while stack:\n        top = stack.pop()\n        width = i if not stack else n - stack[-1] - 1\n        area = nums[top] * width\n        max_area = max(max_area, area)\n\n    return max_area\n\ndef g(nums=[2, 1, 5, 6, 2, 3]):\n    \"\"\"\n    Generate a list of integers for finding the maximum area of a histogram.\n    \"\"\"\n    return (nums,)\n\nassert f(*g()) == 10\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 396, "target_skills": [0, 1, 0, 0, 0, 0, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum area of a rectangle formed by the height of the bars in the histogram.\n\n    Args:\n    nums (List[int]): The list of integers representing the heights of the bars.\n\n    Returns:\n    int: The maximum area of the rectangle.\n    \"\"\"\n    n = len(nums)\n    stack = []\n    max_area = 0\n    i = 0\n\n    while i < n:\n        if not stack or nums[i] >= nums[stack[-1]]:\n            stack.append(i)\n            i += 1\n        else:\n            top = stack.pop()\n            width = i if not stack else i - stack[-1] - 1\n            area = nums[top] * width\n            max_area = max(max_area, area)\n\n    while stack:\n        top = stack.pop()\n        width = i if not stack else n - stack[-1] - 1\n        area = nums[top] * width\n        max_area = max(max_area, area)\n\n    return max_area", "solution_func": "def g(nums=[2, 1, 5, 6, 2, 3]):\n    \"\"\"\n    Generate a list of integers for finding the maximum area of a histogram.\n    \"\"\"\n    return (nums,)", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the total number of subsets that have a sum divisible by 3.\n\n    Example:\n    nums = [1, 2, 3]\n\n    Output:\n    6\n\n    Explanation:\n    The subsets with a sum divisible by 3 are [1], [2], [1, 2], [3], [1, 3], [2, 3].\n    \"\"\"\n\n    count = 0\n\n    # Generate all possible subsets\n    for i in range(1, 2**len(nums)):\n        subset = []\n        for j in range(len(nums)):\n            if (i >> j) & 1:\n                subset.append(nums[j])\n\n        # Check if the sum of the subset is divisible by 3\n        if sum(subset) % 3 == 0:\n            count += 1\n\n    return count\n\ndef g() -> List[int]:\n    return [1, 2, 3]\n\nassert f(g()) == 6\n\n", "emb": null, "idx_generation": 396, "target_skills": [0, 0, 0, 0, 1, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the total number of subsets that have a sum divisible by 3.\n\n    Example:\n    nums = [1, 2, 3]\n\n    Output:\n    6\n\n    Explanation:\n    The subsets with a sum divisible by 3 are [1], [2], [1, 2], [3], [1, 3], [2, 3].\n    \"\"\"\n\n    count = 0\n\n    # Generate all possible subsets\n    for i in range(1, 2**len(nums)):\n        subset = []\n        for j in range(len(nums)):\n            if (i >> j) & 1:\n                subset.append(nums[j])\n\n        # Check if the sum of the subset is divisible by 3\n        if sum(subset) % 3 == 0:\n            count += 1\n\n    return count", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, determine if there is a cycle in the graph.\n\n    Example:\n    graph = [[0, 1, 0, 0],\n             [0, 0, 1, 0],\n             [0, 0, 0, 1],\n             [1, 0, 0, 0]]\n\n    Output:\n    True\n\n    Explanation:\n    The graph has a cycle: 0 -> 1 -> 2 -> 3 -> 0.\n    \"\"\"\n\n    n = len(graph)\n    visited = [False] * n\n\n    def dfs(node: int, stack: List[int]) -> bool:\n        visited[node] = True\n        stack.append(node)\n\n        for neighbor in range(n):\n            if graph[node][neighbor] == 1:\n                if neighbor in stack:\n                    return True\n                elif not visited[neighbor]:\n                    if dfs(neighbor, stack):\n                        return True\n\n        stack.pop()\n        return False\n\n    for node in range(n):\n        if not visited[node]:\n            if dfs(node, []):\n                return True\n\n    return False\n\ndef g() -> List[List[int]]:\n    return [[0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1],\n            [1, 0, 0, 0]]\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 396, "target_skills": [1, 1, 0, 1, 0, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, determine if there is a cycle in the graph.\n\n    Example:\n    graph = [[0, 1, 0, 0],\n             [0, 0, 1, 0],\n             [0, 0, 0, 1],\n             [1, 0, 0, 0]]\n\n    Output:\n    True\n\n    Explanation:\n    The graph has a cycle: 0 -> 1 -> 2 -> 3 -> 0.\n    \"\"\"\n\n    n = len(graph)\n    visited = [False] * n\n\n    def dfs(node: int, stack: List[int]) -> bool:\n        visited[node] = True\n        stack.append(node)\n\n        for neighbor in range(n):\n            if graph[node][neighbor] == 1:\n                if neighbor in stack:\n                    return True\n                elif not visited[neighbor]:\n                    if dfs(neighbor, stack):\n                        return True\n\n        stack.pop()\n        return False\n\n    for node in range(n):\n        if not visited[node]:\n            if dfs(node, []):\n                return True\n\n    return False", "solution_func": "def g() -> List[List[int]]:\n    return [[0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1],\n            [1, 0, 0, 0]]", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the count of numbers from 0 to n (inclusive) that have an even number of set bits in their binary representation.\n\n    Example:\n    n = 5\n\n    Output:\n    3\n\n    Explanation:\n    The numbers from 0 to 5 with an even number of set bits are 0 (0 in binary), 3 (11 in binary), and 5 (101 in binary).\n    \"\"\"\n\n    count = 0\n\n    for num in range(n + 1):\n        if bin(num).count('1') % 2 == 0:\n            count += 1\n\n    return count\n\ndef g() -> int:\n    return 5\n\nassert f(g()) == 3\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 396, "target_skills": [0, 1, 0, 1, 0, 1, 0, 0, 1, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the count of numbers from 0 to n (inclusive) that have an even number of set bits in their binary representation.\n\n    Example:\n    n = 5\n\n    Output:\n    3\n\n    Explanation:\n    The numbers from 0 to 5 with an even number of set bits are 0 (0 in binary), 3 (11 in binary), and 5 (101 in binary).\n    \"\"\"\n\n    count = 0\n\n    for num in range(n + 1):\n        if bin(num).count('1') % 2 == 0:\n            count += 1\n\n    return count", "solution_func": "def g() -> int:\n    return 5", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a matrix of integers and a target number, determine if the target number exists in the matrix.\n    The matrix is sorted in non-decreasing order from left to right and from top to bottom.\n\n    Sample Input:\n    matrix = [\n        [1, 4, 7, 11, 15],\n        [2, 5, 8, 12, 19],\n        [3, 6, 9, 16, 22],\n        [10, 13, 14, 17, 24],\n        [18, 21, 23, 26, 30]\n    ]\n    target = 5\n\n    Sample Output:\n    True (5 is present in the matrix)\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return False\n\n    rows, cols = len(matrix), len(matrix[0])\n    row, col = 0, cols - 1\n\n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n\n    return False\n\ndef g():\n    matrix = [\n        [1, 4, 7, 11, 15],\n        [2, 5, 8, 12, 19],\n        [3, 6, 9, 16, 22],\n        [10, 13, 14, 17, 24],\n        [18, 21, 23, 26, 30]\n    ]\n    target = 5\n    return matrix, target\n\nassert f(*g()) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 396, "target_skills": [1, 1, 0, 0, 0, 1, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a matrix of integers and a target number, determine if the target number exists in the matrix.\n    The matrix is sorted in non-decreasing order from left to right and from top to bottom.\n\n    Sample Input:\n    matrix = [\n        [1, 4, 7, 11, 15],\n        [2, 5, 8, 12, 19],\n        [3, 6, 9, 16, 22],\n        [10, 13, 14, 17, 24],\n        [18, 21, 23, 26, 30]\n    ]\n    target = 5\n\n    Sample Output:\n    True (5 is present in the matrix)\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return False\n\n    rows, cols = len(matrix), len(matrix[0])\n    row, col = 0, cols - 1\n\n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n\n    return False", "solution_func": "def g():\n    matrix = [\n        [1, 4, 7, 11, 15],\n        [2, 5, 8, 12, 19],\n        [3, 6, 9, 16, 22],\n        [10, 13, 14, 17, 24],\n        [18, 21, 23, 26, 30]\n    ]\n    target = 5\n    return matrix, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum product of any three numbers from the list.\n\n    Return the maximum product.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    24\n\n    Explanation:\n    The maximum product can be obtained by multiplying 2, 3, and 4 (2 * 3 * 4 = 24).\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n\n    return max(nums[0] * nums[1] * nums[n - 1], nums[n - 3] * nums[n - 2] * nums[n - 1])\n\ndef g(nums=[1, 2, 3, 4]):\n    \"\"\"\n    Generate a list of integers 'nums'.\n    \"\"\"\n    return nums\n\nassert f(g()) == 24\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 397, "target_skills": [1, 0, 1, 1, 1, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum product of any three numbers from the list.\n\n    Return the maximum product.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    24\n\n    Explanation:\n    The maximum product can be obtained by multiplying 2, 3, and 4 (2 * 3 * 4 = 24).\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n\n    return max(nums[0] * nums[1] * nums[n - 1], nums[n - 3] * nums[n - 2] * nums[n - 1])", "solution_func": "def g(nums=[1, 2, 3, 4]):\n    \"\"\"\n    Generate a list of integers 'nums'.\n    \"\"\"\n    return nums", "map_ix": [1, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers 'grid', find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Return the maximum sum.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The maximum sum can be obtained by following the path 1 -> 3 -> 1 -> 1 -> 1 (1 + 3 + 1 + 1 + 1 = 7).\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[m - 1][n - 1]\n\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    \"\"\"\n    Generate a grid of integers 'grid'.\n    \"\"\"\n    return grid\n\nassert f(g()) == 7\n", "emb": null, "idx_generation": 397, "target_skills": [0, 0, 1, 1, 0, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers 'grid', find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Return the maximum sum.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The maximum sum can be obtained by following the path 1 -> 3 -> 1 -> 1 -> 1 (1 + 3 + 1 + 1 + 1 = 7).\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[m - 1][n - 1]", "solution_func": "def g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    \"\"\"\n    Generate a grid of integers 'grid'.\n    \"\"\"\n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum difference between two consecutive elements in sorted order.\n\n    Return the maximum difference.\n\n    Example:\n    nums = [3, 8, 1, 2, 5]\n\n    Output:\n    5\n\n    Explanation:\n    The maximum difference can be obtained by sorting the list in ascending order: [1, 2, 3, 5, 8].\n    The maximum difference between consecutive elements is 5 (3 - 2 = 1, 8 - 5 = 3).\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n\n    max_diff = 0\n\n    for i in range(1, n):\n        diff = nums[i] - nums[i - 1]\n        max_diff = max(max_diff, diff)\n\n    return max_diff\n\ndef g(nums=[3, 8, 1, 2, 5]):\n    \"\"\"\n    Generate a list of integers 'nums'.\n    \"\"\"\n    return nums\n\nassert f(g()) == 5\n", "emb": null, "idx_generation": 397, "target_skills": [0, 0, 1, 1, 0, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum difference between two consecutive elements in sorted order.\n\n    Return the maximum difference.\n\n    Example:\n    nums = [3, 8, 1, 2, 5]\n\n    Output:\n    5\n\n    Explanation:\n    The maximum difference can be obtained by sorting the list in ascending order: [1, 2, 3, 5, 8].\n    The maximum difference between consecutive elements is 5 (3 - 2 = 1, 8 - 5 = 3).\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n\n    max_diff = 0\n\n    for i in range(1, n):\n        diff = nums[i] - nums[i - 1]\n        max_diff = max(max_diff, diff)\n\n    return max_diff", "solution_func": "def g(nums=[3, 8, 1, 2, 5]):\n    \"\"\"\n    Generate a list of integers 'nums'.\n    \"\"\"\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers, check if the array contains a Pythagorean triplet.\n\n    A Pythagorean triplet is a set of three integers (a, b, c) such that a^2 + b^2 = c^2.\n\n    Example:\n    Input: [3, 1, 4, 6, 5]\n    Output: True\n    Explanation: The array contains a Pythagorean triplet (3, 4, 5), where 3^2 + 4^2 = 5^2.\n\n    \"\"\"\n    # Create a set to store the squares of all elements in the array\n    squares = set([x**2 for x in arr])\n\n    # Iterate through all pairs of elements in the array\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            # Check if the sum of squares of the two elements is in the set\n            if arr[i]**2 + arr[j]**2 in squares:\n                return True\n\n    return False\n\ndef g():\n    return [3, 1, 4, 6, 5]\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 397, "target_skills": [0, 0, 0, 1, 0, 0, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers, check if the array contains a Pythagorean triplet.\n\n    A Pythagorean triplet is a set of three integers (a, b, c) such that a^2 + b^2 = c^2.\n\n    Example:\n    Input: [3, 1, 4, 6, 5]\n    Output: True\n    Explanation: The array contains a Pythagorean triplet (3, 4, 5), where 3^2 + 4^2 = 5^2.\n\n    \"\"\"\n    # Create a set to store the squares of all elements in the array\n    squares = set([x**2 for x in arr])\n\n    # Iterate through all pairs of elements in the array\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            # Check if the sum of squares of the two elements is in the set\n            if arr[i]**2 + arr[j]**2 in squares:\n                return True\n\n    return False", "solution_func": "def g():\n    return [3, 1, 4, 6, 5]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum sum of a subarray.\n\n    Example:\n    Input: [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n    Explanation: The subarray [4, -1, 2, 1] has the maximum sum of 6.\n\n    \"\"\"\n    if len(arr) == 0:\n        return 0\n\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in arr:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 397, "target_skills": [1, 0, 1, 1, 1, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum sum of a subarray.\n\n    Example:\n    Input: [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n    Explanation: The subarray [4, -1, 2, 1] has the maximum sum of 6.\n\n    \"\"\"\n    if len(arr) == 0:\n        return 0\n\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in arr:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum", "solution_func": "def g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a path starting from the top-left corner and ending at the bottom-right corner.\n\n    The path can only move down or right.\n\n    Example:\n    Input: [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    Output: 7\n    Explanation: The maximum sum path is 1 -> 3 -> 1 -> 1 -> 1, which has a sum of 7.\n\n    \"\"\"\n    if len(matrix) == 0 or len(matrix[0]) == 0:\n        return 0\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    # Create a 2D array to store the maximum sum of paths\n    max_sum = [[0] * cols for _ in range(rows)]\n\n    # Initialize the first row and column of the max_sum array\n    max_sum[0][0] = matrix[0][0]\n    for i in range(1, rows):\n        max_sum[i][0] = max_sum[i-1][0] + matrix[i][0]\n    for j in range(1, cols):\n        max_sum[0][j] = max_sum[0][j-1] + matrix[0][j]\n\n    # Calculate the maximum sum of paths for each cell in the matrix\n    for i in range(1, rows):\n        for j in range(1, cols):\n            max_sum[i][j] = max(max_sum[i-1][j], max_sum[i][j-1]) + matrix[i][j]\n\n    return max_sum[rows-1][cols-1]\n\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 7\n", "emb": null, "idx_generation": 397, "target_skills": [0, 1, 0, 1, 0, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a path starting from the top-left corner and ending at the bottom-right corner.\n\n    The path can only move down or right.\n\n    Example:\n    Input: [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    Output: 7\n    Explanation: The maximum sum path is 1 -> 3 -> 1 -> 1 -> 1, which has a sum of 7.\n\n    \"\"\"\n    if len(matrix) == 0 or len(matrix[0]) == 0:\n        return 0\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    # Create a 2D array to store the maximum sum of paths\n    max_sum = [[0] * cols for _ in range(rows)]\n\n    # Initialize the first row and column of the max_sum array\n    max_sum[0][0] = matrix[0][0]\n    for i in range(1, rows):\n        max_sum[i][0] = max_sum[i-1][0] + matrix[i][0]\n    for j in range(1, cols):\n        max_sum[0][j] = max_sum[0][j-1] + matrix[0][j]\n\n    # Calculate the maximum sum of paths for each cell in the matrix\n    for i in range(1, rows):\n        for j in range(1, cols):\n            max_sum[i][j] = max(max_sum[i-1][j], max_sum[i][j-1]) + matrix[i][j]\n\n    return max_sum[rows-1][cols-1]", "solution_func": "def g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\nclass Node:\n    def __init__(self, val: int):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef f(root: Node, target: int) -> List[int]:\n    \"\"\"\n    Given a binary tree and a target value, find all root-to-leaf paths where each path's sum equals the given target.\n\n    Example:\n    root = Node(5)\n    root.left = Node(4)\n    root.right = Node(8)\n    root.left.left = Node(11)\n    root.left.left.left = Node(7)\n    root.left.left.right = Node(2)\n    root.right.left = Node(13)\n    root.right.right = Node(4)\n    root.right.right.left = Node(5)\n    root.right.right.right = Node(1)\n    target = 22\n\n    Output:\n    [[5, 4, 11, 2], [5, 8, 4, 5]]\n    \"\"\"\n    result = []\n\n    def dfs(node: Node, path: List[int], path_sum: int):\n        if not node:\n            return\n\n        path.append(node.val)\n        path_sum += node.val\n\n        if not node.left and not node.right:\n            if path_sum == target:\n                result.append(path[:])\n\n        dfs(node.left, path, path_sum)\n        dfs(node.right, path, path_sum)\n\n        path.pop()\n        path_sum -= node.val\n\n    dfs(root, [], 0)\n    return result\n\ndef g() -> Node:\n    root = Node(5)\n    root.left = Node(4)\n    root.right = Node(8)\n    root.left.left = Node(11)\n    root.left.left.left = Node(7)\n    root.left.left.right = Node(2)\n    root.right.left = Node(13)\n    root.right.right = Node(4)\n    root.right.right.left = Node(5)\n    root.right.right.right = Node(1)\n    return root, 22\n\nassert f(*g()) == [[5, 4, 11, 2], [5, 8, 4, 5]]\n", "emb": [1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 397, "target_skills": [0, 0, 0, 1, 1, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\nclass Node:\n    def __init__(self, val: int):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef f(root: Node, target: int) -> List[int]:\n    \"\"\"\n    Given a binary tree and a target value, find all root-to-leaf paths where each path's sum equals the given target.\n\n    Example:\n    root = Node(5)\n    root.left = Node(4)\n    root.right = Node(8)\n    root.left.left = Node(11)\n    root.left.left.left = Node(7)\n    root.left.left.right = Node(2)\n    root.right.left = Node(13)\n    root.right.right = Node(4)\n    root.right.right.left = Node(5)\n    root.right.right.right = Node(1)\n    target = 22\n\n    Output:\n    [[5, 4, 11, 2], [5, 8, 4, 5]]\n    \"\"\"\n    result = []\n\n    def dfs(node: Node, path: List[int], path_sum: int):\n        if not node:\n            return\n\n        path.append(node.val)\n        path_sum += node.val\n\n        if not node.left and not node.right:\n            if path_sum == target:\n                result.append(path[:])\n\n        dfs(node.left, path, path_sum)\n        dfs(node.right, path, path_sum)\n\n        path.pop()\n        path_sum -= node.val\n\n    dfs(root, [], 0)\n    return result", "solution_func": "def g() -> Node:\n    root = Node(5)\n    root.left = Node(4)\n    root.right = Node(8)\n    root.left.left = Node(11)\n    root.left.left.left = Node(7)\n    root.left.left.right = Node(2)\n    root.right.left = Node(13)\n    root.right.right = Node(4)\n    root.right.right.left = Node(5)\n    root.right.right.right = Node(1)\n    return root, 22", "map_ix": [1, 1, 1, 1, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the length of the longest increasing path.\n\n    Example:\n    grid = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n\n    Output:\n    4\n\n    Explanation:\n    The longest increasing path is [1, 2, 6, 9].\n    \"\"\"\n    if not grid:\n        return 0\n\n    rows = len(grid)\n    cols = len(grid[0])\n    memo = [[0] * cols for _ in range(rows)]\n\n    def dfs(row: int, col: int) -> int:\n        if memo[row][col]:\n            return memo[row][col]\n\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        max_length = 1\n\n        for dx, dy in directions:\n            new_row, new_col = row + dx, col + dy\n\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] > grid[row][col]:\n                max_length = max(max_length, 1 + dfs(new_row, new_col))\n\n        memo[row][col] = max_length\n        return max_length\n\n    max_path = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            max_path = max(max_path, dfs(i, j))\n\n    return max_path\n\ndef g() -> List[List[int]]:\n    return [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 397, "target_skills": [1, 0, 1, 1, 0, 1, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the length of the longest increasing path.\n\n    Example:\n    grid = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n\n    Output:\n    4\n\n    Explanation:\n    The longest increasing path is [1, 2, 6, 9].\n    \"\"\"\n    if not grid:\n        return 0\n\n    rows = len(grid)\n    cols = len(grid[0])\n    memo = [[0] * cols for _ in range(rows)]\n\n    def dfs(row: int, col: int) -> int:\n        if memo[row][col]:\n            return memo[row][col]\n\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        max_length = 1\n\n        for dx, dy in directions:\n            new_row, new_col = row + dx, col + dy\n\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] > grid[row][col]:\n                max_length = max(max_length, 1 + dfs(new_row, new_col))\n\n        memo[row][col] = max_length\n        return max_length\n\n    max_path = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            max_path = max(max_path, dfs(i, j))\n\n    return max_path", "solution_func": "def g() -> List[List[int]]:\n    return [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum path sum from the top left to the bottom right, moving only right and down.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum path sum is 1 + 3 + 1 + 1 + 1 = 7.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    for i in range(1, rows):\n        grid[i][0] += grid[i-1][0]\n\n    for j in range(1, cols):\n        grid[0][j] += grid[0][j-1]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            grid[i][j] += min(grid[i-1][j], grid[i][j-1])\n\n    return grid[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 397, "target_skills": [0, 0, 1, 1, 0, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum path sum from the top left to the bottom right, moving only right and down.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum path sum is 1 + 3 + 1 + 1 + 1 = 7.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    for i in range(1, rows):\n        grid[i][0] += grid[i-1][0]\n\n    for j in range(1, cols):\n        grid[0][j] += grid[0][j-1]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            grid[i][j] += min(grid[i-1][j], grid[i][j-1])\n\n    return grid[rows-1][cols-1]", "solution_func": "def g() -> List[List[int]]:\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]", "map_ix": [0, 0, 0, 1, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Args:\n    - nums: A list of integers\n\n    Returns:\n    - The maximum product of any three numbers in the list\n\n    Example:\n    nums = [1, 2, 3, 4]\n    The maximum product of any three numbers is 2 * 3 * 4 = 24, so the output should be 24.\n    \"\"\"\n\n    nums.sort()\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\n\ndef g():\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == 24\n\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 397, "target_skills": [0, 0, 1, 0, 1, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Args:\n    - nums: A list of integers\n\n    Returns:\n    - The maximum product of any three numbers in the list\n\n    Example:\n    nums = [1, 2, 3, 4]\n    The maximum product of any three numbers is 2 * 3 * 4 = 24, so the output should be 24.\n    \"\"\"\n\n    nums.sort()\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])", "solution_func": "def g():\n    nums = [1, 2, 3, 4]\n    return nums", "map_ix": [1, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "import math\nfrom typing import*\nfrom typing import List, Tuple\n\ndef f(words: List[str], target: str) -> Tuple[str, List[str]]:\n    \"\"\"\n    Given a list of words and a target word, find the word in the list that is closest to the target word based on\n    mathematical distance. The mathematical distance between two words is calculated as the sum of the absolute\n    differences between the ASCII values of their corresponding characters.\n\n    Args:\n    - words: A list of strings, the words to search through.\n    - target: A string, the target word to find the closest word to.\n\n    Returns:\n    - A tuple containing the closest word and a list of all words that have the same distance to the target word.\n    \"\"\"\n    closest_word = \"\"\n    closest_distance = float('inf')\n    same_distance_words = []\n\n    for word in words:\n        distance = sum(abs(ord(c1) - ord(c2)) for c1, c2 in zip(word, target))\n        \n        if distance < closest_distance:\n            closest_word = word\n            closest_distance = distance\n            same_distance_words = [word]\n        elif distance == closest_distance:\n            same_distance_words.append(word)\n\n    return closest_word, same_distance_words\n\ndef g() -> Tuple[List[str], str]:\n    words = [\"apple\", \"banana\", \"cherry\", \"durian\"]\n    target = \"berry\"\n    return words, target\n\nassert f(*g()) == (\"cherry\", [\"cherry\"])\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 398, "target_skills": [0, 0, 1, 1, 1, 0, 1, 0, 1, 1], "problem_func": "import math\nfrom typing import*\nfrom typing import List, Tuple\n\ndef f(words: List[str], target: str) -> Tuple[str, List[str]]:\n    \"\"\"\n    Given a list of words and a target word, find the word in the list that is closest to the target word based on\n    mathematical distance. The mathematical distance between two words is calculated as the sum of the absolute\n    differences between the ASCII values of their corresponding characters.\n\n    Args:\n    - words: A list of strings, the words to search through.\n    - target: A string, the target word to find the closest word to.\n\n    Returns:\n    - A tuple containing the closest word and a list of all words that have the same distance to the target word.\n    \"\"\"\n    closest_word = \"\"\n    closest_distance = float('inf')\n    same_distance_words = []\n\n    for word in words:\n        distance = sum(abs(ord(c1) - ord(c2)) for c1, c2 in zip(word, target))\n        \n        if distance < closest_distance:\n            closest_word = word\n            closest_distance = distance\n            same_distance_words = [word]\n        elif distance == closest_distance:\n            same_distance_words.append(word)\n\n    return closest_word, same_distance_words", "solution_func": "def g() -> Tuple[List[str], str]:\n    words = [\"apple\", \"banana\", \"cherry\", \"durian\"]\n    target = \"berry\"\n    return words, target", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Given a grid of 0s and 1s, where 0 represents an empty cell and 1 represents an obstacle, find the shortest path\n    from the top-left corner to the bottom-right corner, avoiding obstacles. The path can only move right or down.\n\n    Args:\n    - grid: A list of lists of integers, representing the grid.\n\n    Returns:\n    - A tuple containing the minimum number of steps required to reach the destination and the number of obstacles\n    encountered along the path.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[-1][-1], sum(grid[i][j] for i in range(m) for j in range(n) if dp[i][j] < float('inf'))\n\ndef g() -> List[List[int]]:\n    grid = [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [0, 0, 0, 1],\n        [0, 1, 0, 0]\n    ]\n    return grid\n\nassert f(g()) == (4, 3)\n", "emb": null, "idx_generation": 398, "target_skills": [1, 0, 0, 0, 1, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Given a grid of 0s and 1s, where 0 represents an empty cell and 1 represents an obstacle, find the shortest path\n    from the top-left corner to the bottom-right corner, avoiding obstacles. The path can only move right or down.\n\n    Args:\n    - grid: A list of lists of integers, representing the grid.\n\n    Returns:\n    - A tuple containing the minimum number of steps required to reach the destination and the number of obstacles\n    encountered along the path.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[-1][-1], sum(grid[i][j] for i in range(m) for j in range(n) if dp[i][j] < float('inf'))", "solution_func": "def g() -> List[List[int]]:\n    grid = [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [0, 0, 0, 1],\n        [0, 1, 0, 0]\n    ]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(prices: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of stock prices and the maximum number of transactions allowed, find the maximum profit that can be\n    obtained by buying and selling stocks. Each transaction consists of buying at the start of the day and selling at\n    the end of the day.\n\n    Args:\n    - prices: A list of integers, representing the stock prices.\n    - k: An integer, the maximum number of transactions allowed.\n\n    Returns:\n    - An integer, the maximum profit that can be obtained.\n    \"\"\"\n    n = len(prices)\n    \n    if k >= n // 2:\n        return sum(max(prices[i+1] - prices[i], 0) for i in range(n-1))\n    \n    dp = [[0] * n for _ in range(k+1)]\n    \n    for i in range(1, k+1):\n        max_diff = -prices[0]\n        \n        for j in range(1, n):\n            dp[i][j] = max(dp[i][j-1], prices[j] + max_diff)\n            max_diff = max(max_diff, dp[i-1][j] - prices[j])\n    \n    return dp[k][-1]\n\ndef g() -> Tuple[List[int], int]:\n    prices = [3, 2, 6, 5, 0, 3]\n    k = 2\n    return prices, k\n\nassert f(*g()) == 7\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 398, "target_skills": [0, 1, 1, 0, 0, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(prices: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of stock prices and the maximum number of transactions allowed, find the maximum profit that can be\n    obtained by buying and selling stocks. Each transaction consists of buying at the start of the day and selling at\n    the end of the day.\n\n    Args:\n    - prices: A list of integers, representing the stock prices.\n    - k: An integer, the maximum number of transactions allowed.\n\n    Returns:\n    - An integer, the maximum profit that can be obtained.\n    \"\"\"\n    n = len(prices)\n    \n    if k >= n // 2:\n        return sum(max(prices[i+1] - prices[i], 0) for i in range(n-1))\n    \n    dp = [[0] * n for _ in range(k+1)]\n    \n    for i in range(1, k+1):\n        max_diff = -prices[0]\n        \n        for j in range(1, n):\n            dp[i][j] = max(dp[i][j-1], prices[j] + max_diff)\n            max_diff = max(max_diff, dp[i-1][j] - prices[j])\n    \n    return dp[k][-1]", "solution_func": "def g() -> Tuple[List[int], int]:\n    prices = [3, 2, 6, 5, 0, 3]\n    k = 2\n    return prices, k", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers, sort the array in ascending order using the bubble sort algorithm.\n    Return the sorted array.\n    \"\"\"\n\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    \n    return nums\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for the puzzle.\n    \"\"\"\n    nums = [5, 2, 8, 12, 1, 7]\n    return nums\n\nassert f(g()) == [1, 2, 5, 7, 8, 12]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 398, "target_skills": [0, 0, 0, 0, 1, 0, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers, sort the array in ascending order using the bubble sort algorithm.\n    Return the sorted array.\n    \"\"\"\n\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    \n    return nums", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for the puzzle.\n    \"\"\"\n    nums = [5, 2, 8, 12, 1, 7]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: int, target: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of bits required to represent n in binary form.\n    Return the number of bits.\n    \"\"\"\n\n    count = 0\n    while n:\n        count += 1\n        n >>= 1\n    \n    return count\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer for the puzzle.\n    \"\"\"\n    n = 27\n    return n\n\nassert f(g()) == 5\n", "emb": null, "idx_generation": 398, "target_skills": [0, 0, 0, 1, 1, 0, 0, 0, 1, 1], "problem_func": "from typing import*\ndef f(nums: int, target: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of bits required to represent n in binary form.\n    Return the number of bits.\n    \"\"\"\n\n    count = 0\n    while n:\n        count += 1\n        n >>= 1\n    \n    return count", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a positive integer for the puzzle.\n    \"\"\"\n    n = 27\n    return n", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the largest sum of a path from the top-left cell to the bottom-right cell.\n    A path can only move down or right.\n    Return the largest sum.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 7\n\n    Explanation:\n    The path with the largest sum is 1 -> 3 -> 1 -> 1 -> 1, with a sum of 7.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Calculate the cumulative sum for the first row\n    for j in range(1, cols):\n        grid[0][j] += grid[0][j-1]\n\n    # Calculate the cumulative sum for the first column\n    for i in range(1, rows):\n        grid[i][0] += grid[i-1][0]\n\n    # Calculate the cumulative sum for the remaining cells\n    for i in range(1, rows):\n        for j in range(1, cols):\n            grid[i][j] += max(grid[i-1][j], grid[i][j-1])\n\n    return grid[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers for the puzzle.\n    \"\"\"\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n", "emb": null, "idx_generation": 398, "target_skills": [1, 0, 1, 0, 1, 0, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the largest sum of a path from the top-left cell to the bottom-right cell.\n    A path can only move down or right.\n    Return the largest sum.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 7\n\n    Explanation:\n    The path with the largest sum is 1 -> 3 -> 1 -> 1 -> 1, with a sum of 7.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Calculate the cumulative sum for the first row\n    for j in range(1, cols):\n        grid[0][j] += grid[0][j-1]\n\n    # Calculate the cumulative sum for the first column\n    for i in range(1, rows):\n        grid[i][0] += grid[i-1][0]\n\n    # Calculate the cumulative sum for the remaining cells\n    for i in range(1, rows):\n        for j in range(1, cols):\n            grid[i][j] += max(grid[i-1][j], grid[i][j-1])\n\n    return grid[rows-1][cols-1]", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers for the puzzle.\n    \"\"\"\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list containing only the words that are anagrams of each other.\n\n    Example:\n    words = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n\n    Output:\n    [\"eat\", \"tea\", \"ate\"]\n    \"\"\"\n    anagrams = []\n    word_dict = {}\n    for word in words:\n        sorted_word = \"\".join(sorted(word))\n        if sorted_word in word_dict:\n            word_dict[sorted_word].append(word)\n        else:\n            word_dict[sorted_word] = [word]\n    \n    for key in word_dict:\n        if len(word_dict[key]) > 1:\n            anagrams.extend(word_dict[key])\n    \n    return anagrams\n\ndef g():\n    words = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n    return words\n\nassert f(*g()) == [\"eat\", \"tea\", \"ate\"]\n\n", "emb": null, "idx_generation": 398, "target_skills": [0, 0, 1, 0, 1, 1, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list containing only the words that are anagrams of each other.\n\n    Example:\n    words = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n\n    Output:\n    [\"eat\", \"tea\", \"ate\"]\n    \"\"\"\n    anagrams = []\n    word_dict = {}\n    for word in words:\n        sorted_word = \"\".join(sorted(word))\n        if sorted_word in word_dict:\n            word_dict[sorted_word].append(word)\n        else:\n            word_dict[sorted_word] = [word]\n    \n    for key in word_dict:\n        if len(word_dict[key]) > 1:\n            anagrams.extend(word_dict[key])\n    \n    return anagrams", "solution_func": "def g():\n    words = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n    return words", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum path sum from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7 (since the minimum path is 1 -> 3 -> 1 -> 1 -> 1)\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[rows-1][cols-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(*g()) == 7\n\n", "emb": null, "idx_generation": 398, "target_skills": [1, 1, 0, 0, 0, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum path sum from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7 (since the minimum path is 1 -> 3 -> 1 -> 1 -> 1)\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[rows-1][cols-1]", "solution_func": "def g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string, find the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n\n    Output:\n    3 (since the longest substring without repeating characters is \"abc\")\n    \"\"\"\n    max_length = 0\n    start = 0\n    char_dict = {}\n    \n    for end in range(len(s)):\n        if s[end] in char_dict:\n            start = max(start, char_dict[s[end]] + 1)\n        \n        char_dict[s[end]] = end\n        max_length = max(max_length, end - start + 1)\n    \n    return max_length\n\ndef g():\n    s = \"abcabcbb\"\n    return s\n\nassert f(*g()) == 3\n\n", "emb": null, "idx_generation": 398, "target_skills": [0, 1, 1, 1, 1, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string, find the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n\n    Output:\n    3 (since the longest substring without repeating characters is \"abc\")\n    \"\"\"\n    max_length = 0\n    start = 0\n    char_dict = {}\n    \n    for end in range(len(s)):\n        if s[end] in char_dict:\n            start = max(start, char_dict[s[end]] + 1)\n        \n        char_dict[s[end]] = end\n        max_length = max(max_length, end - start + 1)\n    \n    return max_length", "solution_func": "def g():\n    s = \"abcabcbb\"\n    return s", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a power of 2.\n\n    Sample Input:\n    n = 16\n\n    Sample Output:\n    True\n    \"\"\"\n    if n <= 0:\n        return False\n    if n == 1:\n        return True\n    if n % 2 == 1:\n        return False\n    return f(n // 2)\n\ndef g():\n    return [16]\n\nassert f(*g())\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 398, "target_skills": [0, 1, 1, 1, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a power of 2.\n\n    Sample Input:\n    n = 16\n\n    Sample Output:\n    True\n    \"\"\"\n    if n <= 0:\n        return False\n    if n == 1:\n        return True\n    if n % 2 == 1:\n        return False\n    return f(n // 2)", "solution_func": "def g():\n    return [16]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the position of the target value in the list using binary search.\n\n    Return the index of the target value if it exists in the list, otherwise return -1.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 6\n\n    Output:\n    5\n\n    Explanation:\n    The target value 6 is located at index 5 in the list.\n    \"\"\"\n    def binary_search(nums, target, low, high):\n        if low <= high:\n            mid = (low + high) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                return binary_search(nums, target, mid+1, high)\n            else:\n                return binary_search(nums, target, low, mid-1)\n        else:\n            return -1\n    \n    return binary_search(nums, target, 0, len(nums)-1)\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9], 6\n\nassert f(*g()) == 5\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 399, "target_skills": [1, 1, 1, 0, 1, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the position of the target value in the list using binary search.\n\n    Return the index of the target value if it exists in the list, otherwise return -1.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 6\n\n    Output:\n    5\n\n    Explanation:\n    The target value 6 is located at index 5 in the list.\n    \"\"\"\n    def binary_search(nums, target, low, high):\n        if low <= high:\n            mid = (low + high) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                return binary_search(nums, target, mid+1, high)\n            else:\n                return binary_search(nums, target, low, mid-1)\n        else:\n            return -1\n    \n    return binary_search(nums, target, 0, len(nums)-1)", "solution_func": "def g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9], 6", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of unique binary search trees that can be formed using the integers from 1 to n.\n\n    Return the total number of unique BSTs.\n\n    Example:\n    n = 3\n\n    Output:\n    5\n\n    Explanation:\n    The integers from 1 to 3 can form the following unique BSTs:\n    -   1       3     3      2      1\n        \\       /     /      / \\      \\\n         3     2     1      1   3      2\n        /     /       \\                 \\\n       2     1         2                 3\n    \"\"\"\n    def count_bsts(n):\n        if n <= 1:\n            return 1\n        else:\n            count = 0\n            for i in range(1, n+1):\n                count += count_bsts(i-1) * count_bsts(n-i)\n            return count\n    \n    return count_bsts(n)\n\ndef g():\n    return 3\n\nassert f(g()) == 5\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 399, "target_skills": [0, 0, 1, 0, 0, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of unique binary search trees that can be formed using the integers from 1 to n.\n\n    Return the total number of unique BSTs.\n\n    Example:\n    n = 3\n\n    Output:\n    5\n\n    Explanation:\n    The integers from 1 to 3 can form the following unique BSTs:\n    -   1       3     3      2      1\n        \\       /     /      / \\      \\\n         3     2     1      1   3      2\n        /     /       \\                 \\\n       2     1         2                 3\n    \"\"\"\n    def count_bsts(n):\n        if n <= 1:\n            return 1\n        else:\n            count = 0\n            for i in range(1, n+1):\n                count += count_bsts(i-1) * count_bsts(n-i)\n            return count\n    \n    return count_bsts(n)", "solution_func": "def g():\n    return 3", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, find the longest increasing path.\n\n    Return a list of coordinates representing the longest increasing path.\n\n    Example:\n    matrix = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n\n    Output:\n    [(0, 0), (1, 0), (1, 1), (2, 1), (2, 2)]\n\n    Explanation:\n    The longest increasing path in the matrix is [9, 6, 1, 2, 4, 8] with coordinates [(0, 0), (1, 0), (1, 1), (2, 1), (2, 2)].\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    def dfs(i, j, matrix, dp):\n        if dp[i][j] != 0:\n            return dp[i][j]\n        \n        max_path = 0\n        for direction in directions:\n            x = i + direction[0]\n            y = j + direction[1]\n            \n            if x >= 0 and x < rows and y >= 0 and y < cols and matrix[x][y] > matrix[i][j]:\n                max_path = max(max_path, dfs(x, y, matrix, dp))\n        \n        dp[i][j] = max_path + 1\n        return dp[i][j]\n    \n    dp = [[0] * cols for _ in range(rows)]\n    longest_path = []\n    \n    for i in range(rows):\n        for j in range(cols):\n            path_length = dfs(i, j, matrix, dp)\n            \n            if path_length > len(longest_path):\n                longest_path = []\n                \n                for k in range(path_length):\n                    longest_path.append((i, j))\n                    \n    return longest_path\n\ndef g():\n    return [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n\nassert f(g()) == [(0, 0), (1, 0), (1, 1), (2, 1), (2, 2)]\n\n", "emb": null, "idx_generation": 399, "target_skills": [1, 1, 0, 0, 0, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, find the longest increasing path.\n\n    Return a list of coordinates representing the longest increasing path.\n\n    Example:\n    matrix = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n\n    Output:\n    [(0, 0), (1, 0), (1, 1), (2, 1), (2, 2)]\n\n    Explanation:\n    The longest increasing path in the matrix is [9, 6, 1, 2, 4, 8] with coordinates [(0, 0), (1, 0), (1, 1), (2, 1), (2, 2)].\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    def dfs(i, j, matrix, dp):\n        if dp[i][j] != 0:\n            return dp[i][j]\n        \n        max_path = 0\n        for direction in directions:\n            x = i + direction[0]\n            y = j + direction[1]\n            \n            if x >= 0 and x < rows and y >= 0 and y < cols and matrix[x][y] > matrix[i][j]:\n                max_path = max(max_path, dfs(x, y, matrix, dp))\n        \n        dp[i][j] = max_path + 1\n        return dp[i][j]\n    \n    dp = [[0] * cols for _ in range(rows)]\n    longest_path = []\n    \n    for i in range(rows):\n        for j in range(cols):\n            path_length = dfs(i, j, matrix, dp)\n            \n            if path_length > len(longest_path):\n                longest_path = []\n                \n                for k in range(path_length):\n                    longest_path.append((i, j))\n                    \n    return longest_path", "solution_func": "def g():\n    return [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> List[int]:\n    \"\"\"\n    Given the root of a binary tree, return the inorder traversal of its nodes' values.\n\n    Example:\n    Input: [1,null,2,3]\n       1\n        \\\n         2\n        /\n       3\n\n    Output: [1,3,2]\n    \"\"\"\n    stack = []\n    inorder = []\n\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        inorder.append(root.val)\n        root = root.right\n\n    return inorder\n\ndef g():\n    root = TreeNode(1)\n    root.right = TreeNode(2)\n    root.right.left = TreeNode(3)\n    return root\n\nassert f(g()) == [1, 3, 2]\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 399, "target_skills": [1, 0, 0, 1, 1, 1, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> List[int]:\n    \"\"\"\n    Given the root of a binary tree, return the inorder traversal of its nodes' values.\n\n    Example:\n    Input: [1,null,2,3]\n       1\n        \\\n         2\n        /\n       3\n\n    Output: [1,3,2]\n    \"\"\"\n    stack = []\n    inorder = []\n\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        inorder.append(root.val)\n        root = root.right\n\n    return inorder", "solution_func": "def g():\n    root = TreeNode(1)\n    root.right = TreeNode(2)\n    root.right.left = TreeNode(3)\n    return root", "map_ix": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.\n\n    Example:\n    Input: \"Let's solve some puzzles\"\n    Output: \"s'teL elvos emos selzzup\"\n    \"\"\"\n    words = s.split()\n    reversed_words = []\n\n    for word in words:\n        reversed_words.append(word[::-1])\n\n    return ' '.join(reversed_words)\n\ndef g():\n    return \"Let's solve some puzzles\"\n\nassert f(g()) == \"s'teL elvos emos selzzup\"\n", "emb": null, "idx_generation": 399, "target_skills": [0, 1, 0, 0, 1, 1, 0, 1, 1, 0], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.\n\n    Example:\n    Input: \"Let's solve some puzzles\"\n    Output: \"s'teL elvos emos selzzup\"\n    \"\"\"\n    words = s.split()\n    reversed_words = []\n\n    for word in words:\n        reversed_words.append(word[::-1])\n\n    return ' '.join(reversed_words)", "solution_func": "def g():\n    return \"Let's solve some puzzles\"", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the length of the longest increasing path.\n\n    Example:\n    Input: [[9,9,4],[6,6,8],[2,1,1]]\n    Output: 4\n    Explanation: The longest increasing path is [1, 2, 6, 9].\n\n    Note:\n    - The path can start at any position, but it must follow the increasing order of adjacent cells.\n    - You can move up, down, left, or right from a cell to another adjacent one with a smaller or equal value.\n    \"\"\"\n    if not grid:\n        return 0\n\n    rows, cols = len(grid), len(grid[0])\n    longest_path = 0\n    memo = [[0] * cols for _ in range(rows)]\n\n    def dfs(row, col):\n        if memo[row][col]:\n            return memo[row][col]\n\n        path = 1\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        for dx, dy in directions:\n            new_row, new_col = row + dx, col + dy\n\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] > grid[row][col]:\n                path = max(path, dfs(new_row, new_col) + 1)\n\n        memo[row][col] = path\n        return path\n\n    for i in range(rows):\n        for j in range(cols):\n            longest_path = max(longest_path, dfs(i, j))\n\n    return longest_path\n\ndef g():\n    return [[9, 9, 4], [6, 6, 8], [2, 1, 1]]\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 399, "target_skills": [0, 0, 0, 1, 0, 0, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the length of the longest increasing path.\n\n    Example:\n    Input: [[9,9,4],[6,6,8],[2,1,1]]\n    Output: 4\n    Explanation: The longest increasing path is [1, 2, 6, 9].\n\n    Note:\n    - The path can start at any position, but it must follow the increasing order of adjacent cells.\n    - You can move up, down, left, or right from a cell to another adjacent one with a smaller or equal value.\n    \"\"\"\n    if not grid:\n        return 0\n\n    rows, cols = len(grid), len(grid[0])\n    longest_path = 0\n    memo = [[0] * cols for _ in range(rows)]\n\n    def dfs(row, col):\n        if memo[row][col]:\n            return memo[row][col]\n\n        path = 1\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        for dx, dy in directions:\n            new_row, new_col = row + dx, col + dy\n\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] > grid[row][col]:\n                path = max(path, dfs(new_row, new_col) + 1)\n\n        memo[row][col] = path\n        return path\n\n    for i in range(rows):\n        for j in range(cols):\n            longest_path = max(longest_path, dfs(i, j))\n\n    return longest_path", "solution_func": "def g():\n    return [[9, 9, 4], [6, 6, 8], [2, 1, 1]]", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums' and a target integer 'target', find two numbers in the list that add up to the target.\n    Return a list of the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1 in the list add up to the target 9.\n    \"\"\"\n\n    # Sort the list in ascending order\n    nums.sort()\n\n    # Use two pointers to find the two numbers that add up to the target\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 399, "target_skills": [0, 0, 1, 0, 0, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums' and a target integer 'target', find two numbers in the list that add up to the target.\n    Return a list of the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1 in the list add up to the target 9.\n    \"\"\"\n\n    # Sort the list in ascending order\n    nums.sort()\n\n    # Use two pointers to find the two numbers that add up to the target\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers 'nums', return all possible subsets of the list.\n\n    Example:\n    nums = [1, 2, 3]\n\n    Output:\n    [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n\n    Explanation:\n    The possible subsets of the list [1, 2, 3] are:\n    [], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]\n    \"\"\"\n\n    subsets = [[]]\n\n    for num in nums:\n        # Add the current number to all existing subsets\n        for i in range(len(subsets)):\n            subsets.append(subsets[i] + [num])\n\n    return subsets\n\ndef g():\n    nums = [1, 2, 3]\n    return nums\n\nassert f(g()) == [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n", "emb": null, "idx_generation": 399, "target_skills": [0, 0, 1, 0, 1, 1, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers 'nums', return all possible subsets of the list.\n\n    Example:\n    nums = [1, 2, 3]\n\n    Output:\n    [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n\n    Explanation:\n    The possible subsets of the list [1, 2, 3] are:\n    [], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]\n    \"\"\"\n\n    subsets = [[]]\n\n    for num in nums:\n        # Add the current number to all existing subsets\n        for i in range(len(subsets)):\n            subsets.append(subsets[i] + [num])\n\n    return subsets", "solution_func": "def g():\n    nums = [1, 2, 3]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum sum that can be obtained by choosing a non-empty subarray of the list.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n\n    current_sum = max_sum = nums[0]\n\n    for i in range(1, len(nums)):\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 399, "target_skills": [1, 1, 1, 0, 0, 1, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum sum that can be obtained by choosing a non-empty subarray of the list.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n\n    current_sum = max_sum = nums[0]\n\n    for i in range(1, len(nums)):\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target integer, return the index of the target integer in the list.\n    If the target integer is not found in the list, return -1.\n    \"\"\"\n    def binary_search(nums: List[int], target: int) -> int:\n        low = 0\n        high = len(nums) - 1\n\n        while low <= high:\n            mid = (low + high) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n\n        return -1\n\n    return binary_search(nums, target)\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 3, 5, 7, 9, 11]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 3\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 399, "target_skills": [0, 1, 1, 1, 0, 1, 1, 1, 1, 1], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target integer, return the index of the target integer in the list.\n    If the target integer is not found in the list, return -1.\n    \"\"\"\n    def binary_search(nums: List[int], target: int) -> int:\n        low = 0\n        high = len(nums) - 1\n\n        while low <= high:\n            mid = (low + high) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n\n        return -1\n\n    return binary_search(nums, target)", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [1, 3, 5, 7, 9, 11]\n    target = 7\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}]
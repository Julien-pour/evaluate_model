[
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of ways to climb to the top of a staircase with n steps. \n    You can climb either 1 or 2 steps at a time.\"\"\"\n    if n == 0 or n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    else:\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        dp[2] = 2\n        for i in range(3, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        return dp[n]\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 309,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool:\n    \"\"\"Given a grid and two coordinates, determine if there is a path from the start coordinate to the end coordinate.\n    You can only move to adjacent elements in the grid (up, down, left, or right).\"\"\"\n    m, n = len(grid), len(grid[0])\n    visited = [[False] * n for _ in range(m)]\n    stack = [(start[0], start[1])]\n    while stack:\n        x, y = stack.pop()\n        if (x, y) == end:\n            return True\n        visited[x][y] = True\n        neighbors = [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]\n        for nx, ny in neighbors:\n            if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] != -1:\n                stack.append((nx, ny))\n    return False\n\ndef g(grid: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n    \"\"\"Find the coordinates of the start and end elements in the grid.\"\"\"\n    m, n = len(grid), len(grid[0])\n    start = (0, 0)\n    end = (m-1, n-1)\n    return start, end\n\nassert f(grid=[[1, 2, 3], [4, 5, 6], [7, 8, 9]], start=g(grid=[[1, 2, 3], [4, 5, 6], [7, 8, 9]])[0], end=g(grid=[[1, 2, 3], [4, 5, 6], [7, 8, 9]])[1])\n",
        "idx_generation": 51,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Determine if a given grid can be traversed from the top-left corner to the bottom-right corner,\n    while only moving right or down. The grid contains obstacles marked as 1, and open spaces marked as 0.\"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    \n    def dfs(i, j):\n        if i == n-1 and j == m-1:\n            return True\n        if i >= n or j >= m or grid[i][j] == 1 or visited[i][j]:\n            return False\n        visited[i][j] = True\n        return dfs(i+1, j) or dfs(i, j+1)\n    \n    return dfs(0, 0)\n\ndef g():\n    return [[0, 0, 0, 0],\n            [0, 1, 0, 1],\n            [0, 0, 0, 0],\n            [0, 0, 1, 0]]\n\nassert f(g())\n",
        "idx_generation": 7,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid with some empty cells and some blocked cells, determine if it is possible to reach from the top-left\n    corner to the bottom-right corner, by moving only through the empty cells, and only moving diagonally or horizontally.\"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    \n    def dfs(i, j):\n        if i == n-1 and j == m-1:\n            return True\n        if i >= n or j >= m or grid[i][j] == 1 or visited[i][j]:\n            return False\n        visited[i][j] = True\n        return dfs(i+1, j) or dfs(i, j+1) or dfs(i+1, j+1)\n    \n    return dfs(0, 0)\n\ndef g():\n    return [[0, 0, 0, 0],\n            [0, 1, 0, 1],\n            [0, 0, 0, 0],\n            [0, 0, 1, 0]]\n\nassert f(g())\n",
        "idx_generation": 7,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, words=['apple', 'banana', 'cherry', 'date', 'elderberry', 'fig'], target='berry') -> bool:\n    \"\"\"Find if a target substring exists in any of the words in a list by performing a breadth-first search (BFS).\"\"\"\n    def bfs(words, target):\n        queue = []\n        for word in words:\n            queue.append(word)\n        while queue:\n            curr_word = queue.pop(0)\n            if target in curr_word:\n                return True\n        return False\n    \n    return bfs(words, target)\n\ndef g(words=['apple', 'banana', 'cherry', 'date', 'elderberry', 'fig'], target='berry'):\n    for word in words:\n        if target in word:\n            return True\n    return False\n\nassert f(g())\n",
        "idx_generation": 1,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, grid=[['X', 'O', 'X'], ['O', 'X', 'O'], ['X', 'O', 'X']], target='X') -> bool:\n    \"\"\"Find the number of occurrences of a target string in a grid\"\"\"\n    count = 0\n    for row in grid:\n        row_str = ''.join(row)\n        count += row_str.count(target)\n    return count == s\ndef g(grid=[['X', 'O', 'X'], ['O', 'X', 'O'], ['X', 'O', 'X']], target='X'):\n    return sum(row.count(target) for row in grid)\nassert f(g())\n",
        "idx_generation": 8,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"Given an array of integers 'arr' and an integer 'k', determine if there exist two distinct indices i and j,\n    such that arr[i] & arr[j] == k, where '&' denotes the bitwise AND operation.\"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] & arr[j] == k:\n                return True\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g(), 4)\n",
        "idx_generation": 2,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"Given an array of integers 'arr' and an integer 'k', determine the number of subarrays whose bitwise XOR\n    is equal to 'k'.\"\"\"\n    count = 0\n    xor_sum = 0\n    xor_count = {0: 1}\n    for num in arr:\n        xor_sum ^= num\n        count += xor_count.get(xor_sum ^ k, 0)\n        xor_count[xor_sum] = xor_count.get(xor_sum, 0) + 1\n    return count\n\ndef g():\n    return [4, 2, 2, 6, 4]\n\nassert f(g(), 6) == 4\n",
        "idx_generation": 2,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a subset whose XOR is equal to the target value.\n    \"\"\"\n    n = len(nums)\n    total = 2 ** n\n    for i in range(total):\n        curr_xor = 0\n        for j in range(n):\n            if i & (1 << j):\n                curr_xor ^= nums[j]\n        if curr_xor == target:\n            return True\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5], target=6):\n    \"\"\"\n    Generate a list of integers where there exists a subset whose XOR is equal to the target value.\n    \"\"\"\n    return nums\n\nassert f(g(), 6) == True\n\n",
        "idx_generation": 345,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum XOR value that can be obtained by performing XOR operation\n    on any two elements in the grid.\n    Sample Input:\n    grid = [[3, 10, 6, 8],\n            [12, 5, 13, 9],\n            [7, 2, 11, 1],\n            [0, 4, 14, 15]]\n    Sample Output:\n    15\n    \"\"\"\n    max_xor = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            for k in range(i, len(grid)):\n                for l in range(j, len(grid[0])):\n                    xor = grid[i][j] ^ grid[k][l]\n                    max_xor = max(max_xor, xor)\n    return max_xor\n\ndef g():\n    return [[3, 10, 6, 8],\n            [12, 5, 13, 9],\n            [7, 2, 11, 1],\n            [0, 4, 14, 15]]\n\nassert f(g()) == 15\n",
        "idx_generation": 481,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the binary representation of n is a palindrome\"\"\"\n    binary = bin(n)[2:]\n    return binary == binary[::-1]\ndef g(n=21):\n    return n\nassert f(g())\n",
        "idx_generation": 4,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum XOR value between any two numbers in the list.\n    Return the maximum XOR value.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    \n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        unique_nums = set()\n        \n        for num in nums:\n            unique_nums.add(num & mask)\n        \n        current_xor = max_xor | (1 << i)\n        \n        for prefix in unique_nums:\n            if (prefix ^ current_xor) in unique_nums:\n                max_xor = current_xor\n                break\n    \n    return max_xor\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [3, 10, 5, 25, 2, 8]\n    \n    return nums\n\nassert f(g()) == 28\n",
        "idx_generation": 112,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\nfrom math import factorial\n\ndef f(n: int, k=10) -> bool:\n    \"\"\"Given two integers n and k, determine if n is a strong number.\n    A strong number is a number that is equal to the sum of the factorial of its digits.\n    Return True if n is a strong number, otherwise return False.\n    \"\"\"\n    def is_strong_number(num):\n        return sum(factorial(int(digit)) for digit in str(num)) == num\n    \n    return is_strong_number(n)\n\ndef g(k=10):\n    return 145\n\nassert f(g())\n",
        "idx_generation": 145,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the number of unique paths from the top-left corner to the bottom-right corner of a grid of size n x n,\n    where you can only move right or down.\"\"\"\n    def unique_paths_helper(i: int, j: int, memo: dict) -> int:\n        if i == n-1 and j == n-1:\n            return 1\n        if (i, j) in memo:\n            return memo[(i, j)]\n        right = 0\n        down = 0\n        if i < n-1:\n            right = unique_paths_helper(i+1, j, memo)\n        if j < n-1:\n            down = unique_paths_helper(i, j+1, memo)\n        memo[(i, j)] = right + down\n        return memo[(i, j)]\n\n    return unique_paths_helper(0, 0, {})\n\ndef g():\n    return 3\n\nassert f(g()) == 6\n",
        "idx_generation": 78,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of integers, determine if it is possible to reach the bottom-right cell from the top-left cell,\n    moving only down or to the right. Additionally, the sum of all numbers encountered along the path must be even.\"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    return dfs(grid, 0, 0, 0)\n\ndef dfs(grid, i, j, total):\n    n = len(grid)\n    m = len(grid[0])\n    if i == n - 1 and j == m - 1:\n        return total % 2 == 0\n    if i < 0 or i >= n or j < 0 or j >= m:\n        return False\n    total += grid[i][j]\n    return dfs(grid, i + 1, j, total) or dfs(grid, i, j + 1, total)\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g())\n",
        "idx_generation": 57,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\n    The player can only move down or right at each step.\"\"\"\n    grid = [[0] * n for _ in range(n)]\n    return dfs(grid, n - 1, n - 1)\n\ndef dfs(grid, i, j):\n    if i < 0 or j < 0:\n        return 0\n    if i == 0 and j == 0:\n        return 1\n    if grid[i][j] > 0:\n        return grid[i][j]\n    grid[i][j] = dfs(grid, i - 1, j) + dfs(grid, i, j - 1)\n    return grid[i][j]\n\ndef g(n: int) -> int:\n    return f(n)\n\nn = 3\nassert f(n) == g(n)\n",
        "idx_generation": 80,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there is a subset of the elements whose bitwise XOR is equal to zero.\n    Return True if such a subset exists, otherwise return False.\n    \"\"\"\n    n = len(arr)\n    total_sum = sum(arr)\n    \n    if total_sum % 2 != 0:\n        return False\n    \n    target = total_sum // 2\n    dp = [[False] * (target + 1) for _ in range(n+1)]\n    \n    # Base case: subset of empty set has a sum of zero\n    dp[0][0] = True\n    \n    for i in range(1, n+1):\n        for j in range(target + 1):\n            if j < arr[i-1]:\n                dp[i][j] = dp[i-1][j]\n            else:\n                dp[i][j] = dp[i-1][j] or dp[i-1][j-arr[i-1]]\n    \n    return dp[n][target]\n\ndef g():\n    return [1, 2, 3, 4]\n\nassert f(g())\n",
        "idx_generation": 192,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency matrix and two nodes, determine if there exists a path from the start node to the end node.\n    Each node is represented by an integer, and the adjacency matrix indicates the presence of an edge between two nodes.\n    Return True if a path exists, and False otherwise.\n    Sample Input:\n    graph = [[0, 1, 0, 0],\n             [0, 0, 1, 0],\n             [0, 0, 0, 1],\n             [0, 0, 0, 0]]\n    start = 0\n    end = 3\n    Sample Output:\n    True\"\"\"\n    stack = [start]\n    visited = set()\n    while stack:\n        node = stack.pop()\n        visited.add(node)\n        if node == end:\n            return True\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1 and neighbor not in visited:\n                stack.append(neighbor)\n    return False\n\ndef g():\n    return [[0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1],\n            [0, 0, 0, 0]]\n\nassert f(g(), start=0, end=3)\n",
        "idx_generation": 429,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of 0s and 1s, determine if there is a rectangle composed entirely of 1s.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    for i in range(rows):\n        for j in range(cols):\n            if matrix[i][j] == 1:\n                for k in range(i+1, rows):\n                    if matrix[k][j] == 1:\n                        for l in range(j+1, cols):\n                            if matrix[i][l] == 1 and matrix[k][l] == 1:\n                                return True\n                            \n    return False\n\ndef g(matrix=[[1, 0, 0, 1],\n              [0, 1, 1, 0],\n              [0, 1, 1, 0],\n              [1, 0, 0, 1]]):\n    return matrix\n\nassert f(g()) == True\n",
        "idx_generation": 84,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target: int, start: Tuple[int, int]) -> bool:\n    \"\"\"Determine if it is possible to reach the target element from the start element in a grid,\n    by only moving through elements that are greater than or equal to the target value.\n    You can only move to adjacent elements in the grid (up, down, left, or right).\n    Sample Input:\n    grid = [[4, 5, 6],\n            [3, 2, 1],\n            [7, 8, 9]]\n    target = 4\n    start = (0, 0)\n    Sample Output:\n    False\"\"\"\n    m, n = len(grid), len(grid[0])\n    visited = [[False] * n for _ in range(m)]\n    queue = [(start[0], start[1])]\n    while queue:\n        x, y = queue.pop(0)\n        if grid[x][y] == target:\n            return True\n        visited[x][y] = True\n        neighbors = [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]\n        for nx, ny in neighbors:\n            if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] >= target:\n                queue.append((nx, ny))\n    return False\n\ndef g(grid: List[List[int]], target: int) -> Tuple[int, int]:\n    \"\"\"Find the coordinates of the starting element in the grid.\"\"\"\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == target:\n                return (i, j)\n    return (-1, -1)\n\nassert f(grid=[[4, 5, 6], [3, 2, 1], [7, 8, 9]], target=4, start=g(grid=[[4, 5, 6], [3, 2, 1], [7, 8, 9]], target=4))\n",
        "idx_generation": 18,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if there is a path from the top-left corner to the bottom-right corner in a grid.\n    Return True if there is a path, and False otherwise.\"\"\"\n    \n    def dfs(grid: List[List[int]], row: int, col: int) -> bool:\n        \"\"\"Depth-first search to find a path in the grid.\"\"\"\n        \n        if row == len(grid) - 1 and col == len(grid[0]) - 1:\n            return True\n        \n        if row >= len(grid) or col >= len(grid[0]) or grid[row][col] == 1:\n            return False\n        \n        return dfs(grid, row + 1, col) or dfs(grid, row, col + 1)\n    \n    return dfs(grid, 0, 0)\n\ndef g():\n    return [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n\nassert f(g())\n",
        "idx_generation": 56,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"A string `s` is said to be a k-ary string if it consists only of the digits 0 to k-1 (inclusive). Given a string `s`,\n    check if it can be transformed into a k-ary string by replacing each digit with a different digit from 0 to k-1.\"\"\"\n    unique_digits = set(s)\n    if len(unique_digits) > k:\n        return False\n    digit_mapping = {}\n    for digit in unique_digits:\n        digit_mapping[digit] = str(len(digit_mapping))\n    transformed_s = ''.join(digit_mapping[digit] for digit in s)\n    return len(set(transformed_s)) <= k\n\ndef g(s: str, k: int):\n    \"\"\"Transform the string `s` into a k-ary string by replacing each digit with a different digit from 0 to k-1.\"\"\"\n    unique_digits = set(s)\n    digit_mapping = {}\n    for digit in unique_digits:\n        digit_mapping[digit] = str(len(digit_mapping))\n    transformed_s = ''.join(digit_mapping[digit] for digit in s)\n    return transformed_s\n\nassert f(g('12345', 5), 5)\n",
        "idx_generation": 117,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], target: str) -> bool:\n    \"\"\"Given a list of words and a target word, determine if it is possible to form the target word\n    by concatenating words from the list in any order. You can use each word in the list only once.\n    Example:\n    words = [\"apple\", \"pen\", \"pineapple\"]\n    target = \"pineapplepenapple\"\n    Output: True\"\"\"\n    stack = [0]\n    visited = set()\n    while stack:\n        idx = stack.pop()\n        if idx == len(target):\n            return True\n        if idx in visited:\n            continue\n        visited.add(idx)\n        for i, word in enumerate(words):\n            if target[idx:idx+len(word)] == word:\n                stack.append(idx+len(word))\n    return False\n\ndef g():\n    return ([\"apple\", \"pen\", \"pineapple\"], \"pineapplepenapple\")\n\nassert f(*g())\n",
        "idx_generation": 453,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[str]], word: str) -> bool:\n    \"\"\"Given a grid of letters and a target word, determine if the word exists in the grid. The word can be formed by traversing adjacent cells horizontally or vertically.\"\"\"\n    def dfs(grid, word, i, j, index):\n        if index == len(word):\n            return True\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != word[index]:\n            return False\n        temp = grid[i][j]\n        grid[i][j] = \"#\"\n        res = dfs(grid, word, i+1, j, index+1) or dfs(grid, word, i-1, j, index+1) or dfs(grid, word, i, j+1, index+1) or dfs(grid, word, i, j-1, index+1)\n        grid[i][j] = temp\n        return res\n    \n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if dfs(grid, word, i, j, 0):\n                return True\n    return False\n\ndef g(grid=[['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word=\"ABCCED\"):\n    return grid, word\n\nassert f(*g())\n\n",
        "idx_generation": 143,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]], word: str) -> bool:\n    \"\"\"Given a grid of characters and a target word, determine if the word can be formed by traversing adjacent cells (horizontally or vertically) in the grid.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(grid: List[List[str]], row: int, col: int, word: str, index: int) -> bool:\n        if index == len(word):\n            return True\n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] != word[index]:\n            return False\n        temp = grid[row][col]\n        grid[row][col] = ''\n        for direction in directions:\n            newRow = row + direction[0]\n            newCol = col + direction[1]\n            if dfs(grid, newRow, newCol, word, index + 1):\n                return True\n        grid[row][col] = temp\n        return False\n\n    for r in range(rows):\n        for c in range(cols):\n            if dfs(grid, r, c, word, 0):\n                return True\n    return False\n\ndef g() -> List[List[str]]:\n    \"\"\"Generate a grid of characters and a target word.\"\"\"\n    grid = [['A', 'B', 'C', 'E'],\n            ['S', 'F', 'C', 'S'],\n            ['A', 'D', 'E', 'E']]\n    word = \"ABCCED\"\n    return grid, word\n\nassert f(*g())\n",
        "idx_generation": 331,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> bool:\n    \"\"\"Given a binary tree, check if it is a valid binary search tree (BST).\n    Return True if the tree is a valid BST, False otherwise.\n    Sample input:\n    root = TreeNode(2)\n    root.left = TreeNode(1)\n    root.right = TreeNode(3)\n    Sample output:\n    True\n    \"\"\"\n    def isValidBST(node, min_val, max_val):\n        if node is None:\n            return True\n        if node.val <= min_val or node.val >= max_val:\n            return False\n        return isValidBST(node.left, min_val, node.val) and isValidBST(node.right, node.val, max_val)\n    \n    return isValidBST(root, float('-inf'), float('inf'))\n\ndef g():\n    root = TreeNode(2)\n    root.left = TreeNode(1)\n    root.right = TreeNode(3)\n    return root\n\nassert f(g())\n",
        "idx_generation": 211,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there is a path from the start node to the end node in the given graph.\"\"\"\n    visited = set()\n    stack = [start]\n    \n    while stack:\n        node = stack.pop()\n        \n        if node == end:\n            return True\n        \n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    \n    return False\n\ndef g():\n    graph = [[1, 2], [3], [4, 5], [5], [], []]\n    start = 0\n    end = 5\n    return graph, start, end\n\nassert f(*g())\n",
        "idx_generation": 259,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Find a combination of numbers from the given list that adds up to the target value.\"\"\"\n    stack = [(0, [])]\n    while stack:\n        total, combination = stack.pop()\n        if total == target:\n            return True\n        if total > target:\n            continue\n        for num in nums:\n            stack.append((total + num, combination + [num]))\n    return False\ndef g(target=10):\n    nums = [2, 3, 5, 7]\n    return nums\nassert f(g())\n",
        "idx_generation": 52,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"Given a list of integers and a target value, find all unique combinations of numbers in the list that add up to the target.\n    Each number in the combination can be used multiple times.\"\"\"\n    def backtrack(start: int, current: List[int], target: int):\n        if target == 0:\n            combinations.append(current)\n            return\n        if target < 0:\n            return\n        for i in range(start, len(nums)):\n            backtrack(i, current + [nums[i]], target - nums[i])\n    \n    combinations = []\n    backtrack(0, [], target)\n    \n    return combinations\n\ndef g(nums=[2, 3, 6, 7], target=7):\n    return nums, target\n\nassert f(*g()) == [[2, 2, 3], [7]]\n",
        "idx_generation": 318,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, return the count of all possible unique paths from the top-left corner to the bottom-right corner of a n x n grid.\n    You can only move either down or right at any point in time.\"\"\"\n    def factorial(num):\n        if num == 0 or num == 1:\n            return 1\n        return num * factorial(num - 1)\n\n    return factorial(2 * n - 2) // (factorial(n - 1) ** 2)\n\ndef g(n: int):\n    return n\n\nassert f(g(3)) == 6\n",
        "idx_generation": 219,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers, find the index of the target element using binary search.\n    If the target element is not found, return -1.\n    Sample input:\n    [1, 3, 5, 7, 9], 5\n    Sample output:\n    2\"\"\"\n    low = 0\n    high = len(nums) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\ndef g():\n    return [1, 3, 5, 7, 9], 5\n\nassert f(*g()) == 2\n",
        "idx_generation": 16,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(numbers: List[int], target=10) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if there are two integers in the list that add up to the target.\"\"\"\n    stack = []\n    for num in numbers:\n        complement = target - num\n        if complement in stack:\n            return True\n        stack.append(num)\n    return False\ndef g(target=10):\n    return [1, 4, 6, 3, 8, 2]\nassert f(g())\n",
        "idx_generation": 21,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target=100) -> bool:\n    \"\"\"Find a combination of numbers from the given list that sum up to the target value\"\"\"\n    stack = []\n    stack.append((0, 0))\n    while stack:\n        curr_sum, curr_index = stack.pop()\n        if curr_sum == target:\n            return True\n        if curr_index < len(arr):\n            stack.append((curr_sum + arr[curr_index], curr_index + 1))\n            stack.append((curr_sum, curr_index + 1))\n    return False\n\ndef g(target=100):\n    arr = [10, 20, 30, 40, 50, 60]\n    return arr\n\nassert f(g())\n",
        "idx_generation": 68,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Given a 2D grid of 0s and 1s, find the maximum area of a rectangle composed only of 1s.\"\"\"\n    def maximalRectangle(matrix: List[List[int]]) -> int:\n        if not matrix:\n            return 0\n\n        n = len(matrix[0])\n        heights = [0] * (n + 1)\n        maxArea = 0\n\n        for row in matrix:\n            for i in range(n):\n                heights[i] = heights[i] + 1 if row[i] == 1 else 0\n\n            stack = [-1]\n            for i in range(n + 1):\n                while heights[i] < heights[stack[-1]]:\n                    h = heights[stack.pop()]\n                    w = i - stack[-1] - 1\n                    maxArea = max(maxArea, h * w)\n                stack.append(i)\n\n        return maxArea\n\n    return maximalRectangle(matrix)\n\ndef g(matrix=[[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]):\n    return matrix\n\nassert f(g()) == 6\n",
        "idx_generation": 3,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target: int, start: Tuple[int, int]) -> bool:\n    \"\"\"Determine if it is possible to reach the target element from the start element in a grid.\n    You can only move to adjacent elements in the grid (up, down, left, or right).\n    Sample Input:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n    target = 9\n    start = (0, 0)\n    Sample Output:\n    True\"\"\"\n    m, n = len(grid), len(grid[0])\n    visited = [[False] * n for _ in range(m)]\n    stack = [(start[0], start[1])]\n    while stack:\n        x, y = stack.pop()\n        if grid[x][y] == target:\n            return True\n        visited[x][y] = True\n        neighbors = [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]\n        for nx, ny in neighbors:\n            if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] != -1:\n                stack.append((nx, ny))\n    return False\n\ndef g(grid: List[List[int]], target: int) -> Tuple[int, int]:\n    \"\"\"Find the coordinates of the starting element in the grid.\"\"\"\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == target:\n                return (i, j)\n    return (-1, -1)\n\nassert f(grid=[[1, 2, 3], [4, 5, 6], [7, 8, 9]], target=9, start=g(grid=[[1, 2, 3], [4, 5, 6], [7, 8, 9]], target=9))\n",
        "idx_generation": 18,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\ndef f(expression: str) -> bool:\n    \"\"\"Given a mathematical expression in string format, determine if the parentheses are balanced.\"\"\"\n    stack = []\n    \n    for char in expression:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            else:\n                stack.pop()\n    \n    return len(stack) == 0\n\ndef g(expression='(3 + 4) * (5 - 2)'):\n    return expression\n\nassert f(g())\n",
        "idx_generation": 24,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"Rotate the given grid 90 degrees clockwise.\"\"\"\n    n = len(grid)\n    for i in range(n // 2):\n        for j in range(i, n - 1 - i):\n            temp = grid[i][j]\n            grid[i][j] = grid[n - 1 - j][i]\n            grid[n - 1 - j][i] = grid[n - 1 - i][n - 1 - j]\n            grid[n - 1 - i][n - 1 - j] = grid[j][n - 1 - i]\n            grid[j][n - 1 - i] = temp\n    return grid\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 184,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"Given a matrix of integers, return the elements in spiral order.\n    Spiral order starts from the top left element and goes in clockwise direction until all elements have been visited.\"\"\"\n    result = []\n    if not matrix:\n        return result\n    top, bottom, left, right = 0, len(matrix) - 1, 0, len(matrix[0]) - 1\n\n    while top <= bottom and left <= right:\n        # Traverse top row\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n\n        # Traverse right column\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        if top <= bottom:\n            # Traverse bottom row\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left <= right:\n            # Traverse left column\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 165,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(res: int, arr=[5, 2, 8, 1, 9, 3], target=10) -> bool:\n    \"\"\"Find if there exists a pair of integers in the given list whose XOR is equal to the target value.\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        xor = arr[left] ^ arr[right]\n        if xor == target:\n            return True\n        elif xor < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr=[5, 2, 8, 1, 9, 3], target=10):\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        xor = arr[left] ^ arr[right]\n        if xor == target:\n            return True\n        elif xor < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\nassert f(g())\n",
        "idx_generation": 17,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order using the Bitonic Sort algorithm.\n    \"\"\"\n    def bitonic_sort(arr: List[int], low: int, count: int, direction: int):\n        if count > 1:\n            k = count // 2\n            bitonic_sort(arr, low, k, 1)\n            bitonic_sort(arr, low + k, k, 0)\n            bitonic_merge(arr, low, count, direction)\n    \n    def bitonic_merge(arr: List[int], low: int, count: int, direction: int):\n        if count > 1:\n            k = count // 2\n            for i in range(low, low + k):\n                if (arr[i] > arr[i + k]) == direction:\n                    arr[i], arr[i + k] = arr[i + k], arr[i]\n            bitonic_merge(arr, low, k, direction)\n            bitonic_merge(arr, low + k, k, direction)\n    \n    bitonic_sort(nums, 0, len(nums), 1)\n    return nums\n\ndef g():\n    nums = [4, 2, 6, 8, 1, 3, 5, 7]\n    return nums\n\nassert f(g()) == [1, 2, 3, 4, 5, 6, 7, 8]\n",
        "idx_generation": 297,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the array contains a subarray whose bitwise OR is equal to the sum of its elements.\"\"\"\n    for i in range(len(arr)):\n        curr_sum = arr[i]\n        curr_or = arr[i]\n        for j in range(i+1, len(arr)):\n            curr_sum += arr[j]\n            curr_or |= arr[j]\n            if curr_sum == curr_or:\n                return True\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g())\n",
        "idx_generation": 188,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the given array is a sorted array in ascending order.\"\"\"\n    for i in range(len(arr) - 1):\n        if arr[i] > arr[i+1]:\n            return False\n    return True\n\ndef g(arr=[1, 2, 3, 4, 5, 6]):\n    \"\"\"Generate a sorted array in ascending order.\"\"\"\n    return arr\n\nassert f(g())\n",
        "idx_generation": 148,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers nums, return a new list where each element is the product of all elements in nums except itself.\"\"\"\n    n = len(nums)\n    result = [1] * n\n    left_prod, right_prod = 1, 1\n    for i in range(n):\n        result[i] *= left_prod\n        result[n-i-1] *= right_prod\n        left_prod *= nums[i]\n        right_prod *= nums[n-i-1]\n    return result\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [120, 60, 40, 30, 24]\n\n",
        "idx_generation": 169,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if a grid contains a valid magic square, where the sum of each row, column, and diagonal is the same.\"\"\"\n    n = len(grid)\n    target_sum = n * (n ** 2 + 1) // 2\n\n    # Check rows\n    for row in grid:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        if sum(row[col] for row in grid) != target_sum:\n            return False\n\n    # Check diagonals\n    if sum(grid[i][i] for i in range(n)) != target_sum:\n        return False\n    if sum(grid[i][n-i-1] for i in range(n)) != target_sum:\n        return False\n\n    return True\n\ndef g():\n    return [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n\nassert f(g())\n",
        "idx_generation": 164,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(points: List[Tuple[int, int]]) -> bool:\n    \"\"\"Given a list of 2D points, check if there exists a line that can divide the points into two equal groups.\n    The line should pass through at least one of the points.\"\"\"\n    if len(points) < 2:\n        return False\n\n    # Sort the points based on their x-coordinate\n    points.sort(key=lambda x: x[0])\n\n    # Calculate the mid-point of the sorted points\n    mid = (points[0][0] + points[-1][0]) / 2\n\n    # Divide the points into two groups based on their x-coordinate\n    group1 = []\n    group2 = []\n    for point in points:\n        if point[0] <= mid:\n            group1.append(point)\n        else:\n            group2.append(point)\n\n    # Check if the two groups have equal number of points\n    if len(group1) != len(group2):\n        return False\n\n    # Calculate the slopes of the lines passing through each pair of points in the two groups\n    slopes1 = []\n    slopes2 = []\n    for i in range(len(group1)):\n        for j in range(i + 1, len(group1)):\n            slope = (group1[j][1] - group1[i][1]) / (group1[j][0] - group1[i][0])\n            slopes1.append(slope)\n    for i in range(len(group2)):\n        for j in range(i + 1, len(group2)):\n            slope = (group2[j][1] - group2[i][1]) / (group2[j][0] - group2[i][0])\n            slopes2.append(slope)\n\n    # Check if there exists a line that can divide the points into two equal groups\n    for slope1 in slopes1:\n        for slope2 in slopes2:\n            if slope1 == slope2:\n                return True\n\n    return False\n\ndef g():\n    return [(1, 2), (3, 4), (5, 6), (2, 4), (4, 8), (6, 12), (-1, -2), (-3, -4), (-5, -6), (-2, -4), (-4, -8), (-6, -12)]\n\nassert f(g())\n",
        "idx_generation": 446,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(s: str, n=1) -> bool:\n    \"\"\"Check if a given string is a palindrome and if the square root of a given number is a perfect square.\"\"\"\n    return s == s[::-1] and math.isqrt(n) ** 2 == n\n\ndef g(s='racecar', n=16):\n    return s, n\n\nassert f(*g())\n",
        "idx_generation": 30,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Rearrange the elements of the given list such that all even numbers appear before all odd numbers\"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        if arr[left] % 2 == 0:\n            left += 1\n        elif arr[right] % 2 == 1:\n            right -= 1\n        else:\n            arr[left], arr[right] = arr[right], arr[left]\n            left += 1\n            right -= 1\n\n    return arr\n\ndef g(arr: List[int]) -> List[int]:\n    \"\"\"Rearrange the elements of the given list such that all even numbers appear before all odd numbers\"\"\"\n    return sorted(arr, key=lambda x: x % 2)\n\nassert f(g([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])) == [2, 4, 6, 8, 10, 1, 3, 5, 7, 9]\n",
        "idx_generation": 168,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(maze: List[List[int]]) -> bool:\n    \"\"\"Given a maze represented as a 2D grid where 0 represents an empty space and 1 represents a wall, check if there exists a path from the top-left corner to the bottom-right corner.\n    Additionally, you can only move in a diagonal direction if the neighboring cells in both horizontal and vertical directions are empty spaces.\"\"\"\n    m, n = len(maze), len(maze[0])\n    stack = [(0, 0)]\n    visited = set()\n\n    while stack:\n        i, j = stack.pop()\n        if i == m - 1 and j == n - 1:\n            return True\n        visited.add((i, j))\n\n        neighbors = [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1), (i - 1, j - 1), (i - 1, j + 1), (i + 1, j - 1), (i + 1, j + 1)]\n        for x, y in neighbors:\n            if 0 <= x < m and 0 <= y < n and (x, y) not in visited and maze[x][y] == 0:\n                stack.append((x, y))\n\n    return False\n\ndef g():\n    return [[0, 0, 0, 0, 0],\n            [0, 1, 1, 0, 0],\n            [0, 0, 0, 1, 0],\n            [1, 1, 0, 0, 0],\n            [0, 0, 0, 0, 0]]\n\nassert f(g())\n\n",
        "idx_generation": 106,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return a list containing the elements of the matrix in spiral order.\n    \"\"\"\n\n    m = len(matrix)\n    n = len(matrix[0])\n\n    # Define the boundaries of the spiral\n    top = 0\n    bottom = m - 1\n    left = 0\n    right = n - 1\n\n    spiral = []\n\n    while top <= bottom and left <= right:\n        # Traverse the top row\n        for i in range(left, right + 1):\n            spiral.append(matrix[top][i])\n        top += 1\n\n        # Traverse the right column\n        for i in range(top, bottom + 1):\n            spiral.append(matrix[i][right])\n        right -= 1\n\n        # Traverse the bottom row\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                spiral.append(matrix[bottom][i])\n            bottom -= 1\n\n        # Traverse the left column\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                spiral.append(matrix[i][left])\n            left += 1\n\n    return spiral\n\n\ndef g(matrix: List[List[int]] = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 163,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a 2D grid of 0s and 1s, find the length of the longest line of consecutive ones.\n    The line can be horizontal, vertical, diagonal or anti-diagonal.\"\"\"\n    m, n = len(grid), len(grid[0])\n    max_len = 0\n    dp = [[[0] * 4 for _ in range(n)] for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                dp[i][j][0] = dp[i][j-1][0] + 1 if j > 0 else 1\n                dp[i][j][1] = dp[i-1][j][1] + 1 if i > 0 else 1\n                dp[i][j][2] = dp[i-1][j-1][2] + 1 if i > 0 and j > 0 else 1\n                dp[i][j][3] = dp[i-1][j+1][3] + 1 if i > 0 and j < n-1 else 1\n                max_len = max(max_len, dp[i][j][0], dp[i][j][1], dp[i][j][2], dp[i][j][3])\n    return max_len\n\ndef g():\n    return [[1,1,1,0],[0,1,1,0],[0,0,0,1]]\n\nassert f(g()) == 3\n",
        "idx_generation": 236,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix, determine if it is symmetric. A matrix is symmetric if it is equal to its transpose.\nSample input:\n[[1, 2, 3],\n [2, 4, 5],\n [3, 5, 6]]\nSample output:\nFalse\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    if rows != cols:\n        return False\n    for i in range(rows):\n        for j in range(cols):\n            if matrix[i][j] != matrix[j][i]:\n                return False\n    return True\ndef g():\n    return [[1, 2, 3],\n            [2, 4, 5],\n            [3, 5, 6]]\nassert f(g())\n",
        "idx_generation": 13,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"Given a 2D matrix of integers, return the elements of the matrix in spiral order\"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n    \n    result = []\n    top = 0\n    bottom = m - 1\n    left = 0\n    right = n - 1\n    \n    while top <= bottom and left <= right:\n        # Traverse top row\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n        \n        # Traverse right column\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n        \n        if top <= bottom:\n            # Traverse bottom row\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n        \n        if left <= right:\n            # Traverse left column\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n    \n    return result\n\ndef g(matrix: List[List[int]] = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 206,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of size n x n, determine if it is a magic square.\n    A magic square is a square grid of numbers containing distinct integers from 1 to n^2,\n    where the sums of the numbers in each row, each column, and both diagonals are equal.\"\"\"\n    \n    def is_magic_square(grid):\n        target_sum = sum(grid[0])\n        \n        # Check rows\n        for row in grid:\n            if sum(row) != target_sum:\n                return False\n        \n        # Check columns\n        for j in range(n):\n            col_sum = sum(grid[i][j] for i in range(n))\n            if col_sum != target_sum:\n                return False\n        \n        # Check diagonals\n        diagonal_sum1 = sum(grid[i][i] for i in range(n))\n        diagonal_sum2 = sum(grid[i][n-i-1] for i in range(n))\n        if diagonal_sum1 != target_sum or diagonal_sum2 != target_sum:\n            return False\n        \n        return True\n    \n    return is_magic_square(grid)\n\ndef g(n=3, grid=[[2, 7, 6], [9, 5, 1], [4, 3, 8]]):\n    return n, grid\n\nassert f(*g())\n",
        "idx_generation": 10,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given an array of integers, find the maximum XOR value between any two numbers in the array.\"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = set()\n        for num in nums:\n            prefixes.add(num & mask)\n        possible_xor = max_xor | (1 << i)\n        for prefix in prefixes:\n            if prefix ^ possible_xor in prefixes:\n                max_xor = possible_xor\n                break\n    return max_xor\n\ndef g():\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n\n",
        "idx_generation": 494,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Given a list of integers 'nums' and an integer 'k',\n    determine if it is possible to rearrange the elements in 'nums'\n    in such a way that the bitwise AND between any two adjacent elements is equal to 'k'.\n    Return True if it is possible, False otherwise.\n    Example:\n    nums = [1, 3, 4, 6, 7, 8]\n    k = 4\n    The possible rearrangements are [1, 4, 6, 3, 7, 8] and [4, 1, 6, 3, 7, 8].\n    Both of these rearrangements have the bitwise AND between any two adjacent elements equal to 4.\n    Therefore, the answer is True.\n    \"\"\"\n    if len(set(nums)) < k:\n        return False\n    return True\n\ndef g():\n    return [1, 3, 4, 6, 7, 8], 4\n\nassert f(*g())\n",
        "idx_generation": 269,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine whether there exists a subset of the list\n    such that the product of its elements is a perfect square.\n    \n    Return True if such a subset exists, False otherwise.\n    \"\"\"\n    freq = {}\n    for num in nums:\n        factors = []\n        for i in range(2, int(num**0.5) + 1):\n            while num % i == 0:\n                factors.append(i)\n                num //= i\n        if num > 1:\n            factors.append(num)\n        prod = 1\n        for factor in factors:\n            prod *= factor\n        if prod in freq:\n            freq[prod] += 1\n        else:\n            freq[prod] = 1\n    for value in freq.values():\n        if value % 2 != 0:\n            return True\n    return False\n\ndef g():\n    nums = [2, 3, 4, 5, 6]\n    return nums\n\nassert f(g())\n",
        "idx_generation": 115,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency matrix, determine if there is a path from a start node to an end node.\"\"\"\n    visited = [False] * len(graph)\n    stack = [start]\n    \n    while stack:\n        node = stack.pop()\n        \n        if node == end:\n            return True\n        \n        if not visited[node]:\n            visited[node] = True\n            \n            for neighbor in range(len(graph)):\n                if graph[node][neighbor] == 1:\n                    stack.append(neighbor)\n    \n    return False\n\ndef g(graph=[[0, 1, 0, 0, 0],\n             [0, 0, 1, 0, 0],\n             [0, 0, 0, 1, 0],\n             [0, 0, 0, 0, 1],\n             [0, 0, 0, 0, 0]], start=0, end=4):\n    return graph, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 468,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum, i.e., the sum of the contiguous subarray with the largest sum.\n    Return the subarray with the largest sum.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    start_idx = 0\n    end_idx = 0\n    for i in range(len(nums)):\n        current_sum += nums[i]\n        if current_sum > max_sum:\n            max_sum = current_sum\n            end_idx = i\n        if current_sum < 0:\n            current_sum = 0\n            start_idx = i + 1\n    return nums[start_idx:end_idx+1]\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == [4, -1, 2, 1]\n",
        "idx_generation": 380,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(x: str, n=20) -> bool:\n    \"\"\"Check if a number is a perfect square and its square root is divisible by n.\"\"\"\n    num = int(x)\n    return math.isqrt(num) ** 2 == num and math.isqrt(num) % n == 0\n\ndef g(n=20):\n    num = (n ** 2) * (2 ** n)\n    return str(num)\n\nassert f(g())\n",
        "idx_generation": 69,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target=100) -> bool:\n    \"\"\"Determine if there exists a combination of numbers from the given list that adds up to the target value,\n    where each number can only be used once.\"\"\"\n    stack = [(0, [])]\n    while stack:\n        total, combination = stack.pop()\n        if total == target:\n            return True\n        if total > target:\n            continue\n        for i, num in enumerate(nums):\n            stack.append((total + num, combination + [num]))\n            nums_copy = nums.copy()\n            nums_copy.pop(i)\n            stack.append((total + num, combination + [num]))\n    return False\n\ndef g(target=100):\n    nums = [10, 20, 30, 40, 50]\n    return nums\n\nassert f(g(), target=100)\n",
        "idx_generation": 261,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\n    Return True if such pair exists, False otherwise.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Generate a sorted list of integers and a target value.\"\"\"\n    nums = [1, 3, 5, 7, 9, 11]\n    target = 10\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 62,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Find the maximum number of consecutive 1s in a binary array by flipping at most one 0.\n\n    Example:\n    Input: [1, 0, 1, 1, 0]\n    Output: 4\n    Explanation: Flip the first 0 to get the maximum number of consecutive 1s: [1, 1, 1, 1, 0]\n    \"\"\"\n\n    max_ones = 0\n    ones = 0\n    flips = 0\n\n    for num in nums:\n        if num == 1:\n            ones += 1\n        else:\n            flips += 1\n            ones = ones + 1 if flips == 1 else 0\n\n        max_ones = max(max_ones, ones)\n\n    return max_ones\n\ndef g():\n    nums = [1, 0, 1, 1, 0]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 393,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers 'nums', find the maximum product of any two distinct numbers in the list.\"\"\"\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n    return max_product\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"Return the list of integers\"\"\"\n    return nums\n\nassert f(g(nums=[1, 2, 3, 4, 5])) == 20\n",
        "idx_generation": 295,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of 0s and 1s, find the maximum number of consecutive 1s in any row or column.\n    Sample Input:\n    grid = [\n        [1, 1, 0, 0],\n        [0, 1, 1, 1],\n        [1, 0, 0, 1]\n    ]\n    Sample Output:\n    3\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    max_consecutive = 0\n    \n    for i in range(rows):\n        count = 0\n        for j in range(cols):\n            if grid[i][j] == 1:\n                count += 1\n                max_consecutive = max(max_consecutive, count)\n            else:\n                count = 0\n    \n    for j in range(cols):\n        count = 0\n        for i in range(rows):\n            if grid[i][j] == 1:\n                count += 1\n                max_consecutive = max(max_consecutive, count)\n            else:\n                count = 0\n    \n    return max_consecutive\n\ndef g():\n    return [\n        [1, 1, 0, 0],\n        [0, 1, 1, 1],\n        [1, 0, 0, 1]\n    ]\n\nassert f(g()) == 3\n",
        "idx_generation": 452,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum product of any two distinct numbers in the list.\"\"\"\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n    return max_product\n\ndef g():\n    nums = [1, 3, 5, 2, 4]\n    return nums\n\nassert f(g()) == 20\n",
        "idx_generation": 287,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(n: int) -> bool:\n    \"\"\"Check if a number is a perfect square.\"\"\"\n    return math.isqrt(n) ** 2 == n\n\ndef g():\n    return str(16 ** 2)\n\nassert f(int(g()))\n",
        "idx_generation": 55,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"Find the indices of two numbers in the given array that add up to the target value.\"\"\"\n    num_dict = {}\n    for i, num in enumerate(arr):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g(arr=[2, 7, 11, 15], target=9):\n    \"\"\"Generate an array of integers and a target value.\"\"\"\n    return arr, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 148,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given an integer array nums, find the contiguous subarray within the array\n    (containing at least one number) which has the largest product.\n    Return True if the product of the largest subarray is positive, False otherwise.\n    \"\"\"\n    max_product = nums[0]\n    min_product = nums[0]\n    result = max_product > 0\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            max_product, min_product = min_product, max_product\n        max_product = max(nums[i], max_product * nums[i])\n        min_product = min(nums[i], min_product * nums[i])\n        result = result or max_product > 0\n    return result\n\ndef g():\n    nums = [2, -5, 3, -2, 4]\n    return nums\n\nassert f(g())\n",
        "idx_generation": 28,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Determine if the given matrix is a magic square.\n    A matrix is considered a magic square if the sum of each row, each column, and each diagonal is the same.\n    Return True if the matrix is a magic square, and False otherwise.\"\"\"\n    \n    n = len(matrix)\n    target_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != target_sum:\n            return False\n    \n    # Check main diagonal\n    if sum(matrix[i][i] for i in range(n)) != target_sum:\n        return False\n    \n    # Check secondary diagonal\n    if sum(matrix[i][n-1-i] for i in range(n)) != target_sum:\n        return False\n    \n    return True\n\ndef g():\n    return [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n\nassert f(g())\n",
        "idx_generation": 13,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Determine if the given matrix is a magic square.\"\"\"\n    n = len(matrix)\n    expected_sum = n * (n**2 + 1) // 2\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != expected_sum:\n            return False\n\n    # Check columns\n    for j in range(n):\n        column_sum = sum(matrix[i][j] for i in range(n))\n        if column_sum != expected_sum:\n            return False\n\n    # Check diagonals\n    diagonal_sum1 = sum(matrix[i][i] for i in range(n))\n    diagonal_sum2 = sum(matrix[i][n - i - 1] for i in range(n))\n    if diagonal_sum1 != expected_sum or diagonal_sum2 != expected_sum:\n        return False\n\n    return True\n\ndef g():\n    matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 0,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]], target=10) -> bool:\n    \"\"\"Given a matrix of integers, find a submatrix with the largest sum that is less than or equal to the target.\n    The solution is a list of four integers representing the indices of the top-left and bottom-right corners of the submatrix.\"\"\"\n    assert len(matrix) > 0 and len(matrix[0]) > 0, \"Matrix cannot be empty.\"\n    \n    max_sum = float('-inf')\n    max_submatrix = None\n    \n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            for k in range(i, len(matrix)):\n                for l in range(j, len(matrix[0])):\n                    submatrix_sum = sum([matrix[row][col] for row in range(i, k+1) for col in range(j, l+1)])\n                    if submatrix_sum <= target and submatrix_sum > max_sum:\n                        max_sum = submatrix_sum\n                        max_submatrix = [i, j, k, l]\n    \n    return max_submatrix is not None\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    target = 10\n    return matrix, target\n\nassert f(*g())\n",
        "idx_generation": 408,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find n such that the sum of the digits of n is equal to the sum of the digits of n squared.\"\"\"\n    digit_sum = sum(map(int, str(n)))\n    squared_digit_sum = sum(map(int, str(n ** 2)))\n    return digit_sum == squared_digit_sum\n\ndef g():\n    n = 1\n    while True:\n        if f(n):\n            return n\n        n += 1\n\nassert f(g()) == True",
        "idx_generation": 50,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a given string is a palindrome, considering only alphanumeric characters and ignoring cases.\n    Sample input:\n    s = \"A man, a plan, a canal: Panama\"\n    Sample output:\n    True\n    \"\"\"\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    return s == s[::-1]\n\ndef g():\n    return \"A man, a plan, a canal: Panama\"\n\nassert f(g())\n",
        "idx_generation": 54,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, return a new list with all duplicates removed.\n    Sample input:\n    [1, 2, 3, 2, 4, 5, 3]\n    Sample output:\n    [1, 2, 3, 4, 5]\"\"\"\n    return list(set(nums))\n\ndef g():\n    return [1, 2, 3, 2, 4, 5, 3]\n\nassert f(g()) == [1, 2, 3, 4, 5]\n\n",
        "idx_generation": 184,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a number is a power of two.\"\"\"\n    return n > 0 and (n & (n - 1)) == 0\n\ndef g(n: int):\n    return 2 ** n\n\nassert f(g(5))\n",
        "idx_generation": 1,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"Check if the given string is a valid email address and if the given number is a power of 2.\"\"\"\n    is_valid_email = False\n    if '@' in s and '.' in s:\n        is_valid_email = True\n\n    is_power_of_two = n & (n - 1) == 0\n\n    return is_valid_email and is_power_of_two\n\ndef g():\n    s = 'example@example.com'\n    n = 16\n    return s, n\n\nassert f(*g())\n",
        "idx_generation": 158,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the missing number.\n    The list contains all the numbers from 0 to n, except for one missing number.\n    Return the missing number.\n    \"\"\"\n    missing = len(nums)\n    \n    for i, num in enumerate(nums):\n        missing ^= i ^ num\n    \n    return missing\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [0, 1, 3, 4, 5]\n    \n    return nums\n\nassert f(g()) == 2\n\n",
        "idx_generation": 131,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number is a power of 2.\"\"\"\n    return n > 0 and (n & (n - 1)) == 0\n\ndef g():\n    n = 16\n    return n\n\nassert f(g())\n",
        "idx_generation": 148,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find whether the given number is a power of two.\"\"\"\n    return n > 0 and (n & (n - 1)) == 0\n\ndef g(n: int):\n    \"\"\"Find the largest power of two less than or equal to the given number.\"\"\"\n    power = 0\n    while (1 << power) <= n:\n        power += 1\n    return 1 << (power - 1)\n\nassert f(g(20))\n",
        "idx_generation": 103,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a subset whose sum is equal to the target value.\"\"\"\n    def subset_sum(nums, target, n):\n        if target == 0:\n            return True\n        if n == 0:\n            return False\n        if nums[n-1] > target:\n            return subset_sum(nums, target, n-1)\n        return subset_sum(nums, target, n-1) or subset_sum(nums, target-nums[n-1], n-1)\n    return subset_sum(nums, target, len(nums))\ndef g(nums=[1, 2, 3, 4, 5], target=9):\n    \"\"\"Generate a list of integers where there exists a subset whose sum is equal to the target value.\"\"\"\n    return nums\n\nassert f(g(), 9) == True\n",
        "idx_generation": 365,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the number of unique paths from the top-left cell to the bottom-right cell in an n x n grid\"\"\"\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][0] = 1\n        dp[0][i] = 1\n    \n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[n-1][n-1]\n\ndef g(n: int) -> int:\n    \"\"\"Return the value of n\"\"\"\n    return n\n\nassert f(g(3)) == 6\n",
        "idx_generation": 87,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Check if there exists a pair of numbers in the given list whose sum is equal to the target value.\n    Return True if such a pair exists, False otherwise.\n    \"\"\"\n\n    # Create a set to store the complement of each number encountered\n    complement_set = set()\n\n    for num in arr:\n        complement = target - num\n        if complement in complement_set:\n            return True\n        complement_set.add(num)\n\n    return False\n\ndef g():\n    arr = [2, 4, 6, 8]\n    target = 10\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 467,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of integers, determine if it is a magic square.\n    A magic square is a square matrix where the sums of each row, column, and diagonal are all equal.\n    \n    Return True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check columns\n    for j in range(n):\n        col_sum = 0\n        for i in range(n):\n            col_sum += matrix[i][j]\n        if col_sum != target_sum:\n            return False\n    \n    # Check diagonals\n    diagonal_sum = 0\n    anti_diagonal_sum = 0\n    for i in range(n):\n        diagonal_sum += matrix[i][i]\n        anti_diagonal_sum += matrix[i][n-i-1]\n    if diagonal_sum != target_sum or anti_diagonal_sum != target_sum:\n        return False\n    \n    return True\n\ndef g():\n    matrix = [[2, 7, 6],\n              [9, 5, 1],\n              [4, 3, 8]]\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 440,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> int:\n    \"\"\"Given an array of positive integers, return the maximum subarray XOR value.\n    The subarray must contain at least one element.\"\"\"\n    max_xor = 0\n    for i in range(len(arr)):\n        current_xor = 0\n        for j in range(i, len(arr)):\n            current_xor ^= arr[j]\n            max_xor = max(max_xor, current_xor)\n    return max_xor\n\ndef g():\n    return [4, 6, 8, 2, 10, 12, 14, 16]\n\nassert f(g()) == 30\n",
        "idx_generation": 134,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(string: str, pattern: str) -> List[int]:\n    \"\"\"\n    Given a string and a pattern, find all occurrences of the pattern within the string.\n    Return a list of indices where the pattern starts in the string.\n    \"\"\"\n    n, m = len(string), len(pattern)\n    indices = []\n    for i in range(n - m + 1):\n        j = 0\n        while j < m:\n            if string[i + j] != pattern[j]:\n                break\n            j += 1\n        if j == m:\n            indices.append(i)\n    return indices\n\ndef g(string: str, pattern: str) -> List[int]:\n    return f(string, pattern)\n\nstring = \"abababab\"\npattern = \"aba\"\nassert f(string, pattern) == g(string, pattern)\n",
        "idx_generation": 499,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Given a list of integers and a target number k, find if there are two distinct elements in the list whose sum is equal to k.\n    Return True if such elements exist, False otherwise.\n    \"\"\"\n    num_set = set()\n    for num in nums:\n        if k - num in num_set:\n            return True\n        num_set.add(num)\n    return False\n\ndef g(k: int):\n    nums = [1, 2, 3, 4, 5]\n    return nums, k\n\nassert f(*g(6))\n",
        "idx_generation": 124,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string of parentheses, determine if the parentheses are balanced.\"\"\"\n    stack = []\n    for char in s:\n        if char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\ndef g():\n    return \"()()((()))\"\nassert f(g())\n",
        "idx_generation": 21,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Find the minimum number of steps required to reach the target cell from the starting cell in a grid.\n    You can only move either up, down, left, or right and cannot visit the same cell twice.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = [(0, 0, 0)]  # (row, col, steps)\n    visited = set()\n    while queue:\n        row, col, steps = queue.pop(0)\n        if row == rows-1 and col == cols-1:\n            return steps\n        for dx, dy in directions:\n            new_row = row + dx\n            new_col = col + dy\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] != 'X' and (new_row, new_col) not in visited:\n                visited.add((new_row, new_col))\n                queue.append((new_row, new_col, steps+1))\n    return -1\n\ndef g():\n    return [\n        ['.', '.', '.', '.'],\n        ['.', 'X', '.', 'X'],\n        ['.', '.', '.', '.'],\n        ['.', 'X', '.', '.'],\n        ['.', '.', '.', '.']\n    ]\n\nassert f(g()) == 7\n",
        "idx_generation": 21,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(maze: List[List[int]]) -> bool:\n    \"\"\"Given a maze represented as a 2D grid where 0 represents an empty space and 1 represents a wall, check if there exists a path from the top-left corner to the bottom-right corner.\"\"\"\n    m, n = len(maze), len(maze[0])\n    stack = [(0, 0)]\n    visited = set()\n\n    while stack:\n        i, j = stack.pop()\n        if i == m - 1 and j == n - 1:\n            return True\n        visited.add((i, j))\n\n        neighbors = [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]\n        for x, y in neighbors:\n            if 0 <= x < m and 0 <= y < n and (x, y) not in visited and maze[x][y] == 0:\n                stack.append((x, y))\n\n    return False\n\ndef g():\n    return [[0, 0, 0, 0, 0],\n            [0, 1, 1, 1, 0],\n            [0, 0, 0, 0, 0],\n            [1, 1, 1, 1, 0],\n            [0, 0, 0, 0, 0]]\n\nassert f(g())\n",
        "idx_generation": 86,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> int:\n    \"\"\"Count the number of unique paths from the top-left corner to the bottom-right corner of an n x m grid.\n    You can only move down or right at each step.\"\"\"\n    if n == 1 or m == 1:\n        return 1\n    return f(n-1, m) + f(n, m-1)\n\ndef g(n: int, m: int) -> int:\n    \"\"\"Calculate the number of unique paths from the top-left corner to the bottom-right corner of an n x m grid.\"\"\"\n    dp = [[0] * m for _ in range(n)]\n    for i in range(n):\n        dp[i][0] = 1\n    for j in range(m):\n        dp[0][j] = 1\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    return dp[n-1][m-1]\n\nassert f(n=3, m=3) == g(n=3, m=3)\n",
        "idx_generation": 39,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given an integer n, find the number of unique paths in a grid of size n x n, from the top-left corner to the bottom-right corner.\n    You can only move down or right at each step.\"\"\"\n    def unique_paths_helper(i: int, j: int) -> int:\n        if i == n-1 and j == n-1:\n            return 1\n        if i >= n or j >= n:\n            return 0\n        return unique_paths_helper(i+1, j) + unique_paths_helper(i, j+1)\n    return unique_paths_helper(0, 0)\ndef g():\n    return 3\nassert f(g()) == 6\n",
        "idx_generation": 93,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if a string is a valid email address.\n    \"\"\"\n    import re\n    pattern = r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$'\n    return bool(re.match(pattern, s))\n\ndef g():\n    \"\"\"\n    Generate a random valid email address.\n    \"\"\"\n    import random\n    domain = random.choice(['gmail', 'yahoo', 'hotmail'])\n    extension = random.choice(['com', 'net', 'org'])\n    username = ''.join(random.choice('abcdefghijklmnopqrstuvwxyz') for _ in range(5))\n    return f\"{username}@{domain}.{extension}\"\n\nassert f(g())\n",
        "idx_generation": 409,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"Check if a string is a palindrome after removing n characters from it.\"\"\"\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    \n    stack = []\n    for char in s:\n        if stack and stack[-1] == char:\n            stack.pop()\n        else:\n            stack.append(char)\n            \n    return is_palindrome(\"\".join(stack[:n])) or is_palindrome(\"\".join(stack[:-n]))\n\ndef g(s: str, n: int):\n    return s\n\nassert f(g(\"racecar\", 2), 1)\n",
        "idx_generation": 1,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(string: str, pattern: str) -> bool:\n    \"\"\"Check if a given string matches a given pattern.\"\"\"\n    n = len(string)\n    m = len(pattern)\n    if n != m:\n        return False\n    mapping = {}\n    used = set()\n    for i in range(n):\n        if string[i] not in mapping and pattern[i] not in used:\n            mapping[string[i]] = pattern[i]\n            used.add(pattern[i])\n        elif mapping.get(string[i]) != pattern[i]:\n            return False\n    return True\n\ndef g(string: str, pattern: str) -> str:\n    \"\"\"Generate a string that matches the given pattern.\"\"\"\n    n = len(string)\n    m = len(pattern)\n    if n != m:\n        return \"\"\n    mapping = {}\n    for i in range(n):\n        if string[i] not in mapping:\n            mapping[string[i]] = pattern[i]\n    result = []\n    for char in string:\n        result.append(mapping[char])\n    return \"\".join(result)\n\nassert f(g(\"hello\", \"xyzzp\"), \"xyzzp\")\n",
        "idx_generation": 250,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[str]], word='PYTHON') -> bool:\n    \"\"\"Check if the word exists in the grid (horizontally, vertically, or diagonally)\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    for row in range(rows):\n        for col in range(cols):\n            if grid[row][col] == word[0]:\n                if check_horizontal(grid, row, col, word):\n                    return True\n                if check_vertical(grid, row, col, word):\n                    return True\n                if check_diagonal(grid, row, col, word):\n                    return True\n    return False\n\ndef check_horizontal(grid, row, col, word):\n    cols = len(grid[0])\n    if col + len(word) > cols:\n        return False\n    for i, char in enumerate(word):\n        if grid[row][col+i] != char:\n            return False\n    return True\n\ndef check_vertical(grid, row, col, word):\n    rows = len(grid)\n    if row + len(word) > rows:\n        return False\n    for i, char in enumerate(word):\n        if grid[row+i][col] != char:\n            return False\n    return True\n\ndef check_diagonal(grid, row, col, word):\n    rows = len(grid)\n    cols = len(grid[0])\n    if row + len(word) > rows or col + len(word) > cols:\n        return False\n    for i, char in enumerate(word):\n        if grid[row+i][col+i] != char:\n            return False\n    return True\n\ndef g(grid=[['P', 'Y', 'T', 'H', 'O', 'N'], ['A', 'B', 'C', 'D', 'E', 'F'], ['G', 'H', 'I', 'J', 'K', 'L']]):\n    return grid\n\nassert f(g())\n",
        "idx_generation": 118,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Determine if there exists a pair of numbers in an array whose sum is a power of 2.\n    Input: nums = [1, 2, 3, 4, 5, 6]\n    Output: True (1 + 7 = 8, which is a power of 2)\n    \"\"\"\n    def is_power_of_two(n: int) -> bool:\n        return n != 0 and (n & (n - 1)) == 0\n\n    seen = set()\n    for num in nums:\n        complement = 2 ** (len(bin(num)) - 2) - num\n        if complement in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g())\n",
        "idx_generation": 439,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list that XOR to a given target\"\"\"\n    target = 10\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] ^ nums[j] == target:\n                return True\n    return False\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5, 6, 7, 8, 9]):\n    return nums\n\nassert f(g())\n",
        "idx_generation": 82,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if it is possible to rearrange the elements of nums such that the bitwise XOR of any two adjacent elements is equal to the target value.\"\"\"\n    def backtrack(nums, target, visited, curr_xor, count):\n        if count == len(nums) - 1:\n            return curr_xor == target\n\n        for i in range(len(nums)):\n            if not visited[i]:\n                visited[i] = True\n                if backtrack(nums, target, visited, curr_xor ^ nums[i], count + 1):\n                    return True\n                visited[i] = False\n\n        return False\n\n    visited = [False] * len(nums)\n    return backtrack(nums, target, visited, 0, 0)\n\ndef g():\n    nums = [1, 2, 3, 4]\n    target = 5\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 498,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find n such that the binary representation of n is a palindrome.\"\"\"\n    return bin(n)[2:] == bin(n)[2:][::-1]\n\ndef g():\n    n = 1\n    while True:\n        if f(n):\n            return n\n        n += 1\n\nassert f(g()) == True",
        "idx_generation": 50,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Determine if there exists a subset of size k in the range [1, n] such that the sum of its elements is divisible by k.\"\"\"\n    def subset_sum(nums, k, target_sum, curr_sum, curr_index):\n        if curr_sum % k == 0 and curr_index == k:\n            return True\n        if curr_sum % k != 0 and curr_index == k:\n            return False\n        if curr_index >= len(nums):\n            return False\n        return subset_sum(nums, k, target_sum, curr_sum + nums[curr_index], curr_index + 1) or subset_sum(nums, k, target_sum, curr_sum, curr_index + 1)\n    \n    nums = list(range(1, n+1))\n    target_sum = sum(nums)\n    return subset_sum(nums, k, target_sum, 0, 0)\n\ndef g(n=10, k=3):\n    return n, k\n\nassert f(*g())\n",
        "idx_generation": 152,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the sum of all numbers in a grid that are divisible by 3\"\"\"\n    total = 0\n    for row in grid:\n        for num in row:\n            if num % 3 == 0:\n                total += num\n    return total\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 18\n\n",
        "idx_generation": 31,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Find the maximum value in a grid of integers by following a specific path\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    return find_max(matrix, rows - 1, cols - 1)\n\ndef find_max(matrix, i, j):\n    if i < 0 or j < 0:\n        return float('-inf')\n    if i == 0 and j == 0:\n        return matrix[i][j]\n    return matrix[i][j] + max(find_max(matrix, i - 1, j), find_max(matrix, i, j - 1))\n\ndef g(matrix: List[List[int]]) -> List[List[int]]:\n    return matrix\n\nmatrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\nassert f(g(matrix)) == 29\n",
        "idx_generation": 89,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int) -> bool:\n    \"\"\"Given a positive integer, check if it is a palindrome number.\n    A palindrome number is a number that remains the same when its digits are reversed.\n    Sample input:\n    121\n    Sample output:\n    True\"\"\"\n    if num < 0:\n        return False\n    temp = num\n    reverse = 0\n    while temp > 0:\n        remainder = temp % 10\n        reverse = reverse * 10 + remainder\n        temp = temp // 10\n    return num == reverse\n\ndef g():\n    return 121\n\nassert f(g())\n",
        "idx_generation": 123,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int) -> bool:\n    \"\"\"Given an integer, check if it is a power of two.\n    Sample input:\n    16\n    Sample output:\n    True\"\"\"\n    if num <= 0:\n        return False\n    while num % 2 == 0:\n        num //= 2\n    return num == 1\n\ndef g():\n    return 16\n\nassert f(g())\n",
        "idx_generation": 16,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if it is possible to reach the end of a maze starting from the top-left corner.\n    Return True if it is possible, and False otherwise.\"\"\"\n    \n    def dfs(grid: List[List[int]], row: int, col: int) -> bool:\n        \"\"\"Depth-first search to find a path in the maze.\"\"\"\n        \n        if row == len(grid) - 1 and col == len(grid[0]) - 1:\n            return True\n        \n        if row >= len(grid) or col >= len(grid[0]) or grid[row][col] == 1:\n            return False\n        \n        grid[row][col] = 1\n        \n        return dfs(grid, row + 1, col) or dfs(grid, row, col + 1) or dfs(grid, row - 1, col) or dfs(grid, row, col - 1)\n    \n    return dfs(grid, 0, 0)\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a random maze.\"\"\"\n    maze = [[0, 0, 1, 0, 0], [0, 0, 0, 0, 1], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0], [1, 1, 1, 0, 0]]\n    return maze\n\nassert f(g())",
        "idx_generation": 98,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid with '0' representing an empty cell, '1' representing a wall, and '9' representing the target, \n    determine if there exists a path from the top-left corner to the target, using only downwards and rightwards movements.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque([(0, 0)])\n    while queue:\n        x, y = queue.popleft()\n        if grid[x][y] == 9:\n            return True\n        if grid[x][y] == 1 or visited[x][y]:\n            continue\n        visited[x][y] = True\n        if x + 1 < rows:\n            queue.append((x + 1, y))\n        if y + 1 < cols:\n            queue.append((x, y + 1))\n    return False\n\ndef g():\n    return [[0, 1, 0],\n            [0, 1, 0],\n            [0, 0, 9]]\n\nassert f(g())\n",
        "idx_generation": 104,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], x: int, y: int, target: int) -> bool:\n    \"\"\"Check if there exists a path in the given grid starting from (x, y) and reaching a cell containing the target value.\"\"\"\n    def dfs(grid: List[List[int]], x: int, y: int, target: int) -> bool:\n        if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == -1:\n            return False\n        if grid[x][y] == target:\n            return True\n        temp = grid[x][y]\n        grid[x][y] = -1\n        if dfs(grid, x+1, y, target) or dfs(grid, x-1, y, target) or dfs(grid, x, y+1, target) or dfs(grid, x, y-1, target):\n            return True\n        grid[x][y] = temp\n        return False\n\n    return dfs(grid, x, y, target)\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    x, y = 0, 0\n    target = 9\n    return grid, x, y, target\n\nassert f(*g())\n",
        "idx_generation": 14,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool:\n    \"\"\"Given a grid filled with 0s and 1s, determine if there is a path from the start coordinate to the end coordinate.\n    You can only move to adjacent elements in the grid (up, down, left, or right). However, you can only move to a 0 element and not to a 1 element.\"\"\"\n    m, n = len(grid), len(grid[0])\n    visited = [[False] * n for _ in range(m)]\n    stack = [(start[0], start[1])]\n    \n    while stack:\n        x, y = stack.pop()\n        if (x, y) == end:\n            return True\n        visited[x][y] = True\n        \n        neighbors = [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]\n        for nx, ny in neighbors:\n            if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0:\n                stack.append((nx, ny))\n    \n    return False\n\ndef g(grid: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n    \"\"\"Find the coordinates of the start and end elements in the grid.\"\"\"\n    m, n = len(grid), len(grid[0])\n    start = (0, 0)\n    end = (m-1, n-1)\n    \n    return start, end\n\nassert f(grid=[[0, 0, 0], [1, 1, 0], [0, 0, 0]], start=g(grid=[[0, 0, 0], [1, 1, 0], [0, 0, 0]])[0], end=g(grid=[[0, 0, 0], [1, 1, 0], [0, 0, 0]])[1])\n",
        "idx_generation": 106,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of non-negative integers, find the minimum path sum from the top-left cell to the bottom-right cell.\n    You can only move down or to the right.\"\"\"\n    def min_path_sum(grid, i, j, memo):\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\n            return grid[i][j]\n        if i >= len(grid) or j >= len(grid[0]):\n            return float('inf')\n        if memo[i][j] != -1:\n            return memo[i][j]\n        down = min_path_sum(grid, i + 1, j, memo)\n        right = min_path_sum(grid, i, j + 1, memo)\n        memo[i][j] = grid[i][j] + min(down, right)\n        return memo[i][j]\n\n    m = len(grid)\n    n = len(grid[0])\n    memo = [[-1] * n for _ in range(m)]\n    return min_path_sum(grid, 0, 0, memo)\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 255,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(graph: List[List[int]], k: int, n: int) -> bool:\n    \"\"\"Given a graph with n nodes, determine if there exists a path of length k between any two nodes.\"\"\"\n    def dfs(node, path_length):\n        if path_length == k:\n            return True\n        for neighbor in graph[node]:\n            if dfs(neighbor, path_length + 1):\n                return True\n        return False\n    \n    for node in range(n):\n        if dfs(node, 0):\n            return True\n    return False\n\ndef g(n: int):\n    import random\n    graph = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if random.random() < 0.5:\n                graph[i].append(j)\n                graph[j].append(i)\n    return graph\n\nassert f(g(10), 3, 10)\n",
        "idx_generation": 352,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Find if there exists a path from the top-left corner to the bottom-right corner in the given grid.\"\"\"\n    def backtrack(grid, row, col, visited):\n        if row == len(grid) - 1 and col == len(grid[0]) - 1:\n            return True\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] == 1 or visited[row][col]:\n            return False\n        visited[row][col] = True\n        return (\n            backtrack(grid, row + 1, col, visited)\n            or backtrack(grid, row, col + 1, visited)\n            or backtrack(grid, row - 1, col, visited)\n            or backtrack(grid, row, col - 1, visited)\n        )\n\n    m, n = len(grid), len(grid[0])\n    visited = [[False] * n for _ in range(m)]\n    return backtrack(grid, 0, 0, visited)\n\ndef g(grid=[[0, 0, 0], [0, 1, 0], [0, 0, 0]]):\n    return grid\n\nassert f(g())\n",
        "idx_generation": 389,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=0) -> bool:\n    \"\"\"Find a combination of numbers in the list that adds up to the target.\"\"\"\n    stack = []\n    stack.append((0, 0))\n    while stack:\n        total, index = stack.pop()\n        if total == target:\n            return True\n        if index < len(nums):\n            stack.append((total + nums[index], index + 1))\n            stack.append((total, index + 1))\n    return False\n\ndef g(target=0):\n    nums = [1, 2, 3, 4, 5]\n    return f(nums, target)\n    \nassert f(g())\n",
        "idx_generation": 322,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[List[int]]:\n    \"\"\"Given a list of integers 'arr' and a target sum 'target', find all unique combinations of numbers in 'arr' that sum up to 'target'.\"\"\"\n    def backtrack(remaining, temp, start):\n        if sum(temp) == target:\n            result.append(temp[:])\n        elif sum(temp) > target:\n            return\n        else:\n            for i in range(start, len(remaining)):\n                temp.append(remaining[i])\n                backtrack(remaining, temp, i)\n                temp.pop()\n\n    result = []\n    backtrack(arr, [], 0)\n    return result\n\ndef g():\n    return [2, 3, 6, 7], 7\n\nassert f(*g()) == [[2, 2, 3], [7]]\n",
        "idx_generation": 469,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, words=['apple', 'banana', 'cherry', 'date', 'elderberry', 'fig', 'grape', 'honeydew', 'kiwi', 'lemon']) -> bool:\n    \"\"\"Check if a given string can be formed by concatenating words from a list.\"\"\"\n    def dp(i):\n        if i == len(s):\n            return True\n        if i in memo:\n            return memo[i]\n        for word in words:\n            if s.startswith(word, i) and dp(i + len(word)):\n                memo[i] = True\n                return True\n        memo[i] = False\n        return False\n    \n    memo = {}\n    return dp(0)\n\ndef g(words=['apple', 'banana', 'cherry', 'date', 'elderberry', 'fig', 'grape', 'honeydew', 'kiwi', 'lemon']):\n    \"\"\"Generate a string formed by concatenating words from a list.\"\"\"\n    return ''.join(words)\n\nassert f(g())\n",
        "idx_generation": 72,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the given array is a sorted array in descending order.\"\"\"\n    for i in range(len(arr) - 1):\n        if arr[i] < arr[i+1]:\n            return False\n    return True\n\ndef g(arr=[9, 8, 7, 6, 5, 4]):\n    \"\"\"Generate a sorted array in descending order.\"\"\"\n    return arr\n\nassert f(g())\n\n",
        "idx_generation": 149,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers and a target value, determine if there exists a pair of numbers in the array whose sum is equal to the target value.\n    Return True if such a pair exists, otherwise return False.\"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [2, 4, 6, 8, 10, 12, 14], 16\n\nassert f(*g())\n",
        "idx_generation": 46,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of 0s and 1s, find the maximum area of a rectangle that can be formed by connecting only the 1s.\n    Return the maximum area.\"\"\"\n    \n    def largest_rectangle_area(heights: List[int]) -> int:\n        \"\"\"Find the largest rectangle area in a histogram.\"\"\"\n        \n        stack = []\n        max_area = 0\n        i = 0\n        \n        while i < len(heights):\n            if not stack or heights[i] >= heights[stack[-1]]:\n                stack.append(i)\n                i += 1\n            else:\n                top = stack.pop()\n                area = heights[top] * (i - stack[-1] - 1 if stack else i)\n                max_area = max(max_area, area)\n        \n        while stack:\n            top = stack.pop()\n            area = heights[top] * (i - stack[-1] - 1 if stack else i)\n            max_area = max(max_area, area)\n        \n        return max_area\n    \n    max_area = 0\n    heights = [0] * len(grid[0])\n    \n    for row in grid:\n        for i in range(len(row)):\n            if row[i] == 0:\n                heights[i] = 0\n            else:\n                heights[i] += 1\n        \n        max_area = max(max_area, largest_rectangle_area(heights))\n    \n    return max_area\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a random grid of 0s and 1s.\"\"\"\n    grid = [[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]\n    return grid\n\nassert f(g()) == 6\n",
        "idx_generation": 98,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Given a matrix of integers and a target value, return True if the target value exists in the matrix, and False otherwise.\n    The matrix is sorted in non-decreasing order from left to right and top to bottom.\n    Sample Input:\n    matrix = [\n        [1, 4, 7, 11, 15],\n        [2, 5, 8, 12, 19],\n        [3, 6, 9, 16, 22],\n        [10, 13, 14, 17, 24],\n        [18, 21, 23, 26, 30]\n    ]\n    target = 14\n    Sample Output:\n    True\"\"\"\n    if not matrix or not matrix[0]:\n        return False\n    m, n = len(matrix), len(matrix[0])\n    row, col = m - 1, 0\n    while row >= 0 and col < n:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            col += 1\n        else:\n            row -= 1\n    return False\n    \ndef g(matrix=[[1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]], target=14):\n    return matrix, target\n\nassert f(*g())\n",
        "idx_generation": 10,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"Given a matrix of integers, return the spiral order traversal of the matrix.\"\"\"\n    result = []\n    if not matrix:\n        return result\n    top = 0\n    bottom = len(matrix) - 1\n    left = 0\n    right = len(matrix[0]) - 1\n    direction = 0\n    while top <= bottom and left <= right:\n        if direction == 0:\n            for i in range(left, right + 1):\n                result.append(matrix[top][i])\n            top += 1\n        elif direction == 1:\n            for i in range(top, bottom + 1):\n                result.append(matrix[i][right])\n            right -= 1\n        elif direction == 2:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n        else:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n        direction = (direction + 1) % 4\n    return result\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 400,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Find two numbers in the list that sum up to the target\"\"\"\n    num_set = set(nums)\n    for num in nums:\n        complement = target - num\n        if complement in num_set:\n            return True\n    return False\ndef g(target=10):\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9], target\nassert f(*g())\n",
        "idx_generation": 4,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum XOR value between two numbers in a given list of integers.\n\n    Args:\n        nums (List[int]): The list of integers.\n\n    Returns:\n        int: The maximum XOR value.\n\n    Example:\n        Input: nums = [3, 10, 5, 25, 2, 8]\n        Output: 28\n        Explanation: The maximum XOR value is obtained by XORing 5 and 25 (5 XOR 25 = 28).\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n        max_xor |= (1 << i)\n        for prefix in prefixes:\n            if (max_xor ^ prefix) in prefixes:\n                break\n        else:\n            max_xor ^= (1 << i)\n    return max_xor\n\ndef g(nums: List[int]) -> int:\n    return f(nums)\n\nnums = [3, 10, 5, 25, 2, 8]\nassert f(nums) == g(nums)\n",
        "idx_generation": 83,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target: int) -> List[Tuple[int, int]]:\n    \"\"\"Find the indices of all occurrences of a target number in the grid.\"\"\"\n    indices = []\n    for i in range(len(grid)):\n        for j in range(len(grid[i])):\n            if grid[i][j] == target:\n                indices.append((i, j))\n    return indices\n\ndef g(target: int):\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g(5), 5) == [(1, 1)]\n",
        "idx_generation": 242,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return the elements in spiral order.\n    \"\"\"\n    if not matrix:\n        return []\n\n    rows, cols = len(matrix), len(matrix[0])\n    top, bottom, left, right = 0, rows - 1, 0, cols - 1\n    spiral_order = []\n\n    while top <= bottom and left <= right:\n        # Traverse top row\n        for j in range(left, right + 1):\n            spiral_order.append(matrix[top][j])\n        top += 1\n\n        # Traverse right column\n        for i in range(top, bottom + 1):\n            spiral_order.append(matrix[i][right])\n        right -= 1\n\n        # Traverse bottom row\n        if top <= bottom:\n            for j in range(right, left - 1, -1):\n                spiral_order.append(matrix[bottom][j])\n            bottom -= 1\n\n        # Traverse left column\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                spiral_order.append(matrix[i][left])\n            left += 1\n\n    return spiral_order\n\ndef g(matrix: List[List[int]]) -> List[int]:\n    return f(matrix)\n\nmatrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\nassert f(matrix) == g(matrix)\n",
        "idx_generation": 499,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list whose XOR is equal to the target\"\"\"\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] ^ arr[j] == target:\n                return True\n    return False\n\ndef g(arr: List[int], target: int):\n    \"\"\"Return a list of numbers with the maximum possible XOR value\"\"\"\n    max_xor = 0\n    max_pair = []\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] ^ arr[j] > max_xor:\n                max_xor = arr[i] ^ arr[j]\n                max_pair = [arr[i], arr[j]]\n    return max_pair\n\n# Test the solution\narr = [1, 2, 3, 4, 5]\ntarget = 7\nassert f(g(arr, target), target)\n",
        "idx_generation": 45,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, check if the target value exists in the list.\n    Implement a binary search algorithm to solve this problem.\n    \"\"\"\n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return False\n\ndef g():\n    return [1, 3, 5, 7, 9, 11, 13], 7\n\nassert f(*g())\n",
        "idx_generation": 203,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, s: str) -> bool:\n    \"\"\"Check if the given number is a perfect square and if the given string is a palindrome.\"\"\"\n    is_perfect_square = n ** 0.5 == int(n ** 0.5)\n\n    is_palindrome = s == s[::-1]\n\n    return is_perfect_square and is_palindrome\n\ndef g():\n    n = 16\n    s = 'level'\n    return n, s\n\nassert f(*g())\n\n",
        "idx_generation": 415,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers `nums` and an integer `k`, \n    find if there exists two distinct indices i and j in the list\n    such that nums[i] - nums[j] = k.\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = 1\n    while right < len(nums):\n        diff = nums[right] - nums[left]\n        if diff == k:\n            return True\n        elif diff < k:\n            right += 1\n        else:\n            left += 1\n            if left == right:\n                right += 1\n    return False\n\ndef g(nums: List[int], k: int):\n    \"\"\"\n    Generate a list of integers `nums` and an integer `k`\n    such that there exists two distinct indices i and j in the list\n    such that nums[i] - nums[j] = k.\n    \"\"\"\n    nums.sort()\n    return nums, k\n\nassert f(*g([1, 5, 7, 9, 12, 15], 3))\n",
        "idx_generation": 77,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"Given a matrix of 0s and 1s, find the shortest distance from each cell to a nearest 0.\n    Return the resulting matrix.\n    \"\"\"\n    def updateMatrix(matrix):\n        if not matrix:\n            return matrix\n        \n        m, n = len(matrix), len(matrix[0])\n        queue = deque()\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    queue.append((i, j))\n                else:\n                    matrix[i][j] = float('inf')\n        \n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        \n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and matrix[nx][ny] > matrix[x][y] + 1:\n                    matrix[nx][ny] = matrix[x][y] + 1\n                    queue.append((nx, ny))\n\n        return matrix\n    \n    return updateMatrix(matrix)\n\ndef g():\n    matrix = [\n        [0, 0, 0],\n        [0, 1, 0],\n        [1, 1, 1]\n    ]\n    return matrix\n\nassert f(g()) == [[0, 0, 0], [0, 1, 0], [1, 2, 1]]\n",
        "idx_generation": 461,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Given a 2D grid of 0s and 1s, find the shortest path from the top-left corner to the bottom-right corner.\n    You can only move right or down.\n    Return the sum of the values along the shortest path.\n    Sample input:\n    matrix = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Sample output:\n    7\"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = matrix[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    return dp[m-1][n-1]\n\ndef g():\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n",
        "idx_generation": 48,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(points: List[List[int]]) -> int:\n    \"\"\"Given a list of 2D points, find the minimum distance between any two points in the list.\n    Return the minimum distance as an integer.\"\"\"\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n    \n    def closest_points(points):\n        n = len(points)\n        if n <= 3:\n            min_dist = float('inf')\n            for i in range(n-1):\n                for j in range(i+1, n):\n                    min_dist = min(min_dist, distance(points[i], points[j]))\n            return min_dist\n        mid = n // 2\n        mid_point = points[mid]\n        left_points = points[:mid]\n        right_points = points[mid:]\n        min_dist_left = closest_points(left_points)\n        min_dist_right = closest_points(right_points)\n        min_dist = min(min_dist_left, min_dist_right)\n        \n        strip_points = []\n        for point in points:\n            if abs(point[0] - mid_point[0]) < min_dist:\n                strip_points.append(point)\n        strip_points.sort(key=lambda x: x[1])\n        \n        strip_len = len(strip_points)\n        for i in range(strip_len):\n            j = i + 1\n            while j < strip_len and strip_points[j][1] - strip_points[i][1] < min_dist:\n                min_dist = min(min_dist, distance(strip_points[i], strip_points[j]))\n                j += 1\n        return min_dist\n    \n    points.sort()\n    return closest_points(points)\n\ndef g(points: List[List[int]]) -> int:\n    \"\"\"Generate a list of 2D points randomly.\"\"\"\n    return [[random.randint(0, 100), random.randint(0, 100)] for _ in range(points)]\n\nassert f(g(10)) >= 0\n",
        "idx_generation": 189,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of non-negative integers, find the path from the top left corner to the bottom right corner with the maximum sum.\n    You can only move down or right.\n    Return the maximum sum.\"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 12\n",
        "idx_generation": 436,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the size of the largest square subgrid where all elements are 1s.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    max_size = 0\n    \n    dp = [[0] * cols for _ in range(rows)]\n    \n    for i in range(rows):\n        dp[i][0] = grid[i][0]\n        max_size = max(max_size, dp[i][0])\n        \n    for j in range(cols):\n        dp[0][j] = grid[0][j]\n        max_size = max(max_size, dp[0][j])\n        \n    for i in range(1, rows):\n        for j in range(1, cols):\n            if grid[i][j] == 1:\n                dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1\n                max_size = max(max_size, dp[i][j])\n                \n    return max_size\n\ndef g(grid=[[1, 1, 0, 1], [1, 0, 1, 0], [0, 1, 1, 1], [1, 1, 1, 0]]):\n    \"\"\"\n    Generate a grid of random 0s and 1s where the largest square subgrid of 1s has a non-zero size.\n    \"\"\"\n    return grid\n\nassert f(g()) == 2\n",
        "idx_generation": 275,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there exists a pair of numbers in the list\n    whose sum is equal to the target number. Return True if such a pair exists, False otherwise.\n    \"\"\"\n    num_set = set()\n    for num in nums:\n        complement = target - num\n        if complement in num_set:\n            return True\n        num_set.add(num)\n    return False\n\ndef g(target: int) -> List[int]:\n    \"\"\"\n    Generate a list of integers that contains a pair whose sum is equal to the target number.\n    \"\"\"\n    return [1, target-1]\n\nassert f(g(5), 5) == True\n\n",
        "idx_generation": 315,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int, result: List[int]) -> bool:\n    \"\"\"Given a list of integers 'result' of size n, find if there exists k consecutive integers in the list.\"\"\"\n    for i in range(n - k + 1):\n        if result[i] + k - 1 == result[i + k - 1]:\n            return True\n    return False\n\ndef g(n: int, k: int) -> List[int]:\n    \"\"\"Generate a list of integers 'result' of size n where there exists k consecutive integers.\"\"\"\n    result = []\n    for i in range(n - k + 1):\n        result.extend(list(range(i, i + k)))\n    return result\n\nassert f(n=10, k=3, result=g(n=10, k=3))\n",
        "idx_generation": 39,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of integers, return True if it is a magic square, False otherwise.\n    A magic square is a square matrix where the sums of the numbers in each row, each column,\n    and both diagonals are the same.\n    \"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        col_sum = sum(matrix[i][col] for i in range(n))\n        if col_sum != target_sum:\n            return False\n    \n    # Check diagonal\n    diag_sum = sum(matrix[i][i] for i in range(n))\n    if diag_sum != target_sum:\n        return False\n    \n    # Check anti-diagonal\n    anti_diag_sum = sum(matrix[i][n-1-i] for i in range(n))\n    if anti_diag_sum != target_sum:\n        return False\n    \n    return True\n\ndef g():\n    matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    return matrix\n\nassert f(g()) == True\n",
        "idx_generation": 230,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers 'nums' and a target integer 'target',\n    determine if there exists a combination of elements in 'nums' that adds up to 'target'.\n    You can use each element in 'nums' only once.\"\"\"\n    stack = [(0, 0)]\n    while stack:\n        curr_sum, index = stack.pop()\n        if curr_sum == target:\n            return True\n        if index < len(nums):\n            stack.append((curr_sum + nums[index], index + 1))\n            stack.append((curr_sum, index + 1))\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5], 9\n\nassert f(*g())\n",
        "idx_generation": 459,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if the grid is a valid Sudoku solution\"\"\"\n    def check_unique(arr):\n        return len(arr) == len(set(arr))\n\n    def check_rows(grid):\n        for row in grid:\n            if not check_unique(row):\n                return False\n        return True\n\n    def check_columns(grid):\n        for col in range(len(grid)):\n            column = [grid[row][col] for row in range(len(grid))]\n            if not check_unique(column):\n                return False\n        return True\n\n    def check_subgrids(grid):\n        for row in range(0, len(grid), 3):\n            for col in range(0, len(grid), 3):\n                subgrid = [grid[i][j] for i in range(row, row + 3) for j in range(col, col + 3)]\n                if not check_unique(subgrid):\n                    return False\n        return True\n\n    return check_rows(grid) and check_columns(grid) and check_subgrids(grid)\n\ndef g(grid=[[5, 3, 4, 6, 7, 8, 9, 1, 2],\n            [6, 7, 2, 1, 9, 5, 3, 4, 8],\n            [1, 9, 8, 3, 4, 2, 5, 6, 7],\n            [8, 5, 9, 7, 6, 1, 4, 2, 3],\n            [4, 2, 6, 8, 5, 3, 7, 9, 1],\n            [7, 1, 3, 9, 2, 4, 8, 5, 6],\n            [9, 6, 1, 5, 3, 7, 2, 8, 4],\n            [2, 8, 7, 4, 1, 9, 6, 3, 5],\n            [3, 4, 5, 2, 8, 6, 1, 7, 9]]):\n    return grid\n\nassert f(g())",
        "idx_generation": 47,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a given string is a valid mathematical expression.\n    The expression can contain the following characters: digits 0-9, '+', '-', '*', '/', '(', ')'.\n    Sample input:\n    s = \"3 + 2 * (6 - 4)\"\n    Sample output:\n    True\n    \"\"\"\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g():\n    return \"3 + 2 * (6 - 4)\"\n\nassert f(g())\n",
        "idx_generation": 91,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number that appears only once. All other numbers appear twice.\n    \"\"\"\n    unique_num = 0\n    for num in nums:\n        unique_num ^= num\n    return unique_num\n\ndef g(nums=[1, 2, 3, 4, 1, 2, 3]):\n    \"\"\"\n    Generate a list of integers where all numbers appear twice, except for one number that appears only once.\n    \"\"\"\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 228,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if there is a subset of the given array whose XOR is equal to zero.\"\"\"\n    n = len(arr)\n    for i in range(1 << n):\n        subset = []\n        for j in range(n):\n            if (i & (1 << j)) != 0:\n                subset.append(arr[j])\n        xor = 0\n        for num in subset:\n            xor ^= num\n        if xor == 0:\n            return True\n    return False\n\ndef g():\n    return [3, 6, 9, 12, 15, 18, 21, 24, 27, 30]\n\nassert f(g())\n",
        "idx_generation": 108,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m=4, k=2) -> bool:\n    \"\"\"Check if the binary representation of n contains at least k consecutive 1's.\"\"\"\n    binary = bin(n)[2:]\n    return '1' * k in binary\ndef g(m=4, k=2):\n    return int('1' * (m - k) + '0' * k, 2)\nassert f(g())\n",
        "idx_generation": 148,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Given a list of integers, find the longest subarray where the sum of all elements is divisible by 4.\"\"\"\n    prefix_sum = 0\n    max_length = 0\n    prefix_sum_map = {0: -1}\n    \n    for i, num in enumerate(arr):\n        prefix_sum += num\n        remainder = prefix_sum % 4\n        if remainder in prefix_sum_map:\n            length = i - prefix_sum_map[remainder]\n            max_length = max(max_length, length)\n        else:\n            prefix_sum_map[remainder] = i\n    \n    return max_length >= 2\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == True\n",
        "idx_generation": 75,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> bool:\n    \"\"\"Given two positive integers n and m, determine if n is divisible by m without using the division operation.\n    Return True if n is divisible by m, False otherwise.\"\"\"\n    \n    if m == 0:\n        return False\n    \n    while n >= m:\n        n -= m\n    \n    return n == 0\n\ndef g(n=10, m=2):\n    return n, m\n\nassert f(*g())\n",
        "idx_generation": 158,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a subarray in a given array that sums up to the target value.\"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    for num in arr:\n        prefix_sum += num\n        if prefix_sum == target or prefix_sum - target in prefix_sums:\n            return True\n        prefix_sums.add(prefix_sum)\n    return False\n\ndef g(arr=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29], target=42):\n    \"\"\"Generate an array of integers and a target value.\"\"\"\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 72,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of integers, check if it is a magic square.\n    A magic square is a square matrix in which the sum of each row, each column, and both diagonals are equal.\"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        column_sum = sum(matrix[row][col] for row in range(n))\n        if column_sum != target_sum:\n            return False\n\n    # Check main diagonal\n    diagonal_sum = sum(matrix[i][i] for i in range(n))\n    if diagonal_sum != target_sum:\n        return False\n\n    # Check secondary diagonal\n    diagonal_sum = sum(matrix[i][n-i-1] for i in range(n))\n    if diagonal_sum != target_sum:\n        return False\n\n    return True\n\ndef g():\n    return [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n\nassert f(g())\n",
        "idx_generation": 3,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of 0s and 1s, find the largest square submatrix consisting of only 1s.\n    Return True if there is a square submatrix, False otherwise.\"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n    dp = [[0] * (n+1) for _ in range(m+1)]\n    max_side = 0\n\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if matrix[i-1][j-1] == 1:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n                max_side = max(max_side, dp[i][j])\n\n    return max_side > 0\n\ndef g():\n    return [[1, 1, 0, 0, 1],\n            [1, 1, 1, 1, 0],\n            [0, 1, 1, 1, 1],\n            [0, 1, 1, 1, 0],\n            [1, 0, 1, 0, 1]]\n\nassert f(g())\n",
        "idx_generation": 411,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list contains a duplicate element.\n    Sample Input:\n    nums = [1, 2, 3, 4, 5, 2]\n    Sample Output:\n    True\"\"\"\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5, 2]) -> List[int]:\n    \"\"\"Return the given list\"\"\"\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 95,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"Find a pair of elements in a given array that sum up to the target value.\"\"\"\n    complement = {}\n    for num in arr:\n        if num in complement:\n            return [complement[num], num]\n        else:\n            complement[target - num] = num\n    return []\n\ndef g(arr=[2, 7, 11, 15], target=9):\n    \"\"\"Generate an array of integers and a target value.\"\"\"\n    return arr, target\n\nassert f(*g()) == [2, 7]\n",
        "idx_generation": 103,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of any submatrix.\n    A submatrix is defined as a contiguous block of elements within the matrix.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    prefix_sum = [[0] * (cols + 1) for _ in range(rows + 1)]\n    max_sum = float('-inf')\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            prefix_sum[i][j] = prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1] + matrix[i - 1][j - 1]\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            for k in range(i, rows + 1):\n                for l in range(j, cols + 1):\n                    submatrix_sum = prefix_sum[k][l] - prefix_sum[i - 1][l] - prefix_sum[k][j - 1] + prefix_sum[i - 1][j - 1]\n                    max_sum = max(max_sum, submatrix_sum)\n    return max_sum\n\ndef g():\n    return [[1, 2, -1, -4, -20], \n            [-8, -3, 4, 2, 1], \n            [3, 8, 10, 1, 3], \n            [-4, -1, 1, 7, -6]]\n\nassert f(g()) == 29\n",
        "idx_generation": 199,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of non-negative integers, find the maximum XOR value between two elements in the list.\n    Return True if there exist two numbers in the list such that their XOR is equal to the maximum XOR value, otherwise return False.\n    Sample input:\n    [3, 10, 5, 25, 2, 8]\n    Sample output:\n    True\"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):  # Find the maximum XOR value bit by bit\n        mask |= (1 << i)\n        prefixes = set()\n        for num in nums:\n            prefixes.add(num & mask)\n        candidate = max_xor | (1 << i)\n        for prefix in prefixes:\n            if (prefix ^ candidate) in prefixes:\n                max_xor = candidate\n                break\n    return max_xor != 0\n\ndef g():\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == True\n",
        "idx_generation": 125,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Given an array of integers nums and an integer k, determine if there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.\"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        if num in num_dict and i - num_dict[num] <= k:\n            return True\n        num_dict[num] = i\n    return False\n\ndef g(nums=[1, 2, 3, 1], k=3):\n    return nums, k\n\nassert f(*g())\n",
        "idx_generation": 187,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of non-negative integers, find the minimum number of steps required to reach the bottom-right cell\n    starting from the top-left cell. You can only move down or right.\n    Sample Input:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n    Sample Output:\n    7\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    return dp[m - 1][n - 1]\n\ndef g(grid: List[List[int]]) -> int:\n    \"\"\"Find the minimum number of steps required to reach the bottom-right cell of a grid.\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    return dp[m - 1][n - 1]\n\nassert f(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]])\n",
        "idx_generation": 399,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of non-negative integers, determine if there exists a path from the top-left corner to the bottom-right corner\n    such that the sum of all numbers along the path is a prime number.\"\"\"\n    m, n = len(grid), len(grid[0])\n    visited = [[False] * n for _ in range(m)]\n    return dfs(grid, 0, 0, 0, visited)\n\ndef is_prime(n: int) -> bool:\n    \"\"\"Check if a number is prime.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef dfs(grid: List[List[int]], row: int, col: int, curr_sum: int, visited: List[List[bool]]) -> bool:\n    m, n = len(grid), len(grid[0])\n    \n    if row == m - 1 and col == n - 1:\n        return is_prime(curr_sum + grid[row][col])\n    \n    visited[row][col] = True\n    curr_sum += grid[row][col]\n    \n    for dx, dy in [(1, 0), (0, 1)]:\n        new_row, new_col = row + dx, col + dy\n        if 0 <= new_row < m and 0 <= new_col < n and not visited[new_row][new_col]:\n            if dfs(grid, new_row, new_col, curr_sum, visited):\n                return True\n    \n    visited[row][col] = False\n    return False\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"Generate a random 3x3 grid with non-negative integers.\"\"\"\n    return grid\n\nassert f(g([[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]))\n",
        "idx_generation": 229,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if the matrix is a magic square.\n    A magic square is a square matrix where the sum of each row, each column, and each diagonal is the same.\n    Return True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check columns\n    for j in range(n):\n        col_sum = 0\n        for i in range(n):\n            col_sum += matrix[i][j]\n        if col_sum != target_sum:\n            return False\n    \n    # Check diagonals\n    diagonal_sum1 = 0\n    diagonal_sum2 = 0\n    for i in range(n):\n        diagonal_sum1 += matrix[i][i]\n        diagonal_sum2 += matrix[i][n-i-1]\n    if diagonal_sum1 != target_sum or diagonal_sum2 != target_sum:\n        return False\n    \n    return True\n\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a 3x3 magic square.\n    \"\"\"\n    return [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n\nassert f(g()) == True\n",
        "idx_generation": 449,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], k: int) -> bool:\n    \"\"\"Determine if there exists a submatrix with a sum of elements equal to k\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    prefix_sum = [[0] * (cols + 1) for _ in range(rows + 1)]\n\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            prefix_sum[i][j] = prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1] + matrix[i - 1][j - 1]\n\n    for r1 in range(rows):\n        for r2 in range(r1 + 1, rows + 1):\n            for c1 in range(cols):\n                for c2 in range(c1 + 1, cols + 1):\n                    submatrix_sum = prefix_sum[r2][c2] - prefix_sum[r1][c2] - prefix_sum[r2][c1] + prefix_sum[r1][c1]\n                    if submatrix_sum == k:\n                        return True\n\n    return False\n\ndef g(k: int):\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g(12), 12) == True\n",
        "idx_generation": 456,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of positive integers and a target number, determine if it is possible to obtain the target number by performing the following operations:\n    - Choose any two numbers from the list\n    - Perform one of the following operations: addition, subtraction, multiplication, or division\n    - Replace the two chosen numbers with the result of the operation\n    Return True if it is possible to obtain the target number, and False otherwise.\n    Sample Input:\n    nums = [2, 4, 6, 8]\n    target = 12\n    Sample Output:\n    True\"\"\"\n    if target == 0:\n        return True\n    if not nums:\n        return False\n    for i in range(len(nums)):\n        remaining_nums = nums[:i] + nums[i+1:]\n        if f(remaining_nums, target - nums[i]) or f(remaining_nums, target + nums[i]) or f(remaining_nums, target * nums[i]) or (nums[i] != 0 and target % nums[i] == 0 and f(remaining_nums, target // nums[i])):\n            return True\n    return False\n\ndef g():\n    return [2, 4, 6, 8], 12\n\nassert f(*g())\n",
        "idx_generation": 476,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], k=3) -> bool:\n    \"\"\"Given a list of integers and a window size k, find the maximum element in each window of size k.\"\"\"\n    n = len(arr)\n    result = []\n    stack = []\n    for i in range(n):\n        while stack and arr[i] >= arr[stack[-1]]:\n            stack.pop()\n        stack.append(i)\n        if i - stack[0] >= k:\n            stack.pop(0)\n        if i >= k - 1:\n            result.append(arr[stack[0]])\n    return result\ndef g(k=3):\n    return [4, 3, 5, 4, 3, 6, 7]\nassert f(g()) == [5, 5, 5, 6, 7]\n",
        "idx_generation": 21,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given an integer n, find the nth Fibonacci number using dynamic programming.\"\"\"\n    if n <= 0:\n        return False\n    fib = [0, 1]\n    for i in range(2, n+1):\n        fib.append(fib[i-1] + fib[i-2])\n    return fib[n]\ndef g():\n    return 8\nassert f(g()) == 21\n",
        "idx_generation": 25,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid represented as a 2D array of 0s and 1s, check if there exists a path from the top-left corner to the bottom-right corner.\n    Additionally, you can only move in horizontal and vertical directions.\"\"\"\n    m, n = len(grid), len(grid[0])\n    stack = [(0, 0)]\n    visited = set()\n\n    while stack:\n        i, j = stack.pop()\n        if i == m - 1 and j == n - 1:\n            return True\n        visited.add((i, j))\n\n        neighbors = [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]\n        for x, y in neighbors:\n            if 0 <= x < m and 0 <= y < n and (x, y) not in visited and grid[x][y] == 0:\n                stack.append((x, y))\n\n    return False\n\ndef g():\n    return [[0, 0, 0, 0, 0],\n            [0, 1, 1, 1, 0],\n            [0, 1, 0, 0, 0],\n            [0, 1, 1, 1, 1],\n            [0, 0, 0, 0, 0]]\n\nassert f(g())\n\n",
        "idx_generation": 149,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of non-negative integers, find the maximum score you can achieve by summing the values along a path from the top-left to the bottom-right corner of the grid.\n    You can only move down or right.\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[m-1][n-1]\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    return grid\n\nassert f(g([[1,3,1],[1,5,1],[4,2,1]])) == 12\n",
        "idx_generation": 43,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool:\n    \"\"\"Given a grid filled with 0s and 1s, determine if there is a path from the start coordinate to the end coordinate.\n    You can only move to adjacent elements in the grid (up, down, left, or right). However, you can only move to a 0 element and not to a 1 element.\n    Additionally, you can only move in a clockwise or counterclockwise direction in the grid, but not in a straight line.\"\"\"\n    m, n = len(grid), len(grid[0])\n    visited = [[False] * n for _ in range(m)]\n    stack = [(start[0], start[1])]\n    \n    while stack:\n        x, y = stack.pop()\n        if (x, y) == end:\n            return True\n        visited[x][y] = True\n        \n        neighbors = [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]\n        for nx, ny in neighbors:\n            if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0:\n                stack.append((nx, ny))\n    \n    return False\n\ndef g(grid: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n    \"\"\"Find the coordinates of the start and end elements in the grid.\"\"\"\n    m, n = len(grid), len(grid[0])\n    start = (0, 0)\n    end = (m-1, n-1)\n    \n    return start, end\n\nassert f(grid=[[0, 1, 0], [0, 0, 0], [1, 0, 0]], start=g(grid=[[0, 1, 0], [0, 0, 0], [1, 0, 0]])[0], end=g(grid=[[0, 1, 0], [0, 0, 0], [1, 0, 0]])[1])\n",
        "idx_generation": 106,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(s: str) -> bool:\n    \"\"\"Check if a given string is a palindrome using a stack and a queue.\n    Return True if it is a palindrome, False otherwise.\"\"\"\n    stack = []\n    queue = deque()\n    for char in s:\n        if char.isalnum():\n            stack.append(char.lower())\n            queue.append(char.lower())\n    while stack and queue:\n        if stack.pop() != queue.popleft():\n            return False\n    return True\n\ndef g(s: str):\n    return s\n\nassert f(g(\"A man, a plan, a canal: Panama\"))\n",
        "idx_generation": 41,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string s, determine if it is a palindrome after removing exactly one character.\n    Return True if it is possible to make s a palindrome, False otherwise.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    \n    n = len(s)\n    left, right = 0, n - 1\n    \n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s[left:right]) or is_palindrome(s[left+1:right+1])\n        left += 1\n        right -= 1\n    \n    return True\n\ndef g():\n    s = \"raceecar\"\n    return s\n\nassert f(g())\n",
        "idx_generation": 256,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int) -> bool:\n    \"\"\"Check if a number is a power of two\"\"\"\n    return num > 0 and (num & (num - 1)) == 0\n\ndef g(num=16):\n    return f(num)\n\nassert f(g())\n",
        "idx_generation": 2,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the given list whose bitwise XOR is equal to k.\"\"\"\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] ^ arr[j] == k:\n                return True\n    return False\n\ndef g():\n    arr = [2, 5, 8, 10, 12]\n    k = 6\n    return arr, k\n\nassert f(*g())\n",
        "idx_generation": 459,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the binary representation of n is a palindrome.\"\"\"\n    binary = bin(n)[2:]\n    return binary == binary[::-1]\n\ndef g():\n    n = 10\n    while True:\n        if f(n):\n            return n\n        n += 1\n\nassert f(g()) == True\n",
        "idx_generation": 120,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(x: int, y: int) -> bool:\n    \"\"\"Check if the binary representation of x is a substring of the binary representation of y.\"\"\"\n    binary_x = bin(x)[2:]\n    binary_y = bin(y)[2:]\n    return binary_x in binary_y\n\ndef g():\n    \"\"\"Find two numbers that satisfy the condition of the puzzle.\"\"\"\n    for x in range(1, 100):\n        for y in range(1, 100):\n            if f(x, y):\n                return x, y\n\nassert f(*g())\n",
        "idx_generation": 63,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Return the nth Fibonacci number using dynamic programming.\n    The Fibonacci sequence starts with 0 and 1, where each subsequent number is the sum of the two previous numbers.\"\"\"\n    memo = {}\n\n    def fib(n):\n        if n in memo:\n            return memo[n]\n        if n <= 1:\n            return n\n        memo[n] = fib(n - 1) + fib(n - 2)\n        return memo[n]\n\n    return fib(n)\n\ndef g():\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 273,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of numbers, find if there exists a path from the top-left corner to the bottom-right corner\n    where the sum of the numbers along the path is a prime number.\"\"\"\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def dfs(row, col, path_sum):\n        if row == len(grid) - 1 and col == len(grid[0]) - 1:\n            if is_prime(path_sum + grid[row][col]):\n                return True\n            else:\n                return False\n        if row < len(grid) - 1:\n            if dfs(row + 1, col, path_sum + grid[row][col]):\n                return True\n        if col < len(grid[0]) - 1:\n            if dfs(row, col + 1, path_sum + grid[row][col]):\n                return True\n        return False\n\n    return dfs(0, 0, 0)\n\ndef g():\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 114,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> bool:\n    \"\"\"Check if n is a power of 2 and m is a multiple of 4\"\"\"\n    return n & (n - 1) == 0 and m % 4 == 0\n\ndef g(n=16, m=12):\n    return n, m\n\nassert f(*g())\n",
        "idx_generation": 47,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(graph: List[List[int]], n=5) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, determine if there exists a Hamiltonian path.\n    A Hamiltonian path is a path in a graph that visits each vertex exactly once.\n    The solution is a boolean indicating whether a Hamiltonian path exists in the given graph.\n    \"\"\"\n    def backtrack(v, visited):\n        visited[v] = True\n        if len(visited) == n:\n            return True\n        for i in range(n):\n            if graph[v][i] == 1 and not visited[i]:\n                if backtrack(i, visited):\n                    return True\n        visited[v] = False\n        return False\n\n    visited = [False] * n\n    for i in range(n):\n        if backtrack(i, visited):\n            return True\n    return False\n\ndef g(n=5):\n    graph = [[0, 1, 1, 0, 1],\n             [1, 0, 1, 1, 0],\n             [1, 1, 0, 1, 0],\n             [0, 1, 1, 0, 1],\n             [1, 0, 0, 1, 0]]\n    return graph\n\nassert f(g())\n",
        "idx_generation": 42,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of 1s and 0s, determine if there exists a path from the top-left corner to the bottom-right corner. You can only move down or right. Additionally, you can only move through the cells with a value of 0.\"\"\"\n    m, n = len(grid), len(grid[0])\n    stack = [(0, 0)]\n    visited = set()\n\n    while stack:\n        i, j = stack.pop()\n        if i == m - 1 and j == n - 1:\n            return True\n        visited.add((i, j))\n\n        neighbors = [(i + 1, j), (i, j + 1)]\n        for x, y in neighbors:\n            if 0 <= x < m and 0 <= y < n and (x, y) not in visited and grid[x][y] == 0:\n                stack.append((x, y))\n\n    return False\n\ndef g():\n    return [[0, 0, 0, 0],\n            [0, 1, 1, 0],\n            [0, 0, 0, 0],\n            [1, 1, 0, 0],\n            [0, 0, 0, 0]]\n\nassert f(g())\n",
        "idx_generation": 303,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[str]]) -> List[str]:\n    \"\"\"Given a grid of strings, concatenate all the strings in the grid in a clockwise spiral order.\"\"\"\n    result = []\n    if not grid or not grid[0]:\n        return result\n    m, n = len(grid), len(grid[0])\n    top, bottom, left, right = 0, m - 1, 0, n - 1\n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            result.append(grid[top][i])\n        top += 1\n        for i in range(top, bottom + 1):\n            result.append(grid[i][right])\n        right -= 1\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result.append(grid[bottom][i])\n            bottom -= 1\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(grid[i][left])\n            left += 1\n    return result\n\ndef g():\n    return [['A', 'B', 'C', 'D'],\n            ['E', 'F', 'G', 'H'],\n            ['I', 'J', 'K', 'L'],\n            ['M', 'N', 'O', 'P']]\n\nassert f(g()) == ['A', 'B', 'C', 'D', 'H', 'L', 'P', 'O', 'N', 'M', 'I', 'E', 'F', 'G', 'K', 'J']\n",
        "idx_generation": 278,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a 2D grid of integers, find the length of the longest increasing path.\n    A path is considered increasing if each cell in the path is greater than the previous cell.\n    Return the length of the longest increasing path.\"\"\"\n    if not grid:\n        return 0\n    \n    m, n = len(grid), len(grid[0])\n    memo = [[0] * n for _ in range(m)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    def dfs(i: int, j: int) -> int:\n        if memo[i][j] != 0:\n            return memo[i][j]\n        \n        length = 1\n        for dx, dy in directions:\n            ni, nj = i + dx, j + dy\n            if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] > grid[i][j]:\n                length = max(length, 1 + dfs(ni, nj))\n        \n        memo[i][j] = length\n        return length\n    \n    max_length = 0\n    for i in range(m):\n        for j in range(n):\n            max_length = max(max_length, dfs(i, j))\n    \n    return max_length\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a random 2D grid of integers.\"\"\"\n    grid = [[9, 8, 7], [5, 6, 7], [1, 2, 3]]\n    return grid\n\nassert f(g()) == 5\n",
        "idx_generation": 32,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid filled with 0s and 1s, determine if it is possible to flip all the 1s to 0s by performing the following operations:\n    - Flip a single cell from 1 to 0\n    - Flip all the cells in the same row and column as the flipped cell to their opposite value\"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    \n    def flip(row, col):\n        for i in range(n):\n            grid[i][col] = 1 - grid[i][col]\n        for j in range(m):\n            grid[row][j] = 1 - grid[row][j]\n        grid[row][col] = 0\n    \n    def check_all_zeros():\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    return False\n        return True\n    \n    def backtrack(row, col):\n        if row == n:\n            return check_all_zeros()\n        if col == m:\n            return backtrack(row + 1, 0)\n        if grid[row][col] == 0:\n            return backtrack(row, col + 1)\n        \n        flip(row, col)\n        if backtrack(row, col + 1):\n            return True\n        flip(row, col)\n        \n        return backtrack(row, col + 1)\n    \n    return backtrack(0, 0)\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"Return the grid after flipping the cells\"\"\"\n    return grid\n\nassert f(g(grid=[[1, 1, 0], [0, 1, 1], [1, 0, 0]]))\n",
        "idx_generation": 107,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers 'nums' and a target integer 'target',\n    determine if there exists a combination of elements in 'nums' that adds up to 'target'.\n    You can use each element in 'nums' only once.\"\"\"\n    nums.sort()\n    stack = [(0, 0)]\n    while stack:\n        curr_sum, index = stack.pop()\n        if curr_sum == target:\n            return True\n        if index < len(nums):\n            stack.append((curr_sum + nums[index], index + 1))\n            stack.append((curr_sum, index + 1))\n    return False\n\ndef g():\n    return [1, 3, 4, 8, 6], 9\n\nassert f(*g())\n",
        "idx_generation": 498,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, word: str) -> bool:\n    \"\"\"Given a string 's' and a word 'word', determine if the word can be formed by concatenating the characters from 's' in any order. You can use each character in 's' only once.\"\"\"\n    queue = [(\"\", s)]\n    while queue:\n        curr_word, remaining = queue.pop(0)\n        if curr_word == word:\n            return True\n        for i in range(len(remaining)):\n            new_word = curr_word + remaining[i]\n            new_remaining = remaining[:i] + remaining[i+1:]\n            queue.append((new_word, new_remaining))\n    return False\n\ndef g():\n    return \"abracadabra\", \"radar\"\n\nassert f(*g())\n",
        "idx_generation": 320,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target: int) -> bool:\n    \"\"\"Check if it is possible to evaluate the expression s to the target value by inserting '+' or '-' operators between the digits.\"\"\"\n    def evaluate(expression):\n        stack = []\n        num = 0\n        operator = '+'\n\n        for i in range(len(expression)):\n            char = expression[i]\n            if char.isdigit():\n                num = num * 10 + int(char)\n            if i == len(expression) - 1 or char in ['+', '-']:\n                if operator == '+':\n                    stack.append(num)\n                else:\n                    stack.append(-num)\n                num = 0\n                operator = char\n\n        return sum(stack)\n\n    def backtrack(expression, index):\n        if index == len(s):\n            if evaluate(expression) == target:\n                return True\n            return False\n\n        if backtrack(expression + s[index], index + 1):\n            return True\n\n        if backtrack(expression + '+' + s[index], index + 1):\n            return True\n\n        if backtrack(expression + '-' + s[index], index + 1):\n            return True\n\n        return False\n\n    return backtrack('', 0)\n\ndef g():\n    s = \"123\"\n    target = 6\n    return s, target\n\nassert f(*g())\n",
        "idx_generation": 103,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Check if there exists a combination of k numbers from the range 1 to n (inclusive) such that the sum of the numbers is divisible by k.\n    Sample input:\n    n = 6, k = 3\n    Sample output:\n    True\n    Explanation: The combination [1, 2, 3] has a sum of 6, which is divisible by 3.\n    \"\"\"\n    def combination_sum(nums, target, k):\n        if k == 0:\n            return target == 0\n        if not nums or target < 0:\n            return False\n        return combination_sum(nums[1:], target - nums[0], k - 1) or combination_sum(nums[1:], target, k)\n    \n    nums = list(range(1, n + 1))\n    return combination_sum(nums, sum(nums) // k, k)\n\ndef g():\n    return 6, 3\n\nassert f(*g())\n",
        "idx_generation": 54,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k=3) -> bool:\n    \"\"\"Find n such that n can be expressed as a sum of k consecutive integers.\"\"\"\n    i = 1\n    while k * (i + i + k - 1) // 2 <= n:\n        if n % i == 0 and n // i - i + 1 >= k and (n // i - i + 1) % 2 == 0:\n            return True\n        i += 1\n    return False\ndef g(k=3):\n    return 12\nassert f(g())\n",
        "idx_generation": 64,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers, find the index of the target value using binary search.\n    Return -1 if the target value is not found.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers.\n    \"\"\"\n    nums = [-5, -2, 0, 1, 3, 4, 7, 9]\n    return nums\n\nassert f(g(), 4) == 5\n",
        "idx_generation": 267,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(numbers: List[int]) -> List[int]:\n    \"\"\"Sort a list of integers using stack and queue data structures.\"\"\"\n    stack = []\n    queue = []\n    for num in numbers:\n        stack.append(num)\n    while stack:\n        min_num = stack.pop()\n        while queue and queue[-1] > min_num:\n            stack.append(queue.pop())\n        queue.append(min_num)\n    return queue\n\ndef g():\n    \"\"\"Generate a list of integers for sorting.\"\"\"\n    return [5, 2, 8, 1, 9]\n\nassert f(g()) == [1, 2, 5, 8, 9]\n",
        "idx_generation": 74,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string s containing only the characters '(', ')', '{', '}', '[' and ']', determine if it is valid.\n    A string is valid if all the opening brackets are closed in the correct order.\"\"\"\n    stack = []\n    opening = ['(', '{', '[']\n    closing = [')', '}', ']']\n    \n    for char in s:\n        if char in opening:\n            stack.append(char)\n        elif char in closing:\n            if not stack:\n                return False\n            if opening.index(stack[-1]) != closing.index(char):\n                return False\n            stack.pop()\n    \n    return len(stack) == 0\n\ndef g(s: str) -> str:\n    \"\"\"Return the string s\"\"\"\n    return s\n\nassert f(g(s=\"(){}[]\"))\n",
        "idx_generation": 107,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> bool:\n    \"\"\"Determine if a set of points forms a convex polygon.\"\"\"\n    if len(points) < 3:\n        return False\n    n = len(points)\n    direction = None\n    for i in range(n):\n        x1, y1 = points[i]\n        x2, y2 = points[(i+1) % n]\n        x3, y3 = points[(i+2) % n]\n        cross_product = (x2-x1)*(y3-y2) - (y2-y1)*(x3-x2)\n        if cross_product == 0:\n            continue\n        if direction is None:\n            direction = cross_product > 0\n        elif direction != (cross_product > 0):\n            return False\n    return True\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a set of points that form a convex polygon.\"\"\"\n    points = [[0, 0], [1, 0], [1, 1], [0, 1]]\n    return points\n\nassert f(g())\n",
        "idx_generation": 107,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string contains valid parentheses.\n    Sample Input:\n    s = \"((()))\"\n    Sample Output:\n    True\"\"\"\n    stack = []\n    opening = set(['(', '{', '['])\n    closing = set([')', '}', ']'])\n    pairs = {'(': ')', '{': '}', '[': ']'}\n    for char in s:\n        if char in opening:\n            stack.append(char)\n        elif char in closing:\n            if not stack or pairs[stack.pop()] != char:\n                return False\n    return len(stack) == 0\n\ndef g(s=\"((()))\"):\n    \"\"\"Return the given string\"\"\"\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 59,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"Check if a given string can be segmented into space-separated words from a given word dictionary.\n\n    Args:\n        s (str): The input string.\n        words (List[str]): The word dictionary.\n\n    Returns:\n        bool: True if the string can be segmented into words, False otherwise.\n\n    Example:\n        Input: s = \"applepenapple\", words = [\"apple\", \"pen\"]\n        Output: True\n        Explanation: The string can be segmented into \"apple pen apple\".\n    \"\"\"\n    n = len(s)\n    dp = [False] * (n + 1)\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for word in words:\n            if i >= len(word) and s[i - len(word):i] == word:\n                dp[i] = dp[i] or dp[i - len(word)]\n\n    return dp[n]\n\ndef g(s: str, words: List[str]) -> bool:\n    return f(s, words)\n\ns = \"applepenapple\"\nwords = [\"apple\", \"pen\"]\nassert f(s, words) == g(s, words)\n",
        "idx_generation": 83,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, check if there exists a subarray with a sum of zero.\"\"\"\n    prefix_sum = 0\n    prefix_sum_set = set()\n\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum == 0 or prefix_sum in prefix_sum_set:\n            return True\n        prefix_sum_set.add(prefix_sum)\n    \n    return False\n\ndef g():\n    return [4, 2, -3, 1, 6]\n\nassert f(g()) == True\n\n",
        "idx_generation": 110,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given an array of integers 'arr' and a target value 'target', determine if there exist two distinct indices i and j,\n    such that arr[i] ^ arr[j] == target, where '^' denotes the bitwise XOR operation.\"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] ^ arr[j] == target:\n                return True\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g(), 5)\n",
        "idx_generation": 49,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if it is possible to find two numbers in the list\n    that add up to the target number.\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5], target=9):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 227,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(points: List[Tuple[int, int]]) -> bool:\n    \"\"\"Determine if the given points form a square.\n    The input is a list of tuples representing the (x, y) coordinates of the points.\n    Return True if the points form a square, and False otherwise.\"\"\"\n    \n    def distance(p1, p2):\n        return math.sqrt((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2)\n    \n    if len(points) != 4:\n        return False\n    \n    distances = set()\n    \n    for i in range(len(points)):\n        for j in range(i+1, len(points)):\n            distances.add(distance(points[i], points[j]))\n            \n    return len(distances) == 2\n\ndef g():\n    return [(0, 0), (0, 1), (1, 1), (1, 0)]\n\nassert f(g())\n",
        "idx_generation": 13,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if there exists a pair of numbers in the list whose sum is equal to the target.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    nums = [1, 4, 2, 8, 5, 3]\n    target = 10\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 136,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if it is possible to reach the bottom-right cell from the top-left cell in the given grid, while avoiding obstacles.\"\"\"\n    m, n = len(grid), len(grid[0])\n    if grid[0][0] == 1 or grid[m - 1][n - 1] == 1:\n        return False\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                continue\n            if i > 0:\n                dp[i][j] += dp[i - 1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j - 1]\n    return dp[m - 1][n - 1] > 0\n\ndef g():\n    return [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n\nassert f(g())\n",
        "idx_generation": 28,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target=5) -> bool:\n    \"\"\"Given a grid of 0s and 1s, determine if it is possible to reach the target by starting at the top-left corner (0, 0) and moving to the bottom-right corner (n-1, m-1),\n    moving only down or right. 0 represents an empty cell and 1 represents an obstacle.\n    Sample input:\n    [[0, 1, 0, 0],\n     [0, 0, 1, 0],\n     [1, 0, 0, 0],\n     [0, 1, 1, 0]]\n    Sample output:\n    True\"\"\"\n    n, m = len(grid), len(grid[0])\n    dp = [[False] * m for _ in range(n)]\n    dp[0][0] = True\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                continue\n            if i > 0:\n                dp[i][j] = dp[i][j] or dp[i-1][j]\n            if j > 0:\n                dp[i][j] = dp[i][j] or dp[i][j-1]\n    return dp[n-1][m-1]\ndef g():\n    return [[0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [1, 0, 0, 0],\n            [0, 1, 1, 0]]\nassert f(g())\n",
        "idx_generation": 72,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of 0s and 1s, determine if it is possible to reach the bottom-right corner from the top-left corner, only moving right, down, or diagonally down-right. The path must go through the 1s and avoid the 0s.\"\"\"\n    m, n = len(grid), len(grid[0])\n    stack = [(0, 0)]\n    visited = set()\n    while stack:\n        i, j = stack.pop()\n        if (i, j) == (m-1, n-1):\n            return True\n        visited.add((i, j))\n        if i+1 < m and grid[i+1][j] == 1 and (i+1, j) not in visited:\n            stack.append((i+1, j))\n        if j+1 < n and grid[i][j+1] == 1 and (i, j+1) not in visited:\n            stack.append((i, j+1))\n        if i+1 < m and j+1 < n and grid[i+1][j+1] == 1 and (i+1, j+1) not in visited:\n            stack.append((i+1, j+1))\n    return False\n\ndef g():\n    grid = [\n        [1, 1, 1, 0, 0],\n        [0, 1, 1, 1, 0],\n        [1, 0, 0, 1, 1],\n        [1, 1, 1, 1, 1]\n    ]\n    return grid\n\nassert f(g())\n",
        "idx_generation": 417,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a subarray in a given array that sums up to the target value.\"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    for num in arr:\n        prefix_sum += num\n        if prefix_sum == target or prefix_sum - target in prefix_sums:\n            return True\n        prefix_sums.add(prefix_sum)\n    return False\n\ndef g(arr=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29], target=42):\n    \"\"\"Generate an array of integers and a target value.\"\"\"\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 103,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"Given a matrix of integers, return a list containing the values in the matrix obtained by traversing it in a spiral order.\"\"\"\n    result = []\n    m = len(matrix)\n    n = len(matrix[0])\n    top, bottom, left, right = 0, m-1, 0, n-1\n\n    while top <= bottom and left <= right:\n        for i in range(left, right+1):\n            result.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom+1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        if top <= bottom:\n            for i in range(right, left-1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left <= right:\n            for i in range(bottom, top-1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result\n\ndef g():\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 234,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport collections\n\ndef f(n: int, nums: List[int]) -> bool:\n    \"\"\"Given a list of integers 'nums' of size n, determine if there exists a subarray of length at least 2 where the sum of the subarray is divisible by n.\"\"\"\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = (prefix_sum[i - 1] + nums[i - 1]) % n\n    \n    count = collections.Counter(prefix_sum)\n    \n    for val in count.values():\n        if val >= 2:\n            return True\n    \n    return False\n\ndef g(n: int, nums: List[int]) -> List[int]:\n    \"\"\"Generate a list of integers 'nums' of size n where there exists a subarray of length at least 2 where the sum of the subarray is divisible by n.\"\"\"\n    nums.append(0)\n    return nums\n\nassert f(n=5, nums=g(n=5, nums=[1, 2, 3, 4, 1]))\n",
        "idx_generation": 96,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if a given matrix is a magic square.\n    A magic square is a square matrix in which the sum of every row, every column, and both diagonals is the same.\n    Return True if the matrix is a magic square, False otherwise.\"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check columns\n    for j in range(n):\n        col_sum = 0\n        for i in range(n):\n            col_sum += matrix[i][j]\n        if col_sum != target_sum:\n            return False\n    \n    # Check diagonals\n    diag1_sum = 0\n    diag2_sum = 0\n    for i in range(n):\n        diag1_sum += matrix[i][i]\n        diag2_sum += matrix[i][n-i-1]\n    if diag1_sum != target_sum or diag2_sum != target_sum:\n        return False\n    \n    return True\n\ndef g():\n    \"\"\"Generate a 3x3 magic square.\"\"\"\n    matrix = [[8, 1, 6], [3, 5, 7], [4, 9, 2]]\n    return matrix\n\nassert f(g()) == True\n\n",
        "idx_generation": 77,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers and a target number, find the two numbers that sum up to the target.\n    Return the product of the two numbers.\"\"\"\n    seen = set()\n    for num in nums:\n        complement = target - num\n        if complement in seen:\n            return num * complement\n        seen.add(num)\n    return 0\n\ndef g(nums: List[int], target: int) -> int:\n    return f(nums, target)\n\nnums = [2, 4, 6, 8, 10]\ntarget = 16\nassert f(nums, target) == g(nums, target)\n",
        "idx_generation": 135,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of distinct pairs (a, b) such that a XOR b is even.\n    \"\"\"\n    count = 0\n    freq = {}\n    for num in nums:\n        if num % 2 == 0:\n            count += freq.get(num ^ 0, 0)\n        else:\n            count += freq.get(num ^ 1, 0)\n        freq[num] = freq.get(num, 0) + 1\n    return count\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    \"\"\"\n    Generate a list of integers where the number of distinct pairs (a, b) such that a XOR b is even is non-zero.\n    \"\"\"\n    return nums\n\nassert f(g()) > 0\n",
        "idx_generation": 277,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Find if it is possible to represent the number n as the sum of exactly k powers of 2\"\"\"\n    num_powers = 0\n    while n > 0:\n        if n % 2 == 1:\n            num_powers += 1\n        n //= 2\n    return num_powers == k\ndef g(n: int, k: int):\n    return 2 ** n + 2 ** k\nassert f(g(3, 2), 2)\n",
        "idx_generation": 268,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find two numbers in a given list that add up to the target\"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 218,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum subarray sum in a given array\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\ndef g(nums=[-2,1,-3,4,-1,2,1,-5,4]):\n    return nums\nassert f(g()) == 6\n",
        "idx_generation": 175,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if there exists a subset of the integers that adds up\n    to the target value.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    \n    for i in range(n + 1):\n        dp[i][0] = True\n    \n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j < nums[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n    \n    return dp[n][target]\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"Generate a list of integers from the given list such that the sum of the generated list is equal to the target\n    value.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    \n    for i in range(n + 1):\n        dp[i][0] = True\n    \n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j < nums[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n    \n    if not dp[n][target]:\n        return []\n    \n    subset = []\n    i, j = n, target\n    while i > 0 and j > 0:\n        if dp[i][j] != dp[i - 1][j]:\n            subset.append(nums[i - 1])\n            j -= nums[i - 1]\n        i -= 1\n    \n    return subset[::-1]\n\nassert f(g(nums=[1, 2, 3, 4, 5], target=9), target=9)\n",
        "idx_generation": 121,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of integers, determine if it is a magic square.\n    A magic square is a square grid of numbers where the sums of the numbers in each row, each column, and both diagonals are the same.\"\"\"\n    n = len(matrix)\n    target = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != target:\n            return False\n    \n    # Check columns\n    for j in range(n):\n        col_sum = 0\n        for i in range(n):\n            col_sum += matrix[i][j]\n        if col_sum != target:\n            return False\n    \n    # Check diagonals\n    diag_sum1 = 0\n    diag_sum2 = 0\n    for i in range(n):\n        diag_sum1 += matrix[i][i]\n        diag_sum2 += matrix[i][n-i-1]\n    if diag_sum1 != target or diag_sum2 != target:\n        return False\n    \n    return True\n\ndef g():\n    return [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n\nassert f(g())\n",
        "idx_generation": 149,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n=4) -> bool:\n    \"\"\"Find a string that contains exactly n distinct characters and has the same number of vowels and consonants\"\"\"\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count_vowels = sum([s.count(vowel) for vowel in vowels])\n    count_consonants = len(s) - count_vowels\n    return len(set(s)) == n and count_vowels == count_consonants\ndef g(n=4):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    consonants = ['b', 'c', 'd', 'f', 'g']\n    return ''.join(vowels[:n//2] + consonants[:n//2])\nassert f(g())\n",
        "idx_generation": 217,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers 'nums' and a target number 'target',\n    check if there exists a pair of numbers in the list whose sum is equal to the target.\n    Return True if such a pair exists, False otherwise.\n    \"\"\"\n    seen = set()\n    \n    for num in nums:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    \n    return False\n\ndef g():\n    \"\"\"\n    Generate a list of integers and a target number.\n    \"\"\"\n    nums = [2, 4, 6, 8, 10]\n    target = 12\n    \n    return nums, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 170,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport numpy as np\n\ndef f(matrix: np.ndarray) -> bool:\n    \"\"\"Check if a given matrix is a magic square, where the sum of each row, column, and diagonal is equal.\"\"\"\n    n = matrix.shape[0]\n    target_sum = n * (n**2 + 1) // 2\n\n    # Check row sums\n    if not all(np.sum(row) == target_sum for row in matrix):\n        return False\n\n    # Check column sums\n    if not all(np.sum(column) == target_sum for column in matrix.T):\n        return False\n\n    # Check diagonal sums\n    if np.sum(np.diagonal(matrix)) != target_sum or np.sum(np.diagonal(np.fliplr(matrix))) != target_sum:\n        return False\n\n    return True\n\ndef g(n: int) -> np.ndarray:\n    \"\"\"Generate a magic square of size n.\"\"\"\n    magic_square = np.zeros((n, n), dtype=int)\n    i, j = 0, n // 2\n\n    for num in range(1, n**2 + 1):\n        magic_square[i, j] = num\n        i -= 1\n        j += 1\n\n        if num % n == 0:\n            i += 2\n            j -= 1\n        elif i < 0:\n            i = n - 1\n        elif j == n:\n            j = 0\n\n    return magic_square\n\nassert f(g(3))\n",
        "idx_generation": 417,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, find the area of the largest rectangle containing only 1s.\n    Return the area of the largest rectangle.\n    \"\"\"\n    def largest_rectangle(heights: List[int]) -> int:\n        stack = [-1]\n        heights.append(0)\n        max_area = 0\n        for i in range(len(heights)):\n            while heights[i] < heights[stack[-1]]:\n                h = heights[stack.pop()]\n                w = i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n        return max_area\n\n    m, n = len(grid), len(grid[0])\n    histogram = [0] * n\n    max_area = 0\n    for i in range(m):\n        for j in range(n):\n            histogram[j] = 0 if grid[i][j] == 0 else histogram[j] + 1\n        max_area = max(max_area, largest_rectangle(histogram))\n    return max_area\n\ndef g():\n    \"\"\"\n    Generate a 2D grid of 0s and 1s.\n    \"\"\"\n    grid = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n    return grid\n\nassert f(g()) == 6\n",
        "idx_generation": 304,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a valid mathematical expression with balanced parentheses.\"\"\"\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g(s='((3 + 5) * 2) - 1'):\n    return s\n\nassert f(g())\n",
        "idx_generation": 40,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the nth Fibonacci number using recursion.\n    Return the result.\"\"\"\n    if n <= 1:\n        return n\n    return f(n-1) + f(n-2)\n\ndef g(n: int):\n    return n\n\nassert f(g(6)) == 8\n",
        "idx_generation": 41,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of 0s and 1s, determine if it is possible to reach the bottom-right corner starting from the top-left corner. You can only move down or right.\"\"\"\n    m, n = len(grid), len(grid[0])\n    queue = [(0, 0)]\n    visited = set()\n\n    while queue:\n        i, j = queue.pop(0)\n        if i == m - 1 and j == n - 1:\n            return True\n        visited.add((i, j))\n\n        neighbors = [(i + 1, j), (i, j + 1)]\n        for x, y in neighbors:\n            if 0 <= x < m and 0 <= y < n and (x, y) not in visited and grid[x][y] == 0:\n                queue.append((x, y))\n\n    return False\n\ndef g():\n    return [[0, 1, 0, 0],\n            [0, 0, 0, 1],\n            [1, 1, 0, 0],\n            [0, 0, 0, 0]]\n\nassert f(g())\n",
        "idx_generation": 154,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the minimum path sum from the top-left corner to the bottom-right corner of a given grid.\n\n    Args:\n        grid (List[List[int]]): The input grid.\n\n    Returns:\n        int: The minimum path sum.\n\n    Example:\n        Input: grid = [[1,3,1],[1,5,1],[4,2,1]]\n        Output: 7\n        Explanation: The minimum path sum is 1 + 3 + 1 + 1 + 1 = 7.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[m - 1][n - 1]\n\ndef g(grid: List[List[int]]) -> int:\n    return f(grid)\n\ngrid = [[1,3,1],[1,5,1],[4,2,1]]\nassert f(grid) == g(grid)\n",
        "idx_generation": 83,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a 2D grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n            \n    return dp[rows-1][cols-1]\n\ndef g():\n    \"\"\"Return a 2D grid of integers.\"\"\"\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 12\n",
        "idx_generation": 110,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, check if it is a palindrome.\n    Return True if s is a palindrome, otherwise return False.\n    \"\"\"\n    stack = []\n    \n    for char in s:\n        stack.append(char)\n    \n    reversed_s = \"\"\n    while stack:\n        reversed_s += stack.pop()\n    \n    return s == reversed_s\n\ndef g():\n    return \"level\"\n\nassert f(g())\n\n",
        "idx_generation": 166,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome.\"\"\"\n    if len(s) <= 1:\n        return True\n    \n    if s[0] == s[-1]:\n        return f(s[1:-1])\n    \n    return False\n\ndef g():\n    s = \"racecar\"\n    return s\n\nassert f(g())\n",
        "idx_generation": 337,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Determine if there exists a pair of numbers in the list nums, such that their XOR is equal to the target value\"\"\"\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] ^ nums[j] == target:\n                return True\n    return False\n\ndef g(nums: List[int], target: int):\n    \"\"\"Generate a list of numbers where there exists a pair with XOR equal to the target value\"\"\"\n    for i in range(1, target+1):\n        nums.append(i)\n        nums.append(i ^ target)\n    return nums\n\nassert f(g([], 10), 10)\n",
        "idx_generation": 14,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int, target: int) -> bool:\n    \"\"\"Given a list of integers nums and an integer k, determine if it is possible to select k integers from nums such that their XOR is equal to the target value.\"\"\"\n    def backtrack(nums, k, target, curr_xor, start_idx):\n        if k == 0:\n            return curr_xor == target\n        for i in range(start_idx, len(nums)):\n            if backtrack(nums, k-1, target, curr_xor ^ nums[i], i+1):\n                return True\n        return False\n    \n    return backtrack(nums, k, target, 0, 0)\n\ndef g():\n    return ([1, 2, 3, 4, 5], 3, 6)\n\nassert f(*g())\n",
        "idx_generation": 207,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"Given a positive integer num, return the number of bits that are set to 1 in its binary representation.\"\"\"\n    count = 0\n    while num:\n        if num & 1:\n            count += 1\n        num >>= 1\n    return count\n\ndef g(num: int) -> int:\n    \"\"\"Count the number of bits set to 1 in the binary representation of the given number.\"\"\"\n    return bin(num).count('1')\n\nassert f(g(10))\n",
        "idx_generation": 92,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"Return the number of ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n    \"\"\"\n    memo = {}\n    \n    def climb(n: int) -> int:\n        if n in memo:\n            return memo[n]\n        if n <= 1:\n            return 1\n        memo[n] = climb(n-1) + climb(n-2)\n        return memo[n]\n    \n    return climb(n)\n\ndef g() -> int:\n    return 5\n\nassert f(g()) == 8\n",
        "idx_generation": 383,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, find the minimum cost to reach the bottom-right cell from the top-left cell.\n    You can only move down or right at each step, and the cost of moving to a cell is equal to the value in that cell.\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[float('inf')] * (n+1) for _ in range(m+1)]\n    dp[m-1][n] = dp[m][n-1] = 0\n\n    for i in range(m-1, -1, -1):\n        for j in range(n-1, -1, -1):\n            dp[i][j] = grid[i][j] + min(dp[i+1][j], dp[i][j+1])\n\n    return dp[0][0]\n\ndef g(grid: List[List[int]]) -> int:\n    return f(grid)\n\ngrid = [\n    [1, 3, 1],\n    [1, 5, 1],\n    [4, 2, 1]\n]\nassert f(grid) == g(grid)\n",
        "idx_generation": 159,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int) -> bool:\n    \"\"\"Check if a given number is a power of 2 and a perfect square.\"\"\"\n    return is_power_of_two(num) and is_perfect_square(num)\n\ndef is_power_of_two(num):\n    return num != 0 and (num & (num - 1)) == 0\n\ndef is_perfect_square(num):\n    return int(num ** 0.5) ** 2 == num\n\ndef g():\n    return 16\n\nassert f(g())\n",
        "idx_generation": 58,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: List[List[int]], n=4) -> bool:\n    \"\"\"Given a graph as an adjacency matrix, determine if it is a complete graph.\n    A complete graph is a simple undirected graph in which every pair of distinct vertices is connected by a unique edge.\n    Sample input:\n    [[0, 1, 1, 1],\n     [1, 0, 1, 1],\n     [1, 1, 0, 1],\n     [1, 1, 1, 0]]\n    Sample output:\n    True\"\"\"\n    return all(all(graph[i][j] == 1 for j in range(n) if i != j) for i in range(n))\ndef g(n=4):\n    return [[1 if i != j else 0 for j in range(n)] for i in range(n)]\nassert f(g())\n",
        "idx_generation": 72,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool:\n    \"\"\"Check if it is possible to reach the end point from the start point in the given grid, following certain rules.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    stack = [start]\n    visited = set([start])\n\n    while stack:\n        row, col = stack.pop()\n\n        if (row, col) == end:\n            return True\n\n        for i, j in [(row + 1, col), (row - 1, col), (row, col + 1), (row, col - 1)]:\n            if 0 <= i < rows and 0 <= j < cols and (i, j) not in visited:\n                visited.add((i, j))\n                if grid[i][j] != 0:\n                    stack.append((i, j))\n\n    return False\n\ndef g():\n    grid = [\n        [1, 0, 1, 1, 1],\n        [1, 0, 1, 0, 1],\n        [1, 1, 1, 0, 1],\n        [0, 0, 0, 0, 1],\n        [1, 1, 1, 1, 1]\n    ]\n    start = (0, 0)\n    end = (4, 4)\n    return grid, start, end\n\nassert f(*g())\n\n",
        "idx_generation": 464,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if there is a path from the top-left corner to the bottom-right corner in a grid.\n    Return True if there is a path, and False otherwise.\"\"\"\n    \n    def dfs(grid: List[List[int]], row: int, col: int) -> bool:\n        \"\"\"Depth-first search to find a path in the grid.\"\"\"\n        \n        if row == len(grid) - 1 and col == len(grid[0]) - 1:\n            return True\n        \n        if row >= len(grid) or col >= len(grid[0]) or grid[row][col] == 1:\n            return False\n        \n        return dfs(grid, row + 1, col) or dfs(grid, row, col + 1)\n    \n    return dfs(grid, 0, 0)\n\ndef g():\n    return [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n\nassert f(g())\n",
        "idx_generation": 68,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the number of islands in the given grid.\n    An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.\"\"\"\n    if not grid:\n        return 0\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                dfs(grid, i, j)\n                count += 1\n    return count\n\ndef dfs(grid, i, j):\n    if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] != 1:\n        return\n    grid[i][j] = -1\n    dfs(grid, i + 1, j)\n    dfs(grid, i - 1, j)\n    dfs(grid, i, j + 1)\n    dfs(grid, i, j - 1)\n\ndef g():\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 3\n",
        "idx_generation": 156,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(words: List[str], target_word='') -> bool:\n    \"\"\"Given a list of words, determine if a target word can be formed by concatenating two or more words from the list.\"\"\"\n    def can_form(word, words):\n        if word in words:\n            return True\n        for i in range(1, len(word)):\n            if word[:i] in words and can_form(word[i:], words):\n                return True\n        return False\n    return can_form(target_word, words)\ndef g(target_word=''):\n    return target_word\nassert f(g())\n",
        "idx_generation": 38,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string consisting of only '0' and '1', find the maximum number of consecutive '1's that can be obtained\n    by flipping at most one '0'.\n\n    Example:\n    Input:\n    s = '110101011011'\n    Output:\n    6\n\n    Explanation:\n    By flipping the '0' at index 5, we can obtain the string '110111111011' which has the maximum number of consecutive '1's.\n\n    \"\"\"\n\n    max_ones = 0\n    curr_ones = 0\n    prev_ones = 0\n    flipped = False\n    \n    for i in range(len(s)):\n        if s[i] == '1':\n            curr_ones += 1\n            prev_ones += 1\n        else:\n            if flipped:\n                curr_ones = prev_ones + 1\n                prev_ones = 0\n            else:\n                curr_ones += 1\n                flipped = True\n        \n        max_ones = max(max_ones, curr_ones)\n    \n    return max_ones\n\ndef g(s: str) -> int:\n    \"\"\"\n    Find the maximum number of consecutive '1's that can be obtained by flipping at most one '0' in a given string.\n    \"\"\"\n\n    max_ones = 0\n    curr_ones = 0\n    prev_ones = 0\n    flipped = False\n    \n    for i in range(len(s)):\n        if s[i] == '1':\n            curr_ones += 1\n            prev_ones += 1\n        else:\n            if flipped:\n                curr_ones = prev_ones + 1\n                prev_ones = 0\n            else:\n                curr_ones += 1\n                flipped = True\n        \n        max_ones = max(max_ones, curr_ones)\n    \n    return max_ones\n\nassert f(s='110101011011') == g(s='110101011011')\n",
        "idx_generation": 496,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if there exists a combination of numbers that can be subtracted from the target number to obtain zero. Each number in the list can only be used once.\"\"\"\n    def dp(nums, target, index, curr_diff):\n        if curr_diff == target:\n            return True\n        if index == len(nums) or curr_diff > target:\n            return False\n        if dp(nums, target, index + 1, curr_diff - nums[index]):\n            return True\n        if dp(nums, target, index + 1, curr_diff):\n            return True\n        return False\n    return dp(nums, target, 0, target)\ndef g(nums=[1, 2, 3, 4, 5], target=5):\n    return nums, target\nassert f(*g())\n",
        "idx_generation": 119,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int], target: int) -> bool:\n    \"\"\"Check if it is possible to reach the target number by performing addition or subtraction operations on the given list of numbers.\"\"\"\n    queue = [0]  # Start with 0\n    visited = set([0])\n    \n    while queue:\n        current = queue.pop(0)\n        \n        if current == target:\n            return True\n        \n        for num in numbers:\n            new_sum = current + num\n            new_diff = current - num\n            \n            if new_sum not in visited:\n                queue.append(new_sum)\n                visited.add(new_sum)\n            \n            if new_diff not in visited:\n                queue.append(new_diff)\n                visited.add(new_diff)\n    \n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7]\n\nassert f(g(), 10) == True\n",
        "idx_generation": 194,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers and a target number, return the index of the target number in the list using binary search. If the target number is not present in the list, return -1.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g():\n    nums = [1, 3, 5, 7, 9, 11]\n    target = 9\n    return nums, target\n\nassert f(*g()) == 4\n",
        "idx_generation": 289,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers and a target number, determine if there are two numbers in the array that add up to the target.\n    Return True if there are two such numbers, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 10\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 101,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum sum of any subarray within the given list.\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g():\n    \"\"\"Find a list of numbers that satisfy the condition of the puzzle.\"\"\"\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 128,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Given a matrix of integers sorted in ascending order from left to right and top to bottom, and a target value,\n    determine if the target value exists in the matrix.\n    Return True if the target value is found, False otherwise.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    row = 0\n    col = cols - 1\n    \n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n    \n    return False\n\ndef g() -> Tuple[List[List[int]], int]:\n    \"\"\"Generate a matrix of integers sorted in ascending order and a target value.\"\"\"\n    matrix = [\n        [1, 4, 7],\n        [2, 5, 8],\n        [3, 6, 9]\n    ]\n    target = 5\n    return matrix, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 117,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find two numbers in the given list that add up to the target value.\n    Return their indices in ascending order.\"\"\"\n    complement_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complement_map:\n            return [complement_map[complement], i]\n        complement_map[num] = i\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 243,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if there exists a combination of numbers that can be XORed to obtain the target number. Each number in the list can only be used once.\"\"\"\n    def dfs(nums, target, index, curr_xor):\n        if curr_xor == target:\n            return True\n        if index == len(nums) or curr_xor > target:\n            return False\n        for i in range(index, len(nums)):\n            if dfs(nums, target, i + 1, curr_xor ^ nums[i]):\n                return True\n        return False\n    return dfs(nums, target, 0, 0)\ndef g(nums=[1, 2, 3, 4, 5], target=6):\n    return nums, target\nassert f(*g())\n",
        "idx_generation": 97,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list that add up to the target.\"\"\"\n    seen = set()\n    for num in nums:\n        complement = target - num\n        if complement in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 185,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"Given an array of integers 'arr' and an integer 'k', determine if there exist two distinct indices i and j,\n    such that arr[i] | arr[j] == k, where '|' denotes the bitwise OR operation.\"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] | arr[j] == k:\n                return True\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g(), 7)\n",
        "idx_generation": 49,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if a given list of integers is sorted in non-decreasing order and contains all even numbers.\"\"\"\n    return sorted(arr) == arr and all(num % 2 == 0 for num in arr)\n\ndef g() -> List[int]:\n    return [2, 4, 6, 8, 10]\n\nassert f(g())\n",
        "idx_generation": 43,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Find the median of a list of integers.\"\"\"\n    arr.sort()\n    n = len(arr)\n    if n % 2 == 0:\n        median = (arr[n // 2] + arr[n // 2 - 1]) / 2\n    else:\n        median = arr[n // 2]\n    return median\n\ndef g(arr: List[int]) -> int:\n    \"\"\"Generate a list of random integers.\"\"\"\n    return [random.randint(0, 100) for _ in range(arr)]\n\nassert f(g(10)) >= 0\n",
        "idx_generation": 297,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Find the maximum sum of a subarray within a given matrix.\n\n    Args:\n        matrix (List[List[int]]): The matrix of integers.\n\n    Returns:\n        int: The maximum sum of a subarray.\n\n    Example:\n        Input: matrix = [[1, 2, -3], [-4, 5, 6], [7, -8, 9]]\n        Output: 21\n        Explanation: The maximum sum of a subarray is obtained by selecting the subarray [5, 6, 7, -8, 9] (5 + 6 + 7 + -8 + 9 = 21).\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return 0\n    rows, cols = len(matrix), len(matrix[0])\n    max_sum = float('-inf')\n    for left in range(cols):\n        row_sums = [0] * rows\n        for right in range(left, cols):\n            for i in range(rows):\n                row_sums[i] += matrix[i][right]\n            max_sum = max(max_sum, max_subarray_sum(row_sums))\n    return max_sum\n\ndef max_subarray_sum(nums: List[int]) -> int:\n    n = len(nums)\n    max_sum = float('-inf')\n    curr_sum = 0\n    for i in range(n):\n        curr_sum = max(curr_sum + nums[i], nums[i])\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef g(matrix: List[List[int]]) -> int:\n    return f(matrix)\n\nmatrix = [[1, 2, -3], [-4, 5, 6], [7, -8, 9]]\nassert f(matrix) == g(matrix)\n",
        "idx_generation": 114,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Find if there are two numbers in the given list that sum up to the target\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(arr: List[int], target: int) -> List[int]:\n    \"\"\"Find two numbers in the given list that sum up to the target\"\"\"\n    nums = set()\n    for num in arr:\n        if target - num in nums:\n            return [num, target - num]\n        else:\n            nums.add(num)\n\n    return []\n\nassert f(g([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 13), 13) == True\n",
        "idx_generation": 208,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the maximum sum of a path in a grid, moving only down or right.\"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    \n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g():\n    \"\"\"Generate a grid.\"\"\"\n    grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    return grid\n\nassert f(g()) == 12\n",
        "idx_generation": 151,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the minimum number of steps required to reach the target position in a grid\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    queue = [(0, 0, 0)]  # (row, col, steps)\n    visited = set()\n    \n    while queue:\n        row, col, steps = queue.pop(0)\n        \n        if row == rows-1 and col == cols-1:\n            return steps\n        \n        if (row, col) in visited:\n            continue\n        \n        visited.add((row, col))\n        \n        if row > 0 and grid[row-1][col] == 0:\n            queue.append((row-1, col, steps+1))\n        \n        if row < rows-1 and grid[row+1][col] == 0:\n            queue.append((row+1, col, steps+1))\n        \n        if col > 0 and grid[row][col-1] == 0:\n            queue.append((row, col-1, steps+1))\n        \n        if col < cols-1 and grid[row][col+1] == 0:\n            queue.append((row, col+1, steps+1))\n    \n    return -1\n\ndef g(grid: List[List[int]] = [[0, 1, 0, 0], [0, 0, 0, 1], [1, 1, 0, 0], [0, 0, 0, 0]]):\n    return grid\n\nassert f(g()) == 6\n",
        "idx_generation": 82,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers as a list.\n    \"\"\"\n\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []\n\ndef g():\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 186,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"Given a matrix of integers, rotate the matrix 90 degrees clockwise in place.\"\"\"\n    n = len(matrix)\n    \n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n    \n    return matrix\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a matrix of integers.\"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n\n",
        "idx_generation": 284,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers 'arr' and a target integer 'target', find two distinct numbers in the list that sum up to the target.\n    Return True if such numbers exist, and False otherwise.\n    \"\"\"\n\n    # Create a set to store the visited numbers\n    visited = set()\n\n    for num in arr:\n        # Check if the complement of 'num' (target - num) is already visited\n        if target - num in visited:\n            return True\n\n        # Add 'num' to the visited set\n        visited.add(num)\n\n    # No pair of distinct numbers found\n    return False\n\n\ndef g(arr: List[int] = [1, 2, 3, 4, 5], target: int = 9):\n    return arr\n\nassert f(g(), 9)\n",
        "idx_generation": 163,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if a given 2D matrix is a valid Sudoku board.\"\"\"\n    rows = [set() for _ in range(9)]\n    cols = [set() for _ in range(9)]\n    boxes = [set() for _ in range(9)]\n    for i in range(9):\n        for j in range(9):\n            num = matrix[i][j]\n            if num != \".\":\n                if num in rows[i] or num in cols[j] or num in boxes[(i//3)*3 + j//3]:\n                    return False\n                rows[i].add(num)\n                cols[j].add(num)\n                boxes[(i//3)*3 + j//3].add(num)\n    return True\n\ndef g():\n    matrix = [\n        [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n        [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n        [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n        [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n        [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n        [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n        [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n        [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n        [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"]\n    ]\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 274,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\ndef f(equation: str) -> bool:\n    \"\"\"Given a mathematical equation in the form of a string, determine if the equation is balanced.\n    An equation is considered balanced if it has equal number of opening and closing parentheses.\n    Return True if the equation is balanced, False otherwise.\"\"\"\n    stack = []\n\n    for char in equation:\n        if char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if not stack:\n                return False\n            stack.pop()\n\n    return len(stack) == 0\n\ndef g():\n    return \"((3 + 4) * 5)\"  # Balanced equation\n\nassert f(g())\n",
        "idx_generation": 137,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', implement a function to find the maximum XOR value \n    between any two numbers in the list.\n    Return the maximum XOR value.\n    \n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n    \n    The maximum XOR value between any two numbers in the list is 28 (5 XOR 25 = 28).\n    Therefore, the output should be 28.\n    \"\"\"\n    max_xor = 0\n    \n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor_val = nums[i] ^ nums[j]\n            if xor_val > max_xor:\n                max_xor = xor_val\n    \n    return max_xor\n\ndef g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n",
        "idx_generation": 499,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(x: int, a=3, b=7) -> bool:\n    \"\"\"Check if x is a multiple of any integer between 'a' and 'b' (inclusive).\"\"\"\n    for i in range(a, b+1):\n        if x % i == 0:\n            return True\n    return False\n\ndef g(a=3, b=7):\n    x = 42\n    return x\n\nassert f(g())\n",
        "idx_generation": 273,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"Check if there is a path in the given array such that the sum of the elements along the path is equal to k.\"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(i+1, n+1):\n            if sum(arr[i:j]) == k:\n                return True\n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    k = 9\n    return arr, k\n\nassert f(*g())\n",
        "idx_generation": 274,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target integer, determine if there exists a subarray in the list that sums up to the target.\n    Return True if such subarray exists, False otherwise.\"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    \n    for num in nums:\n        prefix_sum += num\n        if prefix_sum == target:\n            return True\n        if prefix_sum - target in prefix_sums:\n            return True\n        prefix_sums.add(prefix_sum)\n    \n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Generate a list of integers and a target integer.\"\"\"\n    return [1, 2, 3, 4, 5], 9\n\nassert f(*g())\n",
        "idx_generation": 202,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given an m x n matrix of integers, check if it is a magic square matrix.\"\"\"\n    n = len(matrix)\n    row_sums = [sum(row) for row in matrix]\n    col_sums = [sum(col) for col in zip(*matrix)]\n    diagonal_sum1 = sum(matrix[i][i] for i in range(n))\n    diagonal_sum2 = sum(matrix[i][n-i-1] for i in range(n))\n    return all(sum == row_sums[0] for sum in row_sums) and all(sum == col_sums[0] for sum in col_sums) and diagonal_sum1 == diagonal_sum2 == row_sums[0]\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a magic square matrix of size 3x3.\"\"\"\n    matrix = [[2, 9, 4],\n              [7, 5, 3],\n              [6, 1, 8]]\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 314,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string, return True if it is a palindrome when all non-alphanumeric characters are removed, False otherwise.\"\"\"\n    s = ''.join(c.lower() for c in s if c.isalnum())\n    return s == s[::-1]\n\ndef g():\n    s = \"A man, a plan, a canal: Panama!\"\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 395,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, x=5, y=7) -> bool:\n    \"\"\"Check if the sum of x and y is equal to the length of s.\"\"\"\n    return x + y == len(s)\ndef g(x=5, y=7):\n    return 'a' * (x + y)\nassert f(g())\n",
        "idx_generation": 127,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, a=123456789) -> bool:\n    \"\"\"Check if a number is divisible by 3, 5, and 7.\"\"\"\n    return n % 3 == 0 and n % 5 == 0 and n % 7 == 0\n\ndef g(a=123456789):\n    num = a\n    while num % 3 != 0 or num % 5 != 0 or num % 7 != 0:\n        num += 1\n    return num\n\nassert f(g())\n",
        "idx_generation": 54,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, calculate the sum of all positive integers less than or equal to n that are divisible by 3 or 5.\n    Return the sum.\n    \"\"\"\n    return sum(i for i in range(1, n + 1) if i % 3 == 0 or i % 5 == 0)\n\ndef g():\n    return 10\n\nassert f(g()) == 33\n",
        "idx_generation": 200,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Determine if there exists a square submatrix in the given matrix where the sum of all elements is divisible by 3\"\"\"\n    n = len(matrix)\n    m = len(matrix[0])\n    for i in range(n):\n        for j in range(m):\n            for k in range(i, n):\n                for l in range(j, m):\n                    submatrix_sum = 0\n                    for p in range(i, k+1):\n                        for q in range(j, l+1):\n                            submatrix_sum += matrix[p][q]\n                    if submatrix_sum % 3 == 0:\n                        return True\n    return False\n\ndef g(n: int, m: int) -> List[List[int]]:\n    \"\"\"Generate a matrix of size n x m with random values\"\"\"\n    import random\n    return [[random.randint(0, 9) for _ in range(m)] for _ in range(n)]\n\nassert f(g(3, 3))\n",
        "idx_generation": 14,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Find the maximum subarray sum of a given list of integers.\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in nums:\n        curr_sum = max(curr_sum + num, num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nassert f(g()) == 6\n",
        "idx_generation": 15,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, expression='1+2*(3+4)') -> bool:\n    \"\"\"Check if a string expression has balanced parentheses.\"\"\"\n    stack = []\n    for char in expression:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\ndef g(expression='1+2*(3+4)'):\n    stack = []\n    for char in expression:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\nassert f(g())\n",
        "idx_generation": 59,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Find the minimum cost to reach the bottom right corner from the top left corner in the given matrix.\"\"\"\n    m, n = len(matrix), len(matrix[0])\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = matrix[0][0]\n    queue = [(0, 0)]\n    while queue:\n        i, j = queue.pop(0)\n        for x, y in [(i+1, j), (i, j+1)]:\n            if x < m and y < n:\n                new_cost = dp[i][j] + matrix[x][y]\n                if new_cost < dp[x][y]:\n                    dp[x][y] = new_cost\n                    queue.append((x, y))\n    return dp[m-1][n-1]\n\ndef g():\n    matrix = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return matrix\n\nassert f(g()) == 7\n",
        "idx_generation": 52,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of 0s and 1s, determine if it is possible to reach the bottom-right corner starting from the top-left corner. You can only move down, right, or diagonally down-right. Additionally, you can only move through the cells with a value of 0.\"\"\"\n    m, n = len(grid), len(grid[0])\n    queue = [(0, 0)]\n    visited = set()\n\n    while queue:\n        i, j = queue.pop(0)\n        if i == m - 1 and j == n - 1:\n            return True\n        visited.add((i, j))\n\n        neighbors = [(i + 1, j), (i, j + 1), (i + 1, j + 1)]\n        for x, y in neighbors:\n            if 0 <= x < m and 0 <= y < n and (x, y) not in visited and grid[x][y] == 0:\n                queue.append((x, y))\n\n    return False\n\ndef g():\n    return [[0, 1, 0, 0],\n            [0, 0, 0, 1],\n            [1, 1, 0, 0],\n            [0, 0, 0, 0]]\n\nassert f(g())\n",
        "idx_generation": 154,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of 0s and 1s, find the largest square of 1s in the grid and return its area.\n    A square is defined as a set of consecutive 1s forming a square shape.\n    Sample Input:\n    grid = [[1, 0, 1, 0, 0],\n            [1, 0, 1, 1, 1],\n            [1, 1, 1, 1, 1],\n            [1, 0, 0, 1, 0]]\n    Sample Output:\n    4\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    maxSquare = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if grid[i - 1][j - 1] == 1:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                maxSquare = max(maxSquare, dp[i][j])\n    return maxSquare * maxSquare\n\ndef g():\n    return ([[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]],)\n\nassert f(*g()) == 4\n",
        "idx_generation": 96,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, find the minimum sum path from the top-left cell to the bottom-right cell by only moving right or down.\"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    dp = [[0] * m for _ in range(n)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n    for j in range(1, m):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])\n            \n    return dp[n-1][m-1]\n\ndef g():\n    grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 136,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"\n    Given a string s, check if it can be transformed into the target string by removing one character.\n    Return True if it is possible, otherwise return False.\n    \"\"\"\n    if len(s) != len(target) + 1:\n        return False\n    \n    queue = []\n    queue.append(s)\n    \n    while queue:\n        current = queue.pop(0)\n        \n        if current == target:\n            return True\n        \n        for i in range(len(current)):\n            new_string = current[:i] + current[i+1:]\n            queue.append(new_string)\n    \n    return False\n\ndef g():\n    return \"abcde\"\n\nassert f(g(), \"abde\")\n",
        "idx_generation": 193,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string, determine if it is a palindrome after removing exactly one character.\n    Return True if it is a palindrome after removal, False otherwise.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    n = len(s)\n    for i in range(n):\n        new_s = s[:i] + s[i+1:]\n        if is_palindrome(new_s):\n            return True\n    return False\n\ndef g():\n    return \"racecar\"\n\nassert f(g()) == True\n",
        "idx_generation": 414,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(x: int, a=10) -> bool:\n    \"\"\"Find the minimum number of bits needed to represent a given integer.\"\"\"\n    return 2 ** x > a and 2 ** (x-1) <= a\ndef g(a=10):\n    x = 0\n    while 2 ** x <= a:\n        x += 1\n    return x\nassert f(g())\n",
        "idx_generation": 20,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(array: List[int], target: int) -> bool:\n    \"\"\"Given an array of integers and a target value, return True if it is possible to obtain the target value by performing bitwise OR operations on a subset of the integers, otherwise return False.\"\"\"\n    def recursive_or(array, target, index, current_or):\n        if current_or == target:\n            return True\n        if index >= len(array):\n            return False\n        return recursive_or(array, target, index+1, current_or | array[index]) or recursive_or(array, target, index+1, current_or)\n    \n    return recursive_or(array, target, 0, 0)\n\ndef g(array=[2, 4, 6, 8, 10], target=12):\n    return array, target\n\nassert f(*g())\n",
        "idx_generation": 223,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given an integer n, determine if it is a palindrome in binary representation.\n    Example:\n    n = 9\n    Binary representation: 1001\n    Output: True\"\"\"\n    binary = bin(n)[2:]\n    return binary == binary[::-1]\n\ndef g():\n    return 9\n\nassert f(g())\n",
        "idx_generation": 167,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"Given n, return the number of unique paths to reach the bottom-right cell of an n x n grid.\n    You can only move down or right at any point in time.\n    \"\"\"\n    def dp(i: int, j: int) -> int:\n        if i == n-1 and j == n-1:\n            return 1\n        if i >= n or j >= n:\n            return 0\n        return dp(i+1, j) + dp(i, j+1)\n    \n    return dp(0, 0)\n\ndef g():\n    return 3\n\nassert f(g()) == 6\n",
        "idx_generation": 429,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum along a path from the top-left corner to the bottom-right corner.\n\n    The path can only move down or right.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    \n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[rows-1][cols-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 12\n\n",
        "idx_generation": 213,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine if a number is a power of 2\"\"\"\n    return n != 0 and (n & (n - 1)) == 0\n\ndef g():\n    return 16\n\nassert f(g())\n",
        "idx_generation": 126,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if the given grid contains a valid path from the top-left corner to the bottom-right corner.\n    The grid is represented as a 2D list, where 0 represents an obstacle and 1 represents an open path.\n    Return True if there exists a valid path from the top-left to the bottom-right, False otherwise.\"\"\"\n    def dfs(i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0:\n            return False\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\n            return True\n        grid[i][j] = 0\n        return dfs(i+1, j) or dfs(i-1, j) or dfs(i, j+1) or dfs(i, j-1)\n    \n    return dfs(0, 0)\n\ndef g():\n    \"\"\"Generate a grid with obstacles and open paths.\"\"\"\n    grid = [[1, 0, 1, 1],\n            [1, 1, 0, 1],\n            [0, 1, 1, 0],\n            [1, 1, 1, 1]]\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 130,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(graph: dict, start: int, end: int) -> bool:\n    \"\"\"Check if there is a path from start to end in the given graph.\"\"\"\n    visited = set()\n    queue = deque([start])\n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    return False\ndef g():\n    return {1: [2, 3], 2: [4], 3: [5], 4: [], 5: []}\nassert f(g(), 1, 5)\n",
        "idx_generation": 18,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there is a path from the start node to the end node in the given graph.\"\"\"\n    visited = set()\n    stack = [start]\n    \n    while stack:\n        node = stack.pop()\n        \n        if node == end:\n            return True\n        \n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    \n    return False\n\ndef g():\n    graph = [[1, 2], [3, 4], [5], [5], [6], [6], []]\n    start = 0\n    end = 6\n    return graph, start, end\n\nassert f(*g())\n\n",
        "idx_generation": 486,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of 0s and 1s, determine if there is a path from the top-left corner to the bottom-right corner, where 0 represents an empty cell and 1 represents an obstacle.\n    Additionally, you are only allowed to move right or down in the grid.\"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    def dfs(i, j):\n        if i == m-1 and j == n-1:\n            return True\n        if i >= m or j >= n or grid[i][j] == 1:\n            return False\n        return dfs(i+1, j) or dfs(i, j+1)\n    \n    return dfs(0, 0)\n\ndef g():\n    return [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n\nassert f(g()) == True\n",
        "idx_generation": 92,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], start: List[int], end: List[int]) -> int:\n    \"\"\"Given a grid with obstacles represented by 1s and empty cells represented by 0s, find the shortest path from the start cell to the end cell. You can only move up, down, left, or right, and cannot cross obstacles.\"\"\"\n    m, n = len(grid), len(grid[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = [(start[0], start[1], 0)]\n    visited = set()\n    while queue:\n        i, j, steps = queue.pop(0)\n        if i == end[0] and j == end[1]:\n            return steps\n        for di, dj in directions:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == 0 and (ni, nj) not in visited:\n                queue.append((ni, nj, steps + 1))\n                visited.add((ni, nj))\n    return -1\n\ndef g():\n    return [[0, 0, 0, 0, 0],\n            [1, 1, 0, 1, 0],\n            [0, 0, 0, 0, 0],\n            [0, 1, 1, 1, 0],\n            [0, 0, 0, 0, 0]]\n\nstart = [0, 0]\nend = [4, 4]\n\nassert f(g(), start, end) == 8\n",
        "idx_generation": 354,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(grid: List[List[str]], word: str) -> bool:\n    \"\"\"Given a grid of characters and a target word, determine if the word exists in the grid.\n    The word can be constructed from adjacent letters (horizontally or vertically) in the grid.\n    Return True if the word exists, False otherwise.\n    Example:\n    grid = [\n        ['A', 'B', 'C', 'E'],\n        ['S', 'F', 'C', 'S'],\n        ['A', 'D', 'E', 'E']\n    ]\n    word = \"ABCCED\"\n    The word \"ABCCED\" can be formed by starting at the 'A' in the top left corner, moving to the 'B' on the right,\n    then moving down to the 'C', and finally moving down and to the right to the 'E'.\n    Therefore, the answer is True.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    def dfs(row, col, index):\n        if index == len(word):\n            return True\n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] != word[index]:\n            return False\n        temp = grid[row][col]\n        grid[row][col] = ''\n        found = (dfs(row+1, col, index+1) or dfs(row-1, col, index+1) or dfs(row, col+1, index+1) or dfs(row, col-1, index+1))\n        grid[row][col] = temp\n        return found\n    \n    for row in range(rows):\n        for col in range(cols):\n            if grid[row][col] == word[0] and dfs(row, col, 0):\n                return True\n    return False\n\ndef g():\n    return [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], \"ABCCED\"\nassert f(*g())\n",
        "idx_generation": 45,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if there exists a combination of numbers that can be concatenated to obtain the target string. Each number in the list can only be used once and the order of concatenation matters.\"\"\"\n    def dfs(nums, target, index, curr_str):\n        if curr_str == target:\n            return True\n        if index == len(nums) or len(curr_str) > len(target):\n            return False\n        for i in range(index, len(nums)):\n            if dfs(nums, target, i + 1, curr_str + str(nums[i])):\n                return True\n        return False\n    return dfs(nums, target, 0, \"\")\n    \ndef g(nums=[1, 2, 3, 4, 5], target=\"12345\"):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 108,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\nfrom math import factorial\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer 'n', calculate the number of derangements of 'n' elements.\n    A derangement is a permutation of the elements in which no element appears in its original position.\n    Return the number of derangements.\n    \"\"\"\n    if n == 0:\n        return 1\n    \n    derangements = factorial(n)\n    sign = 1\n    \n    for i in range(1, n+1):\n        sign *= -1\n        derangements += sign * factorial(n) // factorial(i)\n    \n    return derangements\n\ndef g():\n    \"\"\"\n    Generate an integer.\n    \"\"\"\n    n = 4\n    \n    return n\n\nassert f(g()) == 9\n",
        "idx_generation": 369,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given an array of integers nums sorted in ascending order, and a target value, find two numbers in the array that add up to the target value. Return their indices as a list.\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    Output: [0, 1]\n    Explanation: The numbers at indices 0 and 1 (2 and 7) add up to 9.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 326,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Given a list of integers, find a pair of numbers whose sum is equal to the target. Returns True if such a pair exists, False otherwise.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(target=10):\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    return nums\n\nassert f(g())\n",
        "idx_generation": 120,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(expression: str) -> bool:\n    \"\"\"Given a string 'expression' containing only the characters '(' and ')',\n    determine if the parentheses are balanced.\n    The parentheses are balanced if each opening parenthesis '(' has a corresponding closing parenthesis ')'\n    and they are properly nested.\n    Example:\n    expression = \"((()))\"\n    The parentheses are balanced, so the output should be True.\n    \"\"\"\n    stack = []\n    \n    for char in expression:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    \n    return len(stack) == 0\n\ndef g() -> str:\n    return \"((()))\"\n\nassert f(g()) == True\n",
        "idx_generation": 282,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Given a 2D matrix where each row is sorted in ascending order and each column is sorted in ascending order, determine if a target number exists in the matrix.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    row = rows - 1\n    col = 0\n\n    while row >= 0 and col < cols:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            col += 1\n        else:\n            row -= 1\n\n    return False\n\ndef g(matrix: List[List[int]], target: int) -> bool:\n    return f(matrix, target)\n\nmatrix = [\n    [1, 4, 7, 11, 15],\n    [2, 5, 8, 12, 19],\n    [3, 6, 9, 16, 22],\n    [10, 13, 14, 17, 24],\n    [18, 21, 23, 26, 30]\n]\ntarget = 9\nassert f(matrix, target) == g(matrix, target)\n",
        "idx_generation": 253,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string containing only '(' and ')', determine if it is a valid parentheses sequence.\"\"\"\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack or stack[-1] != '(':\n                return False\n            stack.pop()\n    \n    return len(stack) == 0\n\ndef g():\n    return \"((())())\"\n\nassert f(g())\n",
        "idx_generation": 316,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, s: str) -> bool:\n    \"\"\"Check if the given number is a prime number and if the given string is a palindrome.\"\"\"\n    is_prime = True\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            is_prime = False\n            break\n    return is_prime and s == s[::-1]\n\ndef g():\n    n = 17\n    s = 'racecar'\n    return n, s\n\nassert f(*g())\n",
        "idx_generation": 158,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum sum of a subarray.\n    \n    Return the maximum sum.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef g(nums: List[int]) -> int:\n    return f(nums)\n\nnums = [1, -2, 3, 4, -5, 6]\nassert f(nums) == g(nums)\n\n",
        "idx_generation": 206,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the array whose bitwise AND is equal to zero.\"\"\"\n    arr.sort()\n    for i in range(len(arr)-1):\n        for j in range(i+1, len(arr)):\n            if arr[i] & arr[j] == 0:\n                return True\n    return False\n\ndef g():\n    return [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40]\n\nassert f(g())\n",
        "idx_generation": 51,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers, find the index of the target element using binary search.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g():\n    return [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n\nassert f(g(), 9) == 4\n",
        "idx_generation": 56,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a subarray in the list whose sum is divisible by 9.\n    \"\"\"\n    prefix_sum = 0\n    prefix_sums = {0} # set to store prefix sums\n    for num in nums:\n        prefix_sum += num\n        prefix_sum %= 9\n        if prefix_sum in prefix_sums:\n            return True\n        prefix_sums.add(prefix_sum)\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g())\n",
        "idx_generation": 174,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix, determine if it is a symmetric matrix.\n    A matrix is considered symmetric if it is equal to its transpose.\n    Sample input:\n    [[1, 2, 3],\n     [2, 4, 5],\n     [3, 5, 6]]\n    Sample output:\n    True\"\"\"\n    n = len(matrix)\n    transpose = [[matrix[j][i] for j in range(n)] for i in range(n)]\n    return matrix == transpose\n\ndef g(n=3):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            matrix[i][j] = i + j\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 298,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the shortest path from the top-left corner to the bottom-right corner. Each step in the path can only move down or right.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g(grid: List[List[int]] = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 167,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport heapq\n\ndef f(n: int, edges: List[Tuple[int, int, int]]) -> bool:\n    \"\"\"Given a graph represented as a list of edges (u, v, w), where u and v are nodes and w is the weight of the edge,\n    determine if there exists a negative cycle in the graph.\"\"\"\n    distance = [float('inf')] * n\n    distance[0] = 0\n    \n    for _ in range(n - 1):\n        for u, v, w in edges:\n            if distance[u] != float('inf') and distance[u] + w < distance[v]:\n                distance[v] = distance[u] + w\n    \n    for u, v, w in edges:\n        if distance[u] != float('inf') and distance[u] + w < distance[v]:\n            return True\n    \n    return False\n\ndef g(n: int, edges: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]:\n    \"\"\"Generate a graph represented as a list of edges (u, v, w) where u and v are nodes and w is the weight of the edge,\n    where there exists a negative cycle in the graph.\"\"\"\n    edges.append((0, 1, -1))\n    return edges\n\nassert f(n=3, edges=g(n=3, edges=[(0, 1, 1), (1, 2, -2), (0, 2, 3), (2, 1, 1), (1, 0, -4), (2, 0, -5)]))\n",
        "idx_generation": 96,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Find the missing number in the given array.\"\"\"\n    arr.sort()\n    for i in range(len(arr)):\n        if arr[i] != i+1:\n            return i+1\n    return len(arr) + 1\n\ndef g(arr=[1, 2, 3, 4, 6, 7, 8]):\n    \"\"\"Generate an array with one missing number.\"\"\"\n    return arr\n\nassert f(g()) == 5\n",
        "idx_generation": 194,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"Given a grid of integers, rotate it 90 degrees clockwise in-place.\n    \"\"\"\n    n = len(grid)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = grid[i][j]\n            grid[i][j] = grid[n - j - 1][i]\n            grid[n - j - 1][i] = grid[n - i - 1][n - j - 1]\n            grid[n - i - 1][n - j - 1] = grid[j][n - i - 1]\n            grid[j][n - i - 1] = temp\n    return grid\n\ndef g():\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return grid\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 330,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> str:\n    \"\"\"Given two integers n and k, return the kth smallest number that can be created using the digits of n.\n    Return the number as a string.\"\"\"\n    digits = sorted(str(n))\n    perms = []\n    \n    def generate_permutations(curr_perm, remaining_digits):\n        if len(curr_perm) == len(digits):\n            perms.append(int(''.join(curr_perm)))\n        else:\n            for i in range(len(remaining_digits)):\n                generate_permutations(curr_perm + [remaining_digits[i]], remaining_digits[:i] + remaining_digits[i+1:])\n    \n    generate_permutations([], digits)\n    perms.sort()\n    \n    return str(perms[k-1])\n\ndef g(n: int, k: int) -> str:\n    return f(n, k)\n\nn = 12345\nk = 3\nassert f(n, k) == g(n, k)\n",
        "idx_generation": 205,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"Given a string 's' containing only the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n    An input string is valid if:\n    - Open brackets must be closed by the same type of brackets.\n    - Open brackets must be closed in the correct order.\"\"\"\n    stack = []\n    brackets_map = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n    for char in s:\n        if char in brackets_map:\n            if not stack or brackets_map[char] != stack.pop():\n                return False\n        else:\n            stack.append(char)\n    return not stack\n\ndef g(s: str) -> str:\n    \"\"\"Return the string\"\"\"\n    return s\n\nassert f(g(s=\"()[]{}\"))\n",
        "idx_generation": 295,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Find if there exists a pair of integers in the given list whose sum is equal to the target.\"\"\"\n    visited = set()\n    for num in nums:\n        complement = target - num\n        if complement in visited:\n            return True\n        visited.add(num)\n    return False\ndef g(nums=[2, 4, 6, 8]):\n    return nums\nassert f(g())\n",
        "idx_generation": 1,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums', return a new list where each element is the product of all the elements\n    in the original list except itself.\n    \"\"\"\n    n = len(nums)\n    output = [1] * n\n    left_product = 1\n    right_product = 1\n    \n    for i in range(n):\n        output[i] *= left_product\n        left_product *= nums[i]\n    \n    for i in range(n-1, -1, -1):\n        output[i] *= right_product\n        right_product *= nums[i]\n    \n    return output\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    \n    return nums\n\nassert f(g()) == [120, 60, 40, 30, 24]\n",
        "idx_generation": 365,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=20) -> bool:\n    \"\"\"Find if there exists a subset of the given list of integers whose sum is equal to the target.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if nums[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[n][target]\ndef g(nums=[1, 3, 5, 7, 9]):\n    return nums\nassert f(g())\n",
        "idx_generation": 1,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, return a new list where each element at index i is the product of all the numbers in the original list except the one at i.\n    The product should be calculated without using the division operation.\"\"\"\n    n = len(nums)\n    left_products = [1] * n\n    right_products = [1] * n\n    result = [1] * n\n\n    for i in range(1, n):\n        left_products[i] = left_products[i-1] * nums[i-1]\n\n    for i in range(n-2, -1, -1):\n        right_products[i] = right_products[i+1] * nums[i+1]\n\n    for i in range(n):\n        result[i] = left_products[i] * right_products[i]\n\n    return result\n\ndef g() -> List[int]:\n    \"\"\"Generate a list of integers.\"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [120, 60, 40, 30, 24]\n",
        "idx_generation": 344,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, check if there exists a subarray whose sum is equal to 0.\"\"\"\n    prefix_sum = 0\n    sum_set = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum in sum_set or prefix_sum == 0:\n            return True\n        sum_set.add(prefix_sum)\n    return False\n\ndef g():\n    return [4, -3, 2, 1, 8]\n\nassert f(g())\n",
        "idx_generation": 214,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int, target: int) -> bool:\n    \"\"\"Given a string 's' and an integer 'k', determine if there exists a substring of length 'k' that is a multiple of 'target'.\"\"\"\n    for i in range(len(s) - k + 1):\n        if int(s[i:i+k]) % target == 0:\n            return True\n    return False\n\ndef g():\n    return \"123456789\", 3, 7\n\nassert f(*g())\n",
        "idx_generation": 469,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Determine if it is possible to split the string s into k non-empty substrings, where each substring is a palindrome.\"\"\"\n    def is_palindrome(substr):\n        return substr == substr[::-1]\n    def split_string(s, k):\n        if k == 1:\n            return is_palindrome(s)\n        for i in range(1, len(s)):\n            substr = s[:i]\n            if is_palindrome(substr) and split_string(s[i:], k-1):\n                return True\n        return False\n    return split_string(s, k)\n\ndef g():\n    s = \"ababa\"\n    k = 3\n    return s, k\n\nassert f(*g())\n",
        "idx_generation": 264,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, arr: List[int]) -> bool:\n    \"\"\"Given an array of integers, find if there exists a subarray with a sum equal to n.\"\"\"\n    prefix_sum = 0\n    seen_sums = set()\n    \n    for num in arr:\n        prefix_sum += num\n        \n        if prefix_sum == n or prefix_sum - n in seen_sums:\n            return True\n        \n        seen_sums.add(prefix_sum)\n    \n    return False\n\ndef g(arr=[-2, 4, 6, -3, 8, -1, 0], n=7):\n    return n, arr\n\nassert f(*g())\n",
        "idx_generation": 106,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k=3) -> bool:\n    \"\"\"Given a string s and an integer k, determine if there exists a substring of length k that appears more than once in s.\n    Return True if such a substring exists, False otherwise.\"\"\"\n    n = len(s)\n    for i in range(n-k+1):\n        if s[i:i+k] in s[i+k:]:\n            return True\n    return False\n\ndef g(s: str):\n    \"\"\"Return the string in reverse order.\"\"\"\n    return s[::-1]\n\nassert f(g(\"abracadabra\"))\n",
        "idx_generation": 305,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k=3) -> bool:\n    \"\"\"Check if the given string can be partitioned into k equal sum subsets.\"\"\"\n    if k == 1:\n        return True\n    if len(s) < k or sum(s) % k != 0:\n        return False\n    target = sum(s) // k\n    visited = [False] * len(s)\n\n    def backtrack(curr_sum, start_index, subset_count):\n        if subset_count == k - 1:\n            return True\n        if curr_sum == target:\n            return backtrack(0, 0, subset_count + 1)\n        for i in range(start_index, len(s)):\n            if not visited[i] and curr_sum + s[i] <= target:\n                visited[i] = True\n                if backtrack(curr_sum + s[i], i + 1, subset_count):\n                    return True\n                visited[i] = False\n        return False\n\n    return backtrack(0, 0, 0)\n\ndef g(s=[2, 1, 4, 5, 6], k=3):\n    return s\n\nassert f(g())\n",
        "idx_generation": 142,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a given number is a prime number.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g())\n",
        "idx_generation": 16,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\ndef f(expression: str) -> bool:\n    \"\"\"Given a string representing a mathematical expression, determine if the parentheses in the expression are balanced.\n    A balanced expression has an equal number of opening and closing parentheses and the parentheses are properly nested.\"\"\"\n    stack = []\n    for char in expression:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g():\n    return \"((3 + 4) * (5 - 2))\"\n\nassert f(g())\n",
        "idx_generation": 71,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the maximum sum of a path from the top-left corner to the bottom-right corner in the grid.\n    The path can only move down or right.\n    Return the maximum sum.\"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    \n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g():\n    \"\"\"Generate a random grid of size 3x3 with random non-negative integer values.\"\"\"\n    import random\n    return [[random.randint(0, 9) for _ in range(3)] for _ in range(3)]\n\nassert f(g()) >= 0\n",
        "idx_generation": 95,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid with some empty cells and some blocked cells, determine if it is possible to reach from the top-left\n    corner to the bottom-right corner, by moving only through the empty cells, and only moving diagonally, horizontally, \n    or vertically.\"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    \n    def dfs(i, j):\n        if i == n-1 and j == m-1:\n            return True\n        if i >= n or j >= m or grid[i][j] == 1 or visited[i][j]:\n            return False\n        visited[i][j] = True\n        return dfs(i+1, j) or dfs(i, j+1) or dfs(i+1, j+1) or dfs(i-1, j) or dfs(i, j-1) or dfs(i-1, j-1)\n    \n    return dfs(0, 0)\n\ndef g():\n    return [[0, 0, 0, 0],\n            [0, 1, 0, 1],\n            [0, 0, 0, 0],\n            [0, 0, 1, 0]]\n\nassert f(g())",
        "idx_generation": 7,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> bool:\n    \"\"\"Check if the grid contains a valid path from the top-left corner to the bottom-right corner.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    stack = [(0, 0)]  # Start at the top-left corner\n    visited = set()\n    while stack:\n        row, col = stack.pop()\n        if (row, col) == (rows-1, cols-1):  # Reached the bottom-right corner\n            return True\n        visited.add((row, col))\n        for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:  # Move right, down, left, up\n            new_row, new_col = row + dr, col + dc\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == '.' and (new_row, new_col) not in visited:\n                stack.append((new_row, new_col))\n    return False\n\ndef g(grid=[['.', '.', '.', '.', '.', '.'],\n            ['.', '#', '#', '#', '#', '.'],\n            ['.', '.', '.', '.', '.', '.'],\n            ['#', '#', '#', '#', '#', '.'],\n            ['.', '.', '.', '.', '.', '.']]):\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 174,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, determine the number of unique paths to reach the bottom-right corner of a n x n grid starting from the top-left corner. You can only move down or right at each step.\"\"\"\n    def dfs(i, j, n):\n        if i == n-1 and j == n-1:\n            return 1\n        if i >= n or j >= n:\n            return 0\n        return dfs(i+1, j, n) + dfs(i, j+1, n)\n    \n    return dfs(0, 0, n)\n\ndef g(n=3):\n    return n\n\nassert f(g()) == 6\n",
        "idx_generation": 143,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a 2D grid of integers, determine if it is possible to reach the bottom-right cell from the top-left cell\n    by moving only rightward or downward. Return True if it is possible, otherwise return False.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    # Initialize the dynamic programming table\n    dp = [[False] * n for _ in range(m)]\n\n    # Base case: the top-left cell is reachable\n    dp[0][0] = True\n\n    # Fill in the dynamic programming table\n    for i in range(m):\n        for j in range(n):\n            if dp[i][j]:\n                # Move right\n                if j + 1 < n and grid[i][j + 1] != 1:\n                    dp[i][j + 1] = True\n                # Move down\n                if i + 1 < m and grid[i + 1][j] != 1:\n                    dp[i + 1][j] = True\n\n    # Return the value in the bottom-right cell\n    return dp[m - 1][n - 1]\n\ndef g():\n    return [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n\nassert f(g())\n",
        "idx_generation": 174,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, k: int) -> bool:\n    \"\"\"\n    Given a string s and an integer k, check if it is possible to obtain a palindrome by removing exactly k characters from s.\n    Return True if it is possible, otherwise return False.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    \n    if len(s) <= k:\n        return True\n    \n    queue = []\n    queue.append(s)\n    \n    while queue:\n        current = queue.pop(0)\n        \n        if is_palindrome(current):\n            return True\n        \n        if len(current) <= k:\n            return True\n        \n        for i in range(len(current)):\n            new_string = current[:i] + current[i+1:]\n            queue.append(new_string)\n    \n    return False\n\ndef g() -> List[str]:\n    return [\"racecar\", \"madam\"]\n\nassert f(g()[0], 1)\n",
        "idx_generation": 282,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Determine if a string is a palindrome.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n    Return True if the string is a palindrome, False otherwise.\n    \"\"\"\n    if len(s) <= 1:\n        return True\n    elif s[0] != s[-1]:\n        return False\n    else:\n        return f(s[1:-1])\n    \ndef g():\n    \"\"\"\n    Generate a palindrome string.\n    \"\"\"\n    return \"madam\"\n\nassert f(g())\n",
        "idx_generation": 487,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(x: int, a=10) -> bool:\n    \"\"\"Find the minimum number of bits needed to represent a given integer.\"\"\"\n    return 2 ** x > a and 2 ** (x-1) <= a\ndef g(a=10):\n    x = 0\n    while 2 ** x <= a:\n        x += 1\n    return x\nassert f(g())\n",
        "idx_generation": 20,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if it is possible to select a subset of the list such that the bitwise XOR of all elements in the subset is equal to the target value.\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    Output: True\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n    \n    for i in range(1, n + 1):\n        for j in range(target + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= nums[i - 1]:\n                dp[i][j] |= dp[i - 1][j - nums[i - 1]]\n    \n    return dp[n][target]\n\ndef g():\n    return [1, 2, 3, 4, 5], 7\n\nassert f(*g())\n",
        "idx_generation": 273,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"Check if the given string is a palindrome after performing bitwise OR operation on its ASCII values.\"\"\"\n    ascii_values = [ord(c) for c in string]\n    bitwise_or = 0\n    for value in ascii_values:\n        bitwise_or |= value\n    reversed_string = ''.join(reversed(string))\n    ascii_reversed = [ord(c) for c in reversed_string]\n    bitwise_or_reversed = 0\n    for value in ascii_reversed:\n        bitwise_or_reversed |= value\n    return bitwise_or == bitwise_or_reversed\n\ndef g():\n    return \"racecar\"\n\nassert f(g())\n",
        "idx_generation": 188,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of all previous elements in the original list.\n    \"\"\"\n    result = []\n    total_sum = 0\n    \n    for num in nums:\n        total_sum += num\n        result.append(total_sum)\n    \n    return result\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == [1, 3, 6, 10, 15]\n",
        "idx_generation": 474,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, return the number of unique paths from the top-left cell to the bottom-right\n    cell in a grid of size n x n. You can only move down or right.\"\"\"\n    memo = {}\n\n    def count_paths(i, j):\n        if i == n - 1 and j == n - 1:\n            return 1\n\n        if (i, j) in memo:\n            return memo[(i, j)]\n\n        right_paths = 0\n        down_paths = 0\n\n        if i < n - 1:\n            right_paths = count_paths(i + 1, j)\n\n        if j < n - 1:\n            down_paths = count_paths(i, j + 1)\n\n        memo[(i, j)] = right_paths + down_paths\n        return memo[(i, j)]\n\n    return count_paths(0, 0)\n\ndef g():\n    n = 4\n    return n\n\nassert f(g()) == 20\n",
        "idx_generation": 327,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of set bits (1s) in the binary representation of n.\"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g():\n    return 15\n\nassert f(g()) == 4\n",
        "idx_generation": 190,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"Given an undirected graph represented as an adjacency matrix, determine if the graph contains a cycle.\n    Use depth-first search (DFS) algorithm to solve the problem.\n    Sample input:\n    graph = [[0, 1, 0, 0],\n             [1, 0, 1, 1],\n             [0, 1, 0, 1],\n             [0, 1, 1, 0]]\n    Sample output:\n    True\"\"\"\n    def dfs(v, visited, parent):\n        visited[v] = True\n        for i in range(len(graph)):\n            if graph[v][i] == 1:\n                if not visited[i]:\n                    if dfs(i, visited, v):\n                        return True\n                elif parent != i:\n                    return True\n        return False\n\n    visited = [False] * len(graph)\n    for i in range(len(graph)):\n        if not visited[i]:\n            if dfs(i, visited, -1):\n                return True\n\n    return False\n\n\ndef g():\n    return [[0, 1, 0, 0],\n            [1, 0, 1, 1],\n            [0, 1, 0, 1],\n            [0, 1, 1, 0]]\n\nassert f(g())\n",
        "idx_generation": 132,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a graph represented as an adjacency matrix, determine if there is a path from the start node to the end node.\"\"\"\n    visited = set()\n    stack = [start]\n    \n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            for neighbor in range(len(graph[node])):\n                if graph[node][neighbor] == 1 and neighbor not in visited:\n                    stack.append(neighbor)\n    \n    return False\n\ndef g(graph=[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]], start=0, end=3):\n    return graph, start, end\n\nassert f(*g())\n",
        "idx_generation": 24,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(maze: List[List[int]]) -> bool:\n    \"\"\"Given a maze represented by a 2D grid filled with 0s and 1s, determine if it is possible to navigate from the top-left corner to the bottom-right corner\n    by only moving right or down. The path cannot pass through any cells with a value of 1.\"\"\"\n    n = len(maze)\n    m = len(maze[0])\n    \n    def is_valid_move(row, col):\n        if row < 0 or row >= n or col < 0 or col >= m or maze[row][col] == 1:\n            return False\n        return True\n    \n    def dfs(row, col):\n        if row == n-1 and col == m-1:\n            return True\n        if not is_valid_move(row, col):\n            return False\n        \n        maze[row][col] = 1\n        \n        if dfs(row + 1, col):\n            return True\n        if dfs(row, col + 1):\n            return True\n        \n        return False\n    \n    return dfs(0, 0)\n\ndef g(maze: List[List[int]]) -> List[List[int]]:\n    \"\"\"Return the maze\"\"\"\n    return maze\n\nassert f(g(maze=[[0, 1, 0], [0, 0, 1], [1, 0, 0]]))\n",
        "idx_generation": 107,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]], target: str) -> bool:\n    \"\"\"Given a grid of characters 'grid' and a target word 'target',\n    determine if the target word exists in the grid.\n    The target word can be formed by connecting adjacent cells horizontally or vertically.\n    Return True if the target word exists, False otherwise.\n    Example:\n    grid = [['A', 'B', 'C', 'E'],\n            ['S', 'F', 'C', 'S'],\n            ['A', 'D', 'E', 'E']]\n    target = \"ABCCED\"\n    The word \"ABCCED\" can be formed by starting at the cell (0, 0) and moving in the following path:\n    A -> B -> C -> C -> E -> D\n    Therefore, the answer is True.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    visited = [[False] * cols for _ in range(rows)]\n    \n    def dfs(row, col, word):\n        if len(word) == 0:\n            return True\n        if row < 0 or row >= rows or col < 0 or col >= cols or visited[row][col] or grid[row][col] != word[0]:\n            return False\n        visited[row][col] = True\n        result = dfs(row + 1, col, word[1:]) or dfs(row - 1, col, word[1:]) or dfs(row, col + 1, word[1:]) or dfs(row, col - 1, word[1:])\n        visited[row][col] = False\n        return result\n    \n    for row in range(rows):\n        for col in range(cols):\n            if dfs(row, col, target):\n                return True\n    return False\n\ndef g():\n    return [['A', 'B', 'C', 'E'],\n            ['S', 'F', 'C', 'S'],\n            ['A', 'D', 'E', 'E']], \"ABCCED\"\n\nassert f(*g())\n",
        "idx_generation": 421,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> int:\n    \"\"\"\n    Given a list of words, find the length of the longest word that can be formed by combining\n    other words in the list. The combined word must be a concatenation of at least two words\n    from the input list.\n    Return the length of the longest combined word, or 0 if no such word exists.\n    \"\"\"\n    max_length = 0\n    word_set = set(words)\n    \n    for word in words:\n        word_set.remove(word)\n        if can_form_word(word, word_set):\n            max_length = max(max_length, len(word))\n        word_set.add(word)\n    \n    return max_length\n\ndef can_form_word(word: str, word_set: set) -> bool:\n    if word in word_set:\n        return True\n    \n    for i in range(1, len(word)):\n        prefix = word[:i]\n        suffix = word[i:]\n        \n        if prefix in word_set and can_form_word(suffix, word_set):\n            return True\n    \n    return False\n\ndef g():\n    \"\"\"\n    Generate a list of words.\n    \"\"\"\n    words = [\"cat\", \"cats\", \"catsdogcats\", \"dog\", \"dogcatsdog\", \"hippopotamuses\", \"rat\", \"ratcatdogcat\"]\n    \n    return words\n\nassert f(g()) == 12\n",
        "idx_generation": 112,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport itertools\n\ndef f(n: int, k: int) -> int:\n    \"\"\"Given two integers n and k, find the kth permutation of the numbers from 1 to n.\"\"\"\n    nums = list(range(1, n+1))\n    permutations = list(itertools.permutations(nums))\n    kth_permutation = permutations[k-1]\n    return int(''.join(map(str, kth_permutation)))\n\ndef g(n: int, k: int):\n    def factorial(num):\n        if num <= 1:\n            return 1\n        return num * factorial(num - 1)\n\n    nums = list(range(1, n+1))\n    result = []\n    k -= 1\n\n    while nums:\n        index = k // factorial(n - 1)\n        result.append(nums.pop(index))\n        k -= index * factorial(n - 1)\n        n -= 1\n\n    return int(''.join(map(str, result)))\n\nn = 4\nk = 9\n\nassert f(n, k) == g(n, k)\n",
        "idx_generation": 155,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, return True if there exists a pair of numbers in the list that add up to the target value, otherwise return False.\"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    return arr, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 342,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Sort a list of integers using the Bubble Sort algorithm.\"\"\"\n    n = len(arr)\n    for i in range(n - 1):\n        for j in range(n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n    return arr\n\ndef g() -> List[int]:\n    \"\"\"Generate a random list of integers.\"\"\"\n    arr = [7, 3, 9, 2, 5, 1, 8, 6, 4]\n    return arr\n\nassert f(g()) == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n",
        "idx_generation": 121,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given an array of integers and a target value, determine if there are three integers in the array whose sum is equal to the target value.\"\"\"\n    arr.sort()\n    n = len(arr)\n\n    for i in range(n - 2):\n        left = i + 1\n        right = n - 1\n\n        while left < right:\n            current_sum = arr[i] + arr[left] + arr[right]\n            if current_sum == target:\n                return True\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n\n    return False\n\ndef g():\n    return [1, 4, 5, 6, 8, 2, 3], 18\n\nassert f(*g())\n",
        "idx_generation": 301,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if the given grid is a valid sudoku solution.\"\"\"\n    # Check rows\n    for row in grid:\n        if sorted(row) != list(range(1, 10)):\n            return False\n    \n    # Check columns\n    for col in range(9):\n        if sorted(grid[row][col] for row in range(9)) != list(range(1, 10)):\n            return False\n    \n    # Check subgrids\n    for i in range(3):\n        for j in range(3):\n            subgrid = [grid[row][col] for row in range(i*3, (i+1)*3) for col in range(j*3, (j+1)*3)]\n            if sorted(subgrid) != list(range(1, 10)):\n                return False\n    \n    return True\n\ndef g():\n    return [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9]\n    ]\n\nassert f(g())\n",
        "idx_generation": 266,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(nums: List[int], target: int) -> Tuple[int, int]:\n    \"\"\"Given a list of integers 'nums' and a target value, find the indices of two numbers in the list that add up to the target.\n    Return a tuple of the indices if such pair exists, (-1, -1) otherwise.\"\"\"\n    num_dict = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return num_dict[complement], i\n        else:\n            num_dict[num] = i\n    \n    return -1, -1\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Generate a list of integers and a target value.\"\"\"\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == (0, 1)\n",
        "idx_generation": 374,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, p: str) -> bool:\n    \"\"\"Given a string s and a pattern p, determine if s matches p.\n    In the pattern, '.' matches any single character and '*' matches zero or more of the preceding element.\n    Return True if s matches p, False otherwise.\n    Example:\n    s = \"aab\"\n    p = \"c*a*b\"\n    The pattern \"c*a*b\" can match the string \"aab\" by 'c' (zero 'a's), 'a' (one 'a') and 'b' (one 'b').\n    Therefore, the answer is True.\n    \"\"\"\n    m, n = len(s), len(p)\n    \n    dp = [[False] * (n+1) for _ in range(m+1)]\n    dp[0][0] = True\n    \n    for i in range(1, n+1):\n        if p[i-1] == '*':\n            dp[0][i] = dp[0][i-2]\n    \n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if p[j-1] == '.' or p[j-1] == s[i-1]:\n                dp[i][j] = dp[i-1][j-1]\n            elif p[j-1] == '*':\n                dp[i][j] = dp[i][j-2]\n                if p[j-2] == '.' or p[j-2] == s[i-1]:\n                    dp[i][j] = dp[i][j] or dp[i-1][j]\n            else:\n                dp[i][j] = False\n    \n    return dp[m][n]\n\ndef g():\n    return \"aab\", \"c*a*b\"\n\nassert f(*g())\n",
        "idx_generation": 214,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"\n    Given an array of integers and a target value k, find if there exists a\n    subarray with a sum equal to k.\n    \"\"\"\n    prefix_sum = 0\n    sum_set = set()\n    for num in arr:\n        prefix_sum += num\n        if prefix_sum == k or prefix_sum - k in sum_set:\n            return True\n        sum_set.add(prefix_sum)\n    return False\n\ndef g():\n    return [3, 4, 7, 2, -3, 1, 4, 2], 7\n\nassert f(*g())\n",
        "idx_generation": 351,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, find if there exist three numbers in the list such that their bitwise XOR is equal to the target.\n    Return True if such triplet of numbers exist, otherwise return False.\n    Sample input:\n    [1, 2, 3, 4, 5, 6], 7\n    Sample output:\n    True\"\"\"\n    n = len(arr)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if arr[i] ^ arr[j] ^ arr[k] == target:\n                    return True\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6], 7\n\nassert f(*g()) == True\n",
        "idx_generation": 125,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(x: int, y: int, z: int) -> bool:\n    \"\"\"Check if the sum of the squares of two numbers is equal to the square of the third number.\"\"\"\n    return x**2 + y**2 == z**2 or x**2 + z**2 == y**2 or y**2 + z**2 == x**2\n\ndef g():\n    \"\"\"Find three numbers that satisfy the condition of the puzzle.\"\"\"\n    for x in range(1, 100):\n        for y in range(1, 100):\n            for z in range(1, 100):\n                if f(x, y, z):\n                    return x, y, z\n\nassert f(*g())\n",
        "idx_generation": 63,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(x: int, y: int) -> bool:\n    \"\"\"Check if two integers are coprime.\n    Coprime integers are those that have no common positive integer divisors other than 1.\n    Sample input:\n    x = 15, y = 28\n    Sample output:\n    True\"\"\"\n    def gcd(a, b):\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n    \n    return gcd(x, y) == 1\n\ndef g():\n    return 15, 28\n\nassert f(*g())\n",
        "idx_generation": 177,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target number, determine if the target number is present in the list.\n    Return True if the target number is present, False otherwise.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n            \n    return False\n\ndef g(nums: List[int], target: int) -> bool:\n    return f(nums, target)\n\nnums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ntarget = 5\nassert f(nums, target) == g(nums, target)\n",
        "idx_generation": 431,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Given an m x n matrix filled with non-negative integers, \n    find the maximum score along a path from the top-left cell to the bottom-right cell.\n    The score of a path is the minimum value in that path.\"\"\"\n    \n    m = len(matrix)\n    n = len(matrix[0])\n    \n    # Function to find the minimum value in a path\n    def find_min_value_in_path(path):\n        min_value = float('inf')\n        for i, j in path:\n            min_value = min(min_value, matrix[i][j])\n        return min_value\n    \n    # Function to find all possible paths from top-left to bottom-right\n    def find_paths(i, j, path):\n        if i == m - 1 and j == n - 1:\n            return [path]\n        \n        paths = []\n        \n        if i < m - 1:\n            paths.extend(find_paths(i + 1, j, path + [(i + 1, j)]))\n        \n        if j < n - 1:\n            paths.extend(find_paths(i, j + 1, path + [(i, j + 1)]))\n        \n        return paths\n    \n    paths = find_paths(0, 0, [(0, 0)])\n    max_score = 0\n    \n    # Finding the maximum score along each path\n    for path in paths:\n        min_value = find_min_value_in_path(path)\n        max_score = max(max_score, min_value)\n    \n    return max_score\n\ndef g():\n    return [\n        [5, 1],\n        [4, 2]\n    ]\n\nassert f(g()) == 2\n",
        "idx_generation": 175,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a subarray where the sum of all elements is equal to zero.\n    Return True if such subarray exists, otherwise return False.\"\"\"\n    prefix_sum = 0\n    sum_set = set()\n    for num in arr:\n        prefix_sum += num\n        if prefix_sum in sum_set or prefix_sum == 0:\n            return True\n        sum_set.add(prefix_sum)\n    return False\n\ndef g():\n    return [2, -3, 1, 6, -1, 2, 4, -2]\n\nassert f(g())\n",
        "idx_generation": 129,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of integers, determine if it is a magic square.\n    A magic square is a square matrix where the sum of each row, each column, and each diagonal are all equal.\"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check columns\n    for j in range(n):\n        col_sum = sum(matrix[i][j] for i in range(n))\n        if col_sum != target_sum:\n            return False\n    \n    # Check main diagonal\n    diagonal_sum = sum(matrix[i][i] for i in range(n))\n    if diagonal_sum != target_sum:\n        return False\n    \n    # Check secondary diagonal\n    secondary_diagonal_sum = sum(matrix[i][n-i-1] for i in range(n))\n    if secondary_diagonal_sum != target_sum:\n        return False\n    \n    return True\n\ndef g() -> List[List[int]]:\n    matrix = [\n        [2, 7, 6],\n        [9, 5, 1],\n        [4, 3, 8]\n    ]\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 197,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"Given a matrix of integers, return the spiral order traversal of the matrix elements.\n    \"\"\"\n    if not matrix:\n        return []\n    \n    m, n = len(matrix), len(matrix[0])\n    left, right, top, bottom = 0, n - 1, 0, m - 1\n    spiral_order = []\n    \n    while left <= right and top <= bottom:\n        for i in range(left, right + 1):\n            spiral_order.append(matrix[top][i])\n        top += 1\n        \n        for i in range(top, bottom + 1):\n            spiral_order.append(matrix[i][right])\n        right -= 1\n        \n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                spiral_order.append(matrix[bottom][i])\n            bottom -= 1\n            \n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                spiral_order.append(matrix[i][left])\n            left += 1\n    \n    return spiral_order\n\ndef g():\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 359,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target sum k, find a continuous subarray within the list\n    that adds up to the target sum. Return the subarray if found, otherwise return an empty list.\n    \"\"\"\n    n = len(nums)\n    prefixSum = [0] * (n + 1)\n    prefixSum[0] = 0\n    \n    # Calculate the prefix sum of the list\n    for i in range(1, n + 1):\n        prefixSum[i] = prefixSum[i - 1] + nums[i - 1]\n    \n    subarray = []\n    seen = {}\n    \n    for i in range(n + 1):\n        complement = prefixSum[i] - k\n        \n        if complement in seen:\n            subarray = nums[seen[complement]:i]\n            break\n        \n        seen[prefixSum[i]] = i\n    \n    return subarray\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target sum k.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    k = 9\n    return nums, k\n\nassert f(*g()) == [2, 3, 4]\n",
        "idx_generation": 474,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(expression: str) -> bool:\n    \"\"\"\n    Given a string 'expression' containing only parentheses ( '(' and ')' ),\n    check if the parentheses are balanced.\n    Return True if the parentheses are balanced, False otherwise.\n    \"\"\"\n    stack = []\n\n    for char in expression:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n\n    return len(stack) == 0\n\ndef g():\n    \"\"\"\n    Generate a string with balanced parentheses.\n    \"\"\"\n    expression = \"((()))\"\n    \n    return expression\n\nassert f(g()) == True\n\n",
        "idx_generation": 483,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Determine if there exists a substring of length k in the given string s, where all characters are unique\"\"\"\n    for i in range(len(s)-k+1):\n        substring = s[i:i+k]\n        if len(set(substring)) == k:\n            return True\n    return False\n\ndef g(k: int) -> str:\n    \"\"\"Generate a string of length k where all characters are unique\"\"\"\n    return ''.join(chr(97+i) for i in range(k))\n\nassert f(g(5), 5)\n",
        "idx_generation": 14,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum subarray sum.\n    A subarray is defined as a contiguous subsequence of the original array.\n    Return the maximum sum.\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"Generate a list of integers.\"\"\"\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 62,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum sum of any contiguous subarray.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    \n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 410,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a subarray with maximum sum.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in arr:\n        current_sum += num\n        if current_sum > max_sum:\n            max_sum = current_sum\n        if current_sum < 0:\n            current_sum = 0\n\n    return max_sum > 0\n\ndef g(arr: List[int]) -> List[int]:\n    \"\"\"Generate a list of integers with at least one subarray that has maximum sum.\"\"\"\n    return arr + [1]\n\nassert f(g([1, -2, 3, 4, -5]))\n",
        "idx_generation": 329,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the index of the smallest positive number in the list.\"\"\"\n    min_index = None\n    min_positive = float('inf')\n    \n    for i, num in enumerate(nums):\n        if num > 0 and num < min_positive:\n            min_positive = num\n            min_index = i\n    \n    return min_index\n\ndef g() -> List[int]:\n    \"\"\"Generate a list of integers.\"\"\"\n    nums = [-3, 5, -1, 2, 0, 7, -4]\n    return nums\n\nassert f(g()) == 3\n",
        "idx_generation": 495,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k=3, n=5) -> bool:\n    \"\"\"Find if a string can be formed by concatenating k copies of a substring of length n\"\"\"\n    if len(s) % (n * k) != 0:\n        return False\n    substring = s[:n]\n    return substring * k == s\ndef g(k=3, n=5):\n    substring = 'abcde'\n    return substring * k\nassert f(g())\n",
        "idx_generation": 288,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums', return a new list where each element is\n    the running sum of the original list from the start to the corresponding index.\n    \"\"\"\n    running_sum = 0\n    res = []\n    \n    for num in nums:\n        running_sum += num\n        res.append(running_sum)\n    \n    return res\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    \n    return nums\n\nassert f(g()) == [1, 3, 6, 10, 15]\n\n",
        "idx_generation": 170,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums' and a target sum, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers.\n    \"\"\"\n    complement = {}\n    \n    for i, num in enumerate(nums):\n        if target - num in complement:\n            return [complement[target - num], i]\n        complement[num] = i\n    \n    return []\n\ndef g():\n    \"\"\"\n    Generate a list of integers and a target sum.\n    \"\"\"\n    nums = [2, 7, 11, 15]\n    target = 9\n    \n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 311,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of 0s and 1s, return the count of all possible unique paths from the top-left corner to the bottom-right corner.\n    You can only move either down or right at any point in time. Additionally, you cannot step on cells with a value of 1.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    \n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                dp[i][j] = 0\n            elif i == 0 and j == 0:\n                dp[i][j] = 1\n            elif i == 0:\n                dp[i][j] = dp[i][j-1]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j]\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[rows-1][cols-1]\n\ndef g(grid: List[List[int]]):\n    return grid\n\nassert f(g([[0, 0, 0], [0, 1, 0], [0, 0, 0]])) == 2\n",
        "idx_generation": 256,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"Given an array of integers arr and a target sum, find two distinct indices i and j\n    such that arr[i] + arr[j] equals the target sum.\n    Return a list containing the indices i and j.\n    Example:\n    arr = [2, 7, 11, 15]\n    target = 9\n    The indices i and j are 0 and 1 respectively, because arr[0] + arr[1] = 2 + 7 = 9.\n    Therefore, the answer is [0, 1].\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(arr):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\ndef g():\n    return [2, 7, 11, 15], 9\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 24,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"Check if the given target value exists in the 2D grid.\"\"\"\n    m, n = len(grid), len(grid[0])\n    stack = []\n    stack.append((0, 0))\n    while stack:\n        x, y = stack.pop()\n        if grid[x][y] == target:\n            return True\n        if x + 1 < m:\n            stack.append((x + 1, y))\n        if y + 1 < n:\n            stack.append((x, y + 1))\n    return False\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]], 5\n\nassert f(*g())\n",
        "idx_generation": 79,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if the target sum can be obtained by combining elements from a given list of integers.\n\n    Args:\n        nums (List[int]): The list of integers.\n        target (int): The target sum.\n\n    Returns:\n        bool: True if the target sum can be obtained, False otherwise.\n\n    Example:\n        Input: nums = [1, 3, 5, 7], target = 10\n        Output: True\n        Explanation: The target sum of 10 can be obtained by combining 3 and 7 (3 + 7 = 10).\n    \"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(1, n + 1):\n        dp[i][0] = True\n        for j in range(1, target + 1):\n            if j < nums[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n    return dp[n][target]\n\ndef g(nums: List[int], target: int) -> bool:\n    return f(nums, target)\n\nnums = [1, 3, 5, 7]\ntarget = 10\nassert f(nums, target) == g(nums, target)\n",
        "idx_generation": 114,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of 0s and 1s, find the maximum area of a rectangle that can be formed by 1s in the grid.\"\"\"\n    def max_area_histogram(heights: List[int]) -> int:\n        stack = []\n        max_area = 0\n        i = 0\n        while i < len(heights):\n            if not stack or heights[i] >= heights[stack[-1]]:\n                stack.append(i)\n                i += 1\n            else:\n                top = stack.pop()\n                area = heights[top] * (i - stack[-1] - 1 if stack else i)\n                max_area = max(max_area, area)\n        while stack:\n            top = stack.pop()\n            area = heights[top] * (i - stack[-1] - 1 if stack else i)\n            max_area = max(max_area, area)\n        return max_area\n\n    m, n = len(grid), len(grid[0])\n    heights = [0] * n\n    max_area = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                heights[j] = 0\n            else:\n                heights[j] += 1\n        max_area = max(max_area, max_area_histogram(heights))\n    return max_area\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    return grid\n\nassert f(g([[1, 0, 1, 0, 0],\n            [1, 0, 1, 1, 1],\n            [1, 1, 1, 1, 1],\n            [1, 0, 0, 1, 0]])) == 6\n\n",
        "idx_generation": 77,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> bool:\n    \"\"\"Check if the grid contains a valid path from the top-left corner to the bottom-right corner without crossing any obstacles.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    stack = [(0, 0)]  # Start at the top-left corner\n    visited = set()\n    while stack:\n        row, col = stack.pop()\n        if (row, col) == (rows-1, cols-1):  # Reached the bottom-right corner\n            return True\n        visited.add((row, col))\n        for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:  # Move right, down, left, up\n            new_row, new_col = row + dr, col + dc\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] != '#' and (new_row, new_col) not in visited:\n                stack.append((new_row, new_col))\n    return False\n\ndef g(grid=[['.', '.', '.', '.', '.', '.'],\n            ['.', '#', '#', '#', '#', '.'],\n            ['.', '.', '.', '.', '.', '.'],\n            ['#', '#', '#', '#', '#', '.'],\n            ['.', '.', '.', '.', '.', '.']]):\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 174,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], k: int) -> bool:\n    \"\"\"Given a grid of 0s and 1s, determine if it is possible to reach the bottom-right corner from the top-left corner\n    by flipping at most k 0s to 1s, and moving only down, right, or diagonally down-right.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    def dfs(i: int, j: int, flips: int) -> bool:\n        if i == rows - 1 and j == cols - 1:\n            return True\n        \n        if i < rows - 1 and (grid[i+1][j] == 1 or flips > 0) and dfs(i+1, j, flips):\n            return True\n        \n        if j < cols - 1 and (grid[i][j+1] == 1 or flips > 0) and dfs(i, j+1, flips):\n            return True\n        \n        if i < rows - 1 and j < cols - 1 and (grid[i+1][j+1] == 1 or flips > 0) and dfs(i+1, j+1, flips):\n            return True\n        \n        if grid[i][j] == 0 and flips > 0 and (i < rows - 1 or j < cols - 1):\n            return dfs(i, j, flips-1)\n        \n        return False\n    \n    return dfs(0, 0, k)\n\ndef g(grid=[[1, 1, 0, 0],\n            [1, 0, 0, 1],\n            [1, 1, 0, 1],\n            [1, 1, 1, 1]], k=1):\n    return grid, k\n\nassert f(*g()) == True\n",
        "idx_generation": 154,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"Find the maximum sum of a path in a grid from the top-left corner to the bottom-right corner.\"\"\"\n    m, n = len(graph), len(graph[0])\n    dp = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                dp[i][j] = graph[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + graph[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + graph[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + graph[i][j]\n    return dp[m-1][n-1]\n\ndef g():\n    return [[1,3,1],[1,5,1],[4,2,1]]\n\nassert f(g()) == 12\n",
        "idx_generation": 285,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string 's', reverse the order of the words in the string while preserving the order of the characters within each word.\n    Return the reversed string.\n    \"\"\"\n    words = s.split()\n    reversed_words = deque(words)\n    reversed_words.reverse()\n    \n    return ' '.join(reversed_words)\n\ndef g():\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    s = \"Hello World\"\n    \n    return s\n\nassert f(g()) == \"World Hello\"\n",
        "idx_generation": 369,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(x: int, a=10) -> bool:\n    \"\"\"Find the minimum number of bits needed to represent a given integer.\"\"\"\n    return 2 ** x > a and 2 ** (x-1) <= a\ndef g(a=10):\n    x = 0\n    while 2 ** x <= a:\n        x += 1\n    return x\nassert f(g())\n",
        "idx_generation": 20,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers 'nums' and a target integer 'target',\n    determine if it is possible to form the target integer by performing\n    bitwise XOR operations on any combination of the elements in 'nums'.\n    Return True if it is possible, False otherwise.\n    Example:\n    nums = [2, 4, 6, 8]\n    target = 10\n    The possible combinations are:\n    2 XOR 8 = 10\n    4 XOR 6 = 10\n    Therefore, the answer is True.\n    \"\"\"\n    def backtrack(curr, idx):\n        if curr == target:\n            return True\n        if idx >= len(nums):\n            return False\n        return backtrack(curr ^ nums[idx], idx + 1) or backtrack(curr, idx + 1)\n    \n    return backtrack(0, 0)\n\ndef g():\n    return [2, 4, 6, 8], 10\n\nassert f(*g())\n",
        "idx_generation": 282,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the binary representation of n is a palindrome\"\"\"\n    binary = bin(n)[2:]\n    return binary == binary[::-1]\n\ndef g(n=9):\n    return n\n\nassert f(g())\n",
        "idx_generation": 242,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of integers, determine if there exists a path from the top-left corner to the bottom-right corner,\n    such that the sum of the integers along the path is a prime number.\"\"\"\n\n    def is_prime(n: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    def dfs(row: int, col: int, path_sum: int) -> bool:\n        if row == rows - 1 and col == cols - 1:\n            return is_prime(path_sum + matrix[row][col])\n        if row < 0 or row >= rows or col < 0 or col >= cols:\n            return False\n\n        new_sum = path_sum + matrix[row][col]\n\n        return dfs(row + 1, col, new_sum) or dfs(row, col + 1, new_sum)\n\n    return dfs(0, 0, 0)\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a matrix of integers.\"\"\"\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 339,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given a positive integer 'n', determine if it is a power of two.\"\"\"\n    return n & (n - 1) == 0 and n != 0\n\ndef g(n: int):\n    return n\n\nassert f(g(16))\n",
        "idx_generation": 266,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency list, determine if there exists a path from start to end.\n    Return True if a path exists, and False otherwise.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node in visited:\n            continue\n        visited.add(node)\n        stack.extend(graph[node])\n    return False\n\ndef g():\n    return [[1, 2], [3], [4], [5], [6], []]\n\nassert f(g(), 0, 6)\n",
        "idx_generation": 140,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start='A', end='Z') -> bool:\n    \"\"\"Check if there exists a path from the start node to the end node in the given graph.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\ndef g(graph={'A': ['B', 'C'], 'B': ['D', 'E'], 'C': ['F'], 'D': [], 'E': [], 'F': ['Z'], 'Z': []}, start='A', end='Z'):\n    return graph\nassert f(g())\n",
        "idx_generation": 25,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(adj_matrix: List[List[int]]) -> bool:\n    \"\"\"Check if there is a cycle in a directed graph represented by an adjacency matrix.\"\"\"\n    visited = [False] * len(adj_matrix)\n    stack = [False] * len(adj_matrix)\n    \n    def dfs(node):\n        visited[node] = True\n        stack[node] = True\n        \n        for neighbor in range(len(adj_matrix)):\n            if adj_matrix[node][neighbor] == 1:\n                if not visited[neighbor]:\n                    if dfs(neighbor):\n                        return True\n                elif stack[neighbor]:\n                    return True\n        \n        stack[node] = False\n        return False\n    \n    for node in range(len(adj_matrix)):\n        if not visited[node]:\n            if dfs(node):\n                return True\n    \n    return False\n\ndef g():\n    return [[0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1],\n            [1, 0, 0, 0]]\n    \nassert f(g())\n",
        "idx_generation": 7,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid filled with non-negative numbers, find the minimum sum path from the top-left corner to the bottom-right corner.\n    You can only move down or right at each step.\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    \n    return dp[m - 1][n - 1]\n\ndef g(grid: List[List[int]]) -> int:\n    return f(grid)\n\ngrid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\nassert f(grid) == g(grid)\n",
        "idx_generation": 131,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str, pattern: str) -> bool:\n    \"\"\"Given a string and a pattern, check if the pattern matches the string, where the pattern can contain wildcard characters '?' and '*'.\n    The wildcard character '?' matches any single character, and the wildcard character '*' matches any sequence of characters (including an empty sequence).\"\"\"\n    m, n = len(string), len(pattern)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n    for i in range(1, n + 1):\n        if pattern[i - 1] == '*':\n            dp[0][i] = dp[0][i - 1]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if pattern[j - 1] == '?' or string[i - 1] == pattern[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            elif pattern[j - 1] == '*':\n                dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n    return dp[m][n]\n\ndef g() -> Tuple[str, str]:\n    \"\"\"Generate a string and a pattern.\"\"\"\n    return (\"abcde\", \"a*d?\")\n\nassert f(*g())\n",
        "idx_generation": 267,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\nfrom math import factorial\n\ndef f(n: int, r: int) -> int:\n    \"\"\"\n    Given two integers n and r, calculate the number of combinations (nCr).\n    \n    Return the result.\n    \"\"\"\n    return factorial(n) // (factorial(r) * factorial(n-r))\n\ndef g():\n    n = 5\n    r = 2\n    return n, r\n\nassert f(*g()) == 10\n",
        "idx_generation": 162,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if the target value exists in the list using binary search.\"\"\"\n    \n    low, high = 0, len(nums) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return False\n\ndef g(nums=[1, 3, 5, 7, 9, 11, 13, 15], target=9):\n    return nums, target\n\nassert f(g()[0], g()[1])\n",
        "idx_generation": 354,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, determine if there are two numbers in the list\n    whose sum is equal to the target number. Return True if such pair exists, otherwise return False.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        \n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 15\n\nassert f(*g()) == True\n",
        "idx_generation": 135,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return a list with the maximum number from each column.\n    \"\"\"\n    max_numbers = []\n    for col in range(len(matrix[0])):\n        max_num = float('-inf')\n        for row in range(len(matrix)):\n            if matrix[row][col] > max_num:\n                max_num = matrix[row][col]\n        max_numbers.append(max_num)\n    return max_numbers\n\ndef g():\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [7, 8, 9]\n",
        "idx_generation": 332,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"Check if the target number exists in the grid, where each row and column is sorted in non-decreasing order\"\"\"\n    m, n = len(grid), len(grid[0])\n    i, j = 0, n - 1\n\n    while i < m and j >= 0:\n        if grid[i][j] == target:\n            return True\n        elif grid[i][j] < target:\n            i += 1\n        else:\n            j -= 1\n\n    return False\n\ndef g():\n    return [[1, 4, 7],\n            [2, 5, 8],\n            [3, 6, 9]]\n\nassert f(g(), 5)\n",
        "idx_generation": 279,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum sum of a subarray in a given list of integers.\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    \"\"\"Generate a list of integers.\"\"\"\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 325,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum XOR value of any two numbers in the given list.\n    XOR is a binary operation that returns 1 if the corresponding bits of two numbers are different,\n    and 0 if they are the same. Return the maximum XOR value.\"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            if xor > max_xor:\n                max_xor = xor\n    return max_xor\n\ndef g():\n    \"\"\"Generate a list of random numbers.\"\"\"\n    nums = [3, 5, 9, 2, 8, 1, 6]\n    return nums\n\nassert f(g()) == 15\n",
        "idx_generation": 130,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exist two numbers in the list that sum up to the target\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(target=10):\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9], target\n\nassert f(*g())\n",
        "idx_generation": 68,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(ans: int, target=100) -> bool:\n    \"\"\"Find a number that can be expressed as the product of two distinct prime numbers and is less than the target\"\"\"\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    primes = [i for i in range(2, target) if is_prime(i)]\n    for i in range(len(primes)):\n        for j in range(i+1, len(primes)):\n            if primes[i] * primes[j] == ans:\n                return True\n    return False\n\ndef g(target=100):\n    return 35\n\nassert f(g())\n",
        "idx_generation": 240,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of 0s and 1s, determine if there exists a path from the top-left corner to the bottom-right corner\n    by flipping the minimum number of cells such that all the 0 cells are connected.\n    Example:\n    grid = [\n        [1, 0, 1],\n        [1, 1, 0],\n        [0, 1, 1]\n    ]\n    Output: True\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    def dfs(row, col):\n        if row == rows - 1 and col == cols - 1:\n            return True\n        \n        if grid[row][col] == 0:\n            return False\n        \n        grid[row][col] = 0\n        \n        for d in directions:\n            new_row = row + d[0]\n            new_col = col + d[1]\n            \n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] != 0:\n                if dfs(new_row, new_col):\n                    return True\n                \n        return False\n    \n    return dfs(0, 0)\n\ndef g():\n    return [\n        [1, 0, 1],\n        [1, 1, 0],\n        [0, 1, 1]\n    ]\n\nassert f(g())\n",
        "idx_generation": 178,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"Given a grid of characters, find the number of islands.\n    An island is represented by '1' and is surrounded by water ('0').\n    A group of connected '1's forms an island.\n    Return the total number of islands in the grid.\"\"\"\n    if not grid:\n        return 0\n\n    rows, cols = len(grid), len(grid[0])\n    count = 0\n\n    def dfs(i, j):\n        if i < 0 or i >= rows or j < 0 or j >= cols or grid[i][j] != '1':\n            return\n        grid[i][j] = '0'\n        dfs(i+1, j)\n        dfs(i-1, j)\n        dfs(i, j+1)\n        dfs(i, j-1)\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == '1':\n                count += 1\n                dfs(i, j)\n\n    return count\n\ndef g():\n    return [\n        ['1', '1', '0', '0', '0'],\n        ['1', '1', '0', '0', '0'],\n        ['0', '0', '1', '0', '0'],\n        ['0', '0', '0', '1', '1']\n    ]\n\nassert f(g()) == 3\n",
        "idx_generation": 181,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if the given matrix is a symmetric matrix.\"\"\"\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i+1, n):\n            if matrix[i][j] != matrix[j][i]:\n                return False\n    return True\ndef g():\n    matrix = [[1, 2, 3],\n              [2, 4, 5],\n              [3, 5, 6]]\n    return matrix\nassert f(g())\n",
        "idx_generation": 211,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(expression: str) -> bool:\n    \"\"\"Given a string 'expression' containing only the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n    An input string is valid if:\n    1. Open brackets must be closed by the same type of brackets.\n    2. Open brackets must be closed in the correct order.\n    Return True if the string is valid, False otherwise.\"\"\"\n    stack = []\n    opening = set(['(', '{', '['])\n    closing = set([')', '}', ']'])\n    pairs = {'(': ')', '{': '}', '[': ']'}\n    for char in expression:\n        if char in opening:\n            stack.append(char)\n        elif char in closing:\n            if not stack or pairs[stack.pop()] != char:\n                return False\n    return len(stack) == 0\n\ndef g(expression: str) -> str:\n    \"\"\"Return the given string.\"\"\"\n    return expression\n\nassert f(g(\"({[()]})\")) == True\n",
        "idx_generation": 485,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of integers in the given list that sum up to the target\"\"\"\n    seen = set()\n    for num in nums:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g():\n    return ([2, 4, 6, 8], 10)\n\nassert f(*g())\n",
        "idx_generation": 37,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Given two integers 'n' and 'k', determine if there exist 'k' distinct positive integers\n    less than or equal to 'n' whose sum is exactly equal to 'n'.\"\"\"\n    if k > n or k * (k + 1) // 2 > n:\n        return False\n    return True\n\ndef g():\n    return (10, 3)\n\nassert f(*g())\n",
        "idx_generation": 20,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer `n`, calculate the number of trailing zeros in n!\n    (the factorial of n).\n    \"\"\"\n    count = 0\n    i = 5\n    while n // i >= 1:\n        count += n // i\n        i *= 5\n    return count\n\ndef g(n: int):\n    \"\"\"\n    Generate a positive integer `n` such that the number of trailing zeros in n!\n    (the factorial of n) can be calculated.\n    \"\"\"\n    return n\n\nassert f(g(10)) == 2\n",
        "idx_generation": 77,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"\n    Given an array of integers, determine if there exists a subarray of length k such that the sum of its elements is divisible by k.\n\n    Example:\n    Input: arr = [4, 8, 2, 6], k = 2\n    Output: True\n    Explanation: The subarray [8, 2] has a sum of 10, which is divisible by 2.\n    \"\"\"\n\n    prefix_sum = 0\n    prefix_sum_mod_k = {}\n    prefix_sum_mod_k[0] = -1\n\n    for i, num in enumerate(arr):\n        prefix_sum += num\n        prefix_sum_mod = prefix_sum % k\n\n        if prefix_sum_mod in prefix_sum_mod_k:\n            if i - prefix_sum_mod_k[prefix_sum_mod] >= k:\n                return True\n        else:\n            prefix_sum_mod_k[prefix_sum_mod] = i\n\n    return False\n\ndef g():\n    arr = [4, 8, 2, 6]\n    k = 2\n    return arr, k\n\nassert f(*g()) == True\n",
        "idx_generation": 474,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int, nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers and an integer k, determine if there exists two distinct indices i and j such that \n    nums[i] + nums[j] = k. Return True if such indices exist, otherwise return False.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if k - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(n=5, k=10, nums=[2, 4, 6, 8, 10]):\n    return n, k, nums\n\nassert f(*g()) == True\n",
        "idx_generation": 397,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums', return a new list where each element is the product of all the numbers in the original list except itself.\n    For example, if nums = [1, 2, 3, 4], the output should be [24, 12, 8, 6].\n    \"\"\"\n    n = len(nums)\n    left = [1] * n\n    right = [1] * n\n    output = [1] * n\n    \n    for i in range(1, n):\n        left[i] = left[i-1] * nums[i-1]\n    \n    for i in range(n-2, -1, -1):\n        right[i] = right[i+1] * nums[i+1]\n    \n    for i in range(n):\n        output[i] = left[i] * right[i]\n    \n    return output\n\ndef g():\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == [24, 12, 8, 6]\n",
        "idx_generation": 375,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, return True if there exists a subarray with a sum equal to zero.\"\"\"\n    prefix_sum = 0\n    seen = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum in seen or prefix_sum == 0:\n            return True\n        seen.add(prefix_sum)\n    return False\n\ndef g():\n    nums = [1, -2, 3, 4, -5]\n    return nums\n\nassert f(g())\n",
        "idx_generation": 171,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum sum of a subarray within a given list of integers.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(current_sum + num, num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 335,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if a given matrix is a magic square.\"\"\"\n    n = len(matrix)\n    target_sum = n * (n ** 2 + 1) // 2\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for j in range(n):\n        if sum(matrix[i][j] for i in range(n)) != target_sum:\n            return False\n\n    # Check diagonals\n    if sum(matrix[i][i] for i in range(n)) != target_sum:\n        return False\n    if sum(matrix[i][n - i - 1] for i in range(n)) != target_sum:\n        return False\n\n    return True\n\ndef g(n=3):\n    \"\"\"Generate a magic square of size n.\"\"\"\n    magic_square = [[0] * n for _ in range(n)]\n    i, j = 0, n // 2\n    num = 1\n\n    while num <= n ** 2:\n        magic_square[i][j] = num\n        num += 1\n\n        new_i = (i - 1) % n\n        new_j = (j + 1) % n\n\n        if magic_square[new_i][new_j] != 0:\n            i += 1\n        else:\n            i, j = new_i, new_j\n\n    return magic_square\n\nassert f(g())\n",
        "idx_generation": 410,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of integers, find the sum of all elements in the matrix.\"\"\"\n    if len(matrix) == 0 or len(matrix[0]) == 0:\n        return False\n    total_sum = 0\n    for row in matrix:\n        total_sum += sum(row)\n    return total_sum\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nassert f(g()) == 45\n",
        "idx_generation": 25,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(expression: str) -> bool:\n    \"\"\"Given a string containing only the characters '(' and ')', determine if the parentheses are balanced.\"\"\"\n    stack = []\n\n    for char in expression:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n\n    return len(stack) == 0\n\ndef g():\n    return \"((()))\"\n\nassert f(g())\n",
        "idx_generation": 86,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum sum of a subarray in nums\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 118,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of 0's and 1's, find the size of the largest square containing only 1's.\n\n    Args:\n        grid (List[List[int]]): The grid of 0's and 1's.\n\n    Returns:\n        int: The size of the largest square containing only 1's.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n    max_size = 0\n\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            if grid[i - 1][j - 1] == 1:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                max_size = max(max_size, dp[i][j])\n\n    return max_size * max_size\n\ndef g(grid: List[List[int]]) -> int:\n    return f(grid)\n\ngrid = [\n    [1, 0, 1, 0, 0],\n    [1, 0, 1, 1, 1],\n    [1, 1, 1, 1, 1],\n    [1, 0, 0, 1, 0]\n]\nassert f(grid) == g(grid)\n",
        "idx_generation": 127,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if the grid contains a valid path from the top-left corner to the bottom-right corner without crossing any obstacles.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    stack = [(0, 0)]  # Start at the top-left corner\n    visited = set()\n    while stack:\n        row, col = stack.pop()\n        if (row, col) == (rows-1, cols-1):  # Reached the bottom-right corner\n            return True\n        visited.add((row, col))\n        for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:  # Move right, down, left, up\n            new_row, new_col = row + dr, col + dc\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] != 1 and (new_row, new_col) not in visited:\n                stack.append((new_row, new_col))\n    return False\n\ndef g(grid=[[0, 0, 0, 0, 0],\n            [0, 1, 1, 1, 0],\n            [0, 0, 0, 0, 0],\n            [1, 1, 1, 1, 0],\n            [0, 0, 0, 0, 0]]):\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 194,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid with '0' representing an empty cell, '1' representing a wall, and '9' representing the target, \n    determine if there exists a path from the top-left corner to the target, using only downwards, rightwards, and diagonal movements.\n    You can only move in the directions: down, right, and down-right (diagonal).\n    Example:\n    grid = [[0, 1, 0],\n            [0, 0, 1],\n            [0, 0, 9]]\n    Output: True\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    visited = [[False] * cols for _ in range(rows)]\n    \n    def dfs(x, y):\n        if x == rows - 1 and y == cols - 1:\n            return True\n        visited[x][y] = True\n        dx = [1, 0, 1]\n        dy = [0, 1, 1]\n        for i in range(3):\n            nx, ny = x + dx[i], y + dy[i]\n            if nx < rows and ny < cols and not visited[nx][ny] and grid[nx][ny] != 1:\n                if dfs(nx, ny):\n                    return True\n        return False\n    \n    return dfs(0, 0)\n\ndef g():\n    return [[0, 1, 0],\n            [0, 0, 1],\n            [0, 0, 9]]\n\nassert f(g())\n",
        "idx_generation": 167,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool:\n    \"\"\"Given a grid represented as a 2D list of integers, determine if it is possible to reach from the start position to the end position.\n    You can only move in four directions: up, down, left, and right.\n    Return True if it is possible to reach the end position, False otherwise.\n    Example input:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [0, 1, 1, 1, 1],\n        [1, 0, 0, 0, 1],\n        [1, 1, 1, 1, 1],\n        [1, 1, 1, 1, 1]\n    ]\n    start = (0, 0)\n    end = (4, 4)\n    Example output:\n    True\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def dfs(row: int, col: int) -> bool:\n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] == 0:\n            return False\n\n        if row == end[0] and col == end[1]:\n            return True\n\n        grid[row][col] = 0\n        return dfs(row - 1, col) or dfs(row + 1, col) or dfs(row, col - 1) or dfs(row, col + 1)\n\n    return dfs(start[0], start[1])\n\ndef g():\n    return [\n        [1, 1, 0, 0, 0],\n        [0, 1, 1, 1, 1],\n        [1, 0, 0, 0, 1],\n        [1, 1, 1, 1, 1],\n        [1, 1, 1, 1, 1]\n    ]\n\nassert f(g(), (0, 0), (4, 4))\n",
        "idx_generation": 333,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> str:\n    \"\"\"Given a string s and an integer k, find the lexicographically smallest string that can be formed by removing k characters from s.\n    Example:\n    s = \"leetcode\", k = 3\n    Output: \"code\"\n    Explanation: The lexicographically smallest string that can be formed by removing 3 characters from \"leetcode\" is \"code\".\"\"\"\n    stack = []\n    remaining = k\n    \n    for c in s:\n        while stack and stack[-1] > c and remaining > 0:\n            stack.pop()\n            remaining -= 1\n        stack.append(c)\n    \n    return ''.join(stack[:len(s)-k])\n\ndef g(s: str, k: int) -> str:\n    \"\"\"Find the lexicographically smallest string that can be formed by removing k characters from s.\"\"\"\n    stack = []\n    remaining = k\n    \n    for c in s:\n        while stack and stack[-1] > c and remaining > 0:\n            stack.pop()\n            remaining -= 1\n        stack.append(c)\n    \n    return ''.join(stack[:len(s)-k])\n\nassert f(s=\"leetcode\", k=3) == g(s=\"leetcode\", k=3)\n",
        "idx_generation": 431,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, x: int, y: int):\n    \"\"\"Find the total number of bits set to 1 in the binary representation of all numbers from 1 to n, inclusive.\"\"\"\n    count = 0\n    for i in range(1, n+1):\n        count += bin(i)[2:].count('1')\n    return count % (x + y) == 0\n\ndef g(n: int, x: int, y: int):\n    count = 0\n    for i in range(1, n+1):\n        count += bin(i)[2:].count('1')\n    return count\n\nassert f(g(10, 2, 3), 2, 3)\n",
        "idx_generation": 29,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if it is possible to select a subset of the integers such that their bitwise OR equals the target value.\n    Return True if it is possible, and False otherwise.\"\"\"\n    \n    def backtrack(nums: List[int], target: int, index: int, current: int) -> bool:\n        if current == target:\n            return True\n        \n        if index == len(nums):\n            return False\n        \n        if backtrack(nums, target, index + 1, current | nums[index]):\n            return True\n        \n        return backtrack(nums, target, index + 1, current)\n\n    return backtrack(nums, target, 0, 0)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Generate a random list of integers and a random target value.\"\"\"\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 387,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Given a string 's' and an integer 'k',\n    determine if it is possible to rearrange the characters in 's'\n    in such a way that the bitwise XOR between any two adjacent characters is equal to 'k'.\n    Return True if it is possible, False otherwise.\n    Example:\n    s = \"abcabc\"\n    k = 3\n    The possible rearrangements are \"abacbc\", \"bacabc\", \"cbabac\", \"acbacb\", \"bcabac\".\n    All of these rearrangements have the bitwise XOR between any two adjacent characters equal to 3.\n    Therefore, the answer is True.\n    \"\"\"\n    if len(set(s)) < k:\n        return False\n    return True\n\ndef g():\n    return \"abcabc\", 3\n\nassert f(*g())\n",
        "idx_generation": 269,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of positive integers, find the minimum sum path from the top-left to the bottom-right corner.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[float('inf')] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for row in range(rows):\n        for col in range(cols):\n            if row > 0:\n                dp[row][col] = min(dp[row][col], dp[row - 1][col] + grid[row][col])\n            if col > 0:\n                dp[row][col] = min(dp[row][col], dp[row][col - 1] + grid[row][col])\n\n    return dp[rows - 1][cols - 1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 416,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, find the number of pairs (i, j) where i < j and nums[i] XOR nums[j] is a perfect square.\n\n    Return True if the count of such pairs is odd, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor_result = nums[i] ^ nums[j]\n            if int(xor_result**0.5)**2 == xor_result:\n                count += 1\n    return count % 2 == 1\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g())\n",
        "idx_generation": 354,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(adj_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representing a directed graph, check if the graph contains a cycle.\n\n    Args:\n    - adj_matrix: A 2D list of integers representing the adjacency matrix of the graph.\n    \n    Returns:\n    - True if the graph contains a cycle, False otherwise.\n    \"\"\"\n    visited = [False] * len(adj_matrix)\n    stack = [False] * len(adj_matrix)\n\n    def dfs(node):\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in range(len(adj_matrix[node])):\n            if adj_matrix[node][neighbor] == 1:\n                if not visited[neighbor]:\n                    if dfs(neighbor):\n                        return True\n                elif stack[neighbor]:\n                    return True\n\n        stack[node] = False\n        return False\n\n    for node in range(len(adj_matrix)):\n        if not visited[node]:\n            if dfs(node):\n                return True\n\n    return False\n\ndef g(adj_matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Rearrange the adjacency matrix of a directed graph to break any cycle (if present).\n\n    Args:\n    - adj_matrix: A 2D list of integers representing the adjacency matrix of the graph.\n    \n    Returns:\n    - The rearranged adjacency matrix of the graph with broken cycles.\n    \"\"\"\n    def topological_sort(node, visited, stack):\n        visited[node] = True\n\n        for neighbor in range(len(adj_matrix[node])):\n            if adj_matrix[node][neighbor] == 1:\n                if not visited[neighbor]:\n                    topological_sort(neighbor, visited, stack)\n        \n        stack.append(node)\n\n    visited = [False] * len(adj_matrix)\n    stack = []\n\n    for node in range(len(adj_matrix)):\n        if not visited[node]:\n            topological_sort(node, visited, stack)\n    \n    new_adj_matrix = [[0] * len(adj_matrix) for _ in range(len(adj_matrix))]\n\n    for i in range(len(stack)-1, -1, -1):\n        node = stack[i]\n        for neighbor in range(len(adj_matrix[node])):\n            if adj_matrix[node][neighbor] == 1:\n                new_adj_matrix[neighbor][node] = 1\n    \n    return new_adj_matrix\n\n# Test case\nadj_matrix = [\n    [0, 1, 0, 0],\n    [0, 0, 1, 1],\n    [1, 0, 0, 0],\n    [0, 0, 0, 0]\n]\n\nassert f(g(adj_matrix))\n",
        "idx_generation": 147,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(adjacency_list: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given an adjacency list representation of a directed graph, determine if there exists a path from the start node to the end node.\n    Return True if a path exists, False otherwise.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(adjacency_list[node])\n    return False\n\ndef g() -> Tuple[List[List[int]], int, int]:\n    \"\"\"Generate a random directed graph represented by an adjacency list, along with a start and end node.\"\"\"\n    adjacency_list = [[1, 2], [3], [4], [2, 5], [1, 6], [7], [7], []]\n    start = 0\n    end = 7\n    return adjacency_list, start, end\n\nassert f(*g())\n",
        "idx_generation": 32,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> int:\n    \"\"\"Given a number of nodes n and a list of directed edges, find the maximum depth of the directed graph.\n    The depth of a directed graph is the length of the longest path from any node to a leaf node.\n    Return the maximum depth.\n    Example:\n    n = 5\n    edges = [[0, 1], [1, 2], [1, 3], [2, 4]]\n    The directed graph is: 0 -> 1 -> 2 -> 4\n                              -> 3\n    The maximum depth is 3, as the longest path is from node 0 to node 4.\n    Therefore, the answer is 3.\n    \"\"\"\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n    return dfs(graph, 0)\n\ndef dfs(graph, node):\n    if not graph[node]:\n        return 0\n    depths = [dfs(graph, child) for child in graph[node]]\n    return max(depths) + 1\n\ndef g():\n    return 5, [[0, 1], [1, 2], [1, 3], [2, 4]]\n\nassert f(*g()) == 3\n",
        "idx_generation": 27,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start=0, target=5) -> bool:\n    \"\"\"Find if there is a path from start to target in the given graph\"\"\"\n    visited = set()\n    \n    def dfs(node):\n        visited.add(node)\n        if node == target:\n            return True\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n        return False\n    \n    return dfs(start)\n\ndef g():\n    graph = [\n        [1, 2],\n        [0, 3],\n        [0, 4],\n        [1, 5],\n        [2, 5],\n        [3, 4]\n    ]\n    return graph\n\nassert f(g())\n",
        "idx_generation": 9,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[str]]) -> bool:\n    \"\"\"Given a grid of characters, determine if there is a valid path from the top-left corner to the bottom-right corner.\n    A valid path can only move right or down and cannot visit the same cell more than once.\n    Return True if there is a valid path, False otherwise.\"\"\"\n    def dfs(row, col):\n        if row == len(grid) - 1 and col == len(grid[0]) - 1:\n            return True\n\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] == \"#\":\n            return False\n\n        char = grid[row][col]\n        grid[row][col] = \"#\"  # Mark the current cell as visited\n\n        if dfs(row + 1, col) or dfs(row, col + 1):\n            return True\n\n        grid[row][col] = char  # Revert the cell back to its original value\n        return False\n\n    return dfs(0, 0)\n\ndef g():\n    return [['.', '.', '#', '.'],\n            ['.', '#', '.', '.'],\n            ['.', '.', '.', '.'],\n            ['.', '#', '#', '.']]  # Grid with a valid path\n\nassert f(g())\n",
        "idx_generation": 137,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k=3) -> bool:\n    \"\"\"Determine if there exists a combination of n numbers from the set {1, 2, ..., k} that add up to n\"\"\"\n    def helper(n, k, curr_sum):\n        if curr_sum == n:\n            return True\n        if curr_sum > n or k == 0:\n            return False\n        return helper(n, k-1, curr_sum) or helper(n, k-1, curr_sum+k)\n    return helper(n, k, 0)\ndef g(k=3):\n    return k\nassert f(g())\n",
        "idx_generation": 5,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine if there exists a binary string of length n such that the number of 1's is divisible by 3\"\"\"\n    def count_ones(binary):\n        return binary.count('1')\n    \n    for i in range(2**n):\n        binary = bin(i)[2:].zfill(n)\n        if count_ones(binary) % 3 == 0:\n            return True\n    return False\n\ndef g(n: int):\n    return n\n\nassert f(g(n=4))\n",
        "idx_generation": 434,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Find whether there exists a combination of n numbers from 1 to k (inclusive) such that their sum is divisible by k.\"\"\"\n    count = 0\n    for i in range(1, k+1):\n        if n % i == 0:\n            count += 1\n    return count == n\n\ndef g(k: int) -> int:\n    n = 1\n    while True:\n        if f(n, k):\n            return n\n        n += 1\n\nassert f(g(k=5), k=5)\n",
        "idx_generation": 179,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers 'nums' and a target integer, find the indices of two numbers in the list\n    that add up to the target. If no such pair exists, return an empty list.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        if nums[left] + nums[right] == target:\n            return [left, right]\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g():\n    \"\"\"\n    Generate a sorted list of integers and a target integer.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    target = 8\n    \n    return nums, target\n\nassert f(*g()) == [2, 4]\n",
        "idx_generation": 410,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Sort the given array using the Bubble Sort algorithm.\"\"\"\n    n = len(arr)\n    \n    for i in range(n-1):\n        for j in range(n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    \n    return arr\n\ndef g():\n    return [5, 2, 8, 12, 1, 3]\n\nassert f(g()) == [1, 2, 3, 5, 8, 12]\n",
        "idx_generation": 150,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there is a pair of numbers in a given array that sums up to the target value\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 337,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"Given an m x n matrix, rotate it 90 degrees clockwise in-place.\"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n    for i in range(m // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[m - 1 - j][i]\n            matrix[m - 1 - j][i] = matrix[m - 1 - i][n - 1 - j]\n            matrix[m - 1 - i][n - 1 - j] = matrix[j][n - 1 - i]\n            matrix[j][n - 1 - i] = temp\n    return matrix\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(matrix=g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 327,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string s, return True if it is a palindrome, False otherwise.\n    A palindrome is a string that reads the same forwards and backwards.\n    \"\"\"\n    n = len(s)\n    for i in range(n // 2):\n        if s[i] != s[n - i - 1]:\n            return False\n    return True\n\ndef g():\n    s = \"racecar\"\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 330,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, lst: List[int]) -> bool:\n    \"\"\"Check if the given list is sorted in non-decreasing order and if the given number is a power of 2.\"\"\"\n    is_sorted = all(lst[i] <= lst[i+1] for i in range(len(lst)-1))\n\n    is_power_of_two = n & (n - 1) == 0\n\n    return is_sorted and is_power_of_two\n\ndef g():\n    n = 8\n    lst = [1, 2, 3, 4, 5]\n    return n, lst\n\nassert f(*g())\n",
        "idx_generation": 162,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a given number is a perfect square.\"\"\"\n    if n < 0:\n        return False\n    left = 0\n    right = n\n    while left <= right:\n        mid = left + (right - left) // 2\n        if mid * mid == n:\n            return True\n        elif mid * mid < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef g():\n    n = 16\n    return n\n\nassert f(g())\n",
        "idx_generation": 129,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers and a target number, find the minimum number of elements needed to be removed from the list so that the sum of the remaining elements is greater than or equal to the target.\"\"\"\n    nums.sort(reverse=True)\n    total_sum = sum(nums)\n    if total_sum <= target:\n        return 0\n    curr_sum = 0\n    count = 0\n    for num in nums:\n        curr_sum += num\n        count += 1\n        if curr_sum >= target:\n            return count\n    return count\n\ndef g():\n    nums = [4, 6, 2, 8, 5, 3]\n    target = 20\n    return nums, target\n\nassert f(*g()) == 4\n",
        "idx_generation": 289,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(sudoku: List[List[int]]) -> bool:\n    \"\"\"Solve a 9x9 Sudoku puzzle.\"\"\"\n    def is_valid(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    def solve_sudoku(board):\n        for row in range(9):\n            for col in range(9):\n                if board[row][col] == 0:\n                    for num in range(1, 10):\n                        if is_valid(board, row, col, num):\n                            board[row][col] = num\n                            if solve_sudoku(board):\n                                return True\n                            board[row][col] = 0\n                    return False\n        return True\n\n    return solve_sudoku(sudoku)\n\ndef g():\n    return [[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]\n\nassert f(g())\n",
        "idx_generation": 186,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"Rotate a square matrix 90 degrees clockwise\"\"\"\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n\n    return matrix\n\ndef g():\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 307,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Given a matrix of integers and a target value, determine if the target value exists in the matrix.\"\"\"\n\n    if not matrix or not matrix[0]:\n        return False\n\n    rows, cols = len(matrix), len(matrix[0])\n    row, col = 0, cols - 1\n\n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n\n    return False\n\ndef g(matrix=[[1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]], target=16):\n    return matrix, target\n\nassert f(g()[0], g()[1])\n",
        "idx_generation": 232,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given an array of integers arr and a target sum, determine if there exist three distinct indices i, j, and k\n    such that arr[i] + arr[j] + arr[k] equals the target sum.\n    Return True if such indices exist, False otherwise.\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 9\n    The indices i, j, and k are 0, 1, and 4 respectively, because arr[0] + arr[1] + arr[4] = 1 + 2 + 5 = 9.\n    Therefore, the answer is True.\n    \"\"\"\n    n = len(arr)\n    for i in range(n-2):\n        for j in range(i+1, n-1):\n            for k in range(j+1, n):\n                if arr[i] + arr[j] + arr[k] == target:\n                    return True\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5], 9\n\nassert f(*g()) == True\n",
        "idx_generation": 31,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, check if the list can be partitioned into two subarrays such that the sum of elements in both subarrays is equal.\n    \n    Example:\n    nums = [1, 5, 11, 5]\n    The list can be partitioned into [1, 5, 5] and [11] with equal sums, so the output should be True.\n    \n    nums = [1, 2, 3, 5]\n    The list cannot be partitioned into two subarrays with equal sums, so the output should be False.\n    \"\"\"\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n    \n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    \n    for num in nums:\n        for i in range(target_sum, num-1, -1):\n            if dp[i-num]:\n                dp[i] = True\n    \n    return dp[target_sum]\n\ndef g():\n    return [1, 5, 11, 5]\n\nassert f(g()) == True\n",
        "idx_generation": 53,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], x: int) -> bool:\n    \"\"\"Check if x is a prime number and present in the sorted array\"\"\"\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    arr.sort()\n    if is_prime(x):\n        return x in arr\n    return False\n\ndef g(arr=[10, 5, 3, 8, 2], x=3):\n    return arr, x\n\nassert f(*g())\n",
        "idx_generation": 47,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(n: int) -> bool:\n    \"\"\"Check if a number n is a prime number.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17  # Return the number to be checked\n\nassert f(g()) == True\n",
        "idx_generation": 85,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers and a target number, find the minimum number of elements in a contiguous subarray whose sum is greater than or equal to the target.\n    Return the minimum number of elements.\n    \"\"\"\n    def min_subarray_len(nums, target):\n        n = len(nums)\n        min_len = float('inf')\n        left = 0\n        curr_sum = 0\n        \n        for right in range(n):\n            curr_sum += nums[right]\n            while curr_sum >= target:\n                min_len = min(min_len, right - left + 1)\n                curr_sum -= nums[left]\n                left += 1\n        \n        return min_len if min_len != float('inf') else 0\n    \n    return min_subarray_len(nums, target)\n\ndef g():\n    nums = [4, 3, 1, 7, 2]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 1\n",
        "idx_generation": 423,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Return the longest palindrome substring in the given string s.\"\"\"\n    n = len(s)\n    longest_palindrome = \"\"\n    \n    for i in range(n):\n        for j in range(i, n):\n            substring = s[i:j+1]\n            if substring == substring[::-1] and len(substring) > len(longest_palindrome):\n                longest_palindrome = substring\n    \n    return longest_palindrome\n\ndef g():\n    return \"racecarstacocar\"\n\nassert f(g()) == \"racecar\"\n",
        "idx_generation": 424,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, return a new list where each element is the sum of all the elements in the original list except for the current element.\"\"\"\n    total_sum = sum(nums)\n    return [total_sum - num for num in nums]\ndef g():\n    return [1, 2, 3, 4, 5]\nassert f(g()) == [14, 13, 12, 11, 10]\n",
        "idx_generation": 236,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Count the number of even elements in the list.\"\"\"\n    count = 0\n    for num in nums:\n        if num % 2 == 0:\n            count += 1\n    return count\n\ndef g():\n    return ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],)\n\nassert f(*g()) == 5\n",
        "idx_generation": 495,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of integers, check if there exists a path from the top-left element to the bottom-right element, where the sum of the numbers along the path is equal to a given target value.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    target = 10\n    dp = [[False] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0] == target\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] or (grid[i][0] == target)\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] or (grid[0][j] == target)\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            if dp[i-1][j] or dp[i][j-1]:\n                dp[i][j] = True\n            if grid[i][j] == target:\n                dp[i][j] = True\n\n    return dp[rows-1][cols-1]\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 10]]\n\nassert f(g())\n",
        "idx_generation": 480,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a number is a Fibonacci number.\"\"\"\n    def is_perfect_square(x):\n        return x ** 0.5 % 1 == 0\n\n    return is_perfect_square(5 * n ** 2 + 4) or is_perfect_square(5 * n ** 2 - 4)\n\ndef g():\n    return 8\n\nassert f(int(g()))\n",
        "idx_generation": 55,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(expression: str) -> bool:\n    \"\"\"Determine if the given expression is balanced.\n    The expression is considered balanced if it contains pairs of opening and closing brackets\n    that are properly nested and ordered.\"\"\"\n    stack = []\n    opening_brackets = ['(', '[', '{']\n    closing_brackets = [')', ']', '}']\n    for char in expression:\n        if char in opening_brackets:\n            stack.append(char)\n        elif char in closing_brackets:\n            if not stack:\n                return False\n            if opening_brackets.index(stack[-1]) != closing_brackets.index(char):\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g(n: int) -> str:\n    \"\"\"Generate a string of length n that contains pairs of nested brackets.\"\"\"\n    return '(' * (n // 2) + ')' * (n // 2)\n\nassert f(expression=g(n=6))\n",
        "idx_generation": 117,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], k: int, target: int) -> bool:\n    \"\"\"Given an array of integers and a target value, determine if it is possible to split the array into two non-empty subarrays\n    such that the bitwise XOR of all elements in each subarray is equal to the target value.\"\"\"\n    def helper(nums: List[int], target: int, k: int, currXor: int, startIndex: int) -> bool:\n        if k == 0:\n            return currXor == target\n        if startIndex >= len(nums):\n            return False\n        for i in range(startIndex, len(nums)):\n            newTarget = currXor ^ nums[i]\n            if helper(nums, target, k - 1, newTarget, i + 1):\n                return True\n        return False\n\n    return helper(arr, target, k, 0, 0)\n\ndef g(arr=[1, 2, 3, 4, 5], k=2, target=3):\n    return arr\n\nassert f(g(), k=2, target=3)\n",
        "idx_generation": 3,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid, return the minimum number of steps required to reach the bottom-right corner from the top-left corner. You can only move down or to the right.\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    queue = deque([(0, 0)])\n    \n    while queue:\n        x, y = queue.popleft()\n        moves = [(1, 0), (0, 1)]\n        \n        for dx, dy in moves:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < m and 0 <= ny < n:\n                new_cost = dp[x][y] + grid[nx][ny]\n                if new_cost < dp[nx][ny]:\n                    dp[nx][ny] = new_cost\n                    queue.append((nx, ny))\n    \n    return dp[m-1][n-1]\n\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    \nassert f(g()) == 7\n",
        "idx_generation": 130,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if a given grid is a valid Sudoku solution.\n    Return True if it is valid, and False otherwise.\"\"\"\n    \n    def is_valid_row(grid: List[List[int]], row: int) -> bool:\n        \"\"\"Check if a row in the grid is valid.\"\"\"\n        seen = set()\n        for num in grid[row]:\n            if num != 0 and num in seen:\n                return False\n            seen.add(num)\n        return True\n    \n    def is_valid_col(grid: List[List[int]], col: int) -> bool:\n        \"\"\"Check if a column in the grid is valid.\"\"\"\n        seen = set()\n        for row in grid:\n            num = row[col]\n            if num != 0 and num in seen:\n                return False\n            seen.add(num)\n        return True\n    \n    def is_valid_box(grid: List[List[int]], start_row: int, start_col: int) -> bool:\n        \"\"\"Check if a 3x3 box in the grid is valid.\"\"\"\n        seen = set()\n        for i in range(3):\n            for j in range(3):\n                num = grid[start_row + i][start_col + j]\n                if num != 0 and num in seen:\n                    return False\n                seen.add(num)\n        return True\n    \n    for i in range(9):\n        if not is_valid_row(grid, i) or not is_valid_col(grid, i):\n            return False\n    \n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            if not is_valid_box(grid, i, j):\n                return False\n    \n    return True\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a random valid Sudoku solution.\"\"\"\n    sudoku = [[5, 3, 0, 0, 7, 0, 0, 0, 0],\n              [6, 0, 0, 1, 9, 5, 0, 0, 0],\n              [0, 9, 8, 0, 0, 0, 0, 6, 0],\n              [8, 0, 0, 0, 6, 0, 0, 0, 3],\n              [4, 0, 0, 8, 0, 3, 0, 0, 1],\n              [7, 0, 0, 0, 2, 0, 0, 0, 6],\n              [0, 6, 0, 0, 0, 0, 2, 8, 0],\n              [0, 0, 0, 4, 1, 9, 0, 0, 5],\n              [0, 0, 0, 0, 8, 0, 0, 7, 9]]\n    return sudoku\n\nassert f(g())\n",
        "idx_generation": 144,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"Given a grid with 'S' representing the starting point, 'E' representing the end point, 'X' representing obstacles, and '.' representing empty cells, determine the minimum number of steps required to reach the end point from the starting point, considering only vertical and horizontal movements.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    queue = [(0, 0, 0)]\n    visited = set([(0, 0)])\n    \n    while queue:\n        x, y, steps = queue.pop(0)\n        \n        if grid[x][y] == 'E':\n            return steps\n        \n        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            nx = x + dx\n            ny = y + dy\n            \n            if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] != 'X' and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, steps + 1))\n    \n    return -1\n\ndef g():\n    grid = [\n        ['S', '.', '.', '.', 'X'],\n        ['.', 'X', '.', 'X', '.'],\n        ['.', '.', '.', '.', '.'],\n        ['.', 'X', 'X', '.', 'E']\n    ]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 263,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Given a matrix of 0s and 1s, find the largest square containing only 1s and return its area.\"\"\"\n    if not matrix:\n        return 0\n\n    rows, cols = len(matrix), len(matrix[0])\n    dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n    max_length = 0\n\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            if matrix[i-1][j-1] == 1:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n                max_length = max(max_length, dp[i][j])\n\n    return max_length * max_length\n\ndef g():\n    return [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n\nassert f(g()) == 4\n",
        "idx_generation": 181,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of 0s and 1s, determine if it is possible to reach the bottom-right corner from the top-left corner, only moving right, down, or diagonally down-right. The path must go through the 1s and avoid the 0s.\"\"\"\n    m, n = len(grid), len(grid[0])\n    stack = [(0, 0)]\n    visited = set()\n    while stack:\n        i, j = stack.pop()\n        if (i, j) == (m-1, n-1):\n            return True\n        visited.add((i, j))\n        if i+1 < m and grid[i+1][j] == 1 and (i+1, j) not in visited:\n            stack.append((i+1, j))\n        if j+1 < n and grid[i][j+1] == 1 and (i, j+1) not in visited:\n            stack.append((i, j+1))\n        if i+1 < m and j+1 < n and grid[i+1][j+1] == 1 and (i+1, j+1) not in visited:\n            stack.append((i+1, j+1))\n    return False\n\ndef g():\n    grid = [\n        [1, 1, 1, 0, 0],\n        [0, 1, 1, 1, 0],\n        [1, 0, 0, 1, 1],\n        [1, 1, 1, 1, 1]\n    ]\n    return grid\n\nassert f(g())\n\n",
        "idx_generation": 366,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\nfrom typing import List\n\ndef f(expression: str) -> bool:\n    \"\"\"\n    Given a string representing a mathematical expression containing only the characters '+', '-', '*', and '/'.\n    Determine if the expression is valid by checking if there are an equal number of opening and closing parentheses.\n    Return True if the expression is valid, False otherwise.\n    \"\"\"\n    stack = []\n    \n    for char in expression:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    \n    return len(stack) == 0\n\ndef g():\n    \"\"\"\n    Generate a string representing a mathematical expression.\n    \"\"\"\n    expression = \"(2 + 3) * (4 - 1) / (5 + 1)\"\n    \n    return expression\n\nassert f(g()) == True\n",
        "idx_generation": 461,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of set bits in the binary representation of a number\"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g(n=23):\n    return n\n\nassert f(g()) == 4\n\n",
        "idx_generation": 31,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Find if it is possible to select a subarray from arr such that the bitwise OR of all elements is equal to the target value.\n    \"\"\"\n    def solve(arr: List[int], target: int, idx: int, curr_value: int) -> bool:\n        if curr_value == target:\n            return True\n        if idx == len(arr):\n            return False\n        return solve(arr, target, idx + 1, curr_value | arr[idx]) or solve(arr, target, idx + 1, curr_value)\n    \n    return solve(arr, target, 0, 0)\n\ndef g(arr: List[int], target: int):\n    \"\"\"\n    Select a subarray from arr such that the bitwise OR of all elements is equal to the target value.\n    \"\"\"\n    n = len(arr)\n    subarray = []\n    for i in range(n):\n        if arr[i] == target:\n            return [arr[i]]\n        subarray.append(arr[i])\n        if arr[i] | arr[i+1] == target:\n            subarray.append(arr[i+1])\n            return subarray\n    return None\n\nassert f(g([1, 2, 3, 4, 5], 7), 7)\n",
        "idx_generation": 430,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, return a new list where each element is the count of the number of bits set to 1 in the corresponding element of the input list.\"\"\"\n    return [bin(num).count('1') for num in nums]\n\ndef g():\n    return [2, 5, 8, 10, 12]\n\nassert f(g()) == [1, 2, 1, 2, 2]\n",
        "idx_generation": 349,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, return the maximum sum of a path from the top-left cell to the bottom-right cell. You can only move down or right.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\n\ndef g(grid: List[List[int]] = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(g()) == 12\n",
        "idx_generation": 433,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Given two strings s1 and s2, check if s2 is a rotation of s1.\n    A rotation of string s1 is obtained by rotating the string by k positions,\n    where k is a non-negative integer. For example, \"hello\" can be rotated to\n    form \"lohel\" by rotating it twice.\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n    s1 += s1\n    return s2 in s1\n\ndef g():\n    s1 = \"python\"\n    s2 = \"thonpy\"\n    return s1, s2\n\nassert f(*g())\n",
        "idx_generation": 28,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine if a given number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    while n > 1:\n        if n % 2 != 0:\n            return False\n        n //= 2\n    return True\n\ndef g():\n    return 64\n\nassert f(g()) == True\n",
        "idx_generation": 478,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Determine if there is a path from the start node to the end node in the given directed graph.\"\"\"\n    visited = [False] * len(graph)\n    return dfs(graph, start, end, visited)\n\ndef dfs(graph: List[List[int]], current: int, end: int, visited: List[bool]) -> bool:\n    if current == end:\n        return True\n    visited[current] = True\n    for neighbor in graph[current]:\n        if not visited[neighbor]:\n            if dfs(graph, neighbor, end, visited):\n                return True\n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a directed graph.\"\"\"\n    return [[1, 2], [3], [3, 4], [], []]\n\nassert f(g(), 0, 4) == True\n",
        "idx_generation": 151,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency matrix, determine if there is a path from the start node to the end node.\n    Return True if a path exists, and False otherwise.\"\"\"\n    visited = [False] * len(graph)\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        visited[node] = True\n        neighbors = graph[node]\n        for neighbor, edge in enumerate(neighbors):\n            if edge == 1 and not visited[neighbor]:\n                stack.append(neighbor)\n    return False\n\ndef g(graph: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"Find the start and end nodes for the given graph.\"\"\"\n    start = 0\n    end = len(graph) - 1\n    return start, end\n\nassert f(graph=[[0, 1, 0, 0, 0],\n                [0, 0, 1, 0, 0],\n                [0, 0, 0, 1, 0],\n                [0, 0, 0, 0, 1],\n                [0, 0, 0, 0, 0]], start=g(graph=[[0, 1, 0, 0, 0],\n                                                [0, 0, 1, 0, 0],\n                                                [0, 0, 0, 1, 0],\n                                                [0, 0, 0, 0, 1],\n                                                [0, 0, 0, 0, 0]]), end=g(graph=[[0, 1, 0, 0, 0],\n                                                                                    [0, 0, 1, 0, 0],\n                                                                                    [0, 0, 0, 1, 0],\n                                                                                    [0, 0, 0, 0, 1],\n                                                                                    [0, 0, 0, 0, 0]]))\n",
        "idx_generation": 46,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"Given a directed graph represented by its edges, determine if it contains a cycle.\"\"\"\n    \n    graph = [[] for _ in range(n)]\n    \n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n    \n    def dfs(node, visited):\n        if visited[node] == 1:\n            return True\n        \n        if visited[node] == -1:\n            return False\n        \n        visited[node] = 1\n        \n        for neighbor in graph[node]:\n            if dfs(neighbor, visited):\n                return True\n        \n        visited[node] = -1\n        \n        return False\n    \n    visited = [0] * n\n    \n    for i in range(n):\n        if dfs(i, visited):\n            return True\n    \n    return False\n\ndef g():\n    n = 5\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4], [4, 1]]\n    return n, edges\n\nassert f(*g())\n",
        "idx_generation": 35,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of 0s and 1s, determine if it is possible to reach the bottom-right cell starting from the top-left\ncell, by traversing only through the cells containing 1s. You can only move down or right.\"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    \n    def dfs(i, j):\n        if i == n-1 and j == m-1:\n            return True\n        if i >= n or j >= m or grid[i][j] != 1:\n            return False\n        return dfs(i+1, j) or dfs(i, j+1)\n    \n    return dfs(0, 0)\n\ndef g():\n    return [[1, 0, 0, 0],\n            [1, 1, 0, 1],\n            [0, 1, 1, 0],\n            [1, 0, 1, 1]]\n\nassert f(g())\n",
        "idx_generation": 12,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a 2D grid of 0s and 1s, find the number of distinct islands.\n    An island is considered to be the same if they have the same shape and same arrangement of 1s.\"\"\"\n    m, n = len(grid), len(grid[0])\n    shapes = set()\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                shape = []\n                dfs(i, j, i, j, grid, shape)\n                shapes.add(tuple(shape))\n    return len(shapes)\n\ndef dfs(i, j, x, y, grid, shape):\n    m, n = len(grid), len(grid[0])\n    if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] != 1:\n        return\n    grid[x][y] = -1\n    shape.append((x-i, y-j))\n    dfs(i, j, x+1, y, grid, shape)\n    dfs(i, j, x-1, y, grid, shape)\n    dfs(i, j, x, y+1, grid, shape)\n    dfs(i, j, x, y-1, grid, shape)\n\ndef g():\n    return [[1,1,0,0,0],[1,1,0,0,0],[0,0,0,1,1],[0,0,0,1,1]]\n\nassert f(g()) == 1\n",
        "idx_generation": 236,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k=2) -> bool:\n    \"\"\"Determine if there exists a combination of n numbers from the set {1, 2, ..., k} that multiply to n\"\"\"\n    def helper(n, k, curr_prod):\n        if curr_prod == n:\n            return True\n        if curr_prod > n or k == 0:\n            return False\n        return helper(n, k-1, curr_prod) or helper(n, k-1, curr_prod*k)\n    return helper(n, k, 1)\ndef g(k=2):\n    return k\nassert f(g())\n",
        "idx_generation": 5,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome after removing at most one character\"\"\"\n    left, right = 0, len(s) - 1\n    while left < right:\n        if s[left] != s[right]:\n            return s[left:right] == s[left:right][::-1] or s[left+1:right+1] == s[left+1:right+1][::-1]\n        left += 1\n        right -= 1\n    return True\n\ndef g(s=\"racecar\"):\n    return s\n\nassert f(g())\n",
        "idx_generation": 466,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(n: int, k: int) -> bool:\n    \"\"\"Given two integers n and k, determine if there exists a combination of k elements from the set {1, 2, ..., n} such that the sum of the elements is divisible by k.\n    Return True if such a combination exists, False otherwise.\"\"\"\n    # Check if n is less than k\n    if n < k:\n        return False\n    \n    # Check if k is equal to 1\n    if k == 1:\n        return True\n    \n    # Check if k is equal to 2\n    if k == 2:\n        return n % 2 == 0\n    \n    # Check if k is divisible by 2\n    if k % 2 == 0:\n        return n % k == 0\n    \n    # Check if n is divisible by k\n    if n % k == 0:\n        return True\n    \n    # Check if the sum of the first k - 1 elements is divisible by k\n    if sum(range(1, k)) % k == 0:\n        return True\n    \n    # Check if the sum of the first k - 1 elements plus n is divisible by k\n    if (sum(range(1, k)) + n) % k == 0:\n        return True\n    \n    # Check if the sum of the first k - 1 elements plus n - 1 is divisible by k\n    if (sum(range(1, k)) + n - 1) % k == 0:\n        return True\n    \n    return False\n\ndef g(n=10, k=3) -> Tuple[int, int]:\n    \"\"\"Generate two integers n and k.\"\"\"\n    return n, k\n\nassert f(*g())\n",
        "idx_generation": 202,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum product of any three numbers in the list.\n    Return the maximum product.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n - 1], nums[n - 3] * nums[n - 2] * nums[n - 1])\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 60\n",
        "idx_generation": 414,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums', sort the list in ascending order using the bubble sort algorithm.\n    Return the sorted list.\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    return nums\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [5, 3, 9, 1, 7]\n    \n    return nums\n\nassert f(g()) == [1, 3, 5, 7, 9]\n",
        "idx_generation": 158,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(numbers: List[int], target=10) -> bool:\n    \"\"\"Given a list of numbers, find if it's possible to find a subset whose sum is equal to the target value. The length of the subset should be at least 2.\"\"\"\n    n = len(numbers)\n    \n    dp = [[False] * (target+1) for _ in range(n+1)]\n    \n    for i in range(n+1):\n        dp[i][0] = True\n    \n    for i in range(1, n+1):\n        for j in range(1, target+1):\n            if numbers[i-1] <= j:\n                dp[i][j] = dp[i-1][j] or dp[i-1][j-numbers[i-1]]\n            else:\n                dp[i][j] = dp[i-1][j]\n    \n    return dp[n][target]\n\ndef g(target=10):\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g())\n",
        "idx_generation": 7,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int, k: int) -> bool:\n    \"\"\"Given a list of integers 'nums', a target value 'target', and an integer 'k', determine whether there are 'k'\n    elements in 'nums' that add up to 'target'. Return True if such 'k' elements exist, False otherwise.\"\"\"\n    def backtrack(nums, target, k, start, curr_sum):\n        if k == 0 and curr_sum == target:\n            return True\n        if k == 0 or curr_sum > target:\n            return False\n        for i in range(start, len(nums)):\n            if backtrack(nums, target, k-1, i+1, curr_sum + nums[i]):\n                return True\n        return False\n    \n    nums.sort()\n    return backtrack(nums, target, k, 0, 0)\n\ndef g(nums=[1, 4, 3, 2, 5, 6, 9, 8, 7], target=15, k=3):\n    return nums\n\nassert f(g(), target=15, k=3)\n",
        "idx_generation": 338,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Find if there exists a pair of integers in the list whose XOR is equal to the target value.\"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while left < right:\n        xor = nums[left] ^ nums[right]\n        if xor == target:\n            return True\n        elif xor < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8], 10\n\nassert f(*g()) == True\n",
        "idx_generation": 263,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> List[int]:\n    \"\"\"Find the first k prime numbers greater than n.\"\"\"\n    primes = []\n    current_number = n + 1\n    \n    while len(primes) < k:\n        is_prime = True\n        \n        for i in range(2, int(current_number/2) + 1):\n            if current_number % i == 0:\n                is_prime = False\n                break\n                \n        if is_prime:\n            primes.append(current_number)\n        \n        current_number += 1\n        \n    return primes\n\ndef g():\n    return (10, 5)\n\nassert f(*g()) == [11, 13, 17, 19, 23]\n",
        "idx_generation": 132,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of positive integers nums and a target integer, find a contiguous subarray within the list that has the largest sum and return the subarray.\n    \"\"\"\n    max_sum = float('-inf')\n    max_start = 0\n    max_end = 0\n    current_sum = 0\n    current_start = 0\n    for i in range(len(nums)):\n        current_sum += nums[i]\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start = current_start\n            max_end = i\n        if current_sum < 0:\n            current_sum = 0\n            current_start = i + 1\n    return nums[max_start:max_end+1]\n\ndef g():\n    return ([1, -2, 3, 4, -1, 2, 1, -5, 4], 9)\n\nassert f(*g()) == [3, 4, -1, 2, 1]\n",
        "idx_generation": 299,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given a graph represented as an adjacency matrix, find the shortest path between two nodes.\n    Return the length of the shortest path.\n    \"\"\"\n    n = len(graph)\n    INF = float('inf')\n\n    # Initialize the distance matrix with the adjacency matrix\n    distance = [[graph[i][j] if graph[i][j] != 0 else INF for j in range(n)] for i in range(n)]\n\n    # Floyd-Warshall algorithm\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])\n\n    return distance[0][n-1]\n\ndef g(graph: List[List[int]] = [[0, 1, 0, 0, 0],\n                                [1, 0, 1, 1, 0],\n                                [0, 1, 0, 0, 1],\n                                [0, 1, 0, 0, 1],\n                                [0, 0, 1, 1, 0]]):\n    return graph\n\nassert f(g()) == 3\n",
        "idx_generation": 196,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of non-negative integers, find the maximum sum path from the top-left corner to the bottom-right corner.\n    The player can only move down or right at each step.\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n        \n    return dp[m-1][n-1]\n\ndef g(grid: List[List[int]]) -> int:\n    return f(grid)\n\ngrid = [[1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]]\n\nassert f(grid) == g(grid)\n\n",
        "idx_generation": 325,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"Given a matrix of integers, return the values of the matrix in a spiral order.\"\"\"\n    if not matrix:\n        return []\n    \n    rows, cols = len(matrix), len(matrix[0])\n    top, bottom, left, right = 0, rows - 1, 0, cols - 1\n    direction = 0\n    result = []\n    \n    while top <= bottom and left <= right:\n        if direction == 0:\n            for col in range(left, right + 1):\n                result.append(matrix[top][col])\n            top += 1\n        elif direction == 1:\n            for row in range(top, bottom + 1):\n                result.append(matrix[row][right])\n            right -= 1\n        elif direction == 2:\n            for col in range(right, left - 1, -1):\n                result.append(matrix[bottom][col])\n            bottom -= 1\n        elif direction == 3:\n            for row in range(bottom, top - 1, -1):\n                result.append(matrix[row][left])\n            left += 1\n        \n        direction = (direction + 1) % 4\n    \n    return result\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a matrix of integers.\"\"\"\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 262,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport heapq\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"Find the k smallest elements in the given list and return them in ascending order.\"\"\"\n    return sorted(heapq.nsmallest(k, nums))\n\ndef g(nums=[9, 2, 4, 7, 1, 5, 3], k=3):\n    return nums\n\nassert f(g(), 3) == [1, 2, 3]\n",
        "idx_generation": 51,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, factors: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a subset of factors that can multiply up to the target number\"\"\"\n    def helper(i, prod):\n        if prod == target:\n            return True\n        if i == len(factors):\n            return False\n        return helper(i+1, prod*factors[i]) or helper(i+1, prod)\n    \n    return helper(0, 1)\ndef g(n=5, factors=[2, 3, 4, 5, 6], target=60):\n    return n, factors, target\nassert f(*g())\n",
        "idx_generation": 4,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> Tuple[int, int]:\n    \"\"\"Find two numbers in the given list that add up to the target number.\n    Return the indices of the two numbers.\n    If there are multiple solutions, return any one of them.\n    Sample Input:\n    nums = [2, 7, 11, 15]\n    target = 9\n    Sample Output:\n    (0, 1)\"\"\"\n    complement_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complement_map:\n            return (complement_map[complement], i)\n        complement_map[num] = i\n    return (-1, -1)\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    \"\"\"Return the given list and target\"\"\"\n    return nums, target\n\nassert f(*g()) == (0, 1)\n",
        "idx_generation": 59,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(x: int, a=10, b=100) -> bool:\n    \"\"\"Check if x is a prime number between a and b (inclusive).\"\"\"\n    return a <= x <= b and all(x % i != 0 for i in range(2, int(x ** 0.5) + 1))\ndef g(a=10, b=100):\n    for x in range(a, b+1):\n        if all(x % i != 0 for i in range(2, int(x ** 0.5) + 1)):\n            return x\nassert f(g())\n",
        "idx_generation": 58,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers nums, find the maximum sum of any contiguous subarray in nums.\n    - nums is a list of integers\n    - return the maximum sum of any contiguous subarray\"\"\"\n    \n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for num in nums:\n        curr_sum += num\n        if curr_sum > max_sum:\n            max_sum = curr_sum\n        if curr_sum < 0:\n            curr_sum = 0\n    \n    return max_sum\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 112,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any contiguous subarray.\n    A subarray is defined as a contiguous portion of the original array.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef g(nums: List[int]) -> int:\n    \"\"\"\n    Find the maximum sum of any contiguous subarray in the given list of integers.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\nassert f([1, -2, 3, -4, 5, -6, 7]) == g([1, -2, 3, -4, 5, -6, 7])\n",
        "idx_generation": 426,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, check if there exists a subarray in the list whose sum is equal to the target number.\n    Sample input:\n    [1, 2, 3, 4, 5], 9\n    Sample output:\n    True\"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum == target or prefix_sum - target in prefix_sums:\n            return True\n        prefix_sums.add(prefix_sum)\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5], 9\n\nassert f(*g())\n",
        "idx_generation": 237,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list that sum up to the target\"\"\"\n    seen = set()\n    for num in nums:\n        complement = target - num\n        if complement in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g():\n    return ([1, 2, 3, 4, 5], 8)  # Return a list of numbers and a target sum\n\nassert f(*g()) == True\n",
        "idx_generation": 76,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Stack:\n    def __init__(self):\n        self.stack = []\n\n    def push(self, value):\n        self.stack.append(value)\n\n    def pop(self):\n        if not self.is_empty():\n            return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, reverse the order of the elements using a stack and return the reversed list.\"\"\"\n    stack = Stack()\n    for num in arr:\n        stack.push(num)\n    reversed_arr = []\n    while not stack.is_empty():\n        reversed_arr.append(stack.pop())\n    return reversed_arr\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    return arr\n\nassert f(g()) == [5, 4, 3, 2, 1]\n",
        "idx_generation": 128,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the number of ways to climb n stairs\"\"\"\n    if n <= 1:\n        return 1\n    elif n == 2:\n        return 2\n    else:\n        return f(n-1) + f(n-2)\n\ndef g(n: int):\n    return n\n\nassert f(g(5)) == 8\n",
        "idx_generation": 10,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the number of distinct ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\"\"\"\n    if n <= 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\ndef g(n=5):\n    \"\"\"Generate the number of steps in a staircase.\"\"\"\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 200,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, find the sum of all numbers in the grid.\n    The grid is represented as a list of lists, where each inner list represents a row in the grid.\"\"\"\n    total_sum = 0\n\n    for row in grid:\n        total_sum += sum(row)\n\n    return total_sum\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a grid of integers.\"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 45\n",
        "idx_generation": 232,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of 0s and 1s, determine if it is possible to reach the bottom-right corner starting from the top-left corner. You can only move down, right, or diagonally down-right. Additionally, you can only move through the cells with a value of 0.\"\"\"\n    m, n = len(grid), len(grid[0])\n    queue = [(0, 0)]\n    visited = set()\n\n    while queue:\n        i, j = queue.pop(0)\n        if i == m - 1 and j == n - 1:\n            return True\n        visited.add((i, j))\n\n        neighbors = [(i + 1, j), (i, j + 1), (i + 1, j + 1)]\n        for x, y in neighbors:\n            if 0 <= x < m and 0 <= y < n and (x, y) not in visited and grid[x][y] == 0:\n                queue.append((x, y))\n\n    return False\n\ndef g():\n    return [[0, 1, 0, 0],\n            [0, 0, 0, 1],\n            [1, 1, 0, 0],\n            [0, 0, 0, 0]]\n\nassert f(g())\n",
        "idx_generation": 275,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n    Return the maximum sum.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g():\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 12\n\n",
        "idx_generation": 200,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the length of the shortest path from the top-left corner to the bottom-right corner in a grid.\n    Return the length of the shortest path.\"\"\"\n    \n    m = len(grid)\n    n = len(grid[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    \n    queue = [(0, 0, 0)]\n    visited = set()\n    \n    while queue:\n        row, col, dist = queue.pop(0)\n        \n        if row == m - 1 and col == n - 1:\n            return dist\n        \n        if (row, col) in visited:\n            continue\n        \n        visited.add((row, col))\n        \n        for dx, dy in directions:\n            new_row = row + dx\n            new_col = col + dy\n            \n            if 0 <= new_row < m and 0 <= new_col < n and grid[new_row][new_col] == 0:\n                queue.append((new_row, new_col, dist + 1))\n    \n    return -1\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a grid with obstacles represented by 1s and open cells represented by 0s.\"\"\"\n    grid = [[0, 1, 0, 0, 0], [0, 0, 0, 1, 0], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0], [0, 1, 0, 0, 0]]\n    return grid\n\nassert f(g()) == 8\n",
        "idx_generation": 452,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string is a valid palindrome after removing at most one character.\"\"\"\n    left = 0\n    right = len(s) - 1\n    \n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s[left:right]) or is_palindrome(s[left+1:right+1])\n        left += 1\n        right -= 1\n    \n    return True\n\ndef g(s: str):\n    return s\n\ndef is_palindrome(s: str) -> bool:\n    return s == s[::-1]\n\nassert f(g(\"raceecar\"))\n",
        "idx_generation": 5,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"Count the number of bits set to 1 in the binary representation of a given integer.\"\"\"\n    count = 0\n    while num:\n        count += num & 1\n        num >>= 1\n    return count\n\ndef g(num: int) -> int:\n    \"\"\"Calculate the number of bits set to 1 in the binary representation of a given integer.\"\"\"\n    if num == 0:\n        return 0\n    return num % 2 + g(num // 2)\n\nassert f(num=10) == g(num=10)\n",
        "idx_generation": 39,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of non-negative integers nums and a target integer, determine if there exists a subset of nums\n    such that the bitwise XOR of all elements in the subset is equal to the target.\n    \"\"\"\n    def subset_xor(nums: List[int], target: int, index: int, curr_xor: int) -> bool:\n        if curr_xor == target:\n            return True\n        if index == len(nums):\n            return False\n        return subset_xor(nums, target, index + 1, curr_xor ^ nums[index]) or subset_xor(nums, target, index + 1, curr_xor)\n\n    return subset_xor(nums, target, 0, 0)\n\ndef g():\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g(), 7)\n",
        "idx_generation": 441,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"Check if a given string contains a number that is a power of 2 and divisible by n.\"\"\"\n    numbers = s.split()\n    for num in numbers:\n        if is_power_of_two(int(num)) and int(num) % n == 0:\n            return True\n    return False\n\ndef is_power_of_two(num):\n    return num != 0 and (num & (num - 1)) == 0\n\ndef g():\n    return \"2 4 8 16 32 64\", 8\n\nassert f(*g())\n",
        "idx_generation": 360,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of 0s and 1s, find the number of unique paths from the top-left cell to the bottom-right cell,\n    moving only down or to the right. Additionally, the sum of all numbers encountered along the path must be divisible by 3.\"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    return dfs(grid, 0, 0, 0)\n\ndef dfs(grid, i, j, total):\n    n = len(grid)\n    m = len(grid[0])\n    if i == n - 1 and j == m - 1:\n        return total % 3 == 0\n    if i < 0 or i >= n or j < 0 or j >= m:\n        return False\n    total += grid[i][j]\n    return dfs(grid, i + 1, j, total) or dfs(grid, i, j + 1, total)\n\ndef g():\n    grid = [\n        [3, 1, 1],\n        [1, 2, 1],\n        [1, 1, 3]\n    ]\n    return grid\n\nassert f(g())\n",
        "idx_generation": 439,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"Check if the given string is a palindrome and if the given number is a perfect square.\"\"\"\n    return s == s[::-1] and int(n ** 0.5) ** 2 == n\n\ndef g():\n    s = 'madam'\n    n = 16\n    return s, n\n\nassert f(*g())\n\n",
        "idx_generation": 60,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"Given a graph represented as a list of edges, determine if there exists a cycle in the graph.\n    \n    Sample input:\n    n = 4, edges = [[0, 1], [1, 2], [2, 0], [2, 3]]\n    \n    Sample output:\n    True\n    \n    Explanation:\n    The graph has a cycle 0 -> 1 -> 2 -> 0.\n    \"\"\"\n    def dfs(v, visited, parent):\n        visited[v] = True\n        \n        for neighbor in graph[v]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, v):\n                    return True\n            elif parent != neighbor:\n                return True\n        \n        return False\n    \n    graph = [[] for _ in range(n)]\n    \n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    visited = [False] * n\n    \n    for v in range(n):\n        if not visited[v]:\n            if dfs(v, visited, -1):\n                return True\n    \n    return False\n\ndef g(n=4, edges=[[0, 1], [1, 2], [2, 0], [2, 3]]):\n    \"\"\"Generate an integer n and a list of edges.\"\"\"\n    return n, edges\n\nassert f(*g())\n",
        "idx_generation": 186,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool:\n    \"\"\"Given a grid, determine if there is a path from the start point to the end point.\n    Return True if a path exists, and False otherwise.\"\"\"\n    m, n = len(grid), len(grid[0])\n    visited = [[False] * n for _ in range(m)]\n    stack = [start]\n    while stack:\n        x, y = stack.pop()\n        if (x, y) == end:\n            return True\n        visited[x][y] = True\n        neighbors = [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]\n        for nx, ny in neighbors:\n            if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0:\n                stack.append((nx, ny))\n    return False\n\ndef g(grid: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n    \"\"\"Find the start and end points in the grid.\"\"\"\n    m, n = len(grid), len(grid[0])\n    start = (0, 0)\n    end = (m-1, n-1)\n    return start, end\n\nassert f(grid=[[0, 1, 0, 0, 0],\n                [0, 0, 1, 1, 0],\n                [0, 0, 0, 1, 0],\n                [0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0]], start=g(grid=[[0, 1, 0, 0, 0],\n                                                [0, 0, 1, 1, 0],\n                                                [0, 0, 0, 1, 0],\n                                                [0, 0, 0, 0, 0],\n                                                [0, 0, 0, 0, 0]]), end=g(grid=[[0, 1, 0, 0, 0],\n                                                                                    [0, 0, 1, 1, 0],\n                                                                                    [0, 0, 0, 1, 0],\n                                                                                    [0, 0, 0, 0, 0],\n                                                                                    [0, 0, 0, 0, 0]]))\n",
        "idx_generation": 46,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start_node: str, end_node: str) -> bool:\n    \"\"\"Determine if there exists a path from start_node to end_node in the given graph.\"\"\"\n    def dfs(node, visited):\n        visited.add(node)\n        if node == end_node:\n            return True\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited):\n                    return True\n        return False\n    return dfs(start_node, set())\ndef g():\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['D'],\n        'C': ['E'],\n        'D': [],\n        'E': ['F'],\n        'F': []\n    }\n    start_node = 'A'\n    end_node = 'F'\n    return graph, start_node, end_node\nassert f(*g())\n",
        "idx_generation": 36,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"Given an adjacency matrix graph representing a directed graph, determine if there is a cycle in the graph.\n    Return True if there is a cycle, False otherwise.\n    Example:\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 0, 0, 0]\n    ]\n    There is a cycle in the graph: 0 -> 1 -> 2 -> 3 -> 0\n    Therefore, the answer is True.\n    \"\"\"\n    visited = [False] * len(graph)\n    stack = [False] * len(graph)\n    for node in range(len(graph)):\n        if not visited[node] and f_util(graph, node, visited, stack):\n            return True\n    return False\n\ndef f_util(graph, node, visited, stack):\n    visited[node] = True\n    stack[node] = True\n    for neighbor in range(len(graph)):\n        if graph[node][neighbor]:\n            if not visited[neighbor]:\n                if f_util(graph, neighbor, visited, stack):\n                    return True\n            elif stack[neighbor]:\n                return True\n    stack[node] = False\n    return False\n\ndef g():\n    return [[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [1, 0, 0, 0]]\nassert f(g())\n",
        "idx_generation": 24,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid filled with 0s and 1s, find the number of islands. An island is defined as a group of connected 1s in the grid.\n    Two cells are considered connected if they are adjacent horizontally or vertically.\"\"\"\n    def dfs(row, col):\n        if row < 0 or col < 0 or row >= len(grid) or col >= len(grid[0]) or grid[row][col] != 1:\n            return\n        grid[row][col] = -1\n        dfs(row - 1, col)\n        dfs(row + 1, col)\n        dfs(row, col - 1)\n        dfs(row, col + 1)\n    \n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                count += 1\n                dfs(i, j)\n    \n    return count\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"Return the grid after counting the islands\"\"\"\n    return grid\n\nassert f(g(grid=[[1, 1, 0], [0, 1, 1], [1, 0, 0]])) == 2\n",
        "idx_generation": 303,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k=3) -> bool:\n    \"\"\"Determine if there exists a combination of n numbers from the set {1, 2, ..., k} that satisfy a particular condition\"\"\"\n    def helper(n, k, curr_comb):\n        if len(curr_comb) == n:\n            # Check if the combination satisfies the condition\n            if condition(curr_comb):\n                return True\n            return False\n        for i in range(1, k+1):\n            if helper(n, k, curr_comb + [i]):\n                return True\n        return False\n    \n    def condition(comb):\n        # The condition can be any specific condition that needs to be satisfied by the combination\n        # For example, checking if the sum of the combination is divisible by 3\n        return sum(comb) % 3 == 0\n    \n    return helper(n, k, [])\ndef g(k=3):\n    return k\nassert f(g())\n",
        "idx_generation": 5,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers 'nums' and a target value 'target',\n    find all unique combinations in the list where the sum of the combination is equal to the target value.\n    Each number in the list can be used multiple times.\n    Return a list of all unique combinations as lists.\n    \n    Example:\n    nums = [2, 3, 5]\n    target = 8\n    \n    The unique combinations in the list that sum up to the target value 8 are:\n    [[2, 2, 2, 2], [2, 3, 3], [3, 5]]\n    Therefore, the output should be [[2, 2, 2, 2], [2, 3, 3], [3, 5]].\n    \"\"\"\n    def backtrack(curr_comb, curr_sum, start):\n        if curr_sum == target:\n            result.append(curr_comb[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            curr_comb.append(nums[i])\n            backtrack(curr_comb, curr_sum + nums[i], i)\n            curr_comb.pop()\n    \n    result = []\n    backtrack([], 0, 0)\n    return result\n\ndef g() -> List[int]:\n    return [2, 3, 5], 8\n\nassert f(*g()) == [[2, 2, 2, 2], [2, 3, 3], [3, 5]]\n",
        "idx_generation": 499,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\ndef f(n: int, m=4) -> bool:\n    \"\"\"Find the number of distinct combinations of m elements that can be selected from a set of n elements.\"\"\"\n    from math import comb\n    return comb(n, m)\ndef g(m=4):\n    return m\nassert f(g()) == 1\n",
        "idx_generation": 271,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers 'arr' and a target integer 'target', return True if 'target' exists in 'arr', False otherwise.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 5\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 444,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"Determine whether a given array can be sorted by performing at most one swap operation\"\"\"\n    n = len(arr)\n    swap_count = 0\n    for i in range(n-1):\n        if arr[i] > arr[i+1]:\n            if swap_count == 1:\n                return False\n            arr[i], arr[i+1] = arr[i+1], arr[i]\n            swap_count += 1\n    return True\n\ndef g(arr: List[int]):\n    \"\"\"Sort the given array using bubble sort algorithm\"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\n\nassert f(g([3, 2, 1, 5, 4]))\n",
        "idx_generation": 161,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, find if there exist two numbers in the list such that their sum is equal to the target.\n    Return True if such pair of numbers exist, otherwise return False.\n    Sample input:\n    [2, 4, 6, 8, 10], 12\n    Sample output:\n    True\"\"\"\n    low = 0\n    high = len(arr) - 1\n    while low < high:\n        curr_sum = arr[low] + arr[high]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            low += 1\n        else:\n            high -= 1\n    return False\n\ndef g():\n    return [2, 4, 6, 8, 10], 12\n\nassert f(*g()) == True\n",
        "idx_generation": 20,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Find the maximum subarray sum of nums.\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 387,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a pair of numbers whose XOR is equal to the maximum element in the list.\n    \n    Return True if such a pair exists, False otherwise.\n    \"\"\"\n    max_num = max(nums)\n    seen = set()\n    for num in nums:\n        target = max_num ^ num\n        if target in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g():\n    nums = [2, 3, 4, 5, 6]\n    return nums\n\nassert f(g())\n",
        "idx_generation": 274,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum product of any three numbers in the list.\"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3])\n\ndef g():\n    nums = [2, 6, 3, 1, 8, 4, 9, 5]\n    return nums\n\nassert f(g()) == 432\n",
        "idx_generation": 136,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integer values, find the maximum sum path from the top-left corner to the bottom-right corner.\n    Each step in the path can only move down or right.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Return the grid\n    \"\"\"\n    return grid\n\nassert f(g([[1, 3, 1], [1, 5, 1], [4, 2, 1]])) == 12\n",
        "idx_generation": 300,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"Find the longest increasing path in a matrix.\"\"\"\n    if not matrix:\n        return 0\n\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(i, j):\n        if dp[i][j]:\n            return dp[i][j]\n        dp[i][j] = 1\n        for dx, dy in directions:\n            x, y = i + dx, j + dy\n            if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                dp[i][j] = max(dp[i][j], dfs(x, y) + 1)\n        return dp[i][j]\n\n    max_length = 0\n    for i in range(m):\n        for j in range(n):\n            max_length = max(max_length, dfs(i, j))\n    return max_length\n\ndef g():\n    return [[9, 9, 4], [6, 6, 8], [2, 1, 1]]\n\nassert f(g()) == 4\n",
        "idx_generation": 243,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers 'nums', determine if there exists a subset of the numbers that adds up to a target value of 10.\"\"\"\n    n = len(nums)\n    target = 10\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j < nums[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n    return dp[n][target]\n\ndef g():\n    return [2, 4, 6, 8]\n\nassert f(g())\n",
        "idx_generation": 354,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, rotate the matrix 90 degrees clockwise.\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    The rotated matrix will be:\n    [[7, 4, 1],\n     [8, 5, 2],\n     [9, 6, 3]]\n    Return the rotated matrix.\n    \"\"\"\n    n = len(matrix)\n\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n\n    return matrix\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 300,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the smallest missing positive integer.\n    Example: \n    Input: [1, 2, 0]\n    Output: 3\n    Input: [3, 4, -1, 1]\n    Output: 2\"\"\"\n    nums = list(filter(lambda x: x > 0, nums))\n    nums.sort()\n    smallest_missing = 1\n    \n    for num in nums:\n        if num == smallest_missing:\n            smallest_missing += 1\n        elif num > smallest_missing:\n            return smallest_missing\n    \n    return smallest_missing\n\ndef g() -> List[int]:\n    \"\"\"Generate a list of integers with missing positive numbers.\"\"\"\n    return [3, 4, -1, 1, 0]\n\nassert f(g()) == 2\n",
        "idx_generation": 89,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(x: int, target: int, nums: List[int]) -> bool:\n    \"\"\"Given a list of integers nums and a target integer, check if there is a subset of nums that sums up to the target.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(target + 1):\n            if j < nums[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n\n    return dp[n][target]\n\ndef g(nums: List[int], target: int) -> int:\n    \"\"\"Find the minimum number of integers that need to be removed from nums to make the sum of the remaining integers equal to the target.\"\"\"\n    n = len(nums)\n    dp = [[float('inf')] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(target + 1):\n            if j < nums[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - nums[i - 1]] + 1)\n\n    return dp[n][target]\n\nassert f(g([1, 5, 3, 8, 2], 10), 10, [1, 5, 3, 8, 2])\n",
        "idx_generation": 6,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Check if there exists two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.\"\"\"\n    mapping = {}\n    for i, num in enumerate(nums):\n        if num in mapping and abs(i - mapping[num]) <= k:\n            return True\n        mapping[num] = i\n    return False\n\ndef g():\n    nums = [1, 2, 3, 1, 4, 5]\n    k = 3\n    return nums, k\n\nassert f(*g())\n",
        "idx_generation": 103,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import itertools\nfrom typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if a given matrix is a magic square.\n    A magic square is a square grid of numbers where the sums of the numbers in each row, each column, and both main diagonals are the same.\n    \"\"\"\n    n = len(matrix)\n    target_sum = n * (n**2 + 1) // 2\n    row_sums = [sum(row) for row in matrix]\n    col_sums = [sum(col) for col in zip(*matrix)]\n    diag_sum1 = sum(matrix[i][i] for i in range(n))\n    diag_sum2 = sum(matrix[i][n-i-1] for i in range(n))\n    return all(row_sum == target_sum for row_sum in row_sums) and \\\n           all(col_sum == target_sum for col_sum in col_sums) and \\\n           diag_sum1 == target_sum and diag_sum2 == target_sum\n\ndef g(n=3):\n    import itertools\n    num_set = set(range(1, n**2 + 1))\n    for permutation in itertools.permutations(num_set):\n        matrix = [list(permutation[i:i+n]) for i in range(0, n**2, n)]\n        if f(matrix):\n            return matrix\n    return None\n\nassert f(g())\n",
        "idx_generation": 67,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find the largest n-digit number where the sum of its digits is a perfect square and the number itself is a perfect square.\"\"\"\n    def is_perfect_square(num):\n        return int(num ** 0.5) ** 2 == num\n\n    def sum_of_digits(num):\n        return sum(map(int, str(num)))\n\n    for num in range(10 ** (n - 1), 10 ** n):\n        if is_perfect_square(sum_of_digits(num)) and is_perfect_square(num):\n            return True\n    return False\n\ndef g():\n    return 3\n\nassert f(g()) == True\n",
        "idx_generation": 114,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Find the maximum sum of a subarray within the given list.\"\"\"\n    max_so_far = arr[0]\n    max_ending_here = arr[0]\n    for i in range(1, len(arr)):\n        max_ending_here = max(arr[i], max_ending_here + arr[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far\n\ndef g(arr: List[int]):\n    return arr\n\n# Example usage:\narr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nassert f(g(arr)) == 6\n",
        "idx_generation": 470,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, remove all duplicate elements and return the list with only unique elements.\n    The order of the elements should be preserved.\n    \"\"\"\n    unique_nums = []\n    seen = set()\n    \n    for num in nums:\n        if num not in seen:\n            seen.add(num)\n            unique_nums.append(num)\n    \n    return unique_nums\n    \ndef g(nums=[1, 2, 3, 4, 2, 3, 5, 6]):\n    return nums\n\nassert f(g()) == [1, 2, 3, 4, 5, 6]\n",
        "idx_generation": 283,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a subarray with a sum equal to 0.\n    Return True if such subarray exists, False otherwise.\"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    \n    for num in nums:\n        prefix_sum += num\n        if prefix_sum in prefix_sums or prefix_sum == 0:\n            return True\n        prefix_sums.add(prefix_sum)\n    \n    return False\n\ndef g() -> List[int]:\n    \"\"\"Generate a list of integers.\"\"\"\n    return [4, -2, 1, -3, 2, -1, 3]\n\nassert f(g()) == True\n\n",
        "idx_generation": 80,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string of parentheses, determine if the parentheses are balanced.\n    Use stack data structure to solve the problem.\n    Sample input:\n    s = \"((()))\"\n    Sample output:\n    True\"\"\"\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n\n    return len(stack) == 0\n\n\ndef g():\n    return \"((()))\"\n\nassert f(g())\n",
        "idx_generation": 132,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"Count the number of ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n    \n    Sample input:\n    n = 3\n    \n    Sample output:\n    3\n    \"\"\"\n    if n <= 1:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    \n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    \n    return dp[n]\n\ndef g(n=3):\n    return n\n\nassert f(g()) == 3\n",
        "idx_generation": 17,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Find if there exists a subset of nums that adds up to the target\"\"\"\n    dp = [False] * (target + 1)\n    dp[0] = True\n    for num in nums:\n        for i in range(target, num - 1, -1):\n            dp[i] = dp[i] or dp[i - num]\n    return dp[target]\n\ndef g():\n    nums = [2, 4, 6, 8]\n    target = 10\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 204,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, rotate the matrix 90 degrees clockwise.\n    \"\"\"\n    n = len(matrix)\n    m = len(matrix[0])\n    rotated_matrix = [[0] * n for _ in range(m)]\n    for i in range(n):\n        for j in range(m):\n            rotated_matrix[j][n - i - 1] = matrix[i][j]\n    return rotated_matrix\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 250,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of 0s and 1s, determine if it is possible to reach the bottom-right corner starting from the top-left corner. You can only move down or right. Additionally, you can only move through the cells with a value of 1, and you need to avoid cells with a value of 0.\"\"\"\n    m, n = len(grid), len(grid[0])\n    stack = [(0, 0)]\n    visited = set()\n\n    while stack:\n        i, j = stack.pop()\n        if i == m - 1 and j == n - 1:\n            return True\n        visited.add((i, j))\n\n        neighbors = [(i + 1, j), (i, j + 1)]\n        for x, y in neighbors:\n            if 0 <= x < m and 0 <= y < n and (x, y) not in visited and grid[x][y] == 1:\n                stack.append((x, y))\n\n    return False\n\ndef g():\n    return [[1, 1, 1, 0],\n            [1, 0, 1, 1],\n            [1, 1, 0, 1],\n            [0, 1, 1, 1]]\n\nassert f(g())\n",
        "idx_generation": 326,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Find whether it is possible to reach the bottom right cell from the top left cell in the given grid, moving only down or right.\"\"\"\n    def dfs(row: int, col: int) -> bool:\n        if row == len(grid) - 1 and col == len(grid[0]) - 1:\n            return True\n        if row < len(grid) - 1 and dfs(row + 1, col):\n            return True\n        if col < len(grid[0]) - 1 and dfs(row, col + 1):\n            return True\n        return False\n    \n    return dfs(0, 0)\n\ndef g(grid: List[List[int]]):\n    \"\"\"Find the path from the top left cell to the bottom right cell in the given grid.\"\"\"\n    def dfs(row: int, col: int, path: List[str]) -> List[str]:\n        if row == len(grid) - 1 and col == len(grid[0]) - 1:\n            return path\n        if row < len(grid) - 1:\n            down_path = dfs(row + 1, col, path + ['D'])\n            if down_path:\n                return down_path\n        if col < len(grid[0]) - 1:\n            right_path = dfs(row, col + 1, path + ['R'])\n            if right_path:\n                return right_path\n        return []\n    \n    return dfs(0, 0, [])\n\nassert f(g([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n",
        "idx_generation": 220,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(words: List[str], target: str) -> bool:\n    \"\"\"Given a list of words and a target word, determine if it is possible to form the target word by concatenating the\nwords from the list in any order. Each word can be used only once.\"\"\"\n    def can_form_word(word, remaining_words):\n        if word == \"\":\n            return True\n        for i, w in enumerate(remaining_words):\n            if word.startswith(w) and can_form_word(word[len(w):], remaining_words[:i] + remaining_words[i+1:]):\n                return True\n        return False\n    \n    return can_form_word(target, words)\n\ndef g():\n    return ([\"apple\", \"pen\", \"pineapple\"], \"pineapplepenapple\")\n\nassert f(*g())\n",
        "idx_generation": 12,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Check if the kth bit of n is set (equals to 1)\"\"\"\n    return (n >> k) & 1 == 1\n\ndef g(k: int):\n    return 2 ** k\n\nassert f(g(k=3), k=3)\n",
        "idx_generation": 39,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if the binary representation of 'n' is a palindrome.\n    Return True if it is, False otherwise.\n    \"\"\"\n    binary = bin(n)[2:]\n    return binary == binary[::-1]\n\ndef g():\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    n = 9\n    \n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 454,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size m x n, where each cell contains a non-negative integer, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right at each step.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(g()) == 12\n",
        "idx_generation": 493,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(s: str, x=0) -> bool:\n    \"\"\"Check if the given string s is a palindrome and if x is a perfect square.\"\"\"\n    return s == s[::-1] and math.isqrt(x) ** 2 == x\n\ndef g(x=0):\n    return \"racecar\" if x == 0 else \"level\" if x == 1 else \"deified\"\n\nassert f(g())\n",
        "idx_generation": 83,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, determine if there is a path from the\n    start node to the end node.\n    \"\"\"\n    visited = [False] * len(graph)\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        visited[node] = True\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] and not visited[neighbor]:\n                stack.append(neighbor)\n\n    return False\n\ndef g(graph=[[0, 1, 1, 0], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 0]], start=0, end=3):\n    \"\"\"\n    Generate a directed graph represented as an adjacency matrix, and specify the start and end nodes.\n    \"\"\"\n    return graph, start, end\n\nassert f(*g())\n",
        "idx_generation": 228,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(maze: List[List[int]]) -> bool:\n    \"\"\"Given a maze represented as a 2D grid of 0s and 1s, determine if there is a path from the top-left corner to the bottom-right corner.\n    0 represents an empty cell and 1 represents an obstacle.\"\"\"\n    n = len(maze)\n    m = len(maze[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(0, 0)])\n    visited = set([(0, 0)])\n    while queue:\n        x, y = queue.popleft()\n        if x == n - 1 and y == m - 1:\n            return True\n        for dx, dy in directions:\n            new_x, new_y = x + dx, y + dy\n            if 0 <= new_x < n and 0 <= new_y < m and maze[new_x][new_y] == 0 and (new_x, new_y) not in visited:\n                queue.append((new_x, new_y))\n                visited.add((new_x, new_y))\n    return False\n\ndef g():\n    return [[0, 1, 0], [0, 0, 1], [1, 0, 0]]\n\nassert f(g()) == True\n",
        "idx_generation": 47,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid with 0s and 1s, determine if there is a path from the top-left corner to the bottom-right corner,\n    where 0s represent empty cells and 1s represent blocked cells. You can only move down or right.\"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    \n    def dfs(i, j):\n        if i == n-1 and j == m-1:\n            return True\n        if i >= n or j >= m or grid[i][j] == 1:\n            return False\n        return dfs(i+1, j) or dfs(i, j+1)\n    \n    return dfs(0, 0)\n\ndef g():\n    return [[0, 0, 1, 0],\n            [0, 1, 0, 1],\n            [0, 0, 0, 0],\n            [0, 0, 1, 0]]\n\nassert f(g())\n",
        "idx_generation": 56,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a 2D grid of integers, find the minimum distance to reach the bottom right cell from the top left cell.\n    You can only move down or right from each cell.\n    Return the minimum distance.\"\"\"\n    if not grid:\n        return 0\n    \n    m, n = len(grid), len(grid[0])\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a random 2D grid of integers.\"\"\"\n    grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 32,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: list) -> bool:\n    \"\"\"Check if a given grid of characters contains a valid word (i.e., a word that can be formed by connecting adjacent characters)\"\"\"\n\n    def dfs(i, j, word, visited):\n        if len(word) == 0:\n            return True\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != word[0] or visited[i][j]:\n            return False\n        visited[i][j] = True\n        res = dfs(i+1, j, word[1:], visited) or dfs(i-1, j, word[1:], visited) or dfs(i, j+1, word[1:], visited) or dfs(i, j-1, word[1:], visited)\n        visited[i][j] = False\n        return res\n\n    words = [\"cat\", \"dog\", \"bird\", \"rat\"]\n    visited = [[False]*len(grid[0]) for _ in range(len(grid))]\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if dfs(i, j, words[0], visited):\n                return True\n    return False\n\ndef g():\n    return [['c', 'a', 't'], ['o', 'd', 'g'], ['b', 'i', 'r'], ['r', 'd', 't']]\n\nassert f(g())\n",
        "idx_generation": 380,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find the number of ways to climb n stairs, where you can climb either 1 or 2 steps at a time.\"\"\"\n    if n == 0 or n == 1:\n        return 1\n    else:\n        return f(n-1) + f(n-2)\ndef g(n=5):\n    return n\nassert f(g()) == 8\n",
        "idx_generation": 15,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the number of unique paths from the top-left corner to the bottom-right corner of a grid of size n x n.\n    The only valid moves are down and right.\n    \"\"\"\n    def factorial(m: int) -> int:\n        result = 1\n        for i in range(1, m + 1):\n            result *= i\n        return result\n    \n    return factorial(2 * n - 2) // (factorial(n - 1) ** 2)\n\ndef g():\n    n = 3\n    return n\n\nassert f(g()) == 6\n",
        "idx_generation": 304,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there are two numbers in the list that can be\n    XORed together to obtain the target value. Return True if such pair exists, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if target ^ num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g():\n    nums = [2, 4, 6, 8, 10]\n    target = 12\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 447,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> List[int]:\n    \"\"\"Given an array of integers, find the k smallest elements in the array and return them in sorted order.\"\"\"\n    import heapq\n\n    k_smallest = heapq.nsmallest(k, arr)\n    return sorted(k_smallest)\n\ndef g(arr: List[int], k: int) -> List[int]:\n    return f(arr, k)\n\narr = [5, 2, 9, 1, 3, 7, 6, 4, 8]\nk = 4\nassert f(arr, k) == g(arr, k)\n",
        "idx_generation": 176,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, return True if the target value exists in the list, and False otherwise.\n    Sample Input:\n    nums = [1, 3, 5, 7, 9, 11, 13]\n    target = 7\n    Sample Output:\n    True\"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef g(nums=[1, 3, 5, 7, 9, 11, 13], target=7):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 26,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n    If the target value is not present in the list, return -1.\n    Sample Input:\n    nums = [1, 2, 4, 5, 7, 9, 10]\n    target = 7\n    Sample Output:\n    4\"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g(nums: List[int], target: int) -> int:\n    \"\"\"Find the index of the target value in a sorted list using binary search.\"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\nassert f(nums=[1, 2, 4, 5, 7, 9, 10], target=7) == g(nums=[1, 2, 4, 5, 7, 9, 10], target=7)\n",
        "idx_generation": 406,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array 'arr' in ascending order, and a target integer 'target',\n    determine if there exist two distinct indices i and j, such that arr[i] ^ arr[j] == target,\n    where '^' denotes the bitwise XOR operation.\"\"\"\n    n = len(arr)\n    left, right = 0, n-1\n    while left < right:\n        xor_val = arr[left] ^ arr[right]\n        if xor_val == target:\n            return True\n        elif xor_val < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g(), 7)\n",
        "idx_generation": 336,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number is a perfect number.\n    A perfect number is a positive integer that is equal to the sum of its proper positive divisors, excluding the number itself.\n    Return True if the number is perfect, otherwise return False.\n    Sample input:\n    28\n    Sample output:\n    True\"\"\"\n    divisors = []\n    for i in range(1, n):\n        if n % i == 0:\n            divisors.append(i)\n    return sum(divisors) == n\n\ndef g():\n    return 28\n\nassert f(g()) == True\n",
        "idx_generation": 185,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, find if there is a subset of the list that adds up to the target.\n    Return True if such a subset exists, False otherwise.\n    \"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    \n    # Base cases\n    for i in range(n + 1):\n        dp[i][0] = True\n    \n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j < nums[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n    \n    return dp[n][target]\n\ndef g(nums: List[int], target: int) -> List[int]:\n    return nums, target\n\nassert f(*g([1, 2, 3, 4, 5], 9))\n",
        "idx_generation": 382,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the length of the longest increasing path in the grid.\n    An increasing path is defined as a path where each cell's value is strictly greater than the previous cell's value.\n    \"\"\"\n\n    def dfs(i, j):\n        if memo[i][j] != 0:\n            return memo[i][j]\n\n        max_length = 1\n        for direction in directions:\n            new_i = i + direction[0]\n            new_j = j + direction[1]\n            if 0 <= new_i < m and 0 <= new_j < n and grid[new_i][new_j] > grid[i][j]:\n                max_length = max(max_length, 1 + dfs(new_i, new_j))\n\n        memo[i][j] = max_length\n        return max_length\n\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    memo = [[0] * n for _ in range(m)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    max_length = 0\n\n    for i in range(m):\n        for j in range(n):\n            max_length = max(max_length, dfs(i, j))\n\n    return max_length\n\ndef g():\n    return [[9, 9, 4], [6, 6, 8], [2, 1, 1]]\n\nassert f(g()) == 4\n",
        "idx_generation": 288,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a 2D matrix, check if it is a symmetric matrix.\n    Return True if the matrix is symmetric, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i+1, n):\n            if matrix[i][j] != matrix[j][i]:\n                return False\n    return True\n\ndef g():\n    matrix = [[1, 2, 3],\n              [2, 4, 5],\n              [3, 5, 6]]\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 359,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of integers, return True if the matrix is symmetric, False otherwise.\n    A matrix is symmetric if it is equal to its transpose.\n    Sample input:\n    [[1, 2, 3],\n    [2, 4, 5],\n    [3, 5, 6]]\n    Sample output:\n    True\"\"\"\n    transpose = [[matrix[j][i] for j in range(len(matrix[0]))] for i in range(len(matrix))]\n    return matrix == transpose\n\ndef g():\n    return [[1, 2, 3],\n            [2, 4, 5],\n            [3, 5, 6]]\n\nassert f(g()) == True\n",
        "idx_generation": 372,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list that sum up to k\"\"\"\n    seen = set()\n    for num in nums:\n        complement = k - num\n        if complement in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g():\n    nums = [2, 4, 6, 8, 10]\n    k = 12\n    return nums, k\n\nassert f(*g())\n",
        "idx_generation": 119,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(res: int, arr=[3, 1, 5, 2, 4], target=7) -> bool:\n    \"\"\"Find the minimum number of elements to remove from the given list to make the XOR of the remaining elements equal to the target value.\"\"\"\n    n = len(arr)\n    xor_sum = sum(arr) ^ target\n\n    dp = [[float('inf')] * (xor_sum + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(xor_sum + 1):\n            if j >= arr[i - 1]:\n                dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - arr[i - 1]] + 1)\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[n][xor_sum] != float('inf')\n\ndef g(arr=[3, 1, 5, 2, 4], target=7):\n    n = len(arr)\n    xor_sum = sum(arr) ^ target\n\n    dp = [[float('inf')] * (xor_sum + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(xor_sum + 1):\n            if j >= arr[i - 1]:\n                dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - arr[i - 1]] + 1)\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[n][xor_sum] != float('inf')\n\nassert f(g())\n",
        "idx_generation": 17,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str, n=1) -> bool:\n    \"\"\"Check if string s is a subsequence of string t after removing n characters from t.\"\"\"\n    i = 0\n    for char in t:\n        if i < len(s) and char == s[i]:\n            i += 1\n        if i == len(s):\n            break\n    return i == len(s)\ndef g(n=1):\n    return 'abcde' if n == 0 else 'acde' if n == 1 else 'ade'\nassert f(g(), 'abcde')\n",
        "idx_generation": 18,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers and a target sum, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in a list.\"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g():\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 188,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, find the number of subsets with an even sum.\"\"\"\n    count = 0\n    for i in range(1, 2**len(nums)):\n        subset = [nums[j] for j in range(len(nums)) if (i >> j) & 1]\n        if sum(subset) % 2 == 0:\n            count += 1\n    return count\n\ndef g():\n    return [1, 2, 3, 4]\n\nassert f(g()) == 7\n",
        "idx_generation": 67,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a subarray whose sum is equal to zero.\n    \n    Args:\n    arr: A list of integers\n    \n    Returns:\n    True if there exists a subarray whose sum is equal to zero, False otherwise\n    \"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    for num in arr:\n        prefix_sum += num\n        if prefix_sum in prefix_sums or prefix_sum == 0:\n            return True\n        prefix_sums.add(prefix_sum)\n    return False\n\ndef g():\n    \"\"\"\n    Generate a list of integers such that there exists a subarray whose sum is equal to zero.\n    \n    Returns:\n    A list of integers\n    \"\"\"\n    return [1, -1, 2]\n\nassert f(g())\n",
        "idx_generation": 118,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"Check if the given string s is a subsequence of string t\"\"\"\n    i = 0\n    for char in t:\n        if i < len(s) and char == s[i]:\n            i += 1\n    return i == len(s)\n\ndef g():\n    return \"abc\", \"abracadabra\"\n\nassert f(*g())\n",
        "idx_generation": 346,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, find the smallest positive number that is missing from the list.\n    Return True if there is a missing number, False otherwise.\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        while 0 < nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n    for i in range(n):\n        if nums[i] != i + 1:\n            return True\n    return False\n\ndef g():\n    nums = [1, 2, 0, 4, 5]\n    return nums\n\nassert f(g())\n",
        "idx_generation": 101,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix represented as a 2D grid of integers, determine if there is a path from the top-left corner to the bottom-right corner,\n    where the sum of all numbers along the path is divisible by 3.\"\"\"\n    m, n = len(matrix), len(matrix[0])\n    stack = [(0, 0, matrix[0][0])]\n    visited = set()\n\n    while stack:\n        i, j, path_sum = stack.pop()\n        if i == m - 1 and j == n - 1 and path_sum % 3 == 0:\n            return True\n        visited.add((i, j))\n\n        neighbors = [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]\n        for x, y in neighbors:\n            if 0 <= x < m and 0 <= y < n and (x, y) not in visited:\n                stack.append((x, y, path_sum + matrix[x][y]))\n\n    return False\n\ndef g():\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\nassert f(g())\n",
        "idx_generation": 139,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]], target=10) -> bool:\n    \"\"\"Find if there exists a path in the matrix that sums up to the target value.\"\"\"\n    def dfs(i, j, current_sum):\n        if i < 0 or i >= len(matrix) or j < 0 or j >= len(matrix[0]):\n            return False\n        current_sum += matrix[i][j]\n        if current_sum == target:\n            return True\n        return dfs(i + 1, j, current_sum) or dfs(i, j + 1, current_sum)\n\n    return dfs(0, 0, 0)\ndef g(target=10):\n    return [[1, 2, 3], [4, 5, 1], [6, 7, 2]]\nassert f(g())\n",
        "idx_generation": 22,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum sum of a subarray with the constraint that no two numbers in the\n    subarray are adjacent to each other.\n    Return the maximum sum.\"\"\"\n    if len(nums) == 0:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    if len(nums) == 2:\n        return max(nums[0], nums[1])\n\n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, len(nums)):\n        dp[i] = max(nums[i], dp[i - 2] + nums[i], dp[i - 1])\n\n    return dp[-1]\n\ndef g():\n    return [2, 4, 6, 2, 5]\n\nassert f(g()) == 13\n",
        "idx_generation": 226,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"Given a matrix of integers, rotate it 90 degrees clockwise.\"\"\"\n    n = len(matrix)\n    rotated = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            rotated[j][n-i-1] = matrix[i][j]\n    return rotated\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 279,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"Given a grid filled with non-negative integers, determine if it is possible to reach the target starting from the top-left corner.\n    You can only move to adjacent elements in the grid (up, down, left, or right). However, you can only move to an element that is greater than or equal to the current element.\n    Additionally, each element can only be visited once.\"\"\"\n    m, n = len(grid), len(grid[0])\n    stack = [(0, 0, grid[0][0])]\n    visited = set()\n    while stack:\n        i, j, val = stack.pop()\n        if val == target:\n            return True\n        visited.add((i, j))\n        \n        neighbors = [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]\n        for x, y in neighbors:\n            if 0 <= x < m and 0 <= y < n and (x, y) not in visited and grid[x][y] >= val:\n                stack.append((x, y, grid[x][y]))\n    \n    return False\n\ndef g(grid: List[List[int]], target: int) -> Tuple[int]:\n    \"\"\"Find the target value and return it as a tuple.\"\"\"\n    return (target,)\n\nassert f(grid=[[1, 2, 3], [4, 5, 6], [7, 8, 9]], target=g(grid=[[1, 2, 3], [4, 5, 6], [7, 8, 9]], target=9)[0])\n",
        "idx_generation": 417,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a 2D grid of 0s and 1s, determine if it is possible to reach the bottom-right corner\n    starting from the top-left corner, only moving right or down. The grid can only be traversed\n    through cells with 1s.\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[False] * n for _ in range(m)]\n    dp[0][0] = True\n    for i in range(1, m):\n        if grid[i][0] == 1 and dp[i-1][0]:\n            dp[i][0] = True\n    for j in range(1, n):\n        if grid[0][j] == 1 and dp[0][j-1]:\n            dp[0][j] = True\n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] == 1:\n                dp[i][j] = dp[i-1][j] or dp[i][j-1]\n    return dp[m-1][n-1]\n\ndef g():\n    return [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\n\nassert f(g())\n",
        "idx_generation": 236,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, prefix='hello', suffix='world') -> bool:\n    \"\"\"Find a string that starts with the given prefix and ends with the given suffix.\"\"\"\n    return s.startswith(prefix) and s.endswith(suffix)\ndef g(prefix='hello', suffix='world'):\n    return prefix + 'abc' + suffix\nassert f(g())\n",
        "idx_generation": 28,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of set (1) bits in the binary representation of n\"\"\"\n    binary = bin(n)[2:]\n    return binary.count('1')\n\ndef g(n=42):\n    return n\n\nassert f(g()) == 3\n",
        "idx_generation": 41,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"Given the dimensions of a grid, find the number of unique paths from the top-left corner to the bottom-right corner.\n    The player can only move down or right at each step, but cannot move outside the grid boundaries.\"\"\"\n    grid = [[0] * m for _ in range(n)]\n    return dfs(grid, n - 1, m - 1)\n\ndef dfs(grid, i, j):\n    if i < 0 or j < 0:\n        return 0\n    if i == 0 and j == 0:\n        return 1\n    if grid[i][j] > 0:\n        return grid[i][j]\n    grid[i][j] = dfs(grid, i - 1, j) + dfs(grid, i, j - 1)\n    return grid[i][j]\n\ndef g(n: int, m: int) -> int:\n    return f(n, m)\n\nn = 3\nm = 4\nassert f(n, m) == g(n, m)\n",
        "idx_generation": 493,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, k: int) -> List[str]:\n    \"\"\"Given a string s and an integer k, split the string into k-sized substrings.\n    Return a list of the substrings.\n    Example:\n    s = \"abcdefghi\"\n    k = 3\n    The string can be split into \"abc\", \"def\", \"ghi\".\n    Therefore, the answer is [\"abc\", \"def\", \"ghi\"].\n    \"\"\"\n    return [s[i:i+k] for i in range(0, len(s), k)]\n\ndef g():\n    s = \"abcdefghi\"\n    k = 3\n    return s, k\n\nassert f(*g()) == [\"abc\", \"def\", \"ghi\"]\n",
        "idx_generation": 98,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: dict, start: str, end: str) -> bool:\n    \"\"\"Given a directed graph represented as a dictionary, determine if there is a path from start node to end node.\n    Example:\n    graph = {'A': ['B', 'C'], 'B': ['C', 'D'], 'C': ['D'], 'D': ['A']}\n    start = 'A'\n    end = 'D'\n    Output: True\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph.get(node, []))\n    return False\n\ndef g():\n    graph = {'A': ['B', 'C'], 'B': ['C', 'D'], 'C': ['D'], 'D': ['A']}\n    start = 'A'\n    end = 'D'\n    return graph, start, end\n\nassert f(*g())\n",
        "idx_generation": 231,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start=0, end=5) -> bool:\n    \"\"\"Check if there is a path from start node to end node in the given graph.\"\"\"\n    visited = [False] * len(graph)\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if not visited[node]:\n            visited[node] = True\n            stack.extend(graph[node])\n    return False\n\ndef g():\n    return [[1, 2], [3, 4], [5], [5], [2, 3], []]\n\nassert f(g())\n",
        "idx_generation": 62,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency matrix, determine if there is a path\n    from the start node to the end node. Return True if a path exists, and False otherwise.\"\"\"\n    \n    def dfs(graph: List[List[int]], node: int, visited: List[bool]) -> bool:\n        \"\"\"Depth-first search to find a path from the start node to the end node.\"\"\"\n        \n        if node == end:\n            return True\n        \n        visited[node] = True\n        \n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                if dfs(graph, neighbor, visited):\n                    return True\n        \n        return False\n    \n    visited = [False] * len(graph)\n    return dfs(graph, start, visited)\n\ndef g():\n    graph = [[0, 1, 1, 0],\n             [0, 0, 1, 0],\n             [0, 0, 0, 1],\n             [0, 0, 0, 0]]\n    start = 0\n    end = 3\n    return graph, start, end\n\nassert f(*g())\n",
        "idx_generation": 61,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef f(root: Node) -> int:\n    \"\"\"Count the number of nodes in a binary tree.\"\"\"\n    if root is None:\n        return 0\n    return 1 + f(root.left) + f(root.right)\n\ndef g():\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n    return root\n\nassert f(g()) == 7\n",
        "idx_generation": 51,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport random\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if it is possible to traverse a grid from the top-left corner to the bottom-right corner, only moving right or down.\n    Return True if it is possible, and False otherwise.\"\"\"\n    \n    def dfs(grid: List[List[int]], row: int, col: int) -> bool:\n        \"\"\"Depth-first search to find a path in the grid.\"\"\"\n        \n        if row == len(grid) - 1 and col == len(grid[0]) - 1:\n            return True\n        \n        if row >= len(grid) or col >= len(grid[0]) or grid[row][col] == 1:\n            return False\n        \n        grid[row][col] = 1\n        \n        return dfs(grid, row + 1, col) or dfs(grid, row, col + 1)\n    \n    return dfs(grid, 0, 0)\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a random grid.\"\"\"\n    grid = [[0, 0, 1, 0, 0], [0, 0, 0, 0, 1], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0], [1, 1, 1, 0, 0]]\n    return grid\n\nassert f(g())\n",
        "idx_generation": 404,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int, target_sum: int) -> bool:\n    \"\"\"Find a combination of k distinct positive integers from 1 to n whose sum is equal to target_sum.\"\"\"\n    def helper(n, k, target_sum, curr_sum, curr_comb):\n        if k == 0:\n            return curr_sum == target_sum\n        if curr_sum > target_sum or n <= 0:\n            return False\n        return helper(n-1, k-1, target_sum, curr_sum + n, curr_comb + [n]) or helper(n-1, k, target_sum, curr_sum, curr_comb)\n    return helper(n, k, target_sum, 0, [])\ndef g(n=10, k=3, target_sum=15):\n    return n, k, target_sum\nassert f(*g())\n",
        "idx_generation": 36,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(x: int) -> int:\n    \"\"\"\n    Given an integer x, return the number of trailing zeroes in x factorial.\n    \"\"\"\n    count = 0\n    \n    while x > 0:\n        x //= 5\n        count += x\n    \n    return count\n\ndef g():\n    return 25\n\nassert f(g()) == 6\n",
        "idx_generation": 329,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport heapq\n\ndef f(arr: List[int], k: int) -> List[int]:\n    \"\"\"Find the k smallest elements in the given array\"\"\"\n    return heapq.nsmallest(k, arr)\n\ndef g(arr=[4, 3, 9, 7, 2, 1], k=3):\n    \"\"\"Return the given array and the value of k\"\"\"\n    return arr, k\n\nassert f(*g()) == [1, 2, 3]\n",
        "idx_generation": 180,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, find the longest increasing subsequence. Return True if the subsequence length is greater than or equal to 3, False otherwise.\"\"\"\n    n = len(nums)\n    if n < 3:\n        return False\n    \n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp) >= 3\n\ndef g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g())\n",
        "idx_generation": 26,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Check if it is possible to rearrange the characters of string s such that no two adjacent characters are the same.\"\"\"\n    if len(s) == 1:\n        return True\n    stack = []\n    for char in s:\n        if stack and stack[-1] == char:\n            stack.pop()\n            k -= 1\n        else:\n            stack.append(char)\n    return k >= 0\n\ndef g(s: str, k: int) -> str:\n    \"\"\"Rearrange the characters of string s such that no two adjacent characters are the same.\"\"\"\n    if not f(s, k):\n        return \"\"\n    freq = {}\n    for char in s:\n        freq[char] = freq.get(char, 0) + 1\n    heap = []\n    for char, count in freq.items():\n        heap.append((-count, char))\n    heapq.heapify(heap)\n    result = []\n    while heap:\n        count, char = heapq.heappop(heap)\n        result.append(char)\n        count += 1\n        if count < 0:\n            heapq.heappush(heap, (count, char))\n    return \"\".join(result)\n    \nassert f(g(\"aaabbcc\", 2), 2)\n",
        "idx_generation": 419,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, find if there are two distinct elements in the list whose XOR is equal to the target.\n    Return True if such elements exist, False otherwise.\n    \"\"\"\n    num_set = set()\n    for num in arr:\n        if (num ^ target) in num_set:\n            return True\n        num_set.add(num)\n    return False\n\ndef g(target: int):\n    arr = [1, 2, 3, 4, 5]\n    return arr, target\n\nassert f(*g(6))\n",
        "idx_generation": 359,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, check if there exists a triplet (a, b, c) such that a^2 + b^2 = c^2, where a, b, and c are distinct elements from the list.\n    Return True if such a triplet exists, otherwise return False.\n    Sample input:\n    [3, 1, 4, 6, 5]\n    Sample output:\n    True\"\"\"\n    nums.sort()\n    n = len(nums)\n    for i in range(n - 2):\n        a = nums[i]\n        left = i + 1\n        right = n - 1\n        while left < right:\n            b = nums[left]\n            c = nums[right]\n            if a * a + b * b == c * c:\n                return True\n            elif a * a + b * b < c * c:\n                right -= 1\n            else:\n                left += 1\n    return False\n\ndef g():\n    return [3, 1, 4, 6, 5]\n\nassert f(g()) == True\n",
        "idx_generation": 193,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if there exists a subset of the integers that adds up\n    to the target value.\"\"\"\n    nums.sort()\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    \n    for i in range(n + 1):\n        dp[i][0] = True\n    \n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j < nums[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n    \n    return dp[n][target]\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"Generate a list of integers from the given list such that the sum of the generated list is equal to the target\n    value.\"\"\"\n    nums.sort()\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    \n    for i in range(n + 1):\n        dp[i][0] = True\n    \n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j < nums[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n    \n    if not dp[n][target]:\n        return []\n    \n    subset = []\n    i, j = n, target\n    while i > 0 and j > 0:\n        if dp[i][j] != dp[i - 1][j]:\n            subset.append(nums[i - 1])\n            j -= nums[i - 1]\n        i -= 1\n    \n    return subset[::-1]\n\nassert f(g(nums=[1, 2, 3, 4, 5], target=9), target=9)\n",
        "idx_generation": 382,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the minimum path sum from the top left to the bottom right of a grid.\n    You can only move down or right.\"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    return dp[m - 1][n - 1]\n\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 309,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import Dict, List\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"\n    Given a directed graph represented as a dictionary and two nodes start and end, determine if there is a path from start to end.\n    You can only traverse the graph in one direction (from start to end) and each node can only be visited once.\n    \"\"\"\n    stack = [start]\n    visited = set()\n    \n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        visited.add(node)\n        neighbors = graph.get(node, [])\n        for neighbor in neighbors:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    \n    return False\n\ndef g():\n    return {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D', 'E'],\n        'D': ['E'],\n        'E': []\n    }\n\nassert f(g(), start='A', end='E')\n",
        "idx_generation": 360,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, rotate it 90 degrees clockwise and return the rotated matrix.\n    \"\"\"\n    n = len(matrix)\n    rotated_matrix = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        for j in range(n):\n            rotated_matrix[j][n - i - 1] = matrix[i][j]\n\n    return rotated_matrix\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers for testing the rotation function.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n\n",
        "idx_generation": 425,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, determine if the target number is present in the list.\n    Return True if present, otherwise return False.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5\n\nassert f(*g()) == True\n",
        "idx_generation": 135,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target=10) -> bool:\n    \"\"\"Check if there exists a subarray in the given array that sums up to the target value.\"\"\"\n    n = len(arr)\n    dp = [False] * (target + 1)\n    dp[0] = True\n    for i in range(n):\n        for j in range(target, arr[i] - 1, -1):\n            dp[j] = dp[j] or dp[j - arr[i]]\n    return dp[target]\ndef g(arr=[1, 2, 3, 4, 5]):\n    return arr\nassert f(g())\n",
        "idx_generation": 25,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import itertools\nfrom typing import*\ndef f(nums: List[int], k=3) -> bool:\n    \"\"\"Find if there exists a combination of numbers from the given list that sums up to k.\"\"\"\n    import itertools\n    for r in range(1, len(nums) + 1):\n        for combination in itertools.combinations(nums, r):\n            if sum(combination) == k:\n                return True\n    return False\ndef g(k=3):\n    return [1, 2, 3, 4, 5]\nassert f(g())\n",
        "idx_generation": 22,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find two numbers in the given list that add up to the target value.\n    Return the indices of the two numbers as a list.\"\"\"\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []\n\ndef g():\n    return [2, 7, 11, 15]\n\nassert f(g(), 9) == [0, 1]\n",
        "idx_generation": 240,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if the given matrix is a magic square.\n    A magic square is a square grid of numbers in which the sum of each row, column, and diagonal is the same.\n    Sample Input:\n    matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    Sample Output:\n    True\"\"\"\n    target_sum = sum(matrix[0])\n    n = len(matrix)\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        column_sum = sum(matrix[i][col] for i in range(n))\n        if column_sum != target_sum:\n            return False\n    \n    # Check diagonals\n    diagonal_sum1 = sum(matrix[i][i] for i in range(n))\n    diagonal_sum2 = sum(matrix[i][n-i-1] for i in range(n))\n    if diagonal_sum1 != target_sum or diagonal_sum2 != target_sum:\n        return False\n    \n    return True\n\ndef g(matrix=[[2, 7, 6], [9, 5, 1], [4, 3, 8]]) -> List[List[int]]:\n    \"\"\"Return the given matrix\"\"\"\n    return matrix\n\nassert f(g()) == True\n",
        "idx_generation": 95,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if there is a subarray in the given list of integers, whose sum is divisible by the length of the subarray.\"\"\"\n    prefix_sum = [0] * (len(nums) + 1)\n    for i in range(1, len(nums) + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums) + 1):\n            subarray_sum = prefix_sum[j] - prefix_sum[i]\n            subarray_length = j - i\n            if subarray_length > 0 and subarray_sum % subarray_length == 0:\n                return True\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g())\n",
        "idx_generation": 165,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import Tuple\n\ndef f(n: int) -> Tuple[int, int]:\n    \"\"\"Given a positive integer n, find a pair of distinct positive integers (x, y) such that x*y = n and x+y is minimized.\n    Sample Input:\n    n = 12\n    Sample Output:\n    (3, 4)\"\"\"\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            return (i, n // i)\n    return (n, 1)\n\ndef g(n: int) -> Tuple[int, int]:\n    \"\"\"Find a pair of distinct positive integers (x, y) such that x*y = n and x+y is minimized.\"\"\"\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            return (i, n // i)\n    return (n, 1)\n\nassert f(n=12) == g(n=12)\n",
        "idx_generation": 446,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of integers, check if it is a magic square. A magic square is a square grid of numbers\n    where the sums of each row, each column, and both diagonals are the same.\n    \"\"\"\n    n = len(grid)\n    target_sum = sum(grid[0])\n    \n    for i in range(n):\n        row_sum = sum(grid[i])\n        col_sum = sum(grid[j][i] for j in range(n))\n        if row_sum != target_sum or col_sum != target_sum:\n            return False\n    \n    diag1_sum = sum(grid[i][i] for i in range(n))\n    diag2_sum = sum(grid[i][n-i-1] for i in range(n))\n    \n    return diag1_sum == diag2_sum == target_sum\n\ndef g():\n    return [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n\nassert f(g()) == True\n",
        "idx_generation": 119,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, x=5, y=3) -> bool:\n    \"\"\"Check if n is divisible by both x and y.\"\"\"\n    return n % x == 0 and n % y == 0\ndef g(x=5, y=3):\n    return x * y\nassert f(g())\n",
        "idx_generation": 148,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the nth Fibonacci number using recursion\"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return f(n-1) + f(n-2)\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 5\n",
        "idx_generation": 22,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport heapq\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Find the minimum sum of a path from the top-left corner to the bottom-right corner of the matrix. You can only move right or down.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    dp = [[float('inf')] * cols for _ in range(rows)]\n    dp[0][0] = matrix[0][0]\n    queue = [(matrix[0][0], 0, 0)]  # Priority queue to store the sum, row, and column\n    while queue:\n        curr_sum, row, col = heapq.heappop(queue)\n        if row == rows - 1 and col == cols - 1:  # Reached the bottom-right corner\n            return curr_sum\n        if curr_sum > dp[row][col]:  # If a better path to this cell has already been found\n            continue\n        for dr, dc in [(1, 0), (0, 1)]:  # Move down, right\n            new_row, new_col = row + dr, col + dc\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                new_sum = curr_sum + matrix[new_row][new_col]\n                if new_sum < dp[new_row][new_col]:\n                    dp[new_row][new_col] = new_sum\n                    heapq.heappush(queue, (new_sum, new_row, new_col))\n    return -1\n\ndef g(matrix=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return matrix\n\nassert f(g()) == 7\n",
        "idx_generation": 233,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\nfrom typing import List\n\ndef f(points: List[List[int]]) -> bool:\n    \"\"\"Check if a given polygon is convex.\n    The vertices are represented as a list of [x, y] coordinates in clockwise or counter-clockwise order.\n    Sample Input:\n    points = [[0, 0], [0, 5], [5, 5], [5, 0]]\n    Sample Output:\n    True\"\"\"\n    n = len(points)\n    sign = 0\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n        cross_product = (points[j][0] - points[i][0]) * (points[k][1] - points[j][1]) - (points[j][1] - points[i][1]) * (points[k][0] - points[j][0])\n        if sign == 0:\n            sign = cross_product\n        elif cross_product * sign < 0:\n            return False\n    return True\n\ndef g():\n    points = [[0, 0], [0, 5], [5, 5], [5, 0]]\n    return points\n\nassert f(g())\n",
        "idx_generation": 314,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid with '0' representing an empty cell, '1' representing an obstacle, and '9' representing the target, \n    determine if there exists a path from the top-left corner to the target, using only downwards, rightwards, and diagonal movements.\n    Each movement can only be made to an adjacent cell (either horizontally, vertically, or diagonally).\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    visited = [[False] * cols for _ in range(rows)]\n    queue = [(0, 0)]\n    while queue:\n        x, y = queue.pop(0)\n        if grid[x][y] == 9:\n            return True\n        if grid[x][y] == 1 or visited[x][y]:\n            continue\n        visited[x][y] = True\n        if x + 1 < rows:\n            queue.append((x + 1, y))\n        if y + 1 < cols:\n            queue.append((x, y + 1))\n        if x + 1 < rows and y + 1 < cols:\n            queue.append((x + 1, y + 1))\n    return False\n\ndef g():\n    return [[0, 0, 0, 1],\n            [0, 1, 0, 1],\n            [0, 0, 1, 9]]\n\nassert f(g())\n",
        "idx_generation": 445,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of integers, determine if it is possible to reach the bottom-right cell starting from the top-left cell by moving only right or down.\n    Each cell in the grid represents the maximum number of steps that can be taken from that cell.\n    Return True if it is possible, False otherwise.\"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[False] * n for _ in range(m)]\n    dp[0][0] = True\n\n    for i in range(m):\n        for j in range(n):\n            if dp[i][j]:\n                if i + grid[i][j] < m:\n                    dp[i + grid[i][j]][j] = True\n                if j + grid[i][j] < n:\n                    dp[i][j + grid[i][j]] = True\n    \n    return dp[m - 1][n - 1]\n\ndef g():\n    return [[2, 4, 3], [1, 2, 1], [2, 1, 1]]\n\nassert f(g())\n",
        "idx_generation": 237,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, word_list=['apple', 'banana', 'cherry', 'date', 'elderberry']) -> bool:\n    \"\"\"Check if a string can be formed by concatenating words from a given list\"\"\"\n    n = len(s)\n    word_lengths = [len(word) for word in word_list]\n    dp = [False] * (n + 1)\n    dp[0] = True\n    for i in range(1, n + 1):\n        for length in word_lengths:\n            if i >= length and dp[i - length] and s[i - length:i] in word_list:\n                dp[i] = True\n                break\n    return dp[n]\ndef g(word_list=['apple', 'banana', 'cherry', 'date', 'elderberry']):\n    return 'applebanana'\nassert f(g())\n",
        "idx_generation": 47,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given an array of integers 'arr' and a target value 'target', determine if there exist three distinct indices i, j, and k,\n    such that arr[i] & arr[j] & arr[k] == target, where '&' denotes the bitwise AND operation.\"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if arr[i] & arr[j] & arr[k] == target:\n                    return True\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g(), 4)\n",
        "idx_generation": 49,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find the nth Fibonacci number.\"\"\"\n    def fibonacci(num):\n        if num == 0:\n            return 0\n        if num == 1 or num == 2:\n            return 1\n        return fibonacci(num - 1) + fibonacci(num - 2)\n    \n    return fibonacci(n) == 55\ndef g():\n    return 10\nassert f(g())\n",
        "idx_generation": 6,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k=3) -> bool:\n    \"\"\"Given a string, determine if it can be split into k equal parts, such that each part is a palindrome.\n    Return True if such split is possible, False otherwise.\"\"\"\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    \n    n = len(s)\n    if n % k != 0:\n        return False\n    \n    part_len = n // k\n    for i in range(k):\n        start = i * part_len\n        end = start + part_len\n        if not is_palindrome(s[start:end]):\n            return False\n    \n    return True\n\ndef g(k=3) -> str:\n    \"\"\"Generate a string that can be split into k equal parts, where each part is a palindrome.\"\"\"\n    return \"abcba\" * k\n\nassert f(g())\n",
        "idx_generation": 130,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(arr: List[int], target=100) -> bool:\n    \"\"\"Find if there exists a path in the given graph that starts at node 0 and ends at node N-1, where N is the number of nodes. \n    The path must have a total weight equal to the target value.\n    The graph is represented as an adjacency matrix where arr[i][j] represents the weight of the edge between node i and node j.\n    \"\"\"\n    N = len(arr)\n    visited = [False] * N\n    return dfs(arr, 0, target, visited)\n\ndef dfs(arr, node, target, visited):\n    if node == len(arr) - 1:\n        return target == 0\n    visited[node] = True\n    for i in range(len(arr)):\n        if not visited[i] and arr[node][i] != 0:\n            if dfs(arr, i, target - arr[node][i], visited):\n                return True\n    visited[node] = False\n    return False\n\ndef g(target=100):\n    arr = [\n        [0, 10, 0, 0, 0],\n        [0, 0, 20, 0, 0],\n        [0, 0, 0, 30, 0],\n        [0, 0, 0, 0, 40],\n        [0, 0, 0, 0, 0]\n    ]\n    return arr\n\nassert f(g())\n",
        "idx_generation": 241,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: List[List[int]], source=0, destination=3) -> bool:\n    \"\"\"Find if there is a path from the source node to the destination node in the given undirected graph.\"\"\"\n    visited = [False] * len(graph)\n    stack = [source]\n    while stack:\n        node = stack.pop()\n        if node == destination:\n            return True\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                stack.append(neighbor)\n    return False\ndef g(source=0, destination=3):\n    return [[1, 2], [0, 2, 3], [0, 1, 3], [1, 2]]\nassert f(g())\n",
        "idx_generation": 64,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"Given a directed graph represented by its edges, determine if it contains a Hamiltonian path.\"\"\"\n    \n    graph = [[] for _ in range(n)]\n    \n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n    \n    def dfs(node, visited, path):\n        visited[node] = True\n        path.append(node)\n        \n        if len(path) == n:\n            return True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor] and dfs(neighbor, visited, path):\n                return True\n        \n        visited[node] = False\n        path.pop()\n        \n        return False\n    \n    visited = [False] * n\n    path = []\n    \n    for i in range(n):\n        if dfs(i, visited, path):\n            return True\n    \n    return False\n\ndef g():\n    n = 4\n    edges = [[0, 1], [1, 2], [2, 3]]\n    return n, edges\n\nassert f(*g())\n",
        "idx_generation": 63,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(graph: Dict[str, List[str]], start: str, target: str) -> bool:\n    \"\"\"Given a directed graph represented by an adjacency list, determine if there is a path from the start node to the target node.\n    Return True if a path exists, False otherwise.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == target:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g() -> Tuple[Dict[str, List[str]], str, str]:\n    \"\"\"Generate a random directed graph represented by an adjacency list, along with a start and target node.\"\"\"\n    graph = {'A': ['B', 'C'], 'B': ['D', 'E'], 'C': ['F'], 'D': ['G'], 'E': [], 'F': ['G'], 'G': []}\n    start = 'A'\n    target = 'G'\n    return graph, start, target\n\nassert f(*g())\n\n",
        "idx_generation": 52,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool:\n    \"\"\"Given a grid filled with 0s and 1s, determine if there is a path from the start coordinate to the end coordinate.\n    You can only move to adjacent elements in the grid (up, down, left, or right). However, you can only move to a 0 element and not to a 1 element.\n    Additionally, you can only move in a clockwise or counterclockwise direction in the grid, but not in a straight line.\"\"\"\n    m, n = len(grid), len(grid[0])\n    visited = [[False] * n for _ in range(m)]\n    \n    def dfs(i: int, j: int) -> bool:\n        if (i, j) == end:\n            return True\n        visited[i][j] = True\n        \n        neighbors = [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]\n        for x, y in neighbors:\n            if 0 <= x < m and 0 <= y < n and not visited[x][y] and grid[x][y] == 0:\n                if dfs(x, y):\n                    return True\n        \n        return False\n    \n    return dfs(start[0], start[1])\n\ndef g(grid: List[List[int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n    \"\"\"Find the coordinates of the start and end elements in the grid.\"\"\"\n    m, n = len(grid), len(grid[0])\n    start = (0, 0)\n    end = (m-1, n-1)\n    \n    return start, end\n\nassert f(grid=[[0, 1, 0], [0, 0, 0], [1, 0, 0]], start=g(grid=[[0, 1, 0], [0, 0, 0], [1, 0, 0]])[0], end=g(grid=[[0, 1, 0], [0, 0, 0], [1, 0, 0]])[1])\n",
        "idx_generation": 417,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, calculate the number of unique binary search trees that can be formed using numbers from 1 to n.\"\"\"\n    if n == 0 or n == 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i - j - 1]\n    return dp[n]\n\ndef g():\n    return 5\n\nassert f(g()) == 42\n",
        "idx_generation": 47,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find n such that the number of ways to arrange n different objects in a circle is equal to a perfect cube.\"\"\"\n    factorial = 1\n    for i in range(2, n + 1):\n        factorial *= i\n    return factorial % n == 0\n\ndef g():\n    n = 1\n    while not f(n):\n        n += 1\n    return n\n\nassert f(g())\n",
        "idx_generation": 392,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target number, determine if there are two numbers in the list that add up to the target.\n    Return True if there exist two numbers in the list that add up to the target, otherwise return False.\n    Sample input:\n    nums = [2, 4, 6, 8, 10]\n    target = 12\n    Sample output:\n    True\"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    return [2, 4, 6, 8, 10], 12\n\nassert f(*g()) == True\n\n",
        "idx_generation": 184,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given an integer n, determine if it is a prime number.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n\n    return True\n\ndef g():\n    return 17\n\nassert f(g())\n",
        "idx_generation": 26,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> List[int]:\n    \"\"\"Given an adjacency matrix 'graph' representing a weighted directed graph,\n    find the shortest path from the source node (index 0) to the destination node (index n-1).\n    The graph is represented as a square matrix where graph[i][j] represents the weight of the directed edge from node i to node j.\n    Return a list of nodes representing the shortest path.\n    Example:\n    graph = [[0, 2, 4, 0],\n             [0, 0, 1, 0],\n             [0, 0, 0, 3],\n             [0, 0, 0, 0]]\n    The graph represents the following weighted directed graph:\n    0 --2--> 1 --1--> 2 --3--> 3\n    The shortest path from node 0 to node 3 is [0, 1, 2, 3], so the answer is [0, 1, 2, 3].\n    \"\"\"\n    n = len(graph)\n    distances = [float('inf')] * n\n    distances[0] = 0\n    parents = [-1] * n\n    \n    for _ in range(n-1):\n        for i in range(n):\n            for j in range(n):\n                if graph[i][j] != 0 and distances[i] + graph[i][j] < distances[j]:\n                    distances[j] = distances[i] + graph[i][j]\n                    parents[j] = i\n    \n    path = []\n    current = n-1\n    while current != -1:\n        path.append(current)\n        current = parents[current]\n    return path[::-1]\n\ndef g():\n    return [[0, 2, 4, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 3],\n            [0, 0, 0, 0]]\n\nassert f(g()) == [0, 1, 2, 3]\n",
        "idx_generation": 421,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum XOR value between two numbers in a given list\"\"\"\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n\n        for num in nums:\n            prefix = num & mask\n            prefix_set.add(prefix ^ max_xor)\n\n        possible_max = max_xor | (1 << i)\n        for prefix in prefix_set:\n            if prefix ^ possible_max in prefix_set:\n                max_xor = possible_max\n                break\n\n    return max_xor\n\ndef g():\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n",
        "idx_generation": 456,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum product of three numbers in the list.\n    Return the maximum product.\n    Sample input:\n    [1, 2, 3, 4]\n    Sample output:\n    24\"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n - 1], nums[n - 1] * nums[n - 2] * nums[n - 3])\n\ndef g():\n    return [1, 2, 3, 4]\n\nassert f(g()) == 24\n",
        "idx_generation": 193,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if n is a prime number.\"\"\"\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n    \n    return is_prime(n)\n\ndef g(n: int):\n    return n\n\nassert f(g(13))\n",
        "idx_generation": 385,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=0) -> bool:\n    \"\"\"Find the maximum sum subarray of a given array.\"\"\"\n    def maxSubarray(nums, left, right):\n        if left == right:\n            return nums[left]\n        mid = (left + right) // 2\n        maxLeft = maxSubarray(nums, left, mid)\n        maxRight = maxSubarray(nums, mid + 1, right)\n        maxCross = maxCrossSubarray(nums, left, mid, right)\n        return max(maxLeft, maxRight, maxCross)\n    \n    def maxCrossSubarray(nums, left, mid, right):\n        leftSum = float('-inf')\n        sum = 0\n        for i in range(mid, left - 1, -1):\n            sum += nums[i]\n            if sum > leftSum:\n                leftSum = sum\n        rightSum = float('-inf')\n        sum = 0\n        for i in range(mid + 1, right + 1):\n            sum += nums[i]\n            if sum > rightSum:\n                rightSum = sum\n        return leftSum + rightSum\n    \n    return maxSubarray(nums, 0, len(nums) - 1)\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 353,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of numbers is a valid sequence of a binary search tree's pre-order traversal.\"\"\"\n    if not nums:\n        return True\n    \n    root = float('-inf')\n    stack = []\n    \n    for num in nums:\n        if num < root:\n            return False\n        while stack and stack[-1] < num:\n            root = stack.pop()\n        stack.append(num)\n    \n    return True\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"Generate a valid sequence of a binary search tree's pre-order traversal given a list of numbers.\"\"\"\n    if not nums:\n        return []\n    \n    root = float('-inf')\n    stack = []\n    result = []\n    \n    for num in nums:\n        if num < root:\n            return []\n        while stack and stack[-1] < num:\n            root = stack.pop()\n            result.append(root)\n        stack.append(num)\n    \n    while stack:\n        result.append(stack.pop())\n    \n    return result\n\nassert f(g(nums=[5, 3, 1, 4, 9, 7, 10]))\n",
        "idx_generation": 373,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Find if there exists a subarray in the given array whose sum is equal to 0.\"\"\"\n    prefix_sum = [0]\n    curr_sum = 0\n    for num in nums:\n        curr_sum += num\n        if curr_sum in prefix_sum:\n            return True\n        prefix_sum.append(curr_sum)\n    return False\n\ndef g(nums: List[int]):\n    \"\"\"Find a subarray in the given array whose sum is equal to 0.\"\"\"\n    prefix_sum = {0: -1}\n    curr_sum = 0\n    for i, num in enumerate(nums):\n        curr_sum += num\n        if curr_sum in prefix_sum:\n            return nums[prefix_sum[curr_sum]+1:i+1]\n        prefix_sum[curr_sum] = i\n    return None\n\nassert f(g([-2, 1, 3, -4, 2]))\n",
        "idx_generation": 429,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list such that their sum is even and their product is odd.\"\"\"\n    even_count = 0\n    odd_count = 0\n\n    for num in nums:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    return even_count >= 2 and odd_count >= 2\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g())\n",
        "idx_generation": 220,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers nums and a target sum, find all unique combinations in nums where the candidate numbers\n    sum to target. Each number in nums may only be used once in the combination.\n    The solution set must not contain duplicate combinations.\n    Example:\n    nums = [10, 1, 2, 7, 6, 1, 5]\n    target = 8\n    The unique combinations are [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]], where the sum of each combination is 8.\n    Therefore, the function should return [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]].\n    \"\"\"\n    def backtrack(start, curr_sum, curr_comb):\n        if curr_sum == target:\n            result.append(curr_comb[:])\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            if curr_sum + nums[i] > target:\n                break\n            curr_comb.append(nums[i])\n            backtrack(i + 1, curr_sum + nums[i], curr_comb)\n            curr_comb.pop()\n    \n    nums.sort()\n    result = []\n    backtrack(0, 0, [])\n    return result\n\ndef g():\n    return [10, 1, 2, 7, 6, 1, 5], 8\n\nassert f(*g()) == [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n",
        "idx_generation": 35,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string, determine if it is a palindrome after removing exactly one character\"\"\"\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    left = 0\n    right = len(s) - 1\n\n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s[left:right]) or is_palindrome(s[left + 1:right + 1])\n        left += 1\n        right -= 1\n    return True\n\ndef g(s: str) -> str:\n    \"\"\"Generate a string that is a palindrome after removing exactly one character\"\"\"\n    for i in range(len(s)):\n        if s[i] != s[-i - 1]:\n            return s[:i] + s[i + 1:]\n    return s[:-1]\n\nassert f(g(\"racecar\"))\n",
        "idx_generation": 48,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list that sum up to the target.\"\"\"\n    nums_set = set(nums)\n    for num in nums:\n        complement = target - num\n        if complement in nums_set:\n            return True\n    return False\n\ndef g():\n    return [2, 4, 6, 8, 10]\n\nassert f(g(), 12)\n",
        "idx_generation": 266,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a pair of numbers whose sum is a perfect square.\n    \n    Return True if such a pair exists, False otherwise.\n    \"\"\"\n    squares = set()\n    for i in range(1, int(max(nums)**0.5) + 1):\n        squares.add(i**2)\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] + nums[j] in squares:\n                return True\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g())\n",
        "idx_generation": 122,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if a subset of numbers in the given list can sum up to the target.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if nums[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[n][target]\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find a subset of numbers in the given list that sums up to the target.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if nums[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    subset = []\n    i = n\n    j = target\n    while i > 0 and j > 0:\n        if dp[i - 1][j]:\n            i -= 1\n        else:\n            subset.append(nums[i - 1])\n            j -= nums[i - 1]\n            i -= 1\n    return subset[::-1]\n\nassert f(g([2, 4, 6, 8], 10), 10)\n",
        "idx_generation": 250,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers 'nums', return the sum of all the even numbers in the list.\"\"\"\n    even_sum = 0\n    for num in nums:\n        if num % 2 == 0:\n            even_sum += num\n    return even_sum\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"Return the given list of integers.\"\"\"\n    return nums\n\nassert f(g([1, 2, 3, 4, 5, 6, 7, 8, 9])) == 20\n",
        "idx_generation": 485,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target_sum=0) -> bool:\n    \"\"\"Find if there exists a subset of nums that adds up to the target_sum.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target_sum + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target_sum + 1):\n            if nums[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[n][target_sum]\ndef g(target_sum=0):\n    nums = [1, 3, 5, 7, 9]\n    return nums, target_sum\nassert f(*g())\n",
        "idx_generation": 148,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if the parentheses in string 's' are balanced.\n    Return True if balanced, otherwise return False.\n    \"\"\"\n    stack = deque()\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g():\n    \"\"\"\n    Generate a string with parentheses.\n    \"\"\"\n    s = \"((()))(())\"\n    \n    return s\n\nassert f(g())\n",
        "idx_generation": 156,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of 0s and 1s, determine if there is a path from the top-left corner to the bottom-right corner,\n    only moving through the cells containing 1s.\"\"\"\n    \n    def dfs(i, j):\n        if i == len(matrix) - 1 and j == len(matrix[0]) - 1:\n            return True\n        \n        if matrix[i][j] == 0:\n            return False\n        \n        if i < len(matrix) - 1 and dfs(i + 1, j):\n            return True\n        if j < len(matrix[0]) - 1 and dfs(i, j + 1):\n            return True\n        \n        return False\n    \n    return dfs(0, 0)\n\ndef g():\n    matrix = [\n        [1, 1, 1, 0],\n        [1, 0, 1, 1],\n        [1, 1, 0, 1],\n        [1, 1, 1, 1]\n    ]\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 35,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if it is possible to select a subset of the integers that sum up to the target value.\"\"\"\n    def helper(nums, target, i, memo):\n        if target == 0:\n            return True\n        if i == len(nums):\n            return False\n        if (i, target) in memo:\n            return memo[(i, target)]\n        if nums[i] <= target:\n            if helper(nums, target - nums[i], i + 1, memo):\n                memo[(i, target)] = True\n                return True\n        memo[(i, target)] = helper(nums, target, i + 1, memo)\n        return memo[(i, target)]\n    memo = {}\n    return helper(nums, target, 0, memo)\ndef g(nums=[2, 4, 6, 8, 10], target=16):\n    return nums, target\nassert f(*g())\n",
        "idx_generation": 244,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"Rotate the given grid clockwise by 90 degrees.\n    Sample Input:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n    Sample Output:\n    [[7, 4, 1],\n     [8, 5, 2],\n     [9, 6, 3]]\"\"\"\n    n = len(grid)\n    rotated = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            rotated[j][n - 1 - i] = grid[i][j]\n    return rotated\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"Return the grid to be rotated.\"\"\"\n    return grid\n\nassert f(g(grid=[[1, 2, 3], [4, 5, 6], [7, 8, 9]])) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 347,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if it is possible to reach the bottom-right cell of the grid starting from the top-left cell, following certain rules.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    stack = [(0, 0)]\n    visited = set([(0, 0)])\n\n    while stack:\n        row, col = stack.pop()\n\n        if row == rows - 1 and col == cols - 1:\n            return True\n\n        for i, j in [(row + 1, col), (row, col + 1)]:\n            if 0 <= i < rows and 0 <= j < cols and (i, j) not in visited:\n                visited.add((i, j))\n                if grid[i][j] != 0:\n                    stack.append((i, j))\n\n    return False\n\ndef g():\n    grid = [\n        [1, 1, 0, 0, 0],\n        [0, 1, 1, 0, 0],\n        [0, 0, 1, 1, 1],\n        [0, 0, 0, 0, 1],\n        [1, 1, 1, 1, 1]\n    ]\n    return grid\n\nassert f(g())\n\n",
        "idx_generation": 464,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if the grid contains a path from the top-left corner to the bottom-right corner, where each step can only move right or down\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[False] * n for _ in range(m)]\n    dp[0][0] = True\n\n    for i in range(m):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] = dp[i][j] or (dp[i-1][j] and grid[i][j] != 1)\n            if j > 0:\n                dp[i][j] = dp[i][j] or (dp[i][j-1] and grid[i][j] != 1)\n\n    return dp[m-1][n-1]\n\ndef g():\n    grid = [\n        [0, 0, 0, 0],\n        [0, 1, 1, 0],\n        [0, 1, 0, 0],\n        [0, 0, 0, 0]\n    ]\n    return grid\n\nassert f(g())\n",
        "idx_generation": 249,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome.\"\"\"\n    return s == s[::-1]\n\ndef g():\n    return \"racecar\"\n\nassert f(g())\n",
        "idx_generation": 57,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"Given a non-negative integer num, return the number of 1's in its binary representation.\n    Example:\n    num = 9\n    Output: 2 (binary representation of 9 is 1001, which has 2 1's)\n    \"\"\"\n    count = 0\n    while num > 0:\n        count += num & 1\n        num >>= 1\n    return count\n\ndef g(num: int) -> int:\n    return bin(num).count('1')\n\nnum = 9\nassert f(num) == g(num)\n",
        "idx_generation": 53,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer 'n', return the number of different ways to climb to the top of\n    a staircase with 'n' steps. You can climb either 1 or 2 steps at a time.\"\"\"\n    if n == 0 or n == 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\ndef g():\n    return 5\n\nassert f(g()) == 8\n",
        "idx_generation": 20,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"Check if the given string is a palindrome and if the given number is a prime number.\"\"\"\n    is_palindrome = s == s[::-1]\n\n    is_prime = True\n    if n < 2:\n        is_prime = False\n    else:\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                is_prime = False\n                break\n\n    return is_palindrome and is_prime\n\ndef g():\n    s = 'racecar'\n    n = 17\n    return s, n\n\nassert f(*g())\n",
        "idx_generation": 162,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"Check if there exists a path from the start node to the end node in a given directed graph.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        visited.add(node)\n        if node == end:\n            return True\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    return False\n\ndef g():\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['E'],\n        'D': [],\n        'E': ['F'],\n        'F': []\n    }\n    start = 'A'\n    end = 'F'\n    return graph, start, end\n\nassert f(*g())\n",
        "idx_generation": 293,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport collections\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"Given a directed graph represented as a dictionary where the keys are nodes and the values are lists of\n    neighboring nodes, determine if there is a path from the start node to the end node.\"\"\"\n    visited = set()\n    queue = collections.deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        visited.add(node)\n        \n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                queue.append(neighbor)\n    \n    return False\n\ndef g():\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D', 'E'],\n        'D': ['E'],\n        'E': []\n    }\n    start = 'A'\n    end = 'E'\n    \n    return (graph, start, end)\n\nassert f(*g())\n",
        "idx_generation": 76,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]]) -> bool:\n    \"\"\"Check if a given graph is bipartite.\n    A bipartite graph is a graph whose vertices can be divided into two disjoint sets such that every edge connects a vertex from one set to the other set.\n    \"\"\"\n    n = len(graph)\n    colors = [0] * n\n    \n    def is_bipartite(node, color):\n        if colors[node] != 0:\n            return colors[node] == color\n        colors[node] = color\n        for neighbor in graph[node]:\n            if not is_bipartite(neighbor, -color):\n                return False\n        return True\n    \n    for node in graph:\n        if colors[node] == 0 and not is_bipartite(node, 1):\n            return False\n    return True\n\ndef g(graph: Dict[int, List[int]]):\n    return graph\n\nassert f(g({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]}))\n",
        "idx_generation": 67,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of integers, determine if there exists a path from the top left cell to the bottom right cell,\n    only moving right or down, such that the sum of the integers along the path is a prime number.\"\"\"\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def dfs(i, j, current_sum):\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\n            return is_prime(current_sum + grid[i][j])\n        if i < len(grid) - 1 and dfs(i + 1, j, current_sum + grid[i][j]):\n            return True\n        if j < len(grid[0]) - 1 and dfs(i, j + 1, current_sum + grid[i][j]):\n            return True\n        return False\n\n    return dfs(0, 0, 0)\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g())\n",
        "idx_generation": 71,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid with non-negative integers, find the minimum sum path from the top-left corner to the bottom-right corner.\n    Allowed movements are down and right.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[float('inf')] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(rows):\n        for j in range(cols):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j])\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j])\n    return dp[rows-1][cols-1]\n\ndef g():\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 440,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, determine the number of unique combinations of coins that can be used to make up n cents.\n    You have an unlimited supply of coins in denominations of 1, 5, 10, and 25 cents.\"\"\"\n    coins = [1, 5, 10, 25]\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for coin in coins:\n        for i in range(coin, n + 1):\n            dp[i] += dp[i - coin]\n    return dp[n]\n\ndef g(n: int) -> int:\n    \"\"\"Generate a positive integer\"\"\"\n    return n\n\nassert f(g(10)) == 4\n",
        "idx_generation": 48,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    \"\"\"Find a list of numbers and a target value that satisfy the condition of the puzzle.\"\"\"\n    nums = [1, 3, 5, 7, 9]\n    target = 10\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 215,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Find if there exists a pair of elements in the array that add up to the target value\"\"\"\n    arr.sort()\n    left, right = 0, len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g(arr=[2, 4, 6, 8, 10], target=12):\n    return arr, target\nassert f(*g())\n",
        "idx_generation": 26,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum you can achieve by starting at the top-left corner\n    and moving only right and down to the bottom-right corner. Return the maximum sum.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of non-negative integers.\n    \"\"\"\n    import random\n    grid = [[random.randint(0, 9) for _ in range(5)] for _ in range(5)]\n    \n    return grid\n\nassert f(g()) >= 0\n",
        "idx_generation": 422,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between two numbers in the list.\n    XOR is a bitwise operation that returns 1 if the corresponding bits are different, and 0 if they are the same.\n    \"\"\"\n    max_xor = 0\n    \n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n    \n    return max_xor\n\ndef g(nums=[3, 10, 5, 25, 2, 8]):\n    return nums\n\nassert f(g()) == 28\n",
        "idx_generation": 493,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Given a 2D matrix of distinct integers and a target value, check if the target exists in the matrix.\"\"\"\n    if not matrix or not matrix[0]:\n        return False\n    rows = len(matrix)\n    cols = len(matrix[0])\n    left = 0\n    right = rows * cols - 1\n    while left <= right:\n        mid = (left + right) // 2\n        row = mid // cols\n        col = mid % cols\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef g(matrix=[[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]], target=3):\n    return matrix, target\n\nassert f(*g())\n",
        "idx_generation": 214,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, return True if there exists a subarray (contiguous subsequence) with a sum of 0, and False otherwise.\n    Sample Input:\n    nums = [4, 2, -3, 1, 6]\n    Sample Output:\n    True\n    Explanation: The subarray [2, -3, 1] has a sum of 0.\n    \"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum in prefix_sums or prefix_sum == 0:\n            return True\n        prefix_sums.add(prefix_sum)\n    return False\n\ndef g(nums: List[int]) -> bool:\n    \"\"\"Find if there exists a subarray with a sum of 0 in a given list of integers.\"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum in prefix_sums or prefix_sum == 0:\n            return True\n        prefix_sums.add(prefix_sum)\n    return False\n\nassert f(nums=[4, 2, -3, 1, 6]) == g(nums=[4, 2, -3, 1, 6])\n",
        "idx_generation": 490,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of integers, find the length of the longest increasing path.\n    A path is considered increasing if each cell in the path is greater than the previous cell.\n    Movement is allowed in four directions: up, down, left, or right.\n    Example:\n    Input:\n    [\n      [9,9,4],\n      [6,6,8],\n      [2,1,1]\n    ]\n    Output: 4\n    Explanation: The longest increasing path is [1, 2, 6, 9], therefore the output is 4.\n    \"\"\"\n    if not matrix:\n        return 0\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    def dfs(i, j):\n        if dp[i][j] != 0:\n            return dp[i][j]\n        dp[i][j] = 1\n        for dx, dy in directions:\n            x, y = i + dx, j + dy\n            if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                dp[i][j] = max(dp[i][j], dfs(x, y) + 1)\n        return dp[i][j]\n    \n    max_length = 0\n    for i in range(m):\n        for j in range(n):\n            max_length = max(max_length, dfs(i, j))\n    \n    return max_length\ndef g():\n    return [\n      [9,9,4],\n      [6,6,8],\n      [2,1,1]\n    ]\nassert f(g()) == 4\n",
        "idx_generation": 361,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: List[List[int]]) -> List[int]:\n    \"\"\"Given an undirected graph represented as an adjacency list, return a list of nodes in the graph\n    sorted in topological order.\n    Sample Input:\n    graph = [[1, 2], [3, 4], [5], [], [5], []]\n    Sample Output:\n    [0, 1, 2, 3, 4, 5]\"\"\"\n    visited = set()\n    result = []\n\n    def dfs(node):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor)\n        result.append(node)\n\n    for node in range(len(graph)):\n        if node not in visited:\n            dfs(node)\n\n    return result[::-1]\n\ndef g(graph: List[List[int]]) -> List[int]:\n    \"\"\"Return a list of nodes in an undirected graph sorted in topological order.\"\"\"\n    visited = set()\n    result = []\n\n    def dfs(node):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor)\n        result.append(node)\n\n    for node in range(len(graph)):\n        if node not in visited:\n            dfs(node)\n\n    return result[::-1]\n\nassert f(graph=[[1, 2], [3, 4], [5], [], [5], []]) == g(graph=[[1, 2], [3, 4], [5], [], [5], []])\n",
        "idx_generation": 406,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"Given a matrix of integers, return the flattened matrix in spiral order.\"\"\"\n    result = []\n    if not matrix:\n        return result\n    top = 0\n    bottom = len(matrix) - 1\n    left = 0\n    right = len(matrix[0]) - 1\n    direction = 0\n\n    while top <= bottom and left <= right:\n        if direction == 0:\n            for i in range(left, right + 1):\n                result.append(matrix[top][i])\n            top += 1\n        elif direction == 1:\n            for i in range(top, bottom + 1):\n                result.append(matrix[i][right])\n            right -= 1\n        elif direction == 2:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n        elif direction == 3:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n        direction = (direction + 1) % 4\n\n    return result\n\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 497,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of numbers is a permutation of [1, 2, 3, ..., n], where n is the length of the list.\"\"\"\n    n = len(nums)\n    return sorted(nums) == list(range(1, n + 1))\n\ndef g():\n    return [2, 4, 1, 3]\n\nassert f(g())\n",
        "idx_generation": 266,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if it is possible to obtain the target sum by adding or subtracting elements from the array.\n    You can use each element only once.\n    Sample input:\n    arr = [1, 2, 3, 4, 5]\n    target = 5\n    Sample output:\n    True\n    \"\"\"\n    def backtrack(index, current_sum):\n        if index == len(arr):\n            return current_sum == target\n        return backtrack(index + 1, current_sum + arr[index]) or backtrack(index + 1, current_sum - arr[index])\n    \n    return backtrack(0, 0)\n\ndef g():\n    return [1, 2, 3, 4, 5], 5\n\nassert f(*g())\n",
        "idx_generation": 55,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target=10) -> bool:\n    \"\"\"Find a subarray of arr whose sum is equal to target\"\"\"\n    n = len(arr)\n    for i in range(n):\n        curr_sum = arr[i]\n        j = i + 1\n        while j <= n:\n            if curr_sum == target:\n                return True\n            if curr_sum > target or j == n:\n                break\n            curr_sum += arr[j]\n            j += 1\n    return False\n\ndef g(target=10):\n    arr = [6, 2, 4, 7, 3, 1, 5]\n    return arr\n\nassert f(g())\n",
        "idx_generation": 48,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a subarray in the given list 'nums' whose sum equals the target value.\n    Return True if such a subarray exists, False otherwise.\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n    Output: True (because the subarray [2, 3, 4] has a sum of 9)\n    \"\"\"\n    left = 0\n    right = 0\n    curr_sum = 0\n    while right < len(nums):\n        curr_sum += nums[right]\n        while curr_sum > target:\n            curr_sum -= nums[left]\n            left += 1\n        if curr_sum == target:\n            return True\n        right += 1\n    return False\n\ndef g(nums: List[int]) -> int:\n    \"\"\"Find the target value for which a subarray with the given sum exists in the list 'nums'.\n    Return the target value.\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    Output: 9 (because the subarray [2, 3, 4] has a sum of 9)\n    \"\"\"\n    return sum(nums) // 2\n\nassert f(nums=[1, 2, 3, 4, 5], target=g(nums=[1, 2, 3, 4, 5]))\n",
        "idx_generation": 281,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine if n is a prime number.\n    Return True if n is prime, False otherwise.\"\"\"\n    \n    if n <= 1:\n        return False\n    \n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    \n    return True\n\ndef g(n=17):\n    return n\n\nassert f(g())\n",
        "idx_generation": 158,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum sum of a subsequence where the elements are in increasing order.\"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    \n    dp = [nums[i] for i in range(n)]\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + nums[i])\n    \n    return max(dp)\n\ndef g(nums: List[int] = [1, 101, 2, 3, 100, 4, 5]):\n    return nums\n\nassert f(g()) == 106\n",
        "idx_generation": 274,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find the two numbers in the list that sum up to the target.\n    Return the indices of the two numbers as a list.\n    If there are multiple valid solutions, return any one.\n    \n    Sample Input:\n    nums = [2, 7, 11, 15]\n    target = 9\n    \n    Sample Output:\n    [0, 1]\n    \"\"\"\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 494,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a subarray in a given array that sums up to the target value.\"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    for num in arr:\n        prefix_sum += num\n        if prefix_sum == target or prefix_sum - target in prefix_sums:\n            return True\n        prefix_sums.add(prefix_sum)\n    return False\n\ndef g(arr=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29], target=42):\n    \"\"\"Generate an array of integers and a target value.\"\"\"\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 166,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(expression: str) -> str:\n    \"\"\"Given a string of arithmetic expression in postfix notation, evaluate and return the result.\"\"\"\n    stack = []\n    \n    for char in expression:\n        if char.isdigit():\n            stack.append(int(char))\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            if char == '+':\n                stack.append(a + b)\n            elif char == '-':\n                stack.append(a - b)\n            elif char == '*':\n                stack.append(a * b)\n            elif char == '/':\n                stack.append(a / b)\n    \n    return str(stack[0])\n\ndef g():\n    expression = \"34+2*\"\n    \n    return expression\n\nassert f(g()) == \"14\"\n",
        "idx_generation": 165,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Count the number of unique paths from the top-left corner to the bottom-right corner of a grid, only moving right or down.\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] if grid[i][0] != 1 else 0\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] if grid[0][j] != 1 else 0\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] != 1:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[m-1][n-1]\n\ndef g():\n    return [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n\nassert f(g()) == 2\n",
        "idx_generation": 39,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the nth Fibonacci number using recursion and memoization.\n    \"\"\"\n    memo = {}\n    def fibonacci(n):\n        if n in memo:\n            return memo[n]\n        if n <= 2:\n            return 1\n        memo[n] = fibonacci(n - 1) + fibonacci(n - 2)\n        return memo[n]\n    \n    return fibonacci(n)\n\ndef g(n: int) -> int:\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    return n\n\nassert f(g(5)) == 5\n",
        "idx_generation": 281,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the sum of the diagonal elements in a square grid.\"\"\"\n    n = len(grid)\n    total = 0\n    for i in range(n):\n        total += grid[i][i]\n    return total\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 15\n",
        "idx_generation": 388,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the maximum area of a rectangle containing only 1s.\n    The rectangle can be formed by connecting adjacent 1s horizontally or vertically.\n    Return the maximum area.\n    \"\"\"\n    def max_rectangle_area(grid: List[List[int]]) -> int:\n        if not grid:\n            return 0\n        m, n = len(grid), len(grid[0])\n        heights = [0] * n\n        max_area = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 0:\n                    heights[j] = 0\n                else:\n                    heights[j] += 1\n            max_area = max(max_area, largest_rectangle_area(heights))\n        return max_area\n    \n    def largest_rectangle_area(heights: List[int]) -> int:\n        n = len(heights)\n        left, right = [0] * n, [0] * n\n        stack = []\n        for i in range(n):\n            while stack and heights[stack[-1]] >= heights[i]:\n                stack.pop()\n            left[i] = stack[-1] if stack else -1\n            stack.append(i)\n        stack = []\n        for i in range(n - 1, -1, -1):\n            while stack and heights[stack[-1]] >= heights[i]:\n                stack.pop()\n            right[i] = stack[-1] if stack else n\n            stack.append(i)\n        max_area = 0\n        for i in range(n):\n            max_area = max(max_area, heights[i] * (right[i] - left[i] - 1))\n        return max_area\n    \n    return max_rectangle_area(grid)\n\ndef g():\n    grid = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n    return grid\n\nassert f(g()) == 6\n\n",
        "idx_generation": 475,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]], target: int) -> Tuple[int, int]:\n    \"\"\"\n    Given a 2D grid of integers and a target value, find the coordinates of the first occurrence\n    of the target value in the grid. If the target value does not exist in the grid, return (-1, -1).\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == target:\n                return (i, j)\n    return (-1, -1)\n\ndef g() -> Tuple[List[List[int]], int]:\n    \"\"\"\n    Generate a random 2D grid of integers and a target value.\n    \"\"\"\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    target = 5\n    return (grid, target)\n\nassert f(*g()) == (1, 1)\n",
        "idx_generation": 252,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string, determine if it is a palindrome after removing at most one character.\n    Return True if the string is a palindrome or can be made a palindrome by removing at most one character, otherwise return False.\n    \"\"\"\n    def is_palindrome(s, i, j):\n        while i < j:\n            if s[i] != s[j]:\n                return False\n            i += 1\n            j -= 1\n        return True\n    \n    i, j = 0, len(s) - 1\n    while i < j:\n        if s[i] != s[j]:\n            return is_palindrome(s, i + 1, j) or is_palindrome(s, i, j - 1)\n        i += 1\n        j -= 1\n    \n    return True\n\ndef g():\n    return \"abcdeedcba\"\n\nassert f(g()) == True\n",
        "idx_generation": 84,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, count the number of set bits (1s) in its binary representation.\"\"\"\n    count = 0\n    \n    while n:\n        count += n & 1\n        n >>= 1\n    \n    return count\n\ndef g():\n    return 9\n\nassert f(g()) == 2\n",
        "idx_generation": 56,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine if a given number is a Fibonacci number.\"\"\"\n    def is_perfect_square(x):\n        return int(x**0.5)**2 == x\n\n    return is_perfect_square(5*n**2 + 4) or is_perfect_square(5*n**2 - 4)\n\ndef g(n: int) -> int:\n    a, b = 0, 1\n    while b < n:\n        a, b = b, a + b\n    return b\n\nassert f(g(13))\n",
        "idx_generation": 33,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"Check if the given string is a palindrome and if the given number is a perfect square.\"\"\"\n    is_palindrome = s == s[::-1]\n\n    is_perfect_square = n == int(n**0.5)**2\n\n    return is_palindrome and is_perfect_square\n\ndef g():\n    s = 'madam'\n    n = 16\n    return s, n\n\nassert f(*g())\n",
        "idx_generation": 162,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], source: int, target: int) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency matrix, determine if there is a path from source to target using depth-first search.\"\"\"\n    def dfs(graph, visited, node, target):\n        if node == target:\n            return True\n        visited[node] = True\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                if dfs(graph, visited, neighbor, target):\n                    return True\n        return False\n    \n    visited = [False] * len(graph)\n    return dfs(graph, visited, source, target)\n\ndef g(graph: List[List[int]], source: int, target: int) -> List[List[int]]:\n    \"\"\"Return the graph, source, and target\"\"\"\n    return graph, source, target\n\nassert f(*g(graph=[[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [0, 0, 0, 0]], source=0, target=3))\n",
        "idx_generation": 301,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, target: int) -> bool:\n    \"\"\"Check if there is a path from the start node to the target node in the given graph.\"\"\"\n    stack = [start]\n    visited = set()\n    while stack:\n        node = stack.pop()\n        if node == target:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g():\n    return [[1, 2], [3, 4], [5], [5], [2, 3], []], 0, 5\n\nassert f(*g())\n",
        "idx_generation": 79,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int, grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of size n x m filled with 0s and 1s, determine if there is a path from the top-left corner\n    to the bottom-right corner, where the path consists of only 1s and can only move down or right.\"\"\"\n    def dfs(i, j):\n        if i == n-1 and j == m-1:\n            return True\n        if i >= n or j >= m or grid[i][j] == 0:\n            return False\n        return dfs(i+1, j) or dfs(i, j+1)\n    \n    return dfs(0, 0)\n\ndef g(n=3, m=3, grid=[[1, 1, 0], [1, 0, 1], [1, 1, 1]]):\n    return n, m, grid\n\nassert f(*g())\n",
        "idx_generation": 81,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, target: int) -> bool:\n    \"\"\"Given a graph represented as an adjacency matrix, determine if there is a path from the start node to the target node.\n    Sample input:\n    graph = [[0, 1, 1, 0],\n             [0, 0, 1, 0],\n             [0, 0, 0, 1],\n             [0, 0, 0, 0]]\n    start = 0\n    target = 3\n    Sample output:\n    True\"\"\"\n    visited = set()\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n\n        if node == target:\n            return True\n\n        visited.add(node)\n\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] == 1 and neighbor not in visited:\n                stack.append(neighbor)\n    \n    return False\n\ndef g():\n    graph = [[0, 1, 1, 0],\n             [0, 0, 1, 0],\n             [0, 0, 0, 1],\n             [0, 0, 0, 0]]\n    start = 0\n    target = 3\n    return graph, start, target\n\nassert f(*g())\n",
        "idx_generation": 73,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of 0s and 1s, find the area of the largest island.\n    An island is a group of connected cells with value 1.\n    Return the area of the largest island.\"\"\"\n    m, n = len(grid), len(grid[0])\n    max_area = 0\n\n    def dfs(i, j):\n        if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != 1:\n            return 0\n\n        grid[i][j] = '#'\n        area = 1\n\n        area += dfs(i+1, j)\n        area += dfs(i-1, j)\n        area += dfs(i, j+1)\n        area += dfs(i, j-1)\n\n        return area\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                max_area = max(max_area, dfs(i, j))\n\n    return max_area\n\ndef g():\n    return [[1, 1, 0, 0, 0],\n            [1, 1, 0, 0, 0],\n            [0, 0, 0, 1, 1],\n            [0, 0, 0, 1, 1]]\n\nassert f(g()) == 4\n",
        "idx_generation": 451,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a subsequence of length 3 in the list such that the sum of the elements in the subsequence is equal to 0.\n    The goal is to find the values of the list 'arr' that satisfy this condition.\"\"\"\n    def find_subsequence(arr, start, target_sum, count):\n        if target_sum == 0 and count == 3:\n            return True\n        if start == len(arr) or count == 3:\n            return False\n        return find_subsequence(arr, start+1, target_sum-arr[start], count+1) or find_subsequence(arr, start+1, target_sum, count)\n    \n    return find_subsequence(arr, 0, 0, 0)\n\ndef g(arr: List[int]):\n    return arr\n\n# Example usage\nassert f(g([1, 2, -3, 4, 5, -2, 0]))\n",
        "idx_generation": 68,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, sort them in ascending order using the bubble sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    return nums\n\ndef g():\n    \"\"\"Find a list of numbers that satisfy the condition of the puzzle.\"\"\"\n    nums = [4, 2, 7, 1, 5]\n    return nums\n\nassert f(g()) == [1, 2, 4, 5, 7]\n",
        "idx_generation": 215,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if it is possible to find a non-empty subarray in the given array that sums up to the target value.\"\"\"\n    n = len(arr)\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + arr[i - 1]\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if prefix_sum[j] - prefix_sum[i] == target:\n                return True\n    return False\n\ndef g():\n    return [-2, 1, 5, 2, -3], 4\n\nassert f(*g())\n",
        "idx_generation": 28,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport heapq\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"Find the kth smallest element in a given list of integers.\"\"\"\n    return heapq.nsmallest(k, nums)[-1]\n\ndef g(nums=[4, 7, 2, 1, 9, 5], k=3):\n    return nums, k\n\nassert f(*g()) == 4\n",
        "idx_generation": 462,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a sorted list of integers, find the missing number in the sequence.\n    The list contains numbers from 1 to n, but one number is missing.\n    Return the missing number.\"\"\"\n    n = len(nums) + 1\n    total_sum = (n * (n + 1)) // 2\n    actual_sum = sum(nums)\n    return total_sum - actual_sum\n\ndef g():\n    return [1, 2, 3, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == 4\n",
        "idx_generation": 226,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the given array is a binary search tree.\"\"\"\n    def is_bst(node, min_val=float('-inf'), max_val=float('inf')):\n        if node is None:\n            return True\n        if node.val <= min_val or node.val >= max_val:\n            return False\n        return is_bst(node.left, min_val, node.val) and is_bst(node.right, node.val, max_val)\n\n    class Node:\n        def __init__(self, val=0, left=None, right=None):\n            self.val = val\n            self.left = left\n            self.right = right\n\n    def create_tree(arr):\n        if not arr:\n            return None\n        mid = len(arr) // 2\n        root = Node(arr[mid])\n        root.left = create_tree(arr[:mid])\n        root.right = create_tree(arr[mid+1:])\n        return root\n\n    tree = create_tree(arr)\n    return is_bst(tree)\n\ndef g():\n    arr = [1, 2, 3, 4, 5, 6, 7]\n    return arr\n\nassert f(g())\n",
        "idx_generation": 442,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of size m x n, where each cell contains a non-negative integer, find the minimum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right at each step.\"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[m-1][n-1]\n\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 462,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find the indices of two numbers in the given list that sum up to the target.\"\"\"\n    seen = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    \n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 293,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, nums: List[int]) -> bool:\n    \"\"\"Determine if the given list of integers can be divided into two subsets with equal sum.\"\"\"\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n    \n    target_sum = total_sum // 2\n    \n    dp = [[False] * (target_sum + 1) for _ in range(len(nums) + 1)]\n    \n    for i in range(len(nums) + 1):\n        dp[i][0] = True\n    \n    for i in range(1, len(nums) + 1):\n        for j in range(1, target_sum + 1):\n            if nums[i-1] <= j:\n                dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i-1]]\n            else:\n                dp[i][j] = dp[i-1][j]\n    \n    return dp[len(nums)][target_sum]\n\ndef g(nums: List[int]):\n    n = len(nums)\n    return n, nums\n\nassert f(*g([1, 5, 11, 5]))\n",
        "idx_generation": 63,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(pattern: str, s: str) -> bool:\n    \"\"\"Given a pattern and a string, determine if the string follows the same pattern.\n    Each character in the pattern represents a unique word in the string.\"\"\"\n    words = s.split()\n    if len(pattern) != len(words):\n        return False\n\n    pattern_mapping = {}\n    used_words = set()\n\n    for i, char in enumerate(pattern):\n        if char not in pattern_mapping:\n            if words[i] in used_words:\n                return False\n            pattern_mapping[char] = words[i]\n            used_words.add(words[i])\n        else:\n            if pattern_mapping[char] != words[i]:\n                return False\n\n    return True\n\ndef g():\n    return ('abba', 'dog cat cat dog')\n\nassert f(*g())\n",
        "idx_generation": 3,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, pattern='abab') -> bool:\n    \"\"\"Check if the given string follows the given pattern\"\"\"\n    pattern_dict = {}\n    words = s.split()\n    if len(pattern) != len(words):\n        return False\n    for i in range(len(words)):\n        if pattern[i] not in pattern_dict:\n            if words[i] in pattern_dict.values():\n                return False\n            pattern_dict[pattern[i]] = words[i]\n        else:\n            if pattern_dict[pattern[i]] != words[i]:\n                return False\n    return True\n\ndef g(pattern='abab'):\n    s = \"apple banana apple banana\"\n    return s\n\nassert f(g())\n",
        "idx_generation": 68,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=0) -> bool:\n    \"\"\"Find if there exists a subarray in nums that sums up to the target value.\"\"\"\n    stack = []\n    for num in nums:\n        stack.append(num)\n        while sum(stack) > target:\n            stack.pop(0)\n        if sum(stack) == target:\n            return True\n    return False\ndef g(target=0):\n    return [1, 2, 3, 4, 5]\nassert f(g())\n",
        "idx_generation": 281,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of integers, check if there exists a row or column that contains only prime numbers.\n    Return True if such a row or column exists, otherwise return False.\n    Sample input:\n    [[2, 3, 5],\n     [7, 11, 13],\n     [17, 19, 23]]\n    Sample output:\n    True\"\"\"\n    n = len(matrix)\n    m = len(matrix[0])\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]  # List of prime numbers\n    for row in matrix:\n        if all(num in primes for num in row):\n            return True\n    for j in range(m):\n        column = [matrix[i][j] for i in range(n)]\n        if all(num in primes for num in column):\n            return True\n    return False\n\ndef g():\n    return [[2, 3, 5],\n            [7, 11, 13],\n            [17, 19, 23]]\n\nassert f(g()) == True\n",
        "idx_generation": 171,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there is a subset of numbers in the list that can be XORed to the target value.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(target + 1):\n            if j < nums[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n\n    return dp[n][target]\n\n\ndef g(nums: List[int] = [3, 4, 5, 6, 7]):\n    return nums\n\n\nassert f(g(), 9)\n",
        "idx_generation": 285,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if it is possible to remove a single character from the string s to make it a palindrome.\"\"\"\n    def is_palindrome(s, left, right):\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n\n    left = 0\n    right = len(s) - 1\n\n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s, left + 1, right) or is_palindrome(s, left, right - 1)\n        left += 1\n        right -= 1\n\n    return True\n\ndef g():\n    s = \"abcdba\"\n    return s\n\nassert f(g())\n",
        "idx_generation": 498,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if there exists a subset of the list that sums up to the target value.\n    Return True if such subset exists, False otherwise.\"\"\"\n    n = len(arr)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    \n    for i in range(n + 1):\n        dp[i][0] = True\n    \n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j < arr[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n    \n    return dp[n][target]\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Generate a list of integers and a target value.\"\"\"\n    arr = [1, 5, 10, 15, 20]\n    target = 25\n    \n    return arr, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 177,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(numbers: List[int], target=10) -> bool:\n    \"\"\"Find a combination of numbers that add up to the target value.\"\"\"\n    stack = [(0, 0)]\n    while stack:\n        curr_sum, index = stack.pop()\n        if curr_sum == target:\n            return True\n        if index < len(numbers):\n            stack.append((curr_sum + numbers[index], index + 1))\n            stack.append((curr_sum, index + 1))\n    return False\n\ndef g(target=10):\n    return [1, 2, 3, 4, 5]\n\nassert f(g())\n",
        "idx_generation": 186,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the nth Fibonacci number using recursion.\n    The Fibonacci sequence starts with 0 and 1, and each subsequent number is the sum of the two preceding ones.\n    Return the nth Fibonacci number.\n    \"\"\"\n    if n <= 1:\n        return n\n    else:\n        return f(n-1) + f(n-2)\n\ndef g():\n    \"\"\"Returns the value of n for calculating the nth Fibonacci number.\"\"\"\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 43,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[List[int]], rows=5, cols=5) -> bool:\n    \"\"\"Given an array of size rows x cols, determine if it is possible to reach the bottom-right cell from the top-left cell.\n    Each cell contains a non-negative integer representing the maximum number of steps that can be taken from that cell.\n    You can only move right or down from a cell.\n    \"\"\"\n    visited = [[False] * cols for _ in range(rows)]\n    stack = [(0, 0)]\n    \n    while stack:\n        i, j = stack.pop()\n        visited[i][j] = True\n        \n        if i == rows-1 and j == cols-1:\n            return True\n        \n        if i+1 < rows and not visited[i+1][j] and arr[i+1][j] > 0:\n            stack.append((i+1, j))\n        \n        if j+1 < cols and not visited[i][j+1] and arr[i][j+1] > 0:\n            stack.append((i, j+1))\n            \n    return False\n\ndef g(rows=5, cols=5):\n    return [[1, 2, 3, 2, 1] for _ in range(rows)]\n\nassert f(g())\n",
        "idx_generation": 298,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"Given a 2D grid of integers, rotate the grid clockwise by 90 degrees.\n    The rotated grid should be returned as a new 2D grid.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    rotated_grid = [[0] * rows for _ in range(cols)]\n\n    for i in range(rows):\n        for j in range(cols):\n            rotated_grid[j][rows - i - 1] = grid[i][j]\n\n    return rotated_grid\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a 2D grid of integers.\"\"\"\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n    return grid\n\nassert f(g()) == [[7, 4, 1],\n                  [8, 5, 2],\n                  [9, 6, 3]]\n\n\n",
        "idx_generation": 403,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    The path can only move down or right.\n    Return the maximum sum as an integer.\"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    \n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n                \n    return dp[-1][-1]\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"Generate a grid of integers randomly.\"\"\"\n    return [[random.randint(1, 100) for _ in range(grid)] for _ in range(grid)]\n\nassert f(g(5)) >= 0\n",
        "idx_generation": 269,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string s is a palindrome after removing at most one character\"\"\"\n    def is_palindrome(s, left, right, removed):\n        while left < right:\n            if s[left] != s[right]:\n                if removed:\n                    return False\n                return is_palindrome(s, left + 1, right, True) or is_palindrome(s, left, right - 1, True)\n            left += 1\n            right -= 1\n        return True\n    \n    return is_palindrome(s, 0, len(s) - 1, False)\n\ndef g():\n    return ('racecar',)\n\nassert f(*g())\n",
        "idx_generation": 126,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Find if there is a subset of nums that adds up to the target value using bit manipulation.\"\"\"\n    n = len(nums)\n    for i in range(2**n):\n        subset_sum = sum([nums[j] for j in range(n) if (i & (1 << j))])\n        if subset_sum == target:\n            return True\n    return False\ndef g(nums=[2, 4, 6, 8]):\n    return nums\nassert f(g())\n",
        "idx_generation": 66,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k=3) -> bool:\n    \"\"\"Check if the given number n is a perfect power of k.\n    Return True if n is a perfect power of k, False otherwise.\"\"\"\n    if n <= 0:\n        return False\n\n    def is_perfect_power(x, k):\n        if x == 1:\n            return True\n        if x < k:\n            return False\n\n        for i in range(2, int(x ** 0.5) + 1):\n            if x % i == 0:\n                if i ** k == x:\n                    return True\n                else:\n                    return is_perfect_power(x // i, k)\n        return False\n\n    return is_perfect_power(n, k)\n\ndef g(n: int, k=3):\n    return f(n, k)\n\nassert f(g(27))\n",
        "idx_generation": 33,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target_length=0, target_prefix='', target_suffix='') -> bool:\n    \"\"\"Find a string that has a length of target_length, starts with target_prefix, and ends with target_suffix.\"\"\"\n    return len(s) == target_length and s.startswith(target_prefix) and s.endswith(target_suffix)\ndef g(target_length=0, target_prefix='', target_suffix=''):\n    prefix_length = len(target_prefix)\n    suffix_length = len(target_suffix)\n    remaining_length = target_length - prefix_length - suffix_length\n    return target_prefix + '?' * remaining_length + target_suffix\nassert f(g())\n",
        "idx_generation": 211,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int, g: List[List[int]]) -> bool:\n    \"\"\"Given a list of integers representing a graph, with each integer representing a node, check if it is possible to color the nodes using k colors such that no two adjacent nodes have the same color.\n    Example:\n    n = 4\n    k = 3\n    g = [[1, 2], [2, 3], [3, 4], [4, 1]]\n    Output: True\"\"\"\n    colors = [-1] * n\n    colors[0] = 0\n\n    for i in range(1, n):\n        available_colors = set(range(k))\n        for j in g[i]:\n            if colors[j-1] != -1:\n                available_colors.discard(colors[j-1])\n        if len(available_colors) == 0:\n            return False\n        colors[i] = min(available_colors)\n    return True\n\ndef g():\n    n = 4\n    k = 3\n    g = [[1, 2], [2, 3], [3, 4], [4, 1]]\n    return n, k, g\n\nassert f(*g())\n",
        "idx_generation": 306,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: List[List[int]], source=0, destination=3) -> bool:\n    \"\"\"Find if there is a path from the source node to the destination node in the given directed graph.\"\"\"\n    visited = [False] * len(graph)\n    stack = [source]\n    while stack:\n        node = stack.pop()\n        if node == destination:\n            return True\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                stack.append(neighbor)\n    return False\ndef g(source=0, destination=3):\n    return [[1, 2], [3], [], []]\nassert f(g())\n",
        "idx_generation": 82,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the shortest path from the top-left corner to the bottom-right corner in the given grid.\"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(m):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j])\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j])\n    return dp[m-1][n-1]\n\ndef g():\n    \"\"\"Find a grid such that the function f returns the shortest path sum of 7.\"\"\"\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 7\n",
        "idx_generation": 91,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency list and two nodes, determine if there exists a path from the start node to the end node.\n    Sample input:\n    graph = {'A': ['B', 'C'], 'B': ['C', 'D'], 'C': ['D'], 'D': []}\n    start = 'A'\n    end = 'D'\n    Sample output:\n    True\n    \"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g():\n    graph = {'A': ['B', 'C'], 'B': ['C', 'D'], 'C': ['D'], 'D': []}\n    start = 'A'\n    end = 'D'\n    return graph, start, end\n\nassert f(*g())\n",
        "idx_generation": 97,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the number of unique paths from the top-left corner to the bottom-right corner in a grid.\"\"\"\n    m = len(nums)\n    n = len(nums[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1\n\n    for i in range(1, m):\n        dp[i][0] = 1\n\n    for j in range(1, n):\n        dp[0][j] = 1\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[m-1][n-1]\n\ndef g():\n    nums = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 458,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Determine if it is possible to arrange n numbers such that the absolute difference between each pair of adjacent numbers is exactly k.\"\"\"\n    if n <= 0 or k < 0:\n        return False\n    elif k == 0:\n        return True\n    elif n < 2:\n        return False\n    elif k > n - 1:\n        return False\n    elif k == n - 1:\n        return True\n    else:\n        return f(n - 1, k) or f(n - 1, k - 1)\n\ndef g():\n    return [5, 2]\n\nassert f(*g())\n",
        "idx_generation": 69,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(li: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers 'li' and a target value 'target', return True if there are two distinct elements in the list that sum up to the target value, and False otherwise.\n    Sample input:\n    li = [1, 3, 5, 7, 9]\n    target = 12\n    Sample output:\n    True\n    Explanation: The sum of 3 and 9 is equal to the target value 12.\n    \"\"\"\n    left = 0\n    right = len(li) - 1\n\n    while left < right:\n        current_sum = li[left] + li[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    li = [1, 3, 5, 7, 9]\n    target = 12\n    return li, target\n\nassert f(*g())\n",
        "idx_generation": 3,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]], target: int) -> int:\n    \"\"\"Given a sorted matrix and a target number, find the number of occurrences of the target in the matrix.\n    The matrix is sorted in ascending order from left to right and top to bottom.\n    Return the count of occurrences of the target in the matrix.\n    \"\"\"\n    count = 0\n    rows = len(matrix)\n    cols = len(matrix[0])\n    row = 0\n    col = cols - 1\n\n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            count += 1\n            col -= 1\n        elif matrix[row][col] > target:\n            col -= 1\n        else:\n            row += 1\n\n    return count\n\ndef g(matrix: List[List[int]], target: int):\n    return matrix, target\n\nassert f(*g([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 5))\n",
        "idx_generation": 218,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\n    Return True if there are two such numbers, otherwise return False.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        current_sum = arr[left] + arr[right]\n        \n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), 12) == True\n",
        "idx_generation": 36,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers 'nums' and a target value, find the length of the shortest subarray that has a sum greater than or equal to the target value.\n    Use the sliding window technique to solve this problem.\"\"\"\n    start = 0\n    min_length = float('inf')\n    current_sum = 0\n    for end in range(len(nums)):\n        current_sum += nums[end]\n        while current_sum >= target:\n            min_length = min(min_length, end - start + 1)\n            current_sum -= nums[start]\n            start += 1\n    return min_length\n\ndef g():\n    return [2, 3, 1, 2, 4, 3], 7\n\nassert f(*g()) == 2\n",
        "idx_generation": 496,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two distinct indices i and j in the list such that nums[i] + nums[j] equals to the target value.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5], target=7):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 277,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef is_binary_search_tree(root: Node) -> bool:\n    def helper(node: Node, min_value: int, max_value: int) -> bool:\n        if node is None:\n            return True\n        if node.value <= min_value or node.value >= max_value:\n            return False\n        return helper(node.left, min_value, node.value) and helper(node.right, node.value, max_value)\n\n    return helper(root, float('-inf'), float('inf'))\n\ndef f(values: List[int]) -> bool:\n    \"\"\"Check if the given list of values represent a valid binary search tree\"\"\"\n    root = Node(values[0])\n    for value in values[1:]:\n        current = root\n        while True:\n            if value < current.value:\n                if current.left is None:\n                    current.left = Node(value)\n                    break\n                else:\n                    current = current.left\n            else:\n                if current.right is None:\n                    current.right = Node(value)\n                    break\n                else:\n                    current = current.right\n\n    return is_binary_search_tree(root)\n\ndef g():\n    return [4, 2, 6, 1, 3, 5, 7]\n\nassert f(g())\n",
        "idx_generation": 482,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], k=3) -> bool:\n    \"\"\"Given a list of integers and a value k, determine if there exists a subsequence of length k such that the sum of the\n    subsequence is divisible by k. Return True if such a subsequence exists, False otherwise.\"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(i+1, n):\n            for l in range(j+1, n):\n                if (nums[i] + nums[j] + nums[l]) % k == 0:\n                    return True\n    return False\n\ndef g(nums: List[int]):\n    \"\"\"Return the list of numbers in non-decreasing order.\"\"\"\n    return sorted(nums)\n\nassert f(g([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n",
        "idx_generation": 305,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers, check if there exists a subset of the list that sums up to the target.\n    Return True if such a subset exists, otherwise return False.\"\"\"\n    dp = [False] * (target + 1)\n    dp[0] = True\n    for num in nums:\n        for i in range(target, num-1, -1):\n            dp[i] = dp[i] or dp[i - num]\n    return dp[target]\n\ndef g():\n    nums = [1, 4, 5, 7, 9, 12]\n    target = 16\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 83,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Given a string s and an integer k, determine if it is possible to rearrange the characters in s\n    such that no two adjacent characters are the same and the resulting string has at least k unique characters.\n    Return True if it is possible, False otherwise.\n    Example:\n    s = \"aabbc\"\n    k = 3\n    The possible rearrangements are \"abcab\", \"acbac\", \"bacab\", \"bcaba\", \"cabac\", \"cbaba\".\n    All of these rearrangements have at least 3 unique characters and no adjacent characters are the same.\n    Therefore, the answer is True.\n    \"\"\"\n    frequency = {}\n    for char in s:\n        frequency[char] = frequency.get(char, 0) + 1\n    sorted_chars = sorted(frequency.keys(), key=lambda x: frequency[x], reverse=True)\n    unique_chars = len(sorted_chars)\n    if unique_chars < k:\n        return False\n    max_count = frequency[sorted_chars[0]]\n    if max_count > (len(s) + 1) // 2:\n        return False\n    return True\ndef g():\n    return \"aabbc\", 3\nassert f(*g())\n",
        "idx_generation": 24,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(pattern: str, word: str) -> bool:\n    \"\"\"Given a pattern string and a word string, determine if the word follows the same pattern as the given pattern.\n    The pattern consists of lowercase English letters and the word consists of lowercase English letters separated by a space.\"\"\"\n    pattern_mapping = {}\n    word_mapping = {}\n    words = word.split()\n    \n    if len(pattern) != len(words):\n        return False\n    \n    for i in range(len(pattern)):\n        if pattern[i] not in pattern_mapping:\n            pattern_mapping[pattern[i]] = words[i]\n        else:\n            if pattern_mapping[pattern[i]] != words[i]:\n                return False\n        \n        if words[i] not in word_mapping:\n            word_mapping[words[i]] = pattern[i]\n        else:\n            if word_mapping[words[i]] != pattern[i]:\n                return False\n    \n    return True\n\ndef g(pattern=\"abba\", word=\"dog cat cat dog\"):\n    return pattern, word\n\nassert f(*g())\n",
        "idx_generation": 102,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with all duplicates removed.\n    The order of the elements should be preserved.\n    \"\"\"\n    unique_nums = []\n    num_set = set()\n    \n    for num in nums:\n        if num not in num_set:\n            unique_nums.append(num)\n            num_set.add(num)\n    \n    return unique_nums\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers with duplicates.\n    \"\"\"\n    return [1, 2, 3, 2, 4, 1, 5]\n\nassert f(g()) == [1, 2, 3, 4, 5]\n\n",
        "idx_generation": 315,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a pair of numbers in the list\n    whose sum is a perfect square.\n    \n    Return True if such a pair exists, False otherwise.\n    \"\"\"\n    squares = set()\n    for num in nums:\n        square = int(num**0.5)\n        if square**2 == num:\n            return True\n        squares.add(num)\n    for num in nums:\n        for square in squares:\n            if (num - square) in squares:\n                return True\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g())\n",
        "idx_generation": 180,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"Check if there exists a subarray of length k in the array arr, such that the sum of the subarray is divisible by k\"\"\"\n    n = len(arr)\n    if k > n:\n        return False\n\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = (prefix_sum[i - 1] + arr[i - 1]) % k\n\n    remainder_count = {}\n    for i in range(n + 1):\n        if prefix_sum[i] in remainder_count:\n            if i - remainder_count[prefix_sum[i]] >= k:\n                return True\n        else:\n            remainder_count[prefix_sum[i]] = i\n\n    return False\n\ndef g(arr: List[int], k: int) -> List[int]:\n    \"\"\"Generate an array with elements that satisfy the condition for f\"\"\"\n    return arr + [k] * (k - 1)\n\nassert f(g([1, 2, 3, 4, 5], 7), 7)\n",
        "idx_generation": 319,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that sum up to the target.\n    Return the indices of the two numbers in a list.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n    \ndef g(nums=[2, 7, 11, 15], target=9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 184,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s consisting of parentheses, brackets, and braces, determine if the string is balanced.\n    A string is considered balanced if each opening symbol has a corresponding closing symbol of the same type,\n    and the pairs of parentheses, brackets, and braces are properly nested.\n    Return True if the string is balanced, False otherwise.\n    \"\"\"\n    stack = []\n    opening = ['(', '[', '{']\n    closing = [')', ']', '}']\n    for char in s:\n        if char in opening:\n            stack.append(char)\n        elif char in closing:\n            if not stack:\n                return False\n            if opening.index(stack.pop()) != closing.index(char):\n                return False\n    return len(stack) == 0\n\ndef g():\n    return \"{[()]}\"\n    \nassert f(g()) == True\n",
        "idx_generation": 219,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int, k: int) -> bool:\n    \"\"\"Given an array of integers, determine if there exists a subset of the array with a sum equal to the target,\n    and the length of the subset is exactly k. Return True if such a subset exists, otherwise return False.\"\"\"\n    def subset_sum(arr, target, k):\n        if target == 0 and k == 0:\n            return True\n        if target != 0 and k == 0:\n            return False\n        if len(arr) == 0:\n            return False\n        \n        if arr[0] > target:\n            return subset_sum(arr[1:], target, k)\n        \n        return subset_sum(arr[1:], target-arr[0], k-1) or subset_sum(arr[1:], target, k)\n    \n    return subset_sum(arr, target, k)\n\ndef g(arr: List[int], target: int, k: int) -> List[int]:\n    \"\"\"Given an array of integers, find a subset of the array with a sum equal to the target,\n    and the length of the subset is exactly k. Return the subset as a list of integers.\"\"\"\n    def subset_sum(arr, target, k, subset):\n        if target == 0 and k == 0:\n            return subset\n        if target != 0 and k == 0:\n            return None\n        if len(arr) == 0:\n            return None\n        \n        if arr[0] > target:\n            return subset_sum(arr[1:], target, k, subset)\n        \n        include = subset_sum(arr[1:], target-arr[0], k-1, subset + [arr[0]])\n        if include:\n            return include\n        \n        exclude = subset_sum(arr[1:], target, k, subset)\n        if exclude:\n            return exclude\n        \n        return None\n    \n    return subset_sum(arr, target, k, [])\n\narr = [2, 4, 6, 8, 10]\ntarget = 20\nk = 3\nassert f(g(arr, target, k), target, k)\n",
        "idx_generation": 49,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport itertools\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum sum that can be obtained by selecting a subsequence from the given list of numbers, where no two elements are adjacent.\"\"\"\n    if not nums:\n        return 0\n    \n    n = len(nums)\n    if n == 1:\n        return nums[0]\n    \n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    \n    for i in range(2, n):\n        dp[i] = max(nums[i] + dp[i-2], dp[i-1])\n    \n    return dp[-1]\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7]\n\nassert f(g()) == 16\n",
        "idx_generation": 302,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"Given two integers n and m, find the number of distinct paths from the top-left corner to the bottom-right corner of an n x m grid.\n    You can only move down or right.\n    Return the number of distinct paths.\n    \"\"\"\n    dp = [[0] * m for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][0] = 1\n    \n    for j in range(m):\n        dp[0][j] = 1\n    \n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    \n    return dp[n - 1][m - 1]\n\ndef g() -> Tuple[int, int]:\n    \"\"\"Generate two random integers n and m.\"\"\"\n    n = 4\n    m = 5\n    \n    return n, m\n\nassert f(*g()) == 35\n",
        "idx_generation": 284,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a valid palindrome after removing at most one character.\n    \"\"\"\n    def is_palindrome(s, left, right):\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n    \n    left = 0\n    right = len(string) - 1\n    \n    while left < right:\n        if string[left] != string[right]:\n            return is_palindrome(string, left + 1, right) or is_palindrome(string, left, right - 1)\n        left += 1\n        right -= 1\n    \n    return True\n\ndef g():\n    \"\"\"\n    Generate a string that is a valid palindrome after removing at most one character.\n    \"\"\"\n    string = \"abccba\"\n    \n    return string\n\nassert f(g())\n",
        "idx_generation": 129,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Given a list of integers, find a subset whose sum is equal to the target\"\"\"\n    n = len(nums)\n    \n    # Generate all possible subsets\n    subsets = []\n    for i in range(2**n):\n        subset = []\n        for j in range(n):\n            if (i >> j) & 1:\n                subset.append(nums[j])\n        subsets.append(subset)\n    \n    # Check if any subset has a sum equal to the target\n    for subset in subsets:\n        if sum(subset) == target:\n            return True\n    \n    return False\n\ndef g(target=10):\n    return [1, 2, 3, 4, 5]\n\nassert f(g())\n",
        "idx_generation": 73,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers nums, return True if it can be partitioned into two subsets such that the sum of\n    elements in both subsets is equal, and False otherwise.\n    Example:\n    nums = [1, 5, 11, 5]\n    The list can be partitioned into [1, 5, 5] and [11], where the sum of both subsets is 11.\n    Therefore, the function should return True.\n    \"\"\"\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in nums:\n        for i in range(target_sum, num - 1, -1):\n            dp[i] = dp[i] or dp[i - num]\n    return dp[target_sum]\n\ndef g():\n    return [1, 5, 11, 5]\n\nassert f(g()) == True\n",
        "idx_generation": 35,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, sub: str, k: int) -> bool:\n    \"\"\"Determine if it is possible to form the string s by repeating the substring sub exactly k times.\"\"\"\n    return s == (sub * k)\n\ndef g(sub: str, k: int) -> str:\n    \"\"\"Generate a string by repeating the substring sub exactly k times.\"\"\"\n    return sub * k\n\nassert f(g(sub='abc', k=3), sub='abc', k=3)\n",
        "idx_generation": 276,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, g: List[List[int]]) -> bool:\n    \"\"\"Given a list of integers representing a graph, with each integer representing a node, check if it is possible to visit all nodes starting from node 1 and returning to node 1, while visiting each node exactly once, and traversing each edge of the graph exactly twice.\n    Example:\n    n = 4\n    g = [[1, 2], [2, 3], [3, 4], [4, 1]]\n    Output: True\"\"\"\n    degree = [0] * (n + 1)\n    for edge in g:\n        u, v = edge\n        degree[u] += 1\n        degree[v] += 1\n\n    for d in degree:\n        if d % 2 != 0:\n            return False\n\n    return True\n\ndef g():\n    n = 4\n    g = [[1, 2], [2, 3], [3, 4], [4, 1]]\n    return n, g\n\nassert f(*g())\n",
        "idx_generation": 306,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Find if there is a path from the start node to the end node in the given graph.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g(graph: List[List[int]], start: int, end: int):\n    return graph\n\ngraph = [[1, 2], [3, 4], [5], [6, 7], [8, 9], [], [10, 11], [], [], [], [12], []]\nstart = 0\nend = 12\nassert f(g(graph, start, end), start, end)\n",
        "idx_generation": 91,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"Given an adjacency matrix of a directed graph, determine if the graph contains a cycle.\"\"\"\n    def has_cycle_helper(node: int, visited: List[bool], recursion_stack: List[bool]) -> bool:\n        visited[node] = True\n        recursion_stack[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if has_cycle_helper(neighbor, visited, recursion_stack):\n                    return True\n            elif recursion_stack[neighbor]:\n                return True\n        recursion_stack[node] = False\n        return False\n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n    recursion_stack = [False] * num_nodes\n    for node in range(num_nodes):\n        if not visited[node]:\n            if has_cycle_helper(node, visited, recursion_stack):\n                return True\n    return False\ndef g():\n    return [[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [1, 0, 0, 0]]\nassert f(g()) == True\n",
        "idx_generation": 93,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]]) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency list, determine if it contains a cycle.\n    Sample input:\n    graph = {'A': ['B', 'C'], 'B': ['C', 'D'], 'C': ['D'], 'D': []}\n    Sample output:\n    False\n    \"\"\"\n    visited = set()\n    stack = list(graph.keys())\n    while stack:\n        node = stack.pop()\n        if node in visited:\n            return True\n        visited.add(node)\n        stack.extend(graph[node])\n    return False\n\ndef g():\n    graph = {'A': ['B', 'C'], 'B': ['C', 'D'], 'C': ['D'], 'D': []}\n    return graph\n\nassert f(g())\n",
        "idx_generation": 97,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Find the sum of all numbers that are surrounded by the same number in a matrix.\n    A number is considered surrounded by the same number if all its adjacent cells (up, down, left, right) have the same value.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    visited = [[False] * cols for _ in range(rows)]\n    total = 0\n    \n    def dfs(row, col, value):\n        if row < 0 or row >= rows or col < 0 or col >= cols:\n            return\n        \n        if visited[row][col]:\n            return\n        \n        visited[row][col] = True\n        \n        if matrix[row][col] != value:\n            return\n        \n        if (row - 1 >= 0 and matrix[row - 1][col] == value) and \\\n            (row + 1 < rows and matrix[row + 1][col] == value) and \\\n            (col - 1 >= 0 and matrix[row][col - 1] == value) and \\\n            (col + 1 < cols and matrix[row][col + 1] == value):\n            nonlocal total\n            total += matrix[row][col]\n        \n        dfs(row - 1, col, value)\n        dfs(row + 1, col, value)\n        dfs(row, col - 1, value)\n        dfs(row, col + 1, value)\n    \n    for i in range(rows):\n        for j in range(cols):\n            if not visited[i][j]:\n                dfs(i, j, matrix[i][j])\n    \n    return total\n\ndef g():\n    \"\"\"Generate a 3x3 matrix with random numbers.\"\"\"\n    import random\n    return [[random.randint(1, 3) for _ in range(3)] for _ in range(3)]\n\nassert f(g()) == 0\n",
        "idx_generation": 489,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given an integer n, count the number of valid parentheses expressions with n pairs of parentheses.\"\"\"\n    if n == 0:\n        return 1\n    \n    count = 0\n    for i in range(n):\n        count += f(i) * f(n-i-1)\n        \n    return count\n\ndef g(n=3):\n    return n\n\nassert f(g()) == 5\n",
        "idx_generation": 84,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a subsequence of length 3 where the sum of the first two numbers equals the third number.\n    The goal is to find a subsequence that satisfies the condition.\"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(i+1, n):\n            target = nums[i] + nums[j]\n            if target in nums:\n                return True\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g())\n",
        "idx_generation": 3,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, find the index of the target element using binary search.\n    If the target element is not found, return False.\n    If the target element is found, return True.\n    \"\"\"\n    low = 0\n    high = len(nums) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False\n\ndef g():\n    return [1, 3, 5, 7, 9], 6\n\nassert f(*g()) == False\n",
        "idx_generation": 238,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there exists two numbers in the list that sum up to the target value.\"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), 15)\n",
        "idx_generation": 44,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers in the list that add up to a given target.\n    Return True if such two numbers exist, otherwise return False.\n    Sample input:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    target = 13\n    Sample output:\n    True\"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    return ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 13)\n\nassert f(*g()) == True\n\n",
        "idx_generation": 296,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find two numbers in a given list that sum up to the target value.\"\"\"\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    \n    return []\n\ndef g():\n    return [[2, 7, 11, 15], 9]\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 335,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"Determine if there exists a subarray of length k in the given array whose sum is divisible by k.\"\"\"\n    prefix_sum = [0] * (len(arr) + 1)\n    for i in range(1, len(arr) + 1):\n        prefix_sum[i] = (prefix_sum[i-1] + arr[i-1]) % k\n    \n    remainder_count = [0] * k\n    for i in range(len(prefix_sum)):\n        remainder_count[prefix_sum[i]] += 1\n    \n    for count in remainder_count:\n        if count >= 2:\n            return True\n    \n    return False\n\ndef g(arr=[1, 2, 3, 4, 5], k=3):\n    return arr, k\n\nassert f(*g())\n",
        "idx_generation": 102,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import itertools\nfrom typing import*\nfrom itertools import permutations\n\ndef f(words: List[str]) -> bool:\n    \"\"\"Given a list of words, determine if there exists a permutation of the words such that each word's last character\n    matches the next word's first character. Return True if such a permutation exists, False otherwise.\"\"\"\n    for perm in permutations(words):\n        if all(perm[i][-1] == perm[i+1][0] for i in range(len(perm)-1)):\n            return True\n    return False\n\ndef g(words: List[str]):\n    \"\"\"Return the list of words in alphabetical order.\"\"\"\n    return sorted(words)\n\nassert f(g(['apple', 'egg', 'goat', 'tiger', 'rabbit']))\n",
        "idx_generation": 35,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import itertools\nfrom typing import*\nfrom itertools import permutations\n\ndef f(words: List[str], n=2) -> bool:\n    \"\"\"Given a list of words, find all possible combinations of n words that form a palindrome.\n    Return True if at least one combination exists, otherwise return False.\n    \"\"\"\n    def is_palindrome(word):\n        return word == word[::-1]\n    \n    for combo in permutations(words, n):\n        if all(is_palindrome(word) for word in combo):\n            return True\n    return False\n\ndef g(n=2):\n    return ['racecar', 'level', 'deed', 'noon', 'radar']\n\nassert f(g())\n",
        "idx_generation": 145,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers 'arr' and an integer 'n', determine if there exists a subarray whose sum is equal to 'n'.\n    Return True if such a subarray exists, otherwise return False.\n    \"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    \n    for num in arr:\n        prefix_sum += num\n        \n        if prefix_sum == n or prefix_sum - n in prefix_sums:\n            return True\n        \n        prefix_sums.add(prefix_sum)\n    \n    return False\n\n\ndef g() -> tuple:\n    arr = [1, 2, 3, 4, 5]\n    n = 9\n    return n, arr\n\n\nassert f(*g())\n",
        "idx_generation": 328,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of prime numbers less than a non-negative number n.\"\"\"\n    if n < 2:\n        return 0\n    \n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(n**0.5)+1):\n        if is_prime[i]:\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    return sum(is_prime)\n\ndef g():\n    return 20\n\nassert f(g()) == 8\n",
        "idx_generation": 187,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if there exists a subarray of length k whose sum is divisible by k\"\"\"\n    k = len(nums)\n    prefix_sum = [0] * (k + 1)\n    for i in range(1, k + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]\n    for i in range(k):\n        for j in range(i + 1, k + 1):\n            if (prefix_sum[j] - prefix_sum[i]) % k == 0:\n                return True\n    return False\n\ndef g(k=3, nums=[1, 2, 3, 4, 5, 6, 7, 8, 9]):\n    return nums[:k]\n\nassert f(g())\n",
        "idx_generation": 351,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a subset of the list that adds up to the target sum.\n    Return True if such a subset exists, otherwise return False.\"\"\"\n    dp = [[False] * (target + 1) for _ in range(len(nums) + 1)]\n    dp[0][0] = True\n\n    for i in range(1, len(nums) + 1):\n        dp[i][0] = True\n\n    for i in range(1, len(nums) + 1):\n        for j in range(1, target + 1):\n            if j < nums[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n\n    return dp[len(nums)][target]\n\ndef g(nums: List[int], target: int):\n    return nums, target\n\nassert f(*g([1, 2, 3, 4, 5], 9))\n\n",
        "idx_generation": 199,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\ndef f(expression: str) -> bool:\n    \"\"\"Given a string representing a mathematical expression, return True if the parentheses in the expression are balanced,\n    False otherwise.\n    \"\"\"\n    stack = []\n    \n    for char in expression:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    \n    return len(stack) == 0\n\ndef g():\n    expression = \"(3 + 4) * (2 - 1)\"\n    return expression\n\nassert f(g()) == True\n",
        "idx_generation": 230,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target=10) -> bool:\n    \"\"\"Return True if there exists a subset of the given array that sums up to the target value\"\"\"\n    n = len(arr)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j < arr[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n    return dp[n][target]\ndef g(arr=[2, 4, 6, 8]):\n    return arr\nassert f(g())\n",
        "idx_generation": 50,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(words: List[str], target_word: str) -> bool:\n    \"\"\"Given a list of words and a target word, determine if the target word can be formed by concatenating\n    any number of words from the list in any order. Return True if it is possible, False otherwise.\"\"\"\n    word_set = set(words)\n    memo = {}\n\n    def can_form_word(word):\n        if word in memo:\n            return memo[word]\n        \n        if word in word_set:\n            memo[word] = True\n            return True\n        \n        for i in range(1, len(word)):\n            prefix = word[:i]\n            suffix = word[i:]\n            if prefix in word_set and can_form_word(suffix):\n                memo[word] = True\n                return True\n        \n        memo[word] = False\n        return False\n\n    return can_form_word(target_word)\n\ndef g():\n    words = ['apple', 'banana', 'pear', 'lemon']\n    target_word = 'applebanana'\n    return words, target_word\n\nassert f(*g())\n",
        "idx_generation": 327,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of 0s and 1s, determine if it is possible to reach the bottom-right corner from the top-left corner,\n    moving only downwards or to the right. Additionally, you can flip the values of any cell (from 0 to 1 or from 1 to 0)\n    at most once during the path. Return True if it is possible, False otherwise.\"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    flipped = False\n\n    def dfs(i, j):\n        nonlocal flipped\n        if i == m-1 and j == n-1:\n            return True\n        if i >= m or j >= n or grid[i][j] == -1:\n            return False\n        \n        if grid[i][j] == 1 and not flipped:\n            flipped = True\n            grid[i][j] = 0\n        elif grid[i][j] == 0 and not flipped:\n            flipped = True\n            grid[i][j] = 1\n\n        return dfs(i+1, j) or dfs(i, j+1)\n    \n    return dfs(0, 0)\n\ndef g():\n    return [[0, 1, 0], [0, 1, 1], [0, 0, 0]]\n\nassert f(g()) == True\n\n",
        "idx_generation": 295,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string 's', reverse the words in the string.\n    Return the reversed string.\n    \"\"\"\n    words = s.split()\n    reversed_words = ' '.join(words[::-1])\n    return reversed_words\n\ndef g():\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    s = \"Hello World\"\n    \n    return s\n\nassert f(g()) == \"World Hello\"\n",
        "idx_generation": 158,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, find the maximum XOR value between any two numbers in the list\"\"\"\n    max_xor = 0\n    \n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n    \n    return max_xor\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 7\n",
        "idx_generation": 73,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of integers contains a subsequence that sums up to zero.\n    Sample input:\n    [4, -2, 3, 1, 2, -3, -1]\n    Sample output:\n    True\"\"\"\n    def helper(nums, target, idx, memo):\n        if target == 0:\n            return True\n        if idx == len(nums):\n            return False\n        if (target, idx) in memo:\n            return memo[(target, idx)]\n        include = helper(nums, target - nums[idx], idx + 1, memo)\n        exclude = helper(nums, target, idx + 1, memo)\n        memo[(target, idx)] = include or exclude\n        return memo[(target, idx)]\n    \n    return helper(nums, 0, 0, {})\n\ndef g():\n    return [4, -2, 3, 1, 2, -3, -1]\n\nassert f(g())\n",
        "idx_generation": 37,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k=3, n=5) -> bool:\n    \"\"\"Find if a string can be formed by concatenating k copies of a substring of length n\"\"\"\n    if len(s) % (n * k) != 0:\n        return False\n    substring = s[:n]\n    return substring * k == s\ndef g(k=3, n=5):\n    substring = 'abcde'\n    return substring * k\nassert f(g())\n",
        "idx_generation": 288,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency matrix, determine if there is a path from start to end.\"\"\"\n    visited = set()\n    stack = [start]\n    \n    while stack:\n        node = stack.pop()\n        visited.add(node)\n        \n        if node == end:\n            return True\n        \n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    \n    return False\n\ndef g():\n    graph = [[1, 2, 3], \n             [2, 3], \n             [3, 4], \n             [4]]\n    return graph\n\nassert f(g(), 0, 4) == True\n",
        "idx_generation": 307,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there exists a path from the start node to the end node in a given directed graph.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        visited.add(node)\n        if node == end:\n            return True\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    return False\n\ndef g():\n    graph = [[1, 2], [3], [4], [], [5], []]\n    start = 0\n    end = 5\n    return graph, start, end\n\nassert f(*g())\n",
        "idx_generation": 106,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency matrix and two nodes start and end,\n    determine if there is a path from start to end in the graph.\n    Return True if a path exists, False otherwise.\n    Example:\n    graph = [[0, 1, 0, 0, 0],\n             [0, 0, 1, 0, 0],\n             [0, 0, 0, 1, 0],\n             [0, 0, 0, 0, 1],\n             [0, 0, 0, 0, 0]]\n    start = 0\n    end = 4\n    There is a path from node 0 to node 4 in the graph, so the answer is True.\n    \"\"\"\n    visited = [False] * len(graph)\n    return dfs(graph, start, end, visited)\n\ndef dfs(graph: List[List[int]], current: int, end: int, visited: List[bool]) -> bool:\n    if current == end:\n        return True\n    visited[current] = True\n    for neighbor in range(len(graph)):\n        if graph[current][neighbor] == 1 and not visited[neighbor]:\n            if dfs(graph, neighbor, end, visited):\n                return True\n    return False\n\ndef g():\n    graph = [[0, 1, 0, 0, 0],\n             [0, 0, 1, 0, 0],\n             [0, 0, 0, 1, 0],\n             [0, 0, 0, 0, 1],\n             [0, 0, 0, 0, 0]]\n    start = 0\n    end = 4\n    return graph, start, end\n\nassert f(*g())\n",
        "idx_generation": 98,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there is a path from the start node to the end node in the given graph.\n    Return True if there is a path, and False otherwise.\"\"\"\n    \n    def dfs(graph: List[List[int]], curr_node: int, visited: List[bool]) -> bool:\n        \"\"\"Depth-first search to find a path in the graph.\"\"\"\n        \n        if curr_node == end:\n            return True\n        \n        visited[curr_node] = True\n        \n        for neighbor in graph[curr_node]:\n            if not visited[neighbor]:\n                if dfs(graph, neighbor, visited):\n                    return True\n        \n        return False\n    \n    visited = [False] * len(graph)\n    \n    return dfs(graph, start, visited)\n\ndef g():\n    return [[1, 2], [2, 3, 4], [3, 4], [4], []]\n\nassert f(g(), 0, 4)\n",
        "idx_generation": 98,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, arr: List[int]) -> bool:\n    \"\"\"Given a list of integers and a target sum, find all possible combinations of numbers from the list that add up to the target sum.\n    Return True if there is at least one valid combination, otherwise return False.\n    \"\"\"\n    def backtrack(start, target):\n        if target == 0:\n            return True\n        if target < 0 or start >= len(arr):\n            return False\n        for i in range(start, len(arr)):\n            if backtrack(i + 1, target - arr[i]):\n                return True\n        return False\n    \n    return backtrack(0, n)\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    target = 9\n    return (target, arr)\n\nassert f(*g()) == True\n",
        "idx_generation": 84,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"Find an element in a sorted array that is greater than its neighbors.\"\"\"\n    for i in range(1, len(arr) - 1):\n        if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]:\n            return True\n    return False\ndef g():\n    return [1, 3, 2, 4, 6, 5, 7]\nassert f(g())\n",
        "idx_generation": 7,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers and a target value, determine if there exists a pair of integers in the array that adds up to the target value.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(arr: List[int], target: int) -> List[int]:\n    \"\"\"Generate a sorted array of integers and a target value.\"\"\"\n    return sorted(arr), target\n\nassert f(*g(arr=[2, 4, 6, 8, 10], target=12))\n",
        "idx_generation": 245,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if it is possible to find three distinct integers in the array that sum up to the target value.\"\"\"\n    arr.sort()\n    n = len(arr)\n    for i in range(n-2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            current_sum = arr[i] + arr[left] + arr[right]\n            if current_sum == target:\n                return True\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g(arr=[1, 4, 2, 9, 5, 7, 3], target=12):\n    return arr\n\nassert f(g(), target=12)\n",
        "idx_generation": 59,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> List[List[int]]:\n    \"\"\"Sort the given list of points in ascending order based on their Euclidean distances from the origin (0, 0).\"\"\"\n    return sorted(points, key=lambda x: (x[0]**2 + x[1]**2)**0.5)\n\ndef g():\n    return [[[3, 4], [1, 2], [5, 6], [0, 0]]]\n\nassert f(*g()) == [[0, 0], [1, 2], [3, 4], [5, 6]]\n",
        "idx_generation": 326,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Given a list of integers, find the number of inversions.\"\"\"\n    count = 0\n    \n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n    \n    return count\n\ndef g():\n    return [4, 3, 2, 1]\n\nassert f(g()) == 6\n",
        "idx_generation": 356,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find whether the given number is a prime number.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g(n: int):\n    \"\"\"Generate the nth prime number.\"\"\"\n    count = 0\n    num = 2\n    while count < n:\n        if f(num):\n            count += 1\n        num += 1\n    return num - 1\n\nassert f(g(10))\n",
        "idx_generation": 103,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Given two strings, determine if one is a permutation of the other.\"\"\"\n    if len(s1) != len(s2):\n        return False\n    \n    count_s1 = [0] * 26\n    count_s2 = [0] * 26\n    \n    for c in s1:\n        count_s1[ord(c) - ord('a')] += 1\n    \n    for c in s2:\n        count_s2[ord(c) - ord('a')] += 1\n    \n    return count_s1 == count_s2\n\ndef g(s1=\"abcd\", s2=\"dcba\"):\n    return s1, s2\n\nassert f(*g())\n",
        "idx_generation": 60,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Check if there exists a substring of s that contains exactly k distinct characters.\"\"\"\n    unique_chars = set()\n    for i in range(len(s)):\n        unique_chars.add(s[i])\n        if len(unique_chars) == k:\n            return True\n    return False\n\ndef g():\n    \"\"\"Find a string s and an integer k that satisfy the condition of the puzzle.\"\"\"\n    s = \"abacabad\"\n    k = 3\n    while True:\n        if f(s, k):\n            return s, k\n        k += 1\n\nassert f(*g())\n",
        "idx_generation": 178,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find two numbers in the given list that add up to the target value.\"\"\"\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    return []\n\ndef g() -> List[int]:\n    \"\"\"Generate a list of numbers and a target value.\"\"\"\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 335,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a subsequence of length 4 where the sum is divisible by 4\"\"\"\n    for i in range(len(nums)-3):\n        for j in range(i+1, len(nums)-2):\n            for k in range(j+1, len(nums)-1):\n                for l in range(k+1, len(nums)):\n                    if (nums[i] + nums[j] + nums[k] + nums[l]) % 4 == 0:\n                        return True\n    return False\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"Find a subsequence of length 4 where the sum is divisible by 4\"\"\"\n    max_sum = float('-inf')\n    subsequence = []\n    for i in range(len(nums)-3):\n        for j in range(i+1, len(nums)-2):\n            for k in range(j+1, len(nums)-1):\n                for l in range(k+1, len(nums)):\n                    if (nums[i] + nums[j] + nums[k] + nums[l]) % 4 == 0 and nums[i] + nums[j] + nums[k] + nums[l] > max_sum:\n                        max_sum = nums[i] + nums[j] + nums[k] + nums[l]\n                        subsequence = [nums[i], nums[j], nums[k], nums[l]]\n    return subsequence\n\nassert f(g([1, 2, 3, 4, 5, 6, 7, 8, 9]))\n",
        "idx_generation": 192,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if there exists a path from the top-left corner to the bottom-right corner in the matrix, moving only right or down.\"\"\"\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                dp[i][j] = matrix[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + matrix[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + matrix[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    return dp[m-1][n-1] > 0\ndef g(matrix=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return matrix\nassert f(g())\n",
        "idx_generation": 362,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> int:\n    \"\"\"Given an array of integers, find the maximum subarray sum.\n    A subarray is a contiguous part of the array.\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in arr:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef g(arr=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    \"\"\"Generate an array of integers.\"\"\"\n    return arr\n\nassert f(g()) == 6\n",
        "idx_generation": 200,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(expression: str) -> bool:\n    \"\"\"Given a string containing only '(' and ')', determine if the parentheses are balanced.\n    An expression is considered balanced if each opening parenthesis has a corresponding closing parenthesis.\n    Return True if the expression is balanced, False otherwise.\"\"\"\n    stack = []\n    for char in expression:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g() -> str:\n    \"\"\"Generate a random expression with balanced parentheses.\"\"\"\n    import random\n    n = random.randint(1, 5)\n    expression = '(' * n\n    expression += ')' * n\n    return expression\n\nassert f(g())\n",
        "idx_generation": 241,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the nth Fibonacci number using dynamic programming.\"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        fib = [0] * (n+1)\n        fib[1] = 1\n        for i in range(2, n+1):\n            fib[i] = fib[i-1] + fib[i-2]\n        return fib[n]\n\ndef g():\n    return 10\n\nassert f(g()) == 55\n",
        "idx_generation": 51,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the nth Fibonacci number using recursion.\n    The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones.\n    Return the nth Fibonacci number.\n    Sample input:\n    n = 6\n    Sample output:\n    8\"\"\"\n    if n <= 1:\n        return n\n    return f(n-1) + f(n-2)\n\ndef g():\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 332,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid, determine if there is a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n    Sample input:\n    [[1, 0, 0],\n     [1, 1, 0],\n     [0, 1, 1]]\n    Sample output:\n    True\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[False] * n for _ in range(m)]\n    dp[0][0] = True\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] and grid[i][0] == 1\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] and grid[0][j] == 1\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = (dp[i-1][j] or dp[i][j-1]) and grid[i][j] == 1\n    return dp[m-1][n-1]\n\ndef g():\n    grid = [[1, 0, 0], [1, 1, 0], [0, 1, 1]]\n    return grid\n\nassert f(g())\n",
        "idx_generation": 298,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string 's' containing only lowercase letters,\n    find the length of the longest substring without repeating characters.\n    Return the length of the longest substring.\n    \"\"\"\n    n = len(s)\n    max_length = 0\n    start = 0\n    char_map = {}\n    \n    for end in range(n):\n        if s[end] in char_map:\n            start = max(start, char_map[s[end]] + 1)\n        char_map[s[end]] = end\n        max_length = max(max_length, end - start + 1)\n    \n    return max_length\n\ndef g():\n    \"\"\"\n    Generate a string containing only lowercase letters.\n    \"\"\"\n    s = \"abcabcbb\"\n    \n    return s\n\nassert f(g()) == 3\n",
        "idx_generation": 163,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, return a new list where each element is the bitwise complement of the corresponding element in the input list.\n    \"\"\"\n    return [~num for num in nums]\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [-2, -3, -4, -5, -6]\n",
        "idx_generation": 78,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the nth Fibonacci number\"\"\"\n    def fibonacci(n):\n        if n <= 1:\n            return n\n        return fibonacci(n-1) + fibonacci(n-2)\n\n    return fibonacci(n)\n\ndef g():\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 39,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string, check if it can be formed by concatenating a subsequence of itself multiple times.\n    Return True if it is possible, False otherwise.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            if s[:i] * (n // i) == s:\n                return True\n    return False\n    \ndef g() -> str:\n    \"\"\"Generate a string.\"\"\"\n    return \"abcabcabc\"\n\nassert f(g())\n",
        "idx_generation": 304,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: List[List[int]], start=0, end=4) -> bool:\n    \"\"\"Given a graph represented as an adjacency matrix, find if there exists a path from start to end.\n    Return True if a path exists, False otherwise.\"\"\"\n    visited = [False] * len(graph)\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n        visited[node] = True\n\n        if node == end:\n            return True\n\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] != 0 and not visited[neighbor]:\n                stack.append(neighbor)\n\n    return False\n\ndef g():\n    graph = [\n        [0, 1, 1, 0, 0],\n        [1, 0, 0, 1, 0],\n        [1, 0, 0, 1, 1],\n        [0, 1, 1, 0, 1],\n        [0, 0, 1, 1, 0]\n    ]\n    return graph\n\nassert f(g())\n",
        "idx_generation": 329,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if the target number is reachable from the first element of the array by performing a series of jumps.\"\"\"\n    n = len(arr)\n    visited = [False] * n\n    queue = [0]\n\n    while queue:\n        curr = queue.pop(0)\n        if curr == target:\n            return True\n        visited[curr] = True\n        for jump in range(1, arr[curr] + 1):\n            nxt = curr + jump\n            if nxt < n and not visited[nxt]:\n                queue.append(nxt)\n\n    return False\n\ndef g():\n    \"\"\"Find an array and a target number that satisfy the condition of the puzzle.\"\"\"\n    arr = [1, 3, 2, 4, 1, 2, 0]\n    target = 6\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 128,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(adj_matrix: List[List[int]]) -> bool:\n    \"\"\"Given an adjacency matrix representing a directed graph, determine if there is a cycle in the graph.\"\"\"\n    def dfs(node, visited, stack):\n        visited[node] = True\n        stack[node] = True\n        \n        for neighbor in range(len(adj_matrix)):\n            if adj_matrix[node][neighbor] == 1:\n                if not visited[neighbor]:\n                    if dfs(neighbor, visited, stack):\n                        return True\n                elif stack[neighbor]:\n                    return True\n        \n        stack[node] = False\n        return False\n    \n    num_nodes = len(adj_matrix)\n    visited = [False] * num_nodes\n    stack = [False] * num_nodes\n    \n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(node, visited, stack):\n                return True\n    \n    return False\n\ndef g():\n    return [[0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1],\n            [1, 0, 0, 0]]\n\nassert f(g()) == True\n\n",
        "idx_generation": 116,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"Given a graph represented as a dictionary and two nodes, determine if there exists a path from the start node to the end node.\n    Return True if such path exists, False otherwise.\"\"\"\n    visited = set()\n    stack = [start]\n    \n    while stack:\n        node = stack.pop()\n        visited.add(node)\n        \n        if node == end:\n            return True\n        \n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    \n    return False\n\ndef g() -> Tuple[Dict[str, List[str]], str, str]:\n    \"\"\"Generate a graph represented as a dictionary and two nodes.\"\"\"\n    graph = {\"A\": [\"B\", \"C\"],\n             \"B\": [\"D\"],\n             \"C\": [\"E\"],\n             \"D\": [],\n             \"E\": []}\n    start = \"A\"\n    end = \"E\"\n    \n    return graph, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 117,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Find the number of ways to choose k items from a set of n items, without repetition.\"\"\"\n    def factorial(n):\n        if n == 0 or n == 1:\n            return 1\n        else:\n            return n * factorial(n-1)\n    return factorial(n) // (factorial(k) * factorial(n-k))\ndef g(n=6, k=3):\n    return n, k\nassert f(*g()) == 20\n",
        "idx_generation": 15,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, calculate the number of ways to arrange n pairs of parentheses such that they are balanced.\n    Return the total number of balanced arrangements.\"\"\"\n    if n == 0:\n        return 1\n    \n    count = 0\n    \n    for i in range(n):\n        count += f(i) * f(n - i - 1)\n    \n    return count\n\ndef g() -> int:\n    \"\"\"Generate a positive integer.\"\"\"\n    return 3\n\nassert f(g()) == 5\n",
        "idx_generation": 88,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if an array of integers is sorted in descending order.\"\"\"\n    return all(arr[i] >= arr[i+1] for i in range(len(arr)-1))\n\ndef g():\n    return [5, 3, 2, 1]\n\nassert f(g())\n",
        "idx_generation": 8,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers and a target value, find the index of the target value in the list.\n    If the target value is not found, return -1.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g():\n    return [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n\nassert f(g(), 7) == 3\n",
        "idx_generation": 248,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the closest number to the target in the list.\n    Return True if the closest number is equal to the target, otherwise return False.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return False\n\ndef g():\n    return [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n\nassert f(g(), 14) == False\n",
        "idx_generation": 70,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if there is a pair of numbers in the given list whose sum is a power of 2.\"\"\"\n    nums.sort()\n    n = len(nums)\n    for i in range(n):\n        for j in range(i+1, n):\n            if nums[i] + nums[j] in [2**k for k in range(n)]:\n                return True\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == True\n",
        "idx_generation": 384,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given an array of integers nums and a target value, find the number of occurrences of the target in the array.\"\"\"\n    \n    count = 0\n    \n    for num in nums:\n        if num == target:\n            count += 1\n    \n    return count\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"Return an array of integers and a target value.\"\"\"\n    return nums, target\n\nassert f(*g(nums=[1, 2, 3, 4, 5, 4, 3, 2, 1], target=3)) == 2\n\n",
        "idx_generation": 383,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Determine if there exists a subset of the given list of integers that sums up to the target value.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j < nums[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n    return dp[n][target]\n\ndef g(nums: List[int], target: int) -> bool:\n    return f(nums, target)\n\nnums = [2, 4, 7, 9, 11]\ntarget = 13\nassert f(nums, target) == g(nums, target)\n",
        "idx_generation": 104,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome.\"\"\"\n    return s == s[::-1]\n\ndef g():\n    \"\"\"Find a palindrome string.\"\"\"\n    for i in range(1, 100):\n        for j in range(1, 100):\n            for k in range(1, 100):\n                s = str(i) + str(j) + str(k)\n                if f(s):\n                    return s\n\nassert f(g())\n",
        "idx_generation": 63,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport itertools\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if there exists a subarray of 'nums' with a sum of 0, using a specific combination of elements\"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(i+1, n+1):\n            if sum(nums[i:j]) == 0:\n                return True\n    return False\n\ndef g():\n    nums = [1, -2, 3, 4, -1]\n    combinations = list(itertools.combinations(nums, 3))\n    for comb in combinations:\n        if sum(comb) == 0:\n            return list(comb)\n    return []\n\nassert f(g())\n",
        "idx_generation": 249,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums' and a target integer, return the indices of two numbers in the list\n    that add up to the target.\n    \"\"\"\n    num_dict = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        if complement in num_dict:\n            return [num_dict[complement], i]\n        \n        num_dict[num] = i\n    \n    return []\n\ndef g():\n    \"\"\"\n    Generate a list of integers and a target integer.\n    \"\"\"\n    nums = [2, 7, 11, 15]\n    target = 9\n    \n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 365,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a subsequence of length 2 where the absolute difference is prime\"\"\"\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    for i in range(len(nums)-1):\n        for j in range(i+1, len(nums)):\n            if abs(nums[i] - nums[j]) in primes:\n                return True\n    return False\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"Find a subsequence of length 2 where the absolute difference is prime\"\"\"\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    max_difference = float('-inf')\n    subsequence = []\n    for i in range(len(nums)-1):\n        for j in range(i+1, len(nums)):\n            if abs(nums[i] - nums[j]) in primes and abs(nums[i] - nums[j]) > max_difference:\n                max_difference = abs(nums[i] - nums[j])\n                subsequence = [nums[i], nums[j]]\n    return subsequence\n\nassert f(g([1, 2, 3, 4, 5, 6, 7, 8, 9]))\n",
        "idx_generation": 192,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find n such that the sum of the first n Fibonacci numbers is equal to a perfect square.\"\"\"\n    fibonacci = [0, 1]\n    while fibonacci[-1] < n:\n        fibonacci.append(fibonacci[-1] + fibonacci[-2])\n    return sum(fibonacci) == n ** 2\n\ndef g():\n    n = 1\n    while not f(n):\n        n += 1\n    return n\n\nassert f(g())\n",
        "idx_generation": 392,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given an integer n, determine if it is a prime number.\n    Return True if n is prime, False otherwise.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g() -> int:\n    \"\"\"Generate an integer.\"\"\"\n    return 17\n\nassert f(g())\n",
        "idx_generation": 202,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"Given a grid of characters representing a maze, find the minimum number of steps required to reach the exit.\"\"\"\n    m, n = len(grid), len(grid[0])\n    start = (0, 0)\n    target = (m-1, n-1)\n    queue = [(start, 0)]\n    visited = set()\n\n    while queue:\n        (i, j), steps = queue.pop(0)\n        if (i, j) == target:\n            return steps\n        visited.add((i, j))\n\n        neighbors = [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]\n        for x, y in neighbors:\n            if 0 <= x < m and 0 <= y < n and (x, y) not in visited and grid[x][y] != '#':\n                queue.append(((x, y), steps + 1))\n                visited.add((x, y))\n\n    return -1\n\ndef g() -> List[List[str]]:\n    \"\"\"Generate a grid of characters representing a maze.\"\"\"\n    grid = [['S', '.', '#', '#', '#'],\n            ['#', '.', '.', '.', '#'],\n            ['#', '#', '#', '.', '#'],\n            ['#', '.', '.', '.', 'E']]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 243,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Determine if there is a path from the top-left corner to the bottom-right corner in the given matrix,\n    where each cell represents a cost to move to that cell. You can only move down or right.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = matrix[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    return dp[rows-1][cols-1] < float('inf')\ndef g(matrix: List[List[int]]):\n    return matrix\nassert f(g([[1, 3, 1], [1, 5, 1], [4, 2, 1]]))\n",
        "idx_generation": 56,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nimport math\nfrom typing import*\ndef f(expression: str) -> bool:\n    \"\"\"\n    Given a string representing a mathematical expression containing only parentheses, \n    determine if the parentheses are balanced. Return True if the parentheses are balanced, False otherwise.\n    \"\"\"\n    stack = []\n    for char in expression:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g() -> str:\n    \"\"\"\n    Generate a random string representing a mathematical expression containing only parentheses.\n    \"\"\"\n    expression = \"((()))()(()())\"\n    return expression\n\nassert f(g()) == True\n",
        "idx_generation": 339,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of 0s and 1s, determine if it is possible to reach the bottom-right cell starting from the top-left\ncell, by traversing only through the cells containing 1s. You can only move down, right, or diagonally down-right.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    def dfs(i, j):\n        if i == rows-1 and j == cols-1:\n            return True\n        if i >= rows or j >= cols or matrix[i][j] != 1:\n            return False\n        return dfs(i+1, j) or dfs(i, j+1) or dfs(i+1, j+1)\n    \n    return dfs(0, 0)\n\ndef g():\n    return [[1, 0, 0, 1],\n            [1, 1, 0, 1],\n            [0, 1, 1, 0],\n            [1, 0, 1, 1]]\n\nassert f(g())\n",
        "idx_generation": 316,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string, determine if it is a palindrome.\"\"\"\n    def is_palindrome(s, start, end):\n        if start >= end:\n            return True\n        if s[start] != s[end]:\n            return False\n        return is_palindrome(s, start + 1, end - 1)\n    \n    return is_palindrome(s, 0, len(s) - 1)\n    \ndef g(s=\"racecar\"):\n    return s\n\nassert f(g())\n",
        "idx_generation": 166,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list whose XOR is equal to the target\"\"\"\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] ^ nums[j] == target:\n                return True\n    return False\n\ndef g(target=5):\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9], target\n\nassert f(*g())\n",
        "idx_generation": 85,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the number of ways to climb a staircase with n steps. Each time, you can climb either 1 or 2 steps\"\"\"\n    if n <= 1:\n        return 1\n    prev_prev = 1\n    prev = 1\n    for i in range(2, n+1):\n        current = prev + prev_prev\n        prev_prev = prev\n        prev = current\n    return prev\n\ndef g(n: int) -> int:\n    \"\"\"Generate the number of steps in a staircase\"\"\"\n    return n\n\nassert f(g(5)) == 8\n",
        "idx_generation": 64,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"Check if the given string is a palindrome and if the given number is a perfect square.\"\"\"\n    is_palindrome = s == s[::-1]\n\n    is_perfect_square = n == int(n**0.5)**2\n\n    return is_palindrome or is_perfect_square\n\ndef g():\n    s = 'python'\n    n = 16\n    return s, n\n\nassert f(*g())\n",
        "idx_generation": 375,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]], word: str) -> bool:\n    \"\"\"Given a grid of characters and a target word, determine if the word can be formed by traversing adjacent cells (horizontally, vertically, or diagonally) in the grid.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n\n    def dfs(row: int, col: int, index: int) -> bool:\n        if index == len(word):\n            return True\n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] != word[index]:\n            return False\n        temp = grid[row][col]\n        grid[row][col] = ''\n        for direction in directions:\n            newRow = row + direction[0]\n            newCol = col + direction[1]\n            if dfs(newRow, newCol, index + 1):\n                return True\n        grid[row][col] = temp\n        return False\n\n    for r in range(rows):\n        for c in range(cols):\n            if dfs(r, c, 0):\n                return True\n    return False\n\ndef g() -> List[List[str]]:\n    \"\"\"Generate a grid of characters and a target word.\"\"\"\n    grid = [['A', 'B', 'C', 'E'],\n            ['S', 'F', 'C', 'S'],\n            ['A', 'D', 'E', 'E']]\n    word = \"SEE\"\n    return grid, word\n\nassert f(*g())\n",
        "idx_generation": 336,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of 0s and 1s, determine if it is possible to reach the bottom-right corner starting from the top-left corner. You can only move down, right, or diagonally down-right.\"\"\"\n    m, n = len(grid), len(grid[0])\n    queue = [(0, 0)]\n    visited = set()\n\n    while queue:\n        i, j = queue.pop(0)\n        if i == m - 1 and j == n - 1:\n            return True\n        visited.add((i, j))\n\n        neighbors = [(i + 1, j), (i, j + 1), (i + 1, j + 1)]\n        for x, y in neighbors:\n            if 0 <= x < m and 0 <= y < n and (x, y) not in visited and grid[x][y] == 0:\n                queue.append((x, y))\n\n    return False\n\ndef g():\n    return [[0, 1, 0, 0],\n            [0, 0, 0, 1],\n            [1, 1, 0, 0],\n            [0, 0, 0, 0]]\n\nassert f(g())\n",
        "idx_generation": 154,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, k: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency list and two nodes 'start' and 'end',\n    determine if there exists a path from 'start' to 'end' with at most 'k' edges.\n    Return True if a path exists, False otherwise.\n    \"\"\"\n    def dfs(node, edges):\n        if node == end and edges <= k:\n            return True\n        if edges > k:\n            return False\n        for neighbor in graph[node]:\n            if dfs(neighbor, edges + 1):\n                return True\n        return False\n    \n    return dfs(start, 0)\n\ndef g():\n    \"\"\"\n    Generate a directed graph represented as an adjacency list.\n    \"\"\"\n    graph = [[1, 2],     # node 0\n             [2, 3],     # node 1\n             [4],        # node 2\n             [1, 4],     # node 3\n             [3]]        # node 4\n    start = 0\n    end = 4\n    k = 2\n    \n    return graph, start, end, k\n\nassert f(*g()) == True\n\n",
        "idx_generation": 125,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 0 represents an empty cell and 1 represents a wall,\n    find the length of the shortest path from the top-left corner to the bottom-right corner.\n    Return the length of the shortest path.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    queue = [(0, 0, 0)]  # (x, y, distance)\n    visited = set([(0, 0)])\n    \n    while queue:\n        x, y, distance = queue.pop(0)\n        \n        if x == rows - 1 and y == cols - 1:\n            return distance\n        \n        for dx, dy in directions:\n            nx = x + dx\n            ny = y + dy\n            \n            if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 0 and (nx, ny) not in visited:\n                queue.append((nx, ny, distance + 1))\n                visited.add((nx, ny))\n    \n    return -1\n\ndef g():\n    \"\"\"\n    Generate a grid with 0s and 1s.\n    \"\"\"\n    grid = [[0, 0, 0, 0],\n            [1, 1, 0, 1],\n            [0, 0, 0, 0],\n            [1, 1, 1, 0]]\n    \n    return grid\n\nassert f(g()) == 6\n\n",
        "idx_generation": 125,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport itertools\n\ndef f(num_list: List[int], target=10) -> bool:\n    \"\"\"Check if there is a subset of num_list whose sum is equal to the target\"\"\"\n    for r in range(len(num_list)+1):\n        for subset in itertools.combinations(num_list, r):\n            if sum(subset) == target:\n                return True\n    return False\n\ndef g(target=10):\n    num_list = [1, 2, 3, 4, 5]\n    return num_list\n\nassert f(g())\n",
        "idx_generation": 27,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"Find the number of ways to express n as a sum of 1s, 2s, and 3s.\"\"\"\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    dp[2] = 2\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]\n\n    return dp[n]\n\ndef g():\n    return 5\n\nassert f(g()) == 13\n",
        "idx_generation": 115,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if a given grid is a valid Sudoku solution.\"\"\"\n    def is_row_valid(row):\n        return sorted(row) == list(range(1, 10))\n\n    def is_column_valid(grid, col):\n        return sorted(row[col] for row in grid) == list(range(1, 10))\n\n    def is_box_valid(grid, start_row, start_col):\n        box = [grid[i][j] for i in range(start_row, start_row+3) for j in range(start_col, start_col+3)]\n        return sorted(box) == list(range(1, 10))\n\n    for row in grid:\n        if not is_row_valid(row):\n            return False\n\n    for col in range(9):\n        if not is_column_valid(grid, col):\n            return False\n\n    for start_row in range(0, 9, 3):\n        for start_col in range(0, 9, 3):\n            if not is_box_valid(grid, start_row, start_col):\n                return False\n\n    return True\n\ndef g():\n    return [[5, 3, 4, 6, 7, 8, 9, 1, 2],\n            [6, 7, 2, 1, 9, 5, 3, 4, 8],\n            [1, 9, 8, 3, 4, 2, 5, 6, 7],\n            [8, 5, 9, 7, 6, 1, 4, 2, 3],\n            [4, 2, 6, 8, 5, 3, 7, 9, 1],\n            [7, 1, 3, 9, 2, 4, 8, 5, 6],\n            [9, 6, 1, 5, 3, 7, 2, 8, 4],\n            [2, 8, 7, 4, 1, 9, 6, 3, 5],\n            [3, 4, 5, 2, 8, 6, 1, 7, 9]]\n\nassert f(g())\n",
        "idx_generation": 8,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given an array of integers, sort the array in ascending order using the bubble sort algorithm.\"\"\"\n    n = len(nums)\n\n    for i in range(n):\n        for j in range(n - i - 1):\n            if nums[j] > nums[j + 1]:\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n\n    return nums\n\ndef g(nums: List[int]) -> List[int]:\n    return f(nums)\n\nnums = [64, 34, 25, 12, 22, 11, 90]\nassert f(nums) == g(nums)\n",
        "idx_generation": 253,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the first occurrence of the target in the list.\n    If the target is not found, return -1.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == target:\n            if mid == 0 or arr[mid - 1] < target:\n                return mid\n            else:\n                right = mid - 1\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g():\n    return [1, 2, 3, 3, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), 3) == 2\n",
        "idx_generation": 70,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Determine if there is a pair of numbers in the given list whose sum is a perfect square.\"\"\"\n    squares = set()\n    for i in range(1, int(math.sqrt(max(nums)))+1):\n        squares.add(i*i)\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] + nums[j] in squares:\n                return True\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g())\n",
        "idx_generation": 387,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in descending order using the Counting Sort algorithm.\n\n    Example:\n    Input: [4, 2, 6, 8, 1, 3, 5, 7]\n    Output: [8, 7, 6, 5, 4, 3, 2, 1]\n    \"\"\"\n\n    min_num = min(nums)\n    max_num = max(nums)\n    count = [0] * (max_num - min_num + 1)\n    sorted_nums = []\n\n    for num in nums:\n        count[num - min_num] += 1\n\n    for i in range(len(count) - 1, -1, -1):\n        sorted_nums.extend([i + min_num] * count[i])\n\n    return sorted_nums\n\ndef g():\n    nums = [4, 2, 6, 8, 1, 3, 5, 7]\n    return nums\n\nassert f(g()) == [8, 7, 6, 5, 4, 3, 2, 1]\n",
        "idx_generation": 393,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k=3) -> bool:\n    \"\"\"Count the number of ways to represent n as a sum of k positive integers.\"\"\"\n    dp = [[0] * (n + 1) for _ in range(k + 1)]\n    dp[0][0] = 1\n    for i in range(1, k + 1):\n        for j in range(1, n + 1):\n            for x in range(j):\n                dp[i][j] += dp[i - 1][x]\n    return dp[k][n]\n\ndef g(k=3):\n    return k\n\nassert f(g())\n",
        "idx_generation": 111,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Check if the given two strings are anagrams of each other\"\"\"\n    if len(s1) != len(s2):\n        return False\n    char_count = [0] * 26\n    for i in range(len(s1)):\n        char_count[ord(s1[i]) - ord('a')] += 1\n        char_count[ord(s2[i]) - ord('a')] -= 1\n    for count in char_count:\n        if count != 0:\n            return False\n    return True\n\ndef g():\n    s1 = \"listen\"\n    s2 = \"silent\"\n    return s1, s2\n\nassert f(*g())\n",
        "idx_generation": 68,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string, determine if it is a palindrome.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward, ignoring spaces and punctuation marks.\n    Return True if the string is a palindrome, and False otherwise.\"\"\"\n    \n    s = ''.join(ch for ch in s if ch.isalnum()).lower()\n    \n    return s == s[::-1]\n\ndef g():\n    return \"A man, a plan, a canal, Panama!\"\n\nassert f(g())\n",
        "idx_generation": 272,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums' and a target sum 'target',\n    find two distinct indices i and j such that nums[i] + nums[j] equals to target,\n    and return their indices as a list [i, j].\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    The possible indices are [0, 1] and [1, 0],\n    where nums[0] + nums[1] equals to 9.\n    Therefore, the answer is [0, 1].\n    \"\"\"\n    num_set = set()\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in num_set:\n            return [nums.index(complement), i]\n        num_set.add(nums[i])\n    return []\n\ndef g():\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 366,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Given a matrix (2D list) of integers and a target number, determine if the target number is present in the matrix.\n    Return True if the target number is present, False otherwise.\"\"\"\n    for row in matrix:\n        if target in row:\n            return True\n    return False\n\ndef g(matrix: List[List[int]], target: int) -> bool:\n    return f(matrix, target)\n\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\ntarget = 5\nassert f(matrix, target) == g(matrix, target)\n",
        "idx_generation": 203,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> int:\n    \"\"\"Count the number of positive integers less than or equal to 'n' that are divisible by 'm'.\"\"\"\n    count = 0\n    for i in range(1, n+1):\n        if i % m == 0:\n            count += 1\n    return count\n\ndef g():\n    n = 20\n    m = 4\n    return n, m\n\nassert f(*g()) == 5\n",
        "idx_generation": 419,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers and a target number, find two numbers in the list that add up to the target.\"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 209,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum element in the list using a stack.\"\"\"\n    stack = []\n    max_num = float('-inf')\n    for num in nums:\n        while stack and stack[-1] < num:\n            stack.pop()\n        stack.append(num)\n        max_num = max(max_num, num)\n    return max_num\n\ndef g():\n    nums = [5, 3, 9, 2, 7, 1]\n    return nums\n\nassert f(g()) == 9\n",
        "idx_generation": 252,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if there exists a subset of the list that sums up to the target.\n    Return True if such a subset exists, and False otherwise.\"\"\"\n    \n    def subset_sum(nums, target, index, current_sum):\n        if current_sum == target:\n            return True\n        if current_sum > target or index >= len(nums):\n            return False\n        \n        return subset_sum(nums, target, index+1, current_sum+nums[index]) or subset_sum(nums, target, index+1, current_sum)\n    \n    return subset_sum(nums, target, 0, 0)\n\ndef g():\n    return ([1, 5, 2, 8, 3], 10)\n\nassert f(*g())\n",
        "idx_generation": 57,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum sum of a subarray in the given list.\"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n        \n    return max_sum\n\ndef g(nums: List[int]):\n    return nums\n\n# Example usage\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g(nums)) == 6\n",
        "idx_generation": 341,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Count the number of islands in the given grid, where an island is represented by 1 and is surrounded by water represented by 0.\"\"\"\n    def dfs(grid, i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:\n            return\n        grid[i][j] = -1\n        dfs(grid, i+1, j)\n        dfs(grid, i-1, j)\n        dfs(grid, i, j+1)\n        dfs(grid, i, j-1)\n\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                count += 1\n                dfs(grid, i, j)\n    return count\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a grid of 0s and 1s.\"\"\"\n    return [[1, 1, 0, 0, 0],\n            [0, 1, 0, 0, 1],\n            [1, 0, 0, 1, 1],\n            [0, 0, 0, 0, 0],\n            [1, 0, 1, 0, 1]]\n\nassert f(g()) == 6\n",
        "idx_generation": 318,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Check if there exists a substring of s that contains exactly k uppercase letters.\"\"\"\n    count = 0\n    for i in range(len(s)):\n        if s[i].isupper():\n            count += 1\n            if count == k:\n                return True\n    return False\n\ndef g():\n    \"\"\"Find a string s and an integer k that satisfy the condition of the puzzle.\"\"\"\n    s = \"HelloWorld\"\n    k = 2\n    while True:\n        if f(s, k):\n            return s, k\n        k += 1\n\nassert f(*g())\n",
        "idx_generation": 178,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a 2D grid of integers, determine if it contains a rectangular subgrid where the bitwise XOR of all elements is equal to 0.\n    Sample input:\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    Sample output:\n    False\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    for i in range(m):\n        for j in range(n):\n            for k in range(i, m):\n                for l in range(j, n):\n                    xor = 0\n                    for x in range(i, k + 1):\n                        for y in range(j, l + 1):\n                            xor ^= grid[x][y]\n                    if xor == 0:\n                        return True\n    return False\n\ndef g():\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return grid\n\nassert f(g())\n",
        "idx_generation": 97,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int, res: int) -> bool:\n    \"\"\"Given a set of n distinct integers, find the number of subsets of size k such that the sum of the elements in each subset is equal to res.\n    The goal is to find the values of n, k, and res that satisfy this condition.\"\"\"\n    def count_subsets(arr, n, k, res):\n        if res == 0:\n            return 1\n        if n == 0:\n            return 0\n        if arr[n-1] > res:\n            return count_subsets(arr, n-1, k, res)\n        return count_subsets(arr, n-1, k, res) + count_subsets(arr, n-1, k-1, res-arr[n-1])\n    \n    arr = [i for i in range(1, n+1)]\n    return count_subsets(arr, n, k, res) > 0\n\ndef g(n: int, k: int, res: int):\n    return n, k, res\n\n# Example usage\nassert f(*g(5, 2, 7))\n",
        "idx_generation": 64,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"Check if the given string is a palindrome and if the given number is a perfect square.\"\"\"\n    is_palindrome = s == s[::-1]\n\n    is_perfect_square = n == int(n**0.5)**2\n\n    return is_palindrome and is_perfect_square\n\ndef g():\n    s = 'level'\n    n = 25\n    return s, n\n\nassert f(*g())\n",
        "idx_generation": 375,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"Given a grid of characters, count the number of islands.\n    An island is formed by connecting adjacent lands horizontally or vertically.\n    '1' represents land and '0' represents water.\"\"\"\n    if not grid:\n        return 0\n\n    rows = len(grid)\n    cols = len(grid[0])\n    count = 0\n\n    def dfs(row: int, col: int) -> None:\n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] != '1':\n            return\n\n        grid[row][col] = '0'\n\n        dfs(row+1, col)\n        dfs(row-1, col)\n        dfs(row, col+1)\n        dfs(row, col-1)\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == '1':\n                count += 1\n                dfs(i, j)\n\n    return count\n\ndef g() -> List[List[str]]:\n    \"\"\"Generate a grid of characters.\"\"\"\n    return [['1', '1', '0', '0', '0'],\n            ['1', '1', '0', '0', '0'],\n            ['0', '0', '1', '0', '0'],\n            ['0', '0', '0', '1', '1']]\n\nassert f(g()) == 3\n",
        "idx_generation": 344,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start=1, end=5) -> bool:\n    \"\"\"Given a directed graph in the form of a dictionary, determine if there is a path from start to end.\n    Return True if a path exists, False otherwise.\"\"\"\n    \n    visited = set()\n    stack = [start]\n    \n    while stack:\n        node = stack.pop()\n        visited.add(node)\n        \n        if node == end:\n            return True\n        \n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    \n    return False\n\ndef g(start=1, end=5):\n    graph = {\n        1: [2, 3],\n        2: [4, 5],\n        3: [2],\n        4: [5],\n        5: []\n    }\n    return graph\n\nassert f(g())\n",
        "idx_generation": 158,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]]) -> bool:\n    \"\"\"Given a directed graph represented as a dictionary, determine if there exists a cycle in the graph.\"\"\"\n    visited = set()\n    recursive_stack = set()\n    \n    def dfs(node):\n        visited.add(node)\n        recursive_stack.add(node)\n        \n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n            elif neighbor in recursive_stack:\n                return True\n        \n        recursive_stack.remove(node)\n        return False\n    \n    for node in graph:\n        if node not in visited:\n            if dfs(node):\n                return True\n    \n    return False\n\ndef g():\n    \"\"\"Generate a directed graph.\"\"\"\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['C'],\n        'C': ['D'],\n        'D': ['A']\n    }\n    \n    return graph\n\nassert f(g())\n",
        "idx_generation": 129,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum number of steps required to reach the bottom-right corner from the top-left corner. Each step can move to adjacent cells in the grid, either horizontally or vertically.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g(grid: List[List[int]] = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 167,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given an integer n, find the number of ways to represent n as a sum of 3 non-negative integers.\n    Return True if the number of ways is greater than 5, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(n + 1):\n        for j in range(n + 1):\n            k = n - i - j\n            if k >= 0:\n                count += 1\n    return count > 5\n\ndef g():\n    n = 10\n    return n\n\nassert f(g())\n",
        "idx_generation": 94,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Given two integers n and k, determine if there exists a permutation of the numbers 1 to n such that\n    the sum of any two adjacent numbers is greater than or equal to k.\n    \"\"\"\n    def backtrack(arr: List[int], used: List[bool], k: int) -> bool:\n        if len(arr) == n:\n            return True\n        \n        for i in range(1, n+1):\n            if not used[i] and (not arr or abs(arr[-1] - i) >= k):\n                arr.append(i)\n                used[i] = True\n                \n                if backtrack(arr, used, k):\n                    return True\n                \n                arr.pop()\n                used[i] = False\n        \n        return False\n    \n    return backtrack([], [False] * (n+1), k)\n\ndef g(n=4, k=2):\n    return n, k\n\nassert f(*g()) == True\n",
        "idx_generation": 119,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, nums=[3, 5, 1, 2, 4], target=7) -> bool:\n    \"\"\"Find two numbers in a list that sum up to a target value\"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g(nums=[3, 5, 1, 2, 4], target=7):\n    return any(target - num in nums for num in nums)\nassert f(g())\n",
        "idx_generation": 8,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers nums and a target value, return True if the target value is present in the list, otherwise return False.\n    Implement the solution using a binary search algorithm.\"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Generate a sorted list of integers and a target value.\"\"\"\n    nums = [1, 3, 5, 7, 9, 11, 13, 15]\n    target = 7\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 256,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport random\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target number, return True if the target number is present in the list, False otherwise.\n    Sample input:\n    arr = [2, 4, 6, 8, 10]\n    target = 6\n    Sample output:\n    True\"\"\"\n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return False\n\ndef g():\n    arr = sorted(random.sample(range(20), 10))\n    target = random.choice(arr)\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 73,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of elements in the given array that sums up to the target value.\n\n    Args:\n        arr (List[int]): The input array.\n        target (int): The target value.\n\n    Returns:\n        bool: True if there exists a pair of elements that sums up to the target value, False otherwise.\n\n    Example:\n        Input: arr = [1, 2, 3, 4, 5], target = 9\n        Output: True\n        Explanation: There exists a pair of elements (4, 5) that sums up to 9.\n    \"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(arr: List[int], target: int) -> bool:\n    return f(arr, target)\n\narr = [1, 2, 3, 4, 5]\ntarget = 9\nassert f(arr, target) == g(arr, target)\n",
        "idx_generation": 408,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(numbers: List[int]) -> List[int]:\n    \"\"\"Sort the given list of numbers in descending order and return only the prime numbers.\"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    sorted_numbers = sorted(numbers, reverse=True)\n    prime_numbers = [num for num in sorted_numbers if is_prime(num)]\n\n    return prime_numbers\n\ndef g():\n    numbers = [5, 12, 7, 23, 16, 11]\n    return numbers\n\nassert f(g()) == [23, 11, 7, 5]\n",
        "idx_generation": 424,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, nums: List[int]) -> bool:\n    \"\"\"Given a list of n integers, determine whether there exists a subset of the list\n    such that the sum of its elements is divisible by n.\n    \n    Return True if such a subset exists, False otherwise.\n    \"\"\"\n    dp = [False] * n\n    dp[0] = True\n    for num in nums:\n        for i in range(n-1, -1, -1):\n            if dp[i]:\n                dp[(i + num) % n] = True\n    return dp[0]\n\ndef g():\n    n = 4\n    nums = [3, 2, 7, 1]\n    return n, nums\n\nassert f(*g())\n",
        "idx_generation": 115,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(words: List[str]) -> bool:\n    \"\"\"Given a list of words, find if there exists a word in the list that is formed by concatenating two other words in the list.\"\"\"\n    for word in words:\n        for i in range(len(word)):\n            prefix = word[:i]\n            suffix = word[i:]\n            if prefix in words and suffix in words:\n                return True\n    return False\n\ndef g():\n    words = [\"apple\", \"banana\", \"cat\", \"dog\", \"app\", \"le\", \"ana\", \"a\"]\n    return words\n\nassert f(g()) == True\n",
        "idx_generation": 114,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"Given a string, determine if it is a palindrome.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n    Return True if the string is a palindrome, otherwise return False.\n    \n    Sample Input:\n    string = \"racecar\"\n    \n    Sample Output:\n    True\n    \n    Explanation:\n    The string \"racecar\" can be read the same forward and backward, so the function should return True.\n    \"\"\"\n    return string == string[::-1]\n\ndef g(string: str):\n    \"\"\"Given a string, find the longest palindrome substring within the string.\n    Return the longest palindrome substring.\n    \n    Sample Input:\n    string = \"babad\"\n    \n    Sample Output:\n    \"bab\"\n    \n    Explanation:\n    The longest palindrome substring within the string \"babad\" is \"bab\", so the function should return \"bab\".\n    \"\"\"\n    longest_palindrome = \"\"\n    max_length = 0\n    \n    for i in range(len(string)):\n        # Check odd length palindromes\n        left = i\n        right = i\n        \n        while left >= 0 and right < len(string) and string[left] == string[right]:\n            if right - left + 1 > max_length:\n                longest_palindrome = string[left:right+1]\n                max_length = right - left + 1\n            left -= 1\n            right += 1\n        \n        # Check even length palindromes\n        left = i\n        right = i+1\n        \n        while left >= 0 and right < len(string) and string[left] == string[right]:\n            if right - left + 1 > max_length:\n                longest_palindrome = string[left:right+1]\n                max_length = right - left + 1\n            left -= 1\n            right += 1\n    \n    return longest_palindrome\n\nassert f(g(\"babad\"))\n",
        "idx_generation": 294,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of integers in the given list that sums up to the target value.\"\"\"\n    seen = set()\n    for num in nums:\n        complement = target - num\n        if complement in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 379,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of trailing zeros in the factorial of a given number.\"\"\"\n    count = 0\n    i = 5\n    while n // i >= 1:\n        count += n // i\n        i *= 5\n    \n    return count\n\ndef g():\n    return 20\n\nassert f(g()) == 4\n",
        "idx_generation": 212,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a number is a prime palindrome\"\"\"\n    def is_prime(num) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    def is_palindrome(num) -> bool:\n        return str(num) == str(num)[::-1]\n    \n    return is_prime(n) and is_palindrome(n)\n    \ndef g():\n    num = 2\n    count = 0\n    while True:\n        if f(num):\n            count += 1\n            if count == 10:\n                return num\n        num += 1\n\nassert f(g()) == True",
        "idx_generation": 428,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if there exists a subarray in the given list such that the sum of its elements is equal to zero.\"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum == 0 or prefix_sum in prefix_sums:\n            return True\n        prefix_sums.add(prefix_sum)\n    return False\n\ndef g():\n    return [1, 2, -3, 4, 5]  # Return a list of integers\n\nassert f(g()) == True\n",
        "idx_generation": 215,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers 'arr' and an integer 'target', determine if it is possible to represent the target\n    value using the numbers from the list by performing addition and subtraction operations.\"\"\"\n    stack = [(0, 0)]\n    while stack:\n        total, idx = stack.pop()\n        if total == target:\n            return True\n        if idx == len(arr):\n            continue\n        stack.append((total + arr[idx], idx + 1))\n        stack.append((total - arr[idx], idx + 1))\n    return False\n\ndef g(target: int):\n    return [2, 4, 6, 8, 10]\n\nassert f(g(14), 14)\n",
        "idx_generation": 295,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of paths from (0, 0) to (n, n) on a grid.\n    You can only move down or right.\n    Sample Input:\n    n = 2\n    Sample Output:\n    6\"\"\"\n    memo = [[0] * (n + 1) for _ in range(n + 1)]\n    return count_paths(n, n, memo)\n\ndef count_paths(x: int, y: int, memo: List[List[int]]) -> int:\n    if x == 0 or y == 0:\n        return 1\n    if memo[x][y] != 0:\n        return memo[x][y]\n    memo[x][y] = count_paths(x - 1, y, memo) + count_paths(x, y - 1, memo)\n    return memo[x][y]\n\ndef g(n=2):\n    \"\"\"Return the given grid size\"\"\"\n    return n\n\nassert f(g()) == 6\n",
        "idx_generation": 59,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum sum of any contiguous subarray within the list.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 400,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of positive integers, determine if there exists a path from the top left corner to the bottom right corner\n    where the sum of the numbers along the path is a multiple of 5.\n    \"\"\"\n    def dfs(i: int, j: int, s: int) -> bool:\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\n            return s % 5 == 0\n        if i < len(grid) - 1 and dfs(i + 1, j, s + grid[i + 1][j]):\n            return True\n        if j < len(grid[0]) - 1 and dfs(i, j + 1, s + grid[i][j + 1]):\n            return True\n        return False\n    \n    return dfs(0, 0, grid[0][0])\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g())\n",
        "idx_generation": 321,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(words: List[str], target: str) -> bool:\n    \"\"\"Given a list of words and a target word, determine if it is possible to form the target word\n    by concatenating words from the list without any repetition.\n    Sample input:\n    words = [\"apple\", \"banana\", \"peach\", \"lemon\"]\n    target = \"applebanana\"\n    Sample output:\n    True\"\"\"\n    def can_form_word(words: List[str], target: str, used: set) -> bool:\n        if target == \"\":\n            return True\n        for i in range(len(words)):\n            word = words[i]\n            if word in used:\n                continue\n            if target.startswith(word):\n                used.add(word)\n                if can_form_word(words, target[len(word):], used):\n                    return True\n                used.remove(word)\n        return False\n\n    return can_form_word(words, target, set())\n\ndef g():\n    return [\"apple\", \"banana\", \"peach\", \"lemon\"], \"applebanana\"\n\nassert f(*g())\n",
        "idx_generation": 182,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Find a subset of numbers from the given list that adds up to the target number\"\"\"\n    n = len(nums)\n    for i in range(1 << n):\n        subset_sum = sum(nums[j] for j in range(n) if (i & (1 << j)) != 0)\n        if subset_sum == target:\n            return True\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    return nums\nassert f(g())\n",
        "idx_generation": 100,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the minimum number of steps required to reach the bottom-right corner from the top-left corner in the grid.\n    You can only move down or right.\"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[m-1][n-1]\n\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 7\n",
        "idx_generation": 68,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"Check if the given string is a palindrome and if the given number is a prime number.\"\"\"\n    if s == s[::-1]:\n        if n > 1:\n            for i in range(2, int(n ** 0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n    return False\n\ndef g():\n    s = 'madam'\n    n = 17\n    return s, n\n\nassert f(*g())\n",
        "idx_generation": 461,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph represented as a dictionary of node and its neighbors, determine if there exists\n    a path from the start node to the end node. Return True if a path exists, False otherwise.\n    \"\"\"\n    visited = set()\n    stack = [start]\n    \n    while stack:\n        current_node = stack.pop()\n        if current_node == end:\n            return True\n        if current_node not in visited:\n            visited.add(current_node)\n            stack.extend(graph[current_node])\n    \n    return False\n\ndef g(start: int = 1, end: int = 5) -> Dict[int, List[int]]:\n    \"\"\"\n    Generate a graph represented as a dictionary of node and its neighbors such that there exists\n    a path from the start node to the end node.\n    \"\"\"\n    return {1: [2, 3], 2: [3, 4], 3: [4, 5], 4: [5]}, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 363,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start='A', end='D') -> bool:\n    \"\"\"Find if there exists a path from start to end in the given graph\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\ndef g():\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D'],\n        'D': []\n    }\n    return graph\nassert f(g())\n",
        "idx_generation": 161,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]]) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency list, determine if there is a cycle in the graph.\n    Return True if there is a cycle, False otherwise.\"\"\"\n    def has_cycle(node, visited, recursion_stack):\n        visited[node] = True\n        recursion_stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if has_cycle(neighbor, visited, recursion_stack):\n                    return True\n            elif recursion_stack[neighbor]:\n                return True\n\n        recursion_stack[node] = False\n        return False\n\n    visited = {node: False for node in graph}\n    recursion_stack = {node: False for node in graph}\n\n    for node in graph:\n        if not visited[node]:\n            if has_cycle(node, visited, recursion_stack):\n                return True\n\n    return False\n\ndef g():\n    return {1: [2], 2: [3], 3: [1]}  # Graph with a cycle\n\nassert f(g())\n",
        "idx_generation": 137,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid with obstacles, find the number of unique paths from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Args:\n        grid (List[List[int]]): The grid with obstacles.\n\n    Returns:\n        int: The number of unique paths.\n    \"\"\"\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                dp[i][j] = 1\n            elif grid[i][j] == 0:\n                if i > 0:\n                    dp[i][j] += dp[i - 1][j]\n                if j > 0:\n                    dp[i][j] += dp[i][j - 1]\n\n    return dp[m - 1][n - 1]\n\ndef g(grid: List[List[int]]) -> int:\n    return f(grid)\n\ngrid = [\n    [0, 0, 0],\n    [0, 1, 0],\n    [0, 0, 0]\n]\nassert f(grid) == g(grid)\n",
        "idx_generation": 182,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int, k: int) -> bool:\n    \"\"\"Given a list of integers nums, a target number, and an integer k,\n    determine if there exists a combination of k numbers in nums such that their sum is equal to target.\n    Return True if such combination exists, otherwise return False.\n    Sample input:\n    nums = [2, 4, 6, 8, 10]\n    target = 18\n    k = 3\n    Sample output:\n    True\"\"\"\n    def helper(nums: List[int], target: int, k: int, start: int, curr_sum: int) -> bool:\n        if k == 0:\n            return curr_sum == target\n        if start == len(nums):\n            return False\n        return helper(nums, target, k, start+1, curr_sum) or helper(nums, target, k-1, start+1, curr_sum + nums[start])\n    \n    return helper(nums, target, k, 0, 0)\n\ndef g():\n    return [2, 4, 6, 8, 10], 18, 3\n\nassert f(*g()) == True\n",
        "idx_generation": 139,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(n: int) -> int:\n    \"\"\"Find the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\"\"\"\n    def unique_paths_helper(i, j):\n        if i == 0 or j == 0:\n            return 1\n        return unique_paths_helper(i-1, j) + unique_paths_helper(i, j-1)\n    \n    return unique_paths_helper(n-1, n-1)\n\ndef g():\n    return 3\n\nassert f(g()) == 6\n",
        "idx_generation": 121,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Sort a list of numbers in ascending order\"\"\"\n    return sorted(nums)\ndef g():\n    return [5, 2, 8, 1, 9]\nassert f(g()) == [1, 2, 5, 8, 9]\n",
        "idx_generation": 13,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport heapq\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"Given a list of integers nums and an integer k, return the kth largest element in the list.\n    Implement the solution using a min heap.\"\"\"\n    heap = []\n\n    for num in nums:\n        heapq.heappush(heap, num)\n        if len(heap) > k:\n            heapq.heappop(heap)\n    \n    return heap[0]\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Generate a list of integers and a value for k.\"\"\"\n    nums = [9, 8, 7, 6, 5, 4, 3, 2, 1]\n    k = 3\n    return nums, k\n\nassert f(*g()) == 7\n\n",
        "idx_generation": 256,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of non-negative integers, find the number of unique paths from the top-left to the bottom-right corner of the grid.\n    You can only move down or right.\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    return dp[m-1][n-1]\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    return grid\n\nassert f(g([[1, 1, 1],\n            [1, 1, 1],\n            [1, 1, 1]])) == 6\n\n",
        "idx_generation": 77,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, return True if the list is sorted in non-decreasing order, and False otherwise.\"\"\"\n    return nums == sorted(nums)\n\ndef g() -> List[int]:\n    \"\"\"Generate a list of integers.\"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == True\n",
        "idx_generation": 455,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(li: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, check if there are two numbers whose sum equals the target.\n    Sample input:\n    [1, 2, 3, 4, 5], 7\n    Sample output:\n    True\"\"\"\n    left = 0\n    right = len(li) - 1\n\n    while left < right:\n        current_sum = li[left] + li[right]\n\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5], 7\n\nassert f(*g())\n",
        "idx_generation": 443,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if there exists a subset of the numbers that add up to the target.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    \n    for i in range(n + 1):\n        dp[i][0] = True\n    \n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j < nums[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n    \n    return dp[n][target]\n\ndef g(nums: List[int], target: int) -> bool:\n    return f(nums, target)\n\nnums = [2, 4, 6, 8]\ntarget = 10\nassert f(nums, target) == g(nums, target)\n",
        "idx_generation": 131,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Determine if the decimal representation of n contains exactly k different digits.\"\"\"\n    digits = set(str(n))\n    return len(digits) == k\n\ndef g(n: int, k: int):\n    return int('1' * k)\n\nn = 111111\nk = 1\nassert f(g(n, k), k)\n",
        "idx_generation": 149,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], target: str) -> List[str]:\n    \"\"\"Given a list of words and a target word, find all words from the list that contain all the characters of the target word in any order.\"\"\"\n    def count_chars(word):\n        char_count = {}\n        for char in word:\n            char_count[char] = char_count.get(char, 0) + 1\n        return char_count\n    \n    target_char_count = count_chars(target)\n    result = []\n    \n    for word in words:\n        word_char_count = count_chars(word)\n        if all(word_char_count.get(char, 0) >= count for char, count in target_char_count.items()):\n            result.append(word)\n    \n    return result\n\ndef g(words: List[str], target: str) -> List[str]:\n    \"\"\"Return the list of words that contain all the characters of the target word in any order.\"\"\"\n    return words, target\n\nassert f(*g(words=[\"cat\", \"tac\", \"bat\", \"act\"], target=\"act\")) == [\"cat\", \"tac\", \"act\"]\n",
        "idx_generation": 303,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the sum of all the multiples of 3 or 5 below n.\"\"\"\n    def sum_multiples(n):\n        sum = 0\n        for i in range(n):\n            if i % 3 == 0 or i % 5 == 0:\n                sum += i\n        return sum\n    \n    return sum_multiples(n)\n\ndef g():\n    n = 100\n    return n\n\nassert f(g()) == 2318\n",
        "idx_generation": 393,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, return a new list where each element is the product of all the other elements in the original list.\"\"\"\n    product = 1\n    for num in nums:\n        product *= num\n    return [product // num for num in nums]\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == [120, 60, 40, 30, 24]\n",
        "idx_generation": 234,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, return True if there is a subarray with a sum equal to 0, False otherwise.\"\"\"\n    prefix_sum = set()\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum += num\n\n        if curr_sum == 0 or curr_sum in prefix_sum:\n            return True\n\n        prefix_sum.add(curr_sum)\n\n    return False\n\ndef g():\n    return [4, 2, -3, 1, 6]\n\nassert f(g()) == True\n",
        "idx_generation": 445,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of integers, determine if the matrix forms a magic square.\n    A matrix is a magic square if the sums of the elements in each row, each column, and both diagonals are the same.\"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])  # target sum for each row, column, and diagonal\n    \n    # check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != target_sum:\n            return False\n    \n    # check diagonal from top-left to bottom-right\n    if sum(matrix[i][i] for i in range(n)) != target_sum:\n        return False\n    \n    # check diagonal from top-right to bottom-left\n    if sum(matrix[i][n-i-1] for i in range(n)) != target_sum:\n        return False\n    \n    return True\n\ndef g(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"Generate a random 3x3 matrix with distinct integers from 1 to 9.\"\"\"\n    return matrix\n\nassert f(g([[2, 7, 6],\n            [9, 5, 1],\n            [4, 3, 8]]))\n",
        "idx_generation": 229,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of 0s and 1s, determine if there exists a path from the top-left corner to the bottom-right corner, only moving right or down. The path must go through the 1s and avoid the 0s.\"\"\"\n    m, n = len(grid), len(grid[0])\n    queue = [(0, 0)]\n    visited = set()\n    while queue:\n        i, j = queue.pop(0)\n        if (i, j) == (m-1, n-1):\n            return True\n        visited.add((i, j))\n        if i+1 < m and grid[i+1][j] == 1 and (i+1, j) not in visited:\n            queue.append((i+1, j))\n        if j+1 < n and grid[i][j+1] == 1 and (i, j+1) not in visited:\n            queue.append((i, j+1))\n    return False\n\ndef g():\n    grid = [\n        [1, 1, 1, 0, 0],\n        [0, 1, 1, 1, 0],\n        [0, 0, 0, 1, 1],\n        [1, 1, 1, 1, 1]\n    ]\n    return grid\n\nassert f(g())\n\n",
        "idx_generation": 366,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Given a list of integers and a target value, find if there exists a subset of the list that adds up to the target value.\"\"\"\n    def subset_sum(nums, target, i, curr_sum):\n        if curr_sum == target:\n            return True\n        if i >= len(nums) or curr_sum > target:\n            return False\n        \n        include = subset_sum(nums, target, i+1, curr_sum + nums[i])\n        exclude = subset_sum(nums, target, i+1, curr_sum)\n        \n        return include or exclude\n    \n    return subset_sum(nums, target, 0, 0)\n\ndef g(nums=[2, 4, 6, 8], target=10):\n    return nums\n\nassert f(g())\n",
        "idx_generation": 60,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool:\n    \"\"\"\n    Given a 2D grid of integers and the starting and ending positions, determine if it is possible to reach the\n    ending position from the starting position by moving only rightward, downward, or diagonally.\n    Return True if it is possible, otherwise return False.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    # Initialize the visited set\n    visited = set()\n\n    # Perform a depth-first search\n    def dfs(i: int, j: int) -> bool:\n        # Base case: reached the ending position\n        if (i, j) == end:\n            return True\n\n        # Mark the current position as visited\n        visited.add((i, j))\n\n        # Explore the neighboring positions\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx != 0 or dy != 0:\n                    ni = i + dx\n                    nj = j + dy\n                    if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in visited and grid[ni][nj] != 1:\n                        if dfs(ni, nj):\n                            return True\n\n        # No path found\n        return False\n\n    # Perform the depth-first search from the starting position\n    return dfs(start[0], start[1])\n\ndef g():\n    return [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n\nassert f(g(), (0, 0), (2, 2))\n",
        "idx_generation": 324,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str, pattern: str) -> bool:\n    \"\"\"Given a string and a pattern, determine if the pattern exists in the string.\n    The pattern can contain any number of '?' wildcards, which can be replaced with any single character.\"\"\"\n    if len(pattern) > len(string):\n        return False\n    if pattern == \"\":\n        return True\n    if pattern[0] == \"?\" or pattern[0] == string[0]:\n        return f(string[1:], pattern[1:])\n    return False\n\ndef g():\n    return \"programming\", \"pr?gramm?ng\"\n\nassert f(*g()) == True\n",
        "idx_generation": 252,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(a: int, b: int) -> int:\n    \"\"\"Calculate the bitwise XOR of two numbers a and b.\"\"\"\n    return a ^ b\n\ndef g():\n    return 5, 3\n\nassert f(*g()) == 6\n",
        "idx_generation": 106,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of numbers contains a subsequence that sums up to a target value\"\"\"\n    target = 10\n    return find_subsequence(nums, target, 0)\n\ndef find_subsequence(nums, target, index):\n    if target == 0:\n        return True\n    if index >= len(nums):\n        return False\n    return find_subsequence(nums, target - nums[index], index + 1) or find_subsequence(nums, target, index + 1)\n\ndef g(nums: List[int]) -> List[int]:\n    return nums\n\nnums = [1, 2, 3, 4, 5]\nassert f(g(nums))\n",
        "idx_generation": 89,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, k: int) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency matrix, determine if there is a path from the start node to the end node\n    with exactly k edges.\n    Return True if such a path exists, False otherwise.\n    \"\"\"\n    n = len(graph)\n\n    def dfs(node: int, edges: int) -> bool:\n        if node == end and edges == k:\n            return True\n        if edges > k:\n            return False\n        for neighbor in range(n):\n            if graph[node][neighbor] == 1 and dfs(neighbor, edges + 1):\n                return True\n        return False\n\n    return dfs(start, 0)\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a directed graph represented as an adjacency matrix.\"\"\"\n    graph = [[0, 1, 1, 0],\n             [0, 0, 0, 1],\n             [0, 0, 0, 1],\n             [0, 0, 0, 0]]\n    return graph, 0, 3, 2\n\nassert f(*g())\n",
        "idx_generation": 397,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph represented by an adjacency list and two nodes (start and end), \n    determine if there exists a path from the start node to the end node. \n    Return True if a path exists, False otherwise.\n    \"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a random graph represented by an adjacency list.\n    \"\"\"\n    graph = [[1, 2], [3], [], [4, 5], [2, 6], [7], [], []]\n    return graph\n\nassert f(g(), 0, 7)\n",
        "idx_generation": 170,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"Given an undirected graph represented as an adjacency matrix, check if the graph contains a cycle.\n    Return True if the graph contains a cycle, otherwise return False.\n\n    Example:\n    graph = [\n        [0, 1, 0, 0],\n        [1, 0, 1, 1],\n        [0, 1, 0, 1],\n        [0, 1, 1, 0]\n    ]\n    Output: True\n    Explanation: The graph contains a cycle 0 -> 1 -> 2 -> 3 -> 0.\n\n    \"\"\"\n    def dfs(node, visited, parent):\n        visited[node] = True\n        \n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1:\n                if visited[neighbor]:\n                    if neighbor != parent:\n                        return True\n                else:\n                    if dfs(neighbor, visited, node):\n                        return True\n        \n        return False\n    \n    visited = [False] * len(graph)\n    \n    for node in range(len(graph)):\n        if not visited[node]:\n            if dfs(node, visited, -1):\n                return True\n    \n    return False\n\ndef g():\n    return [\n        [0, 1, 0, 0],\n        [1, 0, 1, 1],\n        [0, 1, 0, 1],\n        [0, 1, 1, 0]\n    ]\n\nassert f(g()) == True\n",
        "idx_generation": 147,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: dict, start: int, end: int, path: str) -> bool:\n    \"\"\"Check if there is a path from start to end in the given graph, where the path matches a specific pattern.\n    The path is represented as a string, where each character represents a node in the graph.\n    Return True if there is a path that matches the given pattern, False otherwise.\"\"\"\n    visited = set()\n    stack = [(start, \"\")]\n    while stack:\n        node, current_path = stack.pop()\n        current_path += str(node)\n        if node == end and current_path == path:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend((neighbor, current_path) for neighbor in graph[node])\n    return False\n\ndef g():\n    return {1: [2, 3], 2: [4], 3: [5], 4: [], 5: []}\n\nassert f(g(), 1, 5, \"135\")\n",
        "idx_generation": 185,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, k: int) -> bool:\n    \"\"\"Given a string 's' and an integer 'k', determine if it is possible to form a palindrome by rearranging the characters of 's'\n    such that each character appears exactly k times in the resulting palindrome.\"\"\"\n    char_count = {}\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n\n    odd_count = 0\n    for count in char_count.values():\n        if count % 2 == 1:\n            odd_count += 1\n\n    return odd_count <= k\n\ndef g():\n    return \"aabbc\"\n\nassert f(g(), 2)\n",
        "idx_generation": 139,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Determine if there exists a combination of k integers from 1 to n that adds up to n.\"\"\"\n    def find_combination(curr_sum, start_index, k):\n        if curr_sum == n and k == 0:\n            return True\n        if curr_sum > n or k == 0:\n            return False\n        for i in range(start_index, n+1):\n            if find_combination(curr_sum + i, i+1, k-1):\n                return True\n        return False\n    return find_combination(0, 1, k)\n\ndef g(n=10, k=3):\n    return n, k\n\nassert f(*g())\n",
        "idx_generation": 138,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers that add up to the target value.\n    Return True if there exists such pair, and False otherwise.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return True\n        \n        if current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    return [-2, 1, 3, 5, 7, 9]\n\nassert f(g(), 10)\n",
        "idx_generation": 14,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list that sum up to the target value.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    nums = [2, 4, 6, 8, 10]\n    target = 12\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 266,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there are three numbers in the given list that sum up to the target value\"\"\"\n    nums.sort()\n    n = len(nums)\n    for i in range(n-2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            if current_sum == target:\n                return True\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g(target=10):\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), target=10)\n",
        "idx_generation": 80,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Given a string s and an integer k, determine if it is possible to rearrange the characters in s\n    such that no two adjacent characters are the same and the resulting string has at least k unique characters.\n    Return True if it is possible, False otherwise.\n    Example:\n    s = \"aabbc\"\n    k = 3\n    The possible rearrangements are \"abcab\", \"acbac\", \"bacab\", \"bcaba\", \"cabac\", \"cbaba\".\n    All of these rearrangements have at least 3 unique characters and no adjacent characters are the same.\n    Therefore, the answer is True.\n    \"\"\"\n    frequency = {}\n    for char in s:\n        frequency[char] = frequency.get(char, 0) + 1\n    sorted_chars = sorted(frequency.keys(), key=lambda x: frequency[x], reverse=True)\n    unique_chars = len(sorted_chars)\n    if unique_chars < k:\n        return False\n    max_count = frequency[sorted_chars[0]]\n    if max_count > (len(s) + 1) // 2:\n        return False\n    return True\ndef g():\n    return \"aabbc\", 3\nassert f(*g())\n",
        "idx_generation": 45,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the smallest positive integer that is divisible by all the numbers from 1 to n.\"\"\"\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    \n    def lcm(a, b):\n        return a * b // gcd(a, b)\n    \n    def smallestMultiple(n):\n        multiple = 1\n        for i in range(1, n + 1):\n            multiple = lcm(multiple, i)\n        return multiple\n    \n    return smallestMultiple(n)\n\ndef g():\n    n = 10\n    return n\n\nassert f(g()) == 2520\n",
        "idx_generation": 461,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import itertools\nfrom typing import*\ndef f(arr: List[int], k=3) -> bool:\n    \"\"\"Determine if there are exactly k elements in the given array that sum up to zero.\"\"\"\n    from itertools import combinations\n    for comb in combinations(arr, k):\n        if sum(comb) == 0:\n            return True\n    return False\n\ndef g(k=3):\n    return [1, -2, 3, -4, 5, -6, 7, -8, 9, -10] * k\n\nassert f(g())\n",
        "idx_generation": 467,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Given a list of integers and a target integer k, find if there exists a subset of the list whose sum is divisible by k.\n    Return True if such subset exists, otherwise return False.\n    Sample input:\n    nums = [4, 7, 2, 9, 5, 1, 8]\n    k = 3\n    Sample output:\n    True\"\"\"\n    n = len(nums)\n    dp = [[False for _ in range(k)] for _ in range(n+1)]\n    dp[0][0] = True\n\n    for i in range(1, n+1):\n        for j in range(k):\n            dp[i][j] = dp[i-1][j]\n            if dp[i-1][j]:\n                dp[i][(j+nums[i-1]) % k] = True\n\n    return dp[n][0]\n\ndef g():\n    return ([4, 7, 2, 9, 5, 1, 8], 3)\n\nassert f(*g()) == True\n",
        "idx_generation": 131,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, s: str) -> bool:\n    \"\"\"Check if the given number is a perfect square and if the given string contains only unique characters.\"\"\"\n    is_perfect_square = int(n ** 0.5) ** 2 == n\n    is_unique_chars = len(set(s)) == len(s)\n\n    return is_perfect_square and is_unique_chars\n\ndef g():\n    n = 25\n    s = 'abcdefg'\n    return n, s\n\nassert f(*g())\n",
        "idx_generation": 158,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string, determine if it is a palindrome after removing exactly one character.\"\"\"\n    def is_palindrome(s, left, right):\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n    \n    left, right = 0, len(s) - 1\n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s, left + 1, right) or is_palindrome(s, left, right - 1)\n        left += 1\n        right -= 1\n    return True\n\ndef g():\n    return \"abca\"\n\nassert f(g()) == True\n",
        "idx_generation": 313,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(s: str) -> bool:\n    \"\"\"Given a string 's' consisting of parentheses ( and ), determine if the parentheses are balanced.\n    Return True if the parentheses are balanced, False otherwise.\"\"\"\n    stack = deque()\n\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n\n    return len(stack) == 0\n\ndef g() -> str:\n    \"\"\"Generate a string consisting of parentheses.\"\"\"\n    s = \"((())())\"\n    return s\n\nassert f(g())\n",
        "idx_generation": 403,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of non-empty subsequences with even sum.\n    \"\"\"\n    count = 0\n    freq = {0: 1}\n    for num in nums:\n        freq[num] = freq.get(num, 0) + 1\n        count += freq.get(0, 0)\n        count += freq.get(num ^ 1, 0)\n    return count\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    \"\"\"\n    Generate a list of integers where the number of non-empty subsequences with even sum is non-zero.\n    \"\"\"\n    return nums\n\nassert f(g()) > 0\n",
        "idx_generation": 277,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, find the maximum sum of a subarray where the sum is a perfect square.\n    \n    Return True if such a subarray exists, False otherwise.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum += num\n        if current_sum < 0:\n            current_sum = 0\n        if current_sum > max_sum and int(current_sum**0.5)**2 == current_sum:\n            max_sum = current_sum\n    \n    return max_sum != float('-inf')\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g())\n",
        "idx_generation": 463,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Find the maximum value in a 2D matrix\"\"\"\n    max_value = float(\"-inf\")\n    for row in matrix:\n        for num in row:\n            if num > max_value:\n                max_value = num\n    return max_value\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 9\n",
        "idx_generation": 234,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num_list: List[int], target_sum: int) -> bool:\n    \"\"\"Given a list of integers 'num_list' and a target sum 'target_sum', determine if there exists a combination of numbers in 'num_list' that adds up to the target sum.\"\"\"\n    stack = [(0, 0)]\n    while stack:\n        curr_sum, index = stack.pop()\n        if curr_sum == target_sum:\n            return True\n        if index < len(num_list):\n            stack.append((curr_sum, index + 1))\n            stack.append((curr_sum + num_list[index], index + 1))\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5], 9\n\nassert f(*g())\n",
        "idx_generation": 376,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int, target_sum: int) -> bool:\n    \"\"\"Given integers n, k, and target_sum, determine if it is possible to choose k integers from the range [1, n] such that their sum is equal to target_sum.\n    Return True if it is possible, False otherwise.\n    \"\"\"\n    if k > n or target_sum > k * n or target_sum < k:\n        return False\n    dp = [[False] * (target_sum + 1) for _ in range(k + 1)]\n    dp[0][0] = True\n    for i in range(1, k + 1):\n        for j in range(1, target_sum + 1):\n            dp[i][j] = dp[i - 1][j - 1] or dp[i][j - 1] or dp[i - 1][j]\n    return dp[k][target_sum]\n\ndef g(n=10, k=3, target_sum=15):\n    return n, k, target_sum\n\nassert f(*g())\n",
        "idx_generation": 62,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers n and m, find the number of unique paths from the top-left corner to the bottom-right corner of an n x m grid.\n    You can only move either down or right at any point in time.\n    - n: number of rows in the grid\n    - m: number of columns in the grid\n    - return: number of unique paths\n    \"\"\"\n    if n == 1 or m == 1:\n        return 1\n    \n    dp = [[1] * m] + [[1] + [0] * (m - 1) for _ in range(n - 1)]\n    \n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    \n    return dp[n - 1][m - 1]\n\ndef g():\n    return (3, 3)\n\nassert f(*g()) == 6\n",
        "idx_generation": 326,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(words: List[str], target_word: str) -> bool:\n    \"\"\"\n    Determine if it is possible to form the target word by concatenating strings from the given list of words,\n    without using any word more than once.\n    \"\"\"\n    word_set = set(words)\n    n = len(target_word)\n    dp = [False] * (n + 1)\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and target_word[j:i] in word_set:\n                dp[i] = True\n                break\n\n    return dp[n]\n\n\ndef g(words=[\"apple\", \"pen\", \"applepen\", \"pine\", \"pineapple\"], target_word=\"pineapplepenapple\"):\n    return words\n\n\nassert f(g(), target_word=\"pineapplepenapple\")\n",
        "idx_generation": 258,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if the target number exists in the array after performing bitwise OR operations on its elements.\"\"\"\n    for num in arr:\n        if num | target == target:\n            return True\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), 7)\n",
        "idx_generation": 109,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> List[int]:\n    \"\"\"Generate the first n terms of the Fibonacci sequence.\"\"\"\n    fib = [0, 1]\n    for i in range(2, n):\n        fib.append(fib[i-1] + fib[i-2])\n    return fib\n\ndef g(n=10):\n    return n\n\nassert f(g()) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
        "idx_generation": 102,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Determine if a given graph is a directed acyclic graph (DAG).\n    A graph is a DAG if it has no directed cycles.\n    The input graph is represented as an adjacency matrix, where graph[i][j] = 1 indicates an edge from node i to node j.\n    Return True if the graph is a DAG, otherwise return False.\n    \"\"\"\n\n    def dfs(node):\n        visited[node] = True\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] == 1:\n                if visited[neighbor]:\n                    return False\n                if not dfs(neighbor):\n                    return False\n        visited[node] = False\n        return True\n\n    visited = [False] * len(graph)\n    for node in range(len(graph)):\n        if not visited[node]:\n            if not dfs(node):\n                return False\n    return True\n\ndef g():\n    return [[0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1],\n            [0, 0, 0, 0]]\n\nassert f(g())\n",
        "idx_generation": 431,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there is a path from the start node to the end node in the given graph\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g(graph={0: [1, 2], 1: [3], 2: [4], 3: [5], 4: [], 5: []}, start=0, end=5):\n    \"\"\"Return the given graph, start node, and end node\"\"\"\n    return graph, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 180,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"Check if a given graph is a tree.\"\"\"\n    n = len(graph)\n    visited = [False] * n\n    \n    def dfs(node, parent):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node):\n                    return True\n            elif neighbor != parent:\n                return True\n        return False\n    \n    if dfs(0, -1):\n        return False\n    \n    for i in range(n):\n        if not visited[i]:\n            return False\n    \n    return True\n\ndef g():\n    \"\"\"Generate a graph.\"\"\"\n    graph = [[1, 2], [0, 3], [0, 4], [1, 5], [2], [3]]\n    return graph\n\nassert f(g())\n",
        "idx_generation": 151,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the minimum number of steps required to reach the target position from the starting position in a grid, \n    where each cell contains a value representing the number of steps that can be taken from that cell.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    return dfs(grid, 0, 0, rows, cols)\n\ndef dfs(grid, i, j, rows, cols):\n    if i < 0 or i >= rows or j < 0 or j >= cols:\n        return float('inf')\n    if i == rows - 1 and j == cols - 1:\n        return 0\n    if grid[i][j] == 0:\n        return float('inf')\n    temp = grid[i][j]\n    grid[i][j] = 0\n    min_steps = min(dfs(grid, i + temp, j, rows, cols), dfs(grid, i - temp, j, rows, cols),\n                    dfs(grid, i, j + temp, rows, cols), dfs(grid, i, j - temp, rows, cols))\n    grid[i][j] = temp\n    return 1 + min_steps\n\ndef g(grid: List[List[int]]) -> int:\n    return f(grid)\n\ngrid = [[2, 8, 3], [1, 0, 2], [3, 7, 1]]\nassert f(grid) == g(grid)\n",
        "idx_generation": 230,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"Given a list of integers, generate all possible subsets of the list.\n    Return a list of lists, where each inner list represents a subset.\n    Example:\n    nums = [1, 2, 3]\n    The subsets are [], [1], [2], [3], [1, 2], [1, 3], [2, 3], and [1, 2, 3].\n    Therefore, the answer is [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]].\n    \"\"\"\n    subsets = [[]]\n    for num in nums:\n        subsets += [subset + [num] for subset in subsets]\n    return subsets\n\ndef g():\n    return [1, 2, 3]\n\nassert f(g()) == [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]\n",
        "idx_generation": 141,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k=3) -> bool:\n    \"\"\"Check if a string can be divided into k non-empty equal sum subsequences.\"\"\"\n    def can_partition(nums, k, current_sum, target_sum, used, start_index):\n        if k == 1:\n            return True\n        if current_sum == target_sum:\n            return can_partition(nums, k-1, 0, target_sum, used, 0)\n        for i in range(start_index, len(nums)):\n            if not used[i] and current_sum + nums[i] <= target_sum:\n                used[i] = True\n                if can_partition(nums, k, current_sum + nums[i], target_sum, used, i+1):\n                    return True\n                used[i] = False\n        return False\n\n    nums = []\n    for c in s:\n        nums.append(ord(c) - ord('a') + 1)\n    \n    total_sum = sum(nums)\n    if total_sum % k != 0:\n        return False\n    \n    target_sum = total_sum // k\n    used = [False] * len(nums)\n    \n    return can_partition(nums, k, 0, target_sum, used, 0)\n\ndef g(s=\"abcdabcda\"):\n    return s\n\nassert f(g())\n",
        "idx_generation": 144,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers, find the index of the target number using binary search.\n    If the target number is not in the list, return -1.\n    \n    Sample input:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 5\n    \n    Sample output:\n    4\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9], 5\n\nassert f(*g()) == 4\n",
        "idx_generation": 17,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Given a matrix of integers and a target number, determine if the target number exists in the matrix.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    row = 0\n    col = cols - 1\n\n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] > target:\n            col -= 1\n        else:\n            row += 1\n    \n    return False\n\ndef g(matrix=[[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]], target=5):\n    return matrix, target\n\nassert f(*g())\n",
        "idx_generation": 283,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers `arr` and a target integer `target`,\n    find the index of the target if it exists in the list. If the target\n    does not exist in the list, return -1.\n    \"\"\"\n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return -1\n\ndef g(arr: List[int], target: int):\n    \"\"\"\n    Generate a sorted list of integers `arr` and a target integer `target`\n    such that the index of the target can be found using binary search.\n    \"\"\"\n    arr = sorted(arr)\n    return arr, target\n\nassert f(*g([1, 2, 3, 4, 5], 3)) == 2\n",
        "idx_generation": 85,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the given array is a palindrome, meaning it reads the same forwards and backwards.\"\"\"\n    return arr == arr[::-1]\n\ndef g():\n    return [1, 2, 3, 2, 1]\n\nassert f(g())\n",
        "idx_generation": 67,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum product of any three elements in the list.\"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 60\n",
        "idx_generation": 467,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Given a list of integers, check if the list is a permutation of the numbers from 1 to n, where n is the length of the list.\"\"\"\n    return sorted(arr) == list(range(1, len(arr) + 1))\n\ndef g():\n    return [3, 1, 4, 2]\n\nassert f(g())\n",
        "idx_generation": 480,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence in the list.\"\"\"\n    n = len(nums)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"Generate a list of integers from the given list that represents the longest increasing subsequence.\"\"\"\n    n = len(nums)\n    dp = [1] * n\n    prev = [-1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j] and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n                prev[i] = j\n    \n    max_len = max(dp)\n    idx = dp.index(max_len)\n    lis = []\n    while idx != -1:\n        lis.append(nums[idx])\n        idx = prev[idx]\n    \n    return lis[::-1]\n\nassert f(g(nums=[3, 4, -1, 0, 6, 2, 3])) == 4\n",
        "idx_generation": 133,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Find the number of ways to divide a string of length n into k non-empty substrings\"\"\"\n    return n % k == 0\ndef g(n=8, k=4):\n    return n, k\nassert f(*g())\n",
        "idx_generation": 160,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Check if it is possible to construct a string of length n using only the characters 'a', 'b', and 'c', such that there are exactly k occurrences of the substring 'abc'.\"\"\"\n    def backtrack(s, count_abc):\n        if len(s) == n:\n            return count_abc == k\n\n        if count_abc < k and backtrack(s + 'abc', count_abc + 1):\n            return True\n\n        if backtrack(s + 'a', count_abc):\n            return True\n\n        if backtrack(s + 'b', count_abc):\n            return True\n\n        if backtrack(s + 'c', count_abc):\n            return True\n\n        return False\n\n    return backtrack('', 0)\n\ndef g():\n    n = 9\n    k = 3\n    return n, k\n\nassert f(*g())\n",
        "idx_generation": 318,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\nfrom typing import List\n\ndef f(arr: List[int], k=3) -> bool:\n    \"\"\"Given a list of integers arr and an integer k, determine if there exists a subarray of length k\n    such that the sum of all elements in the subarray is divisible by k.\n    Return True if such a subarray exists, otherwise return False.\n    \"\"\"\n    def is_divisible_by_k(sub_arr):\n        return sum(sub_arr) % k == 0\n    \n    for i in range(len(arr) - k + 1):\n        sub_arr = arr[i:i+k]\n        if is_divisible_by_k(sub_arr):\n            return True\n    return False\n\ndef g(k=3):\n    return [1, 2, 3, 4, 5, 6, 7, 8]\n\nassert f(g())\n",
        "idx_generation": 412,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, find the majority element, which appears more than n/2 times where n is the length of the list.\n    Return True if a majority element exists, False otherwise.\n    \"\"\"\n    count = 0\n    candidate = None\n    \n    for num in nums:\n        if count == 0:\n            candidate = num\n        count += 1 if num == candidate else -1\n    \n    return nums.count(candidate) > len(nums) // 2\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers containing a majority element.\n    \"\"\"\n    return [1, 2, 2, 2, 3, 4, 2, 2, 2, 5, 2]\n\nassert f(g()) == True\n",
        "idx_generation": 286,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], k=3) -> bool:\n    \"\"\"Given a list of integers, find if there exists a subset of the integers with a sum divisible by k\"\"\"\n    def subset_sum(nums, target):\n        n = len(nums)\n        dp = [[False] * (target + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][0] = True\n        for i in range(1, n + 1):\n            for j in range(1, target + 1):\n                if nums[i - 1] <= j:\n                    dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        return dp[n][target]\n    return subset_sum(nums, sum(nums) % k)\ndef g(k=3):\n    return [1, 2, 3, 4, 5, 6]\nassert f(g())\n",
        "idx_generation": 478,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given an m x n matrix of integers, check if it is a saddle point matrix.\"\"\"\n    m, n = len(matrix), len(matrix[0])\n    for i in range(m):\n        for j in range(n):\n            num = matrix[i][j]\n            row_max = max(matrix[i])\n            col_min = min(matrix[k][j] for k in range(m))\n            if num == row_max and num == col_min:\n                return True\n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a matrix of integers.\"\"\"\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 243,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport heapq\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, find the minimum cost to reach the bottom-right cell from the top-left cell\n    by moving only down or right. Each cell represents the cost to move to that cell.\"\"\"\n    m, n = len(grid), len(grid[0])\n    costs = [[float('inf')] * n for _ in range(m)]\n    costs[0][0] = grid[0][0]\n    heap = [(costs[0][0], 0, 0)]\n    \n    while heap:\n        cost, row, col = heapq.heappop(heap)\n        \n        if row == m - 1 and col == n - 1:\n            return cost\n        \n        for dr, dc in [(1, 0), (0, 1)]:\n            new_row, new_col = row + dr, col + dc\n            if 0 <= new_row < m and 0 <= new_col < n:\n                new_cost = cost + grid[new_row][new_col]\n                if new_cost < costs[new_row][new_col]:\n                    costs[new_row][new_col] = new_cost\n                    heapq.heappush(heap, (new_cost, new_row, new_col))\n    \n    return -1\n\ndef g():\n    return [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\nassert f(g()) == 7\n\n",
        "idx_generation": 379,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a 2D grid of integers, find the sum of all numbers in the grid by traversing from the top-left cell to the bottom-right cell.\n    You can only move down or right at each step.\n    Return the sum of all numbers.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    \n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a 2D grid of integers.\"\"\"\n    grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 62,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\"\"\"\n    def unique_paths_helper(row: int, col: int) -> int:\n        if row == n-1 and col == n-1:\n            return 1\n        if row >= n or col >= n:\n            return 0\n        return unique_paths_helper(row+1, col) + unique_paths_helper(row, col+1)\n\n    return unique_paths_helper(0, 0)\n\ndef g():\n    n = 3\n    return n\n\nassert f(g()) == 6\n",
        "idx_generation": 387,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target_length=10) -> bool:\n    \"\"\"Check if a string can be transformed into target length using only concatenation and repetition.\"\"\"\n    if len(s) == target_length:\n        return True\n    elif len(s) > target_length:\n        return False\n    else:\n        return f(s + s, target_length) or f(s + 'A', target_length)\n\ndef g(target_length=10):\n    \"\"\"Find a string that can be transformed into target length using only concatenation and repetition.\"\"\"\n    return 'A'\n\nassert f(g())\n",
        "idx_generation": 321,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"Given a positive integer, find the number of set bits (1s) in its binary representation.\n    Return the count of set bits.\"\"\"\n    count = 0\n    while num > 0:\n        count += num & 1\n        num >>= 1\n    return count\n\ndef g(num: int) -> int:\n    \"\"\"Generate a positive integer, where the number of set bits (1s) in its binary representation is greater than 1.\"\"\"\n    return num + 2\n\nassert f(g(num=5)) > 1\n",
        "idx_generation": 122,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the nth Fibonacci number.\"\"\"\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    return f(n - 1) + f(n - 2)\n\ndef g(n: int) -> int:\n    return f(n)\n\nn = 6\nassert f(n) == g(n)\n",
        "idx_generation": 104,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the given list is a valid max heap\"\"\"\n    n = len(arr)\n    for i in range(n):\n        left = 2 * i + 1\n        right = 2 * i + 2\n\n        if left < n and arr[i] < arr[left]:\n            return False\n\n        if right < n and arr[i] < arr[right]:\n            return False\n\n    return True\n\ndef g():\n    arr = [9, 7, 6, 5, 4, 3, 2, 1]\n    return arr\n\nassert f(g())\n",
        "idx_generation": 448,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Determine if there exists a path from start to end in a given graph\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g():\n    return [[1, 2], [2, 3], [3, 4], [4], []]\n\nassert f(g(), 0, 4)\n",
        "idx_generation": 187,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(num_courses: int, prerequisites: List[List[int]]) -> bool:\n    \"\"\"Given the total number of courses and a list of prerequisite pairs, return whether it is possible to\n    finish all courses.\"\"\"\n    # Create a graph to represent the courses and their prerequisites\n    graph = [[] for _ in range(num_courses)]\n    for course, prereq in prerequisites:\n        graph[course].append(prereq)\n    \n    # Create an array to track the status of each course: 0 - not visited, 1 - visiting, 2 - visited\n    status = [0] * num_courses\n    \n    # Perform depth-first search on each course\n    for course in range(num_courses):\n        if not dfs(graph, status, course):\n            return False\n    \n    return True\n\ndef dfs(graph: List[List[int]], status: List[int], course: int) -> bool:\n    # If the status of the course is 1, it means there is a cycle\n    if status[course] == 1:\n        return False\n    \n    # If the status of the course is 2, it means it has been visited before\n    if status[course] == 2:\n        return True\n    \n    # Mark the course as visiting\n    status[course] = 1\n    \n    # Perform depth-first search on the prerequisites\n    for prereq in graph[course]:\n        if not dfs(graph, status, prereq):\n            return False\n    \n    # Mark the course as visited\n    status[course] = 2\n    \n    return True\n\ndef g():\n    num_courses = 4\n    prerequisites = [[1,0],[2,1],[3,2]]\n    \n    return (num_courses, prerequisites)\n\nassert f(*g())\n",
        "idx_generation": 156,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there exists a path from the start node to the end node in a given directed graph.\"\"\"\n    def dfs(node, visited):\n        visited.add(node)\n        if node == end:\n            return True\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited):\n                    return True\n        return False\n\n    visited = set()\n    return dfs(start, visited)\n\ndef g():\n    graph = {\n        1: [2, 3],\n        2: [4],\n        3: [5],\n        4: [6],\n        5: [6],\n        6: [7],\n        7: []\n    }\n    start = 1\n    end = 7\n    return graph, start, end\n\nassert f(*g())\n",
        "idx_generation": 253,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\nfrom math import factorial\n\ndef f(n: int) -> int:\n    \"\"\"Calculate the number of permutations of a given number\"\"\"\n    return factorial(n)\n\ndef g(n: int = 5):\n    return n\n\nassert f(g()) == 120\n",
        "idx_generation": 154,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=20) -> bool:\n    \"\"\"Given a list of integers and a target number,\n    find a combination of numbers from the list that sums up to the target.\n    Return True if such a combination exists, otherwise return False.\n    \"\"\"\n    def backtrack(index, curr_sum):\n        if curr_sum == target:\n            return True\n        if curr_sum > target or index >= len(nums):\n            return False\n        if backtrack(index + 1, curr_sum + nums[index]):\n            return True\n        return backtrack(index + 1, curr_sum)\n    \n    return backtrack(0, 0)\n\ndef g(target=20):\n    return [5, 10, 15, 2, 7, 3]\n\nassert f(g())\n",
        "idx_generation": 145,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given an unsorted array of integers, return a new array with all duplicates removed.\n    The resulting array should be sorted in ascending order.\n    \"\"\"\n    return sorted(list(set(arr)))\n\ndef g(arr: List[int]):\n    \"\"\"\n    Generate an unsorted array of integers with some duplicate values.\n    \"\"\"\n    return arr\n\nassert f(g([3, 1, 2, 2, 5, 3, 4, 4, 1])) == [1, 2, 3, 4, 5]\n",
        "idx_generation": 19,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(numbers: List[int]) -> List[int]:\n    \"\"\"Sort a list of integers in ascending order using the bubble sort algorithm.\n    Return the sorted list.\"\"\"\n    \n    def bubble_sort(numbers):\n        n = len(numbers)\n        for i in range(n-1):\n            for j in range(n-i-1):\n                if numbers[j] > numbers[j+1]:\n                    numbers[j], numbers[j+1] = numbers[j+1], numbers[j]\n    \n    sorted_numbers = numbers[:]\n    bubble_sort(sorted_numbers)\n    \n    return sorted_numbers\n\ndef g():\n    return [5, 2, 8, 1, 9, 3, 6]\n\nassert f(g()) == [1, 2, 3, 5, 6, 8, 9]\n",
        "idx_generation": 287,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Given a matrix and a target number, determine if the target number exists in the matrix.\n       The matrix is sorted row-wise and column-wise in ascending order.\"\"\"\n\n    def search(matrix, target, row, col):\n        if row >= len(matrix) or col < 0:\n            return False\n        if matrix[row][col] == target:\n            return True\n        if matrix[row][col] > target:\n            return search(matrix, target, row, col-1)\n        if matrix[row][col] < target:\n            return search(matrix, target, row+1, col)\n\n    return search(matrix, target, 0, len(matrix[0])-1)\n\ndef g():\n    matrix = [[1, 4, 7, 11],\n              [2, 5, 8, 12],\n              [3, 6, 9, 16],\n              [10, 13, 14, 17]]\n    target = 9\n    return matrix, target\n\nassert f(*g())\n",
        "idx_generation": 90,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Given a list of integers and a target value, find a pair of numbers in the list that add up to the target value.\n    \n    Example:\n    nums = [2, 4, 6, 8, 10]\n    target = 14\n    The pair of numbers (4, 10) add up to the target value, so the output should be True.\n    \n    nums = [2, 4, 6, 8, 10]\n    target = 13\n    There is no pair of numbers that add up to the target value, so the output should be False.\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    return [2, 4, 6, 8, 10]\n\nassert f(g(), 14) == True\n",
        "idx_generation": 87,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target value using binary search.\n    Return -1 if the target is not found.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g():\n    return [-10, -5, 0, 3, 7, 9, 11, 15], 7\n\nassert f(*g()) == 4\n",
        "idx_generation": 471,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the second largest element in the list.\"\"\"\n    first = float('-inf')\n    second = float('-inf')\n    \n    for num in nums:\n        if num > first:\n            second = first\n            first = num\n        elif num > second and num != first:\n            second = num\n    \n    return second\n\ndef g() -> List[int]:\n    \"\"\"Generate a list of integers.\"\"\"\n    nums = [5, 8, 3, 0, 12, 9, 6, 2]\n    return nums\n\nassert f(g()) == 9\n",
        "idx_generation": 495,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> List[int]:\n    \"\"\"Generate the first n numbers in the Fibonacci sequence.\"\"\"\n    fib = [0, 1]\n    for i in range(2, n):\n        fib.append(fib[i-1] + fib[i-2])\n    return fib\n\ndef g():\n    return 10\n\nassert f(g()) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
        "idx_generation": 161,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the given array is a palindrome or can be rearranged into a palindrome.\"\"\"\n    counts = {}\n    for num in arr:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n    \n    odd_count = 0\n    for count in counts.values():\n        if count % 2 != 0:\n            odd_count += 1\n    \n    return odd_count <= 1\n\ndef g(arr=[1, 2, 3, 4, 5, 5, 4, 3, 2, 1]):\n    \"\"\"Generate an array of integers.\"\"\"\n    return arr\n\nassert f(g())\n",
        "idx_generation": 175,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a subsequence of length 3 where the middle element is the average of the first and last elements.\n    Return True if such subsequence exists, False otherwise.\"\"\"\n    n = len(nums)\n    for i in range(n - 2):\n        for j in range(i + 2, n):\n            avg = (nums[i] + nums[j]) / 2\n            if avg in nums[i+1:j]:\n                return True\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 325,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers and a target value, return the indices of two numbers such that they add up to the target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    Sample Input:\n    nums = [2, 7, 11, 15], target = 9\n    Sample Output:\n    [0, 1]\n    Explanation: The sum of nums[0] and nums[1] is 9, so the indices are [0, 1].\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find the indices of two numbers in a given list of integers that add up to the target value.\"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\nassert f(nums=[2, 7, 11, 15], target=9) == g(nums=[2, 7, 11, 15], target=9)\n",
        "idx_generation": 490,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a pair of numbers whose sum is a power of 2.\"\"\"\n    powers_of_2 = set(2 ** i for i in range(31))\n\n    for num in nums:\n        if num in powers_of_2:\n            return True\n        for power in powers_of_2:\n            if power - num in powers_of_2:\n                return True\n    return False\n\ndef g():\n    return [1, 3, 5, 7, 9, 11]\n\nassert f(g())\n",
        "idx_generation": 316,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if it is possible to obtain the target number by selecting a subset of the list and taking the sum of its elements.\n    Return True if there exists a subset with a sum equal to the target number, and False otherwise.\n    Sample Input:\n    nums = [2, 4, 6, 8]\n    target = 10\n    Sample Output:\n    True\"\"\"\n    n = len(nums)\n    dp = [[False for _ in range(target + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j < nums[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n\n    return dp[n][target]\n\ndef g():\n    return [2, 4, 6, 8], 10\n\nassert f(*g())\n",
        "idx_generation": 489,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers 'nums' and a target value 'target',\n    find two numbers in the list that add up to the target value.\n    Return the indices of the two numbers as a list.\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    The numbers 2 and 7 add up to the target value 9,\n    so the output should be [0, 1].\n    \"\"\"\n    num_map = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    \n    return []\n\ndef g() -> List[int]:\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 282,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers 'nums', determine if the list is palindrome or not using a stack.\"\"\"\n    stack = []\n    for num in nums:\n        stack.append(num)\n    for num in nums:\n        if num != stack.pop():\n            return False\n    return True\n\ndef g():\n    return [1, 2, 3, 2, 1]\n\nassert f(g())\n",
        "idx_generation": 418,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of ways to reach the Nth step of a staircase, where each step can be climbed\n    by either 1 or 2 steps at a time.\n    Return the total number of distinct ways to reach the Nth step.\"\"\"\n    \n    if n <= 1:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    \n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    \n    return dp[n]\n\ndef g():\n    return 5\n\nassert f(g()) == 8\n",
        "idx_generation": 65,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\n    You can only move either down or right at any point in time.\n    Return the number of unique paths.\n    \"\"\"\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][0] = 1\n        dp[0][i] = 1\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    return dp[n - 1][n - 1]\n\ndef g():\n    n = 3\n    return n\n\nassert f(g()) == 6\n",
        "idx_generation": 390,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], target: str) -> bool:\n    \"\"\"Given a list of words and a target word, determine if the target word can be formed by concatenating two or more words from the list.\"\"\"\n    def dfs(words: List[str], target: str, start: int, count: int) -> bool:\n        if start == len(target):\n            return True\n        for i in range(start, len(target)):\n            if target[start:i+1] in words:\n                if dfs(words, target, i+1, count+1):\n                    return True\n        return False\n\n    return dfs(words, target, 0, 0)\n\ndef g() -> List[str]:\n    \"\"\"Generate a list of words and a target word.\"\"\"\n    words = [\"apple\", \"pen\", \"applepen\", \"pine\", \"pineapple\"]\n    target = \"pineapplepen\"\n    return words, target\n\nassert f(*g())\n",
        "idx_generation": 331,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"Count the number of set bits (1s) in the binary representation of the given number.\"\"\"\n    count = 0\n    while num:\n        count += num & 1\n        num >>= 1\n    return count\n\ndef g():\n    num = 42\n    return num\n\nassert f(g()) == 3\n",
        "idx_generation": 156,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, return True if there exists a subsequence whose sum is divisible by 5.\n    Return False otherwise.\"\"\"\n    n = len(nums)\n    dp = [[False] * (5) for _ in range(n+1)]\n    \n    dp[0][0] = True\n    \n    for i in range(1, n+1):\n        for j in range(5):\n            dp[i][j] = dp[i-1][j]\n            if dp[i-1][(j - nums[i-1] % 5 + 5) % 5]:\n                dp[i][j] = True\n    \n    return dp[n][0]\n\ndef g() -> List[int]:\n    \"\"\"Generate a list of integers.\"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g()) == True\n",
        "idx_generation": 116,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(adj_matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"Given an adjacency matrix representing a directed graph, return the transpose of the graph.\"\"\"\n    transpose = [[0] * len(adj_matrix) for _ in range(len(adj_matrix))]\n    \n    for i in range(len(adj_matrix)):\n        for j in range(len(adj_matrix)):\n            transpose[j][i] = adj_matrix[i][j]\n    \n    return transpose\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate an adjacency matrix for a directed graph.\"\"\"\n    return [[0, 1, 1, 0], [0, 0, 1, 1], [0, 0, 0, 1], [1, 0, 0, 0]]\n\nassert f(g()) == [[0, 0, 0, 1], [1, 0, 0, 0], [1, 1, 0, 0], [0, 1, 1, 0]]\n",
        "idx_generation": 455,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there is a path from start to end in a given graph\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g():\n    graph = [[1, 2], [3], [4], [5], [6], [7], []]\n    start = 0\n    end = 7\n    return graph, start, end\n\nassert f(*g())\n\n",
        "idx_generation": 197,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, k: int) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency matrix, determine if there is a path from start to end with at most k edges.\"\"\"\n    \n    def dfs(graph: List[List[int]], curr: int, end: int, k: int) -> bool:\n        \"\"\"Depth-first search to find a path from curr to end with at most k edges.\"\"\"\n        \n        if k == 0 and curr == end:\n            return True\n        \n        if k <= 0:\n            return False\n        \n        for neighbor in range(len(graph[curr])):\n            if graph[curr][neighbor] == 1:\n                if dfs(graph, neighbor, end, k - 1):\n                    return True\n        \n        return False\n    \n    return dfs(graph, start, end, k)\n\ndef g():\n    graph = [[0, 1, 1, 0, 0],\n             [0, 0, 0, 1, 0],\n             [0, 0, 0, 1, 1],\n             [0, 0, 0, 0, 1],\n             [0, 0, 0, 0, 0]]\n    start = 0\n    end = 4\n    k = 3\n    return graph, start, end, k\n\nassert f(*g())\n",
        "idx_generation": 162,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency matrix, determine if there is a path from start to end.\"\"\"\n    visited = set()\n    return dfs(graph, start, end, visited)\n\ndef dfs(graph, curr, end, visited):\n    if curr == end:\n        return True\n    visited.add(curr)\n    for neighbor in graph[curr]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, end, visited):\n                return True\n    return False\n\ndef g():\n    return [[1, 2], [2, 3], [3], []]\n\nassert f(g(), 0, 3) == True\n\n",
        "idx_generation": 265,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k=3) -> bool:\n    \"\"\"Find the number of ways to choose k items out of n distinct items\"\"\"\n    def factorial(n: int) -> int:\n        if n == 0 or n == 1:\n            return 1\n        return n * factorial(n - 1)\n    \n    return factorial(n) // (factorial(k) * factorial(n - k))\ndef g(k=3):\n    return 7\nassert f(g()) == 35\n",
        "idx_generation": 168,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given an integer n, calculate the number of ways to arrange n pairs of parentheses such that they are balanced.\n    Return the number of valid arrangements.\n\n    Example:\n    n = 3\n    Output: 5\n    Explanation: The valid arrangements are: \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\".\n\n    \"\"\"\n    def backtrack(arrangement, left, right, count):\n        if left == 0 and right == 0:\n            count[0] += 1\n            return\n        \n        if left > 0:\n            backtrack(arrangement + '(', left - 1, right, count)\n        \n        if right > left:\n            backtrack(arrangement + ')', left, right - 1, count)\n    \n    count = [0]\n    backtrack('', n, n, count)\n    return count[0]\n\ndef g():\n    return 3\n\nassert f(g()) == 5\n",
        "idx_generation": 147,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Given a list of integers 'arr', return a new list containing only the unique elements\n    and maintaining their relative order.\"\"\"\n    unique_elements = []\n    for num in arr:\n        if num not in unique_elements:\n            unique_elements.append(num)\n    return unique_elements\n\ndef g():\n    return [1, 2, 3, 4, 2, 5, 3, 6, 1]\n\nassert f(g()) == [1, 2, 3, 4, 5, 6]\n",
        "idx_generation": 20,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, perform a binary search to determine if the target number is present in the list.\n    Returns True if the target is found, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return False\n\ndef g():\n    nums = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n    target = 11\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 292,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Find if the target value exists in the sorted array using recursive binary search.\"\"\"\n    def binary_search(left, right):\n        if left > right:\n            return False\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            return binary_search(mid + 1, right)\n        else:\n            return binary_search(left, mid - 1)\n    return binary_search(0, len(nums) - 1)\ndef g(nums=[1, 3, 5, 7, 9], target=5):\n    return nums, target\nassert f(*g())\n",
        "idx_generation": 90,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[List[str]]:\n    \"\"\"Given a list of words, group them by anagrams and return the groups as a list of lists.\n    Anagrams are words that have the same characters but in a different order.\n    Sample Input:\n    words = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n    Sample Output:\n    [[\"eat\", \"tea\", \"ate\"], [\"tan\", \"nat\"], [\"bat\"]]\"\"\"\n    groups = {}\n    for word in words:\n        sortedWord = ''.join(sorted(word))\n        if sortedWord in groups:\n            groups[sortedWord].append(word)\n        else:\n            groups[sortedWord] = [word]\n    return list(groups.values())\n\ndef g():\n    return ([\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"],)\n\nassert f(*g()) == [[\"eat\", \"tea\", \"ate\"], [\"tan\", \"nat\"], [\"bat\"]]\n",
        "idx_generation": 96,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if it is possible to reorder the elements of the array to form an arithmetic progression.\"\"\"\n    nums.sort()\n    diff = nums[1] - nums[0]\n\n    for i in range(2, len(nums)):\n        if nums[i] - nums[i-1] != diff:\n            return False\n\n    return True\n\ndef g(nums: List[int]):\n    \"\"\"Reorder the elements of the array to form an arithmetic progression.\"\"\"\n    nums.sort()\n    return nums\n\nassert f(g([2, 1, 3, 4, 5]))\n",
        "idx_generation": 497,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"Find the number of unique binary search trees that can be formed using n nodes.\"\"\"\n    if n == 0 or n == 1:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    \n    for i in range(2, n + 1):\n        for j in range(1, i + 1):\n            dp[i] += dp[j - 1] * dp[i - j]\n    \n    return dp[n]\n\ndef g(n: int) -> int:\n    \"\"\"Return the value of n\"\"\"\n    return n\n\nassert f(g(4)) == 14\n",
        "idx_generation": 164,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k=2) -> bool:\n    \"\"\"Check if the string s has exactly k distinct characters\"\"\"\n    return len(set(s)) == k\n\ndef g(k=2):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    return alphabet[:k]\n\nassert f(g())\n",
        "idx_generation": 183,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a given string is a palindrome after removing exactly one character.\"\"\"\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    if is_palindrome(s):\n        return True\n\n    for i in range(len(s)):\n        new_s = s[:i] + s[i+1:]\n        if is_palindrome(new_s):\n            return True\n\n    return False\n\ndef g():\n    return \"racecar\"\n\nassert f(g())\n",
        "idx_generation": 357,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the next greater element on the right side,\n    If there is no greater element on the right side, return -1.\n    \"\"\"\n    stack = []\n    result = [-1] * len(nums)\n    for i in range(len(nums)-1, -1, -1):\n        while stack and stack[-1] <= nums[i]:\n            stack.pop()\n        if stack:\n            result[i] = stack[-1]\n        stack.append(nums[i])\n    return result\n\ndef g(nums=[4, 7, 2, 9, 5]):\n    \"\"\"\n    Generate a list of integers where each element is the next greater element on the right side.\n    \"\"\"\n    return nums\n\nassert f(g()) == [7, 9, 9, -1, -1]\n",
        "idx_generation": 498,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if there exists a subarray of length k whose sum is a power of 2\"\"\"\n    k = len(nums)\n    prefix_sum = [0] * (k + 1)\n    for i in range(1, k + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]\n    powers_of_2 = set()\n    for i in range(k):\n        for j in range(i + 1, k + 1):\n            if (prefix_sum[j] - prefix_sum[i]) in powers_of_2:\n                return True\n            powers_of_2.add(prefix_sum[j] - prefix_sum[i])\n    return False\n\ndef g(k=3, nums=[1, 2, 3, 4, 5, 6, 7, 8, 9]):\n    return nums[:k]\n\nassert f(g())\n",
        "idx_generation": 351,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine if a given number is a prime number.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef g():\n    n = 2\n    while True:\n        if f(n):\n            return n\n        n += 1\nassert f(g())\n",
        "idx_generation": 495,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(a: int, b: int, c: int) -> bool:\n    \"\"\"Check if there exists an integer solution to the equation a*x + b*y = c.\"\"\"\n    for x in range(-100, 101):\n        for y in range(-100, 101):\n            if a*x + b*y == c:\n                return True\n    return False\n\ndef g():\n    a = 5\n    b = 7\n    c = 23\n    return a, b, c\n\nassert f(*g())\n",
        "idx_generation": 293,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Determine if a given list of parentheses is balanced.\n\n    Args:\n        nums (List[int]): The list of parentheses.\n\n    Returns:\n        bool: True if the parentheses are balanced, False otherwise.\n\n    Example:\n        Input: nums = [\"(\", \"(\", \")\", \")\"]\n        Output: True\n        Explanation: The parentheses are balanced.\n    \"\"\"\n    stack = []\n    for num in nums:\n        if num == \"(\":\n            stack.append(num)\n        else:\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n\ndef g(nums: List[int]) -> bool:\n    return f(nums)\n\nnums = [\"(\", \"(\", \")\", \")\"]\nassert f(nums) == g(nums)\n\n",
        "idx_generation": 419,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the minimum cost to reach the bottom-right cell of a grid, starting from the top-left cell.\n    The cost of moving from one cell to another is equal to the value of the destination cell.\n    Return the minimum cost.\"\"\"\n    \n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(m):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] + grid[i][j])\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j - 1] + grid[i][j])\n    \n    return dp[m - 1][n - 1]\n\ndef g():\n    return [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\nassert f(g()) == 7\n",
        "idx_generation": 65,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]], word: str) -> bool:\n    \"\"\"Given a grid of characters and a target word, determine if the word can be formed by traversing adjacent cells (horizontally, vertically, or diagonally) in the grid.\n    Return True if the word can be formed, False otherwise.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def dfs(row: int, col: int, index: int) -> bool:\n        if index == len(word):\n            return True\n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] != word[index]:\n            return False\n        temp = grid[row][col]\n        grid[row][col] = ''\n        for direction in directions:\n            newRow = row + direction[0]\n            newCol = col + direction[1]\n            if dfs(newRow, newCol, index + 1):\n                return True\n        grid[row][col] = temp\n        return False\n\n    for r in range(rows):\n        for c in range(cols):\n            if dfs(r, c, 0):\n                return True\n    return False\n\ndef g() -> List[List[str]]:\n    \"\"\"Generate a grid of characters and a target word.\"\"\"\n    grid = [['A', 'B', 'C', 'E'],\n            ['S', 'F', 'C', 'S'],\n            ['A', 'D', 'E', 'E']]\n    word = \"SEE\"\n    return grid, word\n\nassert f(*g())\n",
        "idx_generation": 397,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string is a palindrome.\"\"\"\n    def isPalindrome(s, left, right):\n        if left >= right:\n            return True\n        if s[left] != s[right]:\n            return False\n        return isPalindrome(s, left + 1, right - 1)\n    \n    return isPalindrome(s, 0, len(s) - 1)\n\ndef g():\n    s = \"racecar\"\n    return s\n\nassert f(g())\n",
        "idx_generation": 353,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list whose bitwise XOR is equal to the target.\"\"\"\n    nums.sort()\n    for i in range(len(nums)-1):\n        for j in range(i+1, len(nums)):\n            if nums[i] ^ nums[j] == target:\n                return True\n    return False\n\ndef g():\n    return [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40], 14\n\nassert f(*g())\n",
        "idx_generation": 157,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if there exists a subsequence of numbers that can be summed to obtain the target number. Each number in the list can only be used once.\"\"\"\n    def dp(nums, target, index, curr_sum):\n        if curr_sum == target:\n            return True\n        if index == len(nums) or curr_sum > target:\n            return False\n        if dp(nums, target, index + 1, curr_sum + nums[index]):\n            return True\n        if dp(nums, target, index + 1, curr_sum):\n            return True\n        return False\n    return dp(nums, target, 0, 0)\ndef g(nums=[1, 2, 3, 4, 5], target=6):\n    return nums, target\nassert f(*g())\n",
        "idx_generation": 119,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], src: int, dest: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix and two vertices src and dest,\n    check if there is a path from src to dest in the graph.\n    \"\"\"\n    stack = [src]\n    visited = set()\n\n    while stack:\n        node = stack.pop()\n        visited.add(node)\n\n        if node == dest:\n            return True\n\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] == 1 and neighbor not in visited:\n                stack.append(neighbor)\n\n    return False\n\ndef g():\n    graph = [\n        [0, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    src = 0\n    dest = 4\n    return graph, src, dest\n\nassert f(*g())\n",
        "idx_generation": 466,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Dict\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"Check if there is a path from the start node to the end node in the given graph.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g(graph: Dict[str, List[str]] = {'A': ['B', 'C'], 'B': ['C', 'D'], 'C': ['D'], 'D': ['C'], 'E': ['F'], 'F': ['C']}, start: str = 'A', end: str = 'D'):\n    return graph, start, end\n\nassert f(*g())\n",
        "idx_generation": 219,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representing a directed graph, determine if the graph is connected or not.\n    \n    Return True if the graph is connected, False otherwise.\n    \"\"\"\n    n = len(graph)\n    visited = [False] * n\n    \n    def dfs(node):\n        visited[node] = True\n        for neighbor in range(n):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                dfs(neighbor)\n    \n    dfs(0)\n    \n    return all(visited)\n\ndef g():\n    graph = [\n        [0, 1, 0, 0],\n        [1, 0, 1, 1],\n        [0, 1, 0, 1],\n        [0, 1, 1, 0]\n    ]\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 162,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given a directed acyclic graph represented as an adjacency list,\n    find the length of the longest path from any node to the destination node.\n    Return the length of the longest path.\n    \"\"\"\n    def dfs(node):\n        nonlocal longest_path\n        if node == destination:\n            return 0\n        if longest_path[node] != -1:\n            return longest_path[node]\n        \n        longest_path[node] = 0\n        for neighbor in graph[node]:\n            longest_path[node] = max(longest_path[node], 1 + dfs(neighbor))\n        \n        return longest_path[node]\n    \n    destination = len(graph) - 1\n    longest_path = [-1] * len(graph)\n    \n    return dfs(0)\n\ndef g():\n    \"\"\"\n    Generate a directed acyclic graph represented as an adjacency list.\n    \"\"\"\n    graph = [[1, 2], [3, 4], [5], [], [5], []]\n    \n    return graph\n\nassert f(g()) == 3\n",
        "idx_generation": 270,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome or can be rearranged into a palindrome.\n    Return True if it is possible to rearrange the characters of the string to form a palindrome, otherwise return False.\n    \"\"\"\n    char_counts = {}\n    odd_count = 0\n\n    # Count the occurrences of each character in the string\n    for char in s:\n        if char in char_counts:\n            char_counts[char] += 1\n        else:\n            char_counts[char] = 1\n\n    # Check if the string can be rearranged into a palindrome\n    for count in char_counts.values():\n        if count % 2 != 0:\n            odd_count += 1\n            if odd_count > 1:\n                return False\n\n    return True\n\ndef g():\n    return \"racecar\"\n\nassert f(g())\n",
        "idx_generation": 174,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Find the number of combinations that add up to the target value using the given array of integers.\n    Sample Input:\n    nums = [1, 2, 3]\n    target = 4\n    Sample Output:\n    7\"\"\"\n    memo = {}\n    def dp(remaining):\n        if remaining in memo:\n            return memo[remaining]\n        if remaining == 0:\n            return 1\n        if remaining < 0:\n            return 0\n        count = 0\n        for num in nums:\n            count += dp(remaining - num)\n        memo[remaining] = count\n        return count\n    return dp(target)\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"Generate a list of random integers and the target value.\"\"\"\n    return nums, target\n\nassert f(*g([1, 2, 3], 4)) == 7\n",
        "idx_generation": 147,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers and a target value, \n    determine if there are two numbers in the array that sum up to the target.\n    Sample input:\n    arr = [2, 4, 6, 8, 10]\n    target = 14\n    Sample output:\n    True\"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [2, 4, 6, 8, 10], 14\n\nassert f(*g())\n",
        "idx_generation": 23,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"Rotate the given list of numbers by k steps to the right.\"\"\"\n    k = k % len(nums)\n    nums[:] = nums[-k:] + nums[:-k]\n    return nums\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6, 7]\n    k = 3\n    return nums, k\n\nassert f(*g()) == [5, 6, 7, 1, 2, 3, 4]\n\n",
        "idx_generation": 293,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int, grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of size n x m, determine if it is possible to reach the bottom right cell from the top left cell,\n    only moving downwards or to the right, and avoiding obstacles with value 1.\"\"\"\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = 1\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                continue\n            if i > 0:\n                dp[i][j] += dp[i - 1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j - 1]\n    \n    return dp[n - 1][m - 1] > 0\n\ndef g(n: int, m: int, grid: List[List[int]]) -> Tuple[int, int, List[List[int]]]:\n    \"\"\"Generate a grid of size n x m where it is possible to reach the bottom right cell from the top left cell,\n    only moving downwards or to the right, and avoiding obstacles with value 1.\"\"\"\n    grid[0][1] = 1\n    return n, m, grid\n\nassert f(*g(n=3, m=3, grid=[[0, 0, 0], [0, 0, 0], [0, 0, 0]]))\n",
        "idx_generation": 96,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"Check if s and t are isomorphic strings.\"\"\"\n    if len(s) != len(t):\n        return False\n    mapping = {}\n    used = set()\n    for i in range(len(s)):\n        if s[i] in mapping:\n            if mapping[s[i]] != t[i]:\n                return False\n        else:\n            if t[i] in used:\n                return False\n            mapping[s[i]] = t[i]\n            used.add(t[i])\n    return True\n\ndef g():\n    s = \"paper\"\n    t = \"title\"\n    return s, t\n\nassert f(*g())\n",
        "idx_generation": 103,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, return True if there exists a subset of the integers that\n    sums up to the target value.\"\"\"\n    def subset_sum(nums, target, index):\n        if target == 0:\n            return True\n        if index >= len(nums):\n            return False\n        if nums[index] > target:\n            return subset_sum(nums, target, index + 1)\n        return subset_sum(nums, target - nums[index], index + 1) or subset_sum(nums, target, index + 1)\n    \n    return subset_sum(nums, target, 0)\n\ndef g():\n    nums = [2, 4, 6, 8]\n    target = 10\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 171,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(points: List[Tuple[int, int]]) -> bool:\n    \"\"\"Check if the given list of points forms a rectangle.\"\"\"\n    if len(points) != 4:\n        return False\n    \n    x_coords = [point[0] for point in points]\n    y_coords = [point[1] for point in points]\n    \n    x_min = min(x_coords)\n    x_max = max(x_coords)\n    y_min = min(y_coords)\n    y_max = max(y_coords)\n    \n    if len(set(x_coords)) == 2 and len(set(y_coords)) == 2:\n        if (x_min, y_min) in points and (x_min, y_max) in points and (x_max, y_min) in points and (x_max, y_max) in points:\n            return True\n    \n    return False\n\ndef g():\n    \"\"\"Find a list of points that form a rectangle.\"\"\"\n    return [(0, 0), (0, 1), (1, 0), (1, 1)]\n\nassert f(g())\n",
        "idx_generation": 193,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string, determine if it is a palindrome after removing all non-alphanumeric characters and ignoring case.\"\"\"\n    def isPalindrome(s: str, left: int, right: int) -> bool:\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n\n    s = ''.join(c.lower() for c in s if c.isalnum())\n    return isPalindrome(s, 0, len(s) - 1)\n\ndef g(s=\"A man, a plan, a canal: Panama\"):\n    return s\n\nassert f(g())\n",
        "idx_generation": 364,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of trailing zeros in the factorial of the given number.\"\"\"\n    count = 0\n    i = 5\n    while n // i >= 1:\n        count += n // i\n        i *= 5\n    return count\n\ndef g():\n    n = 25\n    return n\n\nassert f(g()) == 6\n",
        "idx_generation": 379,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if n is a prime number.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    n = 2\n    while True:\n        if f(n):\n            return n\n        n += 1\n\nassert f(g()) == True\n",
        "idx_generation": 311,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nimport math\nfrom typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string, check if it is a valid mathematical expression with balanced parentheses.\n    Return True if it is valid, False otherwise.\n    \"\"\"\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) == 0 or stack[-1] != '(':\n                return False\n            stack.pop()\n    \n    return len(stack) == 0\n    \ndef g() -> str:\n    \"\"\"Generate a string with random mathematical expression with balanced parentheses.\"\"\"\n    string = \"\"\n    num_open = 0\n    num_close = 0\n    while num_open != num_close or num_open == 0:\n        if random.random() < 0.5 and num_open > num_close:\n            string += ')'\n            num_close += 1\n        else:\n            string += '('\n            num_open += 1\n    \n    return string\n\nassert f(g())\n",
        "idx_generation": 421,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target=20) -> bool:\n    \"\"\"Find if there is a path from the top-left cell to the bottom-right cell in the grid that adds up to the target value using recursion and dynamic programming.\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[False] * n for _ in range(m)]\n    dp[0][0] = True\n    for i in range(m):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] = dp[i][j] or (dp[i-1][j] and grid[i][j] + grid[i-1][j] <= target)\n            if j > 0:\n                dp[i][j] = dp[i][j] or (dp[i][j-1] and grid[i][j] + grid[i][j-1] <= target)\n    return dp[-1][-1]\ndef g(grid=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return grid\nassert f(g())\n",
        "idx_generation": 66,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner. You can only move down or right.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Create a 2D memoization table to store the maximum sum at each cell\n    memo = [[0] * cols for _ in range(rows)]\n\n    # Initialize the memoization table\n    memo[0][0] = grid[0][0]\n    for i in range(1, rows):\n        memo[i][0] = memo[i-1][0] + grid[i][0]\n    for j in range(1, cols):\n        memo[0][j] = memo[0][j-1] + grid[0][j]\n\n    # Fill in the memoization table using dynamic programming\n    for i in range(1, rows):\n        for j in range(1, cols):\n            memo[i][j] = max(memo[i-1][j], memo[i][j-1]) + grid[i][j]\n\n    return memo[rows-1][cols-1]\n\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    \"\"\"Generate a grid of integers.\"\"\"\n    return grid\n\nassert f(g()) == 12\n",
        "idx_generation": 406,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"\n    Given a string 's' and a list of words, determine if the string can be formed by concatenating the words\n    from the list. Each word can be used only once.\n    Return True if the string can be formed, False otherwise.\n    \"\"\"\n    def backtrack(start):\n        if start == len(s):\n            return True\n        \n        for i in range(len(words)):\n            if visited[i]:\n                continue\n            \n            if s.startswith(words[i], start):\n                visited[i] = True\n                \n                if backtrack(start + len(words[i])):\n                    return True\n                \n                visited[i] = False\n        \n        return False\n    \n    visited = [False] * len(words)\n    \n    return backtrack(0)\n\ndef g():\n    \"\"\"\n    Generate a string and a list of words.\n    \"\"\"\n    s = \"leetcodeisfun\"\n    words = [\"leet\", \"code\", \"is\", \"fun\"]\n    \n    return s, words\n\nassert f(*g()) == True\n",
        "idx_generation": 365,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a path from the first element to the last element \n    such that the sum of XOR operations of consecutive elements is equal to a given target value.\n    Example:\n    arr = [2, 4, 6, 8, 10]\n    target = 14\n    Output: True\"\"\"\n    target = 14\n    stack = [(arr[0], 0)]\n    \n    while stack:\n        curr_sum, index = stack.pop()\n        \n        if curr_sum == target and index == len(arr) - 1:\n            return True\n        \n        if index + 1 < len(arr):\n            stack.append((curr_sum ^ arr[index + 1], index + 1))\n        \n        if index + 2 < len(arr):\n            stack.append((curr_sum ^ arr[index + 2], index + 2))\n    \n    return False\n\ndef g():\n    return [2, 4, 6, 8, 10]\n\nassert f(g())\n",
        "idx_generation": 178,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str, target: int) -> bool:\n    \"\"\"Given a string of binary digits, determine if it is possible to split the string into two non-empty parts, such that the decimal value of the first part is equal to the decimal value of the second part, and both parts contain an equal number of 1's.\"\"\"\n    n = len(string)\n    count_ones = string.count('1')\n    if count_ones % 2 != 0:\n        return False\n    target_value = count_ones // 2\n    dp = [[False] * (target_value + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(1, n + 1):\n        for j in range(target_value + 1):\n            if j >= int(string[i - 1]):\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - int(string[i - 1])]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[n][target_value]\ndef g(string: str):\n    target = string.count('1') // 2\n    return string, target\nassert f(*g('110110'))\n",
        "idx_generation": 135,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(adj_matrix: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency matrix and two nodes, determine if there exists a path from the start node to the end node.\n    Each node is represented by an integer, and the adjacency matrix indicates the presence of an edge between two nodes.\n    Return True if a path exists, and False otherwise.\n    Sample Input:\n    adj_matrix = [[0, 1, 0, 0],\n                  [0, 0, 1, 0],\n                  [0, 0, 0, 1],\n                  [0, 0, 0, 0]]\n    start = 0\n    end = 3\n    Sample Output:\n    True\"\"\"\n    stack = [start]\n    visited = set()\n    while stack:\n        node = stack.pop()\n        visited.add(node)\n        if node == end:\n            return True\n        for neighbor in range(len(adj_matrix)):\n            if adj_matrix[node][neighbor] == 1 and neighbor not in visited:\n                stack.append(neighbor)\n    return False\n\ndef g():\n    return [[0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1],\n            [0, 0, 0, 0]]\n\nassert f(g(), start=0, end=3)\n",
        "idx_generation": 486,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency matrix, determine if there exists a path from the start vertex to the end vertex.\"\"\"\n    visited = set()\n    stack = [start]\n\n    while stack:\n        vertex = stack.pop()\n        if vertex == end:\n            return True\n        visited.add(vertex)\n\n        for neighbor in range(len(graph)):\n            if graph[vertex][neighbor] == 1 and neighbor not in visited:\n                stack.append(neighbor)\n\n    return False\n\ndef g() -> List[List[int]]:\n    return [[0, 1, 1, 0, 0],\n            [0, 0, 0, 1, 0],\n            [0, 0, 0, 0, 1],\n            [0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0]]\n\nassert f(g(), 0, 4)\n",
        "idx_generation": 224,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Given two positive integers n and k, determine if there exists a path in a directed graph from node 1 to node n,\n    where each node represents a number from 1 to n. The path should consist of k edges, and the sum of the numbers along the path\n    should be divisible by k.\n    Example:\n    n = 5, k = 2\n    Path: 1 -> 3 -> 5\n    Sum: 1 + 3 + 5 = 9, which is divisible by 2\n    Output: True\"\"\"\n    def dfs(node, path_sum, edge_count):\n        if node == n and edge_count == k:\n            return path_sum % k == 0\n        if node > n or edge_count > k:\n            return False\n        for neighbor in graph[node]:\n            if dfs(neighbor, path_sum + node, edge_count + 1):\n                return True\n        return False\n    \n    graph = [[] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            graph[i].append(j)\n    return dfs(1, 0, 0)\n\ndef g():\n    return 5, 2\n\nassert f(*g())\n",
        "idx_generation": 167,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a graph represented as an adjacency matrix and two vertices start and end, determine if there is a path from start to end.\"\"\"\n    visited = [False] * len(graph)\n    stack = [start]\n\n    while stack:\n        vertex = stack.pop()\n        if vertex == end:\n            return True\n        if not visited[vertex]:\n            visited[vertex] = True\n            for neighbor in range(len(graph[vertex])):\n                if graph[vertex][neighbor] == 1 and not visited[neighbor]:\n                    stack.append(neighbor)\n    \n    return False\n\ndef g(start=0, end=3):\n    graph = [[0, 1, 1, 0], \n             [1, 0, 0, 1], \n             [1, 0, 0, 1], \n             [0, 1, 1, 0]]\n    return graph, start, end\n\nassert f(*g())\n",
        "idx_generation": 283,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k=4) -> bool:\n    \"\"\"Find n such that n is a multiple of k and contains exactly 4 distinct digits\"\"\"\n    digits = set(str(n))\n    return len(digits) == 4 and n % k == 0\n\ndef g(k=4):\n    n = 1000\n    while True:\n        digits = set(str(n))\n        if len(digits) == 4 and n % k == 0:\n            return n\n        n += 1\n\nassert f(g())\n",
        "idx_generation": 222,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if there exists a subset of the list that sums up to the target.\n    Return True if such a subset exists, and False otherwise.\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n    Sample Output:\n    True\"\"\"\n    def subset_sum(nums, target, index, curr_sum):\n        if curr_sum == target:\n            return True\n        if index >= len(nums) or curr_sum > target:\n            return False\n        include = subset_sum(nums, target, index + 1, curr_sum + nums[index])\n        exclude = subset_sum(nums, target, index + 1, curr_sum)\n        return include or exclude\n\n    return subset_sum(nums, target, 0, 0)\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find a subset of the list that sums up to the target number.\"\"\"\n    def subset_sum(nums, target, index, curr_sum, subset):\n        if curr_sum == target:\n            return subset\n        if index >= len(nums) or curr_sum > target:\n            return None\n        include = subset_sum(nums, target, index + 1, curr_sum + nums[index], subset + [nums[index]])\n        exclude = subset_sum(nums, target, index + 1, curr_sum, subset)\n        return include if include else exclude\n\n    return subset_sum(nums, target, 0, 0, [])\n\nassert f(g([1, 2, 3, 4, 5], 9), 9)\n",
        "idx_generation": 156,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target number, determine if the target number exists in the list using binary search.\"\"\"\n    low = 0\n    high = len(nums) - 1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return False\n\ndef g(nums=[1, 3, 5, 7, 9], target=5):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 24,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, sort the list in ascending order using the Bubble Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(n - i - 1):\n            if nums[j] > nums[j + 1]:\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n    return nums\n\ndef g() -> List[int]:\n    nums = [5, 2, 9, 1, 3]\n    return nums\n\nassert f(g()) == [1, 2, 3, 5, 9]\n",
        "idx_generation": 302,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list whose sum is equal to the target.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 5, 3, 9, 2], 8  # Return the list of numbers and the target sum\n\nassert f(*g()) == True\n\n",
        "idx_generation": 105,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, s: str) -> bool:\n    \"\"\"Check if it is possible to rearrange the characters in s to form a string that contains n consecutive equal characters.\"\"\"\n    char_counts = Counter(s)\n    for count in char_counts.values():\n        if count >= n:\n            return True\n    return False\n\ndef g(s: str, n: int):\n    return s\n\nassert f(4, g(\"abbcccddddeeeee\", 4))\n",
        "idx_generation": 107,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Find a combination of numbers from the given list that sums up to the target value\"\"\"\n    def recursive_helper(nums, target, curr_sum, index):\n        if curr_sum == target:\n            return True\n        if index >= len(nums):\n            return False\n        return recursive_helper(nums, target, curr_sum + nums[index], index + 1) or recursive_helper(nums, target, curr_sum, index + 1)\n\n    return recursive_helper(nums, target, 0, 0)\n\ndef g(nums=[2, 3, 4, 5, 6, 7, 8, 9, 10]):\n    return nums\n\nassert f(g())\n",
        "idx_generation": 176,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of integers is sorted in non-decreasing order and contains at least one number that is a perfect square.\"\"\"\n    is_sorted = all(nums[i] <= nums[i + 1] for i in range(len(nums) - 1))\n    contains_square = any(x ** 0.5 == int(x ** 0.5) for x in nums)\n    return is_sorted and contains_square\n\ndef g():\n    return [1, 2, 3, 4, 5, 9, 10, 16, 20]\n\nassert f(g())\n",
        "idx_generation": 204,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, substr='abc') -> bool:\n    \"\"\"Check if the given string can be formed by concatenating the given substring repeatedly.\"\"\"\n    n = len(s)\n    m = len(substr)\n    \n    if n % m != 0:\n        return False\n    \n    repeated_substr = substr * (n // m)\n    \n    return repeated_substr == s\n\ndef g(substr='abc'):\n    return substr * 3\n\nassert f(g())\n\n",
        "idx_generation": 427,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"Given a list of integers and a target sum, check if there exists a subarray whose sum is equal to the target sum.\n    Sample input:\n    arr = [3, 4, 7, 2, 1, 8]\n    k = 10\n    Sample output:\n    True\"\"\"\n    n = len(arr)\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + arr[i - 1]\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if prefix_sum[j] - prefix_sum[i] == k:\n                return True\n    return False\n\ndef g():\n    return [3, 4, 7, 2, 1, 8], 10\n\nassert f(*g())\n",
        "idx_generation": 395,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, check if there exists a subarray with a sum equal to zero.\"\"\"\n    prefix_sum = set()\n    curr_sum = 0\n    for num in nums:\n        curr_sum += num\n        if curr_sum == 0 or curr_sum in prefix_sum:\n            return True\n        prefix_sum.add(curr_sum)\n    return False\n\ndef g():\n    \"\"\"Generate a list of integers where a subarray with a sum equal to zero exists.\"\"\"\n    return [1, 2, -3, 4, -2]\n\nassert f(g())\n",
        "idx_generation": 312,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of 0s and 1s, determine if it is possible to reach the bottom-right corner from the top-left corner by only moving through cells with a value of 1.\"\"\"\n    m, n = len(grid), len(grid[0])\n    stack = [(0, 0)]\n    visited = set()\n\n    while stack:\n        i, j = stack.pop()\n        if i == m - 1 and j == n - 1:\n            return True\n        visited.add((i, j))\n\n        neighbors = [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]\n        for x, y in neighbors:\n            if 0 <= x < m and 0 <= y < n and (x, y) not in visited and grid[x][y] == 1:\n                stack.append((x, y))\n\n    return False\n\ndef g():\n    return [[1, 1, 1, 0, 1],\n            [1, 0, 1, 1, 1],\n            [1, 1, 0, 1, 0],\n            [1, 1, 1, 1, 1],\n            [1, 1, 1, 1, 1]]\n\nassert f(g())\n",
        "idx_generation": 436,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the factorial of a given number using recursion.\"\"\"\n    if n == 0:\n        return 1\n    else:\n        return n * f(n-1)\n\ndef g():\n    return 5\n\nassert f(g()) == 120\n",
        "idx_generation": 67,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find if there exists a Hamiltonian path in a given grid of size n x n.\"\"\"\n    if n == 1:\n        return True\n    if n % 2 == 0:\n        return False\n    return True\ndef g():\n    n = 5\n    return f(n)\nassert g()\n\nassert f(g()) == True",
        "idx_generation": 413,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string 's', determine if it is a valid palindrome by removing at most one character.\n    Return True if it is a valid palindrome, False otherwise.\n    Example:\n    s = \"raceacar\"\n    By removing the 'e', the string becomes \"racacar\", which is a palindrome.\n    Therefore, the answer is True.\n    \"\"\"\n    left = 0\n    right = len(s) - 1\n\n    while left < right:\n        if s[left] != s[right]:\n            # Try removing the character at the left index\n            new_s = s[:left] + s[left + 1:]\n            if new_s == new_s[::-1]:\n                return True\n\n            # Try removing the character at the right index\n            new_s = s[:right] + s[right + 1:]\n            if new_s == new_s[::-1]:\n                return True\n\n            # If neither removals result in a palindrome, the string is not a valid palindrome\n            return False\n\n        left += 1\n        right -= 1\n\n    return True\n\ndef g():\n    return \"raceacar\"\n\nassert f(g())\n",
        "idx_generation": 394,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Find the maximum XOR value of any two numbers in the given list.\"\"\"\n    max_xor = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            xor_value = arr[i] ^ arr[j]\n            if xor_value > max_xor:\n                max_xor = xor_value\n    return max_xor\n\ndef g():\n    arr = [4, 6, 8, 2, 10]\n    return arr\n\nassert f(g()) == 14\n",
        "idx_generation": 180,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport itertools\n\ndef f(grid: List[List[int]], target_sum: int) -> bool:\n    \"\"\"Given a grid of integers, determine if there exists a path from the top-left\n    corner to the bottom-right corner that adds up to the target_sum.\"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[False] * n for _ in range(m)]\n\n    dp[0][0] = True\n\n    for i in range(1, m):\n        if grid[i][0] + dp[i-1][0] == target_sum:\n            dp[i][0] = True\n\n    for j in range(1, n):\n        if grid[0][j] + dp[0][j-1] == target_sum:\n            dp[0][j] = True\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] + max(dp[i-1][j], dp[i][j-1]) == target_sum:\n                dp[i][j] = True\n\n    return dp[m-1][n-1]\n\ndef g(grid: List[List[int]], target_sum: int):\n    m = len(grid)\n    n = len(grid[0])\n\n    def backtrack(row, col, path_sum):\n        if row == m-1 and col == n-1 and path_sum == target_sum:\n            return True\n\n        if row < m-1 and backtrack(row+1, col, path_sum+grid[row+1][col]):\n            return True\n\n        if col < n-1 and backtrack(row, col+1, path_sum+grid[row][col+1]):\n            return True\n\n        return False\n\n    return backtrack(0, 0, grid[0][0])\n\ngrid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\ntarget_sum = 15\n\nassert f(grid, target_sum) == g(grid, target_sum)\n",
        "idx_generation": 155,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given an adjacency matrix representing a graph, and the start and end nodes,\n    determine if there is a path from the start node to the end node in the graph.\"\"\"\n    \n    visited = set()\n    stack = [start]\n    \n    while stack:\n        current_node = stack.pop()\n        \n        if current_node == end:\n            return True\n        \n        visited.add(current_node)\n        \n        for neighbor, edge in enumerate(graph[current_node]):\n            if edge == 1 and neighbor not in visited:\n                stack.append(neighbor)\n    \n    return False\n\ndef g():\n    graph = [\n        [0, 1, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 1, 0, 0, 1],\n        [0, 0, 0, 0, 0],\n        [0, 0, 0, 1, 0]\n    ]\n    start = 0\n    end = 4\n    return graph, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 246,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Find the number of connected regions in the matrix\"\"\"\n    def dfs(i: int, j: int) -> None:\n        if i < 0 or i >= len(matrix) or j < 0 or j >= len(matrix[0]) or matrix[i][j] != 1:\n            return\n        matrix[i][j] = 0\n        dfs(i + 1, j)\n        dfs(i - 1, j)\n        dfs(i, j + 1)\n        dfs(i, j - 1)\n    \n    count = 0\n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            if matrix[i][j] == 1:\n                dfs(i, j)\n                count += 1\n    return count\ndef g():\n    return [[0, 1, 0, 1],\n            [0, 0, 1, 1],\n            [1, 0, 0, 0],\n            [0, 1, 0, 1]]\nassert f(g()) == 5\n",
        "idx_generation": 168,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency matrix, determine if there is a cycle in the graph.\n    Return True if there is a cycle, False otherwise.\"\"\"\n    n = len(graph)\n    visited = [False] * n\n    rec_stack = [False] * n\n\n    def dfs(v):\n        visited[v] = True\n        rec_stack[v] = True\n\n        for neighbor in range(n):\n            if graph[v][neighbor] == 1:\n                if not visited[neighbor]:\n                    if dfs(neighbor):\n                        return True\n                elif rec_stack[neighbor]:\n                    return True\n\n        rec_stack[v] = False\n        return False\n\n    for node in range(n):\n        if dfs(node):\n            return True\n\n    return False\n\ndef g():\n    return [[0, 1, 1, 0],\n            [0, 0, 0, 1],\n            [1, 0, 0, 0],\n            [0, 0, 1, 0]]\n\nassert f(g()) == True\n\n",
        "idx_generation": 295,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the number of ways to choose k objects from a set of n objects.\n\n    Example:\n    Input: n = 5, k = 3\n    Output: 10\n    Explanation: There are 10 ways to choose 3 objects from a set of 5 objects: \n    (1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5), \n    (1, 4, 5), (2, 3, 4), (2, 3, 5), (2, 4, 5), (3, 4, 5)\n    \"\"\"\n    if k == 0 or k == n:\n        return 1\n    return f(n-1, k-1) + f(n-1, k)\n\ndef g(n: int, k: int) -> int:\n    return f(n, k)\n\nassert f(5, 3) == g(5, 3)\n",
        "idx_generation": 225,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers and a target number, find all combinations of numbers in the list that add up to the target.\n    Return a list of lists, where each inner list represents a combination of numbers.\"\"\"\n    def backtrack(start, target, path):\n        if target == 0:\n            result.append(path)\n            return\n        elif target < 0:\n            return\n\n        for i in range(start, len(nums)):\n            backtrack(i, target - nums[i], path + [nums[i]])\n\n    result = []\n    backtrack(0, target, [])\n    return result\n\ndef g():\n    return [2, 3, 6, 7], 7\n\nassert f(*g()) == [[2, 2, 3], [7]]\n\n",
        "idx_generation": 159,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Given a matrix of integers sorted in ascending order from left to right and top to bottom, determine if a given target value exists in the matrix.\"\"\"\n    if not matrix or not matrix[0]:\n        return False\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n    r = 0\n    c = cols - 1\n\n    while r < rows and c >= 0:\n        if matrix[r][c] == target:\n            return True\n        elif matrix[r][c] < target:\n            r += 1\n        else:\n            c -= 1\n\n    return False\n\ndef g(target: int):\n    matrix = [\n        [1, 4, 7, 11, 15],\n        [2, 5, 8, 12, 19],\n        [3, 6, 9, 16, 22],\n        [10, 13, 14, 17, 24],\n        [18, 21, 23, 26, 30]\n    ]\n    return matrix, target\n\nassert f(*g(9))\n",
        "idx_generation": 26,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, sort the list in ascending order using the bubble sort algorithm.\"\"\"\n    n = len(arr)\n    for i in range(n - 1):\n        for j in range(n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n    return arr\n\ndef g():\n    arr = [4, 2, 1, 3, 5]\n    return arr\n\nassert f(g()) == [1, 2, 3, 4, 5]\n\n",
        "idx_generation": 311,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g():\n    return [-3, -2, 1, 3, 5, 7, 9], 5\n\nassert f(*g()) == 4\n",
        "idx_generation": 110,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if it is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n    \n    Args:\n    arr: A list of integers\n    \n    Returns:\n    True if the list is a palindrome, False otherwise\n    \"\"\"\n    return arr == arr[::-1]\n\ndef g():\n    \"\"\"\n    Generate a list of integers that is a palindrome.\n    \n    Returns:\n    A list of integers\n    \"\"\"\n    return [1, 2, 3, 2, 1]\n\nassert f(g())\n",
        "idx_generation": 118,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers nums, return a new array such that each element at index i of the new array is the product of all the numbers\n    in the original array except the one at i.\n    You must implement the solution without using the division operator.\n    Return the new array in any order.\n    \"\"\"\n    n = len(nums)\n    left_product = [1] * n\n    right_product = [1] * n\n    result = [1] * n\n    \n    for i in range(1, n):\n        left_product[i] = left_product[i-1] * nums[i-1]\n    \n    for i in range(n-2, -1, -1):\n        right_product[i] = right_product[i+1] * nums[i+1]\n    \n    for i in range(n):\n        result[i] = left_product[i] * right_product[i]\n    \n    return result\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return (nums,)\n\nassert f(*g()) == [120, 60, 40, 30, 24]\n",
        "idx_generation": 177,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> bool:\n    \"\"\"\n    Given a list of words, determine if there exist two words that are anagrams of each other.\n\n    Return True if such two words exist, False otherwise.\n    \"\"\"\n    sorted_words = [''.join(sorted(word)) for word in words]\n    word_freq = {}\n    for sorted_word in sorted_words:\n        if sorted_word in word_freq:\n            return True\n        else:\n            word_freq[sorted_word] = 1\n    return False\n\ndef g():\n    words = ['listen', 'silent', 'hello', 'world']\n    return words\n\nassert f(g())\n",
        "idx_generation": 206,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the nth number in the Look-and-Say sequence.\n    The Look-and-Say sequence is a sequence of numbers generated by describing the digits of the previous term.\n\n    Example:\n    Input: n = 4\n    Output: 1211\n    Explanation: The sequence starts with 1. The second term is \"one 1\" which is \"11\".\n                 The third term is \"two 1s\" which is \"21\". The fourth term is \"one 2, one 1\" which is \"1211\".\n\n    \"\"\"\n\n    def generate_next(prev: str) -> str:\n        result = \"\"\n\n        i = 0\n        while i < len(prev):\n            count = 1\n            while i + 1 < len(prev) and prev[i] == prev[i + 1]:\n                count += 1\n                i += 1\n\n            result += str(count) + prev[i]\n            i += 1\n\n        return result\n\n    sequence = \"1\"\n    for _ in range(n - 1):\n        sequence = generate_next(sequence)\n\n    return int(sequence)\n\ndef g():\n    n = 4\n    return n\n\nassert f(g()) == 1211\n",
        "idx_generation": 474,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the minimum number of operations required to make all elements equal, where an operation consists of adding or subtracting 1 from any element.\"\"\"\n    n = len(nums)\n    total_sum = sum(nums)\n    target = total_sum // n\n    operations = 0\n    for num in nums:\n        operations += abs(num - target)\n    return operations\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g()) == 20\n",
        "idx_generation": 400,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there exists a subarray in the list\n    whose sum is equal to the target number. Return True if such a subarray exists, False otherwise.\n    \"\"\"\n    n = len(nums)\n    prefix_sum = 0\n    prefix_sums = {0: -1}\n    \n    for i in range(n):\n        prefix_sum += nums[i]\n        if prefix_sum - target in prefix_sums:\n            return True\n        prefix_sums[prefix_sum] = i\n    \n    return False\n\ndef g(target: int) -> List[int]:\n    \"\"\"\n    Generate a list of integers that contains a subarray whose sum is equal to the target number.\n    \"\"\"\n    return [1, target-1]\n\nassert f(g(5), 5) == True\n\n",
        "idx_generation": 315,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of 0s and 1s, determine if there is a path from the top-left corner to the bottom-right corner.\n    You can only move down or right, and you can only move through cells with a value of 1.\n    Additionally, you need to avoid cells with a value of 0.\n    Return True if a path exists, False otherwise.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n    stack = [(0, 0)]\n    visited = set()\n\n    while stack:\n        i, j = stack.pop()\n        if i == m - 1 and j == n - 1:\n            return True\n        visited.add((i, j))\n\n        neighbors = [(i + 1, j), (i, j + 1)]\n        for x, y in neighbors:\n            if 0 <= x < m and 0 <= y < n and (x, y) not in visited and matrix[x][y] == 1:\n                stack.append((x, y))\n\n    return False\n\ndef g():\n    return [[1, 1, 1, 0],\n            [1, 0, 1, 1],\n            [1, 1, 0, 1],\n            [0, 1, 1, 1]]\n\nassert f(g())\n",
        "idx_generation": 462,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find the number of ways to climb n stairs if you can take either 1 or 2 steps at a time.\"\"\"\n    def count_ways(n):\n        if n <= 1:\n            return 1\n        prev, curr = 1, 1\n        for i in range(2, n+1):\n            prev, curr = curr, prev + curr\n        return curr\n    return count_ways(n) == 5\ndef g():\n    return 4\nassert f(g())\n",
        "idx_generation": 74,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, find the size of the largest square subgrid where all elements are 1s.\n    \"\"\"\n    m = len(arr)\n    n = len(arr[0])\n    dp = [[0] * (n+1) for _ in range(m+1)]\n    max_len = 0\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if arr[i-1][j-1] == 1:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n                max_len = max(max_len, dp[i][j])\n    return max_len ** 2\n\ndef g(arr=[[1, 0, 1, 0, 0],\n           [1, 0, 1, 1, 1],\n           [1, 1, 1, 1, 1],\n           [1, 0, 0, 1, 0]]):\n    \"\"\"\n    Find the size of the largest square subgrid where all elements are 1s.\n    \"\"\"\n    return arr\n\nassert f(g()) == 4\n",
        "idx_generation": 445,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome.\"\"\"\n    def is_palindrome(start, end):\n        if start >= end:\n            return True\n        if s[start] != s[end]:\n            return False\n        return is_palindrome(start + 1, end - 1)\n    return is_palindrome(0, len(s) - 1)\n\ndef g(s: str):\n    return s\n\nassert f(g(\"madam\"))\n",
        "idx_generation": 408,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num1: int, num2: int) -> int:\n    \"\"\"Find the bitwise OR of the two given numbers\"\"\"\n    return num1 | num2\n\ndef g(num1=5, num2=3):\n    \"\"\"Return the given numbers\"\"\"\n    return num1, num2\n\nassert f(*g()) == 7\n",
        "idx_generation": 180,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer 'n', calculate the factorial of 'n'.\n    Return the factorial.\n    \"\"\"\n    if n == 0:\n        return 1\n    else:\n        return n * f(n-1)\n\ndef g():\n    \"\"\"\n    Generate an integer.\n    \"\"\"\n    n = 5\n    \n    return n\n\nassert f(g()) == 120\n",
        "idx_generation": 158,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start: str, target: str) -> bool:\n    \"\"\"Given a graph represented as a dictionary and two nodes start and target, find if there exists a path from start to target.\n    Sample Input:\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D'],\n        'D': ['C'],\n        'E': ['F'],\n        'F': ['C']\n    }\n    start = 'A'\n    target = 'D'\n    Sample Output:\n    True\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        current = stack.pop()\n        if current == target:\n            return True\n        visited.add(current)\n        for neighbor in graph.get(current, []):\n            if neighbor not in visited:\n                stack.append(neighbor)\n    return False\n\ndef g():\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D'],\n        'D': ['C'],\n        'E': ['F'],\n        'F': ['C']\n    }\n    start = 'A'\n    target = 'D'\n    return graph, start, target\n\nassert f(*g())\n",
        "idx_generation": 246,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency list, determine if there is a path from the start node to the end node.\"\"\"\n    def dfs(graph, node, visited):\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(graph, neighbor, visited):\n                    return True\n        return False\n    \n    visited = set()\n    return dfs(graph, start, visited)\n\ndef g(graph={\"A\": [\"B\", \"C\"], \"B\": [\"C\", \"D\"], \"C\": [\"D\"], \"D\": []}, start=\"A\", end=\"D\"):\n    return graph, start, end\n\nassert f(*g())\n",
        "idx_generation": 173,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the shortest path from the top-left corner to the bottom-right corner of the grid.\"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    # Create a 2D array to store the shortest path distances\n    distances = [[float('inf')] * n for _ in range(m)]\n\n    # Define the directions for grid traversal\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    # Create a queue for BFS traversal\n    queue = [(0, 0)]\n    distances[0][0] = grid[0][0]\n\n    while queue:\n        x, y = queue.pop(0)\n\n        # Check all possible directions\n        for dx, dy in directions:\n            nx = x + dx\n            ny = y + dy\n\n            # Check if the next position is within the grid boundaries\n            if 0 <= nx < m and 0 <= ny < n:\n                # Calculate the distance to reach the next position\n                dist = distances[x][y] + grid[nx][ny]\n\n                # Update the distance if it is shorter\n                if dist < distances[nx][ny]:\n                    distances[nx][ny] = dist\n                    queue.append((nx, ny))\n\n    # Return the shortest path distance to the bottom-right corner\n    return distances[m - 1][n - 1]\n\ndef g(grid: List[List[int]] = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(g()) == 7\n\n",
        "idx_generation": 377,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Given a positive integer n, generate all possible combinations of n pairs of parentheses.\n\n    Example:\n    Input: 3\n    Output: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n    \"\"\"\n    def backtrack(S='', left=0, right=0):\n        if len(S) == 2 * n:\n            output.append(S)\n            return\n        if left < n:\n            backtrack(S+'(', left+1, right)\n        if right < left:\n            backtrack(S+')', left, right+1)\n\n    output = []\n    backtrack()\n    return output\n\ndef g():\n    return 3\n\nassert f(g()) == [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n",
        "idx_generation": 231,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int, target: int) -> bool:\n    \"\"\"\n    Given a list of n positive integers, find if there exists a combination of k integers whose sum is equal to the target.\n    Return True if such combination exists, and False otherwise.\n    \"\"\"\n    def dfs(nums: List[int], k: int, target: int, curr_sum: int, start: int) -> bool:\n        if k == 0:\n            return curr_sum == target\n        if curr_sum > target or start >= len(nums):\n            return False\n        \n        for i in range(start, len(nums)):\n            if dfs(nums, k-1, target, curr_sum+nums[i], i+1):\n                return True\n        \n        return False\n    \n    return dfs(list(range(1, n+1)), k, target, 0, 0)\n\ndef g(n: int, k: int, target: int) -> List[int]:\n    \"\"\"\n    Given a list of n positive integers, find a combination of k integers whose sum is equal to the target.\n    Return the combination as a list if it exists, and an empty list otherwise.\n    \"\"\"\n    def backtrack(nums: List[int], k: int, target: int, curr_sum: int, start: int, path: List[int], result: List[List[int]]) -> None:\n        if k == 0 and curr_sum == target:\n            result.append(path)\n            return\n        if curr_sum > target or start >= len(nums):\n            return\n        \n        for i in range(start, len(nums)):\n            backtrack(nums, k-1, target, curr_sum+nums[i], i+1, path+[nums[i]], result)\n    \n    result = []\n    backtrack(list(range(1, n+1)), k, target, 0, 0, [], result)\n    return result\n\nassert f(5, 3, 7)\nassert g(5, 3, 7) == [[1, 2, 4]]\n",
        "idx_generation": 159,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the given list is sorted in non-decreasing order.\"\"\"\n    return all(arr[i] <= arr[i+1] for i in range(len(arr)-1))\ndef g():\n    return sorted([4, 2, 7, 1, 5])\nassert f(g())\n",
        "idx_generation": 30,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(l: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, find if there exists two numbers in the list whose sum is equal to the given target.\"\"\"\n    left = 0\n    right = len(l) - 1\n    while left < right:\n        current_sum = l[left] + l[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(target: int):\n    return [3, 7, 11, 15, 19, 23, 27, 31, 35, 39, 43]  # Sorted list\n\nassert f(g(50), 30)\n",
        "idx_generation": 315,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if there exists a subset of the list whose elements add up to the target value.\"\"\"\n    nums.sort()\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(1, n + 1):\n        for j in range(target + 1):\n            if nums[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n    return dp[n][target]\ndef g(nums=[2, 4, 6, 8, 10]):\n    return nums\nassert f(g())\n",
        "idx_generation": 111,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(words: List[str], target='python') -> bool:\n    \"\"\"Given a list of words, find if there exists a word that can be formed by rearranging the letters of the target word.\"\"\"\n    for word in words:\n        if sorted(word) == sorted(target):\n            return True\n    return False\n\ndef g(target='python'):\n    words = ['typhon', 'notpyh', 'thonpy', 'python']\n    return words\n\nassert f(g())\n",
        "idx_generation": 146,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> bool:\n    \"\"\"Given two integers n and k, determine if there exists a combination of n elements from the set {1, 2, ..., k} such that the sum of the elements is divisible by k.\n    \n    Sample input:\n    n = 3, k = 5\n    \n    Sample output:\n    True\n    \n    Explanation:\n    The set {1, 2, 3} has a combination [1, 2, 3] such that the sum is 6, which is divisible by 5.\n    \"\"\"\n    if n > k:\n        return False\n    \n    dp = [[False] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n    \n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            if dp[i - 1][j]:\n                for x in range(1, k + 1):\n                    dp[i][(j + x) % k] = True\n    \n    return dp[n][0]\n\ndef g(n=3, k=5):\n    \"\"\"Generate two integers n and k.\"\"\"\n    return n, k\n\nassert f(*g())\n",
        "idx_generation": 186,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, substrings=['abc', 'def', 'ghi', 'jkl'], n=3) -> bool:\n    \"\"\"Find if a string can be formed by concatenating substrings, each repeated n times.\"\"\"\n    return all((s.count(substring) == n for substring in substrings))\ndef g(substrings=['abc', 'def', 'ghi', 'jkl'], n=3):\n    return ''.join([substring * n for substring in substrings])\nassert f(g())\n",
        "idx_generation": 213,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the missing number in the given list of consecutive integers.\"\"\"\n    n = len(nums) + 1\n    total_sum = (n * (n + 1)) // 2\n    actual_sum = sum(nums)\n    return total_sum - actual_sum\n\ndef g():\n    return [1, 2, 3, 5, 6, 7, 8, 9]\n\nassert f(g()) == 4\n",
        "idx_generation": 424,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Find the maximum sum of a subarray within the given array.\n    Return the maximum sum.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for num in arr:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum\n\ndef g():\n    \"\"\"\n    Generate an array of integers.\n    \"\"\"\n    arr = [1, -3, 2, 5, -1, 4, -2]\n    return arr\n\nassert f(g()) == 10\n",
        "idx_generation": 317,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, find the longest increasing subsequence.\"\"\"\n    n = len(nums)\n    dp = [1] * n\n    \n    for i in range(n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp) >= 2\n\ndef g():\n    return [5, 2, 8, 6, 3, 6, 9, 7]\n\nassert f(g()) == True\n",
        "idx_generation": 75,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right. Additionally, you can only move right when the number of 1s encountered so far is even,\n    and you can only move down when the number of 1s encountered so far is odd.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def dfs(i, j, count):\n        if i == rows-1 and j == cols-1:\n            return grid[i][j]\n        if i >= rows or j >= cols:\n            return float('-inf')\n        \n        if count % 2 == 0:\n            return grid[i][j] + max(dfs(i, j+1, count+1), dfs(i+1, j, count))\n        else:\n            return grid[i][j] + max(dfs(i+1, j, count+1), dfs(i, j+1, count))\n    \n    return dfs(0, 0, 0)\n\ndef g(grid=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    \"\"\"Generate a grid of integers.\"\"\"\n    return grid\n\nassert f(g()) == 29\n",
        "idx_generation": 460,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string, find the length of the longest substring without repeating characters.\n    \"\"\"\n    max_length = 0\n    start = 0\n    char_dict = {}\n    for i, char in enumerate(s):\n        if char in char_dict and start <= char_dict[char]:\n            start = char_dict[char] + 1\n        else:\n            max_length = max(max_length, i - start + 1)\n        char_dict[char] = i\n    return max_length\n\ndef g():\n    return \"abcabcbb\"\n\nassert f(g()) == 3\n\n",
        "idx_generation": 412,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum bitwise XOR value between any two numbers in the list.\n    Return the maximum XOR value.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    \n    for i in range(31, -1, -1):  # Iterate through each bit from left to right\n        mask |= (1 << i)  # Set the mask to include the current bit\n        \n        prefixes = set()\n        for num in nums:\n            prefixes.add(num & mask)  # Get the prefix of each number using the mask\n        \n        # Check if there is a pair of prefixes whose XOR value is greater than max_xor\n        potential_max_xor = max_xor | (1 << i)\n        for prefix in prefixes:\n            if (prefix ^ potential_max_xor) in prefixes:\n                max_xor = potential_max_xor\n                break\n    \n    return max_xor\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n\n",
        "idx_generation": 183,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the maximum sum of a path from the top-left corner to the bottom-right corner of a grid\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[rows-1][cols-1]\ndef g(grid=[[1,3,1],[1,5,1],[4,2,1]]):\n    return grid\nassert f(g()) == 12\n",
        "idx_generation": 175,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start=0, end=5) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency list, determine if there is a path from the start node to the end node.\n    The graph is represented as a dictionary where the keys are the nodes and the values are lists of neighboring nodes.\n    Return True if there is a path from start to end, False otherwise.\"\"\"\n    visited = set()\n    stack = [start]\n    \n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    \n    return False\n\ndef g(graph={0: [1, 2], 1: [2], 2: [3, 4], 3: [4], 4: [5], 5: []}, start=0, end=5):\n    return graph\n\nassert f(g())\n",
        "idx_generation": 255,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representation of a directed graph,\n    determine if the graph contains a cycle.\n    \"\"\"\n    visited = [False] * len(graph)\n    stack = [False] * len(graph)\n\n    def dfs(node):\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n            elif stack[neighbor]:\n                return True\n\n        stack[node] = False\n        return False\n\n    for node in range(len(graph)):\n        if not visited[node]:\n            if dfs(node):\n                return True\n\n    return False\n\ndef g():\n    graph = [[0, 1, 0, 0],\n             [0, 0, 1, 0],\n             [0, 0, 0, 1],\n             [1, 0, 0, 0]]\n    return graph\n\nassert f(g())\n",
        "idx_generation": 183,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(adj_matrix: List[List[int]]) -> bool:\n    \"\"\"Given an adjacency matrix representing a directed graph, return True if the graph contains a cycle, False otherwise.\n    \n    An adjacency matrix is a square matrix in which the element at index (i, j) represents the presence or absence of a directed edge from vertex i to vertex j.\n    \"\"\"\n    # Number of vertices in the graph\n    num_vertices = len(adj_matrix)\n    \n    # Visited array to keep track of visited vertices\n    visited = [False] * num_vertices\n    \n    # Recursive DFS function to check for cycles\n    def dfs(vertex: int, stack: List[int]) -> bool:\n        visited[vertex] = True\n        stack.append(vertex)\n        \n        for neighbor in range(num_vertices):\n            if adj_matrix[vertex][neighbor] == 1:\n                if neighbor in stack:\n                    return True\n                if not visited[neighbor] and dfs(neighbor, stack):\n                    return True\n        \n        stack.remove(vertex)\n        return False\n    \n    # Checking for cycles starting from each vertex\n    for vertex in range(num_vertices):\n        if not visited[vertex]:\n            if dfs(vertex, []):\n                return True\n    \n    return False\n\ndef g():\n    adj_matrix = [\n        [0, 1, 1, 0],\n        [0, 0, 0, 1],\n        [0, 1, 0, 0],\n        [0, 0, 1, 0]\n    ]\n    return adj_matrix\n\nassert f(g()) == True\n\n",
        "idx_generation": 410,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k=3) -> bool:\n    \"\"\"Determine if there exists a combination of k numbers from 1 to n that adds up to n\"\"\"\n    if k == 1:\n        return n > 0\n    if k == 2:\n        return n % 2 == 0\n    return n % 2 == 0 or k % 2 == 0\ndef g(k=3):\n    return k % 2 == 0\nassert f(g())\n",
        "idx_generation": 234,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"Given two integers n and k, calculate the number of possible combinations of k elements from a set of n elements.\"\"\"\n    def factorial(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n-1)\n    return factorial(n) // (factorial(k) * factorial(n-k))\n\ndef g(n: int = 5, k: int = 2):\n    return n, k\n\nassert f(*g()) == 10\n",
        "idx_generation": 190,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of integers is a palindrome\"\"\"\n    return nums == nums[::-1]\n\ndef g():\n    return [1, 2, 3, 2, 1]\n\nassert f(g())\n",
        "idx_generation": 37,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Given a matrix of integers and a target value, determine if the target value exists in the matrix.\n    The matrix is sorted row-wise and column-wise in ascending order.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    r = 0\n    c = cols - 1\n    while r < rows and c >= 0:\n        if matrix[r][c] == target:\n            return True\n        elif matrix[r][c] > target:\n            c -= 1\n        else:\n            r += 1\n    return False\n\ndef g(matrix: List[List[int]]) -> int:\n    \"\"\"Find the maximum value in the matrix.\"\"\"\n    max_val = float('-inf')\n    for row in matrix:\n        max_val = max(max_val, max(row))\n    return max_val\n\nassert f(matrix=[[1, 4, 7], [2, 5, 8], [3, 6, 9]], target=g(matrix=[[1, 4, 7], [2, 5, 8], [3, 6, 9]]))\n",
        "idx_generation": 327,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers that sum up to the target.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        \n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 13\n\nassert f(*g()) == True\n\n",
        "idx_generation": 116,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"Check if a string can be formed by rearranging the characters of another string.\"\"\"\n    sorted_s = ''.join(sorted(s))\n    sorted_target = ''.join(sorted(target))\n    return sorted_s == sorted_target\n\ndef g():\n    return \"python\", \"nohtyp\"\n\nassert f(*g())\n",
        "idx_generation": 157,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], n: int) -> bool:\n    \"\"\"Given a list of integers and a value n, determine if there exists a subarray of length n in the list such that the sum of its elements is even.\n    Return True if such subarray exists, False otherwise.\"\"\"\n    prefix_sum = 0\n    prefix_sums = {0}\n    \n    for num in arr:\n        prefix_sum += num\n        prefix_sums.add(prefix_sum)\n        if prefix_sum % 2 in prefix_sums:\n            return True\n    \n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Generate a list of integers and a value n.\"\"\"\n    arr = [1, 2, 3, 4, 5]\n    n = 3\n    \n    return arr, n\n\nassert f(*g()) == True\n\n",
        "idx_generation": 189,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Find if it is possible to form k anagrams of the string s by rearranging its letters\"\"\"\n    from collections import Counter\n    count = Counter(s)\n    num_anagrams = 1\n    for val in count.values():\n        num_anagrams *= math.factorial(val)\n    return num_anagrams >= k\ndef g(s: str, k: int):\n    return s[::-1] * k\nassert f(g('hello', 2), 2)\n",
        "idx_generation": 268,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> bool:\n    \"\"\"Given two integers n and m, determine if it is possible to construct a sequence of length n such that the sum of any two adjacent elements is divisible by m.\n    The goal is to find values for n and m that satisfy the condition.\"\"\"\n    if n % 2 == 1 and m % 2 == 1:\n        return False\n    return True\n\ndef g():\n    return 6, 2\n\nassert f(*g())\n",
        "idx_generation": 489,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers nums and a target integer, find two numbers in the list that\n    add up to the target. Return the indices of the two numbers as a list.\"\"\"\n    num_set = set(nums)\n    memo = {}\n\n    def find_indices(curr_index, remaining):\n        if remaining == 0:\n            return []\n\n        if (curr_index, remaining) in memo:\n            return memo[(curr_index, remaining)]\n\n        complement = target - nums[curr_index]\n        if complement in num_set:\n            complement_index = nums.index(complement)\n            memo[(curr_index, remaining)] = [curr_index, complement_index]\n            return [curr_index, complement_index]\n\n        for i in range(curr_index + 1, len(nums)):\n            indices = find_indices(i, remaining - 1)\n            if indices:\n                memo[(curr_index, remaining)] = [curr_index] + indices\n                return [curr_index] + indices\n\n        memo[(curr_index, remaining)] = []\n        return []\n\n    return find_indices(0, 2)\n\ndef g():\n    nums = [2, 3, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 2]\n",
        "idx_generation": 327,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> bool:\n    \"\"\"Given two positive integers n and m, determine if there exists a valid arrangement of n knights on an m x m chessboard, such that no two knights attack each other.\"\"\"\n    def is_valid(arrangement):\n        for i in range(len(arrangement)):\n            for j in range(i + 1, len(arrangement)):\n                x1, y1 = arrangement[i]\n                x2, y2 = arrangement[j]\n                if abs(x1 - x2) == 2 and abs(y1 - y2) == 1:\n                    return False\n                if abs(x1 - x2) == 1 and abs(y1 - y2) == 2:\n                    return False\n        return True\n    \n    def backtrack(arrangement, m):\n        if len(arrangement) == n:\n            return arrangement\n        for x in range(m):\n            for y in range(m):\n                if (x, y) not in arrangement:\n                    new_arrangement = arrangement + [(x, y)]\n                    if is_valid(new_arrangement):\n                        result = backtrack(new_arrangement, m)\n                        if result is not None:\n                            return result\n        return None\n    \n    return backtrack([], m) is not None\n\ndef g(n=4, m=4):\n    return n, m\n\nassert f(*g())\n",
        "idx_generation": 75,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid 'grid' containing characters 'W' and 'B', where 'W' represents a white cell and 'B' represents a black cell,\n    find the minimum number of moves required to convert the entire grid into a single color.\n    A move is defined as flipping the color of a cell and all its neighboring cells (up, down, left, right).\n    Return the minimum number of moves required.\n    \"\"\"\n    if not grid:\n        return 0\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    \n    def flip_color(row, col):\n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] == 'W':\n            return\n        \n        grid[row][col] = 'W'\n        \n        flip_color(row-1, col)\n        flip_color(row+1, col)\n        flip_color(row, col-1)\n        flip_color(row, col+1)\n    \n    min_moves = float('inf')\n    colors = ['W', 'B']\n    \n    for color in colors:\n        moves = 0\n        copy_grid = [row[:] for row in grid]\n        \n        for i in range(rows):\n            for j in range(cols):\n                if copy_grid[i][j] == color:\n                    flip_color(i, j)\n                    moves += 1\n        \n        min_moves = min(min_moves, moves)\n    \n    return min_moves\n\ndef g():\n    \"\"\"\n    Generate a grid with a pattern of white and black cells.\n    \"\"\"\n    return [['W', 'B', 'W'],\n            ['B', 'W', 'B'],\n            ['W', 'B', 'W']]\n\nassert f(g()) == 4\n",
        "idx_generation": 475,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, words: List[str]) -> List[str]:\n    \"\"\"Given a string 's' and a list of words 'words',\n    return a list of all valid word breaks for 's' using the words from 'words'.\n    A valid word break is a combination of words from 'words' that concatenates to form 's'.\"\"\"\n    def backtrack(start, current_words):\n        if start == len(s):\n            valid_breaks.append(\" \".join(current_words))\n            return\n        for word in words:\n            if s.startswith(word, start):\n                backtrack(start + len(word), current_words + [word])\n\n    valid_breaks = []\n    backtrack(0, [])\n    return valid_breaks\n\ndef g(s=\"applepie\", words=[\"apple\", \"pie\", \"app\", \"le\"]):\n    \"\"\"Generate a string and a list of words.\"\"\"\n    return s, words\n\nassert f(*g()) == ['apple pie', 'app le pie']\n",
        "idx_generation": 418,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> bool:\n    \"\"\"Given two positive integers n and m, determine if n is a multiple of m using bitwise operations.\n    \n    Sample input:\n    n = 16, m = 4\n    \n    Sample output:\n    True\n    \n    Explanation:\n    16 is a multiple of 4 (4 * 4 = 16).\n    \"\"\"\n    return n & (m - 1) == 0\n\ndef g(n=16, m=4):\n    \"\"\"Generate two positive integers n and m.\"\"\"\n    return n, m\n\nassert f(*g())\n",
        "idx_generation": 186,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a subsequence (not necessarily contiguous)\n    in the list, such that the sum of the subsequence is a perfect square.\n    \n    Return True if such a subsequence exists, False otherwise.\n    \"\"\"\n    def dfs(index, target):\n        if target == 0:\n            return True\n        if index == len(nums) or target < 0:\n            return False\n        if (index, target) in memo:\n            return memo[(index, target)]\n        include = dfs(index + 1, target - nums[index])\n        exclude = dfs(index + 1, target)\n        memo[(index, target)] = include or exclude\n        return memo[(index, target)]\n    \n    memo = {}\n    return dfs(0, 0)\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g())\n",
        "idx_generation": 180,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency matrix, determine if there exists a path from the start node to the end node.\n    Each node is represented by an integer, and the adjacency matrix graph[i][j] indicates if there is an edge between nodes i and j (1 if there is, 0 otherwise).\"\"\"\n    visited = [False] * len(graph)\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if not visited[node]:\n            visited[node] = True\n            neighbors = [i for i in range(len(graph)) if graph[node][i] == 1]\n            stack.extend(neighbors)\n    return False\n\ndef g():\n    return [[0, 1, 1, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1],\n            [0, 0, 0, 0]]\n\nassert f(graph=g(), start=0, end=3)\n",
        "idx_generation": 257,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the shortest path from the top-left corner to the bottom-right corner in a grid.\n    Return the minimum number of steps required to reach the destination.\"\"\"\n    if not grid:\n        return 0\n    queue = [(0, 0, 0)]\n    visited = set()\n    while queue:\n        row, col, steps = queue.pop(0)\n        if row == len(grid) - 1 and col == len(grid[0]) - 1:\n            return steps\n        if (row, col) not in visited:\n            visited.add((row, col))\n            if row + 1 < len(grid) and grid[row + 1][col] == 0:\n                queue.append((row + 1, col, steps + 1))\n            if row - 1 >= 0 and grid[row - 1][col] == 0:\n                queue.append((row - 1, col, steps + 1))\n            if col + 1 < len(grid[0]) and grid[row][col + 1] == 0:\n                queue.append((row, col + 1, steps + 1))\n            if col - 1 >= 0 and grid[row][col - 1] == 0:\n                queue.append((row, col - 1, steps + 1))\n    return -1\n\ndef g():\n    return [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n\nassert f(g()) == 4\n",
        "idx_generation": 184,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency matrix, determine if there exists a cycle that passes through both the start vertex and end vertex.\"\"\"\n    visited = set()\n    stack = [(start, [start])]\n\n    while stack:\n        vertex, path = stack.pop()\n        visited.add(vertex)\n\n        if vertex == end and len(path) > 2:\n            return True\n\n        for neighbor in range(len(graph)):\n            if graph[vertex][neighbor] == 1 and neighbor not in visited:\n                stack.append((neighbor, path + [neighbor]))\n\n    return False\n\ndef g() -> List[List[int]]:\n    return [[0, 1, 1, 0, 0],\n            [0, 0, 0, 1, 0],\n            [0, 0, 0, 0, 1],\n            [0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0]]\n\nassert f(g(), 0, 4)\n",
        "idx_generation": 433,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Compute the number of combinations of n items taken 2 at a time.\"\"\"\n    return n * (n - 1) // 2\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == 10\n",
        "idx_generation": 236,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, substrings=['abc', 'def', 'ghi', 'jkl'], k=2) -> bool:\n    \"\"\"Check if a string can be formed by concatenating substrings, each repeated a multiple of k times. \n    The order of the substrings can be rearranged.\"\"\"\n    def backtrack(remaining, counts):\n        if not remaining:\n            return True\n        for i, substring in enumerate(substrings):\n            if counts[i] > 0 and remaining.startswith(substring):\n                counts[i] -= 1\n                if backtrack(remaining[len(substring):], counts):\n                    return True\n                counts[i] += 1\n        return False\n    counts = [s.count(substring) for substring in substrings]\n    return backtrack(s, counts)\ndef g(substrings=['abc', 'def', 'ghi', 'jkl'], k=2):\n    return ''.join([substring * (k + (k - 1) * i) for i, substring in enumerate(substrings)])\nassert f(g())\n",
        "idx_generation": 213,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a given number n is a perfect square\"\"\"\n    if n < 0:\n        return False\n    if n == 0:\n        return True\n    low, high = 1, n\n    while low <= high:\n        mid = (low + high) // 2\n        if mid * mid == n:\n            return True\n        elif mid * mid < n:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False\n\ndef g():\n    return 16\n\nassert f(g())\n",
        "idx_generation": 37,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, find if there are two numbers in the list\n    that add up to the target. Return True if such numbers exist, otherwise return False.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        \n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    return [1, 2, 4, 7, 11, 15], 9\n\nassert f(*g()) == True\n",
        "idx_generation": 329,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are three elements that sum up to the target value.\"\"\"\n    n = len(arr)\n    for i in range(n - 2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            curr_sum = arr[i] + arr[left] + arr[right]\n            if curr_sum == target:\n                return True\n            elif curr_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g(target: int) -> List[int]:\n    \"\"\"Generate a sorted list of random integers.\"\"\"\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return arr\n\nassert f(g(15), 15) == True\n\n",
        "idx_generation": 121,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"Check if a string can be formed by rearranging the characters of another string, ignoring the case.\"\"\"\n    sorted_s = ''.join(sorted(s.lower()))\n    sorted_target = ''.join(sorted(target.lower()))\n    return sorted_s == sorted_target\n\ndef g():\n    return \"Python\", \"nohtyp\"\n\nassert f(*g())\n",
        "idx_generation": 157,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a subsequence of length 3 where the product is greater than the sum\"\"\"\n    for i in range(len(nums)-2):\n        for j in range(i+1, len(nums)-1):\n            for k in range(j+1, len(nums)):\n                if nums[i] * nums[j] * nums[k] > nums[i] + nums[j] + nums[k]:\n                    return True\n    return False\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"Find a subsequence of length 3 where the product is greater than the sum\"\"\"\n    max_product = float('-inf')\n    subsequence = []\n    for i in range(len(nums)-2):\n        for j in range(i+1, len(nums)-1):\n            for k in range(j+1, len(nums)):\n                if nums[i] * nums[j] * nums[k] > max_product:\n                    max_product = nums[i] * nums[j] * nums[k]\n                    subsequence = [nums[i], nums[j], nums[k]]\n    return subsequence\n\nassert f(g([1, 2, 3, 4, 5, 6, 7]))\n",
        "idx_generation": 192,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"Check if string t is an anagram of string s.\"\"\"\n    if len(s) != len(t):\n        return False\n    s_count = [0] * 26\n    t_count = [0] * 26\n    for i in range(len(s)):\n        s_count[ord(s[i]) - ord('a')] += 1\n        t_count[ord(t[i]) - ord('a')] += 1\n    return s_count == t_count\n\ndef g():\n    s = \"anagram\"\n    t = \"nagaram\"\n    return s, t\n\nassert f(*g())\n",
        "idx_generation": 274,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum subarray sum.\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum\n\ndef g(nums: List[int] = [-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 344,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> bool:\n    \"\"\"Given two positive integers n and m, determine if there exists a valid arrangement of n rooks on an m x m chessboard, such that no two rooks attack each other.\"\"\"\n    def is_valid(arrangement):\n        for i in range(len(arrangement)):\n            for j in range(i + 1, len(arrangement)):\n                x1, y1 = arrangement[i]\n                x2, y2 = arrangement[j]\n                if x1 == x2 or y1 == y2:\n                    return False\n        return True\n    \n    def backtrack(arrangement, m):\n        if len(arrangement) == n:\n            return arrangement\n        for x in range(m):\n            for y in range(m):\n                if (x, y) not in arrangement:\n                    new_arrangement = arrangement + [(x, y)]\n                    if is_valid(new_arrangement):\n                        result = backtrack(new_arrangement, m)\n                        if result is not None:\n                            return result\n        return None\n    \n    return backtrack([], m) is not None\n\ndef g(n=4, m=4):\n    return n, m\n\nassert f(*g())\n",
        "idx_generation": 75,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if it is possible to reach the bottom-right cell in a grid by moving only down or right.\"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[False] * n for _ in range(m)]\n    \n    dp[0][0] = True\n    \n    for i in range(1, m):\n        if grid[i][0] == 1:\n            break\n        dp[i][0] = True\n        \n    for j in range(1, n):\n        if grid[0][j] == 1:\n            break\n        dp[0][j] = True\n        \n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] == 1:\n                continue\n            dp[i][j] = dp[i-1][j] or dp[i][j-1]\n    \n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a random grid with 0s and 1s.\"\"\"\n    grid = [[0, 0, 1, 0, 0], [0, 0, 0, 0, 1], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0], [1, 0, 1, 0, 0]]\n    return grid\n\nassert f(g())\n",
        "idx_generation": 477,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a valid palindrome after deleting at most one character.\n    Return True if it is a valid palindrome, otherwise return False.\n    \n    Example:\n    Input: s = \"abcdcbba\"\n    Output: True\n    Explanation: By deleting 'c' or 'b', the string becomes \"abcba\" which is a palindrome.\n    \"\"\"\n    def is_palindrome(s: str, left: int, right: int) -> bool:\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n    \n    left = 0\n    right = len(s) - 1\n    \n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s, left + 1, right) or is_palindrome(s, left, right - 1)\n        left += 1\n        right -= 1\n    \n    return True\n\ndef g(s: str) -> bool:\n    \"\"\"\n    Determine if a given string is a valid palindrome after deleting at most one character.\n    \"\"\"\n    def is_palindrome(s: str, left: int, right: int) -> bool:\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n    \n    left = 0\n    right = len(s) - 1\n    \n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s, left + 1, right) or is_palindrome(s, left, right - 1)\n        left += 1\n        right -= 1\n    \n    return True\n\nassert f(\"abcdcbba\") == g(\"abcdcbba\")\n",
        "idx_generation": 422,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"Given a list of integers and a value k, determine if there exists a subarray in the list such that the bitwise OR of its elements is equal to k.\n    Return True if such subarray exists, False otherwise.\"\"\"\n    prefix_or = 0\n    prefix_ors = {0}\n    \n    for num in arr:\n        prefix_or |= num\n        prefix_ors.add(prefix_or)\n        if prefix_or == k or (prefix_or ^ k) in prefix_ors:\n            return True\n    \n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Generate a list of integers and a value k.\"\"\"\n    arr = [1, 2, 3, 4, 5]\n    k = 7\n    \n    return arr, k\n\nassert f(*g()) == True\n\n",
        "idx_generation": 189,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Given a matrix of non-negative integers, find the path with the maximum sum from the top-left cell to the\n    bottom-right cell. You can only move down or right.\n\n    Args:\n        matrix (List[List[int]]): The matrix of non-negative integers.\n\n    Returns:\n        int: The maximum sum of the path.\n    \"\"\"\n    if not matrix:\n        return 0\n\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = matrix[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n    return dp[m - 1][n - 1]\n\ndef g(matrix: List[List[int]]) -> int:\n    return f(matrix)\n\nmatrix = [\n    [1, 3, 1],\n    [1, 5, 1],\n    [4, 2, 1]\n]\nassert f(matrix) == g(matrix)\n",
        "idx_generation": 182,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, target: int) -> bool:\n    \"\"\"\n    Given an adjacency matrix representing a directed graph, determine if there is a path from the start node to the target node.\n    \"\"\"\n    stack = [start]\n    visited = set()\n\n    while stack:\n        node = stack.pop()\n        if node == target:\n            return True\n        visited.add(node)\n\n        neighbors = [i for i in range(len(graph[node])) if graph[node][i] == 1]\n        for neighbor in neighbors:\n            if neighbor not in visited:\n                stack.append(neighbor)\n\n    return False\n\ndef g():\n    return [[0, 1, 0, 0, 0],\n            [0, 0, 1, 0, 0],\n            [0, 0, 0, 1, 0],\n            [0, 0, 0, 0, 1],\n            [0, 0, 0, 0, 0]]\n\nassert f(g(), 0, 4)\n\n",
        "idx_generation": 261,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> int:\n    \"\"\"Given a directed acyclic graph represented as an adjacency list, find the number of distinct paths from start to end using dynamic programming.\"\"\"\n    def dfs(node):\n        if node == end:\n            return 1\n        if node in memo:\n            return memo[node]\n        \n        total = 0\n        for neighbor in graph[node]:\n            total += dfs(neighbor)\n        \n        memo[node] = total\n        return total\n    \n    memo = {}\n    return dfs(start)\n\ndef g():\n    return {1: [2, 3], 2: [3, 4], 3: [4], 4: []}, 1, 4\n\nassert f(*g()) == 3\n",
        "idx_generation": 187,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"Given an undirected graph represented as an adjacency list, return the number of connected components in the graph.\"\"\"\n    def dfs(v: int, visited: List[bool]):\n        visited[v] = True\n        for neighbor in graph[v]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited)\n    \n    n = len(graph)\n    visited = [False] * n\n    count = 0\n    \n    for v in range(n):\n        if not visited[v]:\n            dfs(v, visited)\n            count += 1\n    \n    return count\n\ndef g():\n    return [[1, 2], [0, 2], [0, 1], [3, 4], [3, 5], [4, 5]]\n\nassert f(g()) == 2\n\n",
        "idx_generation": 482,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two positive integers n and k, determine the number of ways to choose k elements from a set of n elements.\n    \"\"\"\n    if k == 0 or k == n:\n        return 1\n    elif k > n:\n        return 0\n    else:\n        return f(n - 1, k - 1) + f(n - 1, k)\n\ndef g(n=5, k=2):\n    \"\"\"\n    Generate two positive integers n and k such that k is less than or equal to n.\n    \"\"\"\n    return n, k\n\nassert f(*g()) == 10\n",
        "idx_generation": 247,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"Count the number of ways to choose k elements from a set of n elements.\"\"\"\n    if k == 0 or k == n:\n        return 1\n    else:\n        return f(n - 1, k - 1) + f(n - 1, k)\n\ndef g(n: int, k: int) -> List[int]:\n    \"\"\"Generate values for n and k.\"\"\"\n    return n, k\n\nassert f(*g(n=5, k=3)) == 10\n",
        "idx_generation": 245,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Find the first non-repeating character in a string.\"\"\"\n    def count_chars(string):\n        char_count = {}\n        for char in string:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n        return char_count\n    \n    char_count = count_chars(s)\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None\ndef g():\n    return \"aabbcdddeef\"\nassert f(g()) == 'c'\n",
        "idx_generation": 6,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exist two numbers in the given list that sum up to the target.\"\"\"\n    arr.sort()\n    left, right = 0, len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr=[1, 3, 5, 7, 9], target=12):\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 40,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Given an array 'arr' of integers, sort the array using the Bubble Sort algorithm.\"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\n\ndef g():\n    return [6, 2, 8, 1, 4, 9]\n\nassert f(g()) == [1, 2, 4, 6, 8, 9]\n",
        "idx_generation": 336,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in a given sorted array that sums up to the target value.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr=[1, 2, 3, 4, 5, 6, 7, 8, 9], target=10):\n    \"\"\"Generate a sorted array of integers and a target value.\"\"\"\n    return sorted(arr), target\n\nassert f(*g())\n",
        "idx_generation": 127,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, words=['apple', 'banana', 'cherry', 'date'], length=5) -> bool:\n    \"\"\"Find a string of length length that is present in the list of words\"\"\"\n    return len(s) == length and s in words\n\ndef g(words=['apple', 'banana', 'cherry', 'date'], length=5):\n    sorted_words = sorted(words, key=lambda x: len(x))\n    for word in sorted_words:\n        if len(word) == length:\n            return word\n\nassert f(g())\n\n",
        "idx_generation": 162,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Count the number of ways to reach the target sum by adding up the elements in the list.\"\"\"\n    memo = {}\n    \n    def count_ways(nums: List[int], target: int) -> int:\n        if target == 0:\n            return 1\n        if target < 0:\n            return 0\n        if len(nums) == 0:\n            return 0\n        if (len(nums), target) in memo:\n            return memo[(len(nums), target)]\n        include = count_ways(nums, target - nums[0])\n        exclude = count_ways(nums[1:], target)\n        memo[(len(nums), target)] = include + exclude\n        return include + exclude\n    \n    return count_ways(nums, target)\n\ndef g():\n    return ([1, 2, 3], 4)  # Return a list of numbers and a target sum\n\nassert f(*g()) == 4\n",
        "idx_generation": 215,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Check if two given strings are isomorphic, meaning that each character in the first string can be replaced with \n    a corresponding character in the second string, while preserving the order of characters.\n    \n    Return True if the strings are isomorphic, False otherwise.\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n    \n    mapping = {}\n    used_chars = set()\n    \n    for char1, char2 in zip(s1, s2):\n        if char1 in mapping:\n            if mapping[char1] != char2:\n                return False\n        else:\n            if char2 in used_chars:\n                return False\n            mapping[char1] = char2\n            used_chars.add(char2)\n    \n    return True\n\ndef g():\n    s1 = \"paper\"\n    s2 = \"title\"\n    return s1, s2\n\nassert f(*g())\n",
        "idx_generation": 283,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid filled with non-negative integers, find the minimum path sum from the top-left\n    cell to the bottom-right cell. You can only move down or right.\"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[m-1][n-1]\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"Returns the grid filled with non-negative integers\"\"\"\n    return grid\n\nassert f(g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]])) == 7\n",
        "idx_generation": 357,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer `n`, calculate the number of ways to climb to the top\n    of a staircase with n steps. You can climb either 1 or 2 steps at a time.\n    \"\"\"\n    if n <= 1:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\ndef g(n: int):\n    \"\"\"\n    Generate a positive integer `n` such that the number of ways to climb to the top\n    of a staircase with n steps can be calculated.\n    \"\"\"\n    return n\n\nassert f(g(5)) == 8\n",
        "idx_generation": 85,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, find the number of unique paths from (0, 0) to (n, n) on a n x n grid, where you can only move right or down.\n    \"\"\"\n    def helper(i, j):\n        if i == n and j == n:\n            return 1\n        if i > n or j > n:\n            return 0\n        return helper(i + 1, j) + helper(i, j + 1)\n    return helper(0, 0)\n\ndef g() -> int:\n    return 3\n\nassert f(g()) == 20\n",
        "idx_generation": 481,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome after removing at most one character.\n\n    Return True if the string is a palindrome after removing at most one character, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(s) - 1\n\n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s, left+1, right) or is_palindrome(s, left, right-1)\n        left += 1\n        right -= 1\n\n    return True\n\ndef is_palindrome(s: str, left: int, right: int) -> bool:\n    while left < right:\n        if s[left] != s[right]:\n            return False\n        left += 1\n        right -= 1\n\n    return True\n\ndef g():\n    s = \"abcba\"\n    return s\n\nassert f(g())\n",
        "idx_generation": 446,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list whose bitwise AND is equal to 0.\"\"\"\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] & nums[j] == 0:\n                return True\n    return False\n\ndef g():\n    \"\"\"Find a list of numbers that satisfy the condition of the puzzle.\"\"\"\n    return [2, 4, 6, 8, 10]\n\nassert f(g())\n",
        "idx_generation": 193,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the nth Fibonacci number.\n    The Fibonacci sequence starts with 0 and 1, and each subsequent number is the sum of the two preceding numbers.\n    \"\"\"\n    if n <= 1:\n        return n\n    fib = [0] * (n + 1)\n    fib[1] = 1\n    for i in range(2, n + 1):\n        fib[i] = fib[i - 1] + fib[i - 2]\n    return fib[n]\n\ndef g():\n    return 8\n\nassert f(g()) == 21\n",
        "idx_generation": 199,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Determine if there is a path from the start node to the end node in the graph.\"\"\"\n    visited = [False] * len(graph)\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                stack.append(neighbor)\n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a graph with 5 nodes and random connections.\"\"\"\n    return [[1, 2], [0, 2, 3], [0, 1, 3, 4], [1, 2, 4], [2, 3]]\n\nassert f(g(), start=0, end=4)\n",
        "idx_generation": 276,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"Given a graph with n nodes and a list of edges, determine if the graph contains a cycle.\"\"\"\n    def has_cycle(graph, visited, node, parent):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if has_cycle(graph, visited, neighbor, node):\n                    return True\n            elif parent != neighbor:\n                return True\n        return False\n\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    visited = [False] * n\n    for node in range(n):\n        if not visited[node]:\n            if has_cycle(graph, visited, node, -1):\n                return True\n    return False\n\ndef g(n: int = 4, edges: List[List[int]] = [[0,1], [1,2], [2,3], [3,1]]):\n    return n, edges\n\nassert f(*g()) == True\n",
        "idx_generation": 190,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start=0, end=3) -> bool:\n    \"\"\"Determine if there exists a path from the start node to the end node in the given graph.\"\"\"\n    visited = set()\n    def dfs(node):\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n        return False\n    return dfs(start)\n\ndef g():\n    return {0: [1, 2], 1: [2], 2: [3], 3: []}\n\nassert f(g())\n",
        "idx_generation": 490,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"Find if it is possible to transform string s into string t by performing the following operations:\n    1. Remove any character from s.\n    2. Insert any character at any position in s.\n    3. Replace any character in s with any other character.\"\"\"\n    count_s = Counter(s)\n    count_t = Counter(t)\n    for char, freq in count_t.items():\n        if char not in count_s or count_s[char] < freq:\n            return False\n    return True\ndef g(s: str, t: str):\n    return s + t\nassert f(g('abc', 'abcd'), 'abcd')\n",
        "idx_generation": 268,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, find the number of possible combinations of k elements from a set of n elements, without repetition.\n    \"\"\"\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return f(n - 1, k - 1) + f(n - 1, k)\n\ndef g(n=5, k=3):\n    \"\"\"\n    Generate two integers n and k.\n    \"\"\"\n    return n, k\n\nassert f(*g()) == 10\n\n",
        "idx_generation": 261,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport itertools\n\ndef f(s: str, words=['dog', 'cat', 'bird', 'snake'], target=6) -> bool:\n    \"\"\"Find a combination of words that have a total length equal to the target value\"\"\"\n    for r in range(len(words) + 1):\n        for combination in itertools.combinations(words, r):\n            if sum(len(word) for word in combination) == target:\n                return True\n    return False\ndef g(words=['dog', 'cat', 'bird', 'snake'], target=6):\n    for r in range(len(words) + 1):\n        for combination in itertools.combinations(words, r):\n            if sum(len(word) for word in combination) == target:\n                return combination\nassert f(g())\n",
        "idx_generation": 8,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Determine if the given matrix is a symmetric matrix.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    if rows != cols:\n        return False\n    for i in range(rows):\n        for j in range(cols):\n            if matrix[i][j] != matrix[j][i]:\n                return False\n    return True\ndef g():\n    return [[1, 2, 3],\n            [2, 4, 5],\n            [3, 5, 6]]\nassert f(g())\n",
        "idx_generation": 42,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target number, determine if two numbers in the list add up to the target.\n    \n    Return True if there exist two numbers in the list that add up to the target, otherwise return False.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(nums: List[int], target: int) -> bool:\n    return f(nums, target)\n\nnums = [1, 2, 3, 4, 5]\ntarget = 7\nassert f(nums, target) == g(nums, target)\n\n",
        "idx_generation": 348,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, return True if there exists a pair of numbers whose sum is equal to a target value.\n    Otherwise, return False.\n\n    Args:\n    - nums: A list of integers.\n    \n    Returns:\n    - A boolean value indicating whether a pair of numbers whose sum is equal to the target value exists.\n    \"\"\"\n    nums.sort()  # Sort the list in ascending order\n    left = 0\n    right = len(nums) - 1\n    target = 10\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g() -> List[int]:\n    \"\"\"Generate a list of integers.\"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g())\n",
        "idx_generation": 136,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"Check if a string can be transformed into another string by removing exactly one character.\"\"\"\n    if len(s) != len(target) + 1:\n        return False\n\n    i, j = 0, 0\n    while i < len(s) and j < len(target):\n        if s[i] == target[j]:\n            i += 1\n            j += 1\n        else:\n            i += 1\n\n    return j == len(target)\n\ndef g():\n    return \"python\", \"pyton\"\n\nassert f(*g())\n",
        "idx_generation": 164,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if there exists a subset of the list\n    such that the sum of the subset is equal to the target value.\n    Return True if such subset exists, False otherwise.\"\"\"\n    dp = [False] * (target + 1)\n    dp[0] = True\n    \n    for num in arr:\n        for i in range(target, num - 1, -1):\n            if dp[i - num]:\n                dp[i] = True\n    \n    return dp[target]\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Generate a list of integers and a target value.\"\"\"\n    arr = [2, 4, 6, 8, 10]\n    target = 18\n    \n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 216,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(pattern: str, string: str) -> bool:\n    \"\"\"Given a pattern and a string, determine if the string follows the same pattern. \n    The pattern consists of lowercase letters and the string consists of lowercase letters separated by a space.\n    Sample input:\n    pattern = \"abba\"\n    string = \"dog cat cat dog\"\n    Sample output:\n    True\"\"\"\n    words = string.split()\n    if len(words) != len(pattern):\n        return False\n    pattern_map = {}\n    used_words = set()\n    for i in range(len(pattern)):\n        if pattern[i] not in pattern_map:\n            if words[i] in used_words:\n                return False\n            pattern_map[pattern[i]] = words[i]\n            used_words.add(words[i])\n        else:\n            if pattern_map[pattern[i]] != words[i]:\n                return False\n    return True\n\ndef g():\n    return \"abba\", \"dog cat cat dog\"\n\nassert f(*g()) == True\n",
        "idx_generation": 287,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Find the sum of all the elements in the given matrix.\"\"\"\n    if not matrix:\n        return 0\n\n    rows, cols = len(matrix), len(matrix[0])\n    total_sum = 0\n\n    for row in range(rows):\n        for col in range(cols):\n            total_sum += matrix[row][col]\n\n    return total_sum\n\ndef g():\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\nassert f(g()) == 45\n",
        "idx_generation": 361,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> int:\n    \"\"\"Find the length of the longest palindromic subsequence in the given string\"\"\"\n    n = len(string)\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][i] = 1\n    \n    for cl in range(2, n+1):\n        for i in range(n-cl+1):\n            j = i+cl-1\n            if string[i] == string[j] and cl == 2:\n                dp[i][j] = 2\n            elif string[i] == string[j]:\n                dp[i][j] = dp[i+1][j-1] + 2\n            else:\n                dp[i][j] = max(dp[i][j-1], dp[i+1][j])\n    \n    return dp[0][n-1]\n\ndef g(string: str) -> str:\n    \"\"\"Return the given string\"\"\"\n    return string\n\nassert f(g(\"babad\")) == 3\n",
        "idx_generation": 87,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Determine if it is possible to reach the bottom-right corner of the grid starting from the top-left corner, given that each cell in the grid represents the maximum number of steps that can be taken to move right or down.\n    The goal is to find a path that reaches the bottom-right corner.\"\"\"\n    def backtrack(grid, row, col):\n        if row == len(grid) - 1 and col == len(grid[0]) - 1:\n            return True\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] == -1:\n            return False\n        return (\n            backtrack(grid, row + grid[row][col], col)\n            or backtrack(grid, row, col + grid[row][col])\n        )\n\n    return backtrack(grid, 0, 0)\n\ndef g():\n    grid = [\n        [2, 5, 1, 1],\n        [1, -1, 1, 3],\n        [1, 2, 1, -1],\n        [1, 1, 1, 1]\n    ]\n    return grid\n\nassert f(g())\n",
        "idx_generation": 489,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str, pattern: str) -> bool:\n    \"\"\"Determine if the given string matches the given pattern, where each character in the pattern can represent any sequence of characters in the string\"\"\"\n    if len(string) == 0 and len(pattern) == 0:\n        return True\n    if len(pattern) == 0:\n        return False\n    if pattern[0] == '*':\n        return f(string, pattern[1:]) or (len(string) > 0 and f(string[1:], pattern))\n    else:\n        if len(string) > 0 and (string[0] == pattern[0] or pattern[0] == '?'):\n            return f(string[1:], pattern[1:])\n        else:\n            return False\ndef g(string=\"abcde\", pattern=\"a*c?e\"):\n    return string, pattern\nassert f(*g())",
        "idx_generation": 453,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(x: int) -> int:\n    \"\"\"Count the number of set bits (1s) in the binary representation of the given number.\"\"\"\n    count = 0\n    while x:\n        count += x & 1\n        x >>= 1\n    return count\n\ndef g():\n    \"\"\"Generate a number to be counted for set bits in the binary representation.\"\"\"\n    return 42\n\nassert f(g()) == 3\n",
        "idx_generation": 196,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of non-negative integers and a target sum, determine if it is possible to \n    form the target sum by adding up the elements from the list, with repetition allowed.\"\"\"\n    \n    def can_sum(nums: List[int], target: int, memo: Dict[int, bool]) -> bool:\n        if target in memo:\n            return memo[target]\n        if target == 0:\n            return True\n        if target < 0:\n            return False\n\n        for num in nums:\n            if can_sum(nums, target - num, memo):\n                memo[target] = True\n                return True\n\n        memo[target] = False\n        return False\n    \n    return can_sum(nums, target, {})\n\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"Generate a list of non-negative integers with random values between 1 and 10.\"\"\"\n    import random\n    nums = []\n    for _ in range(5):\n        nums.append(random.randint(1, 10))\n    return (nums, target)\n\n\nnums, target = g([], 15)\nassert f(*g(nums, target))\n",
        "idx_generation": 199,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: dict, start: str, end: str) -> bool:\n    \"\"\"Determine if there is a path from start to end in a directed graph.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        visited.add(node)\n        stack.extend(neighbor for neighbor in graph[node] if neighbor not in visited)\n    return False\n\ndef g():\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['D'],\n        'C': ['E'],\n        'D': [],\n        'E': ['F'],\n        'F': ['G'],\n        'G': []\n    }\n    return graph, 'A', 'G'\n\nassert f(*g())\n",
        "idx_generation": 276,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, grid: List[List[int]]) -> bool:\n    \"\"\"Determine if it is possible to reach the bottom right cell (n-1, m-1) from the top left cell (0, 0) in a grid with obstacles.\"\"\"\n    if grid[0][0] == 1 or grid[n-1][m-1] == 1:\n        return False\n    \n    dp = [[False for _ in range(m)] for _ in range(n)]\n    \n    dp[0][0] = True\n    \n    for i in range(1, n):\n        if grid[i][0] == 1:\n            break\n        dp[i][0] = True\n    \n    for j in range(1, m):\n        if grid[0][j] == 1:\n            break\n        dp[0][j] = True\n    \n    for i in range(1, n):\n        for j in range(1, m):\n            if grid[i][j] == 0:\n                dp[i][j] = dp[i-1][j] or dp[i][j-1]\n    \n    return dp[n-1][m-1]\n\n\ndef g(n=3, m=3, grid=[[0, 0, 0], [0, 0, 0], [0, 0, 0]]):\n    \"\"\"Generate a grid with obstacles and its dimensions.\"\"\"\n    return n, m, grid\n\nassert f(*g())\n",
        "idx_generation": 197,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Check if the given string contains exactly k distinct characters.\"\"\"\n    return len(set(s)) == k\n\ndef g():\n    s = 'abracadabra'\n    k = 5\n    return s, k\n\nassert f(*g())\n",
        "idx_generation": 274,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int, res: int) -> bool:\n    \"\"\"Find the number of ways to arrange n distinct objects in a row such that there are exactly k objects between two specific objects\"\"\"\n    def count_arrangements(n, k):\n        if k == 0:\n            return 1\n        if k > n:\n            return 0\n        return count_arrangements(n - 1, k - 1) + count_arrangements(n - 1, k)\n\n    return count_arrangements(n, k) == res\n\ndef g(n=5, k=2, res=10):\n    return n, k, res\n\nassert f(*g())\n",
        "idx_generation": 270,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str, substr: str, count: int) -> bool:\n    \"\"\"Check if the given string contains at least 'count' number of occurrences of the substring\"\"\"\n    return string.count(substr) >= count\ndef g(string: str, substr: str, count: int):\n    return string * count + substr * (count - 1)\nassert f(g(\"hello\", \"lo\", 3), \"lo\", 3)\n",
        "idx_generation": 34,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, return True if the target value exists in the list, and False otherwise.\n    The list is sorted in non-decreasing order.\n    Sample Input:\n    nums = [1, 3, 5, 7, 9, 11, 13, 15]\n    target = 9\n    Sample Output:\n    True\"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n    \ndef g(nums=[1, 3, 5, 7, 9, 11, 13, 15], target=9):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 45,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Sort the list of integers in non-decreasing order using a stack.\"\"\"\n    stack = []\n    for num in nums:\n        while stack and num < stack[-1]:\n            nums.append(stack.pop())\n        stack.append(num)\n    return stack\n\ndef g() -> List[int]:\n    return [5, 2, 9, 3, 1]\n\nassert f(g()) == [1, 2, 3, 5, 9]\n",
        "idx_generation": 357,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence.\"\"\"\n    if not nums:\n        return 0\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 149,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], target: str) -> bool:\n    \"\"\"Given a list of words and a target word, determine if the target word is present in the list of words.\n    Return True if the target word is present, False otherwise.\"\"\"\n    return target in words\n\ndef g(words: List[str], target: str) -> bool:\n    return f(words, target)\n\nwords = [\"apple\", \"banana\", \"orange\", \"grape\"]\ntarget = \"banana\"\nassert f(words, target) == g(words, target)\n",
        "idx_generation": 203,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if a given list of integers can be divided into two subsets with equal sum\"\"\"\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n    \n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n\n    for num in nums:\n        for i in range(target_sum, num-1, -1):\n            dp[i] = dp[i] or dp[i - num]\n\n    return dp[target_sum]\n\ndef g(nums=[1, 5, 11, 5]):\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 218,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings 's' and 't', check if 't' is an anagram of 's'.\n    An anagram is a word or phrase formed by rearranging the letters of a different word or phrase.\n    Return True if 't' is an anagram of 's', False otherwise.\n    \"\"\"\n    if len(s) != len(t):\n        return False\n    \n    count = [0] * 26\n    \n    for i in range(len(s)):\n        count[ord(s[i]) - ord('a')] += 1\n        count[ord(t[i]) - ord('a')] -= 1\n    \n    for c in count:\n        if c != 0:\n            return False\n    \n    return True\n\ndef g():\n    \"\"\"\n    Generate two strings.\n    \"\"\"\n    s = \"listen\"\n    t = \"silent\"\n    \n    return s, t\n\nassert f(*g()) == True\n",
        "idx_generation": 288,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, find if there exists a subarray with a sum equal to zero.\"\"\"\n    prefix_sum = 0\n    sum_set = set()\n\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum == 0 or prefix_sum in sum_set:\n            return True\n        sum_set.add(prefix_sum)\n\n    return False\n\ndef g() -> List[int]:\n    \"\"\"Generate a list of integers.\"\"\"\n    return [4, -6, 3, 1, -2, 3, -4, 7]\n\nassert f(g())\n",
        "idx_generation": 362,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum sum that can be obtained by choosing a subarray\n    such that no two adjacent elements are selected.\n    Example:\n    arr = [1, 2, 3, 1]\n    The maximum sum can be obtained by selecting the subarray [1, 3], which gives a sum of 4.\n    Therefore, the answer is 4.\n    \"\"\"\n    if not arr:\n        return 0\n    n = len(arr)\n    dp = [0] * (n + 1)\n    dp[1] = arr[0]\n    for i in range(2, n + 1):\n        dp[i] = max(dp[i - 1], dp[i - 2] + arr[i - 1])\n    return dp[n]\n\ndef g():\n    return [1, 2, 3, 1]\n\nassert f(g()) == 4\n",
        "idx_generation": 88,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two positive integers n and m, find the number of unique paths from the top-left cell of an n x m grid\n    to the bottom-right cell. You can only move down or right.\n\n    Example:\n    Input:\n    n = 3, m = 4\n    Output:\n    10\n\n    Explanation:\n    The grid is as follows:\n    1  1  1  1\n    1  2  3  4\n    1  3  6 10\n    The number of unique paths from top-left to bottom-right is 10.\n    \"\"\"\n\n    dp = [[0] * m for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][0] = 1\n    \n    for j in range(m):\n        dp[0][j] = 1\n    \n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[n-1][m-1]\n\ndef g(n: int, m: int) -> int:\n    \"\"\"\n    Find the number of unique paths from the top-left cell to the bottom-right cell of an n x m grid.\n    \"\"\"\n\n    dp = [[0] * m for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][0] = 1\n    \n    for j in range(m):\n        dp[0][j] = 1\n    \n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[n-1][m-1]\n\nassert f(n=3, m=4) == g(n=3, m=4)\n",
        "idx_generation": 496,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string 's', check if it is a valid palindrome after deleting at most one character.\n    Return True if it is a valid palindrome, otherwise return False.\n    \"\"\"\n    def is_palindrome(string, left, right):\n        while left < right:\n            if string[left] != string[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n    \n    left = 0\n    right = len(s) - 1\n    \n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s, left + 1, right) or is_palindrome(s, left, right - 1)\n        left += 1\n        right -= 1\n    \n    return True\n\ndef g():\n    \"\"\"\n    Generate a string 's'.\n    \"\"\"\n    s = \"racecar\"\n    \n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 457,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"Count the number of set bits (1s) in the binary representation of the given number\"\"\"\n    count = 0\n    while num:\n        count += num & 1\n        num >>= 1\n    return count\n\ndef g(num=42):\n    \"\"\"Generate an integer\"\"\"\n    return num\n\nassert f(g()) == 3\n",
        "idx_generation": 196,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the n-th number in the Fibonacci sequence.\"\"\"\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\ndef g(n=6):\n    \"\"\"Generate the position of the number in the Fibonacci sequence.\"\"\"\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 200,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start='A', end='G') -> bool:\n    \"\"\"Determine if there exists a path from the start node to the end node in the given graph.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        visited.add(node)\n        if node == end:\n            return True\n        neighbors = graph.get(node, [])\n        for neighbor in neighbors:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    return False\ndef g():\n    return {\n        'A': ['B', 'C'],\n        'B': ['D'],\n        'C': ['D', 'E'],\n        'D': ['E', 'G'],\n        'E': ['F'],\n        'F': [],\n        'G': []\n    }\nassert f(g())\n",
        "idx_generation": 286,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"Determine whether a given graph is a tree or not.\"\"\"\n    if len(edges) != n - 1:\n        return False\n    \n    graph = {i: [] for i in range(n)}\n    \n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    visited = [False] * n\n    \n    def is_cyclic(node, parent):\n        visited[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if is_cyclic(neighbor, node):\n                    return True\n            elif neighbor != parent:\n                return True\n        \n        return False\n    \n    if is_cyclic(0, -1):\n        return False\n    \n    return all(visited)\n\n\ndef g(n=4, edges=[[0, 1], [0, 2], [0, 3]]):\n    \"\"\"Generate a graph represented by its number of nodes and edges.\"\"\"\n    return n, edges\n\nassert f(*g())\n",
        "idx_generation": 197,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Given an integer n, generate a Pascal's triangle of size n.\n    \"\"\"\n    triangle = [[1] * (i + 1) for i in range(n)]\n    \n    for i in range(2, n):\n        for j in range(1, i):\n            triangle[i][j] = triangle[i-1][j-1] + triangle[i-1][j]\n            \n    return triangle\n\ndef g(n=5):\n    \"\"\"\n    Generate an integer n to determine the size of Pascal's triangle.\n    \"\"\"\n    return n\n\nassert f(g()) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n",
        "idx_generation": 275,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, res: int) -> bool:\n    \"\"\"Find the number of ways to tile a grid of size n x 2 using tiles of size 1 x 2 and 2 x 2\"\"\"\n    def count_tilings(n):\n        if n <= 1:\n            return 1\n        return count_tilings(n - 1) + count_tilings(n - 2)\n\n    return count_tilings(n) == res\n\ndef g(n=4, res=5):\n    return n, res\n\nassert f(*g())\n",
        "idx_generation": 270,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str, pattern='abcde') -> bool:\n    \"\"\"Given a string and a pattern, determine if the pattern can be formed by permuting the characters of the string.\n    The function should return True if the pattern can be formed, and False otherwise.\"\"\"\n    if len(string) != len(pattern):\n        return False\n    count = {}\n    for ch in string:\n        if ch in count:\n            count[ch] += 1\n        else:\n            count[ch] = 1\n    for ch in pattern:\n        if ch not in count or count[ch] == 0:\n            return False\n        count[ch] -= 1\n    return True\n\ndef g(pattern='abcde'):\n    return ''.join(sorted(pattern))\n\nassert f(g())\n",
        "idx_generation": 44,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers and a target value, find the index of the target value using binary search.\n    If the target value is not found, return -1.\n    Sample input:\n    nums = [2, 4, 6, 8, 10]\n    target = 8\n    Sample output:\n    3\"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    return [2, 4, 6, 8, 10], 8\n\nassert f(*g()) == 3\n",
        "idx_generation": 48,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there are two numbers in the given list that add up to the target.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    return [2, 4, 7, 11, 15], 9\n\nassert f(*g())\n",
        "idx_generation": 363,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Given a list of integers, find the longest increasing subsequence (LIS) in the array.\n    The LIS is a subsequence in the array where the elements are in increasing order, and they are not necessarily contiguous.\n    Return the length of the LIS.\"\"\"\n    n = len(arr)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g(arr: List[int]) -> int:\n    return f(arr)\n\narr = [10, 22, 9, 33, 21, 50, 41, 60]\nassert f(arr) == g(arr)\n",
        "idx_generation": 159,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> List[str]:\n    \"\"\"Given a string s, return a list of all possible substrings of s, sorted in lexicographic order.\"\"\"\n    substrings = []\n    \n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            substrings.append(s[i:j])\n    \n    substrings.sort()\n    return substrings\n\ndef g(s: str) -> List[str]:\n    return f(s)\n\ns = \"abc\"\nassert f(s) == g(s)\n",
        "idx_generation": 205,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of ways to climb n stairs, where you can climb either 1 or 2 steps at a time.\"\"\"\n    if n <= 1:\n        return 1\n    return f(n-1) + f(n-2)\ndef g():\n    return 5\nassert f(g()) == 8\n",
        "idx_generation": 236,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k=3, n=5) -> bool:\n    \"\"\"Find if a string can be formed by concatenating k copies of a substring of length n\"\"\"\n    if len(s) % (n * k) != 0:\n        return False\n    substring = s[:n]\n    return substring * k == s\ndef g(k=3, n=5):\n    substring = 'abcde'\n    return substring * k\nassert f(g())\n",
        "idx_generation": 288,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a given number is a prime number.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g())\n",
        "idx_generation": 371,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the longest increasing subsequence in a given list of numbers\"\"\"\n    if not nums:\n        return 0\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g(nums: List[int]) -> List[int]:\n    return nums\n\nnums = [10, 22, 9, 33, 21, 50, 41, 60]\nassert f(g(nums)) == 5\n",
        "idx_generation": 89,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"Check if a given string is a palindrome.\"\"\"\n    string = string.lower()\n    string = ''.join(c for c in string if c.isalnum())\n    return string == string[::-1]\n\ndef g(string=\"A man, a plan, a canal: Panama\") -> str:\n    \"\"\"Return the given string.\"\"\"\n    return string\n\nassert f(g()) == True\n",
        "idx_generation": 471,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given an integer n, return the number of set bits (bits with value 1) in its binary representation.\"\"\"\n    binary = bin(n)[2:]\n    count = 0\n    \n    for bit in binary:\n        if bit == '1':\n            count += 1\n    \n    return count\n\ndef g(n: int) -> int:\n    return f(n)\n\nn = 10\nassert f(n) == g(n)\n",
        "idx_generation": 205,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the number of unique paths from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n    Return the number of unique paths.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = 1\n\n    for i in range(1, m):\n        dp[i][0] = 1\n\n    for j in range(1, n):\n        dp[0][j] = 1\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[m-1][n-1]\n\ndef g():\n    return [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1]\n    ]\n\nassert f(g()) == 6\n\n",
        "idx_generation": 200,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"\n    Given a directed graph represented as a dictionary, determine if there is a path from the start node to the end node.\n    Return True if a path exists, False otherwise.\n    \"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g():\n    \"\"\"\n    Generate a directed graph represented as a dictionary, and choose start and end nodes.\n    \"\"\"\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['D', 'E'],\n        'C': [],\n        'D': [],\n        'E': ['F'],\n        'F': []\n    }\n    start = 'A'\n    end = 'F'\n    return graph, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 305,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: List[List[int]], start: int, end: int, k: int) -> bool:\n    \"\"\"Given a graph represented as an adjacency list and two nodes start and end, determine if there exists a path from start to end with exactly k edges.\n    Return True if such path exists, False otherwise.\"\"\"\n    \n    def dfs(node, edges):\n        if node == end and edges == k:\n            return True\n        if edges >= k:\n            return False\n        for neighbor in graph[node]:\n            if dfs(neighbor, edges + 1):\n                return True\n        return False\n\n    return dfs(start, 0)\n\ndef g(graph: List[List[int]], start: int, end: int, k: int) -> List[List[int]]:\n    \"\"\"Generate a graph and return the adjacency list.\"\"\"\n    return graph\n\ngraph = [[1, 2], [3, 4, 5], [6], [7], [], [8], [9], [], [10], []]\nstart = 0\nend = 10\nk = 4\n\nassert f(g(graph, start, end, k), start, end, k) == True\n",
        "idx_generation": 198,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\nfrom math import comb\n\ndef f(n: int, r: int) -> int:\n    \"\"\"\n    Given two integers 'n' and 'r', calculate the number of combinations (nCr) using the comb() function from the math module.\n    Return the number of combinations.\n    \"\"\"\n    return comb(n, r)\n\ndef g():\n    \"\"\"\n    Generate two integers.\n    \"\"\"\n    n = 6\n    r = 3\n    \n    return n, r\n\nassert f(*g()) == 20\n",
        "idx_generation": 284,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of numbers, determine if there exists a subset whose sum is equal to the target value.\"\"\"\n    def subset_sum(nums, target, index, memo):\n        if target == 0:\n            return True\n        if index == len(nums):\n            return False\n        if memo[index][target] != -1:\n            return memo[index][target]\n        \n        if nums[index] <= target:\n            if subset_sum(nums, target - nums[index], index + 1, memo):\n                memo[index][target] = True\n                return True\n        \n        memo[index][target] = subset_sum(nums, target, index + 1, memo)\n        return memo[index][target]\n    \n    if not nums:\n        return False\n    \n    n = len(nums)\n    memo = [[-1] * (target + 1) for _ in range(n)]\n    \n    return subset_sum(nums, target, 0, memo)\n\n\ndef g(nums=[2, 4, 6, 8, 10], target=14):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 282,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string s, determine if it can be rearranged into a palindrome by rearranging its characters.\"\"\"\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    odd_count = 0\n    for count in char_count.values():\n        if count % 2 != 0:\n            odd_count += 1\n    return odd_count <= 1\ndef g():\n    return \"racecar\"\nassert f(g())\n",
        "idx_generation": 109,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if there exists a pair of numbers in the list whose sum is equal to the target\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums: List[int], target: int) -> Tuple[List[int], int]:\n    \"\"\"Generate a list of unique integers and a target number\"\"\"\n    return list(set(nums)), target\n\nassert f(*g([1, 2, 3, 4, 5], 7))\n",
        "idx_generation": 48,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, find the next greater element for each element in the list.\n    If there is no greater element, replace it with -1.\"\"\"\n    stack = []\n    result = [-1] * len(arr)\n\n    for i in range(len(arr)):\n        while stack and arr[i] > arr[stack[-1]]:\n            index = stack.pop()\n            result[index] = arr[i]\n        stack.append(i)\n\n    return result\n\ndef g() -> List[int]:\n    \"\"\"Generate a list of distinct integers.\"\"\"\n    return [4, 5, 2, 9, 8]\n\nassert f(g()) == [5, 9, 9, -1, -1]\n",
        "idx_generation": 371,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(arr: List[int], target=5) -> bool:\n    \"\"\"Find if there exists a subset of arr that sums up to the target\"\"\"\n    n = len(arr)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if arr[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[n][target]\ndef g(target=5):\n    import random\n    arr = random.sample(range(1, 10), 5)\n    return arr\nassert f(g())\n",
        "idx_generation": 161,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"Check if string 't' is an anagram of string 's'.\"\"\"\n    return sorted(s) == sorted(t)\n\ndef g(s=\"listen\", t=\"silent\") -> Tuple[str, str]:\n    \"\"\"Return two strings that are anagrams of each other.\"\"\"\n    return s, t\n\nassert f(*g())\n",
        "idx_generation": 207,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Given a list of integers and a target number k, check if there exists a contiguous subarray of length k in the list whose product is divisible by k.\n    Sample input:\n    [1, 2, 3, 4, 5], 3\n    Sample output:\n    True\"\"\"\n    prefix_product = 1\n    for i in range(k):\n        prefix_product *= nums[i]\n\n    if prefix_product % k == 0:\n        return True\n\n    for i in range(k, len(nums)):\n        prefix_product = (prefix_product // nums[i-k]) * nums[i]\n        if prefix_product % k == 0:\n            return True\n\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5], 3\n\nassert f(*g())\n",
        "idx_generation": 237,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n=3) -> bool:\n    \"\"\"Given a string and a number n, find if it is possible to rearrange the string such that no two adjacent characters are the same.\n    Return True if possible, False otherwise.\"\"\"\n    if n <= 1:\n        return True\n\n    frequency = {}\n    for char in s:\n        if char not in frequency:\n            frequency[char] = 0\n        frequency[char] += 1\n\n    max_frequency = max(frequency.values())\n    if max_frequency > (len(s) + 1) // 2:\n        return False\n\n    return True\n\ndef g(n=3):\n    return \"aabbc\"\n\nassert f(g())\n",
        "idx_generation": 329,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum sum of a subarray.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n\n",
        "idx_generation": 377,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the n-th number in the Fibonacci sequence using recursion.\"\"\"\n    if n <= 1:\n        return n\n    else:\n        return f(n-1) + f(n-2)\ndef g(n=6):\n    return n\nassert f(g()) == 8\n",
        "idx_generation": 90,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str, k=3) -> bool:\n    \"\"\"\n    Given a string 'string' and an integer 'k', check if the string can be divided into k equal parts such that each part is a palindrome.\n    Return True if it is possible, False otherwise.\n    \"\"\"\n    if len(string) % k != 0:\n        return False\n    \n    n = len(string)\n    part_len = n // k\n    \n    for i in range(0, n, part_len):\n        if string[i:i+part_len] != string[i:i+part_len][::-1]:\n            return False\n    \n    return True\n\ndef g():\n    \"\"\"\n    Generate a string with a pattern of palindromic parts.\n    \"\"\"\n    return \"abbaabbaabba\"\n\nassert f(g(), k=3) == True\n",
        "idx_generation": 475,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int, k=2) -> bool:\n    \"\"\"Count the number of set bits in the binary representation of a given number and return True if the count is equal to k, otherwise return False.\"\"\"\n    binary = bin(num)[2:]\n    count = binary.count('1')\n    return count == k\ndef g(k=2):\n    num = 10\n    return num\nassert f(g())\n",
        "idx_generation": 207,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, calculate the factorial of n.\n    Return the factorial.\n    \"\"\"\n    if n == 0:\n        return 1\n    return n * f(n-1)\n\ndef g():\n    return 5\n\nassert f(g()) == 120\n\n",
        "idx_generation": 217,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"\n    Given a directed graph and two nodes, determine if there is a path from the start node to the end node.\n    Sample Input:\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D'],\n        'D': ['E'],\n        'E': []\n    }\n    start = 'A'\n    end = 'E'\n    Sample Output:\n    True\n    Explanation:\n    There is a path from 'A' to 'E': 'A' -> 'C' -> 'D' -> 'E'.\n    \"\"\"\n    stack = [start]\n    visited = set()\n    \n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    \n    return False\n\ndef g(graph: Dict[str, List[str]], start: str, end: str):\n    return graph, start, end\n\nassert f(*g({'A': ['B', 'C'], 'B': ['C', 'D'], 'C': ['D'], 'D': ['E'], 'E': []}, 'A', 'E')) == True\n",
        "idx_generation": 317,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a graph represented as an adjacency list and two nodes start and end, determine if there exists a path from start to end.\n    Return True if such path exists, False otherwise.\"\"\"\n    \n    visited = set()\n    \n    def dfs(node):\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n        return False\n\n    return dfs(start)\n\ndef g(graph: List[List[int]], start: int, end: int) -> List[List[int]]:\n    \"\"\"Generate a graph and return the adjacency list.\"\"\"\n    return graph\n\ngraph = [[1, 2], [3, 4, 5], [6], [7], [], [8], [9], [], [10], []]\nstart = 0\nend = 10\n\nassert f(g(graph, start, end), start, end) == True\n",
        "idx_generation": 198,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"Given two integers n and k, find the number of ways to choose k items from n items, considering that the order of selection does not matter.\"\"\"\n    def factorial(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n-1)\n    return factorial(n) // (factorial(k) * factorial(n-k))\ndef g(n=5, k=2):\n    return n, k\nassert f(*g()) == 10\n",
        "idx_generation": 307,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, calculate the number of ways to represent n as a sum of unique positive integers.\n    Return the total number of ways.\"\"\"\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            dp[j] += dp[j - i]\n    \n    return dp[n]\n\ndef g(n: int) -> int:\n    \"\"\"Generate a positive integer.\"\"\"\n    return 5\n\nassert f(g(5)) == 7\n\n",
        "idx_generation": 284,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import itertools\nfrom typing import*\nfrom itertools import permutations\n\ndef f(s: str) -> List[str]:\n    \"\"\"Generate all permutations of the characters in s\"\"\"\n    return [''.join(perm) for perm in permutations(s)]\n\ndef g():\n    return \"abc\"\n\nassert f(g()) == ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n",
        "idx_generation": 118,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"Find the kth largest element in the given list.\"\"\"\n    nums.sort()\n    return nums[-k]\n\ndef g(nums=[9, 2, 4, 7, 1, 5, 3], k=2):\n    return nums\n\nassert f(g(), 2) == 7\n",
        "idx_generation": 51,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list using the bubble sort algorithm.\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    return nums\n\ndef g():\n    return [4, 2, 7, 1, 5, 3, 6]\n\nassert f(g()) == [1, 2, 3, 4, 5, 6, 7]\n\n",
        "idx_generation": 382,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> Tuple[int, int]:\n    \"\"\"Given an array of integers arr and a target number, return the indices of two numbers in the array that add up to the target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\"\"\"\n    num_map = {}\n    for i, num in enumerate(arr):\n        complement = target - num\n        if complement in num_map:\n            return (num_map[complement], i)\n        num_map[num] = i\n    return (-1, -1)\n\ndef g():\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == (0, 1)\n",
        "idx_generation": 165,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in non-decreasing order, \n    but all even numbers should come before all odd numbers.\n\n    Example:\n    Input: [3, 1, 4, 2, 5, 6]\n    Output: [2, 4, 6, 1, 3, 5]\n    \"\"\"\n    even_nums = [x for x in nums if x % 2 == 0]\n    odd_nums = [x for x in nums if x % 2 == 1]\n    even_nums.sort()\n    odd_nums.sort()\n    return even_nums + odd_nums\n\ndef g():\n    return [3, 1, 4, 2, 5, 6]\n\nassert f(g()) == [2, 4, 6, 1, 3, 5]\n",
        "idx_generation": 231,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, return the number of trailing zeroes in n! (n factorial).\n    Sample input:\n    n = 10\n    Sample output:\n    2 (10! = 3628800, which has 2 trailing zeroes)\"\"\"\n    count = 0\n    while n > 0:\n        n //= 5\n        count += n\n    return count\n\ndef g():\n    return 10\n\nassert f(g()) == 2\n",
        "idx_generation": 245,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Determine if a string can be rearranged into a palindrome by changing at most k characters.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n    Return True if it is possible to rearrange the string into a palindrome by changing at most k characters, otherwise return False.\n    Sample input:\n    s = \"radar\"\n    k = 2\n    Sample output:\n    True\"\"\"\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    \n    if is_palindrome(s):\n        return True\n    \n    count = 0\n    left = 0\n    right = len(s) - 1\n    \n    while left < right:\n        if s[left] != s[right]:\n            count += 1\n        left += 1\n        right -= 1\n    \n    return count <= k\n\ndef g():\n    return \"radar\", 2\n\nassert f(*g())\n",
        "idx_generation": 332,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Given an array of integers, find the maximum sum of any contiguous subarray.\n    Return the maximum sum.\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in arr:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef g(arr: List[int]) -> List[int]:\n    \"\"\"Return the list of integers arr\"\"\"\n    return arr\n\nassert f(g(arr=[-2,1,-3,4,-1,2,1,-5,4])) == 6\n",
        "idx_generation": 385,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(graph: Dict[int, List[int]]) -> List[int]:\n    \"\"\"Perform a breadth-first search on the given graph and return the order of nodes visited.\"\"\"\n    visited = set()\n    queue = deque([0])\n    order = []\n    while queue:\n        node = queue.popleft()\n        if node not in visited:\n            visited.add(node)\n            order.append(node)\n            queue.extend(graph[node])\n    return order\n\ndef g():\n    \"\"\"Find a graph such that the function f returns the order [0, 1, 2, 3, 4, 5, 6, 7, 8].\"\"\"\n    return {0: [1, 2, 3], 1: [2, 4], 2: [3, 5], 3: [6], 4: [5], 5: [7, 8], 6: [], 7: [], 8: []}\n\nassert f(g()) == [0, 1, 2, 3, 4, 5, 6, 7, 8]\n",
        "idx_generation": 91,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, word='hello') -> bool:\n    \"\"\"Count the number of occurrences of the word in the string s.\"\"\"\n    count = 0\n    length = len(word)\n    for i in range(len(s) - length + 1):\n        if s[i:i + length] == word:\n            count += 1\n    return count\n\ndef g(n=3, word='hello'):\n    \"\"\"Generate a string containing n copies of the word.\"\"\"\n    return word * n\n\nassert f(g()) == 3\n",
        "idx_generation": 489,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int) -> bool:\n    \"\"\"Check if a given number is a power of two.\"\"\"\n    if num <= 0:\n        return False\n    return num & (num - 1) == 0\n\ndef g():\n    return 16\n\nassert f(g())\n",
        "idx_generation": 214,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"Count the number of subsets in the given array that sum up to the target value.\"\"\"\n    n = len(arr)\n    dp = [[0] * (target + 1) for _ in range(n + 1)]\n    \n    for i in range(n + 1):\n        dp[i][0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if arr[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - arr[i - 1]]\n    \n    return dp[n][target]\n\ndef g(arr=[1, 2, 3, 4, 5], target=5):\n    return arr, target\n\nassert f(*g()) == 3\n",
        "idx_generation": 227,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Dict\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"Check if there is a path between start and end in the given graph.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g():\n    return {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D'],\n        'D': ['E'],\n        'E': []\n    }\n\nassert f(g(), 'A', 'E')\n",
        "idx_generation": 323,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> int:\n    \"\"\"Given an undirected tree represented by an adjacency list, find the diameter of the tree.\n    - The diameter of a tree is the length of the longest path between any two nodes in the tree.\n    - Return the diameter of the tree.\"\"\"\n    graph = [[] for _ in range(n+1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        nonlocal diameter\n        first_max = second_max = 0\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                depth = dfs(neighbor, node)\n                if depth > first_max:\n                    first_max, second_max = depth, first_max\n                elif depth > second_max:\n                    second_max = depth\n        diameter = max(diameter, first_max + second_max)\n        return 1 + first_max\n    \n    diameter = 0\n    dfs(1, -1)\n    return diameter\n\ndef g(n: int, edges: List[List[int]]):\n    return n, edges\n\nassert f(*g(6, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6]])) == 5\n",
        "idx_generation": 201,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers 'n' and 'k', calculate the number of combinations of 'n' objects taken 'k' at a time.\n    Return the number of combinations.\n    \"\"\"\n    numerator = 1\n    denominator = 1\n    \n    for i in range(1, k + 1):\n        numerator *= n - i + 1\n        denominator *= i\n    \n    return numerator // denominator\n\ndef g():\n    \"\"\"\n    Generate two integers 'n' and 'k'.\n    \"\"\"\n    n = 5\n    k = 2\n    \n    return n, k\n\nassert f(*g()) == 10\n",
        "idx_generation": 311,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import itertools\nfrom typing import*\ndef f(numbers: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a combination of numbers that equals the target value by using each number at most once.\"\"\"\n    from itertools import combinations\n    for n in range(1, len(numbers)+1):\n        for c in combinations(numbers, n):\n            if sum(c) == target:\n                return True\n    return False\n\ndef g():\n    numbers = [1, 2, 3, 4, 5]\n    target = 9\n    return numbers, target\n\nassert f(*g())\n",
        "idx_generation": 293,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, substr='abc') -> bool:\n    \"\"\"Given a string, determine if it contains a substring that is a permutation of the given substring. Returns True if such a substring exists, False otherwise.\"\"\"\n    from collections import Counter\n    len_substr = len(substr)\n    substr_counts = Counter(substr)\n    for i in range(len(s) - len_substr + 1):\n        window = s[i:i+len_substr]\n        window_counts = Counter(window)\n        if window_counts == substr_counts:\n            return True\n    return False\n\ndef g(substr='abc'):\n    s = 'abcdcbaxyz'\n    return s\n\nassert f(g())\n",
        "idx_generation": 120,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if the target exists in the list using binary search.\n    Return True if the target is found, otherwise return False.\n    Example:\n    nums = [1, 3, 5, 7, 9, 11, 13]\n    target = 9\n    Output: True\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef g(nums: List[int], target: int) -> bool:\n    return target in nums\n\nnums = [1, 3, 5, 7, 9, 11, 13]\ntarget = 9\nassert f(nums, target) == g(nums, target)\n",
        "idx_generation": 53,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in non-decreasing order such that all even numbers appear before odd numbers.\n    Return the sorted list.\n    \"\"\"\n    def is_even(num):\n        return num % 2 == 0\n    \n    even_nums = sorted(filter(is_even, nums))\n    odd_nums = sorted(filter(lambda x: not is_even(x), nums))\n    \n    return even_nums + odd_nums\n\ndef g():\n    nums = [3, 2, 1, 4, 5, 6]\n    return nums\n\nassert f(g()) == [2, 4, 6, 1, 3, 5]\n",
        "idx_generation": 390,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers 'nums' and a target number 'target',\n    find the index of the target number in the list using binary search.\n    Return -1 if the target number is not found.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g():\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    nums = [1, 3, 5, 7, 9, 11, 13]\n    target = 7\n    \n    return nums, target\n\nassert f(*g()) == 3\n\n",
        "idx_generation": 170,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, lst=['apple', 'banana', 'cherry', 'date', 'elderberry']) -> bool:\n    \"\"\"Find the index of the first occurrence of a string that contains 'rr' in a list, after sorting the list in descending order.\"\"\"\n    sorted_lst = sorted(lst, reverse=True)\n    for i, s in enumerate(sorted_lst):\n        if 'rr' in s:\n            return n == i\n    return False\ndef g(lst=['apple', 'banana', 'cherry', 'date', 'elderberry']):\n    return sorted(lst, reverse=True).index(next(s for s in sorted(lst, reverse=True) if 'rr' in s))\nassert f(g())\n",
        "idx_generation": 249,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, return the count of all possible combinations of three numbers that sum up to zero.\"\"\"\n    count = 0\n    nums.sort()\n    for i in range(len(nums) - 2):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n        left = i + 1\n        right = len(nums) - 1\n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n            if total == 0:\n                count += 1\n                while left < right and nums[left] == nums[left+1]:\n                    left += 1\n                while left < right and nums[right] == nums[right-1]:\n                    right -= 1\n                left += 1\n                right -= 1\n            elif total < 0:\n                left += 1\n            else:\n                right -= 1\n    return count\n\ndef g(nums: List[int]):\n    return nums\n\nassert f(g([-1, 0, 1, 2, -1, -4])) == 2\n",
        "idx_generation": 256,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Given two strings, check if they are anagrams of each other. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase.\"\"\"\n    if len(s1) != len(s2):\n        return False\n\n    count = [0] * 26\n\n    for char in s1:\n        count[ord(char) - ord('a')] += 1\n\n    for char in s2:\n        count[ord(char) - ord('a')] -= 1\n\n    for c in count:\n        if c != 0:\n            return False\n\n    return True\n\ndef g():\n    s1 = \"listen\"\n    s2 = \"silent\"\n    return s1, s2\n\nassert f(*g()) == True\n\n",
        "idx_generation": 342,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find two numbers in the list that sum up to the target.\n    Return the indices of the two numbers in the list.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g():\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 389,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Given a matrix of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right in the matrix.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = matrix[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    return dp[rows-1][cols-1]\n\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]  # Return a matrix of integers\n\nassert f(g()) == 12\n",
        "idx_generation": 94,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num1: int, num2: int) -> int:\n    \"\"\"Given two integers, perform the XOR operation on them and return the result.\n    \n    Example:\n    num1 = 5\n    num2 = 3\n    The XOR operation on 5 and 3 is 6, so the output should be 6.\n    \"\"\"\n    return num1 ^ num2\n\ndef g():\n    return 5, 3\n\nassert f(*g()) == 6\n",
        "idx_generation": 215,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique paths to travel from the top-left corner to the bottom-right\n    corner of a grid with dimensions n x n. You can only move down or right.\n    \n    Example:\n    n = 3\n    \n    The grid looks like this:\n    [\n        [S, 0, 0],\n        [0, 0, 0],\n        [0, 0, E]\n    ]\n    \n    S represents the starting point and E represents the ending point.\n    \n    There are 6 unique paths to reach the end:\n    \"DDRR\", \"DRDR\", \"DRRD\", \"RDRD\", \"RDDR\", \"RRDD\"\n    \n    Therefore, the answer is 6.\n    \"\"\"\n    def unique_paths_helper(i: int, j: int) -> int:\n        if i == n-1 or j == n-1:\n            return 1\n        return unique_paths_helper(i+1, j) + unique_paths_helper(i, j+1)\n    \n    return unique_paths_helper(0, 0)\n\ndef g():\n    return 3\n\nassert f(g()) == 6\n",
        "idx_generation": 228,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import Dict, List\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"Given a directed graph as a dictionary and two nodes, check if there exists a path from the start node to the end node.\n    Return True if a path exists, otherwise return False.\n    Sample input:\n    {'A': ['B', 'C'], 'B': ['C', 'D'], 'C': ['D'], 'D': []}, 'A', 'D'\n    Sample output:\n    True\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g():\n    return {'A': ['B', 'C'], 'B': ['C', 'D'], 'C': ['D'], 'D': []}, 'A', 'D'\n\nassert f(*g()) == True\n\n",
        "idx_generation": 328,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Check if there is a path from node 1 to node n in a directed acyclic graph with k nodes.\"\"\"\n    def dfs(node):\n        if node == n:\n            return True\n        if node > n:\n            return False\n        for child in graph[node]:\n            if dfs(child):\n                return True\n        return False\n\n    graph = {1: [2, 3], 2: [4, 5], 3: [6, 7], 4: [], 5: [], 6: [], 7: []}\n    return dfs(1)\n\ndef g(n=7, k=7):\n    return n, k\n\nassert f(*g())\n",
        "idx_generation": 203,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers 'nums' and a target number 'target',\n    find the number of unique combinations of elements in the list that sum up to the target.\n    Return the count of unique combinations.\n    \"\"\"\n    def backtrack(start, curr_sum):\n        nonlocal count\n        if curr_sum == target:\n            count += 1\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            backtrack(i, curr_sum + nums[i])\n    \n    count = 0\n    backtrack(0, 0)\n    return count\n\ndef g():\n    \"\"\"\n    Generate a list of integers and a target number.\n    \"\"\"\n    nums = [2, 3, 6, 7]\n    target = 7\n    \n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 313,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int, m: int) -> bool:\n    \"\"\"Given a list of n distinct integers, find the number of ways to select k integers such that the absolute difference\n    between any two selected integers is greater than or equal to m.\"\"\"\n    def combinations(n, k):\n        if k == 0 or k == n:\n            return 1\n        return combinations(n - 1, k - 1) + combinations(n - 1, k)\n    \n    return combinations(n, k) >= m\ndef g(n=10, k=3, m=100):\n    return n, k, m\nassert f(*g())\n",
        "idx_generation": 302,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Given two strings 's1' and 's2', determine if 's2' is a rotation of 's1'.\n    Return True if 's2' is a rotation of 's1', False otherwise.\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n    \n    s1 += s1\n    \n    if s2 in s1:\n        return True\n    \n    return False\n\ndef g():\n    \"\"\"\n    Generate two strings.\n    \"\"\"\n    s1 = \"rotation\"\n    s2 = \"tionrota\"\n    \n    return s1, s2\n\nassert f(*g()) == True\n\n",
        "idx_generation": 131,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers and a target number, determine if there exist two elements in the array whose sum is equal to the target.\n    Return True if such pair exists, False otherwise.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr=[1, 2, 3, 4, 5, 6], target=10):\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 61,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers in ascending order, determine if there are two numbers in the list\n    that add up to the target number. Return True if such pair exists, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), 13) == True\n",
        "idx_generation": 403,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all numbers from 1 to n using recursion.\n    Return the sum.\n    \"\"\"\n    if n == 1:\n        return 1\n    return n + f(n-1)\n\ndef g(n: int) -> int:\n    \"\"\"\n    Return the value of n.\n    \"\"\"\n    return n\n\nassert f(g(10)) == 55\n",
        "idx_generation": 172,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> str:\n    \"\"\"Reverse the order of words in a given string\"\"\"\n    words = string.split()\n    reverse_words = \" \".join(words[::-1])\n    return reverse_words\n\ndef g():\n    return \"Hello World\"\n\nassert f(g()) == \"World Hello\"\n",
        "idx_generation": 250,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if the list can be partitioned into two subsets such that the sum of elements in both subsets is equal.\"\"\"\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n    target_sum = total_sum // 2\n    n = len(nums)\n    dp = [[False] * (target_sum + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target_sum + 1):\n            if nums[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j - nums[i - 1]] or dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[n][target_sum]\n\ndef g(nums=[1, 5, 11, 5]):\n    return nums\n\nassert f(g())\n",
        "idx_generation": 261,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string 's', determine if it can be rearranged in such a way that\n    it forms a palindrome. Return True if it is possible, False otherwise.\n    Example:\n    s = \"aab\"\n    The possible rearrangements are \"aba\" and \"baa\", both of which form palindromes.\n    Therefore, the answer is True.\n    \"\"\"\n    s = sorted(s)\n    odd_count = 0\n    for i in range(1, len(s)):\n        if s[i] == s[i-1]:\n            continue\n        if (i - odd_count) % 2 != 0:\n            return False\n        odd_count = i\n    return True\n\ndef g():\n    return \"aab\"\n\nassert f(g())\n",
        "idx_generation": 346,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum sum of any contiguous subarray.\n    Return the maximum sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    The contiguous subarray with the maximum sum is [4, -1, 2, 1], which has a sum of 6.\n    Therefore, the answer is 6.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 401,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Find if there exists a combination of numbers from the given list that adds up to the target.\n    Each number can be used multiple times.\n    \"\"\"\n    dp = [False] * (target + 1)\n    dp[0] = True\n\n    for i in range(target + 1):\n        if dp[i]:\n            for num in nums:\n                if i + num <= target:\n                    dp[i + num] = True\n\n    return dp[target]\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Returns a tuple containing a list of numbers and the target sum.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 99,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, count the number of 1 bits in its binary representation.\"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g():\n    return 27\n\nassert f(g()) == 4\n",
        "idx_generation": 223,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, return True if there exists a subset of the list that sums up to the target.\"\"\"\n    def subsetSum(nums, target, n):\n        if target == 0:\n            return True\n        if n == 0:\n            return False\n        if nums[n-1] > target:\n            return subsetSum(nums, target, n-1)\n        \n        return subsetSum(nums, target - nums[n-1], n-1) or subsetSum(nums, target, n-1)\n    \n    return subsetSum(nums, target, len(nums))\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find a subset of the list that sums up to the target.\"\"\"\n    def subsetSum(nums, target, n, subset):\n        if target == 0:\n            return subset\n        if n == 0:\n            return []\n        if nums[n-1] > target:\n            return subsetSum(nums, target, n-1, subset)\n        \n        subset1 = subsetSum(nums, target - nums[n-1], n-1, subset + [nums[n-1]])\n        subset2 = subsetSum(nums, target, n-1, subset)\n        \n        return subset1 if subset1 else subset2\n    \n    return subsetSum(nums, target, len(nums), [])\n\nassert f(g(nums=[2, 4, 6, 8], target=10), target=10)\n",
        "idx_generation": 248,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there exists a path from the start node to the end node in the given graph.\"\"\"\n    stack = [start]\n    visited = set()\n    \n    while stack:\n        curr_node = stack.pop()\n        if curr_node == end:\n            return True\n        visited.add(curr_node)\n        for neighbor in graph[curr_node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    \n    return False\n\ndef g():\n    graph = [[1, 2], [2, 3], [3], []]\n    start = 0\n    end = 3\n    return graph, start, end\n\nassert f(*g()) == True\n\n",
        "idx_generation": 334,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Find if there exists a path from start to end in the given graph\"\"\"\n    visited = [False] * len(graph)\n    return dfs(graph, start, end, visited)\n\ndef dfs(graph, curr, end, visited):\n    if curr == end:\n        return True\n    visited[curr] = True\n    for neighbor in graph[curr]:\n        if not visited[neighbor]:\n            if dfs(graph, neighbor, end, visited):\n                return True\n    return False\n\ndef g():\n    graph = [[1, 2], [2, 3], [3], [4], []]\n    start = 0\n    end = 4\n    return graph, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 204,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"Given two integers n and k, return the number of ways to choose k items from n distinct items without repetition and without considering the order of the selected items.\"\"\"\n    if k == 0 or k == n:\n        return 1\n    elif k > n or k < 0:\n        return 0\n    else:\n        return f(n-1, k-1) + f(n-1, k)\n\ndef g(n=5, k=3):\n    return n, k\n\nassert f(*g()) == 10\n",
        "idx_generation": 318,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target: int) -> int:\n    \"\"\"\n    Given a grid of positive integers and a target number, find the number of unique paths from the top-left corner\n    to the bottom-right corner, where the sum of numbers along the path equals the target.\n    Sample Input:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    target = 12\n    Sample Output:\n    2\n    Explanation:\n    There are 2 unique paths from (0, 0) to (2, 2) with a sum of 12: (1 -> 2 -> 3 -> 6) and (1 -> 4 -> 7 -> 9).\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    def dfs(i, j, curr_sum):\n        if i >= rows or j >= cols:\n            return 0\n        if curr_sum + grid[i][j] == target:\n            return 1\n        return dfs(i+1, j, curr_sum + grid[i][j]) + dfs(i, j+1, curr_sum + grid[i][j])\n    \n    return dfs(0, 0, 0)\n\ndef g(grid: List[List[int]], target: int):\n    return grid, target\n\nassert f(*g([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 12)) == 2\n",
        "idx_generation": 317,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k=2) -> bool:\n    \"\"\"Given a string s, find the number of substrings that contain at least k distinct characters.\n    A substring is defined as a contiguous sequence of characters in the string.\n    \"\"\"\n    count = 0\n    for i in range(len(s)):\n        seen = set()\n        for j in range(i, len(s)):\n            seen.add(s[j])\n            if len(seen) >= k:\n                count += 1\n    return count > 0\n\ndef g(k=2):\n    return \"abcaabbbc\"\n\nassert f(g())\n",
        "idx_generation": 143,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Determine if the given number is a power of k.\"\"\"\n    if n == 0 or k == 0:\n        return False\n    \n    while n % k == 0:\n        n //= k\n    \n    return n == 1\n\ndef g():\n    n = 64\n    k = 4\n    return n, k\n\nassert f(*g())\n",
        "idx_generation": 63,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target=10) -> bool:\n    \"\"\"Given a sorted array of integers, find two numbers in the array that add up to the given target.\nReturn True if such a pair exists, otherwise return False.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g(arr=[1, 2, 3, 4, 5, 6, 7, 8, 9]):\n    return arr\nassert f(g())\n",
        "idx_generation": 404,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers 'arr' and a target integer 'target', determine if there exist two numbers in the list \n    such that their sum is equal to the target.\n    Return True if such numbers exist, and False otherwise.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(arr: List[int] = [1, 2, 3, 4, 5], target: int = 9):\n    return sorted(arr)\n\nassert f(g(), 9)\n",
        "idx_generation": 172,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int) -> bool:\n    \"\"\"Check if the binary representation of num has alternating bits, i.e., 01 or 10.\"\"\"\n    binary = bin(num)[2:]\n    return all(binary[i] != binary[i+1] for i in range(len(binary)-1))\n\ndef g():\n    return 10\n\nassert f(g())\n",
        "idx_generation": 251,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nimport itertools\nfrom typing import List\n\ndef f(elements: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum subset sum where each element in the subset is divisible by the previous element.\n    Return the maximum subset sum as an integer.\"\"\"\n    def is_divisible(a, b):\n        return a % b == 0\n    \n    def subset_sums(elements):\n        n = len(elements)\n        max_sum = 0\n        for r in range(1, n+1):\n            for subset in itertools.combinations(elements, r):\n                is_valid = True\n                for i in range(1, len(subset)):\n                    if not is_divisible(subset[i], subset[i-1]):\n                        is_valid = False\n                        break\n                if is_valid:\n                    max_sum = max(max_sum, sum(subset))\n        return max_sum\n\n    return subset_sums(elements)\n    \ndef g(elements: List[int]) -> int:\n    \"\"\"Generate a list of integers randomly.\"\"\"\n    return [random.randint(1, 100) for _ in range(elements)]\n\nassert f(g(10)) >= 0\n",
        "idx_generation": 269,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport itertools\n\ndef f(string: str, k: int) -> bool:\n    \"\"\"Given a string and an integer k, determine if there exists a subsequence of length k from the string\n    where the characters appear in alphabetical order.\"\"\"\n    subsequences = list(itertools.combinations(string, k))\n    for subsequence in subsequences:\n        if list(subsequence) == sorted(subsequence):\n            return True\n    return False\n\ndef g():\n    return \"programming\", 3\n\nassert f(*g()) == True\n\n",
        "idx_generation": 379,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers and a number 'k', determine if there are two distinct indices i and j,\n    such that arr[i] + arr[j] is equal to k.\n    \"\"\"\n    complement_set = set()\n    for num in arr:\n        complement = k - num\n        if complement in complement_set:\n            return True\n        complement_set.add(num)\n    return False\n\ndef g(arr=[1, 2, 3, 4, 5], k=7):\n    \"\"\"\n    Generate a list of integers and a number 'k'.\n    \"\"\"\n    return arr, k\n\nassert f(*g())\n",
        "idx_generation": 411,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers 'nums' and a target integer 'target', determine if there exists a subset of 'nums'\n    such that the bitwise XOR of all elements in the subset is equal to 'target'.\n    \"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if nums[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[n][target]\n\ndef g():\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g(), 7)\n",
        "idx_generation": 99,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of set bits in the binary representation of a given number.\"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g(n: int) -> int:\n    return f(n)\n\nn = 15\nassert f(n) == g(n)\n",
        "idx_generation": 230,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, check if there exists a subarray with the sum equal to 0.\n    Return True if such a subarray exists, False otherwise.\n    \"\"\"\n    prefix_sum = 0\n    prefix_sum_set = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum in prefix_sum_set or prefix_sum == 0:\n            return True\n        prefix_sum_set.add(prefix_sum)\n    return False\n\ndef g():\n    nums = [4, -2, 3, -1, 0, 2, -3]\n    return (nums,)\n\nassert f(*g())\n",
        "idx_generation": 257,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, target: int) -> bool:\n    \"\"\"\n    Given a graph represented by an adjacency list and two nodes (start and target),\n    determine if there exists a path from the start node to the target node. \n    Return True if a path exists, False otherwise.\n    \"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == target:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a random graph represented by an adjacency list.\n    \"\"\"\n    graph = [[1, 2], [3], [], [4, 5], [2, 6], [7], [], []]\n    return graph\n\nassert f(g(), 0, 7)\n",
        "idx_generation": 339,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"Find the number of connected components in the given grid.\n    A connected component is a group of adjacent cells with the same value.\"\"\"\n    if not grid:\n        return 0\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] != 'X':\n                dfs(grid, i, j)\n                count += 1\n    return count\n\ndef dfs(grid, i, j):\n    if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] == 'X':\n        return\n    grid[i][j] = 'X'\n    dfs(grid, i + 1, j)\n    dfs(grid, i - 1, j)\n    dfs(grid, i, j + 1)\n    dfs(grid, i, j - 1)\n\ndef g():\n    grid = [['O', 'O', 'O'], ['X', 'X', 'O'], ['O', 'O', 'X']]\n    return grid\n\nassert f(g()) == 2\n",
        "idx_generation": 204,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"Find the number of unique combinations of k elements from the given list.\"\"\"\n    def backtrack(start, count, curr_comb):\n        if count == k:\n            return 1\n        total_comb = 0\n        for i in range(start, len(nums)):\n            total_comb += backtrack(i + 1, count + 1, curr_comb + [nums[i]])\n        return total_comb\n    \n    nums.sort()\n    return backtrack(0, 0, [])\n\ndef g(nums=[1, 2, 3, 4, 5], k=3):\n    return nums, k\n\nassert f(*g()) == 10\n\n",
        "idx_generation": 334,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> bool:\n    \"\"\"Check if it is possible to generate a string of length n using only the characters 'a' and 'b', such that there are exactly m occurrences of the substring 'ab'.\"\"\"\n    def backtrack(s, count_a, count_b):\n        if len(s) == n:\n            return s.count('ab') == m\n\n        if count_a < n // 2 and backtrack(s + 'a', count_a + 1, count_b):\n            return True\n\n        if count_b < n // 2 and backtrack(s + 'b', count_a, count_b + 1):\n            return True\n\n        return False\n\n    return backtrack('', 0, 0)\n\ndef g():\n    n = 6\n    m = 2\n    return n, m\n\nassert f(*g())\n",
        "idx_generation": 318,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Given a string s and an integer k, check if there exists a substring of s of length k that contains exactly k unique characters.\n    Return True if such substring exists, otherwise return False.\n\n    Example:\n    s = \"abccdefg\"\n    k = 3\n    Output: True\n    Explanation: The substring \"cde\" has exactly 3 unique characters.\n    \"\"\"\n    if len(s) < k:\n        return False\n    \n    for i in range(len(s) - k + 1):\n        substring = s[i:i+k]\n        if len(set(substring)) == k:\n            return True\n    \n    return False\n\ndef g():\n    return \"abccdefg\"\n\nassert f(g(), 3) == True\n",
        "idx_generation": 147,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, pattern: str) -> bool:\n    \"\"\"Given a string 's' and a pattern 'pattern', determine if 's' follows the pattern.\n    The pattern consists of lowercase letters and the words in 's' are separated by a single space.\n    For example, if the pattern is \"abba\" and 's' is \"cat dog dog cat\", then it follows the pattern.\n    \"\"\"\n    words = s.split()\n    if len(words) != len(pattern):\n        return False\n    \n    word_to_pattern = {}\n    pattern_to_word = {}\n    \n    for word, char in zip(words, pattern):\n        if word in word_to_pattern and word_to_pattern[word] != char:\n            return False\n        if char in pattern_to_word and pattern_to_word[char] != word:\n            return False\n        \n        word_to_pattern[word] = char\n        pattern_to_word[char] = word\n        \n    return True\n\ndef g():\n    return (\"cat dog dog cat\", \"abba\")\n\nassert f(*g())\n",
        "idx_generation": 63,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Sort a list of integers using the bubble sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    return nums\n\ndef g(nums: List[int]):\n    \"\"\"Generate a list of integers.\"\"\"\n    return nums\n\nassert f(g([64, 34, 25, 12, 22, 11, 90])) == [11, 12, 22, 25, 34, 64, 90]\n",
        "idx_generation": 425,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Given an array of integers, return a new array such that each element at index i of the new array is the product of\n    all the numbers in the original array except the one at i.\"\"\"\n    n = len(arr)\n    left_product = [1] * n\n    right_product = [1] * n\n    result = [1] * n\n\n    for i in range(1, n):\n        left_product[i] = arr[i - 1] * left_product[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        right_product[i] = arr[i + 1] * right_product[i + 1]\n\n    for i in range(n):\n        result[i] = left_product[i] * right_product[i]\n\n    return result\n\ndef g(arr: List[int]) -> List[int]:\n    return f(arr)\n\narr = [1, 2, 3, 4, 5]\nassert f(arr) == g(arr)\n",
        "idx_generation": 176,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target number, determine if there are two numbers in the list that add up to the target.\n    Return True if such numbers exist, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(target: int):\n    nums = [-2, 0, 3, 5, 6, 8, 9]\n    return nums, target\n\nassert f(*g(11))\n",
        "idx_generation": 251,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target sum, determine if there is a subset of the elements whose sum is equal to the target.\n    Return True if such a subset exists, otherwise return False.\n    \"\"\"\n    n = len(arr)\n    dp = [[False] * (target + 1) for _ in range(n+1)]\n    \n    # Base case: subset of empty set has a sum of zero\n    dp[0][0] = True\n    \n    for i in range(1, n+1):\n        for j in range(target + 1):\n            if j < arr[i-1]:\n                dp[i][j] = dp[i-1][j]\n            else:\n                dp[i][j] = dp[i-1][j] or dp[i-1][j-arr[i-1]]\n    \n    return dp[n][target]\n\ndef g():\n    return [2, 4, 6, 8, 10]\n\nassert f(g(), 16)\n",
        "idx_generation": 285,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"Check if the given string contains all unique characters\"\"\"\n    return len(set(s)) == len(s)\n\ndef g(n: int) -> str:\n    \"\"\"Generate a string of n unique characters\"\"\"\n    import string\n    return string.ascii_lowercase[:n]\n\nassert f(g(10), 10)\n",
        "idx_generation": 391,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers 'nums', determine if there exists a subsequence of length 3 such that the sum of the first two elements in the subsequence is equal to the third element.\n    Return True if such a subsequence exists, False otherwise.\n    \"\"\"\n    n = len(nums)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if nums[i] + nums[j] == nums[k]:\n                    return True\n    return False\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    \n    return nums\n\nassert f(g())\n\n",
        "idx_generation": 433,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given an integer n, return the nth Fibonacci number.\n    - n is a non-negative integer\n    - return the nth Fibonacci number\"\"\"\n    \n    def fibonacci(n, memo):\n        if n in memo:\n            return memo[n]\n        if n <= 2:\n            return 1\n        memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)\n        return memo[n]\n    \n    memo = {}\n    return fibonacci(n, memo)\n\ndef g():\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 112,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Reverse the bits in a given binary string.\"\"\"\n    return s[::-1]\n\ndef g(s: str) -> str:\n    return s\n\nassert f(g('101010')) == '010101'\n",
        "idx_generation": 233,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the nth Fibonacci number.\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    fib = [0, 1]\n    for i in range(2, n+1):\n        fib.append(fib[i-1] + fib[i-2])\n    \n    return fib[n]\n\ndef g():\n    return 10\n\nassert f(g()) == 55\n",
        "idx_generation": 285,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start='A', end='F') -> bool:\n    \"\"\"Given a directed graph represented as an adjacency list, determine if there exists a path from the start node to the end node.\n    Return True if a path exists, False otherwise.\n    \"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\ndef g():\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['D'],\n        'C': ['E'],\n        'D': ['F'],\n        'E': ['F'],\n        'F': []\n    }\n    return graph\nassert f(g())\n",
        "idx_generation": 339,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, check if there exists a subarray with a sum equal to zero.\n    Return True if such a subarray exists, otherwise return False.\n    Sample input:\n    [4, 2, -3, 1, 6]\n    Sample output:\n    True\"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum == 0 or prefix_sum in prefix_sums:\n            return True\n        prefix_sums.add(prefix_sum)\n    return False\n\ndef g():\n    return [4, 2, -3, 1, 6]\n\nassert f(g()) == True\n",
        "idx_generation": 206,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string s, check if it can be rearranged into a palindrome.\n    Return True if it is possible, False otherwise.\n    \"\"\"\n    char_count = {}\n    \n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    odd_count = 0\n    \n    for count in char_count.values():\n        if count % 2 != 0:\n            odd_count += 1\n    \n    return odd_count <= 1\n\ndef g():\n    return \"aabbc\"\n\nassert f(g())\n",
        "idx_generation": 349,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Find the number of ways to choose k items from a set of n items without repetition.\"\"\"\n    import math\n    if n < k:\n        return False\n    else:\n        return math.comb(n, k) > 0\n\ndef g():\n    n = 5\n    k = 3\n    return n, k\n\nassert f(*g())\n",
        "idx_generation": 323,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string s, find if it can be rearranged into a palindrome\"\"\"\n    return sum(s.count(c) % 2 for c in set(s)) <= 1\ndef g(s='aabbc'):\n    return s\nassert f(g())\n",
        "idx_generation": 160,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Find a pair of numbers from the list whose sum is equal to the target number.\"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(target=10):\n    return [1, 9, 3, 7, 5]\n\nassert f(g())\n",
        "idx_generation": 69,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the given list that add up to the target value.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    nums = [1, 5, 3, 9, 2]\n    target = 8\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 440,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there are three numbers in the list that sum up to the target\"\"\"\n    nums.sort()\n    n = len(nums)\n    for i in range(n - 2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            if current_sum == target:\n                return True\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find three numbers in the list that sum up to the target\"\"\"\n    nums.sort()\n    n = len(nums)\n    for i in range(n - 2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            if current_sum == target:\n                return [nums[i], nums[left], nums[right]]\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return []\n\nnums = [1, 4, 2, 7, 3, 9]\ntarget = 13\nassert f(g(nums, target), target)\n",
        "idx_generation": 181,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"Given two strings s and t, determine if t is an anagram of s. An anagram is a word formed by rearranging the letters of another word.\"\"\"\n    return sorted(s) == sorted(t)\n\ndef g():\n    return \"listen\", \"silent\"\n\nassert f(*g()) == True\n",
        "idx_generation": 262,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, find all unique combinations of numbers in the list that add up to the target.\n    Return True if there exists at least one unique combination, False otherwise.\n    \"\"\"\n    def backtrack(start, path, curr_sum):\n        if curr_sum == target:\n            return True\n        if curr_sum > target:\n            return False\n        \n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            if backtrack(i+1, path + [nums[i]], curr_sum + nums[i]):\n                return True\n        \n        return False\n    \n    nums.sort()\n    return backtrack(0, [], 0)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 7\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 286,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Check if 's1' and 's2' are isomorphic strings.\"\"\"\n    if len(s1) != len(s2):\n        return False\n\n    char_map = {}\n    used_chars = set()\n\n    for i in range(len(s1)):\n        if s1[i] not in char_map:\n            if s2[i] in used_chars:\n                return False\n            char_map[s1[i]] = s2[i]\n            used_chars.add(s2[i])\n        elif char_map[s1[i]] != s2[i]:\n            return False\n\n    return True\n\ndef g():\n    return \"egg\", \"add\"\n\nassert f(*g())\n",
        "idx_generation": 424,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given an integer n, determine if it is a prime number.\"\"\"\n    if n <= 1:\n        return False\n\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            return False\n\n    return True\n\ndef g() -> int:\n    \"\"\"Generate a random prime number.\"\"\"\n    import random\n\n    while True:\n        num = random.randint(2, 100)\n        if f(num):\n            return num\n\nassert f(g())\n",
        "idx_generation": 437,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if it is possible to rearrange the elements of nums to form a subsequence that sums up to the target value.\"\"\"\n    def backtrack(curr_sum, index):\n        if curr_sum == target:\n            return True\n        if curr_sum > target or index == len(nums):\n            return False\n        \n        if backtrack(curr_sum + nums[index], index + 1):\n            return True\n        \n        if backtrack(curr_sum, index + 1):\n            return True\n        \n        return False\n\n    return backtrack(0, 0)\n\ndef g():\n    nums = [2, 4, 6, 8]\n    target = 12\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 113,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"Given a positive integer, return the number of bits required to represent it in binary form.\"\"\"\n    count = 0\n    while num > 0:\n        num >>= 1\n        count += 1\n    return count\n\ndef g():\n    return 25\n\nassert f(g()) == 5\n",
        "idx_generation": 238,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the n-th Fibonacci number using recursion.\n    The Fibonacci sequence is defined as follows:\n    F(0) = 0\n    F(1) = 1\n    F(n) = F(n-1) + F(n-2) for n > 1.\n    Return the n-th Fibonacci number.\"\"\"\n    \n    def fibonacci(n):\n        if n <= 1:\n            return n\n        else:\n            return fibonacci(n-1) + fibonacci(n-2)\n    \n    return fibonacci(n)\n\ndef g():\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 287,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency matrix 'graph', check if there exists a path from 'start' to 'end'.\n    Return True if a path exists, False otherwise.\n    \"\"\"\n    visited = [False] * len(graph)\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if not visited[node]:\n            visited[node] = True\n            stack.extend([i for i in range(len(graph)) if graph[node][i] == 1])\n    return False\n\ndef g():\n    \"\"\"\n    Generate a graph represented as an adjacency matrix.\n    \"\"\"\n    graph = [\n        [0, 1, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 1],\n        [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0]\n    ]\n    return graph\n\nassert f(g(), start=0, end=4)\n",
        "idx_generation": 342,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef f(root: Node) -> int:\n    \"\"\"Count the number of nodes in a binary tree.\"\"\"\n    if root is None:\n        return 0\n    return 1 + f(root.left) + f(root.right)\n\ndef g():\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    return root\n\nassert f(g()) == 5\n",
        "idx_generation": 208,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"Count the number of ways to choose k items from a set of size n.\"\"\"\n    if k == 0 or k == n:\n        return 1\n    return f(n-1, k-1) + f(n-1, k)\n\ndef g() -> Tuple[int, int]:\n    return (5, 3)\n\nassert f(*g()) == 10\n",
        "idx_generation": 357,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a subset whose sum is equal to the target value.\n    You may assume that the input list contains only non-negative integers.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n+1)]\n    dp[0][0] = True\n    for i in range(1, n+1):\n        for j in range(target + 1):\n            if j < nums[i-1]:\n                dp[i][j] = dp[i-1][j]\n            else:\n                dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i-1]]\n    return dp[n][target]\n\ndef g():\n    return [1, 5, 11, 5]\n\nassert f(nums=g(), target=11)\n",
        "idx_generation": 327,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string s, find the number of distinct substrings that can be formed from s.\n    A substring is a contiguous sequence of characters within a string.\n    Return True if the number of distinct substrings is greater than or equal to 10, otherwise return False.\"\"\"\n    substrings = set()\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            substrings.add(s[i:j])\n    return len(substrings) >= 10\n\ndef g():\n    return \"abracadabra\"\n\nassert f(g())\n",
        "idx_generation": 171,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers 'arr', determine if there exists a pair of numbers that sum up to the target.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr: List[int]) -> int:\n    \"\"\"Find the sum of the two smallest numbers in a sorted list 'arr'.\"\"\"\n    return arr[0] + arr[1]\n\nassert f(arr=[1, 2, 3, 4, 5], target=g(arr=[1, 2, 3, 4, 5]))\n",
        "idx_generation": 70,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, sort them in non-decreasing order.\n\n    Return the sorted list.\n    \"\"\"\n    stack = []\n    result = []\n\n    for num in nums:\n        while stack and stack[-1] > num:\n            result.append(stack.pop())\n        stack.append(num)\n    \n    while stack:\n        result.append(stack.pop())\n    \n    return result\n\ndef g(nums: List[int]) -> List[int]:\n    return f(nums)\n\nnums = [5, 2, 8, 3, 1]\nassert f(nums) == g(nums)\n",
        "idx_generation": 442,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n    An increasing subsequence is a sequence of numbers in the list where each number is greater than the previous number.\n    Return the length of the longest increasing subsequence.\n    \"\"\"\n\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 186,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Given a string, reverse the order of the words in the string and return the reversed string.\n    Words are separated by a single space.\"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string\n\ndef g():\n    return \"Hello World\"\n\nassert f(g()) == \"World Hello\"\n",
        "idx_generation": 273,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Given a list of integers and a target number k, determine if there exists a subset of the integers that sums up to k.\n    Sample input:\n    nums = [1, 2, 3, 4, 5]\n    k = 9\n    Sample output:\n    True\"\"\"\n    n = len(nums)\n    dp = [[False] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        dp[i][0] = True\n        \n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= nums[i - 1]:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - nums[i - 1]]\n    \n    return dp[n][k]\n\ndef g():\n    return [1, 2, 3, 4, 5], 9\n\nassert f(*g())\n",
        "idx_generation": 296,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Given a string s, remove all the vowels from the string and return the modified string.\"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in s if char not in vowels])\n\ndef g():\n    return \"Hello, World!\"\n\nassert f(g()) == \"Hll, Wrld!\"\n",
        "idx_generation": 435,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers 'nums' and a target integer, find two numbers in 'nums'\n    that sum up to the target. Return the indices of the two numbers as a list.\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    The numbers at indices 0 and 1 (2 and 7) sum up to 9.\n    Therefore, the answer is [0, 1].\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g():\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 463,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if there exists a combination of numbers that can be multiplied to obtain the target number. Each number in the list can only be used once.\"\"\"\n    def dp(nums, target, index, curr_prod):\n        if curr_prod == target:\n            return True\n        if index == len(nums) or curr_prod > target:\n            return False\n        if dp(nums, target, index + 1, curr_prod * nums[index]):\n            return True\n        if dp(nums, target, index + 1, curr_prod):\n            return True\n        return False\n    return dp(nums, target, 0, 1)\ndef g(nums=[1, 2, 3, 4, 5], target=120):\n    return nums, target\nassert f(*g())\n",
        "idx_generation": 119,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum subarray XOR value.\n    Return the maximum XOR value.\n    Sample input:\n    [1, 2, 3, 4, 5]\n    Sample output:\n    7\"\"\"\n    max_xor = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            max_xor = max(max_xor, arr[i] ^ arr[j])\n    \n    return max_xor\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 7\n\n",
        "idx_generation": 254,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the sum of the first n natural numbers\"\"\"\n    if n == 0:\n        return 0\n    else:\n        return n + f(n - 1)\n\ndef g(n: int) -> int:\n    \"\"\"Return the value of n\"\"\"\n    return n\n\nassert f(g(5)) == 15\n",
        "idx_generation": 289,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool:\n    \"\"\"Determine if it is possible to reach the end cell from the start cell in a grid.\n    You can only move to adjacent cells in the grid (up, down, left, or right) and cannot visit the same cell twice.\n    Sample Input:\n    grid = [[1, 1, 1],\n            [1, 0, 1],\n            [1, 1, 1]]\n    start = (0, 0)\n    end = (2, 2)\n    Sample Output:\n    True\"\"\"\n    m, n = len(grid), len(grid[0])\n    visited = [[False] * n for _ in range(m)]\n    stack = [(start[0], start[1])]\n    while stack:\n        x, y = stack.pop()\n        if (x, y) == end:\n            return True\n        visited[x][y] = True\n        neighbors = [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]\n        for nx, ny in neighbors:\n            if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] != -1:\n                stack.append((nx, ny))\n    return False\n\ndef g(grid=[[1, 1, 1], [1, 0, 1], [1, 1, 1]], start=(0, 0), end=(2, 2)):\n    \"\"\"Return the given grid, start, and end coordinates.\"\"\"\n    return grid, start, end\n\nassert f(*g())\n",
        "idx_generation": 343,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import defaultdict\n\ndef f(graph: Dict[int, List[int]], start=1, target=5) -> bool:\n    \"\"\"Given a directed graph represented as a dictionary where the keys are the nodes and the values are the\n    neighboring nodes, determine if there is a path from the start node to the target node.\n    Return True if a path exists, False otherwise.\n    Sample input:\n    {1: [2, 3], 2: [3, 4], 3: [4], 4: [5]}\n    Sample output:\n    True\n    Explanation: There is a path from node 1 to node 5: 1 -> 2 -> 3 -> 4 -> 5\"\"\"\n    def dfs(node):\n        if node == target:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited and dfs(neighbor):\n                return True\n        return False\n\n    visited = set()\n    return dfs(start)\n\ndef g():\n    return {1: [2, 3], 2: [3, 4], 3: [4], 4: [5]}\n\nassert f(g())\n",
        "idx_generation": 210,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import itertools\nfrom typing import*\ndef f(nums: List[int], target=10, k=3) -> bool:\n    \"\"\"Find if there exists a combination of k numbers in the given list, nums, that adds up to the target\"\"\"\n    from itertools import combinations\n    for combo in combinations(nums, k):\n        if sum(combo) == target:\n            return True\n    return False\ndef g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target=10, k=3):\n    return nums\nassert f(g())\n",
        "idx_generation": 401,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers nums and a target number,\n    find the number of unique combinations of elements in nums that sum up to the target.\n    Each number in nums can be used multiple times.\n    Return the count of unique combinations.\"\"\"\n    \n    def backtrack(nums, target, start, path, result):\n        if target == 0:\n            result.append(path[:])\n            return\n        if target < 0:\n            return\n        \n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            backtrack(nums, target - nums[i], i, path, result)\n            path.pop()\n    \n    result = []\n    backtrack(nums, target, 0, [], result)\n    return len(result)\n\ndef g():\n    return [2, 3, 6, 7]\n\nassert f(g(), 7) == 2\n",
        "idx_generation": 330,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, p: str) -> bool:\n    \"\"\"Find whether the given string s contains a substring that is a permutation of the pattern p.\"\"\"\n    from collections import Counter\n    pattern_count = Counter(p)\n    for i in range(len(s) - len(p) + 1):\n        substring_count = Counter(s[i:i+len(p)])\n        if substring_count == pattern_count:\n            return True\n    return False\n\ndef g(p: str) -> str:\n    return p[::-1]\n\nassert f(g(p='abc'), p='abc')\n",
        "idx_generation": 179,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target in the list.\n    If the target is not found, return -1.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g():\n    return [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n\nassert f(g(), 12) == 5\n",
        "idx_generation": 70,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exist two numbers in the list that sum up to the target\"\"\"\n    stack = []\n    for num in nums:\n        if target - num in stack:\n            return True\n        stack.append(num)\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5], target=9):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 472,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list that adds up to the target.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    nums = [2, 4, 6, 8, 10]\n    target = 14\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 190,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"Check if the given strings are anagrams of each other.\"\"\"\n    return sorted(s) == sorted(t)\n\ndef g():\n    s = 'listen'\n    t = 'silent'\n    return s, t\n\nassert f(*g())\n",
        "idx_generation": 274,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"Given two strings s and t, find the minimum number of operations required to convert s to t.\n    The only allowed operations are:\n    - Insert a character\n    - Delete a character\n    - Replace a character\n    \n    The function should return True if it is possible to convert s to t using less than or equal to 3 operations,\n    otherwise return False.\"\"\"\n    m, n = len(s), len(t)\n    if abs(m - n) > 3:\n        return False\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            elif s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1])\n    return dp[m][n] <= 3\n\ndef g():\n    return \"python\", \"pyton\"\nassert f(*g())\n",
        "idx_generation": 299,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import itertools\nfrom typing import*\nfrom itertools import permutations\n\ndef f(s: str) -> List[str]:\n    \"\"\"Generate all possible permutations of the characters in the given string.\"\"\"\n    perms = []\n    for perm in permutations(s):\n        perms.append(''.join(perm))\n    return perms\n\ndef g(s='abc'):\n    \"\"\"Generate a string.\"\"\"\n    return s\n\nassert f(g()) == ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n",
        "idx_generation": 448,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a 2D matrix of integers and a target number, check if the target number exists in the matrix.\n    Return True if the target is found, False otherwise.\n    \"\"\"\n\n    if not matrix or not matrix[0]:\n        return False\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    row = 0\n    col = cols - 1\n\n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n\n    return False\n\ndef g():\n    matrix = [\n        [1, 4, 7, 11, 15],\n        [2, 5, 8, 12, 19],\n        [3, 6, 9, 16, 22],\n        [10, 13, 14, 17, 24],\n        [18, 21, 23, 26, 30]\n    ]\n    target = 9\n\n    return matrix, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 479,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the nth Fibonacci number.\"\"\"\n    def fibonacci_helper(n):\n        if n <= 1:\n            return n\n        return fibonacci_helper(n-1) + fibonacci_helper(n-2)\n    \n    return fibonacci_helper(n)\n\ndef g():\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 121,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, return a new list containing only the numbers that are powers of two.\"\"\"\n    return [num for num in numbers if (num & (num - 1)) == 0]\n\ndef g() -> List[int]:\n    \"\"\"Generate a list of integers.\"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g()) == [1, 2, 4, 8]\n",
        "idx_generation": 262,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the sum of the first n natural numbers.\"\"\"\n    if n == 0:\n        return 0\n    else:\n        return n + f(n-1)\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 15\n",
        "idx_generation": 291,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Determine if there exists a path from start to end in the given graph.\n    The graph is represented as an adjacency matrix, where graph[i][j] represents\n    an edge from node i to node j. If there is an edge, the value is 1, otherwise 0.\"\"\"\n    stack = [start]\n    visited = set()\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        visited.add(node)\n        neighbors = [i for i in range(len(graph[node])) if graph[node][i] == 1]\n        for neighbor in neighbors:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    return False\n\ndef g():\n    return [[0, 1, 0, 1, 0],\n            [1, 0, 1, 0, 0],\n            [0, 1, 0, 1, 0],\n            [1, 0, 1, 0, 1],\n            [0, 0, 0, 1, 0]]\n\nassert f(g(), 0, 4)\n",
        "idx_generation": 346,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"Check if a directed graph contains a cycle.\"\"\"\n\n    def dfs(node, visited, stack):\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, stack):\n                    return True\n            elif stack[neighbor]:\n                return True\n\n        stack[node] = False\n        return False\n\n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n    stack = [False] * num_nodes\n\n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(node, visited, stack):\n                return True\n\n    return False\n\ndef g(graph=[[1, 2], [2], []]):\n    \"\"\"Generate a directed graph represented as an adjacency list.\"\"\"\n    return graph\n\nassert f(g()) == False\n\n",
        "idx_generation": 212,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"Given a list of integers, generate all possible combinations of length 3.\"\"\"\n    combinations = []\n    \n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                combinations.append([nums[i], nums[j], nums[k]])\n                \n    return combinations\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [[1, 2, 3], [1, 2, 4], [1, 2, 5], [1, 3, 4], [1, 3, 5], [1, 4, 5], [2, 3, 4], [2, 3, 5], [2, 4, 5], [3, 4, 5]]\n",
        "idx_generation": 431,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport itertools\n\ndef f(arr: List[int], target=17) -> bool:\n    \"\"\"Find a subset of the given array whose sum is equal to the target\"\"\"\n    n = len(arr)\n    for r in range(1, n+1):\n        for subset in itertools.combinations(arr, r):\n            if sum(subset) == target:\n                return True\n    return False\n\ndef g():\n    return [4, 5, 2, 3, 6, 1]\n\nassert f(g())\n",
        "idx_generation": 331,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport itertools\n\ndef f(s: str, k=3) -> bool:\n    \"\"\"Given a string s and an integer k, find a substring of length k that contains all unique characters.\n    Return True if such a substring exists, False otherwise.\n    Sample input:\n    \"abracadabra\", 3\n    Sample output:\n    True\n    \"\"\"\n    substrings = [s[i:i+k] for i in range(len(s)-k+1)]\n    for substring in substrings:\n        if len(set(substring)) == k:\n            return True\n    return False\n\ndef g(k=3):\n    return \"abc\" * k\n\nassert f(g())\n",
        "idx_generation": 211,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(numbers: List[int], target: int) -> bool:\n    \"\"\"Check if there are two numbers in the list that sum up to the target.\"\"\"\n    numbers.sort()\n    left = 0\n    right = len(numbers) - 1\n    while left < right:\n        current_sum = numbers[left] + numbers[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(numbers=[3, 5, 9, 2, 8, 1], target=10):\n    return numbers, target\n\nassert f(*g())\n",
        "idx_generation": 70,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target number, return True if there are two numbers in the list that add up to the target, False otherwise.\"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 7\n    return nums, target\n\nassert f(*g())\n\n",
        "idx_generation": 479,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, find if there are three distinct elements in the list whose sum is equal to the target.\n    Return True if such elements exist, False otherwise.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    for i in range(n - 2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            curr_sum = nums[i] + nums[left] + nums[right]\n            if curr_sum == target:\n                return True\n            elif curr_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g(target: int):\n    nums = [1, 2, 3, 4, 5]\n    return nums, target\n\nassert f(*g(9))\n",
        "idx_generation": 192,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Reverse the order of words in a given string.\"\"\"\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)\n\ndef g(s=\"Hello world, how are you?\"):\n    return s\n\nassert f(g()) == \"you? are how world, Hello\"\n",
        "idx_generation": 291,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers 'nums' and a target number 'k',\n    check if there exists a subarray in the list whose sum is divisible by k.\n    Return True if such a subarray exists, False otherwise.\n    \"\"\"\n    prefix_sum = 0\n    seen = set()\n\n    for num in nums:\n        prefix_sum = (prefix_sum + num) % k\n        if prefix_sum in seen or prefix_sum == 0:\n            return True\n        seen.add(prefix_sum)\n    \n    return False\n\ndef g():\n    \"\"\"\n    Generate a list of integers and a target number k.\n    \"\"\"\n    nums = [4, 2, 13, 5, 23]\n    k = 7\n    \n    return nums, k\n\nassert f(*g()) == True\n",
        "idx_generation": 313,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"\n    Given a string 's' and a target string 'target', return True if the target\n    string is a substring of 's', False otherwise.\n    \"\"\"\n    return target in s\n\ndef g(s: str, target: str) -> str:\n    \"\"\"\n    Given a string 's' and a target string 'target', append the target string\n    to the end of 's' and return the new string.\n    \"\"\"\n    return s + target\n\nassert f(g(\"Hello, world!\", \"world\"), \"world\")\n",
        "idx_generation": 449,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there is a subarray with the sum equal to the target value.\n    Return True if such subarray exists, False otherwise.\n    \"\"\"\n    curr_sum = 0\n    prefix_sum = set()\n    for num in nums:\n        curr_sum += num\n        if curr_sum == target or curr_sum - target in prefix_sum:\n            return True\n        prefix_sum.add(curr_sum)\n    return False\n\ndef g(nums=[1, 4, 2, 3, 5], target=9):\n    \"\"\"\n    Generate a list of integers where there is a subarray with the sum equal to the target value.\n    \"\"\"\n    return nums\n\nassert f(g(), 9) == True\n",
        "idx_generation": 498,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if any combination of the integers in the list can sum up to the target value.\n    Sample input:\n    arr = [1, 2, 3, 4, 5]\n    target = 9\n    Sample output:\n    True (since 4 + 5 = 9)\n    \"\"\"\n    def helper(arr, target, index):\n        if target == 0:\n            return True\n        if target < 0 or index >= len(arr):\n            return False\n        if helper(arr, target - arr[index], index + 1):\n            return True\n        return helper(arr, target, index + 1)\n    \n    return helper(arr, target, 0)\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    target = 9\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 122,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, find the maximum XOR value that can be obtained by taking the XOR of two elements in the grid.\"\"\"\n    result = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            for x in range(len(grid)):\n                for y in range(len(grid[0])):\n                    if i != x or j != y:\n                        result = max(result, grid[i][j] ^ grid[x][y])\n    return result\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 15\n\n",
        "idx_generation": 265,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given an integer n, find the nth Fibonacci number.\"\"\"\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    fib = [0] * (n+1)\n    fib[1] = 1\n    for i in range(2, n+1):\n        fib[i] = fib[i-1] + fib[i-2]\n    return fib[n]\n\ndef g(n=6):\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 292,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(graph: Dict[int, List[int]], start: int, target: int) -> bool:\n    \"\"\"Given a directed graph represented as a dictionary where the keys are the nodes and the values are lists of adjacent nodes, determine if there exists a path from the start node to the target node.\"\"\"\n    visited = set()\n    queue = deque([start])\n    while queue:\n        node = queue.popleft()\n        if node == target:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                queue.append(neighbor)\n    return False\n\ndef g():\n    graph = {1: [2, 3], 2: [4, 5], 3: [], 4: [], 5: [6], 6: [7], 7: [8], 8: []}\n    start = 1\n    target = 8\n    return graph, start, target\n\nassert f(*g())\n",
        "idx_generation": 348,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency matrix 'graph', determine if there exists a path from 'start' to 'end'.\"\"\"\n    def dfs(graph: List[List[int]], visited: List[bool], curr: int, end: int) -> bool:\n        if curr == end:\n            return True\n        visited[curr] = True\n        for i in range(len(graph)):\n            if graph[curr][i] == 1 and not visited[i]:\n                if dfs(graph, visited, i, end):\n                    return True\n        return False\n    \n    visited = [False] * len(graph)\n    return dfs(graph, visited, start, end)\n\ndef g():\n    graph = [\n        [0, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    start = 0\n    end = 4\n    return graph, start, end\n\nassert f(*g())\n",
        "idx_generation": 214,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[List[int]]:\n    \"\"\"Given an integer n, generate all possible unique permutations of the numbers 1 to n.\"\"\"\n    def backtrack(nums, path, result):\n        if len(path) == len(nums):\n            result.append(path[:])\n            return\n        for num in nums:\n            if num not in path:\n                path.append(num)\n                backtrack(nums, path, result)\n                path.pop()\n    \n    nums = list(range(1, n + 1))\n    result = []\n    backtrack(nums, [], result)\n    return result\n\ndef g(n: int):\n    return n\n\nassert f(g(3)) == [[1, 2, 3],\n                   [1, 3, 2],\n                   [2, 1, 3],\n                   [2, 3, 1],\n                   [3, 1, 2],\n                   [3, 2, 1]]\n\n",
        "idx_generation": 432,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int, k: int) -> bool:\n    \"\"\"Check if it is possible to select k numbers from the given list that sum up to the target value.\"\"\"\n    def combinationSum(nums, target, k):\n        if k == 0:\n            return target == 0\n        if k < 0 or not nums:\n            return False\n        return combinationSum(nums[1:], target - nums[0], k - 1) or combinationSum(nums[1:], target, k)\n    \n    return combinationSum(nums, target, k)\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 10\n    k = 3\n    return nums, target, k\n\nassert f(*g())\n",
        "idx_generation": 342,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string, return True if it is a palindrome and can be rearranged into a palindrome, and False otherwise.\"\"\"\n    counts = [0] * 26\n    for c in s:\n        counts[ord(c) - ord('a')] += 1\n    odd_counts = 0\n    for count in counts:\n        if count % 2 != 0:\n            odd_counts += 1\n    return odd_counts <= 1\n\ndef g():\n    s = \"aabbcddc\"\n    return s\n\nassert f(g())\n",
        "idx_generation": 275,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if a given list of integers is sorted in non-decreasing order.\n    Sample input:\n    arr = [1, 2, 3, 4, 5]\n    Sample output:\n    True\n    \"\"\"\n    return all(arr[i] <= arr[i+1] for i in range(len(arr)-1))\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g())\n",
        "idx_generation": 72,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers, check if there exists a pair of elements whose sum is equal to the target value.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr=[1, 2, 3, 4, 5, 6, 7, 8, 9], target=10):\n    \"\"\"Generate a sorted array of integers and a target value.\"\"\"\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 487,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers, determine if there are two numbers in the array that add up to a given target.\"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(arr: List[int], target: int) -> bool:\n    return f(arr, target)\n\narr = [1, 2, 4, 7, 11, 15]\ntarget = 9\nassert f(arr, target) == g(arr, target)\n",
        "idx_generation": 194,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string s, determine if it is a palindrome.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\"\"\"\n    return s == s[::-1]\n\ndef g():\n    return \"level\"\n\nassert f(g()) == True\n",
        "idx_generation": 294,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer 'n', calculate the sum of all the even Fibonacci numbers less than or equal to 'n'.\n    Return the sum.\n    \"\"\"\n    fib_sum = 0\n    fib_prev = 1\n    fib_curr = 1\n    \n    while fib_curr <= n:\n        if fib_curr % 2 == 0:\n            fib_sum += fib_curr\n        fib_next = fib_prev + fib_curr\n        fib_prev = fib_curr\n        fib_curr = fib_next\n    \n    return fib_sum\n\ndef g(n: int):\n    \"\"\"\n    Generate a positive integer 'n'.\n    \"\"\"\n    return n\n\nassert f(g(100)) == 44\n",
        "idx_generation": 313,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list containing only the words that are palindromes.\n    A palindrome is a word that is the same when read forwards and backwards.\n    \"\"\"\n    palindromes = []\n\n    for word in words:\n        if word == word[::-1]:\n            palindromes.append(word)\n\n    return palindromes\n\ndef g(words: List[str]) -> List[str]:\n    \"\"\"\n    Find all the palindromes in a list of words.\n    \"\"\"\n    palindromes = []\n\n    for word in words:\n        if word == word[::-1]:\n            palindromes.append(word)\n\n    return palindromes\n\nassert f([\"level\", \"radar\", \"python\", \"madam\", \"hello\"]) == g([\"level\", \"radar\", \"python\", \"madam\", \"hello\"])\n",
        "idx_generation": 483,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum sum of any contiguous subarray.\n    Return the maximum sum.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef g():\n    nums = [1, -2, 3, -4, 5]\n    return nums\n\nassert f(g()) == 5\n",
        "idx_generation": 124,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(x: int, y: int) -> bool:\n    \"\"\"Check if the bitwise AND of two numbers is divisible by their sum\"\"\"\n    return (x & y) % (x + y) == 0\n\ndef g():\n    return 10, 5\n\nassert f(*g())\n",
        "idx_generation": 279,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the number of ways to climb to the top of a staircase with n steps. You can take either 1 or 2 steps at a time.\"\"\"\n    if n == 0 or n == 1:\n        return 1\n    return f(n-1) + f(n-2)\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 296,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: List[List[int]], start: int, end: int, k: int) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency matrix, determine if there exists a path from the start vertex to the end vertex with at most k edges.\"\"\"\n    visited = set()\n    queue = [(start, 0)]\n\n    while queue:\n        vertex, edges = queue.pop(0)\n        if vertex == end and edges <= k:\n            return True\n        visited.add(vertex)\n\n        if edges < k:\n            for neighbor in range(len(graph)):\n                if graph[vertex][neighbor] == 1 and neighbor not in visited:\n                    queue.append((neighbor, edges + 1))\n\n    return False\n\ndef g() -> List[List[int]]:\n    return [[0, 1, 1, 0, 0],\n            [0, 0, 0, 1, 0],\n            [0, 0, 0, 0, 1],\n            [0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0]]\n\nassert f(g(), 0, 4, 2)\n",
        "idx_generation": 352,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(maze: List[List[int]]) -> bool:\n    \"\"\"Given a maze represented as a 2D grid, determine if it is possible to reach the bottom-right corner from the top-left corner.\n    The maze is represented by a matrix where 0 represents an empty cell and 1 represents a wall.\"\"\"\n    rows = len(maze)\n    cols = len(maze[0])\n    visited = [[False] * cols for _ in range(rows)]\n\n    def dfs(x, y):\n        if x == rows-1 and y == cols-1:\n            return True\n        if x < 0 or x >= rows or y < 0 or y >= cols or maze[x][y] == 1 or visited[x][y]:\n            return False\n\n        visited[x][y] = True\n        if dfs(x+1, y) or dfs(x-1, y) or dfs(x, y+1) or dfs(x, y-1):\n            return True\n\n        return False\n\n    return dfs(0, 0)\n\ndef g():\n    \"\"\"Find a maze represented as a 2D grid that satisfy the condition of the puzzle.\"\"\"\n    maze = [\n        [0, 0, 1, 0, 0],\n        [0, 0, 1, 0, 1],\n        [0, 0, 0, 0, 0],\n        [0, 1, 1, 1, 0],\n        [0, 0, 0, 0, 0]\n    ]\n    return maze\n\nassert f(g()) == True\n",
        "idx_generation": 215,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import itertools\nfrom typing import*\ndef f(nums: List[int], target_sum=10, num_elements=3) -> bool:\n    \"\"\"Find num_elements numbers in the list nums that sum up to the target_sum.\"\"\"\n    from itertools import combinations\n    return any(sum(comb) == target_sum for comb in combinations(nums, num_elements))\ndef g(target_sum=10, num_elements=3):\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return nums\nassert f(g())\n",
        "idx_generation": 451,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine the number of possible combinations\n    that add up to the target.\n    Each number in the list can be used multiple times.\n    Example:\n    Input: nums = [1, 2, 3], target = 4\n    Output: 7\n    Explanation: There are 7 possible combinations: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [1, 3], [2, 1, 1], [2, 2], [3, 1].\n    \"\"\"\n    dp = [0] * (target + 1)\n    dp[0] = 1\n    for i in range(1, target + 1):\n        for num in nums:\n            if i >= num:\n                dp[i] += dp[i - num]\n    return dp[target]\ndef g():\n    return [1, 2, 3], 4\nassert f(*g()) == 7\n",
        "idx_generation": 361,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"\n    Given a string and an integer k, determine if there is a substring of length k that contains only unique characters.\n    Return True if such a substring exists, otherwise return False.\n    \"\"\"\n    n = len(s)\n    \n    if k > n:\n        return False\n    \n    seen = set()\n    for i in range(n-k+1):\n        substring = s[i:i+k]\n        if len(substring) == len(set(substring)):\n            return True\n    \n    return False\n\ndef g():\n    return \"abccdefg\"\n\nassert f(g(), 3)\n",
        "idx_generation": 285,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of distinct integers and a target value, determine if there exists two integers in the array\n    such that their sum is equal to the target value. Return True if such a pair exists, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 73,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Given an array of integers, sort the array using the QuickSort algorithm.\"\"\"\n    if len(arr) <= 1:\n        return arr\n    \n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    \n    return f(left) + middle + f(right)\n\ndef g(arr: List[int]) -> List[int]:\n    return f(arr)\n\narr = [5, 2, 8, 1, 9]\nassert f(arr) == g(arr)\n",
        "idx_generation": 194,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string 's', reverse the order of words in the string while preserving the order of characters within each word.\n    Return the reversed string.\n    \"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    \n    return ' '.join(reversed_words)\n\ndef g():\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    s = \"Hello World!\"\n    \n    return s\n\nassert f(g()) == \"World! Hello\"\n",
        "idx_generation": 311,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers 'nums' and a target integer 'target', determine if there exists a subset of 'nums' that adds up to the target.\n    Return True if such a subset exists, False otherwise.\n    \"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if nums[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[n][target]\n\ndef g():\n    \"\"\"\n    Generate a list of integers and a target integer.\n    \"\"\"\n    nums = [2, 4, 6, 8, 10]\n    target = 16\n\n    return nums, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 340,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers 'arr', remove all duplicates and return the updated list.\n    The remaining elements should be in the same order as their first occurrence in the list.\n    \"\"\"\n    seen = set()\n    result = []\n\n    for num in arr:\n        if num not in seen:\n            result.append(num)\n            seen.add(num)\n\n    return result\n\ndef g():\n    \"\"\"\n    Generate a list of integers with duplicates.\n    \"\"\"\n    arr = [1, 2, 3, 1, 4, 2, 5, 3, 6]\n    \n    return arr\n\nassert f(g()) == [1, 2, 3, 4, 5, 6]\n\n",
        "idx_generation": 483,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]], word: str) -> bool:\n    \"\"\"\n    Given a grid of characters and a word, determine if the word exists in the grid.\n    The word can be formed by connecting adjacent characters horizontally or vertically.\n    Return True if the word exists, False otherwise.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    def dfs(i, j, idx):\n        if idx == len(word):\n            return True\n        if i < 0 or i >= rows or j < 0 or j >= cols or grid[i][j] != word[idx]:\n            return False\n        \n        temp = grid[i][j]\n        grid[i][j] = \"#\"\n        \n        if dfs(i + 1, j, idx + 1) or dfs(i - 1, j, idx + 1) or dfs(i, j + 1, idx + 1) or dfs(i, j - 1, idx + 1):\n            return True\n        \n        grid[i][j] = temp\n        \n        return False\n    \n    for i in range(rows):\n        for j in range(cols):\n            if dfs(i, j, 0):\n                return True\n    \n    return False\n\ndef g():\n    \"\"\"\n    Generate a grid of characters and a word.\n    \"\"\"\n    grid = [['A', 'B', 'C', 'E'],\n            ['S', 'F', 'C', 'S'],\n            ['A', 'D', 'E', 'E']]\n    word = \"ABCCED\"\n    \n    return grid, word\n\nassert f(*g()) == True\n\n",
        "idx_generation": 125,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Find the element that appears only once in a given array, where all other elements appear twice.\"\"\"\n    unique_element = 0\n    for num in arr:\n        unique_element ^= num\n    return unique_element\n\ndef g():\n    return [1, 2, 2, 3, 3]\n\nassert f(g()) == 1\n",
        "idx_generation": 323,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer 'n', calculate the sum of all the prime numbers\n    less than or equal to 'n'.\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    prime_sum = 0\n    for i in range(2, n + 1):\n        if is_prime(i):\n            prime_sum += i\n\n    return prime_sum\n\ndef g():\n    return 10\n\nassert f(g()) == 17\n",
        "idx_generation": 300,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a directed acyclic graph represented as an adjacency list, determine if there exists a path from the start vertex to the end vertex.\"\"\"\n    visited = set()\n    stack = [start]\n\n    while stack:\n        vertex = stack.pop()\n        if vertex == end:\n            return True\n        visited.add(vertex)\n\n        for neighbor in graph[vertex]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n\n    return False\n\ndef g() -> List[List[int]]:\n    return [[1, 2],\n            [3],\n            [3, 4],\n            [],\n            [5],\n            []]\n\nassert f(g(), 0, 5)\n",
        "idx_generation": 352,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(adj_list: Dict[int, List[int]]) -> bool:\n    \"\"\"Given an adjacency list representing a directed graph, determine if the graph contains a cycle.\n    Return True if a cycle exists, otherwise return False.\n    \"\"\"\n    visited = set()\n    rec_stack = set()\n\n    def dfs(node):\n        visited.add(node)\n        rec_stack.add(node)\n\n        for neighbor in adj_list[node]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n            elif neighbor in rec_stack:\n                return True\n\n        rec_stack.remove(node)\n        return False\n\n    for node in adj_list:\n        if node not in visited:\n            if dfs(node):\n                return True\n\n    return False\n\ndef g(adj_list: Dict[int, List[int]]):\n    return adj_list\n\nassert f(g({1: [2], 2: [3], 3: [1]}))\n",
        "idx_generation": 218,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import itertools\nfrom typing import*\ndef f(nums: List[int], target_sum=10, target_count=3) -> bool:\n    \"\"\"Find if there are 'target_count' numbers in 'nums' that add up to 'target_sum'.\"\"\"\n    import itertools\n    for combination in itertools.combinations(nums, target_count):\n        if sum(combination) == target_sum:\n            return True\n    return False\ndef g(target_sum=10, target_count=3):\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nassert f(g())\n",
        "idx_generation": 476,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, return the number of valid parentheses expressions of length 2n.\n    A valid parentheses expression is one that consists of opening and closing parentheses such that each opening parenthesis has a corresponding closing parenthesis and the expression is balanced.\"\"\"\n    if n == 0:\n        return 1\n    elif n == 1:\n        return 1\n    else:\n        total = 0\n        for i in range(n):\n            total += f(i) * f(n-i-1)\n        return total\n\ndef g() -> int:\n    \"\"\"Generate a positive integer.\"\"\"\n    return 3\n\nassert f(g()) == 5\n",
        "idx_generation": 396,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"Determine if string s is an anagram of string t.\"\"\"\n    if len(s) != len(t):\n        return False\n    count = [0] * 26\n    for i in range(len(s)):\n        count[ord(s[i]) - ord('a')] += 1\n        count[ord(t[i]) - ord('a')] -= 1\n    for c in count:\n        if c != 0:\n            return False\n    return True\n\ndef g():\n    s = \"listen\"\n    t = \"silent\"\n    return s, t\n\nassert f(*g())\n",
        "idx_generation": 296,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(numbers: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target number, determine if the target number is present in the list using binary search.\"\"\"\n    low = 0\n    high = len(numbers) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if numbers[mid] == target:\n            return True\n        elif numbers[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False\n\ndef g():\n    \"\"\"Generate a sorted list of integers and a target number.\"\"\"\n    numbers = [1, 5, 7, 10, 15, 20]\n    target = 7\n    return numbers, target\n\nassert f(*g())\n",
        "idx_generation": 74,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n    Return the minimum sum.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g():\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n\n",
        "idx_generation": 200,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Given a list of integers, return True if the list is a palindrome, False otherwise.\"\"\"\n    return arr == arr[::-1]\n\ndef g():\n    return [1, 2, 3, 2, 1]\n\nassert f(g()) == True\n",
        "idx_generation": 350,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"Determine if there exists a subarray of length k in the given array that has a sum of 0\"\"\"\n    prefix_sum = [0]\n    for num in arr:\n        prefix_sum.append(prefix_sum[-1] + num)\n    for i in range(len(arr) - k + 1):\n        if prefix_sum[i + k] - prefix_sum[i] == 0:\n            return True\n    return False\n\ndef g():\n    return ([1, 2, -3, 4, 5, -6], 3)\n\nassert f(*g())\n",
        "idx_generation": 341,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"Check if a given string s can be rearranged into a palindrome by removing at most n characters.\"\"\"\n    freq = {}\n    for char in s:\n        freq[char] = freq.get(char, 0) + 1\n\n    odd_count = sum(1 for count in freq.values() if count % 2 != 0)\n\n    return odd_count <= n\n\ndef g(s: str) -> str:\n    \"\"\"Rearrange the string s into a palindrome by removing the minimum number of characters.\"\"\"\n    freq = {}\n    for char in s:\n        freq[char] = freq.get(char, 0) + 1\n\n    palindrome = []\n    middle_char = ''\n    for char, count in freq.items():\n        if count % 2 == 0:\n            palindrome.extend([char] * (count // 2))\n        else:\n            if middle_char == '':\n                middle_char = char\n            else:\n                palindrome.extend([char] * (count // 2))\n\n    return ''.join(palindrome) + middle_char + ''.join(palindrome[::-1])\n\nassert f(g('aabbc'), 1)\n",
        "idx_generation": 484,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(seq: List[int], target_sum=100) -> bool:\n    \"\"\"Find a subsequence of 'seq' that adds up to the target_sum\"\"\"\n    n = len(seq)\n    dp = [[False] * (target_sum + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(1, n + 1):\n        for j in range(target_sum + 1):\n            if j < seq[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - seq[i - 1]]\n    return dp[n][target_sum]\ndef g(target_sum=100):\n    return [i for i in range(1, target_sum + 1)]\nassert f(g())\n",
        "idx_generation": 127,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, find the two numbers that appear only once while all the other numbers appear exactly twice.\n    Return a list containing the two numbers that appear only once.\n    Sample input:\n    [1, 2, 3, 2, 4, 4, 5, 1]\n    Sample output:\n    [3, 5]\"\"\"\n    xor = 0\n    for num in arr:\n        xor ^= num\n    mask = xor & -xor\n    num1 = 0\n    num2 = 0\n    for num in arr:\n        if num & mask:\n            num1 ^= num\n        else:\n            num2 ^= num\n    return [num1, num2]\n\ndef g():\n    return [1, 2, 3, 2, 4, 4, 5, 1]\n\nassert f(g()) == [3, 5]\n\n",
        "idx_generation": 328,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, return the nth number in the Fibonacci sequence.\n    The Fibonacci sequence starts with 0 and 1, and each subsequent number is the sum of the two preceding ones.\"\"\"\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    return f(n-1) + f(n-2)\n\ndef g():\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 315,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: List[List[int]], start: int, end: int, k: int) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency matrix, determine if there exists a path from the start vertex to the end vertex with exactly k edges.\"\"\"\n    visited = set()\n    queue = [(start, 0)]\n\n    while queue:\n        vertex, edges = queue.pop(0)\n        if vertex == end and edges == k:\n            return True\n        visited.add(vertex)\n\n        if edges < k:\n            for neighbor in range(len(graph)):\n                if graph[vertex][neighbor] == 1 and neighbor not in visited:\n                    queue.append((neighbor, edges + 1))\n\n    return False\n\ndef g() -> List[List[int]]:\n    return [[0, 1, 1, 0, 0],\n            [0, 0, 0, 1, 0],\n            [0, 0, 0, 0, 1],\n            [0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0]]\n\nassert f(g(), 0, 4, 2)\n",
        "idx_generation": 352,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency matrix, determine if it contains any cycles.\n    Return True if there is at least one cycle, False otherwise.\"\"\"\n    visited = [0] * len(graph)\n    stack = [0] * len(graph)\n\n    def dfs(node):\n        visited[node] = 1\n        stack[node] = 1\n\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1:\n                if visited[neighbor] == 0:\n                    if dfs(neighbor):\n                        return True\n                elif stack[neighbor] == 1:\n                    return True\n\n        stack[node] = 0\n        return False\n\n    for node in range(len(graph)):\n        if visited[node] == 0:\n            if dfs(node):\n                return True\n\n    return False\n\ndef g():\n    return [\n        [0, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 1],\n        [1, 0, 0, 0, 0]\n    ]\n\nassert f(g()) == True\n",
        "idx_generation": 226,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers nums and a target integer, determine if it is possible to select a combination of numbers from the list that sums up to the target.\n    The goal is to find a combination that satisfies the condition.\"\"\"\n    def backtrack(nums, target, curr_sum, index):\n        if curr_sum == target:\n            return True\n        if curr_sum > target or index >= len(nums):\n            return False\n        return (\n            backtrack(nums, target, curr_sum + nums[index], index + 1)\n            or backtrack(nums, target, curr_sum, index + 1)\n        )\n    \n    return backtrack(nums, target, 0, 0)\n\ndef g():\n    nums = [1, 5, 3, 9, 2]\n    target = 8\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 489,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers, count the number of ways to make the sum of elements equal to the target value.\n    You can use each element as many times as needed.\"\"\"\n    n = len(nums)\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for j in range(n):\n            if i >= nums[j]:\n                dp[i] += dp[i - nums[j]]\n    \n    return dp[target]\n\ndef g():\n    nums = [1, 2, 3]\n    target = 4\n    return nums, target\n\nassert f(*g()) == 7\n\n",
        "idx_generation": 405,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport itertools\n\ndef f(words: List[str], target_word: str) -> bool:\n    \"\"\"Check if the target word can be formed using a combination of words from the given list.\"\"\"\n    for r in range(1, len(words) + 1):\n        for combination in itertools.combinations(words, r):\n            if ''.join(combination) == target_word:\n                return True\n    return False\n\ndef g(target_word: str):\n    \"\"\"Find a list of words that can form the target word using a combination of words.\"\"\"\n    return ['apple', 'banana', 'cat']\n\nassert f(g('applecat'), 'applecat')\n",
        "idx_generation": 321,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if a list of numbers has a duplicate element\"\"\"\n    nums.sort()  # Sort the list in ascending order\n    for i in range(1, len(nums)):\n        if nums[i] == nums[i-1]:\n            return True\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 9]  # Return a list with a duplicate element\n\nassert f(g()) == True\n",
        "idx_generation": 76,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine if the given number is prime or not.\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g() -> int:\n    \"\"\"\n    Find the largest prime number less than or equal to 100.\n    \"\"\"\n    primes = []\n    for i in range(2, 101):\n        if f(i):\n            primes.append(i)\n    return max(primes)\n\nassert f(g()) == True\n",
        "idx_generation": 210,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers, return the indices of two numbers such that they add up to a specific target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return [left, right]\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\ndef g(nums: List[int] = [2, 7, 11, 15], target: int = 9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 355,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> int:\n    \"\"\"Given a list of integers, find the longest increasing subsequence (LIS) and return its length.\n    The LIS is a subsequence in the given list where the elements are in increasing order.\"\"\"\n    n = len(arr)\n    lis = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n    return max(lis)\n\ndef g(arr=[10, 9, 2, 5, 3, 7, 101, 18]):\n    \"\"\"Generate a list of integers.\"\"\"\n    return arr\n\nassert f(g()) == 4\n",
        "idx_generation": 343,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a given string is a pangram, which is a sentence that contains every letter of the alphabet at least once.\"\"\"\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    lower_s = s.lower()\n    for char in alphabet:\n        if char not in lower_s:\n            return False\n    return True\n\ndef g():\n    return \"The quick brown fox jumps over the lazy dog\"\n\nassert f(g()) == True\n",
        "idx_generation": 493,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum sum of a subarray within the list.\"\"\"\n    n = len(nums)\n    dp = [0] * n\n    dp[0] = nums[0]\n    max_sum = dp[0]\n    \n    for i in range(1, n):\n        dp[i] = max(nums[i], nums[i] + dp[i - 1])\n        max_sum = max(max_sum, dp[i])\n    \n    return max_sum\n\ndef g(nums: List[int]) -> int:\n    return f(nums)\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nassert f(nums) == g(nums)\n",
        "idx_generation": 131,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum possible XOR value between two numbers in the list.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask = mask | (1 << i)\n        prefix_set = set()\n        for num in nums:\n            prefix_set.add(num & mask)\n        temp_max_xor = max_xor | (1 << i)\n        for prefix in prefix_set:\n            if (temp_max_xor ^ prefix) in prefix_set:\n                max_xor = temp_max_xor\n                break\n    return max_xor\n\ndef g(nums=[3, 10, 5, 25, 2, 8]):\n    \"\"\"\n    Generate a list of integers to find the maximum possible XOR value between two numbers in the list.\n    \"\"\"\n    return nums\n\nassert f(g()) == 28\n",
        "idx_generation": 331,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the n-th number in the Fibonacci sequence.\n    - n: the position of the number in the Fibonacci sequence\n    - return: the n-th Fibonacci number\n    \"\"\"\n    if n <= 0:\n        return -1\n\n    if n == 1 or n == 2:\n        return 1\n\n    fib = [0] * (n + 1)\n    fib[1] = 1\n    fib[2] = 1\n\n    for i in range(3, n + 1):\n        fib[i] = fib[i - 1] + fib[i - 2]\n\n    return fib[n]\n\ndef g():\n    return 7\n\nassert f(g()) == 13\n",
        "idx_generation": 326,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start=0, end=4) -> bool:\n    \"\"\"Find if there exists a path from start to end in the given graph\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        vertex = stack.pop()\n        if vertex == end:\n            return True\n        if vertex not in visited:\n            visited.add(vertex)\n            stack.extend(graph[vertex])\n    return False\ndef g(start=0, end=4):\n    graph = {\n        0: [1, 2],\n        1: [2],\n        2: [0, 3],\n        3: [3, 4],\n        4: [2]\n    }\n    return graph\nassert f(g())\n",
        "idx_generation": 367,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, k: int) -> bool:\n    \"\"\"Given a graph as an adjacency matrix, starting node, ending node, and a number k,\n    determine if there exists a path from start to end with a product of k.\"\"\"\n    visited = [False] * len(graph)\n    return dfs(graph, start, end, k, visited)\n\ndef dfs(graph: List[List[int]], curr: int, end: int, k: int, visited: List[bool]) -> bool:\n    if curr == end:\n        if k == 1:\n            return True\n        return False\n    \n    visited[curr] = True\n    \n    for neighbor in range(len(graph[curr])):\n        if not visited[neighbor] and graph[curr][neighbor] != 0:\n            if dfs(graph, neighbor, end, k // graph[curr][neighbor], visited):\n                return True\n    \n    visited[curr] = False\n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a random graph with 5 nodes.\"\"\"\n    graph = [[0, 1, 2, 0, 0],\n             [0, 0, 0, 3, 0],\n             [0, 0, 0, 0, 4],\n             [0, 0, 0, 0, 0],\n             [0, 0, 0, 0, 0]]\n    return graph\n\nassert f(g(), 0, 4, 8)\n",
        "idx_generation": 229,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"Given two integers 'n' and 'k', return the number of ways to climb a staircase with 'n' steps\n    if you can climb either 1 or 'k' steps at a time.\"\"\"\n    if n == 0:\n        return 1\n    if n < 0:\n        return 0\n    count = 0\n    for i in range(1, k + 1):\n        count += f(n - i, k)\n    return count\n\ndef g(n=5, k=2):\n    \"\"\"Generate the number of steps in the staircase and the maximum number of steps that can be climbed at a time.\"\"\"\n    return n, k\n\nassert f(*g()) == 8\n",
        "idx_generation": 418,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Given two strings s1 and s2, return True if s2 can be obtained by rotating s1 by any number of places,\notherwise return False.\n\"\"\"\n    if len(s1) != len(s2):\n        return False\n    for i in range(len(s1)):\n        rotated_s1 = s1[i:] + s1[:i]\n        if rotated_s1 == s2:\n            return True\n    return False\ndef g(s1: str, s2: str) -> Tuple[str, str]:\n    # Rotate s1 by a random number of places\n    import random\n    rotations = random.randint(1, len(s1))\n    rotated_s1 = s1[rotations:] + s1[:rotations]\n    return rotated_s1, s2\nassert f(*g('abcd', 'cdab'))\n",
        "idx_generation": 338,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target number, determine if there are two numbers in the list that add up to the target.\n    Return True if such pair exists, False otherwise.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        total = nums[left] + nums[right]\n        if total == target:\n            return True\n        elif total < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 3, 5, 7, 9, 11, 13, 15]\n\nassert f(g(), 16)\n",
        "idx_generation": 78,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if it can be partitioned into two subsets such that the sum of elements in both subsets is equal.\n    Return True if such partitioning is possible, False otherwise.\n    Example:\n    nums = [1, 5, 11, 5]\n    The array can be partitioned into [1, 5, 5] and [11] with equal sums of 11.\n    Therefore, the answer is True.\n    \"\"\"\n    total_sum = sum(nums)\n    \n    if total_sum % 2 != 0:\n        return False\n    \n    target_sum = total_sum // 2\n    \n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    \n    for num in nums:\n        for i in range(target_sum, num - 1, -1):\n            dp[i] = dp[i] or dp[i - num]\n    \n    return dp[target_sum]\n\ndef g():\n    return [1, 5, 11, 5]\n\nassert f(g())\n",
        "idx_generation": 214,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"Sort the list of words in lexicographic order, ignoring case.\"\"\"\n    return sorted(words, key=lambda x: x.lower())\n\ndef g():\n    return [\"Apple\", \"banana\", \"cherry\", \"Date\", \"elderberry\"]\n\nassert f(g()) == [\"Apple\", \"banana\", \"cherry\", \"Date\", \"elderberry\"]\n",
        "idx_generation": 358,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if there exists a subsequence of length k whose sum is divisible by k\"\"\"\n    k = len(nums)\n    dp = [[False] * (k + 1) for _ in range(k)]\n    for i in range(k):\n        dp[i][0] = True\n    for i in range(k):\n        for j in range(1, k + 1):\n            dp[i][j] = dp[i][j - 1] or (i > 0 and dp[i - 1][j - 1])\n    return dp[k - 1][k]\n\ndef g(k=3, nums=[1, 2, 3, 4, 5, 6, 7, 8, 9]):\n    return nums[:k]\n\nassert f(g())\n",
        "idx_generation": 351,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of non-negative integers and a target value, determine if it is possible to split the list into two\n    subsets such that the sum of elements in each subset is equal to the target value.\"\"\"\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n    target_sum = total_sum // 2\n    return can_partition(nums, len(nums) - 1, target_sum)\n\ndef can_partition(nums: List[int], index: int, target_sum: int) -> bool:\n    if target_sum == 0:\n        return True\n    if index < 0 or target_sum < 0 or nums[index] > target_sum:\n        return False\n    return can_partition(nums, index - 1, target_sum - nums[index]) or can_partition(nums, index - 1, target_sum)\n\ndef g() -> List[int]:\n    return [1, 5, 11, 5]\n\ntarget = sum(g()) // 2\nassert f(g(), target)\n",
        "idx_generation": 132,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], k=3) -> bool:\n    \"\"\"Find the maximum bitwise AND value between any two numbers in the given array\"\"\"\n    max_and = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            max_and = max(max_and, arr[i] & arr[j])\n    return max_and >= k\ndef g(k=3):\n    return [5, 8, 12, 3, 16]\nassert f(g())\n",
        "idx_generation": 338,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, find the minimum number of perfect squares that sum up to n.\"\"\"\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    \n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            dp[i] = min(dp[i], dp[i - j * j] + 1)\n            j += 1\n    \n    return dp[n]\n\ndef g(n: int) -> int:\n    \"\"\"Return n\"\"\"\n    return n\n\nassert f(g(n=12)) == 3\n",
        "idx_generation": 337,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"Check if there is a path from the start node to the end node in the given graph.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g():\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['D', 'E'],\n        'C': ['F'],\n        'D': [],\n        'E': ['F'],\n        'F': []\n    }\n    start = 'A'\n    end = 'F'\n    return graph, start, end\n\nassert f(*g())\n",
        "idx_generation": 391,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given an adjacency matrix representation of a graph, determine if there is a path from a start node to an end node.\n    Return True if a path exists, otherwise return False.\n    \"\"\"\n    visited = [False] * len(graph)\n\n    def dfs(node):\n        if node == end:\n            return True\n\n        visited[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n\n        return False\n\n    return dfs(start)\n\ndef g():\n    graph = [\n        [1, 2],     # Node 0 is connected to nodes 1 and 2\n        [0, 3],     # Node 1 is connected to nodes 0 and 3\n        [0, 4],     # Node 2 is connected to nodes 0 and 4\n        [1],        # Node 3 is only connected to node 1\n        [2, 5],     # Node 4 is connected to nodes 2 and 5\n        [4, 6],     # Node 5 is connected to nodes 4 and 6\n        [5]         # Node 6 is only connected to node 5\n    ]\n    start = 0\n    end = 6\n    return graph, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 239,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target sum, find the number of ways to obtain the target sum \n    by adding or subtracting the integers in the list. Duplicates are allowed.\n    Return the count of such ways.\n    \"\"\"\n    def dfs(nums, target, index, curr_sum):\n        if index == len(nums):\n            if curr_sum == target:\n                return 1\n            else:\n                return 0\n        else:\n            return dfs(nums, target, index + 1, curr_sum + nums[index]) + dfs(nums, target, index + 1, curr_sum - nums[index])\n\n    return dfs(nums, target, 0, 0)\n\ndef g():\n    return [1, 2, 3, 4, 5], 5\n\nassert f(*g()) == 3\n",
        "idx_generation": 420,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import itertools\nfrom typing import*\nfrom itertools import permutations\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string 's', check if it is a palindrome and if it can be rearranged to form a palindrome.\n    Return True if it is possible, False otherwise.\n    \"\"\"\n    char_counts = {}\n    odd_count = 0\n    \n    for char in s:\n        if char in char_counts:\n            char_counts[char] += 1\n        else:\n            char_counts[char] = 1\n    \n    for count in char_counts.values():\n        if count % 2 != 0:\n            odd_count += 1\n    \n    return odd_count <= 1\n\ndef g():\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    s = \"aabbaa\"\n    \n    return s\n\nassert f(g())\n",
        "idx_generation": 369,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Remove all occurrences of duplicates in a given list of numbers and return the modified list.\"\"\"\n    unique_nums = []\n    for num in nums:\n        if num not in unique_nums:\n            unique_nums.append(num)\n    return unique_nums\n\ndef g(nums: List[int]):\n    return f(nums)\n\nassert f(g([1, 2, 3, 1, 4, 2, 5, 6, 3, 7])) == [1, 2, 3, 4, 5, 6, 7]\n",
        "idx_generation": 79,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence in the list.\n    An increasing subsequence is a subsequence where the elements are in increasing order, but not necessarily contiguous.\n    Return the length of the longest increasing subsequence.\"\"\"\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g(nums: List[int]):\n    return nums\n\nassert f(g([10, 9, 2, 5, 3, 7, 101, 18])) == 4\n",
        "idx_generation": 219,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target='python') -> bool:\n    \"\"\"Given a string s, check if it is an anagram of the target string.\"\"\"\n    return sorted(s) == sorted(target)\ndef g(target='python'):\n    return ''.join(sorted(target))\nassert f(g())\n",
        "idx_generation": 386,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=0) -> bool:\n    \"\"\"Find a subset of numbers that add up to the target value.\"\"\"\n    def subsetSum(nums, target, index, currentSum):\n        if currentSum == target:\n            return True\n        if index >= len(nums):\n            return False\n        return subsetSum(nums, target, index + 1, currentSum + nums[index]) or subsetSum(nums, target, index + 1, currentSum)\n    \n    return subsetSum(nums, target, 0, 0)\n\ndef g(target=0):\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g(), target=9)\n",
        "idx_generation": 353,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum sum of any contiguous subarray.\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef g() -> List[int]:\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 132,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of set bits in the binary representation of a given number\"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g():\n    return 42\n\nassert f(g()) == 3\n",
        "idx_generation": 341,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a subset with a sum equal to a given target.\"\"\"\n    def can_sum(target, index):\n        if target == 0:\n            return True\n        if target < 0 or index >= len(nums):\n            return False\n        if can_sum(target - nums[index], index + 1):\n            return True\n        return can_sum(target, index + 1)\n    \n    return can_sum(sum(nums) // 2, 0)\n\ndef g(nums: List[int]):\n    return nums\n\nassert f(g([1, 5, 11, 5]))\n",
        "idx_generation": 355,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int, start: int) -> bool:\n    \"\"\"\n    Determine if it is possible to reach the target element from the start element in a directed graph.\n\n    Example:\n    Input: [0, 1, 2, 3, 4, 5], target = 5, start = 0\n    Output: True\n    Explanation: There is a path from 0 to 5 in the directed graph: 0 -> 1 -> 2 -> 3 -> 4 -> 5.\n    \"\"\"\n\n    graph = {}\n    visited = set()\n    stack = [start]\n\n    for i, num in enumerate(nums):\n        if num not in graph:\n            graph[num] = set()\n        if i < len(nums) - 1:\n            graph[num].add(nums[i + 1])\n\n    while stack:\n        current = stack.pop()\n\n        if current == target:\n            return True\n\n        visited.add(current)\n\n        if current in graph:\n            for neighbor in graph[current]:\n                if neighbor not in visited:\n                    stack.append(neighbor)\n\n    return False\n\ndef g():\n    nums = [0, 1, 2, 3, 4, 5]\n    target = 5\n    start = 0\n    return nums, target, start\n\nassert f(*g()) == True\n",
        "idx_generation": 393,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency list and two nodes, determine if there exists a path from the start node to the end node.\"\"\"\n    def dfs(graph, curr, end, visited):\n        if curr == end:\n            return True\n        visited.add(curr)\n        for neighbor in graph[curr]:\n            if neighbor not in visited and dfs(graph, neighbor, end, visited):\n                return True\n        return False\n    visited = set()\n    return dfs(graph, start, end, visited)\ndef g(graph={1: [2, 3], 2: [4, 5], 3: [6, 7], 4: [], 5: [], 6: [], 7: []}, start=1, end=7):\n    return graph, start, end\nassert f(*g())\n",
        "idx_generation": 244,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Given two integers n and k, determine if there exists a combination of k numbers from the range 1 to n\n    such that the sum of the numbers is divisible by k.\n    Return True if such combination exists, False otherwise.\n    \"\"\"\n    def backtrack(nums, target, start, k):\n        if target == 0 and k == 0:\n            return True\n        if k == 0:\n            return False\n        for i in range(start, len(nums)):\n            if backtrack(nums, (target + nums[i]) % k, i + 1, k - 1):\n                return True\n        return False\n    \n    nums = list(range(1, n + 1))\n    target = 0\n    start = 0\n    \n    return backtrack(nums, target, start, k)\n\ndef g() -> Tuple[int, int]:\n    \"\"\"\n    Generate two random integers n and k such that 1 \u2264 k \u2264 n \u2264 10.\n    \"\"\"\n    import random\n    n = random.randint(1, 10)\n    k = random.randint(1, n)\n    \n    return n, k\n\nassert f(*g()) == True\n",
        "idx_generation": 422,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string s, determine if it is a palindrome after removing exactly one character.\n    Return True if it is possible to make s a palindrome by removing one character, False otherwise.\n    \"\"\"\n    i = 0\n    j = len(s) - 1\n    while i < j:\n        if s[i] != s[j]:\n            # Check if removing s[i] makes the rest of the string a palindrome\n            if s[i+1:j+1] == s[i+1:j+1][::-1]:\n                return True\n            # Check if removing s[j] makes the rest of the string a palindrome\n            if s[i:j] == s[i:j][::-1]:\n                return True\n            return False\n        i += 1\n        j -= 1\n    return True\n\ndef g(s: str) -> str:\n    \"\"\"Return the string s\"\"\"\n    return s\n\nassert f(g(s=\"racecar\"))\n",
        "idx_generation": 386,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers that add up to the target value.\n    Return True if there are, False otherwise.\"\"\"\n    i = 0\n    j = len(nums) - 1\n    while i < j:\n        if nums[i] + nums[j] == target:\n            return True\n        elif nums[i] + nums[j] < target:\n            i += 1\n        else:\n            j -= 1\n    return False\n\ndef g(nums: List[int], target: int) -> bool:\n    return f(nums, target)\n\nnums = [1, 2, 3, 4, 5]\ntarget = 7\nassert f(nums, target) == g(nums, target)\n",
        "idx_generation": 80,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the longest increasing subsequence (LIS) in the list.\n    Return the length of the LIS.\"\"\"\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[int]:\n    \"\"\"Return a list of integers\"\"\"\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 224,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> str:\n    \"\"\"Given a positive integer n, return the binary representation of n without leading zeros.\n    \"\"\"\n    return bin(n)[2:]\n\ndef g(n: int) -> int:\n    \"\"\"Return the positive integer n\"\"\"\n    return n\n\nassert f(g(n=10)) == \"1010\"\n",
        "idx_generation": 386,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if it is possible to split the list into two\n    sublists such that the sum of elements in each sublist is equal to the target.\n    The solution is a boolean indicating if the split is possible.\"\"\"\n\n    def subset_sum(nums, target_sum):\n        n = len(nums)\n        dp = [[False] * (target_sum + 1) for _ in range(n + 1)]\n\n        for i in range(n + 1):\n            dp[i][0] = True\n\n        for i in range(1, n + 1):\n            for j in range(1, target_sum + 1):\n                if j < nums[i - 1]:\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n\n        return dp[n][target_sum]\n\n    total_sum = sum(nums)\n\n    if total_sum % 2 != 0:\n        return False\n\n    target_sum = total_sum // 2\n    \n    return subset_sum(nums, target_sum)\n\ndef g(nums: List[int], target: int):\n    return nums\n\n# Example usage\nnums = [1, 5, 11, 5]\ntarget = 11\nassert f(g(nums, target), target)\n",
        "idx_generation": 353,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of non-negative integers and a target value, determine if it is possible to reach the target value\n    by performing any combination of addition or subtraction operations on the list elements.\"\"\"\n    memo = {}\n    return can_reach_target(nums, len(nums) - 1, target, memo)\n\ndef can_reach_target(nums: List[int], index: int, target: int, memo) -> bool:\n    if target == 0:\n        return True\n    if index < 0:\n        return False\n    if (index, target) in memo:\n        return memo[(index, target)]\n    memo[(index, target)] = can_reach_target(nums, index - 1, target - nums[index], memo) or \\\n                            can_reach_target(nums, index - 1, target + nums[index], memo)\n    return memo[(index, target)]\n\ndef g() -> List[int]:\n    return [1, 5, 11]\n\ntarget = 6\nassert f(g(), target)\n",
        "idx_generation": 132,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"Given a non-negative integer, find the number of 1 bits in its binary representation.\"\"\"\n    count = 0\n    while num != 0:\n        count += num & 1\n        num >>= 1\n    return count\n\ndef g():\n    num = 10\n    return num\n\nassert f(g()) == 2\n",
        "idx_generation": 345,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find the number of ways to climb n stairs, where you can only take 1 or 2 steps at a time.\"\"\"\n    if n <= 1:\n        return 1\n    return f(n-1) + f(n-2)\n\ndef g():\n    return 5\n\nassert f(g()) == 8\n",
        "idx_generation": 363,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a directed graph, determine if there exists a path from the start node to the end node.\n    Sample Input:\n    graph = [[0, 1, 1, 0, 0],\n             [0, 0, 1, 0, 0],\n             [0, 0, 0, 1, 0],\n             [0, 0, 0, 0, 1],\n             [0, 0, 0, 0, 0]]\n    start = 0\n    end = 4\n    Sample Output:\n    True\"\"\"\n    stack = [start]\n    visited = set()\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        visited.add(node)\n        neighbors = [i for i in range(len(graph)) if graph[node][i] == 1]\n        for neighbor in neighbors:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    return False\n\ndef g(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if a path exists between two nodes in a directed graph.\"\"\"\n    visited = set()\n    queue = [start]\n    while queue:\n        node = queue.pop(0)\n        if node == end:\n            return True\n        visited.add(node)\n        neighbors = [i for i in range(len(graph)) if graph[node][i] == 1]\n        for neighbor in neighbors:\n            if neighbor not in visited:\n                queue.append(neighbor)\n    return False\n\nassert f(graph=[[0, 1, 1, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0]], start=0, end=4) == g(graph=[[0, 1, 1, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0]], start=0, end=4)\n",
        "idx_generation": 399,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"Given an adjacency matrix representing a directed graph, check if there exists a cycle in the graph.\n    Return True if a cycle exists, False otherwise.\n    \"\"\"\n    visited = [False] * len(graph)\n    stack = [False] * len(graph)\n    \n    def has_cycle(node):\n        visited[node] = True\n        stack[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if has_cycle(neighbor):\n                    return True\n            elif stack[neighbor]:\n                return True\n        \n        stack[node] = False\n        return False\n    \n    for node in range(len(graph)):\n        if not visited[node]:\n            if has_cycle(node):\n                return True\n    \n    return False\n\ndef g():\n    graph = [[0, 1, 0, 0],\n             [0, 0, 1, 0],\n             [0, 0, 0, 1],\n             [1, 0, 0, 0]]\n    return (graph,)\n\nassert f(*g())\n",
        "idx_generation": 257,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the number of ways to select k objects from a set of n objects.\n    Return the number of combinations.\n    \"\"\"\n    if k == 0 or k == n:\n        return 1\n    \n    combinations = f(n-1, k-1) + f(n-1, k)\n    \n    return combinations\n\ndef g():\n    \"\"\"\n    Generate two integers.\n    \"\"\"\n    n = 5\n    k = 3\n    \n    return n, k\n\nassert f(*g()) == 10\n\n",
        "idx_generation": 427,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string 's', determine if it is a palindrome when considering only alphanumeric characters and ignoring case.\n    Return True if it is a palindrome, False otherwise.\n    Example:\n    s = \"A man, a plan, a canal: Panama\"\n    After removing non-alphanumeric characters and converting to lowercase, the string becomes \"amanaplanacanalpanama\",\n    which is a palindrome.\n    Therefore, the answer is True.\n    \"\"\"\n    alphanumeric_s = ''.join(c.lower() for c in s if c.isalnum())\n    return alphanumeric_s == alphanumeric_s[::-1]\n\ndef g():\n    return \"A man, a plan, a canal: Panama\"\n\nassert f(g())\n",
        "idx_generation": 394,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"Given a list of integers, find the k smallest elements in the list.\"\"\"\n    nums.sort()\n    return nums[:k]\n\ndef g():\n    nums = [9, 4, 6, 2, 8, 1, 5, 7, 3]\n    k = 4\n    return nums, k\n\nassert f(*g()) == [1, 2, 3, 4]\n",
        "idx_generation": 83,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if there exists a subset of the list that adds up to the target. You can choose any number of elements from the list to form the subset.\"\"\"\n    n = len(arr)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if arr[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j - arr[i - 1]] or dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[n][target]\n\ndef g() -> List[int]:\n    return [2, 4, 6, 8, 10]\n\nassert f(g(), 14)\n",
        "idx_generation": 224,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"Find the sum of all the ASCII values of the characters in a string.\"\"\"\n    return sum(ord(c) for c in s)\n\ndef g():\n    return \"hello\"\n\nassert f(g()) == 532\n",
        "idx_generation": 388,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a subsequence of the list\n    such that the sum of its elements is a perfect square.\n\n    Return True if such a subsequence exists, False otherwise.\n    \"\"\"\n    def is_perfect_square(n: int) -> bool:\n        return int(n**0.5)**2 == n\n\n    prefix_sums = [0]\n    for num in nums:\n        prefix_sums.append(prefix_sums[-1] + num)\n\n    for i in range(len(prefix_sums)):\n        for j in range(i+1, len(prefix_sums)):\n            subsequence_sum = prefix_sums[j] - prefix_sums[i]\n            if is_perfect_square(subsequence_sum):\n                return True\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g())\n",
        "idx_generation": 354,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers nums and a target integer target, find the number of possible combinations that add up to the target.\n    You may use any number of elements from the list multiple times.\n    Return the total number of combinations.\n    \"\"\"\n    # Dynamic programming approach\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i >= num:\n                dp[i] += dp[i - num]\n\n    return dp[target]\n\ndef g(nums: List[int], target: int) -> Tuple[List[int], int]:\n    \"\"\"Return the list of integers nums and the target integer target\"\"\"\n    return nums, target\n\nassert f(*g([1, 2, 3], 4)) == 7\n\n",
        "idx_generation": 133,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a subarray whose bitwise XOR equals the target value.\n    Sample input:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    Sample output:\n    True\n    Explanation: The subarray [3, 4] has a bitwise XOR of 7.\n    \"\"\"\n    prefix_xor = [0]\n    for num in arr:\n        prefix_xor.append(prefix_xor[-1] ^ num)\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)+1):\n            if prefix_xor[i] ^ prefix_xor[j] == target:\n                return True\n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 345,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if there exists a subset of the list where the sum of the elements is equal to the target.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j < nums[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n\n    return dp[n][target]\n\ndef g() -> List[int]:\n    return [2, 4, 6, 8, 10]\n\nassert f(g(), 16)\n",
        "idx_generation": 364,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(graph: Dict[int, List[int]], start: int, target: int) -> bool:\n    \"\"\"Given a graph represented as an adjacency list and two nodes, determine if there is a path between the two nodes.\"\"\"\n    queue = deque([start])\n    visited = set()\n    \n    while queue:\n        node = queue.popleft()\n        visited.add(node)\n        \n        if node == target:\n            return True\n        \n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                queue.append(neighbor)\n    \n    return False\n\ndef g():\n    graph = {0: [1, 2], 1: [2], 2: [3], 3: [1]}\n    start = 0\n    target = 3\n    return graph, start, target\n\nassert f(*g()) == True\n",
        "idx_generation": 399,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, k: int) -> bool:\n    \"\"\"Check if there is a path from the start node to the end node in the given graph,\n    such that the sum of the edges along the path is divisible by k.\"\"\"\n    visited = set()\n    stack = [(start, 0)]\n    \n    while stack:\n        node, path_sum = stack.pop()\n        \n        if node == end and path_sum % k == 0:\n            return True\n        \n        if node not in visited:\n            visited.add(node)\n            for neighbor, weight in graph[node]:\n                stack.append((neighbor, path_sum + weight))\n    \n    return False\n\ndef g():\n    graph = [[(1, 2), (2, 3)], [(3, 4)], [(4, 5)], [(5, 6)], []]\n    start = 0\n    end = 5\n    k = 3\n    return graph, start, end, k\n\nassert f(*g())\n",
        "idx_generation": 260,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"Given two integers n and k, find the number of ways to choose k items from a set of n items,\n    such that no two items are adjacent to each other.\n    Example:\n    n = 5, k = 3\n    Output: 6\n    Explanation: There are 6 ways to choose 3 items from a set of 5 items such that no two items are adjacent:\n    [1, 3, 5], [1, 4, 5], [2, 4, 5], [2, 3, 5], [2, 3, 4], [1, 3, 4]\"\"\"\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return f(n-1, k) + f(n-2, k-1)\n\ndef g(n: int, k: int) -> int:\n    \"\"\"Find the number of ways to choose k items from a set of n items, such that no two items are adjacent.\"\"\"\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return g(n-1, k) + g(n-2, k-1)\n\nassert f(n=5, k=3) == g(n=5, k=3)\n",
        "idx_generation": 431,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import itertools\nfrom typing import*\nfrom itertools import permutations\n\ndef f(words: List[str], target='python', length=5) -> bool:\n    \"\"\"Given a list of words, find the number of permutations of length `length` that contain the target word `target`.\n    Return True if the count is even, False otherwise.\n    \"\"\"\n    count = 0\n    for perm in permutations(words, length):\n        if target in ''.join(perm):\n            count += 1\n    return count % 2 == 0\n\ndef g(target='python', length=5):\n    words = ['hello', 'world', 'python', 'programming', 'puzzle']\n    return words\n\nassert f(g())\n",
        "idx_generation": 414,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, find if there exists two numbers such that their sum is equal to the target value.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        \n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n            \n    return False\n\ndef g(nums=[1, 2, 3, 4, 5, 6], target=8):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 84,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Determine if there exists a pair of elements in the given array that sums up to the target value.\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(arr=[2, 7, 11, 15], target=18):\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 227,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"Check if the given strings are anagrams\"\"\"\n    return sorted(s) == sorted(t)\n\ndef g() -> Tuple[str, str]:\n    \"\"\"Generate a pair of anagram strings\"\"\"\n    import random\n    word = \"anagram\"\n    shuffled = list(word)\n    random.shuffle(shuffled)\n    return word, ''.join(shuffled)\n\nassert f(*g())\n",
        "idx_generation": 391,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Given a list of integers, determine whether it is possible to split the list into k non-empty sublists\n    such that the sum of each sublist is equal.\"\"\"\n    def split_sublists(curr_sum: int, curr_index: int, target_sum: int, remaining_sublists: int) -> bool:\n        if remaining_sublists == 0:\n            return True\n        if curr_sum == target_sum:\n            return split_sublists(0, 0, target_sum, remaining_sublists - 1)\n        if curr_index >= len(nums):\n            return False\n        for i in range(curr_index, len(nums)):\n            if curr_sum + nums[i] <= target_sum:\n                if split_sublists(curr_sum + nums[i], i + 1, target_sum, remaining_sublists):\n                    return True\n        return False\n    \n    total_sum = sum(nums)\n    if total_sum % k != 0:\n        return False\n    target_sum = total_sum // k\n    return split_sublists(0, 0, target_sum, k)\n\ndef g(nums: List[int], k: int) -> Tuple[List[int], int]:\n    \"\"\"Generate a list of integers and a value k such that it is possible to split the list into k non-empty\n    sublists with equal sum.\"\"\"\n    nums = [1] * (2 * k)\n    return nums, k\n\nassert f(*g(nums=[1, 1, 1, 1, 1, 1], k=3))\n",
        "idx_generation": 372,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers nums and a target integer target, find the minimum number of coins needed to make up the target amount.\n    You may assume that there is an infinite number of coins of each denomination in the list.\n    If it is not possible to make up the target amount, return -1.\n    \"\"\"\n    # Dynamic programming approach\n    dp = [float('inf')] * (target + 1)\n    dp[0] = 0\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i >= num:\n                dp[i] = min(dp[i], dp[i - num] + 1)\n\n    return dp[target] if dp[target] != float('inf') else -1\n\ndef g(nums: List[int], target: int) -> Tuple[List[int], int]:\n    \"\"\"Return the list of integers nums and the target integer target\"\"\"\n    return nums, target\n\nassert f(*g([1, 2, 5], 11)) == 3\n\n",
        "idx_generation": 133,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"Given a positive integer, find the number of set bits (1s) in its binary representation.\"\"\"\n    count = 0\n    while num:\n        count += num & 1\n        num >>= 1\n    return count\n\ndef g():\n    return 23\n\nassert f(g()) == 4\n",
        "idx_generation": 354,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given an integer n, calculate the number of ways to reach the nth step in a staircase\n    where you can only climb 1 or 2 steps at a time.\"\"\"\n    if n <= 1:\n        return 1\n    prev = 1\n    curr = 1\n    for _ in range(2, n + 1):\n        prev, curr = curr, prev + curr\n    return curr\n\ndef g():\n    return 6\n\nassert f(g()) == 13\n\n",
        "idx_generation": 379,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(adj_matrix: List[List[int]], start=0, end=3) -> bool:\n    \"\"\"Given an adjacency matrix representing a directed graph, determine if there is a path from the start\nvertex to the end vertex. Return True if a path exists, otherwise return False.\"\"\"\n    visited = [False] * len(adj_matrix)\n    stack = [start]\n    while stack:\n        current_vertex = stack.pop()\n        visited[current_vertex] = True\n        if current_vertex == end:\n            return True\n        for neighbor in range(len(adj_matrix)):\n            if adj_matrix[current_vertex][neighbor] == 1 and not visited[neighbor]:\n                stack.append(neighbor)\n    return False\ndef g():\n    return [[0, 1, 1, 0], [0, 0, 1, 0], [0, 0, 0, 1], [0, 0, 0, 0]]\nassert f(g())\n",
        "idx_generation": 404,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Count the number of connected islands in the grid.\"\"\"\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    count = 0\n\n    def dfs(i, j):\n        if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != 1:\n            return\n        grid[i][j] = -1\n        dfs(i - 1, j)\n        dfs(i + 1, j)\n        dfs(i, j - 1)\n        dfs(i, j + 1)\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                count += 1\n                dfs(i, j)\n\n    return count\n\ndef g():\n    return [[1, 1, 0, 0, 0],\n            [1, 1, 0, 0, 0],\n            [0, 0, 1, 0, 0],\n            [0, 0, 0, 1, 1]]\n\nassert f(g()) == 3\n",
        "idx_generation": 263,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, return the number of unique binary strings of length n that do not contain consecutive ones.\"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return 2\n\n    prev_prev = 1\n    prev = 2\n\n    for i in range(2, n):\n        curr = prev + prev_prev\n        prev_prev = prev\n        prev = curr\n\n    return prev\n\ndef g(n: int):\n    return f(n)\n\nassert f(g(4)) == 8\n",
        "idx_generation": 443,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, old_sub='abc', new_sub='def', count=2) -> bool:\n    \"\"\"Replace count occurrences of old_sub with new_sub in the given string\"\"\"\n    new_str = s.replace(old_sub, new_sub, count)\n    return new_str.count(new_sub) == count\ndef g(old_sub='abc', new_sub='def', count=2):\n    s = 'abcabcabcabc'\n    return s\nassert f(g())\n",
        "idx_generation": 451,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers `arr` and a target integer `target`,\n    determine whether there exist two distinct indices i and j in the list\n    such that arr[i] + arr[j] == target.\n    \"\"\"\n    low = 0\n    high = len(arr) - 1\n\n    while low < high:\n        if arr[low] + arr[high] == target:\n            return True\n        elif arr[low] + arr[high] < target:\n            low += 1\n        else:\n            high -= 1\n    \n    return False\n\ndef g(arr: List[int], target: int):\n    \"\"\"\n    Generate a sorted list of integers `arr` and a target integer `target`\n    such that there exist two distinct indices i and j in the list\n    such that arr[i] + arr[j] == target.\n    \"\"\"\n    arr = sorted(arr)\n    return arr, target\n\nassert f(*g([1, 2, 3, 4, 5], 9))\n",
        "idx_generation": 85,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, use binary search to determine if a target integer is present.\"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\ndef g(nums: List[int], target: int) -> bool:\n    return f(nums, target)\n\nnums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ntarget = 5\n\nassert f(nums, target) == g(nums, target)\n",
        "idx_generation": 229,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"Check if the string s can be rearranged to form the string t, without changing the order of the characters within each string.\"\"\"\n    if len(s) != len(t):\n        return False\n    for char in set(s):\n        if s.count(char) != t.count(char):\n            return False\n    return True\n\ndef g(s: str, t: str):\n    return ''.join(sorted(s))\n\nassert f(g(\"python\", \"typhon\"), \"typhon\")\n",
        "idx_generation": 396,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, find whether it is possible to split the list into two non-empty subsets such that the sum of elements in each subset is equal to the target value.\n    Return True if it is possible, otherwise return False.\n    \"\"\"\n    total_sum = sum(nums)\n    if total_sum % 2 != 0 or max(nums) > target:\n        return False\n    dp = [False] * (target + 1)\n    dp[0] = True\n    for num in nums:\n        for i in range(target, num-1, -1):\n            dp[i] |= dp[i - num]\n    return dp[target]\n\ndef g():\n    nums = [1, 5, 11, 5]\n    target = 11\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 376,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"Given a matrix, rotate it 90 degrees clockwise.\n    Return the rotated matrix.\n    \"\"\"\n    n = len(matrix)\n    rotated_matrix = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        for j in range(n):\n            rotated_matrix[j][n-i-1] = matrix[i][j]\n    \n    return rotated_matrix\n\ndef g():\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 134,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of 1's in the binary representation of n.\n    \"\"\"\n    count = 0\n    while n:\n        count += 1\n        n = n & (n - 1)\n    return count\n\ndef g(n: int = 8):\n    return n\n\nassert f(g()) == 1\n",
        "idx_generation": 355,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Find the nth Fibonacci number using recursion.\n    \"\"\"\n    if n <= 1:\n        return n\n\n    return f(n - 1) + f(n - 2)\n\n\ndef g():\n    n = 5\n    return n\n\n\nassert f(g()) == 5\n",
        "idx_generation": 379,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start=0, target=4) -> bool:\n    \"\"\"Given a directed acyclic graph represented as an adjacency list, determine if there is a path from the start node to the target node.\"\"\"\n    visited = set()\n    stack = [start]\n    \n    while stack:\n        node = stack.pop()\n        visited.add(node)\n        \n        if node == target:\n            return True\n        \n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    \n    return False\n\ndef g():\n    graph = [[1, 2], [3], [4], [], []]\n    return graph\n\nassert f(g())\n",
        "idx_generation": 405,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"Given an adjacency matrix representing a directed graph, determine if there exists a cycle in the graph.\n    \n    Return True if a cycle exists, False otherwise.\n    \"\"\"\n    visited = [False] * len(graph)\n    stack = [False] * len(graph)\n    \n    def dfs(node):\n        visited[node] = True\n        stack[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n            elif stack[neighbor]:\n                return True\n        stack[node] = False\n        return False\n    \n    for node in range(len(graph)):\n        if not visited[node]:\n            if dfs(node):\n                return True\n    return False\n\ndef g():\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 0, 0, 0]\n    ]\n    return graph\n\nassert f(g())\n",
        "idx_generation": 274,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, determine the number of valid parentheses expressions of length 2*n.\n    \"\"\"\n    dp = [0] * (n+1)\n    dp[0] = 1\n    for i in range(1, n+1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i-j-1]\n    return dp[n]\n\ndef g(n=3):\n    \"\"\"\n    Find the number of valid parentheses expressions of length 2*n.\n    \"\"\"\n    return n\n\nassert f(g()) == 5\n",
        "idx_generation": 445,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the number of unique substrings that can be formed from s.\n    A substring is a contiguous sequence of characters within a string.\n    \"\"\"\n    substrings = set()\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            substrings.add(s[i:j])\n    return len(substrings)\n\ndef g():\n    s = \"abc\"\n    return s\n\nassert f(g()) == 6\n\n",
        "idx_generation": 485,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Given an array of integers, check if the array is sorted in non-decreasing order.\"\"\"\n    return arr == sorted(arr)\n\ndef g():\n    return [2, 4, 6, 8, 10, 12, 14]\n    \nassert f(g())\n",
        "idx_generation": 86,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence.\n    Return the length of the longest increasing subsequence.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 237,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if a string is a pangram.\n    \"\"\"\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    return all(char in s.lower() for char in alphabet)\n\ndef g():\n    \"\"\"\n    Generate a random pangram.\n    \"\"\"\n    import random\n    letters = random.sample('abcdefghijklmnopqrstuvwxyz', k=26)\n    return ''.join(letters)\n\nassert f(g())\n",
        "idx_generation": 409,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Find if there exists a subset of nums that sums up to the target value.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(1, n + 1):\n        dp[i][0] = True\n        for j in range(1, target + 1):\n            if j < nums[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n    return dp[n][target]\n\ndef g(nums=[2, 4, 6, 8, 10]):\n    return nums\n\nassert f(g())\n",
        "idx_generation": 389,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum sum of a subarray with the constraint that no two numbers in the subarray are adjacent.\n    Return the maximum sum.\n    Example:\n    nums = [2, 1, 5, 8, 4]\n    The maximum sum of a subarray with no adjacent numbers is 11, which can be obtained by selecting the subarray [2, 5, 4].\n    Therefore, the answer is 11.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    if n == 1:\n        return nums[0]\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n    return dp[-1]\n\ndef g():\n    return [2, 1, 5, 8, 4]\n\nassert f(g()) == 11\n",
        "idx_generation": 137,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers and a value k, find the number of pairs (a, b) such that (a & b) == k.\n    \"\"\"\n    count = 0\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if (numbers[i] & numbers[j]) == k:\n                count += 1\n    return count\n\ndef g(numbers=[1, 2, 3, 4, 5], k=0):\n    \"\"\"\n    Generate a list of integers and a value k such that the number of pairs (a, b) such that (a & b) == k is non-zero.\n    \"\"\"\n    return numbers, k\n\nassert f(*g()) > 0\n",
        "idx_generation": 360,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target=100) -> bool:\n    \"\"\"Given a list of positive integers and a target number, determine if it is possible to\n    combine the numbers using addition, subtraction, multiplication, or division to reach the target number.\n    You can use each number in the list exactly once.\n    \"\"\"\n    def solve(nums, target):\n        if len(nums) == 1:\n            return nums[0] == target\n        for i, num in enumerate(nums):\n            remaining_nums = nums[:i] + nums[i + 1:]\n            if solve(remaining_nums, target - num):\n                return True\n            if solve(remaining_nums, target + num):\n                return True\n            if solve(remaining_nums, target * num):\n                return True\n            if num != 0 and target % num == 0:\n                if solve(remaining_nums, target // num):\n                    return True\n        return False\n\n    return solve(nums, target)\n\ndef g(nums=[2, 4, 6, 8, 10], target=100):\n    return nums\n\nassert f(g())\n",
        "idx_generation": 381,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"Given an adjacency matrix 'graph' representing a directed graph,\n    determine if there exists a path from the source node (index 0) to the destination node (index n-1).\n    The graph is represented as a square matrix where graph[i][j] = 1 if there is a directed edge from node i to node j,\n    and graph[i][j] = 0 otherwise.\n    Return True if a path exists, False otherwise.\n    Example:\n    graph = [[0, 1, 1, 0],\n             [0, 0, 1, 0],\n             [0, 0, 0, 1],\n             [0, 0, 0, 0]]\n    The graph represents the following directed graph:\n    0 -> 1 -> 2 -> 3\n    There is a path from node 0 to node 3, so the answer is True.\n    \"\"\"\n    stack = [0]\n    visited = [False] * len(graph)\n    while stack:\n        node = stack.pop()\n        if node == len(graph) - 1:\n            return True\n        if visited[node]:\n            continue\n        visited[node] = True\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1:\n                stack.append(neighbor)\n    return False\n\ndef g():\n    return [[0, 1, 1, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1],\n            [0, 0, 0, 0]]\n\nassert f(g())\n",
        "idx_generation": 421,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid. You can only move either down or right at any point in time.\"\"\"\n    def backtrack(i, j):\n        if i == n - 1 and j == n - 1:\n            return 1\n        if i >= n or j >= n:\n            return 0\n        return backtrack(i + 1, j) + backtrack(i, j + 1)\n    \n    return backtrack(0, 0)\n\ndef g():\n    return 3\n\nassert f(g()) == 6\n",
        "idx_generation": 277,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> int:\n    \"\"\"Given an array of integers, find the length of the longest subarray with an equal number of even and odd elements.\n    Sample Input:\n    arr = [2, 3, 4, 6, 7, 8, 9, 10, 14]\n    Sample Output:\n    6\"\"\"\n    prefix_sum = 0\n    max_length = 0\n    prefix_sums = {0: -1}\n    for i, num in enumerate(arr):\n        if num % 2 == 0:\n            prefix_sum += 1\n        else:\n            prefix_sum -= 1\n        if prefix_sum in prefix_sums:\n            length = i - prefix_sums[prefix_sum]\n            max_length = max(max_length, length)\n        else:\n            prefix_sums[prefix_sum] = i\n    return max_length\n\ndef g(arr: List[int]) -> int:\n    \"\"\"Find the length of the longest subarray with an equal number of even and odd elements.\"\"\"\n    prefix_sum = 0\n    max_length = 0\n    prefix_sums = {0: -1}\n    for i, num in enumerate(arr):\n        if num % 2 == 0:\n            prefix_sum += 1\n        else:\n            prefix_sum -= 1\n        if prefix_sum in prefix_sums:\n            length = i - prefix_sums[prefix_sum]\n            max_length = max(max_length, length)\n        else:\n            prefix_sums[prefix_sum] = i\n    return max_length\n\nassert f(arr=[2, 3, 4, 6, 7, 8, 9, 10, 14]) == g(arr=[2, 3, 4, 6, 7, 8, 9, 10, 14])\n",
        "idx_generation": 446,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array arr and a target value, determine if there are two numbers in the array that add up to the target.\"\"\"\n    n = len(arr)\n    left, right = 0, n - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(arr: List[int], target: int) -> List[int]:\n    \"\"\"Given a sorted array arr and a target value, find the two numbers that add up to the target and return them.\"\"\"\n    n = len(arr)\n    left, right = 0, n - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return [arr[left], arr[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\nassert f(g([1, 2, 3, 4, 5, 6], 9), 9)\n",
        "idx_generation": 86,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers in ascending order and a target value, find the index of the target value in the list.\n    If the target value is not in the list, return -1.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(nums=[1, 3, 5, 7, 9, 11, 13, 15], target=7):\n    return nums, target\n\nassert f(g()[0], g()[1]) == 3\n",
        "idx_generation": 239,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"Given two strings s and t, determine if they are isomorphic.\n    Two strings are isomorphic if the characters in s can be replaced to get t.\n    Return True if the strings are isomorphic, False otherwise.\n    \"\"\"\n    if len(s) != len(t):\n        return False\n    s_to_t = {}\n    t_to_s = {}\n    for i in range(len(s)):\n        if s[i] in s_to_t and s_to_t[s[i]] != t[i]:\n            return False\n        if t[i] in t_to_s and t_to_s[t[i]] != s[i]:\n            return False\n        s_to_t[s[i]] = t[i]\n        t_to_s[t[i]] = s[i]\n    return True\n\ndef g():\n    s = \"paper\"\n    t = \"title\"\n    return s, t\n\nassert f(*g()) == True\n",
        "idx_generation": 414,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers nums and a target value, determine if there exists a subset of nums that sums up to the target value.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if nums[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[n][target]\n\ndef g():\n    return [1, 3, 5, 7, 9]\n\nassert f(g(), 12)\n",
        "idx_generation": 400,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\"\"\"\n    def count_paths(i, j):\n        if i == n-1 and j == n-1:\n            return 1\n        if i >= n or j >= n:\n            return 0\n        return count_paths(i+1, j) + count_paths(i, j+1)\n    return count_paths(0, 0)\n\ndef g(n=4):\n    return n\n\nassert f(g()) == 20\n",
        "idx_generation": 138,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of triplets (a, b, c) such that (a | b) ^ c == 0.\n    \"\"\"\n    count = 0\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            for k in range(j+1, len(numbers)):\n                if (numbers[i] | numbers[j]) ^ numbers[k] == 0:\n                    count += 1\n    return count\n\ndef g(numbers=[1, 2, 3, 4, 5]):\n    \"\"\"\n    Generate a list of integers such that the number of triplets (a, b, c) such that (a | b) ^ c == 0 is non-zero.\n    \"\"\"\n    return numbers\n\nassert f(g()) > 0\n",
        "idx_generation": 360,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find n such that the sum of the first n natural numbers is equal to the sum of the first n odd numbers.\"\"\"\n    sum_natural = n * (n + 1) // 2\n    sum_odd = n ** 2\n    return sum_natural == sum_odd\n\ndef g():\n    n = 1\n    while not f(n):\n        n += 1\n    return n\n\nassert f(g())\n",
        "idx_generation": 392,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a graph represented as adjacency lists and two nodes (start and end), determine if there exists a path from start to end.\n    Return True if a path exists, False otherwise.\"\"\"\n    visited = set()\n    stack = [start]\n    \n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n                \n    return False\n\ndef g(graph: List[List[int]], start: int, end: int) -> bool:\n    return f(graph, start, end)\n\ngraph = [[1, 2, 3], [2, 4], [3, 5], [], [], []]\nstart = 0\nend = 5\nassert f(graph, start, end) == g(graph, start, end)\n",
        "idx_generation": 431,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List, Tuple\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given an undirected graph represented as an adjacency matrix and two vertices (start and end), determine if there is a path between the two vertices.\n    Return True if there is a path, False otherwise.\n    \"\"\"\n    visited = set()\n    return dfs(graph, start, end, visited)\n\ndef dfs(graph: List[List[int]], curr: int, end: int, visited: set) -> bool:\n    \"\"\"Depth-first search helper function.\"\"\"\n    if curr == end:\n        return True\n    visited.add(curr)\n    for neighbor in range(len(graph[curr])):\n        if graph[curr][neighbor] == 1 and neighbor not in visited:\n            if dfs(graph, neighbor, end, visited):\n                return True\n    return False\n\ndef g(n=4):\n    \"\"\"Generate an undirected graph represented as an adjacency matrix and two random vertices.\"\"\"\n    graph = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            graph[i][j] = graph[j][i] = 1\n    return graph, 0, n-1\n\nassert f(*g())\n",
        "idx_generation": 297,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target sum, find the number of unique combinations of the integers that sum up to the target.\n\n    Example:\n    Input: nums = [2, 3, 6, 7], target = 7\n    Output: 2\n    Explanation: There are two unique combinations [2, 2, 3] and [7].\n\n    \"\"\"\n\n    def backtrack(comb: List[int], remaining: int, start: int) -> None:\n        if remaining == 0:\n            combinations.append(comb[:])\n            return\n        elif remaining < 0:\n            return\n\n        for i in range(start, len(nums)):\n            comb.append(nums[i])\n            backtrack(comb, remaining - nums[i], i)\n            comb.pop()\n\n    combinations = []\n    backtrack([], target, 0)\n\n    return len(combinations)\n\ndef g():\n    nums = [2, 3, 6, 7]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 447,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers nums, find the maximum product of any two distinct elements in the list.\"\"\"\n    n = len(nums)\n    max_product = float('-inf')\n\n    for i in range(n):\n        for j in range(i+1, n):\n            max_product = max(max_product, nums[i] * nums[j])\n    \n    return max_product\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers nums, find the two distinct elements that produce the maximum product.\"\"\"\n    n = len(nums)\n    max_product = float('-inf')\n    max_i = max_j = -1\n\n    for i in range(n):\n        for j in range(i+1, n):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n                max_i = i\n                max_j = j\n    \n    return [nums[max_i], nums[max_j]]\n\nassert f(g([1, 2, 3, 4, 5])) == 20\n",
        "idx_generation": 86,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the length of the longest increasing subsequence in the given list.\"\"\"\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n\n",
        "idx_generation": 243,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Check if the given strings are anagrams and if the lengths of the strings are equal.\"\"\"\n    is_anagram = sorted(s1) == sorted(s2)\n\n    lengths_equal = len(s1) == len(s2)\n\n    return is_anagram and lengths_equal\n\ndef g():\n    s1 = 'listen'\n    s2 = 'silent'\n    return s1, s2\n\nassert f(*g())\n\n",
        "idx_generation": 415,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, find if there exists a subset of the list that sums up to the target value.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(1, n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if nums[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n    return dp[n][target]\n\ndef g():\n    return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29], 42\n\nassert f(*g())\n",
        "idx_generation": 400,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, count the number of ways to climb to the top of a staircase.\n    You can climb 1 or 2 steps at a time. Return the total number of distinct ways to reach the top.\n    Example:\n    n = 3\n    There are three ways to climb to the top: [1, 1, 1], [1, 2], and [2, 1].\n    Therefore, the answer is 3.\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\ndef g():\n    return 3\n\nassert f(g()) == 3\n",
        "idx_generation": 141,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Find the maximum XOR value of any two numbers in the list\"\"\"\n    max_xor = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            xor = arr[i] ^ arr[j]\n            if xor > max_xor:\n                max_xor = xor\n    return max_xor\n\ndef g(arr: List[int]):\n    \"\"\"Return the pair of numbers with the maximum XOR value\"\"\"\n    max_xor = float('-inf')\n    max_pair = []\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            xor = arr[i] ^ arr[j]\n            if xor > max_xor:\n                max_xor = xor\n                max_pair = [arr[i], arr[j]]\n    return max_pair\n\n# Test the solution\narr = [1, 2, 3, 4, 5]\nassert f(g(arr)) == 7\n",
        "idx_generation": 367,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, return the nth Fibonacci number.\"\"\"\n    if n <= 1:\n        return n\n    else:\n        return f(n-1) + f(n-2)\n\ndef g():\n    n = 6\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 395,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid filled with 0s and 1s, determine if it is possible to reach the bottom-right corner (cell with value 0) from the top-left corner (cell with value 1).\n    You can only move to adjacent elements in the grid (up, down, left, or right). However, you can only move to a 0 element and not to a 1 element.\"\"\"\n    m, n = len(grid), len(grid[0])\n    visited = [[False] * n for _ in range(m)]\n    stack = [(0, 0)]\n    \n    while stack:\n        x, y = stack.pop()\n        if (x, y) == (m-1, n-1):\n            return True\n        visited[x][y] = True\n        \n        neighbors = [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]\n        for nx, ny in neighbors:\n            if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0:\n                stack.append((nx, ny))\n    \n    return False\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"Return the grid after flipping the cells\"\"\"\n    return grid\n\nassert f(g(grid=[[1, 0, 0], [1, 1, 0], [0, 0, 0]]))\n",
        "idx_generation": 434,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there is a path from the start node to the end node in a directed graph.\n    Return True if there is a path, and False otherwise.\"\"\"\n    \n    def dfs(graph: List[List[int]], node: int, visited: List[bool]) -> bool:\n        \"\"\"Depth-first search to find a path in the graph.\"\"\"\n        \n        if node == end:\n            return True\n        \n        visited[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(graph, neighbor, visited):\n                    return True\n        \n        return False\n    \n    visited = [False] * len(graph)\n    return dfs(graph, start, visited)\n\ndef g():\n    return [[1, 2], [2], [3, 4], [], [5], []]\n\nassert f(g(), 0, 5)\n",
        "idx_generation": 303,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of ways to climb n stairs, where at each step you can either climb 1 or 2 steps\"\"\"\n    if n <= 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\ndef g(n=5):\n    return n\nassert f(g()) == 8\n",
        "idx_generation": 453,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there are two numbers in the list that sum up to the target.\"\"\"\n    start = 0\n    end = len(arr) - 1\n\n    while start < end:\n        current_sum = arr[start] + arr[end]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            start += 1\n        else:\n            end -= 1\n\n    return False\n\ndef g():\n    arr = [1, 2, 4, 7, 11, 15]\n    target = 9\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 86,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Sort the given list of integers in ascending order using the merge sort algorithm.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left = f(left)\n    right = f(right)\n\n    return merge(left, right)\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    result = []\n    i = j = 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    while i < len(left):\n        result.append(left[i])\n        i += 1\n\n    while j < len(right):\n        result.append(right[j])\n        j += 1\n\n    return result\n\ndef g():\n    return [5, 2, 9, 1, 7, 3]\n\nassert f(g()) == [1, 2, 3, 5, 7, 9]\n",
        "idx_generation": 245,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(pattern: str, string: str) -> bool:\n    \"\"\"\n    Given a pattern and a string, determine if the string follows the given pattern.\n    The pattern consists of unique characters, and the string contains words separated by spaces.\n    Return True if the string follows the pattern, False otherwise.\n    \"\"\"\n    words = string.split()\n    if len(pattern) != len(words):\n        return False\n\n    pattern_to_word = {}\n    word_to_pattern = {}\n\n    for i in range(len(pattern)):\n        char = pattern[i]\n        word = words[i]\n\n        if char not in pattern_to_word and word not in word_to_pattern:\n            pattern_to_word[char] = word\n            word_to_pattern[word] = char\n        elif pattern_to_word.get(char) != word or word_to_pattern.get(word) != char:\n            return False\n\n    return True\n\ndef g():\n    pattern = \"abba\"\n    string = \"dog cat cat dog\"\n    return (pattern, string)\n\nassert f(*g())\n",
        "idx_generation": 418,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Given a list of integers, find a subset of the numbers that sum up to the target value.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    \n    for i in range(n + 1):\n        dp[i][0] = True\n    \n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if nums[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n    \n    return dp[n][target]\n\ndef g():\n    nums = [2, 4, 6, 8]\n    return nums\n\nassert f(g())\n",
        "idx_generation": 405,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence (LIS).\n    An increasing subsequence is defined as a subsequence where the elements are in increasing order,\n    but not necessarily contiguous.\n    \"\"\"\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp) >= 3\n\ndef g():\n    return [1, 3, 2, 4, 5, 8, 6]\n\nassert f(g())\n",
        "idx_generation": 143,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[int], k: int, g=[1, 3, 5, 7, 9]) -> bool:\n    \"\"\"Given a list of integers, check if there exists a subset of size k that XORs to a value in the given list g.\n    Return True if such subset exists, False otherwise.\n    \"\"\"\n    n = len(arr)\n    for i in range(1 << n):\n        subset = [arr[j] for j in range(n) if (i & (1 << j))]\n        if len(subset) == k and any(x ^ y in g for x in subset for y in subset):\n            return True\n    return False\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nassert f(g(), 3)\n",
        "idx_generation": 367,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given a positive integer n, determine if it can be expressed as the sum of distinct powers of 2.\n    Return True if it is possible, False otherwise.\"\"\"\n    def can_sum(n, memo={}):\n        if n in memo:\n            return memo[n]\n        if n == 0:\n            return True\n        if n < 0:\n            return False\n        for power in range(1, n+1):\n            if can_sum(n - 2**power):\n                memo[n] = True\n                return True\n        memo[n] = False\n        return False\n    return can_sum(n)\n\ndef g():\n    \"\"\"Generate a positive integer.\"\"\"\n    return 12\n\nassert f(g())\n",
        "idx_generation": 395,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of 0s and 1s, determine the length of the longest path of consecutive 1s.\"\"\"\n    m, n = len(grid), len(grid[0])\n    stack = [(i, j, 1) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    max_path = 0\n\n    while stack:\n        i, j, path_len = stack.pop()\n\n        neighbors = [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]\n        for x, y in neighbors:\n            if 0 <= x < m and 0 <= y < n and grid[x][y] == 1:\n                grid[x][y] = 0\n                stack.append((x, y, path_len + 1))\n                max_path = max(max_path, path_len + 1)\n\n    return max_path\n\ndef g():\n    return [[1, 1, 0, 0, 1],\n            [1, 0, 1, 1, 0],\n            [0, 1, 1, 0, 1],\n            [0, 0, 1, 1, 1],\n            [1, 1, 1, 0, 1]]\n\nassert f(g()) == 7\n",
        "idx_generation": 436,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(adjacency_matrix: List[List[int]], start_node: int, end_node: int) -> bool:\n    \"\"\"\n    Given an adjacency matrix representing a directed graph and two nodes: start_node and end_node,\n    determine if there exists a path from start_node to end_node in the graph.\n    \"\"\"\n    def dfs(current_node: int, visited: List[bool]) -> bool:\n        if current_node == end_node:\n            return True\n\n        visited[current_node] = True\n        for neighbor in range(len(adjacency_matrix)):\n            if adjacency_matrix[current_node][neighbor] == 1 and not visited[neighbor]:\n                if dfs(neighbor, visited):\n                    return True\n\n        return False\n\n    visited = [False] * len(adjacency_matrix)\n    return dfs(start_node, visited)\n\ndef g():\n    adjacency_matrix = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start_node = 0\n    end_node = 3\n    return adjacency_matrix, start_node, end_node\n\nassert f(*g())\n",
        "idx_generation": 304,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"Given an integer n, find the number of unique binary search trees that can be formed with nodes labeled from 1 to n.\"\"\"\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    \n    for i in range(2, n + 1):\n        for j in range(1, i + 1):\n            dp[i] += dp[j - 1] * dp[i - j]\n    \n    return dp[n]\n\ndef g(n=4):\n    \"\"\"Generate an integer n where the number of unique binary search trees that can be formed is maximized.\"\"\"\n    return n\n\nassert f(g()) == 14\n",
        "idx_generation": 463,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there are two numbers in the list that sum up to the target.\n    Return True if such pair exists, False otherwise.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        current_sum = arr[left] + arr[right]\n        \n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Generate a sorted list of integers and a target value.\"\"\"\n    return [1, 3, 5, 7, 9], 12\n\nassert f(*g()) == True\n",
        "idx_generation": 88,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list.\n    Implement a binary search algorithm to solve this problem.\n    If the target value does not exist in the list, return -1.\n    \"\"\"\n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1\n\ndef g():\n    return [1, 3, 5, 7, 9, 11, 13], 7\n\nassert f(*g()) == 3\n",
        "idx_generation": 245,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find two numbers in a given list that sum up to the target value.\n\n    Args:\n        nums (List[int]): The list of integers.\n        target (int): The target value.\n\n    Returns:\n        List[int]: The two numbers that sum up to the target value.\n\n    Example:\n        Input: nums = [2, 7, 11, 15], target = 9\n        Output: [2, 7]\n        Explanation: The numbers 2 and 7 sum up to the target value of 9.\n    \"\"\"\n    complement = {}\n    for num in nums:\n        if num in complement:\n            return [complement[num], num]\n        else:\n            complement[target - num] = num\n    return []\n\ndef g(nums: List[int], target: int) -> List[int]:\n    return f(nums, target)\n\nnums = [2, 7, 11, 15]\ntarget = 9\nassert f(nums, target) == g(nums, target)\n\n",
        "idx_generation": 419,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Given a list of integers, find a subset of the numbers that sum up to the target.\n    The solution is a list of indices representing the subset of numbers.\"\"\"\n    assert len(nums) > 0, \"List cannot be empty.\"\n    \n    n = len(nums)\n    \n    dp = [[False] * (target + 1) for _ in range(n+1)]\n    \n    for i in range(n+1):\n        dp[i][0] = True\n    \n    for i in range(1, n+1):\n        for j in range(1, target+1):\n            if nums[i-1] <= j:\n                dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i-1]]\n            else:\n                dp[i][j] = dp[i-1][j]\n    \n    return dp[n][target]\n\ndef g():\n    nums = [2, 4, 6, 8]\n    target = 10\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 408,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=0) -> bool:\n    \"\"\"Find if there exists a subset of nums that XORs to the target value.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if nums[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j ^ nums[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[n][target]\ndef g(target=0):\n    nums = [2, 4, 6, 8, 10]\n    return nums, target\nassert f(*g())\n",
        "idx_generation": 148,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum XOR value between any two elements in the list.\"\"\"\n    max_xor = 0\n    \n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n    \n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"Generate a list of integers.\"\"\"\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n",
        "idx_generation": 368,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Determine if there exists a path from the top-left corner to the bottom-right corner in the given grid,\n    where each step can only be taken down or to the right, and the sum of the numbers along the path is a prime number.\"\"\"\n    \n    def is_prime(n: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    def backtrack(grid: List[List[int]], row: int, col: int, path_sum: int) -> bool:\n        if row == len(grid) - 1 and col == len(grid[0]) - 1:\n            return is_prime(path_sum + grid[row][col])\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]):\n            return False\n        return (\n            backtrack(grid, row + 1, col, path_sum + grid[row][col])\n            or backtrack(grid, row, col + 1, path_sum + grid[row][col])\n        )\n    \n    return backtrack(grid, 0, 0, 0)\n\ndef g(grid: List[List[int]]):\n    return grid\n\nassert f(g([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n",
        "idx_generation": 397,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, k: int) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency matrix, two nodes, and an integer k,\n    determine if there exists a path from the start node to the end node with exactly k edges.\n    Each node is represented by an integer, and the adjacency matrix indicates the presence of an edge between two nodes.\n    Return True if a path exists, and False otherwise.\n    Sample Input:\n    graph = [[0, 1, 1, 0],\n             [0, 0, 1, 0],\n             [0, 0, 0, 1],\n             [0, 0, 0, 0]]\n    start = 0\n    end = 3\n    k = 2\n    Sample Output:\n    True\"\"\"\n    stack = [(start, 0)]\n    while stack:\n        node, edges = stack.pop()\n        if node == end and edges == k:\n            return True\n        if edges < k:\n            for neighbor in range(len(graph)):\n                if graph[node][neighbor] == 1:\n                    stack.append((neighbor, edges + 1))\n    return False\n\ndef g():\n    return [[0, 1, 1, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1],\n            [0, 0, 0, 0]]\n\nassert f(g(), start=0, end=3, k=2)\n",
        "idx_generation": 439,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"Given an undirected graph represented as an adjacency matrix, find the number of connected components.\n    Return the number of connected components.\n    \"\"\"\n    def dfs(node: int):\n        visited[node] = True\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                dfs(neighbor)\n\n    n = len(graph)\n    visited = [False] * n\n    count = 0\n    for node in range(n):\n        if not visited[node]:\n            count += 1\n            dfs(node)\n    return count\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate an adjacency matrix for an undirected graph.\"\"\"\n    return [[0, 1, 0, 1],\n            [1, 0, 1, 0],\n            [0, 1, 0, 1],\n            [1, 0, 1, 0]]\n\nassert f(g())\n",
        "idx_generation": 304,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if there exists a subset of the list that adds up to the target number.\"\"\"\n    def helper(nums, target, index, curr_sum):\n        if curr_sum == target:\n            return True\n        if index >= len(nums):\n            return False\n        include = helper(nums, target, index+1, curr_sum + nums[index])\n        exclude = helper(nums, target, index+1, curr_sum)\n        return include or exclude\n    \n    return helper(nums, target, 0, 0)\n\ndef g(nums=[1, 2, 3, 4, 5], target=9):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 467,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers arr, determine if there exists two distinct indices i and j\n    such that arr[i] + arr[j] equals the target sum.\n    Return True if such indices exist, False otherwise.\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    The indices i and j are 2 and 4 respectively, because arr[2] + arr[4] = 3 + 5 = 7.\n    Therefore, the answer is True.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5], 7\n\nassert f(*g()) == True\n",
        "idx_generation": 88,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers that add up to the target\"\"\"\n    left, right = 0, len(nums)-1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [2, 4, 6, 8, 10]\n\nassert f(g(), 12)\n",
        "idx_generation": 250,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with all the even numbers followed by all the odd numbers.\n    The even numbers should be sorted in ascending order, and the odd numbers should be sorted in descending order.\n    \"\"\"\n    even_nums = sorted([num for num in nums if num % 2 == 0])\n    odd_nums = sorted([num for num in nums if num % 2 != 0], reverse=True)\n    return even_nums + odd_nums\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"\n    Rearrange the given list such that all even numbers are followed by all odd numbers.\n    The even numbers should be sorted in ascending order, and the odd numbers should be sorted in descending order.\n    \"\"\"\n    even_nums = sorted([num for num in nums if num % 2 == 0])\n    odd_nums = sorted([num for num in nums if num % 2 != 0], reverse=True)\n    return even_nums + odd_nums\n\nassert f([1, 2, 3, 4, 5, 6, 7, 8, 9]) == g([1, 2, 3, 4, 5, 6, 7, 8, 9])\n",
        "idx_generation": 426,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers and a number 'k', find two distinct indices i and j,\n    such that arr[i] + arr[j] is divisible by k.\n    \"\"\"\n    remainders = [0] * k\n    for num in arr:\n        remainder = num % k\n        if remainders[(k - remainder) % k] > 0:\n            return True\n        remainders[remainder] += 1\n    return False\n\ndef g(arr=[4, 5, 7, 12, 15], k=6):\n    \"\"\"\n    Generate a list of integers and a number 'k'.\n    \"\"\"\n    return arr, k\n\nassert f(*g())\n",
        "idx_generation": 411,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the nth Fibonacci number.\"\"\"\n    if n <= 0:\n        return None\n    if n == 1 or n == 2:\n        return 1\n    fib = [0] * (n + 1)\n    fib[1] = 1\n    fib[2] = 1\n    for i in range(3, n + 1):\n        fib[i] = fib[i-1] + fib[i-2]\n    return fib[n]\n\ndef g():\n    return 8\n\nassert f(g()) == 21\n",
        "idx_generation": 149,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine if the given number is a power of two.\"\"\"\n    return n > 0 and (n & (n - 1)) == 0\n\ndef g():\n    return 16\n\nassert f(g()) == True\n",
        "idx_generation": 370,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Determine if there exists a subset in the given list where the sum of all elements is equal to the target\"\"\"\n    def subset_sum(nums, target, index, curr_sum):\n        if curr_sum == target:\n            return True\n        if index == len(nums):\n            return False\n        if curr_sum + nums[index] <= target:\n            if subset_sum(nums, target, index+1, curr_sum+nums[index]):\n                return True\n        return subset_sum(nums, target, index+1, curr_sum)\n    return subset_sum(nums, target, 0, 0)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Generate a list of random integers and a random target\"\"\"\n    import random\n    nums = [random.randint(1, 10) for _ in range(5)]\n    target = random.randint(5, 20)\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 402,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(adjacency_matrix: List[List[int]], start_node: int, end_node: int) -> bool:\n    \"\"\"Given an adjacency matrix representing a directed graph, determine if there is a path from start_node to end_node.\"\"\"\n    visited = [False] * len(adjacency_matrix)\n    stack = [start_node]\n    while stack:\n        current_node = stack.pop()\n        if current_node == end_node:\n            return True\n        if visited[current_node]:\n            continue\n        visited[current_node] = True\n        for neighbor, connected in enumerate(adjacency_matrix[current_node]):\n            if connected:\n                stack.append(neighbor)\n    return False\n\ndef g():\n    adjacency_matrix = [[0, 1, 1, 0],\n                        [0, 0, 1, 1],\n                        [0, 0, 0, 1],\n                        [0, 0, 0, 0]]\n    start_node = 0\n    end_node = 3\n    return adjacency_matrix, start_node, end_node\n\nassert f(*g())\n",
        "idx_generation": 440,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, g: List[List[int]]) -> bool:\n    \"\"\"Given a list of integers representing a graph, with each integer representing a node, check if it is possible to visit all nodes starting from node 1 and returning to node 1, while visiting each node exactly once, and traversing each edge of the graph exactly once.\n    Example:\n    n = 4\n    g = [[1, 2], [2, 3], [3, 4], [4, 1]]\n    Output: True\"\"\"\n    visited = [False] * (n + 1)\n\n    def dfs(node, count):\n        visited[node] = True\n        if count == n:  # All nodes visited\n            return True\n        for neighbor in g[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, count + 1):\n                    return True\n        visited[node] = False\n        return False\n\n    return dfs(1, 1)\n\ndef g():\n    n = 4\n    g = [[1, 2], [2, 3], [3, 4], [4, 1]]\n    return n, g\n\nassert f(*g())\n",
        "idx_generation": 306,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers 'nums' and a target integer 'target', find the number of unique combinations of 'nums' that add up to 'target'.\n    Return the count of unique combinations.\n    \"\"\"\n    dp = [0] * (target + 1)\n    dp[0] = 1\n    for num in nums:\n        for i in range(num, target + 1):\n            dp[i] += dp[i - num]\n    return dp[target]\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums' and a target integer 'target', return the list 'nums'.\n    \"\"\"\n    return nums\n\nassert f(nums=g([2, 3, 5], target=8), target=8) == 3\n",
        "idx_generation": 468,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Find if the target value exists in the sorted array using binary search.\"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\ndef g(nums=[1, 3, 5, 7, 9], target=5):\n    return nums, target\nassert f(*g())\n",
        "idx_generation": 90,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target number using binary search. If the target number is not in the list, return -1.\n    \"\"\"\n    low, high = 0, len(nums) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1\n\ndef g(nums=[1, 2, 3, 4, 5, 6, 7], target=5):\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    return nums, target\n\nassert f(*g()) == 4\n\n",
        "idx_generation": 261,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Find if the given string is a palindrome.\"\"\"\n    return s == s[::-1]\n\ndef g(s: str):\n    \"\"\"Reverse the given string.\"\"\"\n    return s[::-1]\n\nassert f(g(\"level\"))\n",
        "idx_generation": 429,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of positive integers and a target number,\n    determine if it is possible to select a subset of the numbers\n    such that their sum is equal to the target number.\n    Return True if such a subset exists, False otherwise.\n    \"\"\"\n    def subset_sum(nums: List[int], target: int, index: int) -> bool:\n        if target == 0:\n            return True\n        if index >= len(nums):\n            return False\n        if nums[index] > target:\n            return subset_sum(nums, target, index + 1)\n        return subset_sum(nums, target, index + 1) or subset_sum(nums, target - nums[index], index + 1)\n\n    return subset_sum(nums, target, 0)\n\ndef g():\n    nums = [1, 5, 3, 9, 2]\n    target = 7\n    return (nums, target)\n\nassert f(*g())\n",
        "idx_generation": 418,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the nth Fibonacci number using dynamic programming.\"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    \n    fib = [0] * (n+1)\n    fib[0] = 0\n    fib[1] = 1\n    \n    for i in range(2, n+1):\n        fib[i] = fib[i-1] + fib[i-2]\n    \n    return fib[n]\n\ndef g():\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 150,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a given number is a power of 2\"\"\"\n\n    def is_power_of_two(num):\n        return num != 0 and (num & (num - 1)) == 0\n\n    return is_power_of_two(n)\n\ndef g():\n    return 16\n\nassert f(g())\n",
        "idx_generation": 380,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if a given list of numbers can be partitioned into two subsets such that the sum of elements in both subsets is equal.\"\"\"\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n\n    target_sum = total_sum // 2\n\n    def subset_sum(nums: List[int], target: int, index: int) -> bool:\n        if target == 0:\n            return True\n        if index == 0:\n            return False\n\n        if nums[index - 1] <= target:\n            return subset_sum(nums, target - nums[index - 1], index - 1) or subset_sum(nums, target, index - 1)\n        else:\n            return subset_sum(nums, target, index - 1)\n\n    return subset_sum(nums, target_sum, len(nums))\n\ndef g(length: int = 10) -> List[int]:\n    \"\"\"Generate a list of random positive integers.\"\"\"\n    return random.choices(range(1, 10), k=length)\n\nassert f(g())\n",
        "idx_generation": 417,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(adj_list: dict, start_node=1, end_node=5) -> bool:\n    \"\"\"Find if there is a path from start_node to end_node in the given adjacency list\"\"\"\n    visited = set()\n    stack = [start_node]\n    while stack:\n        node = stack.pop()\n        if node == end_node:\n            return True\n        visited.add(node)\n        for neighbor in adj_list[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    return False\ndef g(start_node=1, end_node=5):\n    adj_list = {\n        1: [2, 3],\n        2: [4],\n        3: [4, 5],\n        4: [5],\n        5: []\n    }\n    return adj_list\nassert f(g())\n",
        "idx_generation": 451,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, path: List[int]) -> bool:\n    \"\"\"Given a directed graph, determine if there is a path from start to end.\n    Return True if a path exists, False otherwise.\n    Example:\n    graph = [[1, 2], [3], [4], [], []]\n    start = 0\n    end = 4\n    The path from node 0 to node 4 is 0 -> 2 -> 4.\n    Therefore, the answer is True.\n    \"\"\"\n    if start == end:\n        return True\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g():\n    return [[1, 2], [3], [4], [], []], 0, 4, []\n\nassert f(*g()) == True\n",
        "idx_generation": 309,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target sum k, determine if there exists a subset of the list\n    that adds up to the target sum. Return True if such a subset exists, False otherwise.\n    \"\"\"\n    def subsetSum(nums: List[int], k: int, index: int, currSum: int) -> bool:\n        if currSum == k:\n            return True\n        if index >= len(nums):\n            return False\n        \n        # Include the current number in the subset\n        if subsetSum(nums, k, index + 1, currSum + nums[index]):\n            return True\n        \n        # Exclude the current number from the subset\n        if subsetSum(nums, k, index + 1, currSum):\n            return True\n        \n        return False\n    \n    return subsetSum(nums, k, 0, 0)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target sum k.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    k = 9\n    return nums, k\n\nassert f(*g()) == True\n",
        "idx_generation": 474,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers 'arr' in ascending order, and a target value 'target',\n    return True if the target value exists in the list, and False otherwise.\n    Use binary search to solve the problem.\"\"\"\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef g():\n    return [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n\nassert f(g(), 7)\n",
        "idx_generation": 90,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if the list contains a pair of numbers whose sum is equal to a target value.\n    Return True if such a pair exists, otherwise return False.\n    \"\"\"\n    n = len(arr)\n    target = 10\n    \n    arr.sort()  # Sort the list in ascending order\n    \n    left = 0\n    right = n - 1\n    \n    while left < right:\n        current_sum = arr[left] + arr[right]\n        \n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g())\n",
        "idx_generation": 265,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"Check if t is an anagram of s.\"\"\"\n    return sorted(s) == sorted(t)\n\ndef g():\n    return \"listen\", \"silent\"\n\nassert f(*g())\n",
        "idx_generation": 450,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers 'nums' and a target integer 'target',\n    determine if there exists a combination of numbers in 'nums' that add up to 'target'.\n    Return True if such a combination exists, False otherwise.\"\"\"\n    def backtrack(index, current_sum):\n        if current_sum == target:\n            return True\n        if current_sum > target or index >= len(nums):\n            return False\n        return backtrack(index + 1, current_sum + nums[index]) or backtrack(index + 1, current_sum)\n\n    return backtrack(0, 0)\n\ndef g(nums=[2, 4, 6, 8], target=14):\n    \"\"\"Generate a list of integers and a target value.\"\"\"\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 418,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Find if there exists a subset of nums that sums up to the target value.\"\"\"\n    def dfs(i, cur_sum):\n        if cur_sum == target:\n            return True\n        if i == len(nums) or cur_sum > target:\n            return False\n        return dfs(i + 1, cur_sum + nums[i]) or dfs(i + 1, cur_sum)\n    \n    return dfs(0, 0)\n\ndef g(nums=[1, 2, 3, 4, 5], target=9):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 150,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given a positive integer n, determine if it is a power of two.\n    \"\"\"\n    return n > 0 and (n & (n - 1)) == 0\n\ndef g(n=16):\n    return n\n\nassert f(g())\n",
        "idx_generation": 381,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the nth number in the Fibonacci sequence.\n    \"\"\"\n    fib = [0, 1]\n    for i in range(2, n+1):\n        fib.append(fib[i-1] + fib[i-2])\n    return fib[n]\n\ndef g():\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 434,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, check if there is a path from a given start node to a given end node.\n    Return True if a path exists, False otherwise.\n    \"\"\"\n\n    visited = [False] * len(graph)\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n\n        if node == end:\n            return True\n\n        if not visited[node]:\n            visited[node] = True\n            neighbors = [i for i, val in enumerate(graph[node]) if val == 1]\n            stack.extend(neighbors)\n\n    return False\n\ndef g():\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n\n    return graph, start, end\n\nassert f(*g()) == True\n\n",
        "idx_generation": 479,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of non-negative integers, find the minimum distance from the top-left corner to the bottom-right corner. You can only move down or right.\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(m):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j])\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j])\n\n    return dp[m-1][n-1]\n\ndef g():\n    return [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\nassert f(g()) == 7\n",
        "idx_generation": 316,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target_length=0) -> bool:\n    \"\"\"Find the number of subsequences in string s that have a length equal to target_length.\"\"\"\n    count = 0\n    def backtrack(start, length):\n        nonlocal count\n        if length == target_length:\n            count += 1\n            return\n        for i in range(start, len(s)):\n            backtrack(i+1, length+1)\n    backtrack(0, 0)\n    return count\ndef g(target_length=0):\n    s = \"abcde\"\n    return f(s, target_length)\nassert f(g())\n",
        "idx_generation": 491,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there are two numbers in the given array whose sum equals the target.\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    \"\"\"Find an array and a target value such that the function f returns True.\"\"\"\n    return [1, 4, 6, 8, 10], 14\n\nassert f(*g())\n",
        "idx_generation": 91,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers, determine if there are two numbers in the array that\n    add up to a given target.\n    \n    Return True if such a pair exists, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        sum = nums[left] + nums[right]\n        \n        if sum == target:\n            return True\n        elif sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6, 7]\n    target = 9\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 268,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string, determine if it can be rearranged into a palindrome.\n    A palindrome is a word that is the same forwards and backwards.\n    \"\"\"\n    char_counts = {}\n    for char in s:\n        if char in char_counts:\n            char_counts[char] += 1\n        else:\n            char_counts[char] = 1\n    odd_count = 0\n    for count in char_counts.values():\n        if count % 2 == 1:\n            odd_count += 1\n        if odd_count > 1:\n            return False\n    return True\n\ndef g(s='aabcc'):\n    return s\n\nassert f(g())\n",
        "idx_generation": 459,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it can be expressed as the sum of distinct Fibonacci numbers.\n    Return True if it is possible, False otherwise.\n\n    Example:\n    Input: 5\n    Output: True\n    Explanation: 5 can be expressed as the sum of distinct Fibonacci numbers: 1 + 4 = 5.\n    \"\"\"\n\n    def is_sum_of_distinct_fibonacci(n: int, fib_numbers: List[int]) -> bool:\n        if n == 0:\n            return True\n        if n < 0 or len(fib_numbers) <= 1:\n            return False\n        \n        current_fib = fib_numbers[-1]\n        remaining_fib_numbers = fib_numbers[:-1]\n\n        return is_sum_of_distinct_fibonacci(n, remaining_fib_numbers) or is_sum_of_distinct_fibonacci(n - current_fib, remaining_fib_numbers)\n\n    fib_numbers = [1, 1]\n    while fib_numbers[-1] < n:\n        fib_numbers.append(fib_numbers[-1] + fib_numbers[-2])\n    \n    return is_sum_of_distinct_fibonacci(n, fib_numbers)\n\n\ndef g():\n    return 5\n\nassert f(g())\n",
        "idx_generation": 421,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of 0s and 1s, determine if there is a path from the top-left corner to the bottom-right corner,\n    only moving down or right, by flipping at most k 0s to 1s.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    def dfs(i: int, j: int, flips: int) -> bool:\n        if i == rows - 1 and j == cols - 1:\n            return True\n        \n        if i < rows - 1 and (grid[i+1][j] == 1 or flips > 0) and dfs(i+1, j, flips):\n            return True\n        \n        if j < cols - 1 and (grid[i][j+1] == 1 or flips > 0) and dfs(i, j+1, flips):\n            return True\n        \n        if grid[i][j] == 0 and flips > 0 and (i < rows - 1 or j < cols - 1):\n            return dfs(i, j, flips-1)\n        \n        return False\n    \n    return dfs(0, 0, 1)\n\ndef g(grid=[[1, 1, 0, 0],\n            [1, 0, 0, 1],\n            [1, 1, 0, 1],\n            [1, 1, 1, 1]]):\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 154,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string is a palindrome\"\"\"\n    n = len(s)\n    for i in range(n // 2):\n        if s[i] != s[n - i - 1]:\n            return False\n    return True\n\ndef g():\n    return \"racecar\"\n\nassert f(g())\n",
        "idx_generation": 12,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Check if the kth bit of n is set\"\"\"\n    return (n & (1 << k)) != 0\n\ndef g(n=10, k=1):\n    return n, k\n\nassert f(*g())\n",
        "idx_generation": 384,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Find if there exists a subset of nums that adds up to the target value.\"\"\"\n    def subset_sum(nums, n, target):\n        if target == 0:\n            return True\n        if n == 0 and target != 0:\n            return False\n        if nums[n-1] > target:\n            return subset_sum(nums, n-1, target)\n        return subset_sum(nums, n-1, target) or subset_sum(nums, n-1, target-nums[n-1])\n    return subset_sum(nums, len(nums), target)\n\ndef g(nums=[2, 4, 6, 8], target=10):\n    return nums\n\nassert f(g(), 10)\n",
        "idx_generation": 448,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency matrix, determine if there exists a path from the start node to the end node.\"\"\"\n    stack = [start]\n    visited = set()\n\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        visited.add(node)\n\n        neighbors = [i for i, connected in enumerate(graph[node]) if connected]\n        for neighbor in neighbors:\n            if neighbor not in visited:\n                stack.append(neighbor)\n\n    return False\n\ndef g():\n    graph = [[0, 1, 1, 0],\n             [0, 0, 1, 1],\n             [0, 0, 0, 1],\n             [0, 0, 0, 0]]\n    start = 0\n    end = 3\n    return graph, start, end\n\nassert f(*g())\n",
        "idx_generation": 493,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"Given an adjacency matrix representation of a graph, determine if there is a cycle in the graph.\"\"\"\n    visited = [0] * len(graph)\n    def dfs(graph: List[List[int]], vertex: int, visited: List[int]) -> bool:\n        visited[vertex] = 1\n        for neighbor in range(len(graph)):\n            if graph[vertex][neighbor] == 1:\n                if visited[neighbor] == 0:\n                    if dfs(graph, neighbor, visited):\n                        return True\n                elif visited[neighbor] == 1:\n                    return True\n        visited[vertex] = 2\n        return False\n\n    for i in range(len(graph)):\n        if visited[i] == 0:\n            if dfs(graph, i, visited):\n                return True\n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a graph represented by an adjacency matrix.\"\"\"\n    graph = [[0, 1, 0, 0, 0],\n             [0, 0, 1, 0, 0],\n             [0, 0, 0, 1, 0],\n             [0, 0, 0, 0, 1],\n             [1, 0, 0, 0, 0]]\n    return graph\n\nassert f(g())\n",
        "idx_generation": 331,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of ways to climb n stairs, where each step can be taken as 1 or 2 at a time.\"\"\"\n    if n <= 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 497,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there exist two integers in the list whose sum is equal to the target value.\n    Return True if such pair exists, False otherwise.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g() -> (List[int], int):\n    \"\"\"Generate a sorted list of integers and a target value.\"\"\"\n    return [-2, 1, 3, 5, 7, 9], 10\n\nassert f(*g()) == True\n",
        "idx_generation": 92,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, find the longest increasing subsequence in the list.\"\"\"\n    n = len(arr)\n    if n == 0:\n        return []\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    max_length = max(dp)\n    sequence = []\n    for i in range(n - 1, -1, -1):\n        if dp[i] == max_length:\n            sequence.append(arr[i])\n            max_length -= 1\n    return sequence[::-1]\n\ndef g():\n    return [1, 3, 2, 6, 4, 9, 5, 8, 7]\n\nassert f(g()) == [1, 2, 4, 5, 7]",
        "idx_generation": 280,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Check if the two given strings are anagrams of each other.\n    An anagram is a word or phrase formed by rearranging the letters of another word or phrase.\n    Return True if s1 and s2 are anagrams, False otherwise.\n    \"\"\"\n\n    # Remove whitespace and convert to lowercase for case-insensitive comparison\n    s1 = s1.replace(\" \", \"\").lower()\n    s2 = s2.replace(\" \", \"\").lower()\n\n    # Sort the characters in the strings\n    sorted_s1 = sorted(s1)\n    sorted_s2 = sorted(s2)\n\n    return sorted_s1 == sorted_s2\n\ndef g():\n    s1 = \"listen\"\n    s2 = \"silent\"\n    return s1, s2\n\nassert f(*g())\n",
        "idx_generation": 467,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a subset of the list that sums up to a target value.\n    Return True if such a subset exists, and False otherwise.\"\"\"\n    target = sum(nums)\n    if target % 2 != 0:\n        return False\n    target //= 2\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if nums[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[n][target]\n\ndef g(nums: List[int]):\n    return nums\n\nassert f(g([1, 5, 11, 5]))\n\n",
        "idx_generation": 432,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if there exists a subset of the list that sums up to the target value.\n    Return True if such subset exists, False otherwise.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    \n    for i in range(n + 1):\n        dp[i][0] = True\n    \n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j < nums[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n    \n    return dp[n][target]\n\ndef g():\n    return [2, 4, 6, 8, 10], 14\n    \nassert f(*g())\n",
        "idx_generation": 155,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"Count the number of vowels in a string\"\"\"\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = 0\n    for char in s:\n        if char.lower() in vowels:\n            count += 1\n    return count\ndef g():\n    return \"python programming\"\nassert f(g()) == 4\n",
        "idx_generation": 13,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num1: int, num2: int) -> int:\n    \"\"\"\n    Given two integers, return their sum without using the '+' operator.\n    \"\"\"\n    while num2 != 0:\n        carry = num1 & num2\n        num1 = num1 ^ num2\n        num2 = carry << 1\n    return num1\n\ndef g(num1=5, num2=3):\n    return num1, num2\n\nassert f(*g()) == 8\n",
        "idx_generation": 390,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n    \"\"\"\n    if n <= 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\ndef g(n: int = 5) -> int:\n    \"\"\"\n    Return the number of ways to climb to the top of a staircase with n steps.\n    \"\"\"\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 465,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a directed graph as an adjacency list 'graph', a starting node 'start', and an ending node 'end', determine\n    whether there exists a path from 'start' to 'end' in the graph. Return True if a path exists, False otherwise.\"\"\"\n    def dfs(graph, start, end, visited):\n        if start == end:\n            return True\n        visited[start] = True\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                if dfs(graph, neighbor, end, visited):\n                    return True\n        return False\n    \n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n    return dfs(graph, start, end, visited)\n\ndef g(graph=[[1, 2], [2, 3], [3], []], start=0, end=3):\n    return graph\n\nassert f(g(), start=0, end=3)\n",
        "idx_generation": 338,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers and a target value, return the index of the target if it exists in the list, otherwise return -1.\n    The list is assumed to be sorted in ascending order.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g() -> (List[int], int):\n    \"\"\"Generate a sorted list of integers and a target value.\"\"\"\n    return [2, 4, 6, 8, 10, 12, 14, 16, 18, 20], 12\n\nassert f(*g()) == 5\n",
        "idx_generation": 92,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Find the index of the first occurrence of the target value in the given sorted list 'nums'.\n    If the target value is not found, return -1.\n    Example:\n    nums = [1, 2, 2, 3, 4, 5]\n    target = 2\n    Output: 1 (because nums[1] is the first occurrence of 2)\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            if mid > 0 and nums[mid - 1] == target:\n                right = mid - 1\n            else:\n                return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g(nums: List[int]) -> int:\n    \"\"\"Find the target value for which the first occurrence index needs to be found in the sorted list 'nums'.\n    Return the target value.\n    Example:\n    nums = [1, 2, 2, 3, 4, 5]\n    Output: 2 (because nums[1] is the first occurrence of 2)\n    \"\"\"\n    return nums[1]\n\nassert f(nums=[1, 2, 2, 3, 4, 5], target=g(nums=[1, 2, 2, 3, 4, 5]))\n",
        "idx_generation": 281,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], target: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a target word, find all the words that can be formed by rearranging the letters of the target word.\n    Return a list of words that can be formed.\n    Example:\n    words = [\"cat\", \"tac\", \"act\", \"dog\", \"god\"]\n    target = \"act\"\n    The words that can be formed by rearranging the letters of \"act\" are \"cat\", \"tac\", and \"act\".\n    Therefore, the answer is [\"cat\", \"tac\", \"act\"].\n    \"\"\"\n    sorted_target = ''.join(sorted(target))\n    result = []\n    for word in words:\n        if ''.join(sorted(word)) == sorted_target:\n            result.append(word)\n    return result\n\ndef g():\n    return [\"cat\", \"tac\", \"act\", \"dog\", \"god\"], \"act\"\n\nassert f(*g()) == [\"cat\", \"tac\", \"act\"]\n",
        "idx_generation": 470,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there exists a subarray that sums up to the target.\n    Return True if such subarray exists, otherwise return False.\n    \"\"\"\n    n = len(nums)\n    prefix_sum = 0\n    prefix_sums = set()\n    \n    for num in nums:\n        prefix_sum += num\n        if prefix_sum - target in prefix_sums:\n            return True\n        prefix_sums.add(prefix_sum)\n    \n    return False\n\ndef g():\n    return [3, 4, 7, 2, -3, 1, 4, 2], 7\n\nassert f(*g()) == True\n",
        "idx_generation": 444,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Find the maximum sum of a subarray in the given array.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g():\n    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return arr\n\nassert f(g()) == 6\n",
        "idx_generation": 156,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string s, determine if it is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\nSample input:\n\"racecar\"\nSample output:\nTrue\"\"\"\n    return s == s[::-1]\ndef g():\n    return \"racecar\"\nassert f(g())\n",
        "idx_generation": 13,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a given number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & (n - 1) == 0\n\ndef g():\n    return 16\n\nassert f(g()) == True\n",
        "idx_generation": 399,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine if n is a perfect square and the square root of n is a prime number.\n    Return True if the conditions are satisfied, and False otherwise.\"\"\"\n    \n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    return is_prime(n ** 0.5) and int(n ** 0.5) ** 2 == n\n\ndef g():\n    return 49\n\nassert f(g())\n",
        "idx_generation": 13,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, return the nth Fibonacci number. The Fibonacci sequence starts with 0 and 1,\n    and each subsequent number is the sum of the two preceding ones.\"\"\"\n    if n <= 1:\n        return n\n    fib = [0] * (n + 1)\n    fib[1] = 1\n    for i in range(2, n + 1):\n        fib[i] = fib[i - 1] + fib[i - 2]\n    return fib[n]\n\ndef g() -> int:\n    \"\"\"Generate a positive integer.\"\"\"\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 468,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, determine if the graph contains a cycle.\n    \"\"\"\n    def is_cyclic_util(graph, v, visited, parent):\n        visited[v] = True\n        for i in graph[v]:\n            if visited[i] == False:\n                if is_cyclic_util(graph, i, visited, v):\n                    return True\n            elif parent != i:\n                return True\n        return False\n\n    visited = [False] * len(graph)\n    for i in range(len(graph)):\n        if visited[i] == False:\n            if is_cyclic_util(graph, i, visited, -1) == True:\n                return True\n    return False\n\ndef g(graph=[[1, 2], [0, 2], [0, 1]]):\n    \"\"\"\n    Generate an undirected graph represented as an adjacency list where the graph contains a cycle.\n    \"\"\"\n    return graph\n\nassert f(g()) == True\n\n",
        "idx_generation": 345,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers in the list that add up to the target value\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return ([-2, 1, 3, 5, 6, 8, 10], 7)  # Return a sorted list of integers and a target sum\n\nassert f(*g()) == True\n",
        "idx_generation": 94,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(numbers: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, find if there are two numbers that sum up to the target.\n    Return True if such pair exists, and False otherwise.\"\"\"\n    \n    def binary_search(numbers, target, start, end):\n        if start > end:\n            return False\n        \n        mid = (start + end) // 2\n        if numbers[mid] == target:\n            return True\n        elif numbers[mid] < target:\n            return binary_search(numbers, target, mid+1, end)\n        else:\n            return binary_search(numbers, target, start, mid-1)\n    \n    for i in range(len(numbers)):\n        complement = target - numbers[i]\n        if binary_search(numbers, complement, i+1, len(numbers)-1):\n            return True\n    \n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9], 10\n\nassert f(*g())\n",
        "idx_generation": 287,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Given a string s, reverse the order of the words in the string while maintaining\n    the order of the characters within each word.\n    Return the reversed string.\n    Example:\n    s = \"Hello World\"\n    The reversed string is \"World Hello\".\n    Therefore, the answer is \"World Hello\".\n    \"\"\"\n    words = s.split()\n    reverse_words = words[::-1]\n    return ' '.join(reverse_words)\n\ndef g():\n    return \"Hello World\"\n\nassert f(g()) == \"World Hello\"\n",
        "idx_generation": 488,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"Find the nth Fibonacci number.\n    The Fibonacci sequence is defined as follows:\n    F(0) = 0, F(1) = 1, and F(n) = F(n-1) + F(n-2) for n > 1.\"\"\"\n    if n <= 1:\n        return n\n    \n    fib = [0, 1]\n    \n    for i in range(2, n+1):\n        fib.append(fib[i-1] + fib[i-2])\n    \n    return fib[n]\n\ndef g(n: int):\n    return n\n\nassert f(g(6)) == 8\n",
        "idx_generation": 454,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the nth Fibonacci number.\"\"\"\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    return f(n-1) + f(n-2)\n\ndef g(n: int) -> int:\n    return f(n)\n\nn = 6\nassert f(n) == g(n)\n",
        "idx_generation": 159,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a given string is a palindrome.\"\"\"\n    return s == s[::-1]\n\ndef g():\n    return \"racecar\"\n\nassert f(g())\n",
        "idx_generation": 16,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of bits that are set to 1 in its binary representation.\n    \"\"\"\n    count = 0\n    while n > 0:\n        if n & 1 == 1:\n            count += 1\n        n >>= 1\n    return count\n\ndef g():\n    return 10\n\nassert f(g()) == 2\n",
        "idx_generation": 403,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int, m: int) -> bool:\n    \"\"\"Check if a string can be formed by repeating a given pattern and if a given number is a prime number.\"\"\"\n    return s in (s * m) and all(n % i != 0 for i in range(2, int(n**0.5)+1))\n\ndef g(s='abcabcabc', n=17, m=3):\n    return s, n, m\n\nassert f(*g())\n",
        "idx_generation": 30,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Given a matrix of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = matrix[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    return dp[m-1][n-1]\n\ndef g():\n    matrix = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    return matrix\n\nassert f(g()) == 12\n\n",
        "idx_generation": 468,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency matrix, determine if it contains a cycle.\"\"\"\n    visited = [False] * len(graph)\n    rec_stack = [False] * len(graph)\n    for node in range(len(graph)):\n        if not visited[node]:\n            if is_cyclic(graph, node, visited, rec_stack):\n                return True\n    return False\n\ndef is_cyclic(graph, node, visited, rec_stack):\n    visited[node] = True\n    rec_stack[node] = True\n    for neighbor in graph[node]:\n        if not visited[neighbor]:\n            if is_cyclic(graph, neighbor, visited, rec_stack):\n                return True\n        elif rec_stack[neighbor]:\n            return True\n    rec_stack[node] = False\n    return False\n\ndef g():\n    return [[0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1],\n            [1, 0, 0, 0]]\n\nassert f(g()) == True\n",
        "idx_generation": 354,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers nums, and a target number, determine if there are two numbers in the list\n    that sum up to the target. Return True if such pair exists, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 94,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> int:\n    \"\"\"Given two integers n and m, find the sum of all multiples of n and m below 1000.\"\"\"\n    multiples_sum = 0\n    for i in range(1, 1000):\n        if i % n == 0 or i % m == 0:\n            multiples_sum += i\n    return multiples_sum\n\ndef g():\n    return 3, 5\n\nassert f(*g()) == 233168\n",
        "idx_generation": 291,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, nums: List[int]) -> bool:\n    \"\"\"Check if there exists a subset of nums with length n, such that the sum of its elements is divisible by m.\"\"\"\n    def subset_sum(nums, target):\n        dp = [False] * (target + 1)\n        dp[0] = True\n\n        for num in nums:\n            for i in range(target, num - 1, -1):\n                dp[i] = dp[i] or dp[i - num]\n\n        return dp[target]\n\n    return subset_sum(nums, sum(nums) // m)\n\ndef g():\n    n = 3\n    m = 5\n    nums = [2, 4, 6, 8, 10]\n    return n, m, nums\n\nassert f(*g())\n",
        "idx_generation": 455,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, find the minimum cost to reach the bottom-right cell from the top-left cell.\n    Each cell has a cost associated with it, and you can only move right or down.\n    Return the minimum cost.\"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    # Fill in the first row\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    # Fill in the first column\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    # Fill in the rest of the grid\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[m - 1][n - 1]\n\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 7\n\n",
        "idx_generation": 159,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target='python') -> bool:\n    \"\"\"Check if the string s contains the target string 'python' in a specific order\"\"\"\n    stack = []\n    for char in s:\n        if char == target[len(stack)]:\n            stack.append(char)\n            if len(stack) == len(target):\n                return True\n    return False\n\ndef g(target='python'):\n    return target\n\nassert f(g())\n",
        "idx_generation": 22,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum xor value between any two elements in the list.\n    Return the maximum xor value.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        xor_set = set()\n        for num in nums:\n            xor_set.add(num & mask)\n        temp = max_xor | (1 << i)\n        for xor in xor_set:\n            if (temp ^ xor) in xor_set:\n                max_xor = temp\n                break\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a random list of positive integers.\n    \"\"\"\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n",
        "idx_generation": 419,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine if a number is a prime number.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g(n: int) -> int:\n    return n\n\nassert f(g(17))\n",
        "idx_generation": 33,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find the number of ways to climb n stairs, where you can take either 1 or 2 steps at a time\"\"\"\n    if n <= 1:\n        return 1\n    dp = [0] * (n+1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n+1):\n        dp[i] = dp[i-1] + dp[i-2]\n    return dp[n]\ndef g():\n    return 4\nassert f(g()) == 5\n",
        "idx_generation": 473,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if a given list of numbers is a binary search tree (BST).\"\"\"\n    def is_bst(node, min_val, max_val):\n        if node is None:\n            return True\n        if node.val <= min_val or node.val >= max_val:\n            return False\n        return is_bst(node.left, min_val, node.val) and is_bst(node.right, node.val, max_val)\n    \n    class TreeNode:\n        def __init__(self, val=0, left=None, right=None):\n            self.val = val\n            self.left = left\n            self.right = right\n    \n    # Construct the tree from the given list of numbers\n    root = TreeNode(nums[0])\n    for num in nums[1:]:\n        curr = root\n        while curr:\n            if num < curr.val:\n                if curr.left:\n                    curr = curr.left\n                else:\n                    curr.left = TreeNode(num)\n                    break\n            else:\n                if curr.right:\n                    curr = curr.right\n                else:\n                    curr.right = TreeNode(num)\n                    break\n    \n    # Check if the constructed tree is a BST\n    return is_bst(root, float('-inf'), float('inf'))\n\ndef g():\n    return [4, 2, 6, 1, 3, 5, 7]\n\nassert f(g())\n",
        "idx_generation": 357,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\n    Return True if such a pair exists, and False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5, 6, 7], target=9):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 98,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], x: int) -> bool:\n    \"\"\"Given a sorted list of integers 'arr' and a target integer 'x', \n    determine if there exist two elements in the list whose sum is equal to 'x'.\n    Return True if such elements exist, otherwise return False.\n    \n    Sample Input:\n    arr = [1, 3, 5, 7, 9]\n    x = 12\n    \n    Sample Output:\n    True\n    \n    Explanation:\n    The sum of 3 and 9 is equal to 12, so the function should return True.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        if arr[left] + arr[right] == x:\n            return True\n        elif arr[left] + arr[right] < x:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(arr: List[int], x: int):\n    \"\"\"Find two elements in the given sorted list 'arr' whose sum is equal to 'x'.\n    Return the two elements as a list.\n    \n    Sample Input:\n    arr = [1, 3, 5, 7, 9]\n    x = 12\n    \n    Sample Output:\n    [3, 9]\n    \n    Explanation:\n    The sum of 3 and 9 is equal to 12, so the function should return [3, 9].\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        if arr[left] + arr[right] == x:\n            return [arr[left], arr[right]]\n        elif arr[left] + arr[right] < x:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\nassert f(g([1, 3, 5, 7, 9], 12), 12)\n",
        "idx_generation": 294,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, find the longest increasing subsequence.\"\"\"\n    n = len(nums)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    max_length = max(dp)\n    max_subsequence = []\n    current_length = max_length\n    \n    for i in range(n-1, -1, -1):\n        if dp[i] == current_length:\n            max_subsequence.append(nums[i])\n            current_length -= 1\n    \n    max_subsequence.reverse()\n    return max_subsequence\n\ndef g():\n    return [3, 4, -1, 0, 6, 2, 3]\n\nassert f(g()) == [-1, 0, 2, 3]\n",
        "idx_generation": 470,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Determine if there exists a subarray of nums that sums up to the target value.\"\"\"\n    n = len(nums)\n    prefix_sums = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sums[i] = prefix_sums[i - 1] + nums[i - 1]\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if prefix_sums[j] - prefix_sums[i] == target:\n                return True\n    return False\n\ndef g():\n    nums = [2, 4, -2, 1, -3, 5, -6, 3]\n    target = 4\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 0,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer 'n', return the nth Fibonacci number.\n    \"\"\"\n\n    # Base cases\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n\n    # Dynamic programming approach\n    fib = [0] * (n + 1)\n    fib[1] = 1\n\n    for i in range(2, n + 1):\n        fib[i] = fib[i - 1] + fib[i - 2]\n\n    return fib[n]\n\n\ndef g(n: int = 6):\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 163,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target='abc') -> bool:\n    \"\"\"Check if the given string contains all the characters in the target string in the same order.\"\"\"\n    t_index = 0\n    for char in s:\n        if char == target[t_index]:\n            t_index += 1\n            if t_index == len(target):\n                return True\n    return False\ndef g(target='abc'):\n    return target\nassert f(g())\n",
        "idx_generation": 25,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if there is a pair of numbers in the given list whose XOR value is a power of 2.\"\"\"\n    xor_values = set()\n    for num in arr:\n        for xor_val in xor_values:\n            if (num ^ xor_val) & ((num ^ xor_val) - 1) == 0:\n                return True\n        xor_values.add(num)\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g())\n",
        "idx_generation": 423,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, x: int) -> bool:\n    \"\"\"Check if the sum of first n natural numbers is divisible by x.\"\"\"\n    return sum(range(n+1)) % x == 0\n\ndef g(n: int, x: int):\n    return n\n\nassert f(g(10, 3), g(5, 2))\n",
        "idx_generation": 50,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a 2D grid filled with 0s and 1s, determine the size of the largest island (a group of connected 1s).\n    Sample input:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    Sample output:\n    4\n    \"\"\"\n    if not grid:\n        return 0\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    max_size = 0\n\n    def dfs(row, col):\n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] == 0:\n            return 0\n        \n        grid[row][col] = 0\n        size = 1\n        size += dfs(row-1, col)\n        size += dfs(row+1, col)\n        size += dfs(row, col-1)\n        size += dfs(row, col+1)\n        \n        return size\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                max_size = max(max_size, dfs(i, j))\n    \n    return max_size\n\ndef g():\n    return [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n\nassert f(g()) == 4\n",
        "idx_generation": 358,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there are two numbers in the list that sum up to the target.\n    Return True if such numbers exist, otherwise return False.\n    \n    Sample input:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    \n    Sample output:\n    True\n    \n    Explanation:\n    The numbers 2 and 5 sum up to the target value 7.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n            \n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5], 7\n\nassert f(*g())\n",
        "idx_generation": 99,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence.\n    Sample input:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Sample output:\n    4\"\"\"\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 296,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the nth Fibonacci number\"\"\"\n    if n <= 1:\n        return n\n    fib = [0, 1]\n    for i in range(2, n+1):\n        fib.append(fib[i-1] + fib[i-2])\n    return fib[n]\n\ndef g(n=6):\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 472,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given a positive integer 'n', determine the number of unique binary search trees that can be formed\n    using the numbers from 1 to n as values.\"\"\"\n    if n == 0 or n == 1:\n        return 1\n    dp = [0] * (n+1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n+1):\n        for j in range(1, i+1):\n            dp[i] += dp[j-1] * dp[i-j]\n    return dp[n]\n\ndef g():\n    return 3\n\nassert f(g()) == 5\n",
        "idx_generation": 2,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of non-negative integers, find the maximum sum of a subsequence with the constraint that no two numbers in the sequence should be adjacent.\"\"\"\n    if not nums:\n        return 0\n    \n    n = len(nums)\n    if n == 1:\n        return nums[0]\n    \n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    \n    for i in range(2, n):\n        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n    \n    return dp[n - 1]\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"Return the list of non-negative integers\"\"\"\n    return nums\n\nassert f(g([1, 2, 3, 1])) == 4\n",
        "idx_generation": 164,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"Check if a given string is a palindrome and if a given number is a perfect power.\"\"\"\n    return s == s[::-1] and any(n**(1/i) % 1 == 0 for i in range(2, int(math.log2(n))+1))\n\ndef g(s='radar', n=16):\n    return s, n\n\nassert f(*g())\n",
        "idx_generation": 30,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a given number is a power of 2.\"\"\"\n    return n != 0 and (n & (n - 1)) == 0\n\ndef g():\n    return 64\n\nassert f(g())\n",
        "idx_generation": 435,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a number is a perfect number\"\"\"\n    if n <= 0:\n        return False\n    divisors = [1]\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            divisors.append(n // i)\n    return sum(divisors) == n\n\ndef g():\n    \"\"\"Generate the next perfect number\"\"\"\n    i = 2\n    while True:\n        if f(i):\n            yield i\n        i += 1\n\nassert f(next(g()))\n",
        "idx_generation": 53,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: dict, start: str, end: str) -> bool:\n    \"\"\"\n    Given a directed graph represented as a dictionary, determine if there is a\n    path from a given start node to a given end node.\n    \"\"\"\n    visited = set()\n\n    def dfs(node):\n        if node == end:\n            return True\n\n        visited.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n\n        return False\n\n    return dfs(start)\n\n\ndef g():\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['D'],\n        'C': ['E'],\n        'D': ['E', 'F'],\n        'E': [],\n        'F': []\n    }\n    start = 'A'\n    end = 'F'\n    return graph, start, end\n\n\nassert f(*g())\n",
        "idx_generation": 379,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers that add up to the target.\n    Return True if such a pair exists, and False otherwise.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5], target=9):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 100,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> bool:\n    \"\"\"Given two positive integers n and k, determine if it is possible to form a sequence of length n where each element is a power of k.\n    Return True if possible, False otherwise.\n    \"\"\"\n    if n == 1:\n        return True\n    if n % k != 0:\n        return False\n    return f(n // k, k)\n\ndef g(n=16, k=2):\n    \"\"\"Generate a positive integer n and a positive integer k.\"\"\"\n    return n, k\n\nassert f(*g())\n",
        "idx_generation": 297,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of positive integers, determine if there exists a subset whose sum is equal to the target number.\"\"\"\n    def helper(i: int, curr_sum: int) -> bool:\n        if curr_sum == target:\n            return True\n        if i == len(nums) or curr_sum > target:\n            return False\n        return helper(i+1, curr_sum + nums[i]) or helper(i+1, curr_sum)\n    \n    return helper(0, 0)\n\ndef g():\n    return [1, 3, 5, 7, 9, 11]\n\nassert f(g(), 16) == True\n",
        "idx_generation": 478,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, move all zeros to the end while maintaining the relative order of the non-zero elements.\n    \"\"\"\n    non_zeros = [num for num in nums if num != 0]\n    zeros = [num for num in nums if num == 0]\n    return non_zeros + zeros\n\ndef g(nums: List[int]):\n    return nums\n\nassert f(g([0, 1, 0, 3, 12])) == [1, 3, 12, 0, 0]\n",
        "idx_generation": 5,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given an integer n, determine the number of ways to represent n as a sum of powers of 2.\n    Each power of 2 can be used at most once.\"\"\"\n    if n == 0:\n        return 1\n    elif n < 0:\n        return 0\n    else:\n        return f(n-1) + f(n-2)\n\ndef g():\n    return 5\n\nassert f(g()) == 8\n\n",
        "idx_generation": 169,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, check if it is a palindrome.\n    Return True if the string is a palindrome, otherwise return False.\n    \"\"\"\n    s = s.lower()\n    s = ''.join(char for char in s if char.isalnum())\n    \n    left = 0\n    right = len(s) - 1\n    \n    while left < right:\n        if s[left] != s[right]:\n            return False\n        left += 1\n        right -= 1\n    \n    return True\n\ndef g():\n    return \"A man, a plan, a canal: Panama\"\n\nassert f(g()) == True\n",
        "idx_generation": 36,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target integer, determine if it is possible to select a subset of the numbers\n    such that the bitwise XOR of all the selected numbers is equal to the target.\n    \"\"\"\n    def count_bits(num: int) -> int:\n        count = 0\n        while num:\n            count += 1\n            num = num & (num - 1)\n        return count\n    \n    total_bits = 0\n    for num in nums:\n        total_bits += count_bits(num)\n    \n    return total_bits >= count_bits(target)\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target\n\nassert f(*g())\n\n",
        "idx_generation": 438,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a given number is a perfect square.\n    Sample input:\n    n = 16\n    Sample output:\n    True\n    \"\"\"\n    if n < 0:\n        return False\n    if n == 0:\n        return True\n    x = n\n    while x * x > n:\n        x = (x + n // x) // 2\n    return x * x == n\n\ndef g():\n    return 16\n\nassert f(g())\n",
        "idx_generation": 54,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, determine if there is a cycle in the graph.\n    \"\"\"\n    n = len(graph)\n    visited = [False] * n\n    stack = [False] * n\n\n    for node in range(n):\n        if not visited[node]:\n            if dfs(graph, node, visited, stack):\n                return True\n\n    return False\n\ndef dfs(graph, node, visited, stack):\n    visited[node] = True\n    stack[node] = True\n\n    for neighbor in graph[node]:\n        if not visited[neighbor]:\n            if dfs(graph, neighbor, visited, stack):\n                return True\n        elif stack[neighbor]:\n            return True\n\n    stack[node] = False\n    return False\n\ndef g():\n    return [[0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1],\n            [1, 0, 0, 0]]\n\nassert f(g()) == True\n\n",
        "idx_generation": 382,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers `nums` and a target integer `target`, \n    return True if there exist two numbers in the list that sum up to the target, \n    otherwise return False.\"\"\"\n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        \n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(nums=[-2, 0, 3, 5, 7, 9, 11, 15], target=12):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 102,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, find the longest increasing subsequence (LIS) and return True if its length is greater than or equal to 3, False otherwise.\"\"\"\n    if len(nums) < 3:\n        return False\n    \n    dp = [1] * len(nums)\n    max_length = 1\n    \n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n                max_length = max(max_length, dp[i])\n    \n    return max_length >= 3\n\ndef g() -> List[int]:\n    \"\"\"Generate a list of integers.\"\"\"\n    nums = [1, 3, 2, 4, 6, 5]\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 318,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Given a list of integers, find if there exists a subset of the integers with a sum equal to the target\"\"\"\n    def subset_sum(nums, target):\n        n = len(nums)\n        dp = [[False] * (target + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][0] = True\n        for i in range(1, n + 1):\n            for j in range(1, target + 1):\n                if nums[i - 1] <= j:\n                    dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        return dp[n][target]\n    return subset_sum(nums, target)\ndef g(target=10):\n    return [1, 2, 3, 4, 5]\nassert f(g())\n",
        "idx_generation": 478,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a number is a power of three.\"\"\"\n    if n < 1:\n        return False\n    while n % 3 == 0:\n        n /= 3\n    return n == 1\n\ndef g():\n    return 27\n\nassert f(g())\n",
        "idx_generation": 8,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence (LIS).\n    An increasing subsequence is a sequence of numbers in an array where the elements are sorted in increasing order.\n    Return the length of the LIS.\n    \"\"\"\n    n = len(arr)\n    lis = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    return max(lis)\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [10, 22, 9, 33, 21, 50, 41, 60, 80]\n\nassert f(g()) == 6\n",
        "idx_generation": 172,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string s, determine if it can be rearranged into a palindrome.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n    You may ignore the case of letters and remove all non-alphanumeric characters.\n    Return True if s can be rearranged into a palindrome, False otherwise.\n    \n    Example:\n    Input: \"A man, a plan, a canal: Panama\"\n    Output: True\n    Explanation: \"amanaplanacanalpanama\" is a palindrome.\n    \"\"\"\n    s = ''.join(filter(str.isalnum, s)).lower()\n    return s == s[::-1]\n    \ndef g():\n    return \"A man, a plan, a canal: Panama\"\n\nassert f(g())\n",
        "idx_generation": 41,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers nums, find the maximum XOR value between any two numbers in the list.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n    return max_xor\n\ndef g():\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g()) == 7\n",
        "idx_generation": 441,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if the given matrix is symmetric.\"\"\"\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i+1, n):\n            if matrix[i][j] != matrix[j][i]:\n                return False\n    return True\n\ndef g():\n    matrix = [[1, 2, 3],\n              [2, 4, 5],\n              [3, 5, 6]]\n    return matrix\n\nassert f(g()) == True\n",
        "idx_generation": 54,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if it is possible to traverse a grid from the top-left corner to the bottom-right corner, only moving right, down, or diagonally.\n    Return True if it is possible, and False otherwise.\"\"\"\n    \n    def dfs(grid: List[List[int]], row: int, col: int) -> bool:\n        \"\"\"Depth-first search to find a path in the grid.\"\"\"\n        \n        if row == len(grid) - 1 and col == len(grid[0]) - 1:\n            return True\n        \n        if row >= len(grid) or col >= len(grid[0]) or grid[row][col] == 1:\n            return False\n        \n        grid[row][col] = 1\n        \n        return dfs(grid, row + 1, col) or dfs(grid, row, col + 1) or dfs(grid, row + 1, col + 1)\n    \n    return dfs(grid, 0, 0)\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a random grid.\"\"\"\n    grid = [[0, 0, 1, 0, 0], [0, 0, 0, 0, 1], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0], [1, 1, 1, 0, 0]]\n    return grid\n\nassert f(g())\n",
        "idx_generation": 404,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> int:\n    \"\"\"Find the kth smallest element in a given array.\"\"\"\n    arr.sort()\n    return arr[k - 1]\n\ndef g(arr=[5, 9, 1, 3, 7], k=3):\n    \"\"\"Generate an array of integers and a value k.\"\"\"\n    return arr, k\n\nassert f(*g()) == 5\n",
        "idx_generation": 103,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a 2D grid of integers, determine if it is possible to reach the bottom-right cell from the top-left cell\n    by moving only rightward, downward, or diagonally. Additionally, each cell in the grid has a positive integer value,\n    and you can only move to a neighboring cell if its value is greater than or equal to the current cell's value.\n    Return True if it is possible, otherwise return False.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    # Initialize the dynamic programming table\n    dp = [[False] * n for _ in range(m)]\n\n    # Base case: the top-left cell is reachable\n    dp[0][0] = True\n\n    # Fill in the dynamic programming table\n    for i in range(m):\n        for j in range(n):\n            if dp[i][j]:\n                # Move right\n                if j + 1 < n and grid[i][j + 1] >= grid[i][j]:\n                    dp[i][j + 1] = True\n                # Move down\n                if i + 1 < m and grid[i + 1][j] >= grid[i][j]:\n                    dp[i + 1][j] = True\n                # Move diagonally\n                if i + 1 < m and j + 1 < n and grid[i + 1][j + 1] >= grid[i][j]:\n                    dp[i + 1][j + 1] = True\n\n    # Return the value in the bottom-right cell\n    return dp[m - 1][n - 1]\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g())\n",
        "idx_generation": 324,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there exists a subsequence of the list\n    whose sum is equal to the target number. The subsequence can be non-contiguous.\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    Output: True\n    \"\"\"\n    def dfs(nums, target, idx, current_sum):\n        if current_sum == target:\n            return True\n        if idx >= len(nums) or current_sum > target:\n            return False\n        return dfs(nums, target, idx + 1, current_sum + nums[idx]) or dfs(nums, target, idx + 1, current_sum)\n\n    return dfs(nums, target, 0, 0)\n\ndef g():\n    return ([1, 2, 3, 4, 5], 7)\n\nassert f(*g())\n",
        "idx_generation": 479,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of integers, check if it is a magic square.\nA magic square is a square grid of numbers where the sums of each row, each column, and both diagonals are the same.\"\"\"\n    n = len(grid)\n    target_sum = sum(grid[0])\n    # Check rows\n    for i in range(n):\n        if sum(grid[i]) != target_sum:\n            return False\n    # Check columns\n    for j in range(n):\n        if sum(grid[i][j] for i in range(n)) != target_sum:\n            return False\n    # Check diagonals\n    if sum(grid[i][i] for i in range(n)) != target_sum or sum(grid[i][n-i-1] for i in range(n)) != target_sum:\n        return False\n    return True\ndef g():\n    return [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\nassert f(g())\n",
        "idx_generation": 9,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if there exists a subset of the list that sums up to the target value.\"\"\"\n    def subset_sum(nums, target, index, curr_sum):\n        if curr_sum == target:\n            return True\n        if index >= len(nums) or curr_sum > target:\n            return False\n        include = subset_sum(nums, target, index+1, curr_sum + nums[index])\n        exclude = subset_sum(nums, target, index+1, curr_sum)\n        return include or exclude\n    \n    return subset_sum(nums, target, 0, 0)\n\ndef g(nums=[2, 4, 6, 8], target=10):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 173,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target='python', replacement='java') -> str:\n    \"\"\"Replace all occurrences of target in s with replacement\"\"\"\n    return s.replace(target, replacement)\n\ndef g(s='I love python and python is the best'):\n    return s\n\nassert f(g()) == 'I love java and java is the best'\n",
        "idx_generation": 41,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, use bit manipulation to count the number of\n    bits set to 1 in the binary representation of n.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g():\n    return 15\n\nassert f(g()) == 4\n",
        "idx_generation": 450,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(s: str, n=1, m=10) -> bool:\n    \"\"\"What is the sum of the first n terms of the arithmetic sequence with a common difference of m?\"\"\"\n    seq_sum = n * (2 * s + (n - 1) * m) // 2\n    return seq_sum == s * n\ndef g(n=1, m=10):\n    return n * (2 * 1 + (n - 1) * m) // 2\nassert f(g())\n",
        "idx_generation": 63,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(adj_matrix: List[List[int]]) -> bool:\n    \"\"\"Given an adjacency matrix representing a directed graph and two vertices u and v, determine if there is a path from u to v.\n    Return True if there is a path, False otherwise.\"\"\"\n    n = len(adj_matrix)\n    visited = [False] * n\n\n    def dfs(v, target):\n        if v == target:\n            return True\n        visited[v] = True\n        for i in range(n):\n            if adj_matrix[v][i] == 1 and not visited[i]:\n                if dfs(i, target):\n                    return True\n        return False\n\n    return dfs(0, n-1)\n\ndef g():\n    return [[0, 1, 1, 0, 0],\n            [0, 0, 0, 1, 0],\n            [0, 0, 0, 1, 1],\n            [0, 0, 0, 0, 1],\n            [0, 0, 0, 0, 0]]\n\nassert f(g())\n",
        "idx_generation": 411,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if there are three integers in the list that sum up to the target value.\n    \n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n    The list contains the triplet (2, 3, 4) that sums up to the target value, so the output should be True.\n    \n    nums = [1, 2, 3, 4, 5]\n    target = 10\n    The list does not contain any triplet that sums up to the target value, so the output should be False.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    \n    for i in range(n-2):\n        left = i + 1\n        right = n - 1\n        \n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            \n            if current_sum == target:\n                return True\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    \n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5], 9\n\nassert f(*g()) == True\n",
        "idx_generation": 104,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers and a target integer, find a pair of distinct numbers whose sum is closest to the target.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    closest_sum = float('inf')\n    pair = []\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        \n        if abs(curr_sum - target) < abs(closest_sum - target):\n            closest_sum = curr_sum\n            pair = [nums[left], nums[right]]\n        \n        if curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return pair\n\ndef g(nums=[-1, 2, 1, -4], target=1):\n    \"\"\"Generate a list of integers and a target integer.\"\"\"\n    return nums, target\n\nassert f(*g()) == [-1, 2]\n",
        "idx_generation": 325,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers 'arr' and a target integer 'target',\n    determine if there exists a combination of numbers in 'arr' that\n    can add up to the target. Each element in 'arr' can be used only once.\"\"\"\n    def backtrack(idx: int, curr_sum: int) -> bool:\n        if curr_sum == target:\n            return True\n        if curr_sum > target or idx == len(arr):\n            return False\n        \n        for i in range(idx, len(arr)):\n            if i > idx and arr[i] == arr[i-1]:\n                continue\n            if backtrack(i+1, curr_sum + arr[i]):\n                return True\n        \n        return False\n    \n    arr.sort()\n    return backtrack(0, 0)\n\ndef g():\n    return ([1, 2, 3, 4, 5], 9)\n\nassert f(*g())\n",
        "idx_generation": 480,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given a positive integer n, determine if it is a prime number. A prime number is a number that is divisible only by 1 and itself.\nSample input:\n7\nSample output:\nTrue\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef g():\n    return 7\nassert f(g())\n",
        "idx_generation": 13,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, find the longest increasing subsequence (LIS) and return True if the LIS has a length greater than or equal to 3.\n    Otherwise, return False.\n    \"\"\"\n    n = len(arr)\n    if n < 3:\n        return False\n\n    # Initialize the LIS array\n    lis = [1] * n\n\n    # Compute the LIS values\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n\n    # Check if the LIS has length greater than or equal to 3\n    return max(lis) >= 3\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g())\n",
        "idx_generation": 174,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"Check if the given string is a palindrome.\"\"\"\n    string = string.lower()\n    string = ''.join(char for char in string if char.isalpha())\n    return string == string[::-1]\ndef g():\n    return \"A man, a plan, a canal, Panama!\"\nassert f(g())\n",
        "idx_generation": 42,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> int:\n    \"\"\"Count the number of bits that need to be flipped to convert n to m.\"\"\"\n    xor_result = n ^ m\n    count = 0\n    while xor_result != 0:\n        count += xor_result & 1\n        xor_result >>= 1\n    return count\n\ndef g():\n    return (29, 15)\n\nassert f(*g()) == 2\n",
        "idx_generation": 455,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find the sum of the first n natural numbers.\"\"\"\n    sum_of_numbers = n * (n + 1) // 2\n    return sum_of_numbers == 15\ndef g():\n    n = 5\n    return n\nassert f(g())\n",
        "idx_generation": 67,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of integers, determine if it is possible to reach the bottom-right cell\n    starting from the top-left cell, only moving downwards or to the right.\n    Return True if it is possible, False otherwise.\n    Example:\n    grid = [\n        [1, 3, 2],\n        [4, 1, 3],\n        [2, 4, 1]\n    ]\n    The possible path to reach the bottom-right cell is [1, 3, 2, 3, 1].\n    Therefore, the answer is True.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    \n    def dfs(i: int, j: int) -> bool:\n        if i >= m or j >= n:\n            return False\n        if i == m - 1 and j == n - 1:\n            return True\n        if grid[i][j] == 0:\n            return False\n        \n        return dfs(i + 1, j) or dfs(i, j + 1)\n    \n    return dfs(0, 0)\n\ndef g():\n    return [\n        [1, 3, 2],\n        [4, 1, 3],\n        [2, 4, 1]\n    ]\n\nassert f(g())\n",
        "idx_generation": 418,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the sum of all prime numbers less than or equal to n.\"\"\"\n    primes = []\n    for num in range(2, n+1):\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                break\n        else:\n            primes.append(num)\n    return sum(primes)\n\ndef g():\n    return 10\n\nassert f(g()) == 17\n",
        "idx_generation": 106,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Given an array of integers, return True if the array can be divided into two subarrays such that the sum of the elements in both subarrays is equal, and False otherwise.\n    Example:\n    arr = [1, 1, 2, 3, 4, 5, 5, 7]\n    Output: True\n    Explanation: The array can be divided into two subarrays [1, 1, 2, 3, 4] and [5, 5, 7], and the sum of both subarrays is 11.\n    \"\"\"\n    total_sum = sum(arr)\n    if total_sum % 2 != 0:\n        return False\n\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n\n    for num in arr:\n        for i in range(target_sum, num - 1, -1):\n            if dp[i - num]:\n                dp[i] = True\n\n    return dp[target_sum]\n\ndef g():\n    arr = [1, 1, 2, 3, 4, 5, 5, 7]\n    return arr\n\nassert f(g())\n",
        "idx_generation": 326,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, find if there are three distinct elements in the list whose sum is equal to the target.\n    Return True if such elements exist, False otherwise.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    for i in range(n-2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            curr_sum = nums[i] + nums[left] + nums[right]\n            if curr_sum == target:\n                return True\n            elif curr_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g(target: int):\n    nums = [1, 2, 3, 4, 5, 6, 7]\n    return nums, target\n\nassert f(*g(10))\n",
        "idx_generation": 482,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if a given list of numbers forms an arithmetic progression.\"\"\"\n    diff = nums[1] - nums[0]\n    for i in range(2, len(nums)):\n        if nums[i] - nums[i-1] != diff:\n            return False\n    return True\n\ndef g():\n    nums = [5, 7, 9, 11, 13]\n    return sorted(nums, reverse=True)\n\nassert f(g())\n",
        "idx_generation": 16,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, arr: List[int]) -> bool:\n    \"\"\"Find if there exists a subset of the given array with a sum equal to n.\n\n    Args:\n        n (int): The target sum.\n        arr (List[int]): The input array.\n\n    Returns:\n        bool: True if there exists a subset with the target sum, False otherwise.\n    \"\"\"\n\n    def subsetSum(target: int, arr: List[int], idx: int, currSum: int) -> bool:\n        if currSum == target:\n            return True\n        if idx == len(arr):\n            return False\n\n        # Include the current element in the subset\n        if subsetSum(target, arr, idx + 1, currSum + arr[idx]):\n            return True\n\n        # Exclude the current element from the subset\n        if subsetSum(target, arr, idx + 1, currSum):\n            return True\n\n        return False\n\n    return subsetSum(n, arr, 0, 0)\n\ndef g(arr: List[int], n: int) -> bool:\n    return f(n, arr)\n\narr = [2, 4, 6, 8, 10]\nn = 14\nassert f(n, arr) == g(arr, n)\n",
        "idx_generation": 176,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> int:\n    \"\"\"Count the number of unique characters in a given string.\n    Return the count as an integer.\n    \"\"\"\n    unique_chars = set(string)  # Using a set to store unique characters\n    return len(unique_chars)\n\ndef g():\n    \"\"\"Returns a string with repeated characters.\"\"\"\n    return \"hello\"\n\nassert f(g()) == 4\n",
        "idx_generation": 43,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two elements in the list.\n    Return the maximum XOR value.\n    Example:\n    nums = [3, 10, 5, 25, 2]\n    The maximum XOR value is 28, which is obtained by XORing 5 and 25.\n    Therefore, the answer is 28.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask = mask | (1 << i)\n        prefix_set = set()\n        for num in nums:\n            prefix_set.add(num & mask)\n        temp = max_xor | (1 << i)\n        for prefix in prefix_set:\n            if temp ^ prefix in prefix_set:\n                max_xor = temp\n                break\n    return max_xor\n\ndef g():\n    return [3, 10, 5, 25, 2]\n\nassert f(g()) == 28\n",
        "idx_generation": 470,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine if a number is a prime number.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g())\n",
        "idx_generation": 80,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]]) -> bool:\n    \"\"\"Check if there is a cycle in the given directed graph.\"\"\"\n    visited = set()\n    recursion_stack = set()\n\n    def dfs(node):\n        visited.add(node)\n        recursion_stack.add(node)\n\n        if node in graph:\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    if dfs(neighbor):\n                        return True\n                elif neighbor in recursion_stack:\n                    return True\n\n        recursion_stack.remove(node)\n        return False\n\n    for node in graph:\n        if node not in visited:\n            if dfs(node):\n                return True\n\n    return False\n\ndef g():\n    return {1: [2], 2: [3], 3: [4], 4: [1]}\n\nassert f(g())\n",
        "idx_generation": 423,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"Check if the target string can be formed by rearranging the characters of s.\"\"\"\n    return sorted(s) == sorted(target)\n\ndef g():\n    return \"python\"\n\nassert f(g(), \"typhon\")\n",
        "idx_generation": 109,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"Given a list of integers and a target integer k, find all pairs of numbers that sum up to k.\n    Return a list of pairs.\"\"\"\n    nums.sort()\n    pairs = []\n    left, right = 0, len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == k:\n            pairs.append((nums[left], nums[right]))\n            left += 1\n            right -= 1\n        elif curr_sum < k:\n            left += 1\n        else:\n            right -= 1\n    return pairs\n\ndef g(k: int):\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(11), 11) == [(1, 10), (2, 9), (3, 8), (4, 7), (5, 6)]\n",
        "idx_generation": 329,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Given a list of integers, find a sublist (contiguous subsequence) whose sum equals the given target.\n    Return True if such a sublist exists, False otherwise.\"\"\"\n    n = len(nums)\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i-1] + nums[i-1]\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if prefix_sum[j] - prefix_sum[i] == target:\n                return True\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g())\n",
        "idx_generation": 485,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers that add up to a given target.\n    Return True if such numbers exist, False otherwise.\n    \n    Sample input:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 10\n    \n    Sample output:\n    True\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g(), 10)\n",
        "idx_generation": 17,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the maximum sum of a path from the top-left corner to the bottom-right corner of a given grid.\n\n    Args:\n        grid (List[List[int]]): The input grid.\n\n    Returns:\n        int: The maximum sum of a path.\n\n    Example:\n        Input: grid = [[1,3,1],[1,5,1],[4,2,1]]\n        Output: 12\n        Explanation: The maximum sum of a path is 1 + 3 + 5 + 1 + 2 + 1 = 12.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[m - 1][n - 1]\n\ndef g(grid: List[List[int]]) -> int:\n    return f(grid)\n\ngrid = [[1,3,1],[1,5,1],[4,2,1]]\nassert f(grid) == g(grid)\n",
        "idx_generation": 176,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find if the binary representation of the given integer is a palindrome.\"\"\"\n    binary = bin(n)[2:]\n    return binary == binary[::-1]\n\ndef g(n: int) -> bool:\n    \"\"\"Find if the binary representation of the given integer is a palindrome.\"\"\"\n    binary = bin(n)[2:]\n    return binary == binary[::-1]\n\nassert f(g(9))\n",
        "idx_generation": 45,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a pair of numbers in the list that XOR to a given target value.\n    Return True if such a pair exists, otherwise return False.\n    \"\"\"\n    def check_pair(nums: List[int], target: int) -> bool:\n        seen = set()\n        for num in nums:\n            complement = target ^ num\n            if complement in seen:\n                return True\n            seen.add(num)\n        return False\n    \n    return check_pair(nums, 10)\n\ndef g():\n    nums = [3, 5, 2, 8, 6, 9]\n    return nums\n\nassert f(g()) == True\n\n",
        "idx_generation": 475,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, find the number of unique binary search trees that can be formed\n    with the integers from 1 to n.\n    Example:\n    n = 3\n    The unique binary search trees that can be formed are:\n    - Root node 1, right subtree with nodes 2 and 3\n    - Root node 2, left subtree with node 1 and right subtree with node 3\n    - Root node 3, left subtree with nodes 1 and 2\n    Therefore, the answer is 5.\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(1, i + 1):\n            dp[i] += dp[j - 1] * dp[i - j]\n    return dp[n]\n\ndef g():\n    return 3\n\nassert f(g()) == 5\n",
        "idx_generation": 88,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(adjacency_matrix: List[List[int]], start_node: int, end_node: int, path_length: int) -> bool:\n    \"\"\"Given an adjacency matrix representing a directed graph and two nodes, determine if there is a path from the start node to the end node\n    with a length equal to path_length.\"\"\"\n    visited = [False] * len(adjacency_matrix)\n    return dfs(adjacency_matrix, start_node, end_node, path_length, visited)\n\ndef dfs(adjacency_matrix: List[List[int]], current_node: int, end_node: int, path_length: int, visited: List[bool]) -> bool:\n    if path_length == 0 and current_node == end_node:\n        return True\n    if path_length < 0:\n        return False\n    visited[current_node] = True\n    for neighbor in range(len(adjacency_matrix)):\n        if adjacency_matrix[current_node][neighbor] == 1 and not visited[neighbor]:\n            if dfs(adjacency_matrix, neighbor, end_node, path_length - 1, visited):\n                return True\n    visited[current_node] = False\n    return False\n\ndef g():\n    adjacency_matrix = [\n        [0, 1, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 1],\n        [0, 0, 0, 0, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    start_node = 0\n    end_node = 4\n    path_length = 3\n    return (adjacency_matrix, start_node, end_node, path_length)\n\nassert f(*g())\n\n",
        "idx_generation": 426,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there are two numbers in the list that sum up to the target.\"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [-3, -2, 1, 3, 5, 7, 9], 6\n\nassert f(*g())\n",
        "idx_generation": 110,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers 'nums' and a target value 'target',\n    determine if there are three integers in 'nums' that sum up to the target value.\n    Return True if such integers exist, False otherwise.\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n    The possible triplet is [2, 4, 3] which sums up to 9.\n    Therefore, the answer is True.\n    \"\"\"\n    nums.sort()\n    for i in range(len(nums) - 2):\n        left = i + 1\n        right = len(nums) - 1\n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            if current_sum == target:\n                return True\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5], 9\n\nassert f(*g())\n",
        "idx_generation": 330,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers 'nums', find the maximum sum of any contiguous subarray.\n    Return the maximum sum.\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    The maximum sum of a contiguous subarray is 6, which can be obtained from the subarray [4, -1, 2, 1].\n    Therefore, the output should be 6.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef g() -> List[int]:\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 488,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the sum of all positive integers less than or equal to n that are divisible by either 3 or 5.\n    Sample input:\n    20\n    Sample output:\n    98\"\"\"\n    total_sum = 0\n    for i in range(1, n + 1):\n        if i % 3 == 0 or i % 5 == 0:\n            total_sum += i\n    return total_sum\n\ndef g():\n    return 20\n\nassert f(g()) == 98\n",
        "idx_generation": 20,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the nth number in the Fibonacci sequence.\n\n    Args:\n        n (int): The position of the number in the Fibonacci sequence.\n\n    Returns:\n        int: The nth number in the Fibonacci sequence.\n\n    Note:\n        The Fibonacci sequence starts with 0 and 1, and each subsequent number is the sum of the two preceding ones.\n        For example, the first 10 numbers in the Fibonacci sequence are: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34.\n    \"\"\"\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n\n    fib = [0] * (n + 1)\n    fib[1] = 1\n\n    for i in range(2, n + 1):\n        fib[i] = fib[i - 1] + fib[i - 2]\n\n    return fib[n]\n\ndef g(n: int) -> int:\n    return f(n)\n\nassert f(10) == g(10)\n",
        "idx_generation": 176,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(x: str, y: str) -> bool:\n    \"\"\"Check if two strings have the same number of vowels.\"\"\"\n    vowels = \"aeiouAEIOU\"\n    return sum([1 for c in x if c in vowels]) == sum([1 for c in y if c in vowels])\n  \ndef g(x: str, y: str):\n    return x + y\n\nassert f(g(\"hello\", \"world\"), g(\"hi\", \"there\"))\n",
        "idx_generation": 50,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum XOR value\n    that can be obtained by selecting two different integers from the list.\"\"\"\n    max_xor = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            max_xor = max(max_xor, arr[i] ^ arr[j])\n    \n    return max_xor\n\ndef g():\n    return ([1, 2, 3, 4, 5], )\n\nassert f(*g()) == 7\n",
        "idx_generation": 480,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given an integer n, determine if it is a prime number.\n    Return True if it is prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    n = 17\n    return n\n\nassert f(g())\n",
        "idx_generation": 101,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> int:\n    \"\"\"Given a number of nodes n and a list of edges connecting the nodes, find the number of connected components in the graph.\n    Example:\n    n = 6, edges = [[0, 1], [1, 2], [3, 4]]\n    Output: 3\n    Explanation: The graph has 3 connected components: {0, 1, 2}, {3, 4}, {5}\"\"\"\n    parent = list(range(n))\n    rank = [0] * n\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX == rootY:\n            return\n        if rank[rootX] < rank[rootY]:\n            parent[rootX] = rootY\n        elif rank[rootX] > rank[rootY]:\n            parent[rootY] = rootX\n        else:\n            parent[rootY] = rootX\n            rank[rootX] += 1\n    \n    for u, v in edges:\n        union(u, v)\n    \n    components = set()\n    for i in range(n):\n        components.add(find(i))\n    \n    return len(components)\n\ndef g(n: int, edges: List[List[int]]) -> int:\n    \"\"\"Find the number of connected components in a graph.\"\"\"\n    parent = list(range(n))\n    rank = [0] * n\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX == rootY:\n            return\n        if rank[rootX] < rank[rootY]:\n            parent[rootX] = rootY\n        elif rank[rootX] > rank[rootY]:\n            parent[rootY] = rootX\n        else:\n            parent[rootY] = rootX\n            rank[rootX] += 1\n    \n    for u, v in edges:\n        union(u, v)\n    \n    components = set()\n    for i in range(n):\n        components.add(find(i))\n    \n    return len(components)\n\nassert f(n=6, edges=[[0, 1], [1, 2], [3, 4]]) == g(n=6, edges=[[0, 1], [1, 2], [3, 4]])\n",
        "idx_generation": 431,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target=10) -> bool:\n    \"\"\"Find a pair of elements from arr that sums up to the target value.\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr=[2, 5, 7, 3, 1, 9]):\n    return arr\n\nassert f(g())\n",
        "idx_generation": 111,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, use binary search to determine if a target number is present in the list.\n    \"\"\"\n    low = 0\n    high = len(nums) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target=7):\n    \"\"\"\n    Generate a sorted list of integers and a target number to search for in the list.\n    \"\"\"\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 331,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, return the length of the longest increasing subsequence (LIS).\n    Sample Input:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Sample Output:\n    4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g(nums: List[int]) -> int:\n    \"\"\"Find the length of the longest increasing subsequence in a given list of integers.\"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\nassert f(nums=[10, 9, 2, 5, 3, 7, 101, 18]) == g(nums=[10, 9, 2, 5, 3, 7, 101, 18])\n",
        "idx_generation": 490,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Reverse the words in a string using a stack\"\"\"\n    stack = []\n    words = s.split()\n    for word in words:\n        stack.append(word)\n    reversed_words = []\n    while stack:\n        reversed_words.append(stack.pop())\n    return ' '.join(reversed_words)\n\ndef g(s='Hello World'):\n    return s\n\nassert f(g()) == 'World Hello'\n",
        "idx_generation": 22,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given an m x n matrix filled with non-negative integers, find the minimum sum along a path from the top-left cell to the bottom-right cell.\n    You can only move either down or right at any point in time.\n    Return the minimum sum.\n    \"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = matrix[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g():\n    matrix = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return (matrix,)\n\nassert f(*g()) == 7\n",
        "idx_generation": 177,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Reverse the order of words in a given string s.\"\"\"\n    words = s.split()\n    return ' '.join(words[::-1])\n\ndef g(s=\"Hello World, how are you?\"):\n    return s\n\nassert f(g()) == \"you? are how World, Hello\"\n",
        "idx_generation": 51,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], k=3) -> bool:\n    \"\"\"Determine if there exists a subarray in the given list, such that the bitwise XOR of all its elements is equal to k.\"\"\"\n    prefix_xor = 0\n    xor_count = {0: 1}\n    count = 0\n    for num in nums:\n        prefix_xor ^= num\n        count += xor_count.get(prefix_xor ^ k, 0)\n        xor_count[prefix_xor] = xor_count.get(prefix_xor, 0) + 1\n    return count > 0\n\ndef g(k=3):\n    return [4, 2, 1, 6, 3, 5, 7]\n\nassert f(g())\n",
        "idx_generation": 490,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(n: int, k: int) -> bool:\n    \"\"\"Determine if a number is a prime that can be expressed as a sum of k consecutive prime numbers.\"\"\"\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    primes = []\n    for i in range(2, n+k+1):\n        if is_prime(i):\n            primes.append(i)\n    \n    for i in range(len(primes) - k):\n        if sum(primes[i:i+k]) == n:\n            return True\n    \n    return False\n\ndef g(n=41, k=3):\n    return n, k\n\nassert f(*g())\n",
        "idx_generation": 102,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import Dict, List\n\ndef f(graph: Dict[str, List[str]]) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency list, return True if the graph contains a cycle, and False otherwise.\n    \"\"\"\n\n    def dfs(node):\n        visited.add(node)\n        current_path.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor in current_path:\n                return True\n            elif neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n\n        current_path.remove(node)\n        return False\n\n    visited = set()\n    current_path = set()\n\n    for node in graph:\n        if node not in visited:\n            if dfs(node):\n                return True\n\n    return False\n\n\ndef g(graph: Dict[str, List[str]] = {'A': ['B', 'C'], 'B': ['C'], 'C': []}):\n    return graph\n\nassert f(g()) == False\n\n",
        "idx_generation": 433,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers 'nums' and a target number 'target',\n    determine if there exist two numbers in the list such that their sum is equal to the target.\n    Return True if such numbers exist, False otherwise.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 10\n    \n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 112,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of unique integers and a target value, determine if there are two numbers in the list\n    that add up to the target value. Return True if such numbers exist, False otherwise.\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    The pairs that add up to 7 are (2, 5) and (3, 4), therefore the answer is True.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5], 7\n\nassert f(*g())\n",
        "idx_generation": 333,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, find the second largest element in the list.\"\"\"\n    if len(nums) < 2:\n        return False\n    largest = float('-inf')\n    second_largest = float('-inf')\n    for num in nums:\n        if num > largest:\n            second_largest = largest\n            largest = num\n        elif num > second_largest and num < largest:\n            second_largest = num\n    return second_largest\ndef g():\n    return [1, 5, 9, 3, 7, 2, 8, 4, 6]\nassert f(g()) == 8\n",
        "idx_generation": 25,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value k, return True if there is a subset of the list that sums up to k,\n    and False otherwise.\n    \n    Example:\n    nums = [1, 3, 5, 7, 9]\n    k = 12\n    Output:\n    True\n    Explanation: The subset [3, 9] sums up to 12.\n    \"\"\"\n    def subset_sum(nums, k, index, curr_sum):\n        if curr_sum == k:\n            return True\n        if curr_sum > k or index >= len(nums):\n            return False\n        \n        # Include current element in the subset\n        if subset_sum(nums, k, index + 1, curr_sum + nums[index]):\n            return True\n        \n        # Exclude current element from the subset\n        if subset_sum(nums, k, index + 1, curr_sum):\n            return True\n        \n        return False\n    \n    return subset_sum(nums, k, 0, 0)\n\ndef g():\n    nums = [1, 3, 5, 7, 9]\n    k = 12\n    return nums, k\n\nassert f(*g())\n",
        "idx_generation": 181,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string, determine if it is a palindrome.\"\"\"\n    i, j = 0, len(s) - 1\n    while i < j:\n        if s[i] != s[j]:\n            return False\n        i += 1\n        j -= 1\n    return True\n\ndef g(s: str) -> str:\n    \"\"\"Reverse the given string.\"\"\"\n    return s[::-1]\n\nassert f(g(s='radar'))\n",
        "idx_generation": 51,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum bitwise OR value between any two numbers in the array.\n    \"\"\"\n    max_or = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            _or = arr[i] | arr[j]\n            max_or = max(max_or, _or)\n    return max_or\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    arr = [5, 10, 15, 20, 25]\n    return arr\n\nassert f(g()) == 31\n",
        "idx_generation": 492,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find if the given number is a prime number.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    \"\"\"Return a positive integer.\"\"\"\n    return 13\n\nassert f(g())\n",
        "idx_generation": 110,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Determine if there exists a path from the top-left corner to the bottom-right corner in the given matrix, where each cell represents the cost to reach that cell\"\"\"\n    rows, cols = len(matrix), len(matrix[0])\n    \n    def dfs(row, col):\n        if row == rows-1 and col == cols-1:\n            return True\n        if row >= rows or col >= cols:\n            return False\n        if matrix[row][col] == -1:\n            return False\n        \n        return dfs(row+1, col) or dfs(row, col+1)\n    \n    return dfs(0, 0)\n\ndef g(matrix: List[List[int]]):\n    return [[0 for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n\nassert f(g(matrix=[[0, 1, 0], [0, 0, 1], [1, 0, 0]]))\n",
        "idx_generation": 434,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers nums and a target value, determine if there is a pair of numbers in the list\n    that add up to the target value.\n    - nums is a list of integers in ascending order\n    - target is an integer\n    - return True if there exists a pair of numbers in nums that add up to target, and False otherwise.\"\"\"\n    \n    def binary_search(nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False\n    \n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if binary_search(nums[i+1:], complement):\n            return True\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7], 9\n\nassert f(*g())\n",
        "idx_generation": 112,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the given list is sorted in ascending order\"\"\"\n    for i in range(len(arr) - 1):\n        if arr[i] > arr[i+1]:\n            return False\n    return True\n\ndef g(arr: List[int]) -> List[int]:\n    \"\"\"Sort the given list in ascending order\"\"\"\n    return sorted(arr)\n\nassert f(g([1, 2, 3, 4, 5]))\n",
        "idx_generation": 333,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Given a list of integers nums and a target integer k, return True if there exist two distinct indices i and j\n    such that nums[i] + nums[j] is divisible by k, and False otherwise.\n    Example:\n    nums = [4, 5, 10, 12, 14, 15]\n    k = 7\n    The indices i and j are 0 and 4 respectively, because nums[0] + nums[4] = 4 + 14 = 18, which is divisible by 7.\n    Therefore, the function should return True.\n    \"\"\"\n    remainders = [0] * k\n    for num in nums:\n        remainder = num % k\n        if remainders[(k - remainder) % k] > 0:\n            return True\n        remainders[remainder] += 1\n    return False\n\ndef g():\n    return [4, 5, 10, 12, 14, 15], 7\n\nassert f(*g()) == True\n",
        "idx_generation": 35,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given an array of integers 'arr' and a target integer, return True if there is a subset of 'arr' that adds up to the target, and False otherwise.\"\"\"\n    def subset_sum(arr: List[int], target: int, index: int) -> bool:\n        if target == 0:\n            return True\n        if index == len(arr):\n            return False\n        if arr[index] > target:\n            return subset_sum(arr, target, index + 1)\n        return subset_sum(arr, target - arr[index], index + 1) or subset_sum(arr, target, index + 1)\n    \n    return subset_sum(arr, target, 0)\n\ndef g():\n    return [2, 4, 6, 8, 10]\n\nassert f(g(), 14) == True\n",
        "idx_generation": 181,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, words=['apple', 'banana', 'orange', 'grapefruit', 'kiwi', 'mango', 'pineapple'], prefix='gr') -> bool:\n    \"\"\"Check if there is a word in the list that starts with a given prefix.\"\"\"\n    return any(word.startswith(prefix) for word in words)\ndef g(words=['apple', 'banana', 'orange', 'grapefruit', 'kiwi', 'mango', 'pineapple'], prefix='gr'):\n    return [word for word in words if word.startswith(prefix)][0]\nassert f(g())\n",
        "idx_generation": 59,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(n: int) -> int:\n    \"\"\"Count the number of prime numbers less than or equal to n.\"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    count = 0\n    for num in range(2, n + 1):\n        if is_prime(num):\n            count += 1\n    return count\n\ndef g():\n    return 20\n\nassert f(g()) == 8\n",
        "idx_generation": 121,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix, determine if it represents a valid connected graph.\"\"\"\n    n = len(matrix)\n\n    visited = [False] * n\n\n    def dfs(node):\n        visited[node] = True\n        for i in range(n):\n            if matrix[node][i] == 1 and not visited[i]:\n                dfs(i)\n\n    dfs(0)\n\n    return all(visited)\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a matrix that represents a valid connected graph.\"\"\"\n    import random\n    n = random.randint(3, 8)\n    matrix = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if random.choice([True, False]):\n                matrix[i][j] = 1\n                matrix[j][i] = 1\n\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 437,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, check if the list is a valid permutation of the numbers from 1 to n.\n    Return True if it is a valid permutation, False otherwise.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    for i in range(n):\n        if nums[i] != i + 1:\n            return False\n    return True\n\ndef g():\n    nums = [2, 4, 1, 3]\n    return nums\n\nassert f(g())\n",
        "idx_generation": 113,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given an array of integers nums, return True if there exists a subsequence of the array that is strictly decreasing, otherwise return False.\"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] < nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp) >= 3\n\ndef g(nums=[5, 4, 3, 2, 1]):\n    return nums\n\nassert f(g())\n",
        "idx_generation": 334,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all positive integers less than or equal to n that are divisible by 3 or 5.\n    Return the sum.\n    \"\"\"\n    sum = 0\n    \n    for i in range(1, n+1):\n        if i % 3 == 0 or i % 5 == 0:\n            sum += i\n    \n    return sum\n\ndef g():\n    return 100\n\nassert f(g()) == 2418\n",
        "idx_generation": 36,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(pattern: str, text: str) -> bool:\n    \"\"\"Check if the given pattern appears in the text, where the pattern can contain wildcards represented by '?'.\n    Return True if the pattern matches the text, False otherwise.\"\"\"\n    m, n = len(pattern), len(text)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n    for i in range(1, m + 1):\n        if pattern[i - 1] == '?':\n            dp[i][0] = dp[i - 1][0]\n        for j in range(1, n + 1):\n            if pattern[i - 1] == '?' or pattern[i - 1] == text[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            elif pattern[i - 1] == '*':\n                dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n    return dp[m][n]\n\ndef g():\n    return (\"a*bc?\", \"abbcc\")\n\nassert f(*g())\n",
        "idx_generation": 185,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome, ignoring non-alphanumeric characters.\"\"\"\n    s = ''.join(c.lower() for c in s if c.isalnum())\n    return s == s[::-1]\n\ndef g(s: str):\n    \"\"\"Remove non-alphanumeric characters from the given string.\"\"\"\n    return ''.join(c for c in s if c.isalnum())\n\nassert f(g(\"A man, a plan, a canal: Panama\"))\n",
        "idx_generation": 65,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(n: int, k: int) -> bool:\n    \"\"\"Determine if the given number n is a perfect power of k.\"\"\"\n    return math.isqrt(n) ** k == n\n\ndef g(k: int) -> int:\n    \"\"\"Find the smallest perfect power of k.\"\"\"\n    return k ** 2\n\nassert f(g(2), 2)\n",
        "idx_generation": 124,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given an adjacency matrix representing a graph, find if there exists a path from a given start node to a given end node,\n    where the path contains an even number of edges.\"\"\"\n    n = len(graph)\n    visited = [False] * n\n    return dfs(graph, start, end, visited, 0)\n\ndef dfs(graph, u, end, visited, count):\n    if u == end:\n        return count % 2 == 0\n    visited[u] = True\n    for v in range(len(graph[u])):\n        if graph[u][v] == 1 and not visited[v]:\n            if dfs(graph, v, end, visited, count + 1):\n                return True\n    visited[u] = False\n    return False\n\ndef g():\n    graph = [\n        [0, 1, 0, 0, 1],\n        [1, 0, 1, 1, 0],\n        [0, 1, 0, 1, 0],\n        [0, 1, 1, 0, 1],\n        [1, 0, 0, 1, 0]\n    ]\n    start = 0\n    end = 4\n    return graph, start, end\n\nassert f(*g())\n",
        "idx_generation": 439,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a sorted list of distinct integers, find the missing number in the sequence.\"\"\"\n    n = len(nums)\n    low = 0\n    high = n - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] != mid + 1:\n            if mid == 0 or nums[mid - 1] == mid:\n                return mid + 1\n            high = mid - 1\n        else:\n            low = mid + 1\n\n    return n + 1\n\ndef g():\n    nums = [1, 2, 3, 4, 6, 7, 8, 9, 10]\n    return nums\n\nassert f(g()) == 5\n",
        "idx_generation": 115,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers and a target value, determine if there exists two numbers in the array whose sum is equal to the target.\"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5, 6, 7]\n    target = 9\n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 336,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of numbers contains a perfect square\"\"\"\n    for num in nums:\n        if int(num ** 0.5) ** 2 == num:\n            return True\n    return False\n\ndef g():\n    return [12, 6, 9, 16, 5]\n\nassert f(g()) == True\n",
        "idx_generation": 40,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the number of binary strings of length n that do not contain consecutive 1's.\"\"\"\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 2\n    prev_prev = 1\n    prev = 2\n    for i in range(2, n):\n        curr = prev + prev_prev\n        prev_prev = prev\n        prev = curr\n    return prev\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 185,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, check if it is a palindrome list.\n    A palindrome list is a list that reads the same backward as forward.\"\"\"\n    \n    def is_palindrome(nums):\n        return nums == nums[::-1]\n    \n    return is_palindrome(nums)\n\ndef g(nums=[1, 2, 3, 2, 1]):\n    return nums\n\nassert f(g())\n",
        "idx_generation": 66,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum sum of a contiguous subarray within the list.\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"Generate a list of integers from the given list that represents the contiguous subarray with the maximum sum.\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    start = 0\n    end = 0\n    temp_start = 0\n    \n    for i, num in enumerate(nums):\n        if num > curr_sum + num:\n            curr_sum = num\n            temp_start = i\n        else:\n            curr_sum += num\n        \n        if curr_sum > max_sum:\n            max_sum = curr_sum\n            start = temp_start\n            end = i\n    \n    return nums[start:end+1]\n\nassert f(g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4])) == 6\n",
        "idx_generation": 133,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(graph: List[List[int]], start_node: int, end_node: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix (graph) and two nodes (start_node and end_node),\n    determine if there exists a path from start_node to end_node.\n    Return True if a path exists, False otherwise.\n\n    Example:\n    graph = [[0, 1, 1, 0],\n             [0, 0, 1, 0],\n             [0, 0, 0, 1],\n             [1, 0, 0, 0]]\n\n    In the above graph, there is a path from node 0 to node 3: 0 -> 1 -> 2 -> 3.\n    Therefore, the answer is True.\n    \"\"\"\n\n    def dfs(node):\n        visited.add(node)\n        if node == end_node:\n            return True\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] == 1 and neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n        return False\n\n    visited = set()\n    return dfs(start_node)\n\ndef g():\n    graph = [[0, 1, 1, 0],\n             [0, 0, 1, 0],\n             [0, 0, 0, 1],\n             [1, 0, 0, 0]]\n    start_node = 0\n    end_node = 3\n    return graph, start_node, end_node\n\nassert f(*g())\n",
        "idx_generation": 441,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there exist two numbers in the list such that their sum is equal to the target.\"\"\"\n    low = 0\n    high = len(nums) - 1\n\n    while low < high:\n        total = nums[low] + nums[high]\n        if total == target:\n            return True\n        elif total < target:\n            low += 1\n        else:\n            high -= 1\n\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 13\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 115,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, move all zeros to the end while maintaining the relative order of the non-zero elements.\"\"\"\n    n = len(nums)\n    count = 0\n\n    for i in range(n):\n        if nums[i] != 0:\n            nums[count] = nums[i]\n            count += 1\n\n    while count < n:\n        nums[count] = 0\n        count += 1\n\n    return nums\n\ndef g():\n    nums = [0, 1, 0, 3, 12]\n    return nums\n\nassert f(g()) == [1, 3, 12, 0, 0]\n\n",
        "idx_generation": 342,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Check if the given target number exists in the matrix.\"\"\"\n    rows, cols = len(matrix), len(matrix[0])\n    row, col = 0, cols - 1\n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n    return False\n\ndef g(matrix=[[1, 3, 5], [7, 9, 11], [13, 15, 17]], target=9):\n    return matrix, target\n\nassert f(*g())\n",
        "idx_generation": 40,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there exists a subset of the integers that adds up to the target.\n    Return True if such a subset exists, False otherwise.\n    \"\"\"\n\n    def is_subset_sum(nums: List[int], target: int, n: int) -> bool:\n        # Base cases\n        if target == 0:\n            return True\n        if n == 0 and target != 0:\n            return False\n\n        # If last element is greater than target, ignore it\n        if nums[n-1] > target:\n            return is_subset_sum(nums, target, n-1)\n\n        # Check if target can be obtained by including or excluding the last element\n        return is_subset_sum(nums, target-nums[n-1], n-1) or is_subset_sum(nums, target, n-1)\n\n    return is_subset_sum(nums, target, len(nums))\n\ndef g():\n    return [3, 34, 4, 12, 5, 2], 9\n\nassert f(*g())\n",
        "idx_generation": 186,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(s: str, target='abcde') -> bool:\n    \"\"\"Find if the string s is a permutation of the target string using string manipulation.\"\"\"\n    return sorted(s) == sorted(target)\ndef g(target='abcde'):\n    return ''.join(random.sample(target, len(target)))\nassert f(g())\n",
        "idx_generation": 66,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find if n is a prime number.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    n = 2\n    while True:\n        if f(n):\n            return n\n        n += 1\n\nassert f(g()) == True\n",
        "idx_generation": 133,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(edges: List[List[int]], n=5) -> bool:\n    \"\"\"Check if a given directed graph contains a cycle.\"\"\"\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n    \n    visited = [False] * n\n    rec_stack = [False] * n\n    \n    def is_cyclic_util(node):\n        visited[node] = True\n        rec_stack[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if is_cyclic_util(neighbor):\n                    return True\n            elif rec_stack[neighbor]:\n                return True\n        \n        rec_stack[node] = False\n        return False\n    \n    for node in range(n):\n        if not visited[node]:\n            if is_cyclic_util(node):\n                return True\n    \n    return False\n\ndef g(n=5):\n    import random\n    \n    edges = []\n    for _ in range(n):\n        u = random.randint(0, n-1)\n        v = random.randint(0, n-1)\n        edges.append([u, v])\n    \n    return edges\n\nassert f(g())\n",
        "idx_generation": 443,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Determine if there exists a pair of numbers in the given list that sum up to 10.\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == 10:\n            return True\n        elif arr[left] + arr[right] < 10:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g())\n",
        "idx_generation": 115,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Find the next permutation of the given list of numbers.\n    If no next permutation exists, return the list in ascending order.\n    Sample Input:\n    nums = [1, 2, 3]\n    Sample Output:\n    [1, 3, 2]\"\"\"\n    i = len(nums) - 2\n    while i >= 0 and nums[i] >= nums[i + 1]:\n        i -= 1\n    if i >= 0:\n        j = len(nums) - 1\n        while j >= 0 and nums[j] <= nums[i]:\n            j -= 1\n        nums[i], nums[j] = nums[j], nums[i]\n    left = i + 1\n    right = len(nums) - 1\n    while left < right:\n        nums[left], nums[right] = nums[right], nums[left]\n        left += 1\n        right -= 1\n    return nums\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"Return the list of numbers.\"\"\"\n    return nums\n\nassert f(g(nums=[1, 2, 3])) == [1, 3, 2]\n",
        "idx_generation": 347,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given an array of integers arr and a target sum, determine if there exist three distinct indices i, j, and k\n    such that arr[i] * arr[j] * arr[k] equals the target sum.\n    Return True if such indices exist, False otherwise.\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 24\n    The indices i, j, and k are 0, 2, and 4 respectively, because arr[0] * arr[2] * arr[4] = 1 * 3 * 5 = 15.\n    Therefore, the answer is True.\n    \"\"\"\n    n = len(arr)\n    for i in range(n-2):\n        for j in range(i+1, n-1):\n            for k in range(j+1, n):\n                if arr[i] * arr[j] * arr[k] == target:\n                    return True\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5], 24\n\nassert f(*g()) == True\n",
        "idx_generation": 42,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"Given a list of integers and a value k, determine if there exists a subset of the list such that the sum of its elements is divisible by k.\n    Return True if such subset exists, False otherwise.\"\"\"\n    n = len(arr)\n    dp = [False] * k\n    dp[0] = True\n    \n    for i in range(n):\n        new_dp = dp.copy()\n        for j in range(k):\n            if dp[j]:\n                new_dp[(j + arr[i]) % k] = True\n        dp = new_dp\n    \n    return dp[0]\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Generate a list of integers and a value k.\"\"\"\n    arr = [2, 4, 6, 8, 10]\n    k = 5\n    \n    return arr, k\n\nassert f(*g()) == True\n\n",
        "idx_generation": 189,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(s: str, words: List[str]) -> int:\n    \"\"\"Count the number of occurrences of each word in the string\"\"\"\n    word_count = {}\n    for word in words:\n        count = s.count(word)\n        word_count[word] = count\n    return word_count\n\ndef g():\n    return \"I scream, you scream, we all scream for ice cream\", [\"scream\", \"for\"]\n\nassert f(*g()) == {'scream': 3, 'for': 1}\n",
        "idx_generation": 68,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given an integer n, return True if n is a prime number, otherwise return False.\n\n    Args:\n    - n: An integer.\n\n    Returns:\n    - A boolean value indicating whether n is a prime number.\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g() -> int:\n    \"\"\"Generate a prime number.\"\"\"\n    return 17\n\nassert f(g())\n",
        "idx_generation": 136,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    Given a number of nodes `n` and a list of directed edges between nodes,\n    find the length of the longest path in the graph.\n    Return the length of the longest path.\n    \"\"\"\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n\n    def dfs(node):\n        nonlocal max_length\n        path_length = 0\n        for neighbor in graph[node]:\n            path_length = max(path_length, dfs(neighbor))\n        max_length = max(max_length, path_length + 1)\n        return path_length + 1\n\n    max_length = 0\n    for node in range(n):\n        dfs(node)\n\n    return max_length\n\ndef g():\n    n = 5\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4]]\n    return n, edges\n\nassert f(*g()) == 5\n",
        "idx_generation": 445,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, return True if there exists a pair of numbers whose sum is equal to 10.\n    Return False otherwise.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == 10:\n            return True\n        elif current_sum < 10:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g() -> List[int]:\n    \"\"\"Generate a list of integers.\"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g()) == True\n",
        "idx_generation": 116,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Check if it is possible to divide the given list into k subarrays such that the sum of each subarray is equal.\"\"\"\n    def partition(nums, k, target, currSum, start):\n        if k == 1:\n            return True\n        if currSum == target:\n            return partition(nums, k - 1, target, 0, 0)\n        for i in range(start, len(nums)):\n            if not visited[i] and currSum + nums[i] <= target:\n                visited[i] = True\n                if partition(nums, k, target, currSum + nums[i], i + 1):\n                    return True\n                visited[i] = False\n        return False\n\n    if sum(nums) % k != 0:\n        return False\n    visited = [False] * len(nums)\n    return partition(nums, k, sum(nums) // k, 0, 0)\n\ndef g():\n    return [4, 3, 2, 3, 5, 2, 1], 4\n\nassert f(*g())\n",
        "idx_generation": 347,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, find if there are two numbers in the list that add up to the target value.\"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return ([1, 2, 3, 4, 5], 8)\n\nassert f(*g())\n",
        "idx_generation": 47,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the given array can be partitioned into two subsets with equal sum\"\"\"\n    total_sum = sum(arr)\n    if total_sum % 2 != 0:\n        return False\n    \n    target_sum = total_sum // 2\n    n = len(arr)\n    dp = [[False] * (target_sum + 1) for _ in range(n + 1)]\n    \n    for i in range(n + 1):\n        dp[i][0] = True\n    \n    for i in range(1, n + 1):\n        for j in range(1, target_sum + 1):\n            if j < arr[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n    \n    return dp[n][target_sum]\n\ndef g(arr=[1, 5, 11, 5]):\n    return arr\n\nassert f(g())\n",
        "idx_generation": 189,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string 's' is a palindrome after removing all non-alphanumeric characters and converting to lowercase.\"\"\"\n    clean_string = ''.join(c.lower() for c in s if c.isalnum())\n    return clean_string == clean_string[::-1]\n\ndef g(s: str) -> str:\n    \"\"\"Remove all non-alphanumeric characters from a string 's' and return the result.\"\"\"\n    return ''.join(c for c in s if c.isalnum())\n\nassert f(s=g(s=\"A man, a plan, a canal: Panama\"))\n",
        "idx_generation": 70,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number is a perfect square.\"\"\"\n    if n < 0:\n        return False\n    root = int(n ** 0.5)\n    return root * root == n\n\ndef g():\n    \"\"\"Generate a perfect square number.\"\"\"\n    return 25\n\nassert f(g())\n\n",
        "idx_generation": 149,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"Given an adjacency matrix representing a directed graph, check if the graph contains a cycle.\"\"\"\n    def dfs(node, visited, stack):\n        visited[node] = True\n        stack[node] = True\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor]:\n                if not visited[neighbor]:\n                    if dfs(neighbor, visited, stack):\n                        return True\n                elif stack[neighbor]:\n                    return True\n        stack[node] = False\n        return False\n    \n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n    stack = [False] * num_nodes\n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(node, visited, stack):\n                return True\n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate an adjacency matrix representing a directed graph.\"\"\"\n    graph = [[0, 1, 0, 0],\n             [0, 0, 1, 0],\n             [0, 0, 0, 1],\n             [1, 0, 0, 0]]\n    return graph\n\nassert f(g())\n",
        "idx_generation": 451,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there exists a pair of numbers whose sum is equal to the target.\n    Return True if such pair exists, False otherwise.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Generate a sorted list of integers and a target number.\"\"\"\n    return [1, 3, 5, 7, 9], 12\n\nassert f(*g()) == True\n",
        "idx_generation": 117,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence.\n    An increasing subsequence is a sequence of numbers in the list that are in increasing order, but not necessarily contiguous.\"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 350,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, check if there exists a subarray of length 3 where the sum of the first two numbers in the subarray is equal to the third number.\n    Return True if such a subarray exists, False otherwise.\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    The subarray [1, 2, 3] satisfies the condition since 1 + 2 = 3.\n    Therefore, the answer is True.\n    \"\"\"\n    for i in range(len(nums) - 2):\n        if nums[i] + nums[i + 1] == nums[i + 2]:\n            return True\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g())\n",
        "idx_generation": 48,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, calculate the number of ways to form a staircase with n steps.\n    Each step can either be climbed as a single step or a double step.\n    Return the total number of unique ways to climb the staircase.\n    \"\"\"\n    if n <= 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\ndef g():\n    return 5\n\nassert f(g()) == 8\n",
        "idx_generation": 192,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"Given two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t.\"\"\"\n    if len(s) != len(t):\n        return False\n    \n    mapping = {}\n    used = set()\n    for i in range(len(s)):\n        if s[i] not in mapping and t[i] not in used:\n            mapping[s[i]] = t[i]\n            used.add(t[i])\n        elif s[i] in mapping and mapping[s[i]] == t[i]:\n            continue\n        else:\n            return False\n    return True\n\ndef g(s='', t=''):\n    return s, t\n\nassert f(*g())\n",
        "idx_generation": 73,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(n: int, m: int) -> bool:\n    \"\"\"\n    Given two integers n and m, determine if n is a prime number and m is a perfect square.\n    Return True if n is prime and m is a perfect square, otherwise return False.\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    def is_perfect_square(num):\n        return math.isqrt(num) ** 2 == num\n    \n    return is_prime(n) and is_perfect_square(m)\n\ndef g():\n    return 17, 144\n\nassert f(*g())\n\n",
        "idx_generation": 166,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> int:\n    \"\"\"Given a binary tree, find the maximum depth.\n    The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\"\"\"\n    if root is None:\n        return 0\n\n    left_depth = f(root.left)\n    right_depth = f(root.right)\n\n    return max(left_depth, right_depth) + 1\n\ndef g():\n    # Create a binary tree\n    #       3\n    #      / \\\n    #     9   20\n    #        /  \\\n    #       15   7\n    root = TreeNode(3)\n    root.left = TreeNode(9)\n    root.right = TreeNode(20)\n    root.right.left = TreeNode(15)\n    root.right.right = TreeNode(7)\n\n    return root\n\nassert f(g()) == 3\n",
        "idx_generation": 451,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target=10) -> bool:\n    \"\"\"Find a pair of distinct integers in arr that sum up to target\"\"\"\n    arr.sort()\n    left, right = 0, len(arr) - 1\n    while left < right:\n        total = arr[left] + arr[right]\n        if total == target:\n            return True\n        elif total < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target=10):\n    return arr\n\nassert f(g())\n",
        "idx_generation": 118,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers 'nums', find the longest increasing subsequence (LIS) in the list.\n    Return the LIS as a list of integers.\"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    max_length = max(dp)\n    lis = []\n    for i in range(n-1, -1, -1):\n        if dp[i] == max_length:\n            lis.append(nums[i])\n            max_length -= 1\n    return lis[::-1]\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"Returns the list of integers\"\"\"\n    return nums\n\nassert f(g(nums=[4, 2, 7, 1, 3, 5])) == [1, 3, 5]\n",
        "idx_generation": 357,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a number is a prime number\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    \"\"\"Generate the next prime number\"\"\"\n    i = 2\n    while True:\n        if f(i):\n            yield i\n        i += 1\n\nassert f(next(g()))\n",
        "idx_generation": 53,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Find the maximum sum of a subarray in the given array.\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in arr:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef g(arr=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    \"\"\"Generate an array with both positive and negative numbers.\"\"\"\n    return arr\n\nassert f(g()) == 6\n",
        "idx_generation": 194,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"Check if a given string is a palindrome after removing exactly one character from it.\"\"\"\n    left = 0\n    right = len(string) - 1\n    while left < right:\n        if string[left] != string[right]:\n            return string[left:right] == string[left:right][::-1] or string[left+1:right+1] == string[left+1:right+1][::-1]\n        left += 1\n        right -= 1\n    return True\n\ndef g():\n    return \"level\"\n\nassert f(g())\n",
        "idx_generation": 78,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a non-negative integer n, count all numbers with unique digits, x, where 0 \u2264 x < 10^n.\"\"\"\n    if n == 0:\n        return 1\n    \n    count = 10\n    unique_digits = 9\n    available_digits = 9\n    \n    for i in range(2, n+1):\n        unique_digits *= available_digits\n        count += unique_digits\n        available_digits -= 1\n    \n    return count\n\ndef g():\n    return 3\n\nassert f(g()) == 739\n",
        "idx_generation": 187,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there is a path from the start node to the end node in a directed graph.\n    Return True if a path exists, and False otherwise.\"\"\"\n    \n    def dfs(graph: List[List[int]], node: int, visited: set) -> bool:\n        \"\"\"Depth-first search to find a path from the start node to the end node.\"\"\"\n        \n        if node == end:\n            return True\n        \n        if node in visited:\n            return False\n        \n        visited.add(node)\n        \n        for neighbor in graph[node]:\n            if dfs(graph, neighbor, visited):\n                return True\n        \n        return False\n    \n    visited = set()\n    return dfs(graph, start, visited)\n\ndef g() -> tuple:\n    \"\"\"Generate a directed graph and the start and end nodes.\"\"\"\n    graph = [[1, 2], [2], [3], [4], []]\n    start = 0\n    end = 4\n    return graph, start, end\n\nassert f(*g())\n",
        "idx_generation": 452,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the given list whose sum is equal to the target.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    \"\"\"Generate a list of numbers and a target sum.\"\"\"\n    nums = [5, 7, 2, 10, 4]\n    target = 12\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 120,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target integer, determine if there exists a pair of integers in the list that sum up to the target.\n    Return True if such a pair exists, False otherwise.\"\"\"\n    start = 0\n    end = len(arr) - 1\n\n    while start < end:\n        current_sum = arr[start] + arr[end]\n        if current_sum == target:\n            return True\n        elif current_sum > target:\n            end -= 1\n        else:\n            start += 1\n\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Generate a sorted list of integers and a target integer.\"\"\"\n    return [1, 2, 3, 4, 5], 9\n\nassert f(*g())\n",
        "idx_generation": 371,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string is a palindrome.\"\"\"\n    return s == s[::-1]\n\ndef g():\n    return 'racecar'\n\nassert f(g())\n",
        "idx_generation": 55,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number is a prime number\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    n = 1\n    while not f(n):\n        n += 1\n    return n\n\nassert f(g())\n",
        "idx_generation": 195,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"Given a string, find the length of the longest substring without repeating characters.\n    \"\"\"\n    max_length = 0\n    start = 0\n    char_map = {}\n    for i, char in enumerate(s):\n        if char in char_map and start <= char_map[char]:\n            start = char_map[char] + 1\n        else:\n            max_length = max(max_length, i - start + 1)\n        char_map[char] = i\n    return max_length\n\ndef g():\n    return \"abcabcbb\"\n\nassert f(g()) == 3\n",
        "idx_generation": 78,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given an integer n, calculate the number of subsets of a set with n elements.\"\"\"\n    return 2**n\n\ndef g(n: int = 3):\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 190,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of 0s and 1s, find the number of unique paths from the top-left corner to the bottom-right corner.\n    You can only move down or right. Each 1 represents an obstacle that cannot be crossed.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def dfs(i, j):\n        if i == rows-1 and j == cols-1:\n            return 1\n        if i >= rows or j >= cols or grid[i][j] == 1:\n            return 0\n        \n        return dfs(i+1, j) + dfs(i, j+1)\n    \n    return dfs(0, 0)\n\ndef g():\n    return [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n\nassert f(g()) == 2\n",
        "idx_generation": 460,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers and a target value, determine if there are two numbers in the array that add up to the target.\n    Return True if such a pair exists, otherwise return False.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(arr: List[int], target: int) -> List[int]:\n    \"\"\"Generate a sorted array of integers and a target value, where there are two numbers in the array that add up to the target.\"\"\"\n    arr.sort()\n    return arr, target\n\nassert f(*g(arr=[1, 2, 3, 4, 5], target=7))\n",
        "idx_generation": 122,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n    An increasing subsequence is a subsequence in which the elements are in increasing order,\n    but not necessarily consecutive.\n    \"\"\"\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g(nums=[3, 6, 2, 8, 4, 5, 7]):\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 373,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number is a perfect number.\"\"\"\n    if n <= 0:\n        return False\n    factors = []\n    for i in range(1, n):\n        if n % i == 0:\n            factors.append(i)\n    return sum(factors) == n\n\ndef g():\n    n = 1\n    while True:\n        if f(n):\n            return n\n        n += 1\n\nassert f(g())\n",
        "idx_generation": 57,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a number n, calculate the factorial of n using recursion.\n    The factorial of a number is the product of all positive integers from 1 to n.\n    \"\"\"\n    if n == 0:\n        return 1\n    else:\n        return n * f(n-1)\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == 120\n",
        "idx_generation": 201,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"Check if a given string 's' can be formed by concatenating words from the given list 'words'.\"\"\"\n    stack = []\n    stack.append(0)\n    n = len(s)\n    while stack:\n        start = stack.pop()\n        if start == n:\n            return True\n        for word in words:\n            end = start + len(word)\n            if end <= n and s[start:end] == word:\n                stack.append(end)\n    return False\n\ndef g():\n    return \"leetcode\", [\"leet\", \"code\"]\n\nassert f(*g())\n",
        "idx_generation": 79,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Calculate the sum of all primes in a given list of integers.\"\"\"\n    res = 0\n    for num in nums:\n        if is_prime(num):\n            res += num\n    return res\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g(nums: List[int]) -> int:\n    return f(nums)\n\nnums = [2, 3, 4, 5, 6, 7, 8, 9, 10]\nassert f(nums) == g(nums)\n",
        "idx_generation": 230,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, target: int) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency list and two nodes, determine if there is a path from the start node to the target node.\"\"\"\n    visited = [False] * len(graph)\n\n    def dfs(graph: List[List[int]], node: int, target: int) -> bool:\n        if node == target:\n            return True\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor] and dfs(graph, neighbor, target):\n                return True\n        return False\n\n    return dfs(graph, start, target)\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a directed graph represented as an adjacency list and two nodes.\"\"\"\n    graph = [[1, 2], [2], []]\n    start = 0\n    target = 2\n    return graph, start, target\n\nassert f(*g())\n",
        "idx_generation": 473,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum product of any two numbers in the list.\n    Return the maximum product.\n    \"\"\"\n    max_product = 0\n    \n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n    \n    return max_product\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [2, 5, 3, 10, 4]\n    \n    return nums\n\nassert f(g()) == 50\n\n",
        "idx_generation": 123,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int, k: int) -> bool:\n    \"\"\"Given a list of integers and a target value, find whether it is possible to select k numbers from the list that sum up to the target value.\n    Return True if it is possible, otherwise return False.\n    \"\"\"\n    def helper(nums: List[int], target: int, k: int) -> bool:\n        if k == 0:\n            return target == 0\n        if not nums or target < nums[0] * k or target > nums[-1] * k:\n            return False\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            if helper(nums[i+1:], target-nums[i], k-1):\n                return True\n        return False\n\n    nums.sort()\n    return helper(nums, target, k)\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n    k = 3\n    return nums, target, k\n\nassert f(*g())\n",
        "idx_generation": 376,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(x: int, a=2, b=9) -> bool:\n    \"\"\"Check if x is a perfect square between a and b (inclusive).\"\"\"\n    return a <= x <= b and int(x ** 0.5) ** 2 == x\ndef g(a=2, b=9):\n    for x in range(a, b+1):\n        if int(x ** 0.5) ** 2 == x:\n            return x\nassert f(g())\n",
        "idx_generation": 58,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the nth Fibonacci number\"\"\"\n    if n <= 1:\n        return n\n    else:\n        return f(n-1) + f(n-2)\n\ndef g(n: int) -> int:\n    \"\"\"Return the value of n\"\"\"\n    return n\n\nassert f(g(6)) == 8\n",
        "idx_generation": 201,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(sentence: str) -> bool:\n    \"\"\"Given a sentence, check if it is a palindrome.\"\"\"\n    sentence = ''.join(filter(str.isalpha, sentence)).lower()\n    return sentence == sentence[::-1]\n\ndef g() -> str:\n    \"\"\"Generate a palindrome sentence.\"\"\"\n    return \"Able, was I saw eLba\"\n\nassert f(g()) == True\n",
        "idx_generation": 81,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Compute the sum of the first n natural numbers.\"\"\"\n    return n * (n + 1) // 2\n\ndef g():\n    n = 100\n    return n\n\nassert f(g()) == 5050\n",
        "idx_generation": 236,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of non-negative integers, find the shortest path from the top-left corner to the bottom-right corner, only moving right or down.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[float('inf')] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(rows):\n        for j in range(cols):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j])\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j])\n\n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a grid of non-negative integers.\"\"\"\n    grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 473,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"Determine if string s can be rearranged to form string t.\"\"\"\n    return sorted(s) == sorted(t)\n\ndef g(t: str) -> str:\n    \"\"\"Find a string that can be rearranged to form string t.\"\"\"\n    return ''.join(sorted(t))\n\nassert f(g(\"programming\"), \"gnimmargorp\")\n",
        "idx_generation": 124,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"Check if there exists two elements in the given list whose sum is equal to k.\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == k:\n            return True\n        elif arr[left] + arr[right] < k:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    arr = [1, 4, 2, 6, 5, 3]\n    k = 8\n    return arr, k\n\nassert f(*g())\n",
        "idx_generation": 383,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(x: int, a=1, b=100) -> bool:\n    \"\"\"Check if x is a prime number or a perfect square between a and b (inclusive).\"\"\"\n    return a <= x <= b and (all(x % i != 0 for i in range(2, int(x ** 0.5) + 1)) or int(x ** 0.5) ** 2 == x)\ndef g(a=1, b=100):\n    for x in range(a, b+1):\n        if all(x % i != 0 for i in range(2, int(x ** 0.5) + 1)) or int(x ** 0.5) ** 2 == x:\n            return x\nassert f(g())\n",
        "idx_generation": 58,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the length of the longest increasing subsequence in nums\"\"\"\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"Return the list of nums\"\"\"\n    return nums\n\nassert f(g([10, 9, 2, 5, 3, 7, 101, 18])) == 4\n",
        "idx_generation": 201,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Check if s2 can be formed by rearranging characters of s1\"\"\"\n    count1 = [0] * 26\n    count2 = [0] * 26\n    \n    for char in s1:\n        count1[ord(char) - ord('a')] += 1\n    \n    for char in s2:\n        count2[ord(char) - ord('a')] += 1\n    \n    return count1 == count2\n\ndef g(s1: str = \"abcdefg\", s2: str = \"gfedcba\"):\n    return s1, s2\n\nassert f(*g())\n",
        "idx_generation": 82,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n=4) -> bool:\n    \"\"\"Find the smallest number that is divisible by all integers from 1 to n (inclusive).\"\"\"\n    for i in range(1, n+1):\n        if int(s) % i != 0:\n            return False\n    return True\n\ndef g(n=4):\n    def gcd(a, b):\n        while b != 0:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return (a * b) // gcd(a, b)\n\n    result = 1\n    for i in range(2, n+1):\n        result = lcm(result, i)\n    return str(result)\n\nassert f(g())\n",
        "idx_generation": 248,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given an adjacency matrix of a directed graph, determine if there exists a Hamiltonian path in the graph.\"\"\"\n    def dfs(curr, visited):\n        visited[curr] = True\n        if all(visited):\n            return True\n        for i in range(len(matrix)):\n            if matrix[curr][i] == 1 and not visited[i]:\n                if dfs(i, visited):\n                    return True\n        visited[curr] = False\n        return False\n    return any(dfs(i, [False] * len(matrix)) for i in range(len(matrix)))\ndef g():\n    return [[0, 1, 1, 0],\n            [0, 0, 1, 1],\n            [1, 0, 0, 1],\n            [1, 0, 0, 0]]\nassert f(g())\n",
        "idx_generation": 478,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the given list is sorted in non-decreasing order.\"\"\"\n    return all(arr[i] <= arr[i+1] for i in range(len(arr)-1))\n\ndef g(arr: List[int]):\n    \"\"\"Sort the given list in non-decreasing order.\"\"\"\n    return sorted(arr)\n\nassert f(g([3, 1, 4, 1, 5, 9, 2, 6, 5, 3]))\n",
        "idx_generation": 124,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted array of integers nums and a target value, find the index of the first occurrence of the target in the array.\n    If the target is not found, return -1.\"\"\"\n    \n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            if mid == 0 or nums[mid - 1] != target:\n                return mid\n            else:\n                right = mid - 1\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"Return a sorted array of integers and a target value.\"\"\"\n    nums.sort()\n    return nums, target\n\nassert f(*g(nums=[1, 2, 2, 3, 4, 5, 5, 6, 7], target=5)) == 5\n\n",
        "idx_generation": 383,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]], target=5) -> bool:\n    \"\"\"Check if a target number exists in a 2D matrix.\"\"\"\n    return any(target in row for row in matrix)\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]], target=5):\n    return any(target in row for row in matrix)\nassert f(g())\n",
        "idx_generation": 59,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, return the nth Fibonacci number\"\"\"\n    if n <= 1:\n        return n\n    \n    fib = [0, 1]\n    for i in range(2, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2])\n    \n    return fib[n]\n\ndef g(n: int = 6):\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 206,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[str]], target='python') -> bool:\n    \"\"\"Given a matrix of characters, find the number of occurrences of the target string, considering all possible directions: horizontally, vertically, and diagonally\"\"\"\n    count = 0\n    rows = len(matrix)\n    cols = len(matrix[0])\n    for i in range(rows):\n        for j in range(cols):\n            if matrix[i][j] == target[0]:\n                for dx, dy in [(0, 1), (1, 0), (1, 1)]:\n                    x, y = i, j\n                    k = 0\n                    while 0 <= x < rows and 0 <= y < cols and k < len(target) and matrix[x][y] == target[k]:\n                        x += dx\n                        y += dy\n                        k += 1\n                    if k == len(target):\n                        count += 1\n    return count\ndef g(target='python'):\n    matrix = [\n        ['p', 'y', 't', 'h', 'o', 'n'],\n        ['o', 'x', 'y', 'z', 'a', 'b'],\n        ['t', 'h', 'o', 'n', 'p', 'y'],\n        ['a', 'b', 'c', 'd', 'e', 'f'],\n    ]\n    return matrix\nassert f(g())\n",
        "idx_generation": 89,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of integers, check if it is a diagonal matrix.\n    A diagonal matrix is a square matrix in which all the elements outside the main diagonal (from top-left to bottom-right) are zero.\n    Return True if the matrix is a diagonal matrix, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    for i in range(n):\n        for j in range(n):\n            if i != j and matrix[i][j] != 0:\n                return False\n    return True\n\ndef g():\n    matrix = [[1, 0, 0],\n              [0, 2, 0],\n              [0, 0, 3]]\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 255,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(edges: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a list of edges in a directed graph, determine if there is a path from the start node to the end node.\"\"\"\n    graph = {}\n    for edge in edges:\n        u, v = edge\n        if u in graph:\n            graph[u].append(v)\n        else:\n            graph[u] = [v]\n\n    visited = set()\n\n    def dfs(node):\n        visited.add(node)\n        if node == end:\n            return True\n        if node in graph:\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    if dfs(neighbor):\n                        return True\n        return False\n\n    return dfs(start)\n\ndef g():\n    edges = [[1, 2], [2, 3], [3, 4], [4, 5]]\n    start = 1\n    end = 5\n    return edges, start, end\n\nassert f(*g())\n\n",
        "idx_generation": 479,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list that sum up to the target value.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(nums=[2, 4, 7, 11, 15], target=9):\n    return nums\n\nassert f(g(), target=9)\n",
        "idx_generation": 125,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers, find the index of the first occurrence of the target number using binary search.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == target and (mid == 0 or arr[mid - 1] != target):\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g() -> List[int]:\n    return [1, 3, 3, 5, 7, 9, 11, 13]\n\nassert f(g(), 3) == 1\n",
        "idx_generation": 384,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"Check if a given string is a valid palindrome after removing at most one character.\"\"\"\n    def is_palindrome(s, i, j):\n        while i < j:\n            if s[i] != s[j]:\n                return False\n            i += 1\n            j -= 1\n        return True\n    \n    i = 0\n    j = len(string) - 1\n    while i < j:\n        if string[i] != string[j]:\n            return is_palindrome(string, i + 1, j) or is_palindrome(string, i, j - 1)\n        i += 1\n        j -= 1\n    return True\n\ndef g(string: str):\n    return string\n\nassert f(g(\"abca\"))\n",
        "idx_generation": 67,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Given a 2D grid of positive integers, find the maximum sum of a path starting at the top-left cell and ending at the bottom-right cell.\n    You can only move down or right. Return the maximum sum.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = matrix[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    return dp[rows-1][cols-1]\n\ndef g(matrix: List[List[int]]) -> List[List[int]]:\n    return matrix\n\nmatrix = [\n    [1, 3, 1],\n    [1, 5, 1],\n    [4, 2, 1]\n]\nassert f(g(matrix)) == 12\n",
        "idx_generation": 209,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n    Sample Input:\n    s = \"madam\"\n    Sample Output:\n    True\"\"\"\n    return s == s[::-1]\n\ndef g(s=\"madam\") -> str:\n    \"\"\"Return the given string\"\"\"\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 95,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if the given matrix is a magic square, where the sum of each row, column, and diagonal is the same.\"\"\"\n    n = len(matrix)\n    target_sum = n * (n ** 2 + 1) // 2\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        if sum(row[col] for row in matrix) != target_sum:\n            return False\n\n    # Check diagonals\n    if sum(matrix[i][i] for i in range(n)) != target_sum:\n        return False\n    if sum(matrix[i][n-i-1] for i in range(n)) != target_sum:\n        return False\n\n    return True\n\ndef g():\n    return ([[2, 7, 6], [9, 5, 1], [4, 3, 8]],)\n\nassert f(*g())\n",
        "idx_generation": 257,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(adj_list: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency list of a directed graph, determine if there is a cycle in the graph.\n    Sample Input:\n    adj_list = [[1, 2], [2], []]\n    Sample Output:\n    False\n    \"\"\"\n    visited = [False] * len(adj_list)\n    recursion_stack = [False] * len(adj_list)\n    for node in range(len(adj_list)):\n        if not visited[node] and is_cyclic_util(adj_list, node, visited, recursion_stack):\n            return True\n    return False\n\ndef is_cyclic_util(adj_list: List[List[int]], node: int, visited: List[bool], recursion_stack: List[bool]) -> bool:\n    visited[node] = True\n    recursion_stack[node] = True\n    for neighbor in adj_list[node]:\n        if not visited[neighbor]:\n            if is_cyclic_util(adj_list, neighbor, visited, recursion_stack):\n                return True\n        elif recursion_stack[neighbor]:\n            return True\n    recursion_stack[node] = False\n    return False\n\ndef g():\n    return [[1, 2], [2], []]\n\nassert f(g()) == False\n",
        "idx_generation": 481,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target number, determine if there are two numbers in the list that add up to the target.\n\n    Args:\n        nums (List[int]): The sorted list of integers.\n        target (int): The target number.\n\n    Returns:\n        bool: True if there are two numbers that add up to the target, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        total = nums[left] + nums[right]\n        if total == target:\n            return True\n        elif total < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(nums: List[int], target: int) -> bool:\n    return f(nums, target)\n\nnums = [1, 2, 3, 4, 5]\ntarget = 7\nassert f(nums, target) == g(nums, target)\n",
        "idx_generation": 127,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers, determine if there are two numbers in the array that add up to the target value.\"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 15\n\nassert f(*g())\n",
        "idx_generation": 393,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target sum, find a pair of numbers in the list that add up to the target sum.\"\"\"\n    num_set = set()\n    \n    for num in nums:\n        complement = target - num\n        if complement in num_set:\n            return True\n        num_set.add(num)\n    \n    return False\n\ndef g(target: int = 10):\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g(), target=10) == True\n",
        "idx_generation": 75,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=16) -> bool:\n    \"\"\"Given a list of integers and a target sum, determine if it is possible to form the target sum using a combination\n    of the given integers, with repetition allowed. Return True if possible, False otherwise.\n    Sample input:\n    [2, 4, 6, 8]\n    Sample output:\n    True\n    Explanation: 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 = 16\"\"\"\n    def dp(nums, target):\n        if target < 0:\n            return False\n        if target == 0:\n            return True\n        if target in memo:\n            return memo[target]\n        for num in nums:\n            if dp(nums, target - num):\n                memo[target] = True\n                return True\n        memo[target] = False\n        return False\n\n    memo = {}\n    return dp(nums, target)\n\ndef g():\n    return [2, 4, 6, 8]\n\nassert f(g())\n",
        "idx_generation": 210,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string, check if it is a palindrome after removing all non-alphanumeric characters and ignoring case.\"\"\"\n    s = ''.join(ch.lower() for ch in s if ch.isalnum())\n    return s == s[::-1]\n\ndef g():\n    return \"A man, a plan, a canal: Panama!\"\n\nassert f(g())\n",
        "idx_generation": 104,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find if the given number is a prime number.\"\"\"\n    if n <= 1:\n        return False\n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n\n    return True\n\ndef g():\n    n = 2\n    while True:\n        if f(n):\n            return n\n        n += 1\n\nassert f(g()) == True\n",
        "idx_generation": 260,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Graph:\n    def __init__(self, vertices: int):\n        self.vertices = vertices\n        self.adj_list = [[] for _ in range(vertices)]\n\n    def add_edge(self, u: int, v: int, weight: int):\n        self.adj_list[u].append((v, weight))\n\n    def shortest_path(self, start: int, end: int) -> List[int]:\n        distances = [float('inf')] * self.vertices\n        distances[start] = 0\n\n        queue = [start]\n        while queue:\n            node = queue.pop(0)\n            for neighbor, weight in self.adj_list[node]:\n                if distances[node] + weight < distances[neighbor]:\n                    distances[neighbor] = distances[node] + weight\n                    queue.append(neighbor)\n\n        return distances[end]\n\ndef f(min_weight: int, max_weight: int) -> bool:\n    \"\"\"Check if there exists a path in the graph where the sum of weights is between min_weight and max_weight (inclusive)\"\"\"\n    graph = Graph(4)\n    graph.add_edge(0, 1, 2)\n    graph.add_edge(1, 2, 3)\n    graph.add_edge(2, 3, 4)\n    graph.add_edge(3, 0, 5)\n\n    shortest_path_weight = graph.shortest_path(0, 3)\n    return min_weight <= shortest_path_weight <= max_weight\n\ndef g(min_weight=8, max_weight=10):\n    return (min_weight, max_weight)\n\nassert f(*g())\n",
        "idx_generation": 482,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target number, determine if the target number is present in the list using binary search.\n    Return True if the target number is found, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef g():\n    nums = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n    target = 11\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 128,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum sum of a subarray.\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\n\nassert f(g()) == 6\n\n",
        "idx_generation": 398,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a number is a perfect square\"\"\"\n    if n < 0:\n        return False\n    root = int(n ** 0.5)\n    return root * root == n\n\ndef g():\n    return 25  # Return a perfect square number\n\nassert f(g()) == True\n",
        "idx_generation": 76,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=0) -> bool:\n    \"\"\"Given a list of integers and a target value, return True if there exists a subset of the integers that\n    adds up to the target, and False otherwise.\n    Example:\n    Input: nums = [2, 4, 6, 8], target = 10\n    Output: True\n    Explanation: There exists a subset [2, 8] that adds up to the target value 10.\"\"\"\n    def subset_sum(nums: List[int], target: int, index: int, memo: dict) -> bool:\n        if target == 0:\n            return True\n        if index >= len(nums):\n            return False\n        if (index, target) in memo:\n            return memo[(index, target)]\n        include = subset_sum(nums, target - nums[index], index + 1, memo)\n        exclude = subset_sum(nums, target, index + 1, memo)\n        memo[(index, target)] = include or exclude\n        return memo[(index, target)]\n    \n    return subset_sum(nums, target, 0, {})\n\ndef g(nums=[2, 4, 6, 8], target=10):\n    return nums\n\nassert f(g())\n",
        "idx_generation": 216,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string, check if it is a valid palindrome after removing at most one character.\"\"\"\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    \n    n = len(s)\n    left, right = 0, n - 1\n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s[left:right]) or is_palindrome(s[left + 1:right + 1])\n        left += 1\n        right -= 1\n    return True\ndef g():\n    return \"racecar\"\nassert f(g())\n",
        "idx_generation": 111,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a number is a perfect square.\"\"\"\n    if n < 0:\n        return False\n    sqrt = int(n ** 0.5)\n    return sqrt * sqrt == n\ndef g(n=16):\n    return f(n)\nassert f(g())\n",
        "idx_generation": 275,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers, determine if two numbers in the array\n    sum up to the target value. Return True if such numbers exist, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5, 6]\n    target = 8\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 129,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of numbers is sorted in non-decreasing order\"\"\"\n    return all(nums[i] <= nums[i+1] for i in range(len(nums)-1))\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"Sort the given list of numbers in non-decreasing order\"\"\"\n    return sorted(nums)\n\nassert f(g([1, 2, 3, 4, 5])) == True\n",
        "idx_generation": 401,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of size m x n, return all elements of the matrix in spiral order.\n    \"\"\"\n    result = []\n    if not matrix:\n        return result\n    rows, cols = len(matrix), len(matrix[0])\n    top, bottom, left, right = 0, rows-1, 0, cols-1\n    while top <= bottom and left <= right:\n        for i in range(left, right+1):\n            result.append(matrix[top][i])\n        top += 1\n        for i in range(top, bottom+1):\n            result.append(matrix[i][right])\n        right -= 1\n        if top <= bottom:\n            for i in range(right, left-1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n        if left <= right:\n            for i in range(bottom, top-1, -1):\n                result.append(matrix[i][left])\n            left += 1\n    return result\n\ndef g(matrix: List[List[int]]):\n    \"\"\"\n    Generate a matrix of size m x n such that all elements of the matrix\n    can be returned in spiral order.\n    \"\"\"\n    return matrix\n\nassert f(g([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 77,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, find the nth Fibonacci number.\n    Return the nth Fibonacci number.\n    \"\"\"\n    if n <= 0:\n        return None\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return f(n-1) + f(n-2)\n\ndef g():\n    return 6\n\nassert f(g()) == 5\n\n",
        "idx_generation": 217,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string is a valid palindrome by ignoring non-alphanumeric characters and considering case sensitivity.\"\"\"\n    def is_palindrome(s):\n        s = ''.join(c.lower() for c in s if c.isalnum())\n        return s == s[::-1]\n    \n    return is_palindrome(s)\n\ndef g():\n    return \"A man, a plan, a canal: Panama\"\n\nassert f(g()) == True\n",
        "idx_generation": 111,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a given number is a perfect square.\"\"\"\n    if n < 0:\n        return False\n    x = n\n    while x * x > n:\n        x = (x + n // x) // 2\n    return x * x == n\n\ndef g():\n    return 49\n\nassert f(g())\n",
        "idx_generation": 314,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine if a given number is a prime number.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    n = 17\n    return n\n\nassert f(g())\n",
        "idx_generation": 129,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there exists a pair of numbers in the list\n    whose sum is equal to the target number. Return True if such a pair exists, False otherwise.\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(nums: List[int] = [2, 4, 6, 8, 10], target: int = 12) -> List[int]:\n    \"\"\"\n    Generate a list of integers that contains a pair whose sum is equal to the target number.\n    \"\"\"\n    return nums\n\nassert f(g(), 12) == True\n\n",
        "idx_generation": 406,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(points: List[List[int]]) -> int:\n    \"\"\"Given a list of points in a 2D coordinate system, find the minimum distance between any two points.\n    Return the square of the minimum distance.\"\"\"\n    min_distance = float('inf')\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            distance = (points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2\n            min_distance = min(min_distance, distance)\n    return min_distance\n\ndef g(points: List[List[int]]) -> int:\n    return f(points)\n\npoints = [[1, 2], [3, 4], [5, 6]]\nassert f(points) == g(points)\n",
        "idx_generation": 80,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the length of the longest increasing path.\n    An increasing path is defined as a path (from a starting point to an ending point) where all the elements along the path are increasing.\n    \"\"\"\n    if not matrix:\n        return 0\n    \n    rows = len(matrix)\n    cols = len(matrix[0])\n    dp = [[0] * cols for _ in range(rows)]\n    \n    def dfs(i, j):\n        if dp[i][j] != 0:\n            return dp[i][j]\n        \n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        max_length = 1\n        \n        for dx, dy in directions:\n            x = i + dx\n            y = j + dy\n            \n            if x >= 0 and x < rows and y >= 0 and y < cols and matrix[x][y] > matrix[i][j]:\n                max_length = max(max_length, 1 + dfs(x, y))\n        \n        dp[i][j] = max_length\n        return max_length\n    \n    longest_path = 0\n    \n    for i in range(rows):\n        for j in range(cols):\n            longest_path = max(longest_path, dfs(i, j))\n    \n    return longest_path\n\ndef g(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers from the given matrix where each element represents the length of the longest increasing path starting from that element.\n    \"\"\"\n    if not matrix:\n        return matrix\n    \n    rows = len(matrix)\n    cols = len(matrix[0])\n    dp = [[0] * cols for _ in range(rows)]\n    \n    def dfs(i, j):\n        if dp[i][j] != 0:\n            return dp[i][j]\n        \n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        max_length = 1\n        \n        for dx, dy in directions:\n            x = i + dx\n            y = j + dy\n            \n            if x >= 0 and x < rows and y >= 0 and y < cols and matrix[x][y] > matrix[i][j]:\n                max_length = max(max_length, 1 + dfs(x, y))\n        \n        dp[i][j] = max_length\n        return max_length\n    \n    for i in range(rows):\n        for j in range(cols):\n            dp[i][j] = dfs(i, j)\n    \n    return dp\n\nassert f(g(matrix=[[9, 9, 4], [6, 6, 8], [2, 1, 1]])) == 4\n",
        "idx_generation": 217,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a given string is a pangram, which means it contains every letter of the alphabet at least once.\n    Sample input:\n    s = \"The quick brown fox jumps over the lazy dog\"\n    Sample output:\n    True\n    \"\"\"\n    alphabet = set('abcdefghijklmnopqrstuvwxyz')\n    for char in s.lower():\n        if char.isalpha() and char in alphabet:\n            alphabet.remove(char)\n    return len(alphabet) == 0\n\ndef g():\n    return \"The quick brown fox jumps over the lazy dog\"\n\nassert f(g())\n",
        "idx_generation": 112,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the sum of all prime numbers in the given list of integers.\"\"\"\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    return sum(num for num in nums if is_prime(num))\n\ndef g() -> List[int]:\n    \"\"\"Generate a list of integers.\"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == 17\n",
        "idx_generation": 318,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there are two numbers in the given list that sum up to the target value.\n    Return True if there exists a pair of numbers that sum up to target, False otherwise.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    \"\"\"Generate a list of random numbers and a target value.\"\"\"\n    nums = [3, 5, 9, 2, 8, 1, 6]\n    target = 10\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 130,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the given array is a sorted sequence in non-decreasing order.\"\"\"\n    def is_sorted(start):\n        if start >= len(arr) - 1:\n            return True\n        if arr[start] > arr[start + 1]:\n            return False\n        return is_sorted(start + 1)\n    return is_sorted(0)\n\ndef g(arr: List[int]):\n    return arr\n\nassert f(g([1, 2, 3, 4, 5]))\n",
        "idx_generation": 408,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the Fibonacci sequence up to the nth term.\"\"\"\n    fib = [0, 1]\n    for i in range(2, n+1):\n        fib.append(fib[i-1] + fib[i-2])\n    return fib[n]\n\ndef g():\n    return 7  # Return the value of n\n\nassert f(g()) == 13\n",
        "idx_generation": 85,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"Count the number of unique paths from the top-left corner to the bottom-right corner in a grid\"\"\"\n    if n == 0 or m == 0:\n        return 0\n    \n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = 1\n\n    for i in range(n):\n        for j in range(m):\n            if i > 0 and j > 0:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n            elif i > 0:\n                dp[i][j] = dp[i-1][j]\n            elif j > 0:\n                dp[i][j] = dp[i][j-1]\n\n    return dp[n-1][m-1]\n\ndef g(n=3, m=3, grid=[[0, 0, 0], [0, 0, 0], [0, 0, 0]]):\n    return n, m, grid\n\nassert f(*g()) == 6\n",
        "idx_generation": 218,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Check if two strings are isomorphic.\n\n    Args:\n        s1 (str): The first string.\n        s2 (str): The second string.\n\n    Returns:\n        bool: True if the strings are isomorphic, False otherwise.\n\n    Example:\n        Input: s1 = \"egg\", s2 = \"add\"\n        Output: True\n        Explanation: The strings \"egg\" and \"add\" are isomorphic because each character in s1 can be replaced with a corresponding character in s2 while preserving the order.\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n    mapping = {}\n    used = set()\n    for c1, c2 in zip(s1, s2):\n        if c1 in mapping:\n            if mapping[c1] != c2:\n                return False\n        else:\n            if c2 in used:\n                return False\n            mapping[c1] = c2\n            used.add(c2)\n    return True\n\ndef g(s1: str, s2: str) -> bool:\n    return f(s1, s2)\n\ns1 = \"egg\"\ns2 = \"add\"\nassert f(s1, s2) == g(s1, s2)\n",
        "idx_generation": 114,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, find the n-th Fibonacci number.\n    The Fibonacci sequence is defined as follows: F(0) = 0, F(1) = 1, and F(i) = F(i-1) + F(i-2) for i >= 2.\n    Return the n-th Fibonacci number.\n    Example:\n    n = 6\n    The 6th Fibonacci number is 8.\n    Therefore, the answer is 8.\n    \"\"\"\n    fib = [0, 1]\n    for i in range(2, n+1):\n        fib.append(fib[i-1] + fib[i-2])\n    return fib[n]\n\ndef g():\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 333,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers that add up to the target.\n    Return True if there are, False otherwise.\"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find two numbers in the list that add up to the target.\"\"\"\n    sorted_nums = sorted(nums)\n    return sorted_nums\n\nnums = [2, 5, 7, 10, 15]\ntarget = 12\n\nassert f(g(nums, target), target)\n",
        "idx_generation": 130,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums', sort the list in descending order using the quicksort algorithm.\n    Return the sorted list.\n    \"\"\"\n    if len(nums) <= 1:\n        return nums\n\n    pivot = nums[len(nums) // 2]\n    left = [x for x in nums if x > pivot]\n    middle = [x for x in nums if x == pivot]\n    right = [x for x in nums if x < pivot]\n\n    return f(left) + middle + f(right)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [9, 3, 7, 2, 5]\n    \n    return nums\n\nassert f(g()) == [9, 7, 5, 3, 2]\n",
        "idx_generation": 408,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if a specific pattern exists in the given list of integers\"\"\"\n    pattern = [1, 2, 3]  # The pattern to search for\n    n = len(nums)\n    if n < len(pattern):\n        return False\n    for i in range(n - len(pattern) + 1):\n        if nums[i:i+len(pattern)] == pattern:\n            return True\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 1, 2, 3, 7, 8, 9]  # Modify the list of integers as needed\n\nassert f(g())\n",
        "idx_generation": 87,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the nth term of the Fibonacci sequence.\n    The Fibonacci sequence is defined as follows: F(0) = 0, F(1) = 1, and F(i) = F(i-1) + F(i-2) for i >= 2.\n    Return the nth term of the Fibonacci sequence.\n    \"\"\"\n    if n <= 1:\n        return n\n    else:\n        return f(n-1) + f(n-2)\n\ndef g():\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 219,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string, determine whether it is a palindrome after removing at most one character.\n\n    Example:\n    s = \"abcba\"\n\n    In this case, the function should return True, as \"abcba\" is already a palindrome.\n\n    Hint: This problem can be solved using two pointers approach.\n\n    Args:\n        s: A string.\n    \n    Returns:\n        A boolean indicating whether the string is a palindrome after removing at most one character.\n    \"\"\"\n    left = 0\n    right = len(s) - 1\n\n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s, left+1, right) or is_palindrome(s, left, right-1)\n        \n        left += 1\n        right -= 1\n\n    return True\n\ndef is_palindrome(s: str, left: int, right: int) -> bool:\n    while left < right:\n        if s[left] != s[right]:\n            return False\n        \n        left += 1\n        right -= 1\n    \n    return True\n\ndef g(s: str) -> str:\n    return s\n\nassert f(g(\"abcba\"))\n",
        "idx_generation": 116,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number is a perfect square.\"\"\"\n    if n < 0:\n        return False\n    if n == 0:\n        return True\n    low = 1\n    high = n // 2\n    while low <= high:\n        mid = (low + high) // 2\n        if mid * mid == n:\n            return True\n        elif mid * mid < n:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False\n\ndef g():\n    return 16\n\nassert f(g())\n",
        "idx_generation": 347,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the given list is a sorted list, either in ascending or descending order.\"\"\"\n    return arr == sorted(arr) or arr == sorted(arr, reverse=True)\n\ndef g():\n    \"\"\"Generate a list of integers in descending order.\"\"\"\n    return [i for i in range(10, 0, -1)]\n\nassert f(g())\n",
        "idx_generation": 131,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum. Return True if the maximum subarray sum is greater than or equal to zero, False otherwise.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum >= 0\n\ndef g(nums: List[int] = [-2, 1, -3, 4, -1, 2, 1, -5, 4]) -> List[int]:\n    \"\"\"\n    Generate a list of integers that will result in a maximum subarray sum greater than or equal to zero.\n    \"\"\"\n    return nums\n\nassert f(g())\n",
        "idx_generation": 411,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if a specific arithmetic sequence exists in the given list of integers\"\"\"\n    n = len(nums)\n    if n < 3:\n        return False\n    \n    diff = nums[1] - nums[0]  # The common difference of the arithmetic sequence\n    for i in range(2, n):\n        if nums[i] - nums[i-1] != diff:\n            return False\n    \n    return True\n\ndef g():\n    # Modify the list of integers as needed\n    return [1, 3, 5, 7, 9]\n\nassert f(g())\n",
        "idx_generation": 87,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Given two integers n and k, determine if it is possible to partition the set {1, 2, ..., n} into k subsets such that the sum of elements in each subset is equal.\n    Return True if such partition is possible, False otherwise.\"\"\"\n    if n % k != 0:\n        return False\n    target_sum = n // k\n    nums = [i for i in range(1, n + 1)]\n    return can_partition(nums, 0, k, target_sum)\n\ndef can_partition(nums: List[int], index: int, k: int, target_sum: int) -> bool:\n    if k == 1:\n        return True\n    if index == len(nums):\n        return False\n    for i in range(index, len(nums)):\n        if nums[i] > target_sum:\n            continue\n        if nums[i] == target_sum and can_partition(nums, i + 1, k - 1, target_sum):\n            return True\n        if can_partition(nums, i + 1, k, target_sum - nums[i]):\n            return True\n    return False\n\ndef g(n: int, k: int) -> Tuple[int, int]:\n    \"\"\"Generate two integers n and k.\"\"\"\n    return n, k\n\nassert f(*g(10, 2)) == True\n",
        "idx_generation": 221,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"Given a string, determine if it is a palindrome.\n    Return True if the string is a palindrome, False otherwise.\"\"\"\n    left = 0\n    right = len(string) - 1\n    \n    while left < right:\n        if string[left] != string[right]:\n            return False\n        left += 1\n        right -= 1\n    \n    return True\n\ndef g() -> str:\n    \"\"\"Generate a palindrome string.\"\"\"\n    return \"level\"\n\nassert f(g()) == True\n",
        "idx_generation": 117,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a number is a prime number.\"\"\"\n    if n <= 1:\n        return False\n    \n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            return False\n    \n    return True\n\ndef g():\n    return 17\n\nassert f(g())\n",
        "idx_generation": 358,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int, arr: List[int]) -> bool:\n    \"\"\"Given a sorted list of integers, find if there exists a pair of elements whose sum is equal to k.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        current_sum = arr[left] + arr[right]\n        \n        if current_sum == k:\n            return True\n        elif current_sum < k:\n            left += 1\n        else:\n            right -= 1\n            \n    return False\n\ndef g():\n    return (10, 15, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\nassert f(*g()) == True\n",
        "idx_generation": 132,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if the given target exists in the sorted list of numbers.\"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\ndef g(nums: List[int], target: int):\n    return sorted(nums)\n\nassert f(g([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5), 5)\n",
        "idx_generation": 412,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"Given a matrix of integers, rotate it 90 degrees clockwise.\n    Return the rotated matrix.\"\"\"\n    n = len(matrix)\n    m = len(matrix[0])\n    \n    rotated = [[0] * n for _ in range(m)]\n    \n    for i in range(n):\n        for j in range(m):\n            rotated[j][n - i - 1] = matrix[i][j]\n    \n    return rotated\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a matrix of integers.\"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 88,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence.\n    Return the length of the longest increasing subsequence.\"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"Generate a list of integers.\"\"\"\n    return nums\n\nassert f(g([10, 9, 2, 5, 3, 7, 101, 18])) == 4\n",
        "idx_generation": 221,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Given two strings s1 and s2, check if s2 is a rotation of s1.\n\n    Args:\n        s1 (str): The first string.\n        s2 (str): The second string.\n\n    Returns:\n        bool: True if s2 is a rotation of s1, False otherwise.\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n\n    s1s1 = s1 + s1\n\n    return s2 in s1s1\n\ndef g(s1: str, s2: str) -> bool:\n    return f(s1, s2)\n\ns1 = \"hello\"\ns2 = \"lohel\"\nassert f(s1, s2) == g(s1, s2)\n",
        "idx_generation": 127,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport collections\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a subarray with a sum equal to zero.\n    Return True if such subarray exists, False otherwise.\"\"\"\n    prefix_sum = 0\n    sum_counter = collections.Counter()\n\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum == 0 or sum_counter[prefix_sum] > 0:\n            return True\n        sum_counter[prefix_sum] += 1\n\n    return False\n\ndef g():\n    return [4, 2, -3, 1, 6]  # There exists a subarray [2, -3, 1] with a sum equal to zero\n\nassert f(g())\n",
        "idx_generation": 362,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers and a target value, determine if the target is present in the array.\n    Use binary search algorithm to solve the problem.\n    Sample input:\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 5\n    Sample output:\n    True\"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9], 5\n\nassert f(*g())\n",
        "idx_generation": 132,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the length of the longest increasing subsequence.\n    Return the length of the subsequence.\n    \"\"\"\n    n = len(arr)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate an array of integers.\n    \"\"\"\n    arr = [10, 22, 9, 33, 21, 50, 41, 60]\n    return arr\n\nassert f(g()) == 5\n\n",
        "idx_generation": 415,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if there exists a subarray in the given list of integers whose sum is equal to the product of its elements.\"\"\"\n    prefix_sum = [0]\n    current_sum = 0\n    \n    for num in nums:\n        current_sum += num\n        prefix_sum.append(current_sum)\n    \n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)+1):\n            subarray_sum = prefix_sum[j] - prefix_sum[i]\n            subarray_product = math.prod(nums[i:j])\n            \n            if subarray_sum == subarray_product:\n                return True\n    \n    return False\n\ndef g(nums: List[int]):\n    return nums\n\nassert f(g([2, 4, 6, 1, 3, 5]))\n",
        "idx_generation": 89,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, return the maximum sum of a subarray.\n    Sample input:\n    [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Sample output:\n    6\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 223,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, sub1='abc', sub2='def', sub3='ghi') -> bool:\n    \"\"\"Given a string and three substrings, determine if the string can be formed by concatenating the three substrings in any order.\"\"\"\n    return set(s) == set(sub1 + sub2 + sub3)\ndef g(sub1='abc', sub2='def', sub3='ghi'):\n    return sub1 + sub2 + sub3\nassert f(g())\n",
        "idx_generation": 128,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if n is a perfect square\"\"\"\n    return int(n ** 0.5) ** 2 == n\n\ndef g():\n    return 25\n\nassert f(g())\n",
        "idx_generation": 384,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, check if there are two numbers that add up to the target.\n    Return True if such numbers exist, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        \n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(target: int):\n    nums = [-2, 1, 3, 5, 6, 8, 10]\n    return nums, target\n\nassert f(*g(9))\n",
        "idx_generation": 134,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of distinct integers, and a target value, determine if the target is present in the array.\n    - Return True if the target is present, False otherwise.\n    - Use binary search algorithm to solve the problem.\"\"\"\n    def binary_search(arr, target, low, high):\n        if low > high:\n            return False\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] > target:\n            return binary_search(arr, target, low, mid - 1)\n        else:\n            return binary_search(arr, target, mid + 1, high)\n    \n    return binary_search(arr, target, 0, len(arr) - 1)\n\ndef g(arr: List[int], target: int):\n    return arr, target\n\nassert f(*g([1, 3, 5, 7, 9], 5))\n",
        "idx_generation": 420,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if a given matrix is symmetric.\n    A matrix is symmetric if it is equal to its transpose.\n    Sample input:\n    matrix = [[1, 2, 3],\n              [2, 4, 5],\n              [3, 5, 6]]\n    Sample output:\n    True\n    \"\"\"\n    transpose = [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]\n    return matrix == transpose\n\ndef g():\n    return [[1, 2, 3],\n            [2, 4, 5],\n            [3, 5, 6]]\n\nassert f(g())\n",
        "idx_generation": 91,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray.\n    Return the maximum sum.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g(nums: List[int] = [-2, 1, -3, 4, -1, 2, 1, -5, 4]) -> List[int]:\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 224,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, check if it is a palindrome.\n    \"\"\"\n    return s == s[::-1]\n\ndef g():\n    \"\"\"\n    Generate a palindrome string.\n    \"\"\"\n    return \"racecar\"\n\nassert f(g())\n",
        "idx_generation": 129,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Determine if a given matrix is a sparse matrix, where a sparse matrix is defined as a matrix in which the\n    majority of its elements are zero.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    non_zero_count = 0\n    for i in range(rows):\n        for j in range(cols):\n            if matrix[i][j] != 0:\n                non_zero_count += 1\n    return non_zero_count < rows * cols // 2\ndef g():\n    matrix = [[1, 0, 0], [0, 0, 0], [0, 0, 1]]\n    return matrix\nassert f(g())\n",
        "idx_generation": 385,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers, determine if there exists a pair of numbers that sum up to a given target.\n    Return True if such a pair exists, otherwise return False.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return ([1, 2, 3, 4, 5, 6, 7, 8, 9], 10)\n\nassert f(*g())\n",
        "idx_generation": 134,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"Check if the given target number is present in the grid.\"\"\"\n    def search(grid, target):\n        rows = len(grid)\n        cols = len(grid[0])\n        row = 0\n        col = cols - 1\n\n        while row < rows and col >= 0:\n            if grid[row][col] == target:\n                return True\n            elif grid[row][col] < target:\n                row += 1\n            else:\n                col -= 1\n        return False\n\n    return search(grid, target)\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    target = 5\n    return grid, target\n\nassert f(*g())\n",
        "idx_generation": 424,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if n is a prime number.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n/2) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef g(n=17):\n    return n\nassert f(g())\n",
        "idx_generation": 91,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"Count the number of ways to climb to the top of a staircase with n steps.\"\"\"\n    if n == 0 or n == 1:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    \n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    \n    return dp[n]\n\ndef g(n: int) -> int:\n    \"\"\"Return the value of n\"\"\"\n    return n\n\nassert f(g(5)) == 8\n",
        "idx_generation": 227,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> str:\n    \"\"\"Given a string, reverse the order of words in the string.\n    Return the reversed string.\n    \"\"\"\n    words = string.split()\n    reversed_string = ' '.join(words[::-1])\n    return reversed_string\n\ndef g():\n    string = \"Hello, World!\"\n    return string\n\nassert f(g()) == \"World! Hello,\"\n",
        "idx_generation": 134,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number is a perfect square.\n    A perfect square is a number that is equal to the square of an integer.\n    Return True if the number is a perfect square, otherwise return False.\n    Sample input:\n    16\n    Sample output:\n    True\"\"\"\n    if n < 0:\n        return False\n    sqrt = int(n ** 0.5)\n    return sqrt * sqrt == n\n\ndef g():\n    return 16\n\nassert f(g()) == True\n\n",
        "idx_generation": 387,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, return the number of prime numbers less than or equal to n.\"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2, n + 1):\n        if is_prime(i):\n            count += 1\n    return count\n\ndef g():\n    return 20\n\nassert f(g()) == 8\n",
        "idx_generation": 134,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers arr and a target integer, determine if there exist two distinct indices i and j in the array such that arr[i] + arr[j] == target.\n    Return True if such indices exist, False otherwise.\n    Example:\n    arr = [2, 5, 7, 11, 15]\n    target = 9\n    The array contains the indices i=0 and j=2, where arr[i] + arr[j] = 2 + 7 = 9.\n    Therefore, the answer is True.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    \n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    return [2, 5, 7, 11, 15], 9\n\nassert f(*g())\n",
        "idx_generation": 428,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, return the number of trailing zeroes in n factorial (n!).\"\"\"\n    count = 0\n    \n    while n >= 5:\n        n //= 5\n        count += n\n    \n    return count\n\ndef g() -> int:\n    \"\"\"Generate a positive integer.\"\"\"\n    return 30\n\nassert f(g()) == 7\n",
        "idx_generation": 92,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, find the maximum sum of a path from the top left to the bottom right.\n    You can only move down or right.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[rows - 1][cols - 1]\n\ndef g(grid: List[List[int]]) -> int:\n    return f(grid)\n\ngrid = [\n    [1, 3, 1],\n    [1, 5, 1],\n    [4, 2, 1]\n]\n\nassert f(grid) == g(grid)\n",
        "idx_generation": 229,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string s, determine if it is a palindrome after removing exactly one character.\n    Return True if it is possible, False otherwise.\n    Example:\n    s = \"radar\"\n    The string \"radar\" is a palindrome, so the answer is True.\n    \"\"\"\n    left = 0\n    right = len(s) - 1\n    while left < right:\n        if s[left] != s[right]:\n            return s[left:right] == s[left:right][::-1] or s[left+1:right+1] == s[left+1:right+1][::-1]\n        left += 1\n        right -= 1\n    return True\n\ndef g():\n    return \"radar\"\n\nassert f(g())\n",
        "idx_generation": 140,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the sum of the squares of the first n natural numbers.\"\"\"\n    total = 0\n    for i in range(1, n+1):\n        total += i**2\n    return total\n\ndef g():\n    return 5\n\nassert f(g()) == 55\n",
        "idx_generation": 388,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list whose sum is equal to the target.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 5, 3, 9, 2], 8  # Return the list of numbers and the target sum\n\nassert f(*g()) == True\n",
        "idx_generation": 134,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of numbers, find the length of the longest increasing subsequence.\"\"\"\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g():\n    return [10, 22, 9, 33, 21, 50, 41, 60]\n\nassert f(g()) == 5\n",
        "idx_generation": 429,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> bool:\n    \"\"\"Check if n is a prime number and m is a perfect square\"\"\"\n    is_prime = True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            is_prime = False\n            break\n    is_square = m**0.5 == int(m**0.5)\n    return is_prime and is_square\n\ndef g():\n    return 17, 16\n\nassert f(*g())\n",
        "idx_generation": 92,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[str]], word: str) -> bool:\n    \"\"\"Given a 2D grid of characters and a word, determine if the word exists in the grid.\n    The word can be constructed from adjacent letters (horizontally or vertically) in the grid.\n    Example:\n    grid = [\n        ['A', 'B', 'C', 'E'],\n        ['S', 'F', 'C', 'S'],\n        ['A', 'D', 'E', 'E']\n    ]\n    word = \"ABCCED\"\n    Output: True\"\"\"\n    rows, cols = len(grid), len(grid[0])\n    \n    def dfs(row, col, idx):\n        if idx == len(word):\n            return True\n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] != word[idx]:\n            return False\n        temp, grid[row][col] = grid[row][col], '#'\n        found = dfs(row+1, col, idx+1) or dfs(row-1, col, idx+1) or dfs(row, col+1, idx+1) or dfs(row, col-1, idx+1)\n        grid[row][col] = temp\n        return found\n\n    for i in range(rows):\n        for j in range(cols):\n            if dfs(i, j, 0):\n                return True\n    return False\n\ndef g():\n    grid = [\n        ['A', 'B', 'C', 'E'],\n        ['S', 'F', 'C', 'S'],\n        ['A', 'D', 'E', 'E']\n    ]\n    word = \"ABCCED\"\n    return grid, word\n\nassert f(*g())\n",
        "idx_generation": 231,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import itertools\nfrom typing import*\ndef f(s: str, target='abc') -> bool:\n    \"\"\"Check if the given string contains all characters in the target string, in any order\"\"\"\n    return all(char in s for char in target)\n    \ndef g(target='abc'):\n    from itertools import permutations\n    permutations_list = permutations(target)\n    for perm in permutations_list:\n        string = ''.join(perm)\n        if f(string, target):\n            return string\n    \nassert f(g())\n",
        "idx_generation": 142,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if there exists a pair of elements in the given list such that their sum is a perfect square\"\"\"\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if is_perfect_square(arr[i] + arr[j]):\n                return True\n    return False\n    \ndef g():\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    return arr\n\ndef is_perfect_square(n):\n    return int(n**0.5)**2 == n\n\nassert f(g())\n",
        "idx_generation": 397,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers nums, find the maximum product of three numbers from the list.\n    Return the maximum product.\n    Sample input:\n    nums = [1, 2, 3, 4]\n    Sample output:\n    24\"\"\"\n    nums.sort()\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\n\ndef g():\n    return [1, 2, 3, 4]\n\nassert f(g()) == 24\n",
        "idx_generation": 139,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there are k numbers in the list that sum up to the target.\n    Return True if there are, False otherwise.\n    \"\"\"\n    nums.sort()\n    return helper(nums, target, k, 0, [])\n\ndef helper(nums: List[int], target: int, k: int, start: int, curr: List[int]) -> bool:\n    if k == 0 and target == 0:\n        return True\n    if k == 0 or target < 0:\n        return False\n    for i in range(start, len(nums)):\n        if i > start and nums[i] == nums[i-1]:\n            continue\n        curr.append(nums[i])\n        if helper(nums, target-nums[i], k-1, i+1, curr):\n            return True\n        curr.pop()\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5], target=9, k=3) -> Tuple[List[int], int, int]:\n    \"\"\"\n    Return the given list, target number, and k value.\n    \"\"\"\n    return nums, target, k\n\nassert f(*g()) == True\n",
        "idx_generation": 430,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum product of any two numbers in the list.\"\"\"\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n    return max_product\n\ndef g():\n    return [1, 3, 5, 2, 4]  # Return a list of integers\n\nassert f(g()) == 20\n",
        "idx_generation": 94,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import itertools\nfrom typing import*\nfrom itertools import permutations\n\ndef f(nums: List[int], target_sum=100) -> bool:\n    \"\"\"Given a list of positive integers and a target sum, determine if there exists a subset of the integers that adds up to the target sum.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target_sum + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(target_sum + 1):\n            if j < nums[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n\n    return dp[n][target_sum]\n\ndef g(nums=[10, 20, 30, 40, 50]):\n    return nums\n\nassert f(g())\n",
        "idx_generation": 232,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, x: int, y: int) -> bool:\n    \"\"\"Check if there exists a substring of s that has a decimal representation divisible by x and a binary representation divisible by y\"\"\"\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            decimal = int(s[i:j])\n            binary = bin(decimal)[2:]\n            if decimal % x == 0 and int(binary) % y == 0:\n                return True\n    return False\n\ndef g(s: str, x: int, y: int):\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            decimal = int(s[i:j])\n            binary = bin(decimal)[2:]\n            if decimal % x == 0 and int(binary) % y == 0:\n                return s[i:j]\n    return None\n\nassert f(g(\"123456789\", 3, 4), 3, 4)\n",
        "idx_generation": 145,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(s: str, n=10) -> bool:\n    \"\"\"Determine if a given number is a perfect square.\"\"\"\n    return math.isqrt(int(s)) ** 2 == int(s)\n\ndef g(n=10):\n    return str(n ** 2)\n\nassert f(g())\n",
        "idx_generation": 398,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a sorted list of integers nums and a target number,\n    return the indices of two numbers from the list that add up to the target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    Sample input:\n    nums = [2, 7, 11, 15]\n    target = 9\n    Sample output:\n    [0, 1]\"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\ndef g():\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 139,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a sorted list of integers, find two numbers that sum up to the target value.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [nums[left], nums[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [3, 6]\n",
        "idx_generation": 431,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if a given list of integers is a palindrome sequence.\n\n    Args:\n        nums (List[int]): The list of integers.\n\n    Returns:\n        bool: True if the list is a palindrome sequence, False otherwise.\n    \"\"\"\n    return nums == nums[::-1]\n\ndef g(nums: List[int]) -> List[int]:\n    return nums\n\nnums = [1, 2, 3, 4, 5, 4, 3, 2, 1]\nassert f(g(nums))\n",
        "idx_generation": 94,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the minimum number of steps required to reach the bottom-right corner of the grid, starting from the top-left corner. You can only move right or down.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[float('inf')] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(rows):\n        for j in range(cols):\n            if i - 1 >= 0:\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] + grid[i][j])\n            if j - 1 >= 0:\n                dp[i][j] = min(dp[i][j], dp[i][j - 1] + grid[i][j])\n    return dp[rows - 1][cols - 1]\n\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 233,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str, substring='abc', count=2) -> bool:\n    \"\"\"Given a string, find if there exists a substring that occurs at least count number of times.\"\"\"\n    return string.count(substring) >= count\n\ndef g(substring='abc', count=2):\n    string = 'abcaabcabc'\n    return string\n\nassert f(g())\n",
        "idx_generation": 146,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, return the nth Fibonacci number.\n    The Fibonacci sequence starts with 0 and 1, and each subsequent number in the sequence is the sum of the two preceding ones.\n    Sample Input:\n    n = 6\n    Sample Output:\n    8\"\"\"\n    if n <= 1:\n        return n\n    else:\n        fib = [0, 1]\n        for i in range(2, n + 1):\n            fib.append(fib[i - 1] + fib[i - 2])\n        return fib[n]\n\ndef g(n: int) -> int:\n    \"\"\"Return the nth Fibonacci number.\"\"\"\n    if n <= 1:\n        return n\n    else:\n        fib = [0, 1]\n        for i in range(2, n + 1):\n            fib.append(fib[i - 1] + fib[i - 2])\n        return fib[n]\n\nassert f(n=6) == g(n=6)\n",
        "idx_generation": 406,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if the given list contains a pair of numbers whose sum is equal to the target.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9], target=10):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 140,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers, find the number of occurrences of a target value in the list.\n    Return the count of occurrences.\"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            count = 1\n            i = mid - 1\n            while i >= left and nums[i] == target:\n                count += 1\n                i -= 1\n\n            j = mid + 1\n            while j <= right and nums[j] == target:\n                count += 1\n                j += 1\n\n            return count\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return 0\n\ndef g():\n    return [1, 2, 2, 2, 3, 4, 4, 5, 5], 2\n\nassert f(*g()) == 3\n",
        "idx_generation": 436,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Find the maximum sum of a subarray in a 2D matrix.\n\n    Args:\n        matrix (List[List[int]]): The 2D matrix.\n\n    Returns:\n        int: The maximum sum of a subarray.\n\n    Example:\n        Input: matrix = [[1, 2, -3], [-4, 5, 6], [7, -8, 9]]\n        Output: 17\n        Explanation: The maximum sum is obtained by selecting the submatrix [[5, 6], [-8, 9]].\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    max_sum = float('-inf')\n\n    for left in range(cols):\n        temp = [0] * rows\n        for right in range(left, cols):\n            for i in range(rows):\n                temp[i] += matrix[i][right]\n            \n            # Kadane's algorithm to find the maximum sum of a subarray\n            curr_sum = max(temp[i] for i in range(rows))\n            max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g(matrix: List[List[int]]) -> int:\n    return f(matrix)\n\nmatrix = [[1, 2, -3], [-4, 5, 6], [7, -8, 9]]\nassert f(matrix) == g(matrix)\n",
        "idx_generation": 94,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum subarray sum.\n    Return the maximum sum.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 240,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"Given a string, determine if it is a palindrome.\n    Return True if the string is a palindrome, False otherwise.\n    \"\"\"\n    string = string.lower().replace(\" \", \"\")\n    left = 0\n    right = len(string) - 1\n    while left < right:\n        if string[left] != string[right]:\n            return False\n        left += 1\n        right -= 1\n    return True\n\ndef g():\n    string = \"Able was I saw Elba\"\n    return string\n\nassert f(g())\n",
        "idx_generation": 147,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number is a prime number.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    \"\"\"Find the largest prime number less than or equal to 100.\"\"\"\n    for num in range(100, 1, -1):\n        if f(num):\n            return num\n\nassert f(g())\n",
        "idx_generation": 416,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target=10) -> bool:\n    \"\"\"Given a list of integers and a target value, find three distinct integers from the list that sum up to the target value.\n    Return True if such integers exist, False otherwise.\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 10\n    The possible combinations are (1, 2, 7), (1, 3, 6), and (2, 3, 5).\n    Therefore, the answer is True.\n    \"\"\"\n    arr.sort()\n    for i in range(len(arr)-2):\n        left = i + 1\n        right = len(arr) - 1\n        while left < right:\n            curr_sum = arr[i] + arr[left] + arr[right]\n            if curr_sum == target:\n                return True\n            elif curr_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g(arr=[1, 2, 3, 4, 5], target=10):\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 140,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers that sum up to the target.\n    Return True if such pair exists, otherwise return False.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return ([1, 2, 3, 4, 5, 6, 7, 8, 9], 10)\n\nassert f(*g())\n\n",
        "idx_generation": 436,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find two numbers in a given list that sum up to the target value.\n\n    Args:\n        nums (List[int]): The list of integers.\n        target (int): The target sum.\n\n    Returns:\n        List[int]: The two numbers that sum up to the target value.\n\n    Example:\n        Input: nums = [2, 7, 11, 15], target = 9\n        Output: [2, 7]\n        Explanation: 2 + 7 = 9.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [complement, num]\n        num_dict[num] = i\n\ndef g(nums: List[int], target: int) -> List[int]:\n    return f(nums, target)\n\nnums = [2, 7, 11, 15]\ntarget = 9\nassert f(nums, target) == g(nums, target)\n",
        "idx_generation": 94,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the nth Fibonacci number using dynamic programming.\"\"\"\n    fib = [0, 1]\n    for i in range(2, n+1):\n        fib.append(fib[i-1] + fib[i-2])\n    return fib[n]\n\ndef g():\n    return 8\n\nassert f(g()) == 21\n",
        "idx_generation": 243,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome.\n    Sample Input:\n    s = \"level\"\n    Sample Output:\n    True\"\"\"\n    return s == s[::-1]\n\ndef g(s=\"level\"):\n    \"\"\"Return the given string\"\"\"\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 157,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Calculate the sum of all the numbers in the given list.\"\"\"\n    return sum(nums)\n\ndef g():\n    \"\"\"Generate a list of numbers from 1 to 100.\"\"\"\n    return list(range(1, 101))\n\nassert f(g()) == 5050\n",
        "idx_generation": 416,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"Given an n x n matrix, rotate the matrix 90 degrees clockwise.\n    Return the rotated matrix.\n    Example:\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    The rotated matrix is [[7, 4, 1], [8, 5, 2], [9, 6, 3]].\n    Therefore, the answer is [[7, 4, 1], [8, 5, 2], [9, 6, 3]].\n    \"\"\"\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n    return matrix\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 141,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the longest increasing subsequence.\n\n    Return the length of the longest increasing subsequence.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g(nums: List[int]) -> int:\n    return f(nums)\n\nnums = [10, 22, 9, 33, 21, 50, 41, 60]\nassert f(nums) == g(nums)\n",
        "idx_generation": 442,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, find if there exist two elements in the list such that their sum is equal to the target value.\n    Return True if such a pair exists, otherwise return False.\n    Example:\n    nums = [2, 4, 6, 8]\n    target = 10\n    The pair (2, 8) sums up to 10, so the answer is True.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g():\n    nums = [2, 4, 6, 8]\n    target = 10\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 102,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k=3) -> bool:\n    \"\"\"Count the number of ways to climb to the nth step of a staircase with k possible steps.\n    You can take up to k steps at a time and each step has a cost associated with it.\n    Return True if there is at least one way to reach the nth step with a cost of zero, False otherwise.\"\"\"\n    ways = [0] * (n + 1)\n    ways[0] = 1\n    for i in range(1, n + 1):\n        total = 0\n        for j in range(1, k + 1):\n            if i - j >= 0:\n                total += ways[i - j]\n        ways[i] = total\n    return ways[n] > 0\ndef g(k=3):\n    return 5\nassert f(g())\n",
        "idx_generation": 244,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, t: str) -> bool:\n    \"\"\"Check if the characters in string 't' can be rearranged to form string 's'.\"\"\"\n    count = [0] * 26\n    for char in s:\n        count[ord(char) - ord('a')] += 1\n    for char in t:\n        count[ord(char) - ord('a')] -= 1\n        if count[ord(char) - ord('a')] < 0:\n            return False\n    return True\n\ndef g(s=\"abc\", t=\"bac\") -> List[str]:\n    \"\"\"Generate two strings 's' and 't'.\"\"\"\n    return s, t\n\nassert f(*g())\n",
        "idx_generation": 159,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element\n    is the product of all the elements in the original list except for the current element.\n    \"\"\"\n    n = len(nums)\n    left_products = [1] * n\n    right_products = [1] * n\n    result = [1] * n\n\n    for i in range(1, n):\n        left_products[i] = left_products[i - 1] * nums[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        right_products[i] = right_products[i + 1] * nums[i + 1]\n\n    for i in range(n):\n        result[i] = left_products[i] * right_products[i]\n\n    return result\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == [120, 60, 40, 30, 24]\n",
        "idx_generation": 418,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if a number is a prime number and the sum of its digits is equal to 10.\n    Sample input:\n    n = 37\n    Sample output:\n    True\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    return is_prime(n) and sum(int(digit) for digit in str(n)) == 10\n\ndef g():\n    return 37\n\nassert f(g())\n",
        "idx_generation": 141,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in descending order using the Quick Sort algorithm.\n    \"\"\"\n    def quick_sort(arr: List[int], low: int, high: int):\n        if low < high:\n            pi = partition(arr, low, high)\n            quick_sort(arr, low, pi - 1)\n            quick_sort(arr, pi + 1, high)\n    \n    def partition(arr: List[int], low: int, high: int) -> int:\n        i = low - 1\n        pivot = arr[high]\n        for j in range(low, high):\n            if arr[j] >= pivot:\n                i += 1\n                arr[i], arr[j] = arr[j], arr[i]\n        arr[i + 1], arr[high] = arr[high], arr[i + 1]\n        return i + 1\n    \n    quick_sort(nums, 0, len(nums) - 1)\n    return nums\n\ndef g():\n    nums = [5, 3, 8, 2, 9, 1, 4, 7, 6]\n    return nums\n\nassert f(g()) == [9, 8, 7, 6, 5, 4, 3, 2, 1]\n",
        "idx_generation": 447,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum sum of a subarray in the given list of integers.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g(nums: List[int]) -> int:\n    return f(nums)\n\nnums = [1, -2, 3, 4, -1, 2, 1, -5, 4]\nassert f(nums) == g(nums)\n",
        "idx_generation": 104,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, find the maximum sum that can be obtained by combining non-adjacent elements. The list may contain both positive and negative numbers.\n    Example: \n    Input: [2, 4, 6, 2, 5]\n    Output: 13\n    Explanation: The maximum sum can be obtained by selecting elements 2, 6, and 5.\"\"\"\n    if len(nums) <= 2:\n        return max(nums)\n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    for i in range(2, len(nums)):\n        dp[i] = max(nums[i] + dp[i-2], dp[i-1])\n    return dp[-1]\n    \ndef g():\n    return [2, 4, 6, 2, 5]\nassert f(g()) == 13\n",
        "idx_generation": 247,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome.\"\"\"\n    return s == s[::-1]\n\ndef g():\n    return \"racecar\"\n\nassert f(g())\n",
        "idx_generation": 161,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if a given matrix is a magic square.\"\"\"\n    n = len(matrix)\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != (n * (n**2 + 1)) // 2:\n            return False\n\n    # Check columns\n    for j in range(n):\n        col_sum = 0\n        for i in range(n):\n            col_sum += matrix[i][j]\n        if col_sum != (n * (n**2 + 1)) // 2:\n            return False\n\n    # Check diagonals\n    main_diag_sum = 0\n    anti_diag_sum = 0\n    for i in range(n):\n        main_diag_sum += matrix[i][i]\n        anti_diag_sum += matrix[i][n - i - 1]\n    if main_diag_sum != (n * (n**2 + 1)) // 2 or anti_diag_sum != (n * (n**2 + 1)) // 2:\n        return False\n\n    return True\n\ndef g():\n    return [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n\nassert f(g())\n",
        "idx_generation": 424,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers 'arr' in ascending order, find the index of the first occurrence of 'target' in the list using binary search.\"\"\"\n    low = 0\n    high = len(arr) - 1\n    first_occurrence = -1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            first_occurrence = mid\n            high = mid - 1\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return first_occurrence\n\ndef g():\n    return [1, 2, 2, 2, 4, 5, 5, 8]\n\nassert f(g(), 2) == 1\n",
        "idx_generation": 142,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n\n",
        "idx_generation": 452,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine if a given number is a prime palindrome.\"\"\"\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    def is_palindrome(n: int) -> bool:\n        return str(n) == str(n)[::-1]\n    \n    return is_prime(n) and is_palindrome(n)\ndef g():\n    return 131\nassert f(g())\n",
        "idx_generation": 111,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix, find the minimum number of moves required to move from the top-left corner to the bottom-right corner. Each move can only be made to the right or down.\n    Example: \n    Input: \n    [[1, 3, 1],\n     [1, 5, 1],\n     [4, 2, 1]]\n    Output: 7\n    Explanation: The minimum number of moves to reach the bottom-right corner is 7 (1 -> 3 -> 1 -> 1 -> 1).\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = matrix[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = matrix[i][j] + min(dp[i-1][j], dp[i][j-1])\n    return dp[-1][-1]\n\ndef g():\n    return [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\nassert f(g()) == 7\n",
        "idx_generation": 247,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[str]], target: str) -> bool:\n    \"\"\"Check if the given target string exists in the grid horizontally, vertically, or diagonally.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == target:\n                return True\n    \n    for i in range(rows):\n        if target in ''.join(grid[i]):\n            return True\n    \n    for j in range(cols):\n        if target in ''.join([grid[i][j] for i in range(rows)]):\n            return True\n    \n    for i in range(rows):\n        for j in range(cols):\n            if i + len(target) <= rows and j + len(target) <= cols:\n                if target == ''.join([grid[i+k][j+k] for k in range(len(target))]):\n                    return True\n    \n    return False\n\ndef g():\n    return [['a', 'b', 'c', 'd'],\n            ['e', 'f', 'g', 'h'],\n            ['i', 'j', 'k', 'l'],\n            ['m', 'n', 'o', 'p']]\n\nassert f(g(), 'efgh')\n",
        "idx_generation": 161,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given an integer n, determine if it is a power of 4.\"\"\"\n    if n <= 0:\n        return False\n    while n % 4 == 0:\n        n //= 4\n    return n == 1\n\ndef g():\n    return 64\n\nassert f(g())\n",
        "idx_generation": 433,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, and a target number, find if there are two elements in the list that sum up to the target.\n    Return True if such elements exist, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(target: int):\n    nums = [-2, 0, 3, 5, 7, 9]\n    return nums, target\n\nassert f(*g(8))\n",
        "idx_generation": 147,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers 'nums' and a target integer, find all unique combinations in 'nums' where the sum of the\n    combinations is equal to the target.\n    Return a list of all the unique combinations.\n    \"\"\"\n    def backtrack(start, path, target):\n        if target == 0:\n            result.append(path)\n            return\n        \n        for i in range(start, len(nums)):\n            if nums[i] > target:\n                break\n            \n            backtrack(i, path + [nums[i]], target - nums[i])\n    \n    result = []\n    nums.sort()\n    backtrack(0, [], target)\n    \n    return result\n\ndef g():\n    \"\"\"\n    Generate the list of integers 'nums' and the target integer.\n    \"\"\"\n    nums = [2, 3, 6, 7]\n    target = 7\n    \n    return nums, target\n\nassert f(*g()) == [[2, 2, 3], [7]]\n",
        "idx_generation": 457,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if a given matrix is a magic square, which means that all rows, columns, and diagonals have the same sum.\n    Sample input:\n    matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    Sample output:\n    True\n    \"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    # Check columns\n    for j in range(n):\n        column_sum = 0\n        for i in range(n):\n            column_sum += matrix[i][j]\n        if column_sum != target_sum:\n            return False\n    # Check diagonals\n    diagonal_sum = 0\n    anti_diagonal_sum = 0\n    for i in range(n):\n        diagonal_sum += matrix[i][i]\n        anti_diagonal_sum += matrix[i][n - i - 1]\n    if diagonal_sum != target_sum or anti_diagonal_sum != target_sum:\n        return False\n    return True\n\ndef g():\n    return [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n\nassert f(g())\n",
        "idx_generation": 112,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the minimum path sum from top-left to bottom-right in a grid\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 7\n",
        "idx_generation": 250,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Given a string, reverse the order of words in the string and return the reversed string.\n    Words are separated by a single space.\"\"\"\n    words = s.split()\n    return ' '.join(words[::-1])\n\ndef g(s: str):\n    return s\n\nassert f(g(\"Hello World\")) == \"World Hello\"\n",
        "idx_generation": 163,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the factorial of n.\n    \"\"\"\n    if n == 0:\n        return 1\n    factorial = 1\n    for i in range(1, n+1):\n        factorial *= i\n    return factorial\n\ndef g():\n    return 5\n\nassert f(g()) == 120\n",
        "idx_generation": 434,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, remove all duplicates and return the updated list.\n    \"\"\"\n    num_set = set()\n    result = []\n    for num in nums:\n        if num not in num_set:\n            num_set.add(num)\n            result.append(num)\n    return result\n\ndef g():\n    nums = [1, 2, 3, 3, 4, 4, 5]\n    return nums\n\nassert f(g()) == [1, 2, 3, 4, 5]\n",
        "idx_generation": 147,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n    Return the length.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    n = len(nums)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 458,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Determine if the given grid is a valid Sudoku solution.\n    A valid Sudoku solution must satisfy the following conditions:\n    1. Each row contains all the numbers from 1 to 9 with no duplicates.\n    2. Each column contains all the numbers from 1 to 9 with no duplicates.\n    3. Each 3x3 sub-grid contains all the numbers from 1 to 9 with no duplicates.\n    Return True if the grid is a valid Sudoku solution, and False otherwise.\"\"\"\n    \n    # Check rows\n    for row in grid:\n        if len(set(row)) != len(row):\n            return False\n    \n    # Check columns\n    for col in range(len(grid[0])):\n        column = [grid[row][col] for row in range(len(grid))]\n        if len(set(column)) != len(column):\n            return False\n    \n    # Check sub-grids\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            subgrid = [grid[row][col] for row in range(i, i+3) for col in range(j, j+3)]\n            if len(set(subgrid)) != len(subgrid):\n                return False\n    \n    return True\n\ndef g():\n    return [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9]\n    ]\n\nassert f(g())\n",
        "idx_generation": 113,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subsequence where the elements are sorted in non-decreasing order.\n    The subsequence can be non-contiguous and may contain duplicate elements.\n    \"\"\"\n    n = len(nums)\n    dp = [nums[i] for i in range(n)]\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] >= nums[j]:\n                dp[i] = max(dp[i], dp[j] + nums[i])\n    return max(dp)\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7]\n\nassert f(g()) == 28\n",
        "idx_generation": 250,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string s, return True if the string is a palindrome, and False otherwise.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\"\"\"\n    return s == s[::-1]\n\ndef g():\n    return \"radar\"\n\nassert f(g()) == True\n",
        "idx_generation": 165,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if n is a prime number.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    num = 2\n    while True:\n        if f(num):\n            return num\n        num += 1\n\nassert f(g())\n",
        "idx_generation": 436,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Find the number of occurrences of the target element in a sorted array of integers.\n    Sample Input:\n    nums = [1, 2, 2, 3, 4, 4, 4, 5]\n    target = 4\n    Sample Output:\n    3\"\"\"\n    left = 0\n    right = len(nums) - 1\n    first_occurrence = -1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            first_occurrence = mid\n            right = mid - 1\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    if first_occurrence == -1:\n        return 0\n    left = first_occurrence\n    right = len(nums) - 1\n    last_occurrence = first_occurrence\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            last_occurrence = mid\n            left = mid + 1\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return last_occurrence - first_occurrence + 1\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find the sorted list of integers and the target element.\"\"\"\n    nums.sort()\n    return nums, target\n\nassert f(*g([1, 2, 2, 3, 4, 4, 4, 5], 4)) == 3\n",
        "idx_generation": 147,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], x: int) -> bool:\n    \"\"\"Given a sorted array of integers and a target value 'x', determine if 'x' exists in the array using binary search.\"\"\"\n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == x:\n            return True\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return False\n\ndef g() -> List[int]:\n    \"\"\"Generate a sorted array of integers.\"\"\"\n    return [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n\nassert f(g(), 12)\n",
        "idx_generation": 458,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if it contains any duplicate numbers.\n    Return True if there are duplicate numbers in the list, and False otherwise.\"\"\"\n    unique_nums = set()\n    for num in nums:\n        if num in unique_nums:\n            return True\n        unique_nums.add(num)\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == False\n",
        "idx_generation": 113,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if there exists a path from the top-left corner to the bottom-right corner\n    where the sum of the elements along the path is a perfect square.\n    Return True if such a path exists, otherwise return False.\n    \"\"\"\n    def isPerfectSquare(n: int) -> bool:\n        return int(n ** 0.5) ** 2 == n\n    \n    def dfs(matrix: List[List[int]], row: int, col: int, current_sum: int) -> bool:\n        if row < 0 or row >= len(matrix) or col < 0 or col >= len(matrix[0]):\n            return False\n        \n        current_sum += matrix[row][col]\n        \n        if row == len(matrix) - 1 and col == len(matrix[0]) - 1:\n            return isPerfectSquare(current_sum)\n        \n        return dfs(matrix, row + 1, col, current_sum) or dfs(matrix, row, col + 1, current_sum)\n    \n    return dfs(matrix, 0, 0, 0)\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g())\n",
        "idx_generation": 250,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string is a palindrome\"\"\"\n    return s == s[::-1]\ndef g(s='racecar'):\n    return s\nassert f(g())\n",
        "idx_generation": 175,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the sum of all positive integers up to and including 'n'.\n    Return the sum.\n    \"\"\"\n    return (n * (n + 1)) // 2\n\ndef g():\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    n = 10\n    \n    return n\n\nassert f(g()) == 55\n",
        "idx_generation": 454,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    nums = [1, 3, 5, 7, 9]\n    target = 10\n    return nums, target\n\nassert f(*g())\n\n",
        "idx_generation": 148,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Sort a given list of integers in ascending order using the Bubble Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    return nums\n\ndef g():\n    \"\"\"Generate a list of integers to be sorted using the Bubble Sort algorithm.\"\"\"\n    nums = [9, 4, 7, 2, 1, 5]\n    return nums\n\nassert f(g()) == [1, 2, 4, 5, 7, 9]\n",
        "idx_generation": 462,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if there exists a subarray in nums with a sum equal to 0\"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum in prefix_sums or prefix_sum == 0:\n            return True\n        prefix_sums.add(prefix_sum)\n    return False\n\ndef g():\n    return [4, -2, 3, 1, 2, -3, -1]\n\nassert f(g())\n",
        "idx_generation": 118,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a subset of numbers whose sum is equal to the target value.\"\"\"\n    def helper(i, curr_sum):\n        if curr_sum == target:\n            return True\n        if i >= len(nums) or curr_sum > target:\n            return False\n        return helper(i + 1, curr_sum + nums[i]) or helper(i + 1, curr_sum)\n\n    return helper(0, 0)\n\ndef g(nums=[2, 4, 6, 8, 10], target=18):\n    \"\"\"Generate a list of integers and a target value.\"\"\"\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 251,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if they are isomorphic.\n    Two strings are isomorphic if the characters in s can be replaced to get t.\n    Each character in s can be replaced with a character in t, but the replacement must be one-to-one,\n    meaning that each character in s maps to a unique character in t, and each character in t maps to a unique character in s.\n    Return True if the strings are isomorphic, False otherwise.\n    \"\"\"\n    if len(s) != len(t):\n        return False\n    \n    char_map_s = {}\n    char_map_t = {}\n    \n    for i in range(len(s)):\n        char_s = s[i]\n        char_t = t[i]\n        \n        if char_s in char_map_s:\n            if char_map_s[char_s] != char_t:\n                return False\n        else:\n            char_map_s[char_s] = char_t\n        \n        if char_t in char_map_t:\n            if char_map_t[char_t] != char_s:\n                return False\n        else:\n            char_map_t[char_t] = char_s\n    \n    return True\n\ndef g():\n    s = \"paper\"\n    t = \"title\"\n    return s, t\n\nassert f(*g())\n",
        "idx_generation": 177,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if n is a prime number.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    n = 2\n    while True:\n        if f(n):\n            return n\n        n += 1\n\nassert f(g())\n",
        "idx_generation": 457,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of integers in the given array that sum up to the target value.\n    Return True if such a pair exists, False otherwise.\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5], 7\n\nassert f(*g()) == True\n",
        "idx_generation": 150,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, find a combination of numbers from the list that add up to the target.\n    \n    Return True if such a combination exists, False otherwise.\n    \"\"\"\n    def backtrack(combination: List[int], index: int, current_sum: int) -> bool:\n        if current_sum == target:\n            return True\n        if current_sum > target or index >= len(nums):\n            return False\n        \n        for i in range(index, len(nums)):\n            if i > index and nums[i] == nums[i-1]:\n                continue\n            combination.append(nums[i])\n            if backtrack(combination, i+1, current_sum + nums[i]):\n                return True\n            combination.pop()\n        \n        return False\n    \n    nums.sort()\n    return backtrack([], 0, 0)\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 463,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target sum, check if there exists a pair of integers in the list whose sum is equal to the target.\n    \n    Args:\n    arr: A list of integers\n    target: Target sum\n    \n    Returns:\n    True if there exists a pair of integers whose sum is equal to the target, False otherwise\n    \"\"\"\n    complements = set()\n    for num in arr:\n        if num in complements:\n            return True\n        complements.add(target - num)\n    return False\n\ndef g(target: int):\n    \"\"\"\n    Generate a list of integers and a target sum such that there exists a pair of integers whose sum is equal to the target.\n    \n    Args:\n    target: Target sum\n    \n    Returns:\n    A tuple containing a list of integers and the target sum\n    \"\"\"\n    return ([1, 2, 3, 4], target)\n\nassert f(*g(5))\n",
        "idx_generation": 118,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence.\n    Return the length of the longest increasing subsequence.\n    Sample input:\n    [10, 9, 2, 5, 3, 7, 101, 18]\n    Sample output:\n    4\"\"\"\n    n = len(arr)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n\n",
        "idx_generation": 254,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"Given a string, determine if it is a palindrome. Return True if the string is a palindrome,\n    otherwise return False. A palindrome is a string that reads the same forwards and backwards.\"\"\"\n    return string == string[::-1]\n\ndef g(string: str) -> bool:\n    \"\"\"Generate a palindrome string based on the given input string.\"\"\"\n    return string + string[::-1]\n    \nassert f(g(\"python\"))\n",
        "idx_generation": 189,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> bool:\n    \"\"\"\n    Check if the given numbers n and m are coprime (relatively prime).\n    Two numbers are coprime if their greatest common divisor (GCD) is 1.\n    Return True if n and m are coprime, False otherwise.\n    \"\"\"\n\n    def gcd(a: int, b: int) -> int:\n        while b != 0:\n            a, b = b, a % b\n        return a\n\n    return gcd(n, m) == 1\n\ndef g():\n    n = 15\n    m = 28\n    return n, m\n\nassert f(*g())\n",
        "idx_generation": 467,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers, find the index of the target element.\n    If the target element is not found, return -1.\n\n    Example:\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n    The target element 5 is found at index 2, so the answer is 2.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    return [1, 3, 5, 7, 9], 5\n\nassert f(*g()) == 2\n",
        "idx_generation": 151,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target=9) -> bool:\n    \"\"\"Find two numbers in arr that add up to target\"\"\"\n    arr.sort()\n    left, right = 0, len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(target=9):\n    arr = [4, 2, 7, 5, 1, 3]\n    return arr\n\nassert f(g())\n",
        "idx_generation": 469,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers and a target number, find two distinct elements in the list whose sum is equal to the target.\n    Return the indices of the two elements as a list.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        if target - num in num_dict:\n            return [num_dict[target - num], i]\n        num_dict[num] = i\n    return []\n\ndef g(target: int):\n    nums = [1, 2, 3, 4, 5]\n    return nums, target\n\nassert f(*g(6)) == [1, 3]\n",
        "idx_generation": 124,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum subarray sum, which is the sum of a contiguous subarray\n    with the largest sum.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 255,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string of alphanumeric characters, reverse the order of the words in the string.\n    \"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)\n\ndef g(s: str = \"hello world\"):\n    return s\n\nassert f(g()) == \"world hello\"\n",
        "idx_generation": 196,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the sum of all positive integers up to and including the given number.\"\"\"\n    return (n * (n + 1)) // 2\n\ndef g(n: int) -> int:\n    \"\"\"Calculate the sum of all positive integers up to and including the given number using a loop.\"\"\"\n    total = 0\n    for i in range(1, n + 1):\n        total += i\n    return total\n\nassert f(10) == g(10)\n",
        "idx_generation": 480,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if the target value is present in the list using binary search.\"\"\"\n    low = 0\n    high = len(arr) - 1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return False\n\ndef g():\n    arr = [1, 3, 5, 7, 9, 11, 13, 15]\n    target = 7\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 153,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers and a target value, find the minimum number of elements that need to be removed from the list to make the sum of the remaining elements equal to the target.\"\"\"\n    n = len(nums)\n    total_sum = sum(nums)\n    target_sum = total_sum - target\n    \n    dp = [[float('inf')] * (target_sum + 1) for _ in range(n+1)]\n    dp[0][0] = 0\n    \n    for i in range(1, n+1):\n        for j in range(target_sum + 1):\n            if nums[i-1] <= j:\n                dp[i][j] = min(dp[i-1][j], dp[i-1][j-nums[i-1]] + 1)\n            else:\n                dp[i][j] = dp[i-1][j]\n    \n    return dp[n][target_sum]\n\ndef g():\n    return [1, 2, 3, 4, 5], 9\n\nassert f(*g()) == 2\n",
        "idx_generation": 470,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum product of any two distinct numbers in the list.\n    Return the maximum product.\n    Sample input:\n    nums = [2, 3, 4, 5]\n    Sample output:\n    20\"\"\"\n    max_product = float('-inf')\n    n = len(nums)\n\n    for i in range(n):\n        for j in range(i+1, n):\n            max_product = max(max_product, nums[i] * nums[j])\n\n    return max_product\n\ndef g():\n    return [2, 3, 4, 5]\n\nassert f(g()) == 20\n",
        "idx_generation": 131,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(binary_list: List[int], target_sum: int) -> bool:\n    \"\"\"\n    Determine if there exists a subset of the given binary list that sums up to the target sum.\n    \"\"\"\n    n = len(binary_list)\n    dp = [[False] * (target_sum + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target_sum + 1):\n            if binary_list[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - binary_list[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[n][target_sum]\n\n\ndef g(binary_list=[1, 2, 3, 4, 5], target_sum=9):\n    return binary_list\n\n\nassert f(g(), target_sum=9)\n",
        "idx_generation": 258,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Given a string, reverse the order of the words in the string.\n    The function should return the reversed string.\n    \"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string\n\ndef g():\n    s = \"Hello World\"\n    return s\n\nassert f(g()) == \"World Hello\"\n",
        "idx_generation": 201,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of integers, check if it is a square matrix.\"\"\"\n    num_rows = len(matrix)\n    for row in matrix:\n        if len(row) != num_rows:\n            return False\n    return True\n\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    \"\"\"Generate a matrix of integers.\"\"\"\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 487,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, arr: List[int]) -> bool:\n    \"\"\"Check if a given number is present in the sorted array.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == n:\n            return True\n        elif arr[mid] < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return False\n\ndef g(arr: List[int]):\n    return (10, sorted(arr))\n\nassert f(*g([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n",
        "idx_generation": 154,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums', remove all duplicates in-place such that each element appears only once and return the modified list.\n    Do not allocate extra space for another array, you must modify the input list in-place with O(1) extra memory.\n    \"\"\"\n    if not nums:\n        return []\n    \n    i = 0\n    for j in range(1, len(nums)):\n        if nums[j] != nums[i]:\n            i += 1\n            nums[i] = nums[j]\n    \n    return nums[:i+1]\n\ndef g():\n    \"\"\"\n    Generate a list of integers with duplicates.\n    \"\"\"\n    nums = [1, 1, 2, 2, 3, 4, 4, 5]\n    \n    return nums\n\nassert f(g()) == [1, 2, 3, 4, 5]\n\n",
        "idx_generation": 484,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"Count the number of multiples of k in the range from 1 to n.\"\"\"\n    count = 0\n    \n    for i in range(1, n+1):\n        if i % k == 0:\n            count += 1\n    \n    return count\n\ndef g():\n    return (100, 7)\n\nassert f(*g()) == 14\n",
        "idx_generation": 132,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence.\n    An increasing subsequence is defined as a subsequence in which the elements are in increasing order.\n    Return the length of the longest increasing subsequence.\"\"\"\n    if not nums:\n        return 0\n    \n    n = len(nums)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g() -> List[int]:\n    \"\"\"Generate a list of integers.\"\"\"\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 262,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome.\"\"\"\n    return s == s[::-1]\ndef g():\n    return \"madam\"\nassert f(g())\n",
        "idx_generation": 202,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there exists a pair of numbers in the list that add up to the target value.\n    Return True if such pair exists, False otherwise.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    return [1, 3, 5, 7, 9, 11, 13], 10\n\nassert f(*g())\n",
        "idx_generation": 155,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there exists a pair of numbers whose sum is equal to the target.\n    Return True if such a pair exists, and False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), 12)\n",
        "idx_generation": 484,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given an array of integers and a target integer, find a subarray that sums up to the target value. Return True if such a subarray exists, otherwise return False.\"\"\"\n    n = len(nums)\n    prefix_sum = 0\n    seen = set()\n    for i in range(n):\n        prefix_sum += nums[i]\n        if prefix_sum == target or prefix_sum - target in seen:\n            return True\n        seen.add(prefix_sum)\n    return False\ndef g(nums: List[int], target: int):\n    return nums, target\nassert f(*g([1, 3, 4, 2, 8], 9))\n",
        "idx_generation": 135,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a 2D grid of integers, find the minimum sum path from the top left corner to the bottom right corner.\n    You can only move down or right.\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 7\n",
        "idx_generation": 264,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of words in the string.\n    \"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)\n\ndef g():\n    return \"Hello World\"\n\nassert f(g()) == \"World Hello\"\n",
        "idx_generation": 203,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the given list that sums up to the target value.\n    Sample Input:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    Sample Output:\n    True\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr=[1, 2, 3, 4, 5], target=7):\n    \"\"\"Return the given list and target value\"\"\"\n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 157,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence.\n    An increasing subsequence is a subsequence where the elements are in increasing order,\n    not necessarily contiguous.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 489,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n    Return the maximum product as an integer.\n    \"\"\"\n    max_product = float('-inf')\n    \n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            product = arr[i] * arr[j]\n            max_product = max(max_product, product)\n    \n    return max_product\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == 90\n",
        "idx_generation": 135,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(n: int, k: int) -> bool:\n    \"\"\"Given two integers n and k, determine if n is a perfect power of k.\n    A perfect power is a positive integer that can be expressed as an integer power of another positive integer.\n    For example, 8 is a perfect power of 2 (2^3 = 8) and 81 is a perfect power of 3 (3^4 = 81).\"\"\"\n    if n <= 0 or k <= 0:\n        return False\n    if n == 1:\n        return True\n    for i in range(2, int(math.sqrt(n)) + 1):\n        x = i\n        while x <= n:\n            x *= i\n            if x == n:\n                return True\n    return False\n\ndef g(n: int, k: int) -> int:\n    \"\"\"Find the largest perfect power of k less than or equal to the given number n.\"\"\"\n    power = 0\n    while k ** power <= n:\n        power += 1\n    return k ** (power - 1)\n\nassert f(g(100, 3), 3)\n",
        "idx_generation": 267,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, s: str) -> bool:\n    \"\"\"Find n such that s can be formed by concatenating n copies of itself\"\"\"\n    return s == s * n\ndef g(s: str):\n    n = 1\n    while not f(n, s):\n        n += 1\n    return n\nassert f(g('hello'), 'hellohellohello')\n",
        "idx_generation": 204,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers that sum up to the target value.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr=[1, 2, 3, 4, 5], target=9) -> List[int]:\n    \"\"\"Generate a sorted list of integers and a target value.\"\"\"\n    return sorted(arr), target\n\nassert f(*g())\n",
        "idx_generation": 159,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target value, find two numbers in the list that sum up to the target.\n    Return the indices of the two numbers.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return nums\n\nassert f(g(), target=9) == [0, 1]\n",
        "idx_generation": 493,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"Count the number of vowels in the given string.\"\"\"\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = 0\n    \n    for char in s.lower():\n        if char in vowels:\n            count += 1\n    \n    return count\n\ndef g(s=\"Hello, World!\"):\n    return s\n\nassert f(g()) == 3\n",
        "idx_generation": 140,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix filled with non-negative integers, find the path from the top-left cell to the bottom-right cell\n    with the largest sum. You can only move down or right. Return the maximum sum.\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return 0\n    \n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n    \n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                dp[i][j] = matrix[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + matrix[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + matrix[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix with random non-negative integers.\n    \"\"\"\n    matrix = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    return matrix\n\nassert f(g()) == 12\n",
        "idx_generation": 267,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, substring: str, k: int) -> bool:\n    \"\"\"Check if a substring of length k exists in the given string s.\"\"\"\n    for i in range(len(s) - k + 1):\n        if s[i:i+k] == substring:\n            return True\n    return False\n\ndef g(substring='bar', k=3):\n    return 'foobarbaz'\n\nassert f(g(), substring='bar', k=3)\n",
        "idx_generation": 205,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target number, determine if there exist two numbers in the list that sum up to the target.\n    Return True if such numbers exist, otherwise return False.\"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    return [1, 3, 5, 7, 9, 11, 13, 15], 20\n\nassert f(*g()) == True\n\n",
        "idx_generation": 159,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], k=3) -> bool:\n    \"\"\"Given a list of integers, check if there are k consecutive numbers in the list.\"\"\"\n    nums.sort()\n    count = 1\n    for i in range(1, len(nums)):\n        if nums[i] == nums[i - 1] + 1:\n            count += 1\n            if count == k:\n                return True\n        else:\n            count = 1\n    return False\n\ndef g(nums=[1, 5, 2, 3, 4, 9, 8, 6, 7], k=3):\n    return nums\n\nassert f(g())\n",
        "idx_generation": 497,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Return a new list with all duplicates removed, while preserving the original order of elements.\"\"\"\n    seen = set()\n    result = []\n    \n    for num in nums:\n        if num not in seen:\n            result.append(num)\n            seen.add(num)\n    \n    return result\n\ndef g(nums=[1, 2, 2, 3, 4, 4, 5, 5, 5]):\n    return nums\n\nassert f(g()) == [1, 2, 3, 4, 5]\n",
        "idx_generation": 140,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of integers, determine if there exists a path from the top-left corner to the bottom-right corner, where each step can only be taken to the right or down.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    dp = [[False] * cols for _ in range(rows)]\n    dp[0][0] = True\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] and matrix[i][0] != 0\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] and matrix[0][j] != 0\n    for i in range(1, rows):\n        for j in range(1, cols):\n            if matrix[i][j] != 0:\n                dp[i][j] = dp[i-1][j] or dp[i][j-1]\n    return dp[-1][-1]\n\ndef g():\n    matrix = [[1, 1, 0], [1, 0, 1], [1, 1, 1]]\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 275,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"Check if string 't' is a rotation of string 's'.\"\"\"\n    if len(s) != len(t):\n        return False\n    return t in (s + s)\n\ndef g(s=\"watermelon\", t=\"melonwater\") -> Tuple[str, str]:\n    \"\"\"Return two strings where the second string is a rotation of the first string.\"\"\"\n    return s, t\n\nassert f(*g())\n",
        "idx_generation": 207,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine whether there exist two numbers\n    in the list such that their sum equals the target.\n    \n    Return True if such a pair exists, False otherwise.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    nums = [-2, -1, 0, 3, 5, 6, 8, 9]\n    target = 7\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 160,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers 'nums' and a target integer 'target',\n    determine if it is possible to select a subset of 'nums' such that the bitwise XOR of all elements in the subset is equal to 'target'.\n    Return True if it is possible, False otherwise.\n    Example:\n    nums = [1, 2, 3, 4]\n    target = 5\n    The possible subsets are [1, 4] and [2, 3].\n    The bitwise XOR of [1, 4] is 5, which is equal to the target.\n    Therefore, the answer is True.\n    \"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(target + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= nums[i - 1]:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - nums[i - 1]]\n\n    return dp[n][target]\n\ndef g():\n    return [1, 2, 3, 4], 5\n\nassert f(*g())\n\n",
        "idx_generation": 497,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if the given matrix is a magic square.\"\"\"\n    n = len(matrix)\n    row_sums = [0] * n\n    col_sums = [0] * n\n    diag_sum = 0\n    anti_diag_sum = 0\n\n    for i in range(n):\n        for j in range(n):\n            row_sums[i] += matrix[i][j]\n            col_sums[j] += matrix[i][j]\n            if i == j:\n                diag_sum += matrix[i][j]\n            if i + j == n - 1:\n                anti_diag_sum += matrix[i][j]\n\n    target_sum = row_sums[0]\n    if any(row_sum != target_sum for row_sum in row_sums) or any(col_sum != target_sum for col_sum in col_sums):\n        return False\n    if diag_sum != target_sum or anti_diag_sum != target_sum:\n        return False\n\n    return True\n\ndef g(matrix=[[2, 7, 6], [9, 5, 1], [4, 3, 8]]):\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 142,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if there is a path from the top-left corner to the bottom-right corner in the grid, using only downward and rightward movements\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[False] * n for _ in range(m)]\n    dp[0][0] = True\n\n    for i in range(m):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] = dp[i][j] or (dp[i-1][j] and grid[i][j] != 1)\n            if j > 0:\n                dp[i][j] = dp[i][j] or (dp[i][j-1] and grid[i][j] != 1)\n    \n    return dp[m-1][n-1]\n\ndef g(grid: List[List[int]]):\n    \"\"\"Return the grid\"\"\"\n    return grid\n\nassert f(g([[0, 0, 0], [0, 1, 0], [0, 0, 0]]))\n",
        "idx_generation": 280,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Given two strings s1 and s2, determine if s1 can be rearranged to form s2.\n\n    Return True if s1 can be rearranged to form s2, False otherwise.\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n    \n    count = [0] * 26\n    \n    for char in s1:\n        count[ord(char) - ord('a')] += 1\n    \n    for char in s2:\n        count[ord(char) - ord('a')] -= 1\n        if count[ord(char) - ord('a')] < 0:\n            return False\n    \n    return True\n\ndef g():\n    s1 = \"listen\"\n    s2 = \"silent\"\n    return s1, s2\n\nassert f(*g()) == True\n\n",
        "idx_generation": 213,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the number of elements that are less than or equal to the target value.\n    \n    Return the count of elements.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] <= target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return left\n\ndef g():\n    nums = [1, 3, 5, 7, 9]\n    target = 6\n    return nums, target\n\nassert f(*g()) == 3\n",
        "idx_generation": 162,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers and a target value, \n    find the index of the target value using binary search.\"\"\"\n    low, high = 0, len(nums) - 1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return -1\n\ndef g():\n    nums = [1, 3, 5, 7, 9, 11, 13]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 3\n",
        "idx_generation": 497,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Given a list of integers, find the number of distinct pairs (i, j) such that arr[i] + arr[j] = k,\n    where k is a given integer.\"\"\"\n    count = 0\n    seen = set()\n    for num in arr:\n        complement = k - num\n        if complement in seen:\n            count += 1\n        seen.add(num)\n    return count\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nk = 10\n\nassert f(g()) == 4\n\n",
        "idx_generation": 143,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the nth Fibonacci number using recursion.\"\"\"\n    if n <= 1:\n        return n\n    return f(n-1) + f(n-2)\n\ndef g():\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 280,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str, substring: str, k: int) -> bool:\n    \"\"\"Count the number of occurrences of the substring in the given string and return True if the count is greater than or equal to k, otherwise return False.\"\"\"\n    count = string.count(substring)\n    return count >= k\n\ndef g(string: str, substring: str, k: int):\n    return (string, substring, k)\n\nassert f(*g(\"abababab\", \"aba\", 2))\n",
        "idx_generation": 215,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum product of any three numbers from the list.\n    The maximum product should be returned as an integer.\"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3])\n\ndef g(nums: List[int]):\n    return nums\n\nnums = [1, 2, 3, 4]\nassert f(g(nums)) == 24\n",
        "idx_generation": 163,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums', implement a function to find the longest\n    increasing subsequence in the list.\n    A subsequence is a sequence that can be derived from another sequence by deleting\n    some or no elements without changing the order of the remaining elements.\n    Return the longest increasing subsequence as a list.\n    \n    Example:\n    nums = [3, 10, 2, 1, 20]\n    \n    The longest increasing subsequence in the list is [3, 10, 20].\n    Therefore, the output should be [3, 10, 20].\n    \"\"\"\n    n = len(nums)\n    lis = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n    \n    max_len = max(lis)\n    max_idx = lis.index(max_len)\n    \n    subsequence = [nums[max_idx]]\n    curr_len = max_len\n    \n    for i in range(max_idx-1, -1, -1):\n        if lis[i] == curr_len - 1 and nums[i] < subsequence[-1]:\n            subsequence.append(nums[i])\n            curr_len -= 1\n    \n    return subsequence[::-1]\n\ndef g() -> List[int]:\n    return [3, 10, 2, 1, 20]\n\nassert f(g()) == [3, 10, 20]\n",
        "idx_generation": 499,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if it is possible to find a contiguous subarray of the given array, such that the sum of the subarray is equal to the target.\"\"\"\n    n = len(arr)\n    prefix_sum = [0] * (n+1)\n    for i in range(1, n+1):\n        prefix_sum[i] = prefix_sum[i-1] + arr[i-1]\n    \n    for i in range(n+1):\n        for j in range(i+1, n+1):\n            if prefix_sum[j] - prefix_sum[i] == target:\n                return True\n    return False\n\ndef g():\n    \"\"\"Generate an array and a target sum.\"\"\"\n    arr = [1, 4, 2, 3, 5]\n    target = 9\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 151,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence.\n    Sample input:\n    [10, 9, 2, 5, 3, 7, 101, 18]\n    Sample output:\n    4\"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 287,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a given string is a palindrome.\n    Return True if the string is a palindrome, False otherwise.\n    \"\"\"\n    if len(s) <= 1:\n        return True\n    if s[0] != s[-1]:\n        return False\n    return f(s[1:-1])\n\ndef g():\n    return \"racecar\"\n\nassert f(g())\n\n",
        "idx_generation": 217,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, return the index of the target element if it exists. If the target element does not exist, return -1.\n    \"\"\"\n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1\n\ndef g(arr: List[int] = [1, 3, 5, 7, 9, 11, 13], target: int = 7):\n    return arr, target\n\nassert f(*g()) == 3\n",
        "idx_generation": 167,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find two numbers that sum up to the target.\n    Return the indices of the two numbers.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\ndef g(nums: List[int], target: int) -> List[int]:\n    return f(nums, target)\n\nnums = [1, 2, 3, 4, 5, 6]\ntarget = 9\nassert f(nums, target) == g(nums, target)\n",
        "idx_generation": 499,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Determine whether 'n' is a prime number and if its factorial is divisible by 'k'.\n    Return True if both conditions are satisfied, otherwise return False.\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                return False\n        return True\n    \n    def factorial(num):\n        result = 1\n        for i in range(1, num+1):\n            result *= i\n        return result\n    \n    return is_prime(n) and factorial(n) % k == 0\n\ndef g():\n    \"\"\"\n    Generate values for 'n' and 'k'.\n    \"\"\"\n    n = 7\n    k = 10\n    \n    return n, k\n\nassert f(*g())\n",
        "idx_generation": 156,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an unsorted list of integers, find the length of the longest increasing subsequence.\n    An increasing subsequence is a subsequence where the elements are in increasing order, but not necessarily contiguous.\n    \"\"\"\n\n    dp = [1] * len(nums)\n\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 288,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n=3) -> bool:\n    \"\"\"Find a string that contains exactly n distinct characters\"\"\"\n    return len(set(s)) == n\ndef g(n=3):\n    chars = ['a', 'b', 'c', 'd', 'e', 'f']\n    return ''.join(chars[:n])\nassert f(g())\n",
        "idx_generation": 217,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target element if it exists. If the target element\n    does not exist in the list, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target: int = 6):\n    return nums, target\n\nassert f(*g()) == 5\n",
        "idx_generation": 167,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(arr: List[int], target=10) -> bool:\n    \"\"\"Find if there exists a subarray in arr that sums up to the target\"\"\"\n    n = len(arr)\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + arr[i - 1]\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if prefix_sum[j] - prefix_sum[i] == target:\n                return True\n    return False\ndef g(target=10):\n    import random\n    arr = random.sample(range(1, 20), 10)\n    return arr\nassert f(g())\n",
        "idx_generation": 161,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if there exists a path from the top-left corner to the bottom-right corner in the given matrix, \n    where each cell value represents the cost of moving to that cell. You can only move right or down.\"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n    \n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = matrix[0][0]\n    \n    for i in range(m):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + matrix[i][j])\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + matrix[i][j])\n    \n    return dp[m-1][n-1] < float('inf')\n\ndef g(matrix: List[List[int]]):\n    return matrix\n\nassert f(g([[1, 3, 1], [1, 5, 1], [4, 2, 1]]))\n",
        "idx_generation": 292,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str, pattern='abc') -> bool:\n    \"\"\"Given a string and a pattern, determine if the string follows the pattern.\n    The pattern consists of lowercase English letters and the string contains only lowercase English letters.\n    Return True if the string follows the pattern, False otherwise.\n    \"\"\"\n    pattern_mapping = {}\n    string_mapping = {}\n    if len(pattern) != len(string):\n        return False\n    for i in range(len(pattern)):\n        if pattern[i] not in pattern_mapping:\n            pattern_mapping[pattern[i]] = string[i]\n        if string[i] not in string_mapping:\n            string_mapping[string[i]] = pattern[i]\n        if pattern_mapping[pattern[i]] != string[i] or string_mapping[string[i]] != pattern[i]:\n            return False\n    return True\n\ndef g(pattern='abc'):\n    string = 'xyz'\n    return string\n\nassert f(g())\n",
        "idx_generation": 221,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers in ascending order, find two numbers that add up to the given target.\n    Return their indices in a list.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15, 18, 23]\n    target = 26\n    return nums, target\n\nassert f(*g()) == [2, 3]\n",
        "idx_generation": 169,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers 'nums' and a target number 'target',\n    determine if there exists a subarray of 'nums' that adds up to 'target'.\n    Return True if such subarray exists, False otherwise.\n    \"\"\"\n    n = len(nums)\n    prefix_sum = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]\n    \n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if prefix_sum[j] - prefix_sum[i] == target:\n                return True\n    \n    return False\n\ndef g(target: int):\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [4, 2, 6, 8, 1, 5]\n    \n    return nums, target\n\nassert f(*g(12)) == True\n",
        "idx_generation": 163,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the nth Fibonacci number.\"\"\"\n    if n <= 1:\n        return n\n    memo = [0] * (n + 1)\n    memo[1] = 1\n    for i in range(2, n + 1):\n        memo[i] = memo[i - 1] + memo[i - 2]\n    return memo[n]\n\ndef g():\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 293,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string, return True if the string is a palindrome.\n    Sample input:\n    \"racecar\"\n    Sample output:\n    True\"\"\"\n    return s == s[::-1]\n\ndef g():\n    return \"madam\"\n\nassert f(g()) == True\n",
        "idx_generation": 223,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\n    Sample input:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    Sample output:\n    True\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        sum = nums[left] + nums[right]\n        if sum == target:\n            return True\n        elif sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5], 7\n\nassert f(*g())\n",
        "idx_generation": 172,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine if the given number n is a prime number.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n    \ndef g(n=17):\n    return n\n\nassert f(g())\n",
        "idx_generation": 166,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a subarray of length 3 such that the middle element is the average of the other two elements.\n    Return True if such subarray exists, False otherwise.\n    \"\"\"\n\n    for i in range(len(arr)-2):\n        if (arr[i] + arr[i+2]) / 2 == arr[i+1]:\n            return True\n    return False\n\ndef g():\n    \"\"\"\n    Generate a list of integers where there exists a subarray of length 3 such that the middle element is the average of the other two elements.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7]\n\nassert f(g())\n",
        "idx_generation": 294,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str, target: str) -> int:\n    \"\"\"Given a string, return the number of occurrences of a target substring in the string.\"\"\"\n    count = 0\n    target_len = len(target)\n    string_len = len(string)\n\n    for i in range(string_len - target_len + 1):\n        if string[i:i + target_len] == target:\n            count += 1\n\n    return count\n\ndef g(string: str, target: str) -> int:\n    return f(string, target)\n\nstring = \"ababababa\"\ntarget = \"aba\"\n\nassert f(string, target) == g(string, target)\n",
        "idx_generation": 229,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order using the bubble sort algorithm.\n    Return the sorted list.\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    return nums\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"\n    Return the input list of integers.\n    \"\"\"\n    return nums\n\nassert f(g([4, 2, 6, 1, 7, 3])) == [1, 2, 3, 4, 6, 7]\n",
        "idx_generation": 172,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, check if there exists a subarray with consecutive elements that sums up to a prime number.\n    Return True if such a subarray exists, otherwise return False.\n    Sample input:\n    [1, 2, 3, 4, 5, 6, 7]\n    Sample output:\n    True\"\"\"\n    n = len(nums)\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]  # List of prime numbers\n    for i in range(n):\n        for j in range(i+1, n+1):\n            subarray = nums[i:j]\n            if sum(subarray) in primes:\n                return True\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7]\n\nassert f(g()) == True\n",
        "idx_generation": 171,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k=3) -> bool:\n    \"\"\"Check if there exists a subsequence of length k in the string s that contains all distinct characters.\"\"\"\n    def dp(i, chars):\n        if len(chars) == k:\n            return True\n        if i == len(s):\n            return False\n        if dp(i+1, chars):\n            return True\n        if s[i] not in chars:\n            return dp(i+1, chars + s[i])\n        return False\n    \n    return dp(0, '')\n\ndef g(k=3):\n    \"\"\"Generate a string with distinct characters that contains a subsequence of length k.\"\"\"\n    chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    return ''.join([chars[i] for i in range(k)])\n\nassert f(g())\n",
        "idx_generation": 297,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome or not.\n    A palindrome is a word, phrase, number, or other sequence of characters \n    that reads the same forward and backward, ignoring spaces, punctuation, and capitalization.\n\n    Example:\n    Input: \"A man, a plan, a canal: Panama\"\n    Output: True\n    \"\"\"\n    s = ''.join(e.lower() for e in s if e.isalnum())\n    return s == s[::-1]\n\ndef g():\n    return \"A man, a plan, a canal: Panama\"\n\nassert f(g()) == True\n",
        "idx_generation": 231,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers 'nums' and a target value 'target',\n    determine if there are two numbers in the list that add up to the target value.\"\"\"\n    \n    # Implementing binary search\n    def binary_search(nums, target):\n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False\n    \n    # Sorting the list\n    nums.sort()\n    \n    # Searching for pairs of numbers that add up to the target\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if binary_search(nums[i+1:], complement):\n            return True\n    \n    return False\n\ndef g():\n    return [1, 3, 5, 7, 9], 12\n\nassert f(*g())\n",
        "idx_generation": 175,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all even Fibonacci numbers less than or equal to n.\n    Return the sum.\n    \"\"\"\n    fib = [1, 2]\n    even_sum = 2\n    while True:\n        next_fib = fib[-1] + fib[-2]\n        if next_fib > n:\n            break\n        if next_fib % 2 == 0:\n            even_sum += next_fib\n        fib.append(next_fib)\n    return even_sum\n\ndef g(n: int) -> int:\n    \"\"\"\n    Return the value of n.\n    \"\"\"\n    return n\n\nassert f(g(100)) == 44\n",
        "idx_generation": 172,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, return the sum of all even numbers from 1 to n (inclusive).\"\"\"\n    if n == 0:\n        return 0\n    if n % 2 == 0:\n        return n + f(n - 2)\n    return f(n - 1)\n\ndef g(n: int) -> int:\n    return f(n)\n\nn = 10\nassert f(n) == g(n)\n",
        "idx_generation": 302,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string is a palindrome, considering only alphanumeric characters and ignoring cases.\"\"\"\n    s = ''.join(c.lower() for c in s if c.isalnum())\n    return s == s[::-1]\n\ndef g(s: str) -> str:\n    return s\n\nassert f(g('A man, a plan, a canal: Panama')) == True\n",
        "idx_generation": 233,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers 'nums' in ascending order, and a target integer 'target',\n    determine if there are two numbers in the list that add up to the target.\n    Return True if such pair exists, False otherwise.\n    \"\"\"\n    n = len(nums)\n    left, right = 0, n-1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5, 6, 7], target=10):\n    \"\"\"\n    Generate a sorted list of integers in ascending order and a target integer.\n    \"\"\"\n    return nums, target\n\nassert f(*g())\n\n",
        "idx_generation": 175,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], x=5) -> bool:\n    \"\"\"Check if the given list contains the number x.\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n    x = 5\n    Sample Output:\n    True\"\"\"\n    return x in nums\n\ndef g(nums=[1, 2, 3, 4, 5]) -> List[int]:\n    \"\"\"Return the given list\"\"\"\n    return nums\n\nassert f(g())\n",
        "idx_generation": 173,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a subset of the integers that adds up to 0.\"\"\"\n    def subset_sum(nums, n, target):\n        if target == 0:\n            return True\n        if n == 0:\n            return False\n        if nums[n-1] > target:\n            return subset_sum(nums, n-1, target)\n        return subset_sum(nums, n-1, target) or subset_sum(nums, n-1, target-nums[n-1])\n    \n    return subset_sum(nums, len(nums), 0)\n\ndef g():\n    return [1, 2, -3, 4, -5, 6]\n\nassert f(g()) == True\n",
        "idx_generation": 303,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str, target: str) -> bool:\n    \"\"\"Check if a string can be formed by rearranging the characters of another string\"\"\"\n    count = {}\n    for char in string:\n        if char in count:\n            count[char] += 1\n        else:\n            count[char] = 1\n    for char in target:\n        if char not in count or count[char] == 0:\n            return False\n        count[char] -= 1\n    return True\n\ndef g():\n    return \"hello\", \"olleh\"\n\nassert f(*g())\n",
        "idx_generation": 234,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, return True if the target value is present in the list, otherwise return False.\n    \"\"\"\n\n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n\n        if arr[mid] == target:\n            return True\n        \n        elif arr[mid] < target:\n            low = mid + 1\n        \n        else:\n            high = mid - 1\n\n    return False\n\n\ndef g(arr: List[int] = [1, 3, 5, 7, 9, 11, 13, 15], target: int = 7):\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 179,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(x: str, y: str) -> bool:\n    \"\"\"Check if the given strings are anagrams.\n    Sample Input:\n    x = \"listen\"\n    y = \"silent\"\n    Sample Output:\n    True\"\"\"\n    return sorted(x) == sorted(y)\n\ndef g() -> Tuple[str, str]:\n    \"\"\"Return two anagram strings\"\"\"\n    return \"listen\", \"silent\"\n\nassert f(*g())\n",
        "idx_generation": 173,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, find if there exists a subset of the list whose sum is 0.\n    Return True if such a subset exists, False otherwise.\n    \"\"\"\n    n = len(nums)\n    dp = [[False] * (n + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if nums[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n    return dp[n][n // 2]\n\ndef g() -> List[int]:\n    \"\"\"Generate a list of integers.\"\"\"\n    return [1, 2, 3, 4, -5]\n\nassert f(g())\n",
        "idx_generation": 304,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str, k: int) -> bool:\n    \"\"\"Given a string and an integer k, return True if there exists a substring of length k such that it contains all unique characters, False otherwise.\"\"\"\n    unique_chars = set()\n    for i in range(len(string)-k+1):\n        substring = string[i:i+k]\n        if len(substring) == len(set(substring)):\n            return True\n    return False\n\ndef g(k: int):\n    string = \"abccba\"\n    return string, k\n\nassert f(*g(3))\n",
        "idx_generation": 234,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Return a new list containing only the even numbers from the given list, sorted in ascending order.\"\"\"\n    even_numbers = [num for num in arr if num % 2 == 0]\n    sorted_numbers = sorted(even_numbers)\n    return sorted_numbers\n\ndef g():\n    arr = [3, 9, 2, 7, 4, 6]\n    return arr\n\nassert f(g()) == [2, 4, 6]\n",
        "idx_generation": 180,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in a list.\n    \"\"\"\n    mapping = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in mapping:\n            return [mapping[complement], i]\n        mapping[num] = i\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 173,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Find if there exists a subarray in arr that sums up to the target value\"\"\"\n    def helper(arr, target, curr_sum, start):\n        if curr_sum == target:\n            return True\n        if curr_sum > target or start >= len(arr):\n            return False\n        return helper(arr, target, curr_sum + arr[start], start + 1) or helper(arr, target, curr_sum, start + 1)\n    \n    return helper(arr, target, 0, 0)\n\ndef g():\n    arr = [1, 3, 5, 7, 9]\n    target = 12\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 304,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"Check if the given string is a palindrome with an odd length.\"\"\"\n    n = len(string)\n    if n % 2 == 0:\n        return False\n    \n    left = 0\n    right = n - 1\n    \n    while left < right:\n        if string[left] != string[right]:\n            return False\n        left += 1\n        right -= 1\n    \n    return True\n\ndef g(string: str):\n    \"\"\"Find the largest palindrome substring in the given string.\"\"\"\n    n = len(string)\n    longest_palindrome = \"\"\n    \n    for i in range(n):\n        for j in range(i, n):\n            substring = string[i:j+1]\n            if substring == substring[::-1] and len(substring) > len(longest_palindrome):\n                longest_palindrome = substring\n    \n    return longest_palindrome\n\nassert f(g(\"madamracecar\"))\n",
        "idx_generation": 234,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers 'nums' and a target integer 'target', determine if there are two numbers in 'nums' that add up to 'target'.\n    Return True if there exists such a pair, otherwise return False.\"\"\"\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    return [1, 3, 5, 7, 9], 12\n\nassert f(*g()) == True\n",
        "idx_generation": 181,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> bool:\n    \"\"\"Check if the binary representation of n has alternating 0s and 1s.\"\"\"\n    binary = bin(n)[2:]\n    for i in range(len(binary) - 1):\n        if binary[i] == binary[i+1]:\n            return False\n    return True\n\ndef g():\n    n = 0\n    while True:\n        if f(n):\n            return n\n        n += 1\n\nassert f(g()) == True\n",
        "idx_generation": 174,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix with distinct elements, find the longest increasing path in the matrix.\n    Return the path as a list of elements.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    def dfs(i, j):\n        if (i, j) in memo:\n            return memo[(i, j)]\n        \n        longest_path = 1\n        \n        for dx, dy in directions:\n            new_i = i + dx\n            new_j = j + dy\n            \n            if 0 <= new_i < rows and 0 <= new_j < cols and matrix[new_i][new_j] > matrix[i][j]:\n                longest_path = max(longest_path, 1 + dfs(new_i, new_j))\n        \n        memo[(i, j)] = longest_path\n        return longest_path\n    \n    longest_path = 0\n    memo = {}\n    \n    for i in range(rows):\n        for j in range(cols):\n            longest_path = max(longest_path, dfs(i, j))\n    \n    return longest_path\n\ndef g(matrix=[[9, 9, 4], [6, 6, 8], [2, 1, 1]]):\n    \"\"\"\n    Generate a matrix with distinct elements where the longest increasing path in the matrix has a non-zero length.\n    \"\"\"\n    return matrix\n\nassert f(g()) == 4\n",
        "idx_generation": 306,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Determine if a given string is a palindrome.\"\"\"\n    return s == s[::-1]\ndef g():\n    return \"racecar\"\nassert f(g())\n",
        "idx_generation": 236,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the array whose sum is equal to a target value.\"\"\"\n    arr.sort()\n    target = 10\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    return [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n\nassert f(g())\n",
        "idx_generation": 182,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of size m x n, find the maximum sum of a subgrid \n    where the subgrid is formed by selecting a rectangular region from the original grid.\"\"\"\n    \n    m = len(grid)\n    n = len(grid[0])\n    \n    # Function to calculate the sum of a subgrid\n    def calculate_subgrid_sum(top_left, bottom_right):\n        sum = 0\n        for i in range(top_left[0], bottom_right[0] + 1):\n            for j in range(top_left[1], bottom_right[1] + 1):\n                sum += grid[i][j]\n        return sum\n    \n    max_sum = float('-inf')\n    \n    # Iterating over all possible subgrids and finding the maximum sum\n    for i in range(m):\n        for j in range(n):\n            for k in range(i, m):\n                for l in range(j, n):\n                    subgrid_sum = calculate_subgrid_sum((i, j), (k, l))\n                    max_sum = max(max_sum, subgrid_sum)\n    \n    return max_sum\n\ndef g():\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g()) == 45\n",
        "idx_generation": 175,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Find a subset of numbers from the given list that sums up to the target number.\"\"\"\n    def subset_sum(nums, target):\n        if target == 0:\n            return True\n        if not nums or target < 0:\n            return False\n        \n        return subset_sum(nums[1:], target-nums[0]) or subset_sum(nums[1:], target)\n    \n    return subset_sum(nums, target)\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 312,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the given list is a palindrome\"\"\"\n    return arr == arr[::-1]\n\ndef g(arr: List[int]) -> List[int]:\n    \"\"\"Reverse the given list\"\"\"\n    return arr[::-1]\n\nassert f(g([1, 2, 3, 4, 3, 2, 1]))\n",
        "idx_generation": 239,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers `nums` and a target number, \n    determine if there exists a pair of numbers in the list whose sum is equal to the target.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    nums = [1, 4, 5, 6, 8, 9]\n    target = 10\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 183,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the given array is a valid mountain array or not.\"\"\"\n    if len(arr) < 3:\n        return False\n    \n    increasing = True\n    for i in range(1, len(arr)):\n        if arr[i] == arr[i-1]:\n            return False\n        \n        if increasing:\n            if arr[i] < arr[i-1]:\n                if i == 1:\n                    return False\n                increasing = False\n        else:\n            if arr[i] > arr[i-1]:\n                return False\n    \n    return not increasing\n\ndef g(arr=[1, 2, 3, 4, 5, 4, 3, 2, 1]):\n    \"\"\"Generate an array of integers.\"\"\"\n    return arr\n\nassert f(g())\n",
        "idx_generation": 175,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum sum of a subarray with the constraint that no two elements in the subarray should be adjacent.\n    Example:\n    Input: [2, 5, 3, 1, 7]\n    Output: 12\n    Explanation: The maximum sum can be achieved by selecting the subarray [2, 3, 7].\n    \"\"\"\n    if not nums:\n        return 0\n    n = len(nums)\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    for i in range(2, n):\n        dp[i] = max(nums[i] + dp[i-2], dp[i-1])\n    return dp[-1]\n\ndef g():\n    nums = [2, 5, 3, 1, 7]\n    return nums\n\nassert f(g()) == 12\n",
        "idx_generation": 315,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"Check if a target number exists in the grid.\"\"\"\n    for row in grid:\n        if str(target) in ''.join(map(str, row)):\n            return True\n    return False\n\ndef g(target: int):\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g(5), 5)\n",
        "idx_generation": 242,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, return the maximum product that can be obtained by multiplying any three numbers from the list.\n    Sample input:\n    [1, 2, 3, 4, 5]\n    Sample output:\n    60\"\"\"\n    nums.sort()\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 60\n\n",
        "idx_generation": 184,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the maximum sum of a subarray in a given array of integers.\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in n:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g(n: List[int]) -> int:\n    return f(n)\n\narr = [1, -2, 3, 4, -1, 2, 1, -5, 4]\nassert f(arr) == g(arr)\n",
        "idx_generation": 176,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence (not necessarily contiguous) in the list.\n    Example:\n    Input: [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j]+1)\n    return max(dp)\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 315,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(pattern: str, word: str) -> bool:\n    \"\"\"Given a pattern and a string, determine if the string follows the same pattern.\n    The pattern follows a specific format where each letter in the pattern corresponds to a non-empty substring in the string.\n    For example, given pattern = \"abab\" and word = \"redblueredblue\", return True since the string follows the pattern.\n    Sample input:\n    pattern = \"abab\"\n    word = \"redblueredblue\"\n    Sample output:\n    True\"\"\"\n    words = word.split()\n    if len(pattern) != len(words):\n        return False\n\n    pattern_map = {}\n    word_map = {}\n\n    for p, w in zip(pattern, words):\n        if p not in pattern_map:\n            pattern_map[p] = w\n        if w not in word_map:\n            word_map[w] = p\n        if pattern_map[p] != w or word_map[w] != p:\n            return False\n\n    return True\n\ndef g():\n    return \"abab\", \"red blue red blue\"\n\nassert f(*g())\n",
        "idx_generation": 245,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers that sum up to the given target.\n    Return True if such numbers exist, otherwise return False.\n    \n    Sample input:\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 8\n    \n    Sample output:\n    True\n    (because 2 + 6 = 8)\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6], 8\n\nassert f(*g())\n",
        "idx_generation": 186,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum sum of any subarray within the list.\n    Return the maximum sum.\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for num in arr:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"Generate a list of integers.\"\"\"\n    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    \n    return arr\n\nassert f(g()) == 6\n",
        "idx_generation": 177,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Count the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\n    The only allowed movements are rightwards and downwards.\n    Return the total number of unique paths.\n    \"\"\"\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][0] = 1\n        dp[0][i] = 1\n    \n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[n-1][n-1]\n\ndef g(n=3):\n    \"\"\"\n    Generate a random value for n, representing the size of the grid.\n    \"\"\"\n    return n\n\nassert f(g()) == 6\n",
        "idx_generation": 317,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Given a string, reverse the order of words in the string.\"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string\n\ndef g():\n    s = \"Hello World! I am a programmer.\"\n    return s\n\nassert f(g()) == \"programmer. a am I World! Hello\"\n",
        "idx_generation": 246,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers arr and a target value, find the index of the target value in the list using binary search. If the target value is not found, return -1.\"\"\"\n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1\n\ndef g():\n    return [2, 4, 6, 8, 10, 12], 8\n\nassert f(*g()) == 3\n",
        "idx_generation": 187,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a given number n is a prime number and a perfect square at the same time.\"\"\"\n    if n <= 1:\n        return False\n    elif n == 2:\n        return True\n    else:\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return (int(n**0.5))**2 == n\n\ndef g():\n    i = 2\n    while True:\n        if f(i):\n            return i\n        i += 1\n\nassert f(g())\n",
        "idx_generation": 177,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if it is possible to obtain the target sum by using a subset of elements from the array arr\"\"\"\n    n = len(arr)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    \n    for i in range(n + 1):\n        dp[i][0] = True\n    \n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if arr[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j - arr[i - 1]] or dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    \n    return dp[n][target]\n\ndef g(arr: List[int], target: int) -> List[int]:\n    \"\"\"Generate an array with elements that satisfy the condition for f\"\"\"\n    return arr + [target]\n\nassert f(g([2, 4, 6, 8], 10), 10)\n",
        "idx_generation": 319,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Check if two strings are anagrams of each other.\n    Return True if they are anagrams, False otherwise.\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n    count = [0] * 26\n    for char in s1:\n        count[ord(char) - ord('a')] += 1\n    for char in s2:\n        count[ord(char) - ord('a')] -= 1\n    return all(count[i] == 0 for i in range(26))\n\ndef g():\n    s1 = \"listen\"\n    s2 = \"silent\"\n    return s1, s2\n\nassert f(*g())\n",
        "idx_generation": 255,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, sort the list in non-decreasing order (ascending) and return the sorted list.\"\"\"\n    nums.sort()\n    return nums\n\ndef g():\n    return [5, 2, 9, 1, 7, 3]\n\nassert f(g()) == [1, 2, 3, 5, 7, 9]\n",
        "idx_generation": 188,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find whether the given number n is a power of 2.\"\"\"\n    if n <= 0:\n        return False\n    while n > 1:\n        if n % 2 != 0:\n            return False\n        n //= 2\n    return True\n\ndef g() -> int:\n    n = 1\n    while True:\n        if f(n):\n            return n\n        n += 1\n\nassert f(g())\n",
        "idx_generation": 179,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the longest increasing subsequence (LIS).\n    The LIS is a subsequence of the input sequence in which the elements are in increasing order.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g(nums=[10, 9, 2, 5, 3, 7, 101, 18]):\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 321,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], prefix: str) -> int:\n    \"\"\"\n    Given a list of words and a prefix, count the number of words in the list that start with the prefix.\n    Return the count of such words.\n    \"\"\"\n    count = 0\n    for word in words:\n        if word.startswith(prefix):\n            count += 1\n    return count\n\ndef g():\n    words = [\"apple\", \"banana\", \"avocado\", \"orange\", \"apricot\"]\n    prefix = \"a\"\n    return words, prefix\n\nassert f(*g()) == 3\n",
        "idx_generation": 261,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Check if the target value exists in the matrix, where each row and column is sorted in ascending order.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    row = 0\n    col = cols - 1\n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] > target:\n            col -= 1\n        else:\n            row += 1\n    return False\n\ndef g():\n    return ([[1, 4, 7],\n             [2, 5, 8],\n             [3, 6, 9]], 5)\n\nassert f(*g())\n",
        "idx_generation": 188,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> float:\n    \"\"\"Given a list of 2D points, find the minimum distance between any two points.\n\n    Args:\n        points (List[List[int]]): The list of 2D points.\n\n    Returns:\n        float: The minimum distance between any two points.\n    \"\"\"\n    min_distance = float('inf')\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            distance = ((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) ** 0.5\n            min_distance = min(min_distance, distance)\n    return min_distance\n\ndef g(points: List[List[int]]) -> List[List[int]]:\n    return points\n\npoints = [[0, 0], [1, 1], [2, 2], [3, 3]]\nassert f(g(points)) == 1.4142135623730951\n",
        "idx_generation": 182,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], k: int) -> bool:\n    \"\"\"\n    Given a 2D grid of integers, determine if it is possible to reach the bottom-right cell from the top-left cell\n    by moving only rightward, downward, or diagonally. Additionally, you can only make at most k turns while moving.\n    Return True if it is possible, otherwise return False.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    # Initialize the dynamic programming table\n    dp = [[[False] * (k + 1) for _ in range(n)] for _ in range(m)]\n\n    # Base case: the top-left cell is reachable\n    dp[0][0][0] = True\n\n    # Fill in the dynamic programming table\n    for i in range(m):\n        for j in range(n):\n            for t in range(k + 1):\n                if dp[i][j][t]:\n                    # Move right\n                    if j + 1 < n and (grid[i][j + 1] != 1 or t > 0):\n                        dp[i][j + 1][t] = True\n                    # Move down\n                    if i + 1 < m and (grid[i + 1][j] != 1 or t > 0):\n                        dp[i + 1][j][t] = True\n                    # Move diagonally\n                    if i + 1 < m and j + 1 < n and (grid[i + 1][j + 1] != 1 or t > 0):\n                        dp[i + 1][j + 1][t] = True\n                # Make a turn\n                if t + 1 <= k:\n                    # Move right\n                    if j + 1 < n and (grid[i][j + 1] != 1 or t > 0):\n                        dp[i][j + 1][t + 1] = True\n                    # Move down\n                    if i + 1 < m and (grid[i + 1][j] != 1 or t > 0):\n                        dp[i + 1][j][t + 1] = True\n                    # Move diagonally\n                    if i + 1 < m and j + 1 < n and (grid[i + 1][j + 1] != 1 or t > 0):\n                        dp[i + 1][j + 1][t + 1] = True\n\n    # Return the value in the bottom-right cell\n    return dp[m - 1][n - 1][k]\n\ndef g(k: int):\n    return [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n\nassert f(g(2), 2)\n",
        "idx_generation": 324,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string s, determine if it is a palindrome.\n    A palindrome is a string that reads the same forwards and backwards, ignoring spaces, punctuation, and capitalization.\"\"\"\n    s = ''.join(c.lower() for c in s if c.isalpha())\n    return s == s[::-1]\n\ndef g(s: str) -> str:\n    \"\"\"Reverse the given string.\"\"\"\n    return s[::-1]\n\nassert f(g(\"A man, a plan, a canal: Panama\"))\n",
        "idx_generation": 267,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers, determine if there exists two elements whose sum is equal to the target.\"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(arr=[1, 2, 3, 4, 5], target=9):\n    return arr\n\nassert f(g(), target=9) == True\n",
        "idx_generation": 191,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\nimport math\n\ndef f(points: List[List[int]]) -> bool:\n    \"\"\"Given a list of 2D points, check if these points form a square.\n    Return True if the points form a square, otherwise return False.\n    Sample input:\n    [[0, 0], [0, 1], [1, 1], [1, 0]]\n    Sample output:\n    True\"\"\"\n    if len(points) != 4:\n        return False\n    distances = []\n    for i in range(4):\n        for j in range(i+1, 4):\n            distance = math.sqrt((points[i][0] - points[j][0])**2 + (points[i][1] - points[j][1])**2)\n            distances.append(distance)\n    return len(set(distances)) == 2 and distances.count(max(distances)) == 2\n\ndef g():\n    return [[0, 0], [0, 1], [1, 1], [1, 0]]\n\nassert f(g()) == True\n",
        "idx_generation": 185,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given an integer n, return the nth Fibonacci number.\n    Example:\n    Input: n = 6\n    Output: 8\n    Explanation: The 6th Fibonacci number is 8.\n    \"\"\"\n    if n <= 1:\n        return n\n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\ndef g():\n    n = 6\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 326,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> str:\n    \"\"\"Given a string, reverse the order of words while preserving the order of characters within each word.\"\"\"\n    words = string.split()\n    reversed_words = [word[::-1] for word in words]\n    return ' '.join(reversed_words)\n\ndef g():\n    return \"Hello world\"\n\nassert f(g()) == \"olleH dlrow\"\n",
        "idx_generation": 276,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in the list that sum up to the target.\n    Return the indices of the two numbers as a list.\n    \"\"\"\n    num_dict = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        if complement in num_dict:\n            return [num_dict[complement], i]\n        \n        num_dict[num] = i\n    \n    return []\n\ndef g():\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 193,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if there exists a pair of elements in the given array such that their sum is divisible by 5.\"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(i+1, n):\n            if (arr[i] + arr[j]) % 5 == 0:\n                return True\n    return False\n\ndef g():\n    return [3, 7, 2, 8, 1, 4]\n\nassert f(g())\n",
        "idx_generation": 185,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string s, determine if it is a palindrome after removing exactly one character from it.\"\"\"\n    left = 0\n    right = len(s) - 1\n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s, left+1, right) or is_palindrome(s, left, right-1)\n        left += 1\n        right -= 1\n    return True\n\ndef is_palindrome(s: str, left: int, right: int) -> bool:\n    while left < right:\n        if s[left] != s[right]:\n            return False\n        left += 1\n        right -= 1\n    return True\n\ndef g():\n    return \"raceacar\"\n\nassert f(s=g())\n",
        "idx_generation": 327,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"Check if a given string is a palindrome\"\"\"\n    return string == string[::-1]\ndef g(string=\"racecar\"):\n    return string\nassert f(g())\n",
        "idx_generation": 280,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target value. Return True if such pair exists, False otherwise.\"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [-2, 0, 3, 5, 7, 9, 11, 13]\n\ntarget = 10\nassert f(g(), target)\n\n",
        "idx_generation": 193,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given an integer array nums, find the sum of the elements that appear only once in the array.\"\"\"\n    unique_nums = []\n    non_unique_nums = set()\n    for num in nums:\n        if num not in non_unique_nums:\n            if num in unique_nums:\n                unique_nums.remove(num)\n                non_unique_nums.add(num)\n            else:\n                unique_nums.append(num)\n    return sum(unique_nums)\n\ndef g(nums=[1, 2, 3, 2, 4, 5, 4]):\n    return nums\n\nassert f(g()) == 9\n",
        "idx_generation": 187,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers nums and a target number,\n    find the minimum number of elements in nums that sum up to the target.\n    Each number in nums can be used multiple times.\n    Return the minimum number of elements required.\"\"\"\n\n    dp = [float('inf')] * (target + 1)\n    dp[0] = 0\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if num <= i:\n                dp[i] = min(dp[i], dp[i - num] + 1)\n\n    return dp[target]\n\ndef g():\n    return [1, 2, 5]\n\nassert f(g(), 11) == 3\n",
        "idx_generation": 330,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, check if it is a palindrome after removing all non-alphanumeric characters and converting it to lowercase.\n    Return True if the resulting string is a palindrome, False otherwise.\n    \"\"\"\n    s = ''.join(c.lower() for c in s if c.isalnum())\n    return s == s[::-1]\n\ndef g() -> str:\n    \"\"\"\n    Generate a string containing alphanumeric and non-alphanumeric characters.\n    \"\"\"\n    return \"A man, a plan, a canal: Panama!\"\n\nassert f(g()) == True\n",
        "idx_generation": 286,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers, determine if there exists two numbers in the array such that their sum is equal to the target value.\n    Return True if such pair exists, otherwise return False.\"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr=[1, 2, 3, 4, 5, 6], target=9):\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 195,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, return a new list with all the elements duplicated.\"\"\"\n    duplicated_arr = []\n    for num in arr:\n        duplicated_arr.append(num)\n        duplicated_arr.append(num)\n    return duplicated_arr\n\ndef g(arr: List[int]):\n    \"\"\"Return a list of integers with all the elements reversed.\"\"\"\n    return arr[::-1]\n\n# Test the solution\narr = [1, 2, 3, 4, 5]\nassert f(g(arr)) == [5, 5, 4, 4, 3, 3, 2, 2, 1, 1]\n",
        "idx_generation": 188,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any subarray.\n    Return the maximum sum.\n    Example:\n    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    The subarray [4, -1, 2, 1] has the maximum sum of 6.\n    Therefore, the answer is 6.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in arr:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 333,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n=1) -> bool:\n    \"\"\"Check if a given string is a palindrome.\"\"\"\n    return s == s[::-1]\n\ndef g():\n    return \"racecar\"\n\nassert f(g())\n",
        "idx_generation": 293,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers, find the index of the target element using binary search.\n    If the target element is not found, return -1.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\n\ndef g(arr: List[int] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target: int = 6):\n    return arr, target\n\nassert f(*g()) == 5\n",
        "idx_generation": 196,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum sum of a subarray in the given list.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(current_sum + num, num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 190,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given an array of integers nums, return True if there exists a subsequence of the array that is strictly increasing, otherwise return False.\"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp) >= 3\n\ndef g(nums=[1, 2, 3, 1, 2]):\n    return nums\n\nassert f(g())\n",
        "idx_generation": 334,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string 's' consisting of only uppercase English letters, find the length of the longest substring without repeating characters.\n    Return the length of the longest substring.\n    \"\"\"\n    n = len(s)\n    max_length = 0\n    start = 0\n    char_map = {}\n\n    for end in range(n):\n        if s[end] in char_map:\n            start = max(start, char_map[s[end]] + 1)\n        max_length = max(max_length, end - start + 1)\n        char_map[s[end]] = end\n\n    return max_length\n\ndef g():\n    \"\"\"\n    Generate a string consisting of uppercase English letters.\n    \"\"\"\n    s = \"ABACDEFGH\"\n    return s\n\nassert f(g()) == 8\n",
        "idx_generation": 304,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Sort the given array in ascending order using the bubble sort algorithm\"\"\"\n    n = len(arr)\n    for i in range(n-1):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\n\ndef g(arr=[9, 1, 5, 3, 7, 2, 4, 6, 8]):\n    \"\"\"Generate an array of integers\"\"\"\n    return arr\n\nassert f(g()) == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n",
        "idx_generation": 196,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, find the sum of all numbers from 1 to n that are divisible by 3 or 5.\n    Return the sum.\"\"\"\n    if n <= 0:\n        return 0\n    \n    total_sum = 0\n    for i in range(1, n+1):\n        if i % 3 == 0 or i % 5 == 0:\n            total_sum += i\n    \n    return total_sum\n\ndef g() -> int:\n    \"\"\"Generate a positive integer.\"\"\"\n    return 10\n\nassert f(g()) == 33\n",
        "idx_generation": 191,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the n-th Fibonacci number.\"\"\"\n    if n <= 1:\n        return n\n    \n    fib = [0, 1]\n    \n    for i in range(2, n+1):\n        fib.append(fib[i-1] + fib[i-2])\n    \n    return fib[n]\n\ndef g():\n    n = 6\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 337,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of the words in the string.\n    \"\"\"\n    words = string.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)\n\ndef g():\n    return \"Hello World!\"\n\nassert f(g()) == \"World! Hello\"\n",
        "idx_generation": 305,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\n    Return True if such a pair exists, otherwise return False.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    return ([1, 2, 3, 4, 5], 8)\n\nassert f(*g()) == True\n",
        "idx_generation": 200,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, calculate the nth Fibonacci number.\n    Return the nth Fibonacci number.\"\"\"\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    \n    fib_list = [0, 1]\n    \n    for i in range(2, n+1):\n        fib_list.append(fib_list[i-1] + fib_list[i-2])\n    \n    return fib_list[n]\n\ndef g() -> int:\n    \"\"\"Generate a positive integer.\"\"\"\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 191,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if it is possible to construct the target value\n    by summing a subset of the integers in the list.\n    \"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(1, n + 1):\n        for j in range(target + 1):\n            if j < nums[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n    return dp[n][target]\n\ndef g(nums: List[int], target: int) -> List[int]:\n    return nums, target\n\nnums = [2, 4, 6, 8]\ntarget = 10\nassert f(*g(nums, target)) == True\n",
        "idx_generation": 339,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Given two strings s1 and s2, determine if s2 is a rotation of s1.\"\"\"\n    if len(s1) != len(s2):\n        return False\n    s1 += s1\n    return s2 in s1\n\ndef g():\n    return ('waterbottle', 'erbottlewat')\n\nassert f(*g())\n",
        "idx_generation": 316,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers, determine if there exists a pair of numbers that sum up to the target value.\n    Return True if such a pair exists, False otherwise.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\ntarget = 14\n\nassert f(g(), target)\n",
        "idx_generation": 200,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a number is a prime number.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    return 13\n\nassert f(g()) == True\n",
        "idx_generation": 193,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Given a list of numbers, determine if there exists a subset whose sum is equal to the target value.\n    Return True if such a subset exists, False otherwise.\n    \"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if nums[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[n][target]\ndef g(nums=[1, 2, 3, 4, 5]):\n    return nums\nassert f(g())\n",
        "idx_generation": 339,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import itertools\nfrom typing import*\nfrom itertools import permutations\n\ndef f(word_list: List[str], target: str) -> bool:\n    \"\"\"Given a list of words and a target string, determine if it is possible to form the target string\n    by concatenating the words in the list, without any repetition. Return True if possible, False otherwise.\"\"\"\n    perms = permutations(word_list)\n    for perm in perms:\n        concat = ''.join(perm)\n        if concat == target:\n            return True\n    return False\n\ndef g(word_list: List[str], target: str):\n    \"\"\"Find a permutation of the words in the list that forms the target string by concatenation.\"\"\"\n    perms = permutations(word_list)\n    for perm in perms:\n        concat = ''.join(perm)\n        if concat == target:\n            return perm\n    return []\n\nword_list = ['apple', 'banana', 'pear']\ntarget = 'applebananapear'\nassert f(g(word_list, target), target)\n",
        "idx_generation": 317,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int, start: int = 0, end: int = -1) -> bool:\n    \"\"\"Given a sorted array of integers, find if there exists a pair of elements such that their sum is equal to the target value.\n    The function should return True if such a pair exists, and False otherwise.\n    \"\"\"\n    if end == -1:\n        end = len(arr) - 1\n    \n    while start < end:\n        curr_sum = arr[start] + arr[end]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            start += 1\n        else:\n            end -= 1\n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    target = 9\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 201,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers and a target number, find two numbers in the list that add up to the target.\n    Return a list containing the indices of the two numbers.\"\"\"\n    \n    complement = {}\n    \n    for i, num in enumerate(nums):\n        if target - num in complement:\n            return [complement[target - num], i]\n        complement[num] = i\n    \n    return []\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"Generate a list of integers and a target number.\"\"\"\n    return (nums, target)\n\nnums = [2, 7, 11, 15]\ntarget = 9\n\nassert f(*g(nums, target)) == [0, 1]\n",
        "idx_generation": 198,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of numbers, find the maximum sum that can be obtained by selecting a subarray with the constraint that no two numbers in the subarray are adjacent.\n    Return the maximum sum.\n    \"\"\"\n    if len(nums) == 0:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    if len(nums) == 2:\n        return max(nums[0], nums[1])\n    \n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    \n    for i in range(2, len(nums)):\n        dp[i] = max(nums[i] + dp[i-2], dp[i-1])\n    \n    return dp[-1]\n\ndef g() -> List[int]:\n    return [1, 2, 3, 1]\n  \nassert f(g()) == 4\n",
        "idx_generation": 340,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Reverse the words in a given string, while keeping the order of the words intact.\"\"\"\n    words = s.split()\n    reversed_words = [word[::-1] for word in words]\n    return ' '.join(reversed_words)\n\ndef g() -> str:\n    \"\"\"Generate a string with multiple words.\"\"\"\n    return \"hello world python programming\"\n\nassert f(g()) == \"olleh dlrow nohtyp gnimmargorp\"\n",
        "idx_generation": 318,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, sort the list in ascending order and return the sorted list.\"\"\"\n    return sorted(nums)\n\ndef g(nums: List[int]) -> List[int]:\n    return f(nums)\n\nnums = [4, 2, 7, 1, 5]\nassert f(nums) == g(nums)\n",
        "idx_generation": 203,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Given an array of integers, find the length of the longest increasing subsequence.\n    - A subsequence is a sequence that can be derived from the given array by deleting some or no elements\n      without changing the order of the remaining elements.\n    - Return the length of the longest increasing subsequence.\"\"\"\n    def dfs(i, prev):\n        if i == len(nums):\n            return 0\n        if nums[i] > prev:\n            return max(1 + dfs(i+1, nums[i]), dfs(i+1, prev))\n        return dfs(i+1, prev)\n    return dfs(0, float('-inf'))\n\ndef g(nums: List[int]):\n    return nums\n\nassert f(g([10, 9, 2, 5, 3, 7, 101, 18])) == 4\n",
        "idx_generation": 201,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> int:\n    \"\"\"Find the maximum subarray sum of length k in the given array\"\"\"\n    max_sum = curr_sum = sum(arr[:k])\n    for i in range(k, len(arr)):\n        curr_sum += arr[i] - arr[i - k]\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef g():\n    return ([1, -2, 3, -4, 5], 3)\n\nassert f(*g()) == 4\n",
        "idx_generation": 341,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], sub_str: str) -> int:\n    \"\"\"\n    Given a list of integers 'nums' and a substring 'sub_str', count the number of times the substring appears\n    as a contiguous sequence of digits in the concatenation of all the numbers in the list.\n    Return the count.\n    \"\"\"\n    concat_str = ''.join(map(str, nums))\n    count = 0\n    sub_len = len(sub_str)\n    \n    for i in range(len(concat_str) - sub_len + 1):\n        if concat_str[i:i+sub_len] == sub_str:\n            count += 1\n    \n    return count\n\ndef g():\n    \"\"\"\n    Generate a list of integers and a substring.\n    \"\"\"\n    nums = [123, 456, 789]\n    sub_str = '45'\n    \n    return nums, sub_str\n\nassert f(*g()) == 1\n\n",
        "idx_generation": 319,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a perfect square.\n    Return True if n is a perfect square, otherwise return False.\n    \"\"\"\n    if n < 0:\n        return False\n    if n == 0 or n == 1:\n        return True\n    \n    left, right = 1, n\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if mid * mid == n:\n            return True\n        elif mid * mid < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return False\n\ndef g():\n    return 16\n\nassert f(g())\n",
        "idx_generation": 205,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all positive integers less than n that are divisible by 3 or 5.\n    \"\"\"\n    total = 0\n    for i in range(n):\n        if i % 3 == 0 or i % 5 == 0:\n            total += i\n    return total\n\ndef g():\n    return 100\n\nassert f(g()) == 2318\n",
        "idx_generation": 203,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Given a matrix of integers, find the number of paths from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n    Example:\n    Input: [[1, 1, 1],\n            [1, 1, 1],\n            [1, 1, 1]]\n    Output: 6\"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n    \n    for i in range(m):\n        for j in range(n):\n            if i == 0 or j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a matrix of integers valid for the problem.\"\"\"\n    return [[1, 1, 1],\n            [1, 1, 1],\n            [1, 1, 1]]\n\nassert f(g()) == 6\n",
        "idx_generation": 343,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a given string is a palindrome.\"\"\"\n    return s == s[::-1]\n\ndef g():\n    \"\"\"Generate a palindrome string.\"\"\"\n    return \"racecar\"\n\nassert f(g())\n",
        "idx_generation": 320,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target\"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5], target: int = 9):\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 206,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the product of all the elements.\n    \n    Return the product.\n    \"\"\"\n    product = 1\n    for num in nums:\n        product *= num\n    return product\n\ndef g(nums: List[int]) -> int:\n    return f(nums)\n\nnums = [1, 2, 3, 4, 5]\nassert f(nums) == g(nums)\n\n",
        "idx_generation": 206,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target sum, find if there exists a subset of the list\n    that sums to the target.\n    Example:\n    Input: [1, 5, 11, 5]\n           Target: 10\n    Output: True\"\"\"\n    def subset_sum(nums, target):\n        n = len(nums)\n        dp = [[False] * (target+1) for _ in range(n+1)]\n        \n        for i in range(n+1):\n            dp[i][0] = True\n        \n        for i in range(1, n+1):\n            for j in range(1, target+1):\n                if nums[i-1] > j:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i-1]]\n        \n        return dp[n][target]\n    \n    return subset_sum(nums, target)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Generate a tuple with a list of integers and a target sum valid for the problem.\"\"\"\n    return [1, 5, 11, 5], 10\n\nassert f(*g()) == True\n",
        "idx_generation": 343,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Reverse the order of words in a given string.\"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    return \" \".join(reversed_words)\n\ndef g():\n    \"\"\"Generate a string with multiple words.\"\"\"\n    return \"Hello, world!\"\n\nassert f(g()) == \"world! Hello,\"\n",
        "idx_generation": 320,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if there exists a pair of numbers\n    in the list whose sum is equal to the target number.\n    \n    Return True if such a pair exists, False otherwise.\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums: List[int], target: int) -> bool:\n    return f(nums, target)\n\nnums = [1, 2, 3, 4, 5]\ntarget = 9\nassert f(nums, target) == g(nums, target)\n\n",
        "idx_generation": 206,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import Tuple\n\ndef f(matrix: List[List[int]], target: int) -> Tuple[int, int]:\n    \"\"\"Given a matrix of integers and a target value, find the position of the target in the matrix.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    row = 0\n    col = cols - 1\n    \n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return row, col\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n    \n    return -1, -1\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]], 5\n\nassert f(*g()) == (1, 1)\n",
        "idx_generation": 212,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D matrix of integers, find the maximum sum of any path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n    \"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = matrix[0][0]\n\n    # Initialize first row\n    for i in range(1, n):\n        dp[0][i] = dp[0][i-1] + matrix[0][i]\n\n    # Initialize first column\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n\n    # Fill in the rest of the dp table\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    return dp[m-1][n-1]\n\ndef g(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Generate a 2D matrix of integers with random values.\n    \"\"\"\n    return matrix\n\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nassert f(g(matrix)) == 29\n\n",
        "idx_generation": 344,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str, k: int) -> bool:\n    \"\"\"Given a string 'string' and an integer 'k',\n    determine if it is possible to rearrange the characters in 'string'\n    in such a way that there are no two adjacent characters that are the same,\n    and the resulting string has exactly 'k' distinct characters.\n    Return True if it is possible, False otherwise.\n    Example:\n    string = \"aabbc\"\n    k = 3\n    The possible rearrangements are \"abcab\", \"bacab\", and \"bcaab\".\n    All of these rearrangements have no two adjacent characters that are the same,\n    and they have exactly 3 distinct characters.\n    Therefore, the answer is True.\n    \"\"\"\n    if len(set(string)) < k:\n        return False\n    return True\n\ndef g():\n    return \"aabbc\", 3\n\nassert f(*g())\n",
        "idx_generation": 322,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there exist three integers\n    in the list whose sum is equal to the target number.\n\n    Return True if such three integers exist, False otherwise.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    for i in range(n - 2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            if current_sum == target:\n                return True\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g():\n    nums = [3, 2, 4, 5, 1]\n    target = 10\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 206,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, p: int) -> bool:\n    \"\"\"Given three integers n, m, p, determine if it is possible to construct a grid of size n x m\n    such that the sum of all elements in the grid is divisible by p.\n    Return True if such grid is possible, False otherwise.\"\"\"\n    if (n * m) % p != 0:\n        return False\n    return True\n\ndef g() -> Tuple[int, int, int]:\n    \"\"\"Generate three integers n, m, p.\"\"\"\n    n = 4\n    m = 3\n    p = 2\n    \n    return n, m, p\n\nassert f(*g()) == True\n",
        "idx_generation": 216,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of ways to climb a staircase with n steps, where each step can be taken either 1 or 2 steps at a time\"\"\"\n    if n <= 1:\n        return 1\n    return f(n - 1) + f(n - 2)\n\ndef g():\n    return 4\n\nassert f(g()) == 5\n",
        "idx_generation": 346,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"Count the number of lowercase vowels in the given string.\"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    for char in s:\n        if char.islower() and char in vowels:\n            count += 1\n    return count\n\ndef g():\n    return \"Hello, World!\"\n\nassert f(g()) == 3\n",
        "idx_generation": 323,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Find the maximum sum of a contiguous subarray within the given list, such that the sum is less than or equal to the target value.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        if current_sum <= target:\n            max_sum = max(max_sum, current_sum)\n        else:\n            current_sum = num\n    return max_sum\ndef g(target=10):\n    nums = [1, 2, 3, 4, 5]\n    return nums\nassert f(g()) == 10\n",
        "idx_generation": 207,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, return a new list where each element is the product of all the other elements in the original list.\"\"\"\n    product = 1\n    zero_count = 0\n\n    for num in nums:\n        if num != 0:\n            product *= num\n        else:\n            zero_count += 1\n\n    res = []\n\n    for num in nums:\n        if zero_count > 1:\n            res.append(0)\n        elif zero_count == 1:\n            if num != 0:\n                res.append(0)\n            else:\n                res.append(product)\n        else:\n            res.append(product // num)\n\n    return res\n\ndef g(nums: List[int]):\n    return nums\n\nassert f(g([1, 2, 3, 4, 5])) == [120, 60, 40, 30, 24]\n",
        "idx_generation": 219,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Check if it is possible to partition the given list into k subarrays such that the sum of each subarray is equal.\"\"\"\n    totalSum = sum(nums)\n    targetSum = totalSum // k\n    if totalSum % k != 0:\n        return False\n    visited = [False] * len(nums)\n    \n    def partition(nums, k, target, currSum, start):\n        if k == 1:\n            return True\n        if currSum == target:\n            return partition(nums, k - 1, target, 0, 0)\n        for i in range(start, len(nums)):\n            if not visited[i] and currSum + nums[i] <= target:\n                visited[i] = True\n                if partition(nums, k, target, currSum + nums[i], i + 1):\n                    return True\n                visited[i] = False\n        return False\n\n    return partition(nums, k, targetSum, 0, 0)\n\ndef g():\n    return [2, 2, 3, 5, 4, 1, 1], 3\n\nassert f(*g())\n",
        "idx_generation": 347,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Find if the given string is a palindrome, ignoring non-alphanumeric characters and case sensitivity.\"\"\"\n    s = ''.join(ch.lower() for ch in s if ch.isalnum())\n    return s == s[::-1]\n\ndef g():\n    \"\"\"Generate a palindrome string.\"\"\"\n    return \"A man, a plan, a canal, Panama!\"\n\nassert f(g())\n",
        "idx_generation": 325,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Find the smallest missing positive number in the given list\"\"\"\n    n = len(arr)\n    for i in range(n):\n        while 1 <= arr[i] <= n and arr[i] != arr[arr[i] - 1]:\n            arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1]\n\n    for i in range(n):\n        if arr[i] != i + 1:\n            return i + 1\n\n    return n + 1\n\ndef g(arr: List[int]) -> List[int]:\n    \"\"\"Generate a list of positive numbers\"\"\"\n    return arr\n\nassert f(g([3, 4, -1, 1])) == 2\n",
        "idx_generation": 208,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of integers, determine if there exists a path from the top-left cell (0, 0) to the bottom-right cell (n-1, m-1)\n    such that the sum of all the numbers along the path is a prime number.\n    Note: You can only move down or right in the grid.\n    Example:\n    Input:\n    [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    Output: True (1 -> 2 -> 3 -> 6 -> 9 is a valid path with sum 21, which is prime.)\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, m):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return is_prime(dp[n-1][m-1])\n\ndef g(grid: List[List[int]]):\n    return grid\n\nassert f(g([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n",
        "idx_generation": 221,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Find the minimum sum of a path from the top-left cell to the bottom-right cell in the given matrix, moving only right or down.\"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = matrix[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = matrix[i][j] + min(dp[i-1][j], dp[i][j-1])\n    return dp[m-1][n-1]\n\ndef g(matrix=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    \"\"\"Generate a matrix of integers.\"\"\"\n    return matrix\n\nassert f(g()) == 7\n",
        "idx_generation": 351,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, check if it is a palindrome after removing all non-alphanumeric characters\n    and ignoring case sensitivity.\n    \"\"\"\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    \n    return s == s[::-1]\n\ndef g():\n    return \"A man, a plan, a canal: Panama\"\n\nassert f(g()) == True\n",
        "idx_generation": 329,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers that sum up to the target value.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 15\n\nassert f(*g()) == True\n",
        "idx_generation": 212,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k=5) -> bool:\n    \"\"\"Find n such that n is a multiple of k and the sum of its digits is a multiple of k\"\"\"\n    digit_sum = sum(map(int, str(n)))\n    return n % k == 0 and digit_sum % k == 0\n\ndef g(k=5):\n    n = 1\n    while True:\n        digit_sum = sum(map(int, str(n)))\n        if n % k == 0 and digit_sum % k == 0:\n            return n\n        n += 1\n\nassert f(g())\n",
        "idx_generation": 222,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum subarray sum in the given array.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    \"\"\"Generate an array of integers.\"\"\"\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 351,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string 's', return True if it is a palindrome, and False otherwise.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward,\n    ignoring spaces, punctuation, and capitalization.\n    \"\"\"\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    return s == s[::-1]\n\ndef g():\n    s = \"A man, a plan, a canal, Panama!\"\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 332,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Given a sorted 2D matrix 'matrix' and a target value, determine if the target is present in the matrix.\"\"\"\n    if not matrix:\n        return False\n    rows = len(matrix)\n    cols = len(matrix[0])\n    row = 0\n    col = cols - 1\n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n    return False\n\ndef g():\n    matrix = [\n        [1, 4, 7, 11, 15],\n        [2, 5, 8, 12, 19],\n        [3, 6, 9, 16, 22],\n        [10, 13, 14, 17, 24],\n        [18, 21, 23, 26, 30]\n    ]\n    target = 9\n    return matrix, target\n\nassert f(*g())\n",
        "idx_generation": 214,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum sum of a subarray (contiguous elements) in the list.\n    Return the maximum sum.\"\"\"\n    n = len(arr)\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for i in range(n):\n        current_sum += arr[i]\n        if current_sum > max_sum:\n            max_sum = current_sum\n        if current_sum < 0:\n            current_sum = 0\n\n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"Return a list of integers\"\"\"\n    return [1, -3, 2, 1, -1, 4, -2, 5, -1]\n\nassert f(g()) == 9\n",
        "idx_generation": 224,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers 'nums', determine if it can be partitioned into two subsets such that the sum of elements in both subsets is equal.\"\"\"\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n    target_sum = total_sum // 2\n    n = len(nums)\n    dp = [[False] * (target_sum + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target_sum + 1):\n            if j < nums[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n    return dp[n][target_sum]\n\ndef g():\n    return [1, 5, 11, 5]\n\nassert f(g())\n",
        "idx_generation": 354,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string 's', determine if it is a palindrome after deleting at most one character.\n    Return True if it is a palindrome, False otherwise.\n    \"\"\"\n    def is_palindrome(s: str, left: int, right: int) -> bool:\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n    \n    n = len(s)\n    left = 0\n    right = n - 1\n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s, left + 1, right) or is_palindrome(s, left, right - 1)\n        left += 1\n        right -= 1\n    return True\n\ndef g() -> str:\n    \"\"\"\n    Generate a string that is a palindrome after deleting at most one character.\n    \"\"\"\n    return \"abca\"\n\nassert f(g()) == True\n",
        "idx_generation": 332,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if the target value is present in the list using binary search.\n    \n    Example:\n    nums = [1, 3, 5, 7, 9, 11]\n    target = 7\n    The target value 7 is present in the list, so the output should be True.\n    \n    nums = [2, 4, 6, 8, 10]\n    target = 5\n    The target value 5 is not present in the list, so the output should be False.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return False\n\ndef g():\n    return [1, 3, 5, 7, 9, 11], 7\n\nassert f(*g()) == True\n",
        "idx_generation": 215,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of integers, find the smallest element in each row and return their sum.\"\"\"\n    min_sums = []\n    \n    for row in matrix:\n        min_sums.append(min(row))\n    \n    return sum(min_sums)\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a matrix of integers.\"\"\"\n    return [[4, 7, 2], [3, 9, 5], [1, 6, 8]]\n\nassert f(g()) == 6\n",
        "idx_generation": 225,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if it can be partitioned into two subsets such that the sum of elements in both subsets is equal.\"\"\"\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n    target_sum = total_sum // 2\n    \n    def can_partition(index, current_sum):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index >= len(nums):\n            return False\n        if can_partition(index + 1, current_sum + nums[index]):\n            return True\n        return can_partition(index + 1, current_sum)\n    \n    return can_partition(0, 0)\n\ndef g(nums: List[int]):\n    return nums\n\nassert f(g([1, 5, 11, 5]))\n",
        "idx_generation": 355,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(string: str) -> List[str]:\n    \"\"\"Given a string, return a list of all possible substrings of length 3 that can be formed.\"\"\"\n    substrings = []\n    for i in range(len(string) - 2):\n        substrings.append(string[i:i+3])\n    return substrings\n\ndef g():\n    string = \"abcde\"\n    return string\n\nassert f(g()) == ['abc', 'bcd', 'cde']\n",
        "idx_generation": 336,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers and a target value, find the index of the target value in the list using linear search.\n    \n    Example:\n    nums = [2, 4, 6, 8, 10]\n    target = 6\n    The target value 6 is present at index 2 in the list, so the output should be 2.\n    \n    nums = [2, 4, 6, 8, 10]\n    target = 5\n    The target value 5 is not present in the list, so the output should be -1.\n    \"\"\"\n    for i in range(len(nums)):\n        if nums[i] == target:\n            return i\n    \n    return -1\n\ndef g():\n    return [2, 4, 6, 8, 10], 6\n\nassert f(*g()) == 2\n",
        "idx_generation": 215,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"Given two integers n and k, find the kth smallest prime number greater than or equal to n.\n    Return the prime number as an integer.\"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    count = 0\n    while count < k:\n        if is_prime(n):\n            count += 1\n        n += 1\n    \n    return n - 1\n\ndef g(n: int, k: int) -> int:\n    return f(n, k)\n\nn = 10\nk = 3\nassert f(n, k) == g(n, k)\n\n",
        "idx_generation": 227,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there exists a subset of the list that sums up to the target.\n    You can choose any combination of numbers from the list, and each number can be used multiple times.\n    \"\"\"\n    if target == 0:\n        return True\n    if target < 0:\n        return False\n    for num in arr:\n        if f(arr, target - num):\n            return True\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g(), target=9)\n",
        "idx_generation": 360,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str, pattern='abc') -> bool:\n    \"\"\"Given a string and a pattern, determine if the pattern exists in the string.\n    Return True if the pattern exists, False otherwise.\n    \"\"\"\n    n = len(string)\n    m = len(pattern)\n    if n < m:\n        return False\n    for i in range(n - m + 1):\n        if string[i:i+m] == pattern:\n            return True\n    return False\ndef g(string='abcdefg'):\n    return string\nassert f(g())\n",
        "idx_generation": 339,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Sort the given list in ascending order using the bubble sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    return nums\n\ndef g():\n    return [5, 2, 7, 1, 3]  # Return a list of integers\n\nassert f(g()) == [1, 2, 3, 5, 7]\n",
        "idx_generation": 215,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers arr, find the length of the longest increasing subarray.\n    An increasing subarray is defined as a contiguous subarray where every element is greater than the previous element.\n    \n    Example:\n    arr = [2, 3, 1, 4, 7, 9, 5, 8]\n    \n    The longest increasing subarray is [1, 4, 7, 9], with a length of 4.\n    \n    Therefore, the answer is 4.\n    \"\"\"\n    max_length = 1\n    current_length = 1\n    \n    for i in range(1, len(arr)):\n        if arr[i] > arr[i-1]:\n            current_length += 1\n        else:\n            max_length = max(max_length, current_length)\n            current_length = 1\n    \n    max_length = max(max_length, current_length)\n    \n    return max_length\n\ndef g():\n    return [2, 3, 1, 4, 7, 9, 5, 8]\n\nassert f(g()) == 4\n",
        "idx_generation": 228,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Given a list of positive integers, determine if there exists a combination of numbers that adds up to the target value.\n    Return True if such a combination exists, and False otherwise.\"\"\"\n    def dp(nums, target):\n        if target == 0:\n            return True\n        if target < 0 or len(nums) == 0:\n            return False\n        return dp(nums[1:], target-nums[0]) or dp(nums[1:], target)\n    return dp(nums, target)\n\ndef g(target=10):\n    nums = [2, 4, 6, 8]\n    return nums\n\nassert f(g())\n",
        "idx_generation": 360,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> str:\n    \"\"\"\n    Given a string 's' and an integer 'k', reverse every subsegment of length 'k' in the string.\n    Return the modified string.\n    \"\"\"\n    n = len(s)\n    s = list(s)\n\n    for i in range(0, n, k*2):\n        s[i:i+k] = reversed(s[i:i+k])\n\n    return \"\".join(s)\n\ndef g():\n    \"\"\"\n    Generate a string and an integer.\n    \"\"\"\n    s = \"abcdefghi\"\n    k = 3\n\n    return s, k\n\nassert f(*g()) == \"cbadefihg\"\n\n",
        "idx_generation": 340,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subarray.\n    An increasing subarray is defined as a contiguous subarray in which all the elements are in increasing order.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    longest_subarray = 1\n    current_length = 1\n    \n    for i in range(1, len(nums)):\n        if nums[i] > nums[i-1]:\n            current_length += 1\n        else:\n            longest_subarray = max(longest_subarray, current_length)\n            current_length = 1\n    \n    longest_subarray = max(longest_subarray, current_length)\n    \n    return longest_subarray\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"\n    Generate a list of integers from the given list that represents the longest increasing subarray.\n    \"\"\"\n    if not nums:\n        return []\n    \n    longest_subarray = [nums[0]]\n    current_subarray = [nums[0]]\n    \n    for i in range(1, len(nums)):\n        if nums[i] > nums[i-1]:\n            current_subarray.append(nums[i])\n        else:\n            if len(current_subarray) > len(longest_subarray):\n                longest_subarray = current_subarray\n            current_subarray = [nums[i]]\n    \n    if len(current_subarray) > len(longest_subarray):\n        longest_subarray = current_subarray\n    \n    return longest_subarray\n\nassert f(g(nums=[1, 2, 3, 2, 5, 6, 7])) == 4\n",
        "idx_generation": 217,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum XOR value between any two numbers in the list.\n    Return the maximum XOR value.\n    Sample input:\n    nums = [3, 10, 5, 25, 2, 8]\n    Sample output:\n    28\"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            if xor > max_xor:\n                max_xor = xor\n    return max_xor\n\ndef g():\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n",
        "idx_generation": 229,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given a positive integer n, determine the number of ways to climb to the top of a staircase with n steps.\n    You can climb 1 or 2 steps at a time.\n    Return the total number of distinct ways to climb to the top.\"\"\"\n    def count_ways(n):\n        if n <= 1:\n            return 1\n        return count_ways(n-1) + count_ways(n-2)\n    return count_ways(n)\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 360,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a given string is a palindrome, considering only alphanumeric characters and ignoring cases.\"\"\"\n    \n    s = ''.join(c.lower() for c in s if c.isalnum())\n    return s == s[::-1]\n\ndef g(s: str):\n    return s\n\n# Example usage\ns = \"A man, a plan, a canal: Panama\"\n\nassert f(g(s))\n",
        "idx_generation": 341,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of numbers is a permutation of the first n positive integers\"\"\"\n    n = len(nums)\n    nums.sort()\n    for i in range(n):\n        if nums[i] != i+1:\n            return False\n    return True\n\ndef g():\n    return [3, 1, 2]\n\nassert f(g())\n",
        "idx_generation": 217,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target=10) -> bool:\n    \"\"\"Given a list of integers and a target value, find a subarray that sums up to the target value\"\"\"\n    n = len(arr)\n    for i in range(n):\n        current_sum = arr[i]\n        j = i + 1\n        while j <= n:\n            if current_sum == target:\n                return True\n            if current_sum > target or j == n:\n                break\n            current_sum += arr[j]\n            j += 1\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g())\n",
        "idx_generation": 230,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence (LIS).\n    A subsequence is a sequence that can be derived from another sequence by deleting some or no elements\n    without changing the order of the remaining elements.\n    Example:\n    Input: [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the output is 4.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\ndef g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]\nassert f(g()) == 4\n",
        "idx_generation": 361,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str, k: int) -> bool:\n    \"\"\"Check if it is possible to split the string into k equal parts\"\"\"\n    n = len(string)\n    if n % k != 0:\n        return False\n    chunk_size = n // k\n    for i in range(0, n, chunk_size):\n        if string[i:i+chunk_size] != string[:chunk_size]:\n            return False\n    return True\n\ndef g(string: str, k: int):\n    \"\"\"Split the string into k equal parts\"\"\"\n    n = len(string)\n    chunk_size = n // k\n    return [string[i:i+chunk_size] for i in range(0, n, chunk_size)]\n\nassert f(g(\"hellohellohello\", 3), 3)\n",
        "idx_generation": 341,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Sort the given list in non-decreasing order using bubble sort.\"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    \n    return nums\n\ndef g():\n    return [5, 2, 8, 12, 3]\n\nassert f(g()) == [2, 3, 5, 8, 12]\n",
        "idx_generation": 220,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Given a matrix of integers, return the sum of the elements in the diagonal line from the top left to the bottom right.\n    \"\"\"\n    n = len(matrix)\n    diagonal_sum = 0\n    for i in range(n):\n        diagonal_sum += matrix[i][i]\n    return diagonal_sum\n\ndef g():\n    return [\n        [2, 4, 6],\n        [1, 3, 5],\n        [7, 9, 11]\n    ]\n\nassert f(g()) == 16\n",
        "idx_generation": 233,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right from each cell.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a grid of integers.\"\"\"\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 12\n",
        "idx_generation": 362,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string 's', find the length of the longest substring without repeating characters.\n    Return the length of the longest substring.\n    \"\"\"\n    n = len(s)\n    max_length = 0\n    start = 0\n    last_seen = {}\n    for i in range(n):\n        if s[i] in last_seen and last_seen[s[i]] >= start:\n            start = last_seen[s[i]] + 1\n        last_seen[s[i]] = i\n        max_length = max(max_length, i - start + 1)\n    return max_length\n\ndef g(s: str) -> str:\n    \"\"\"\n    Return the string 's'\n    \"\"\"\n    return s\n\nassert f(g(s=\"abcabcbb\")) == 3\n",
        "idx_generation": 342,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if there are three numbers in the list that sum up to the target.\n    Return True if such numbers exist, False otherwise.\"\"\"\n    nums.sort()\n    n = len(nums)\n    for i in range(n - 2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            if current_sum == target:\n                return True\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g(nums: List[int], target: int) -> bool:\n    return f(nums, target)\n\nnums = [1, 2, 3, 4, 5]\ntarget = 9\nassert f(nums, target) == g(nums, target)\n",
        "idx_generation": 220,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a subsequence of length 3 where the sum of the first two numbers\n    is equal to the third number.\n    Return True if such a subsequence exists, False otherwise.\n    \"\"\"\n    n = len(nums)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if nums[i] + nums[j] == nums[k]:\n                    return True\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g())\n",
        "idx_generation": 237,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(x: int, n: int) -> bool:\n    \"\"\"Check if a number is a power of another number.\"\"\"\n    if x == 1:\n        return True\n    if x < 1:\n        return False\n    return f(x/n, n)\n\ndef g(n: int):\n    return n**3\n\nassert f(g(5), 5)\n",
        "idx_generation": 365,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Given a string, reverse the words in the string.\"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    result = ' '.join(reversed_words)\n    \n    return result\n\ndef g(s: str = \"Hello World\"):\n    return s\n\nassert f(g()) == \"World Hello\"\n",
        "idx_generation": 344,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, find the next permutation in lexicographic order.\n    Return the next permutation as a list of integers.\"\"\"\n    n = len(nums)\n    i = n - 2\n    while i >= 0 and nums[i] >= nums[i + 1]:\n        i -= 1\n    if i >= 0:\n        j = n - 1\n        while j >= 0 and nums[i] >= nums[j]:\n            j -= 1\n        nums[i], nums[j] = nums[j], nums[i]\n    left, right = i + 1, n - 1\n    while left < right:\n        nums[left], nums[right] = nums[right], nums[left]\n        left += 1\n        right -= 1\n    return nums\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"Generate a list of integers.\"\"\"\n    return nums\n\nassert f(g([1, 2, 3])) == [1, 3, 2]\n",
        "idx_generation": 221,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a given number is a power of two.\"\"\"\n    if n == 0:\n        return False\n    while n % 2 == 0:\n        n //= 2\n    return n == 1\n\ndef g():\n    return 64\n\nassert f(g())\n",
        "idx_generation": 238,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=0) -> bool:\n    \"\"\"Find if there is a way to partition the list into two subsets with equal sums\"\"\"\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n    target_sum = total_sum // 2\n    dp = [[False] * (target_sum + 1) for _ in range(len(nums) + 1)]\n    dp[0][0] = True\n    for i in range(1, len(nums) + 1):\n        dp[i][0] = True\n    for i in range(1, len(nums) + 1):\n        for j in range(1, target_sum + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= nums[i - 1]:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - nums[i - 1]]\n    return dp[len(nums)][target_sum]\ndef g(target=0):\n    return [1, 5, 11, 5]\nassert f(g())\n",
        "idx_generation": 366,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Convert the given string 's' to its lowercase equivalent, \n    but with all the vowels replaced by the corresponding digit (a = 1, e = 2, i = 3, o = 4, u = 5).\n    \"\"\"\n    vowels = {'a': '1', 'e': '2', 'i': '3', 'o': '4', 'u': '5'}\n    result = \"\"\n    \n    for char in s:\n        if char.lower() in vowels:\n            result += vowels[char.lower()]\n        else:\n            result += char.lower()\n    \n    return result\n\ndef g():\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    s = \"Hello, World!\"\n    \n    return s\n\nassert f(g()) == \"h2ll4, w4rld!\"\n",
        "idx_generation": 348,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Given a matrix of integers sorted in ascending order from left to right and top to bottom, and a target value, determine if the target is present in the matrix.\n    The matrix has the following properties:\n        - Integers in each row are sorted in ascending order from left to right.\n        - Integers in each column are sorted in ascending order from top to bottom.\"\"\"\n    if not matrix or not matrix[0]:\n        return False\n\n    m, n = len(matrix), len(matrix[0])\n    i, j = m - 1, 0\n\n    while i >= 0 and j < n:\n        if matrix[i][j] == target:\n            return True\n        elif matrix[i][j] < target:\n            j += 1\n        else:\n            i -= 1\n\n    return False\n\ndef g():\n    return ([[1, 4, 7, 11, 15],\n             [2, 5, 8, 12, 19],\n             [3, 6, 9, 16, 22],\n             [10, 13, 14, 17, 24],\n             [18, 21, 23, 26, 30]], 16)\n\nassert f(*g())\n",
        "idx_generation": 223,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int, k: int) -> bool:\n    \"\"\"Check if a given number is a prime number and its binary representation has exactly k set bits.\"\"\"\n    if num < 2:\n        return False\n    if num == 2:\n        return bin(num).count('1') == k\n    if num % 2 == 0:\n        return False\n    for i in range(3, int(num ** 0.5) + 1, 2):\n        if num % i == 0:\n            return False\n    return bin(num).count('1') == k\n\ndef g(k: int):\n    num = 2\n    while True:\n        if f(num, k):\n            return num\n        num += 1\n\nassert f(g(k=3), k=3)\n",
        "idx_generation": 239,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, word1: str, word2: str) -> bool:\n    \"\"\"\n    Given a string 's' and two words 'word1' and 'word2',\n    determine if it is possible to form 's' by interleaving the characters of 'word1' and 'word2',\n    while maintaining the relative order of the characters from each word.\n    Return True if it is possible, False otherwise.\n    Example:\n    s = \"applebanana\"\n    word1 = \"apple\"\n    word2 = \"banana\"\n    The possible interleavings are \"aabpplenanaa\" and \"apbaepnalan\",\n    where the characters from 'word1' and 'word2' are interleaved to form 's'.\n    Therefore, the answer is True.\n    \"\"\"\n    if len(s) != len(word1) + len(word2):\n        return False\n    if not s or (not word1 and s == word2) or (not word2 and s == word1):\n        return True\n    if s[0] == word1[0] and f(s[1:], word1[1:], word2):\n        return True\n    if s[0] == word2[0] and f(s[1:], word1, word2[1:]):\n        return True\n    return False\n\ndef g():\n    return \"applebanana\", \"apple\", \"banana\"\n\nassert f(*g())\n\n",
        "idx_generation": 366,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Reverse the order of words in the given string.\"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)\n\ndef g(s: str):\n    return s\n\nassert f(g(\"Hello World\")) == \"World Hello\"\n",
        "idx_generation": 356,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, return True if there exists a pair of numbers in the list whose sum is equal to 10.\n    Sample input:\n    [1, 2, 3, 4, 5, 6]\n    Sample output:\n    True\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == 10:\n            return True\n        elif nums[left] + nums[right] < 10:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [2, 4, 6, 8, 10]\n\nassert f(g()) == True\n",
        "idx_generation": 223,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(arr: List[int], target=100) -> bool:\n    \"\"\"Given a list of integers, find the maximum subarray sum that is less than or equal to the target value.\n    Return True if there exists a subarray with sum less than or equal to the target, otherwise return False.\n    \"\"\"\n    n = len(arr)\n    max_sum = float('-inf')\n    for i in range(n):\n        curr_sum = 0\n        for j in range(i, n):\n            curr_sum += arr[j]\n            if curr_sum <= target:\n                max_sum = max(max_sum, curr_sum)\n    return max_sum <= target\n\ndef g(target=100):\n    arr = [10, 20, 30, 40, 50]\n    return arr\n\nassert f(g())\n",
        "idx_generation": 241,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Compute the nth Fibonacci number using dynamic programming.\"\"\"\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    fib = [0] * (n + 1)\n    fib[1] = 1\n    for i in range(2, n + 1):\n        fib[i] = fib[i-1] + fib[i-2]\n    return fib[n]\n\ndef g(n: int):\n    return n\n\nassert f(g(6)) == 8\n",
        "idx_generation": 367,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Given a string, convert it to \"title case\" where the first letter of each word is capitalized and the rest of the letters are in lowercase.\n    Sample input:\n    s = \"hello world\"\n    Sample output:\n    \"Hello World\"\n    \"\"\"\n    return s.title()\n\ndef g():\n    return \"hello world\"\n\nassert f(g()) == \"Hello World\"\n",
        "idx_generation": 358,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there are three integers in the list that sum up to the target value.\n    Return True if such three integers exist, otherwise return False.\"\"\"\n    n = len(arr)\n    for i in range(n - 2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            current_sum = arr[i] + arr[left] + arr[right]\n            if current_sum == target:\n                return True\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g() -> List[int]:\n    \"\"\"Return a sorted list of integers\"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g(), target=15)\n",
        "idx_generation": 224,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int, k: int) -> bool:\n    \"\"\"Given three integers n, m, and k, determine if it is possible to construct a string of length n using only the characters '0' and '1' such that there are exactly m occurrences of the substring '11' and exactly k occurrences of the substring '00' in the string.\n    Return True if such a string can be constructed, otherwise return False.\n\n    Example:\n    n = 6, m = 2, k = 1\n    Output: True\n    Explanation: One possible string is '010110' which has 2 occurrences of '11' and 1 occurrence of '00'.\n    \"\"\"\n    num_ones = (n-1) // 2\n    num_zeros = n // 2\n    return num_ones >= m and num_zeros >= k\n\ndef g(n: int, m: int, k: int):\n    return n\n\nassert f(g(6, 2, 1), 2, 1) == True\n",
        "idx_generation": 242,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a given string is a palindrome using recursion.\"\"\"\n    def is_palindrome(s, start, end):\n        if start >= end:\n            return True\n        if s[start] != s[end]:\n            return False\n        return is_palindrome(s, start + 1, end - 1)\n    \n    return is_palindrome(s, 0, len(s) - 1)\n\ndef g(s: str):\n    return s\n\nassert f(g(\"racecar\")) == True\n",
        "idx_generation": 367,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a valid palindrome.\"\"\"\n    return s == s[::-1]\n\ndef g(s: str) -> str:\n    \"\"\"Return a valid palindrome string by appending the reverse of the given string to itself.\"\"\"\n    return s + s[::-1]\n\nassert f(g(\"level\"))\n",
        "idx_generation": 359,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, check if there exists a pair of numbers whose sum is equal to the target value.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9], target=10):\n    \"\"\"Generate a sorted list of integers and a target value.\"\"\"\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 224,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, check if there exist two numbers that sum up to the target value.\"\"\"\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9], target=10):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 245,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Compute the nth Fibonacci number using dynamic programming.\"\"\"\n    dp = [0] * (n+1)\n    dp[0] = 0\n    dp[1] = 1\n    \n    for i in range(2, n+1):\n        dp[i] = dp[i-1] + dp[i-2]\n    \n    return dp[n]\n    \ndef g(n=10):\n    \"\"\"Generate an integer.\"\"\"\n    return n\n\nassert f(g()) == 55\n",
        "idx_generation": 368,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"Given a string, determine if it is a palindrome or not.\n    Return True if it is a palindrome, and False otherwise.\"\"\"\n    def is_palindrome(string):\n        n = len(string)\n        for i in range(n // 2):\n            if string[i] != string[n-i-1]:\n                return False\n        return True\n    return is_palindrome(string)\n\ndef g():\n    string = \"racecar\"\n    return string\n\nassert f(g())\n",
        "idx_generation": 360,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if it contains a subsequence that forms an arithmetic progression.\n    Return True if such subsequence exists, False otherwise.\"\"\"\n    nums.sort()\n    \n    if len(nums) < 3:\n        return False\n    \n    for i in range(len(nums) - 2):\n        if nums[i+2] - nums[i+1] == nums[i+1] - nums[i]:\n            return True\n    \n    return False\n\ndef g() -> List[int]:\n    \"\"\"Generate a list of integers.\"\"\"\n    return [1, 4, 7, 10, 13]\n\nassert f(g()) == True\n",
        "idx_generation": 225,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], k=3) -> bool:\n    \"\"\"Find if there exists a subarray of length k in the given array such that the sum of its elements is divisible by k\"\"\"\n    return any(sum(arr[i:i+k]) % k == 0 for i in range(len(arr)-k+1))\n    \ndef g(arr=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]):\n    return arr\nassert f(g())\n",
        "idx_generation": 247,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Compute the factorial of a number using recursion.\"\"\"\n    if n == 0:\n        return 1\n    else:\n        return n * f(n-1)\n    \ndef g(n=5):\n    \"\"\"Generate an integer.\"\"\"\n    return n\n\nassert f(g()) == 120\n",
        "idx_generation": 368,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> bool:\n    \"\"\"Given a list of words, check if it is possible to form a word square.\"\"\"\n    n = len(words)\n    m = len(words[0])\n    \n    for i in range(n):\n        for j in range(m):\n            if words[i][j] != words[j][i]:\n                return False\n    return True\n\ndef g(words=[\"abcd\", \"bnrt\", \"crmy\", \"dtye\"]):\n    return words\n\nassert f(g()) == True\n",
        "idx_generation": 361,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers, find the index of the target number in the list using binary search.\n    If the target number is not found, return -1.\n    \"\"\"\n    low = 0\n    high = len(nums) - 1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return -1\n\ndef g():\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 230,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if a given matrix is symmetric.\"\"\"\n    n = len(matrix)\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] != matrix[j][i]:\n                return False\n    return True\n\ndef g(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"Generate a symmetric matrix.\"\"\"\n    n = len(matrix)\n    for i in range(n):\n        for j in range(n):\n            matrix[i][j] = matrix[j][i]\n    return matrix\n\nassert f(g([[1, 2, 3], [2, 4, 5], [3, 5, 6]]))\n",
        "idx_generation": 250,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum sum of a subarray with the constraint that no two numbers in the subarray are adjacent to each other.\"\"\"\n    if not nums:\n        return 0\n    n = len(nums)\n    if n == 1:\n        return nums[0]\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n    return dp[n-1]\n\ndef g():\n    return [2, 7, 9, 3, 1, 4]\n\nassert f(g()) == 15\n",
        "idx_generation": 369,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> int:\n    \"\"\"\n    Given a string, count the number of occurrences of each character in the string and return the count\n    for the character 'a'. If 'a' does not occur in the string, return 0.\n    \"\"\"\n    count = 0\n    for char in string:\n        if char == 'a':\n            count += 1\n    return count\n\ndef g(string: str = \"abracadabra\") -> str:\n    \"\"\"\n    Generate a string such that the character 'a' occurs at least once.\n    \"\"\"\n    return string\n\nassert f(g()) == 5\n",
        "idx_generation": 363,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target integer, determine if there exists a pair of numbers in the list that sum up to the target.\n    Return True if such pair exists, False otherwise.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Generate a list of integers and a target integer.\"\"\"\n    return [1, 4, 3, 6, 5], 9\n\nassert f(*g())\n",
        "idx_generation": 232,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number n is a power of two.\"\"\"\n    return n != 0 and (n & (n-1)) == 0\n\ndef g():\n    return 16\n\nassert f(g())\n",
        "idx_generation": 251,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence.\"\"\"\n    if not nums:\n        return 0\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 369,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome\"\"\"\n    left = 0\n    right = len(s) - 1\n    while left < right:\n        if s[left] != s[right]:\n            return False\n        left += 1\n        right -= 1\n    return True\n\ndef g(s: str):\n    \"\"\"Return the longest palindrome substring in the given string\"\"\"\n    longest_palindrome = \"\"\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            substring = s[i:j]\n            if f(substring) and len(substring) > len(longest_palindrome):\n                longest_palindrome = substring\n    return longest_palindrome\n\n# Test the solution\ns = \"babad\"\nassert f(g(s)) == True\n",
        "idx_generation": 367,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers and a target integer, find the index of the target element in the list using binary search.\n    If the target is not found, return -1.\"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Generate a sorted list of integers and a target integer.\"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 6\n\nassert f(*g()) == 5\n",
        "idx_generation": 232,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Determine if there exists a subarray in the given array whose sum is equal to the target value.\"\"\"\n    for i in range(len(arr)):\n        curr_sum = 0\n        for j in range(i, len(arr)):\n            curr_sum += arr[j]\n            if curr_sum == target:\n                return True\n    return False\n\ndef g():\n    arr = [1, 4, 2, 3, 5, 6]\n    target = 8\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 255,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the nth Fibonacci number using dynamic programming.\"\"\"\n    if n <= 0:\n        return 0\n    if n == 1 or n == 2:\n        return 1\n    fib = [0] * (n + 1)\n    fib[1] = 1\n    fib[2] = 1\n    for i in range(3, n + 1):\n        fib[i] = fib[i - 1] + fib[i - 2]\n    return fib[n]\n\ndef g():\n    return 8\n\nassert f(g()) == 21\n",
        "idx_generation": 370,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"Check if the given strings are anagrams of each other.\"\"\"\n    return sorted(s) == sorted(t)\n\ndef g():\n    return \"listen\", \"silent\"\n\nassert f(*g()) == True\n",
        "idx_generation": 370,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target number, find if there exists two numbers in the list whose sum is equal to the target.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        \n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    return [1, 3, 5, 7, 9], 12\n\nassert f(*g())\n",
        "idx_generation": 232,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Find the maximum element in the given matrix.\"\"\"\n    max_element = float('-inf')\n\n    for row in matrix:\n        for element in row:\n            if element > max_element:\n                max_element = element\n\n    return max_element\n\ndef g():\n    return ([[4, 2, 9], [1, 7, 5], [3, 6, 8]],)\n\nassert f(*g()) == 9\n",
        "idx_generation": 257,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the nth Fibonacci number using recursion.\"\"\"\n    if n <= 1:\n        return n\n    else:\n        return f(n-1) + f(n-2)\n\ndef g(n=10):\n    \"\"\"Generate the value of n for finding the nth Fibonacci number.\"\"\"\n    return n\n\nassert f(g()) == 55\n",
        "idx_generation": 372,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"Given a string 's', check if it can be rearranged into a palindrome.\n    Return True if it is possible, False otherwise.\"\"\"\n    char_count = {}\n    odd_count = 0\n    \n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    for count in char_count.values():\n        if count % 2 != 0:\n            odd_count += 1\n    \n    return odd_count <= 1\n\ndef g() -> str:\n    \"\"\"Generate a string 's' that can be rearranged into a palindrome.\"\"\"\n    s = \"aabbcddccbbaa\"\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 374,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if a given list of integers is sorted in non-decreasing order\"\"\"\n    return nums == sorted(nums)\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7]\n\nassert f(g())\n",
        "idx_generation": 234,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return the spiral traversal of the matrix.\n    \"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n    result = []\n    row_start = 0\n    row_end = m - 1\n    col_start = 0\n    col_end = n - 1\n\n    while row_start <= row_end and col_start <= col_end:\n        for i in range(col_start, col_end + 1):\n            result.append(matrix[row_start][i])\n        row_start += 1\n\n        for i in range(row_start, row_end + 1):\n            result.append(matrix[i][col_end])\n        col_end -= 1\n\n        if row_start <= row_end:\n            for i in range(col_end, col_start - 1, -1):\n                result.append(matrix[row_end][i])\n            row_end -= 1\n\n        if col_start <= col_end:\n            for i in range(row_end, row_start - 1, -1):\n                result.append(matrix[i][col_start])\n            col_start += 1\n\n    return result\n\n\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix\n\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 258,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of ways to climb a staircase with n steps using recursion.\"\"\"\n    if n <= 1:\n        return 1\n    return f(n-1) + f(n-2)\n\ndef g(n=4):\n    \"\"\"Generate the number of steps for the staircase.\"\"\"\n    return n\n\nassert f(g()) == 5\n",
        "idx_generation": 372,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings 'strings', return a new list of strings\n    where each string is reversed.\n    \"\"\"\n    reversed_strings = [string[::-1] for string in strings]\n    \n    return reversed_strings\n\ndef g():\n    \"\"\"\n    Generate a list of strings.\n    \"\"\"\n    strings = [\"hello\", \"world\"]\n    \n    return strings\n\nassert f(g()) == [\"olleh\", \"dlrow\"]\n",
        "idx_generation": 380,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target number, determine if there are two numbers in the list that add up to the target number.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 236,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> int:\n    \"\"\"Given a list of heights representing the elevation of a mountain, return the maximum height difference between any two adjacent peaks.\n    A peak is defined as a height that is greater than both its adjacent heights.\"\"\"\n    n = len(heights)\n    max_diff = 0\n    \n    for i in range(1, n-1):\n        if heights[i] > heights[i-1] and heights[i] > heights[i+1]:\n            max_diff = max(max_diff, heights[i] - heights[i-1])\n    \n    return max_diff\n\ndef g():\n    return [2, 3, 5, 1, 6, 4, 9, 7]\n\nassert f(g()) == 5\n",
        "idx_generation": 259,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a 2D matrix of integers, find the path from the top-left corner to the bottom-right corner\n    that maximizes the sum of the numbers along the path. Return the maximum sum.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = matrix[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    return dp[rows-1][cols-1]\n\ndef g(matrix=[[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]):\n    return matrix\n\nassert f(g()) == 29\n",
        "idx_generation": 373,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome.\"\"\"\n    s = s.lower()\n    s = \"\".join(ch for ch in s if ch.isalnum())\n    return s == s[::-1]\n\ndef g():\n    s = \"A man, a plan, a canal: Panama\"\n    return s\n\nassert f(g())\n",
        "idx_generation": 383,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, check if there exists a pair of numbers in the list whose sum is equal to the maximum number in the list.\n    Sample input:\n    [1, 2, 3, 4, 5]\n    Sample output:\n    True\"\"\"\n    nums.sort()\n    target = nums[-1]\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g())\n",
        "idx_generation": 237,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers and a target value, find two numbers in the list that sum up to the target.\n    Return the indices of the two numbers.\"\"\"\n    num_map = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    \n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Generate a list of integers and a target value.\"\"\"\n    nums = [2, 7, 11, 15, 3, 6, 8]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 262,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the minimum number of moves required to reach the target cell from the starting cell in a grid, where each cell represents a cost.\"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    dp = [[float('inf')] * m for _ in range(n)]\n    dp[0][0] = grid[0][0]\n    for i in range(n):\n        for j in range(m):\n            if i + 1 < n:\n                dp[i+1][j] = min(dp[i+1][j], dp[i][j] + grid[i+1][j])\n            if j + 1 < m:\n                dp[i][j+1] = min(dp[i][j+1], dp[i][j] + grid[i][j+1])\n    return dp[n-1][m-1]\n\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 7\n",
        "idx_generation": 384,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Determine if a given string is a palindrome, considering only alphanumeric characters and ignoring cases.\"\"\"\n    s = ''.join(c.lower() for c in s if c.isalnum())\n    return s == s[::-1]\ndef g():\n    return \"A man, a plan, a canal: Panama\"\nassert f(g())\n",
        "idx_generation": 385,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"Given a matrix of integers, find the maximum element in each row.\n    Return a list of the maximum elements.\"\"\"\n    max_elements = []\n    for row in matrix:\n        max_elements.append(max(row))\n    return max_elements\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [3, 6, 9]\n",
        "idx_generation": 240,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers and a target number, find two numbers in the list that sum up to the target. Return the indices of these numbers.\"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g():\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 262,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Determine the number of distinct ways to climb to the top of a staircase of n steps. You can take either 1 or 2 steps\n    at a time.\"\"\"\n    if n <= 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\ndef g():\n    return 5\nassert f(g()) == 8\n",
        "idx_generation": 385,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"Check if a given string contains a substring that is a binary representation of a number divisible by n.\"\"\"\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            substring = s[i:j]\n            if is_binary_divisible(substring, n):\n                return True\n    return False\n\ndef is_binary_divisible(substring, n):\n    num = int(substring, 2)\n    return num % n == 0\n\ndef g():\n    return \"101011011001\", 3\n\nassert f(*g())\n",
        "idx_generation": 386,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Given a sorted list of integers in ascending order, find the missing number in the sequence.\n    Sample input:\n    [1, 2, 3, 5, 6, 7, 8]\n    Sample output:\n    4\"\"\"\n    for i in range(len(arr) - 1):\n        if arr[i] + 1 != arr[i+1]:\n            return arr[i] + 1\n    return -1\n\ndef g():\n    return [1, 2, 3, 5, 6, 7, 8]\n\nassert f(g()) == 4\n",
        "idx_generation": 240,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(board: List[List[str]]) -> bool:\n    \"\"\"Given a 9x9 Sudoku board, determine if it is valid. The board is valid if each row, each column, and each of the\n    nine 3x3 sub-grids contains the digits 1-9 without repetition.\"\"\"\n    \n    # Check each row\n    for row in board:\n        if not is_valid(row):\n            return False\n    \n    # Check each column\n    for col in range(9):\n        column = [board[row][col] for row in range(9)]\n        if not is_valid(column):\n            return False\n    \n    # Check each 3x3 sub-grid\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            sub_grid = [board[row][col] for row in range(i, i+3) for col in range(j, j+3)]\n            if not is_valid(sub_grid):\n                return False\n    \n    return True\n\ndef is_valid(nums: List[str]) -> bool:\n    \"\"\"Check if a list of numbers is valid, meaning it contains the digits 1-9 without repetition.\"\"\"\n    nums = [num for num in nums if num != \".\"]\n    return len(nums) == len(set(nums))\n\ndef g():\n    board = [['5', '3', '.', '.', '7', '.', '.', '.', '.'],\n             ['6', '.', '.', '1', '9', '5', '.', '.', '.'],\n             ['.', '9', '8', '.', '.', '.', '.', '6', '.'],\n             ['8', '.', '.', '.', '6', '.', '.', '.', '3'],\n             ['4', '.', '.', '8', '.', '3', '.', '.', '1'],\n             ['7', '.', '.', '.', '2', '.', '.', '.', '6'],\n             ['.', '6', '.', '.', '.', '.', '2', '8', '.'],\n             ['.', '.', '.', '4', '1', '9', '.', '.', '5'],\n             ['.', '.', '.', '.', '8', '.', '.', '7', '9']]\n    return board\n\nassert f(g()) == True\n",
        "idx_generation": 264,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if there is a path from the top-left corner to the bottom-right corner in the matrix, only moving right and down.\"\"\"\n    def is_path(matrix, row, col, m, n):\n        if row >= m or col >= n:\n            return False\n        if row == m-1 and col == n-1:\n            return True\n        if matrix[row][col] == 0:\n            return False\n        return is_path(matrix, row+1, col, m, n) or is_path(matrix, row, col+1, m, n)\n    \n    m = len(matrix)\n    n = len(matrix[0])\n    return is_path(matrix, 0, 0, m, n)\n\ndef g(matrix: List[List[int]]):\n    return matrix\n\nassert f(g([[1, 1, 0], [1, 0, 1], [1, 1, 1]]))\n",
        "idx_generation": 385,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a given string is a palindrome.\"\"\"\n    return s == s[::-1]\n\ndef g():\n    return \"racecar\"\n\nassert f(g()) == True\n",
        "idx_generation": 388,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"Given a sorted list of integers and a target value, find two numbers in the list that add up to the target.\"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return [arr[left], arr[right]]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Generate a sorted list of integers and a target value.\"\"\"\n    arr = [1, 2, 3, 5, 6, 8, 9]\n    target = 11\n    return arr, target\n\nassert f(*g()) == [2, 9]\n",
        "idx_generation": 243,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, check if there exists a subarray whose sum is equal to zero.\"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum in prefix_sums or prefix_sum == 0:\n            return True\n        prefix_sums.add(prefix_sum)\n    return False\n\ndef g() -> List[int]:\n    \"\"\"Generate a list of integers.\"\"\"\n    return [4, -2, 3, 1, -3, 2]\n\nassert f(g())\n",
        "idx_generation": 267,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number k, find the maximum sum of any contiguous subarray of size k.\n    \"\"\"\n    window_sum = sum(nums[:k])\n    max_sum = window_sum\n    for i in range(len(nums) - k):\n        window_sum = window_sum - nums[i] + nums[i + k]\n        max_sum = max(max_sum, window_sum)\n    return max_sum\n\ndef g(nums=[1, 2, 3, 4, 5], k=3):\n    return nums, k\n\nassert f(*g()) == 12\n",
        "idx_generation": 390,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome\"\"\"\n    return s == s[::-1]\n\ndef g(s: str) -> str:\n    \"\"\"Reverse the given string\"\"\"\n    return s[::-1]\n\nassert f(g(\"level\")) == True\n",
        "idx_generation": 401,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"Find the kth largest element in the given list.\"\"\"\n    nums.sort(reverse=True)\n    return nums[k - 1]\n\ndef g():\n    nums = [3, 2, 1, 5, 6, 4]\n    k = 2\n    return nums, k\n\nassert f(*g()) == 5\n\n",
        "idx_generation": 243,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if there exists a subarray with equal number of even and odd elements.\"\"\"\n    count = 0\n    for num in nums:\n        if num % 2 == 0:\n            count += 1\n        else:\n            count -= 1\n    return count == 0\ndef g():\n    nums = [2, 4, 7, 9, 8, 6, 5, 3]\n    return nums\nassert f(g())\n",
        "idx_generation": 267,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, find the number of ways to select a subsequence from the list such that the sum of the subsequence is equal to the target.\n    Return True if there exists at least one such subsequence, False otherwise.\n    \"\"\"\n    n = len(nums)\n    dp = [[0] * (target + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = 1\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= nums[i - 1]:\n                dp[i][j] += dp[i - 1][j - nums[i - 1]]\n    return dp[n][target] > 0\n\ndef g(target: int):\n    nums = [1, 2, 3, 4, 5]\n    return nums, target\n\nassert f(*g(6))\n",
        "idx_generation": 390,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"Check if the given string is a palindrome.\"\"\"\n    return string == string[::-1]\n\ndef g():\n    string = \"madam\"\n    return string\n\nassert f(g())\n",
        "idx_generation": 413,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums' and an integer 'k',\n    find the top k frequent elements in the list.\n    Return a list of the k most frequent elements in descending order of their frequency.\n    \"\"\"\n    freq_dict = {}\n    for num in nums:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n    \n    sorted_freq = sorted(freq_dict.items(), key=lambda x: x[1], reverse=True)\n    top_k = [x[0] for x in sorted_freq[:k]]\n    \n    return top_k\n\ndef g(nums=[1, 1, 1, 2, 2, 3], k=2):\n    return nums, k\n\nassert f(*g()) == [1, 2]\n",
        "idx_generation": 243,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], prefix: str) -> List[str]:\n    \"\"\"Given a list of words, return a new list containing only the words that start with the given prefix.\n    The prefix comparison should be case-insensitive.\"\"\"\n    \n    prefix = prefix.lower()\n    \n    return [word for word in words if word.lower().startswith(prefix)]\n\ndef g():\n    return [\"apple\", \"banana\", \"cherry\", \"Apricot\", \"grape\", \"Lemon\"]\n\nassert f(g(), prefix=\"a\") == [\"apple\", \"Apricot\"]\n",
        "idx_generation": 272,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n    Return the length of the longest increasing subsequence.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n\n",
        "idx_generation": 392,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Reverse the words in a string.\"\"\"\n    words = s.split()\n    reversed_words = [word[::-1] for word in words]\n    return ' '.join(reversed_words)\n\ndef g():\n    s = \"Hello World\"\n    return s\n\nassert f(g()) == \"olleH dlroW\"\n",
        "idx_generation": 413,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Given a list of integers, find a pair of numbers whose sum is equal to the target value.\n    Return True if such a pair exists, False otherwise.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g(target=10):\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nassert f(g())\n",
        "idx_generation": 244,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, calculate the sum of all elements in the grid.\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    total = 0\n\n    for i in range(n):\n        for j in range(m):\n            total += grid[i][j]\n\n    return total\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return grid\n\nassert f(g([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) == 45\n",
        "idx_generation": 281,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the nth Fibonacci number.\"\"\"\n    def fibonacci(n):\n        if n <= 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            return fibonacci(n-1) + fibonacci(n-2)\n    \n    return fibonacci(n)\n\ndef g():\n    n = 8\n    return n\n\nassert f(g()) == 21\n",
        "idx_generation": 393,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"Check if the given string is a palindrome and if the given number is a prime number.\"\"\"\n    is_palindrome = s == s[::-1]\n\n    is_prime = True\n    if n < 2:\n        is_prime = False\n    else:\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                is_prime = False\n                break\n\n    return is_palindrome and is_prime\n\ndef g():\n    s = 'radar'\n    n = 17\n    return s, n\n\nassert f(*g())\n\n",
        "idx_generation": 415,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence.\n    Return True if the length is greater than or equal to 3, False otherwise.\"\"\"\n    n = len(arr)\n    if n < 3:\n        return False\n    lengths = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and lengths[i] < lengths[j] + 1:\n                lengths[i] = lengths[j] + 1\n    return max(lengths) >= 3\ndef g():\n    return [1, 3, 2, 4, 5, 6, 7, 8, 9]\nassert f(g())\n",
        "idx_generation": 244,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, check if there exists a subarray such that the sum of its elements is a perfect square.\n    \n    Return True if such a subarray exists, False otherwise.\n    \"\"\"\n    prefix_sum = 0\n    sum_counts = {0: 1}\n    perfect_squares = set()\n    \n    for num in nums:\n        prefix_sum += num\n        for square in perfect_squares:\n            if prefix_sum - square in sum_counts:\n                return True\n        if prefix_sum in sum_counts:\n            sum_counts[prefix_sum] += 1\n        else:\n            sum_counts[prefix_sum] = 1\n        perfect_squares.add(prefix_sum)\n        \n    return False\n\ndef g():\n    nums = [2, 3, -4, 5, 6]\n    return nums\n\nassert f(g())\n",
        "idx_generation": 283,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum product of a subarray in the given list of numbers.\"\"\"\n    max_product = float('-inf')\n    current_max = 1\n    current_min = 1\n    \n    for num in nums:\n        if num < 0:\n            current_max, current_min = current_min, current_max\n        \n        current_max = max(num, current_max * num)\n        current_min = min(num, current_min * num)\n        \n        max_product = max(max_product, current_max)\n    \n    return max_product\n\ndef g(nums=[-2, 3, -4]):\n    return nums\n\nassert f(g()) == 24\n",
        "idx_generation": 396,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int, s: str) -> bool:\n    \"\"\"Determine if it is possible to rearrange the characters in the given string to form a palindrome\n    of length 'n' and with 'k' distinct characters.\"\"\"\n    if n < 2 or n > len(s) or k > len(set(s)):\n        return False\n    return True\n\ndef g():\n    n = 5\n    k = 3\n    s = \"aabbc\"\n    return n, k, s\n\nassert f(*g())\n",
        "idx_generation": 419,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"Find the index of the target value in a sorted array using binary search.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g(arr: List[int], target: int) -> List[int]:\n    \"\"\"Generate a sorted array of integers and a target value.\"\"\"\n    return sorted(arr), target\n\nassert f(*g(arr=[2, 4, 6, 8, 10], target=6)) == 2\n",
        "idx_generation": 245,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer 'n', calculate the sum of all multiples of 3 or 5 below 'n'.\n    Return the sum.\n    \"\"\"\n    total = 0\n    \n    for i in range(n):\n        if i % 3 == 0 or i % 5 == 0:\n            total += i\n    \n    return total\n\ndef g():\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    n = 100\n    \n    return n\n\nassert f(g()) == 2318\n",
        "idx_generation": 288,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence.\"\"\"\n    if not nums:\n        return 0\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g(nums=[10, 9, 2, 5, 3, 7, 101, 18]):\n    return nums\n\nassert f(g()) == 4\n\n",
        "idx_generation": 398,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"Given a string s, find the length of the longest substring without repeating characters.\n    Sample Input:\n    s = \"abcabcbb\"\n    Sample Output:\n    3\n    Explanation:\n    The longest substring without repeating characters is \"abc\", which has a length of 3.\"\"\"\n    max_len = 0\n    start = 0\n    char_map = {}\n    for end in range(len(s)):\n        if s[end] in char_map:\n            start = max(start, char_map[s[end]] + 1)\n        char_map[s[end]] = end\n        max_len = max(max_len, end - start + 1)\n    return max_len\n\ndef g(s: str) -> int:\n    \"\"\"Find the length of the longest substring without repeating characters in a given string.\"\"\"\n    max_len = 0\n    start = 0\n    char_map = {}\n    for end in range(len(s)):\n        if s[end] in char_map:\n            start = max(start, char_map[s[end]] + 1)\n        char_map[s[end]] = end\n        max_len = max(max_len, end - start + 1)\n    return max_len\n\nassert f(\"abcabcbb\") == g(\"abcabcbb\")\n",
        "idx_generation": 422,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers, determine if there exists two numbers in the array such that their sum is equal to the target.\n    Return True if such a pair exists, otherwise return False.\"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9], 10\n\nassert f(*g())\n",
        "idx_generation": 245,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> List[int]:\n    \"\"\"\n    Given a positive integer 'n', generate the first 'n' terms of the Fibonacci sequence.\n    Return the list of Fibonacci numbers.\n    \"\"\"\n    fib = [0, 1]\n    \n    for i in range(2, n):\n        fib.append(fib[i - 1] + fib[i - 2])\n    \n    return fib\n\ndef g():\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    n = 10\n    \n    return n\n\nassert f(g()) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
        "idx_generation": 288,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> int:\n    \"\"\"Find the number of ways to climb to the top of a staircase with n steps.\n    You can either climb 1 or 2 steps at a time.\n    Sample Input:\n    n = 3\n    Sample Output:\n    3\"\"\"\n    if n <= 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\ndef g(n: int, m: int) -> int:\n    \"\"\"Find the number of ways to climb to the top of a staircase with n steps.\"\"\"\n    if n <= 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\nassert f(n=3, m=0) == g(n=3, m=0)\n",
        "idx_generation": 399,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Check if the two given strings are anagrams of each other.\"\"\"\n    def count_chars(s):\n        char_count = [0] * 26\n        for char in s:\n            char_count[ord(char) - ord('a')] += 1\n        return char_count\n\n    char_count_s1 = count_chars(s1)\n    char_count_s2 = count_chars(s2)\n\n    return char_count_s1 == char_count_s2\n\ndef g():\n    s1 = 'listen'\n    s2 = 'silent'\n    return s1, s2\n\nassert f(*g())\n",
        "idx_generation": 424,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array and a target value, determine if there are two numbers in the array that add up to the target.\n    Sample input:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    Sample output:\n    True\n    \"\"\"\n    start = 0\n    end = len(arr) - 1\n    while start < end:\n        if arr[start] + arr[end] == target:\n            return True\n        elif arr[start] + arr[end] < target:\n            start += 1\n        else:\n            end -= 1\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5], 7\n\nassert f(*g())\n",
        "idx_generation": 246,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a non-empty subarray.\n    Return the maximum sum.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, -3, 4, -2, -1, 6, 8, -5]\n\nassert f(g()) == 15\n\n",
        "idx_generation": 289,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there exists a subset of the list whose sum is equal to the target.\n    Return True if such a subset exists, otherwise return False.\n    \"\"\"\n    def subset_sum(nums: List[int], target: int, index: int) -> bool:\n        if target == 0:\n            return True\n        if index < 0 or target < 0:\n            return False\n        \n        include = subset_sum(nums, target - nums[index], index - 1)\n        exclude = subset_sum(nums, target, index - 1)\n        \n        return include or exclude\n    \n    return subset_sum(nums, target, len(nums) - 1)\n\ndef g(nums=[2, 3, 5, 7, 10], target=14):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 399,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string 's', determine if it is a valid palindrome.\n    Ignore non-alphanumeric characters and consider uppercase and lowercase letters as equal.\n    Return True if 's' is a valid palindrome, False otherwise.\n    \"\"\"\n    cleaned_s = ''.join(char.lower() for char in s if char.isalnum())\n    \n    return cleaned_s == cleaned_s[::-1]\n\ndef g():\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    s = \"A man, a plan, a canal: Panama!\"\n    \n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 432,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(numbers: List[int], target=10) -> bool:\n    \"\"\"Given a list of numbers, find if there exists a pair of numbers that sums up to the target value.\n    Sample Input:\n    numbers = [1, 3, 5, 7, 9]\n    target = 10\n    Sample Output:\n    True\"\"\"\n    numbers.sort()\n    left = 0\n    right = len(numbers) - 1\n    while left < right:\n        current_sum = numbers[left] + numbers[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(numbers=[1, 3, 5, 7, 9], target=10):\n    return numbers\n\nassert f(g())\n",
        "idx_generation": 246,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers and a target number, count the number of distinct pairs of elements in the list that add up to the target.\"\"\"\n    num_dict = {}\n    count = 0\n    for num in nums:\n        complement = target - num\n        if complement in num_dict:\n            count += 1\n        num_dict[num] = True\n    return count\n\ndef g(nums=[2, 7, 11, 15, 3, 6, 9], target=9):\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 292,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any contiguous subarray.\n    Return the maximum sum.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 403,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> str:\n    \"\"\"\n    Given a string 'string', reverse the order of the words in the string.\n    Return the reversed string.\n    \"\"\"\n    words = string.split()\n    reversed_string = ' '.join(reversed(words))\n    return reversed_string\n\ndef g() -> str:\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    string = \"Hello, world! This is a test.\"\n    \n    return string\n\nassert f(g()) == \"test. a is This world! Hello,\"\n\n",
        "idx_generation": 433,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, determine if there are two numbers in the list that add up to the target.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5, 6], target=9):\n    \"\"\"\n    Generate a sorted list of integers and a target number such that there are two numbers in the list that add up to the target.\n    \"\"\"\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 247,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum sum of any contiguous subarray.\n    Sample input:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Sample output:\n    6\"\"\"\n    n = len(nums)\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for i in range(n):\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 296,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find the length of the longest arithmetic subsequence.\n    An arithmetic subsequence is a sequence of at least two numbers where the difference between consecutive numbers is the same.\n    Return the length of the longest arithmetic subsequence.\n    \"\"\"\n    n = len(nums)\n    if n <= 2:\n        return n\n    dp = {}\n    for i in range(n):\n        for j in range(i + 1, n):\n            diff = nums[j] - nums[i]\n            if (i, diff) in dp:\n                dp[j, diff] = dp[i, diff] + 1\n            else:\n                dp[j, diff] = 2\n    return max(dp.values())\n\ndef g():\n    return [3, 6, 9, 12, 15]\n\nassert f(g()) == 5\n",
        "idx_generation": 409,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> str:\n    \"\"\"Merge two strings by alternating their characters.\"\"\"\n    merged = \"\"\n    i = 0\n    while i < len(s1) or i < len(s2):\n        if i < len(s1):\n            merged += s1[i]\n        if i < len(s2):\n            merged += s2[i]\n        i += 1\n    return merged\n\ndef g():\n    s1 = \"abc\"\n    s2 = \"defg\"\n    return s1, s2\n\nassert f(*g()) == \"adbecfg\"\n",
        "idx_generation": 440,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in non-decreasing order using the bubble sort algorithm.\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(n - i - 1):\n            if nums[j] > nums[j + 1]:\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n    return nums\n\ndef g(nums=[5, 4, 3, 2, 1]):\n    \"\"\"\n    Generate a list of integers in random order.\n    \"\"\"\n    return nums\n\nassert f(g()) == [1, 2, 3, 4, 5]\n",
        "idx_generation": 247,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if it is a magic square. A magic square is a square matrix in which the sums \n    of each row, each column, and both diagonals are the same. The matrix is a magic square if this condition is satisfied.\n    \"\"\"\n\n    n = len(matrix)\n    target_sum = sum(matrix[0])  # The sum of each row, column, and diagonal should be equal to this value\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for j in range(n):\n        column_sum = sum(matrix[i][j] for i in range(n))\n        if column_sum != target_sum:\n            return False\n\n    # Check diagonal 1\n    diagonal_sum_1 = sum(matrix[i][i] for i in range(n))\n    if diagonal_sum_1 != target_sum:\n        return False\n\n    # Check diagonal 2\n    diagonal_sum_2 = sum(matrix[i][n-i-1] for i in range(n))\n    if diagonal_sum_2 != target_sum:\n        return False\n\n    return True\n\n\ndef g():\n    matrix = [\n        [2, 7, 6],\n        [9, 5, 1],\n        [4, 3, 8]\n    ]\n    return matrix\n\n\nassert f(g())\n",
        "idx_generation": 296,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if it is possible to select a subset of the integers\n    such that their sum is equal to the target value. Return True if it is possible, otherwise return False.\n    \"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    \n    # Base cases\n    dp[0][0] = True\n    \n    # Fill in the dynamic programming table\n    for i in range(1, n + 1):\n        for j in range(target + 1):\n            if j < nums[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n    \n    return dp[n][target]\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 409,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int, s: str) -> int:\n    \"\"\"Given a string s consisting of lowercase letters, find the number of distinct substrings of length k that can be formed using the characters of s, considering only contiguous substrings.\"\"\"\n    distinct_substrings = set()\n    for i in range(len(s) - k + 1):\n        distinct_substrings.add(s[i:i+k])\n    return len(distinct_substrings)\n\ndef g(n=5, k=2, s=\"abbac\"):\n    return n, k, s\n\nassert f(*g()) == 4\n",
        "idx_generation": 441,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Given a list of integers, find a pair of numbers whose sum is equal to the target value.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\nassert f(g())\n",
        "idx_generation": 249,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given a positive integer n, determine if it is a prime number.\"\"\"\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    return is_prime(n)\ndef g(n=17):\n    return n\nassert f(g())\n",
        "idx_generation": 302,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, find the longest increasing subsequence. Return True if the subsequence length is greater than or equal to 4, False otherwise.\n    \"\"\"\n    n = len(nums)\n    if n < 4:\n        return False\n    \n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp) >= 4\n\ndef g(nums: List[int] = [10, 9, 2, 5, 3, 7, 101, 18, 17]) -> List[int]:\n    \"\"\"\n    Generate a list of integers that will result in a longest increasing subsequence length greater than or equal to 4.\n    \"\"\"\n    return nums\n\nassert f(g())\n",
        "idx_generation": 411,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"Given a string s, find the length of the longest substring without repeating characters.\"\"\"\n    max_len = 0\n    start = 0\n    char_dict = {}\n    for i in range(len(s)):\n        if s[i] in char_dict and start <= char_dict[s[i]]:\n            start = char_dict[s[i]] + 1\n        else:\n            max_len = max(max_len, i - start + 1)\n        char_dict[s[i]] = i\n    return max_len\n\ndef g(s: str) -> str:\n    \"\"\"Returns the string s\"\"\"\n    return s\n\nassert f(g(s=\"abcabcbb\")) == 3\n",
        "idx_generation": 443,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers, find if there exists a pair of numbers that sum up to the target value. Return True if such a pair exists, otherwise return False.\"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        \n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(nums=[2, 4, 6, 8, 10], target=12):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 249,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"Find the sum of all positive integers less than or equal to n that are divisible by 3 or 5.\"\"\"\n    def sum_multiples(k):\n        num_terms = n // k\n        return k * (num_terms * (num_terms + 1)) // 2\n    \n    sum_3 = sum_multiples(3)\n    sum_5 = sum_multiples(5)\n    sum_15 = sum_multiples(15)\n    \n    return sum_3 + sum_5 - sum_15\n\ndef g(n: int) -> int:\n    \"\"\"Return the sum of all positive integers less than or equal to n that are divisible by 3 or 5.\"\"\"\n    return n\n\nassert f(g(n=20)) == 98\n",
        "idx_generation": 303,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a subset of the given list of numbers that adds up to the target.\"\"\"\n    def subset_sum(nums, target, index):\n        if target == 0:\n            return True\n        if index >= len(nums):\n            return False\n        if nums[index] > target:\n            return subset_sum(nums, target, index + 1)\n        return subset_sum(nums, target - nums[index], index + 1) or subset_sum(nums, target, index + 1)\n    \n    return subset_sum(nums, target, 0)\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find a subset of the given list of numbers that adds up to the target.\"\"\"\n    def subset_sum(nums, target, index):\n        if target == 0:\n            return []\n        if index >= len(nums):\n            return None\n        if nums[index] > target:\n            return subset_sum(nums, target, index + 1)\n        subset = subset_sum(nums, target - nums[index], index + 1)\n        if subset is not None:\n            subset.append(nums[index])\n            return subset\n        return subset_sum(nums, target, index + 1)\n    \n    return subset_sum(nums, target, 0)\n\nassert f(g([1, 2, 3, 4, 5], 9), 9)\n",
        "idx_generation": 415,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string, determine if it is a valid palindrome. Consider only alphanumeric characters and ignore case.\n    Sample Input:\n    s = \"A man, a plan, a canal: Panama\"\n    Sample Output:\n    True\"\"\"\n    alphanumeric_s = [char.lower() for char in s if char.isalnum()]\n    return alphanumeric_s == alphanumeric_s[::-1]\n\ndef g(s: str) -> bool:\n    \"\"\"Determine if a string is a valid palindrome, considering only alphanumeric characters and ignoring case.\"\"\"\n    alphanumeric_s = [char.lower() for char in s if char.isalnum()]\n    return alphanumeric_s == alphanumeric_s[::-1]\n\nassert f(s=\"A man, a plan, a canal: Panama\") == g(s=\"A man, a plan, a canal: Panama\")\n",
        "idx_generation": 446,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a sorted list of integers, find two numbers in the list that add up to the target using two pointers.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [nums[left], nums[right]]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\ndef g(target: int):\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    return nums\n\nassert f(g(target=10), target=10) == [1, 9]\n",
        "idx_generation": 252,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers 'nums', determine if there exists a subsequence of length 3 where the sum of the first two numbers is equal to the third number.\n    Return True if such a subsequence exists, False otherwise.\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(i+1, n):\n            target = nums[i] + nums[j]\n            if target in nums:\n                return True\n    return False\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5, 6]\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 304,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Determine if there exists a subset of a given list of integers that sums up to the target value.\n\n    Args:\n        nums (List[int]): The list of integers.\n        target (int): The target value.\n\n    Returns:\n        bool: True if a subset exists, False otherwise.\n\n    Example:\n        Input: nums = [2, 4, 6, 8], target = 10\n        Output: True\n        Explanation: The subset [2, 8] sums up to the target value of 10.\n    \"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if nums[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n    return dp[n][target]\n\ndef g(nums: List[int], target: int) -> bool:\n    return f(nums, target)\n\nnums = [2, 4, 6, 8]\ntarget = 10\nassert f(nums, target) == g(nums, target)\n\n",
        "idx_generation": 419,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a number is a palindrome in both decimal and binary representations.\n    Return True if the number is a palindrome, False otherwise.\n    \"\"\"\n    decimal_str = str(n)\n    binary_str = bin(n)[2:]\n    \n    return decimal_str == decimal_str[::-1] and binary_str == binary_str[::-1]\n\ndef g():\n    n = 9\n    return n\n\nassert f(g())\n",
        "idx_generation": 447,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum product of any two numbers in the list.\"\"\"\n    max_product = float(\"-inf\")\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n    return max_product\n\ndef g():\n    return [2, 5, 8, 12, 17, 19, 22]\n\nassert f(g()) == 418\n",
        "idx_generation": 252,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of heights representing the elevation map, find the volume of water that can be trapped between the bars.\n    \"\"\"\n    left = 0\n    right = len(heights) - 1\n    left_max = 0\n    right_max = 0\n    volume = 0\n    \n    while left < right:\n        if heights[left] < heights[right]:\n            if heights[left] > left_max:\n                left_max = heights[left]\n            else:\n                volume += left_max - heights[left]\n            \n            left += 1\n        else:\n            if heights[right] > right_max:\n                right_max = heights[right]\n            else:\n                volume += right_max - heights[right]\n            \n            right -= 1\n    \n    return volume\n\ndef g(heights=[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]):\n    \"\"\"\n    Generate a list of heights representing the elevation map where water can be trapped between the bars.\n    \"\"\"\n    return heights\n\nassert f(g()) == 6\n",
        "idx_generation": 306,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target=10) -> bool:\n    \"\"\"Find a subset of numbers from the given list that add up to the target value.\n    Return True if such subset exists, False otherwise.\"\"\"\n    def subset_sum(arr, n, target):\n        if target == 0:\n            return True\n        if n == 0 and target != 0:\n            return False\n        if arr[n-1] > target:\n            return subset_sum(arr, n-1, target)\n        return subset_sum(arr, n-1, target) or subset_sum(arr, n-1, target-arr[n-1])\n    return subset_sum(arr, len(arr), target)\n\ndef g(target=10):\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g())\n",
        "idx_generation": 420,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Reverse the words in the given string.\n    A word is defined as a sequence of non-space characters.\n    The input string may contain leading or trailing spaces.\n    Sample Input:\n    s = \"   Hello   World!   \"\n    Sample Output:\n    \"World! Hello\"\n    \"\"\"\n    \n    words = s.split()\n    reversed_words = words[::-1]\n    \n    return ' '.join(reversed_words)\n\ndef g(s=\"   Hello   World!   \") -> str:\n    \"\"\"Return the given string\"\"\"\n    return s\n\nassert f(g()) == \"World! Hello\"\n",
        "idx_generation": 449,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Given a sorted list of integers, find the missing number in the sequence.\n    Return the missing number.\n    Sample input:\n    [1, 2, 3, 5, 6, 7, 8]\n    Sample output:\n    4\"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] != arr[left] + mid - left:\n            if mid == 0 or arr[mid-1] == arr[left] + mid - left - 1:\n                return arr[left] + mid - left\n            else:\n                right = mid - 1\n        else:\n            left = mid + 1\n    \n    return None\n\ndef g():\n    return [1, 2, 3, 5, 6, 7, 8]\n\nassert f(g()) == 4\n\n",
        "idx_generation": 254,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of elements in the given list whose sum is equal to the target number.\"\"\"\n    seen = set()\n    for num in arr:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g():\n    arr = [2, 4, 6, 8, 10]\n    target = 12\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 307,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find the longest increasing subsequence (LIS) in the list.\n    The LIS is a subsequence of the given list where the elements are in increasing order.\n    Return the LIS as a list of integers.\n    \n    Example:\n    Input: nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: [2, 3, 7, 18]\n    Explanation: The longest increasing subsequence is [2, 3, 7, 18].\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    max_length = max(dp)\n    lis = []\n    for i in range(n-1, -1, -1):\n        if dp[i] == max_length:\n            lis.append(nums[i])\n            max_length -= 1\n    lis.reverse()\n    \n    return lis\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"\n    Find the longest increasing subsequence (LIS) in a given list of integers.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    max_length = max(dp)\n    lis = []\n    for i in range(n-1, -1, -1):\n        if dp[i] == max_length:\n            lis.append(nums[i])\n            max_length -= 1\n    lis.reverse()\n    \n    return lis\n\nassert f([10, 9, 2, 5, 3, 7, 101, 18]) == g([10, 9, 2, 5, 3, 7, 101, 18])\n",
        "idx_generation": 422,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n    Return True if the string is a palindrome, False otherwise.\n    \"\"\"\n    string = string.lower()\n    string = ''.join(c for c in string if c.isalnum())\n    return string == string[::-1]\n\ndef g() -> str:\n    \"\"\"\n    Generate a palindrome string.\n    \"\"\"\n    return \"A man, a plan, a canal: Panama\"\n\nassert f(g()) == True\n",
        "idx_generation": 449,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target integer, determine if there exists a pair of numbers in the list that sum up to the target.\n    Return True if such pair exists, False otherwise.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Generate a list of integers and a target integer.\"\"\"\n    return [3, 5, 1, 7, 2, 9], 10\n\nassert f(*g())\n",
        "idx_generation": 254,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given an integer n, determine if it is a prime number.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            return False\n    return True\ndef g(n=7):\n    return n\nassert f(g()) == True\n",
        "idx_generation": 307,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if it can be partitioned into two subsets such that the sum of elements in both subsets is equal.\n    Sample Input:\n    nums = [1, 5, 11, 5]\n    Sample Output:\n    True\"\"\"\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in nums:\n        for i in range(target_sum, num - 1, -1):\n            dp[i] = dp[i] or dp[i - num]\n    return dp[target_sum]\n\ndef g():\n    return [1, 5, 11, 5]\n\nassert f(g())\n",
        "idx_generation": 422,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"Given a string containing only digits, return the sum of all numbers formed by concatenating consecutive digits together.\"\"\"\n    nums = []\n    current = \"\"\n    \n    for char in s:\n        if char.isdigit():\n            current += char\n        else:\n            if current:\n                nums.append(int(current))\n                current = \"\"\n    \n    if current:\n        nums.append(int(current))\n    \n    return sum(nums)\n\ndef g() -> str:\n    \"\"\"Generate a string containing only digits.\"\"\"\n    return \"12345\"\n\nassert f(g()) == 12345\n",
        "idx_generation": 455,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Check if a given matrix contains a target value.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    left = 0\n    right = rows * cols - 1\n    while left <= right:\n        mid = (left + right) // 2\n        num = matrix[mid // cols][mid % cols]\n        if num == target:\n            return True\n        elif num < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef g():\n    matrix = [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]]\n    target = 16\n    return matrix, target\n\nassert f(*g())\n",
        "idx_generation": 255,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if a given matrix is a magic square.\"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])  # The sum of each row, column, and diagonal should be the same\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check columns\n    for j in range(n):\n        column_sum = sum(matrix[i][j] for i in range(n))\n        if column_sum != target_sum:\n            return False\n    \n    # Check diagonals\n    diagonal_sum = sum(matrix[i][i] for i in range(n))\n    if diagonal_sum != target_sum:\n        return False\n    reverse_diagonal_sum = sum(matrix[i][n-i-1] for i in range(n))\n    if reverse_diagonal_sum != target_sum:\n        return False\n    \n    return True\n\ndef g(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"Transform a matrix into a magic square.\"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n    \n    # Modify rows\n    for i in range(n):\n        row_sum = sum(matrix[i])\n        difference = target_sum - row_sum\n        matrix[i] = [element + difference for element in matrix[i]]\n    \n    # Modify columns\n    for j in range(n):\n        column_sum = sum(matrix[i][j] for i in range(n))\n        difference = target_sum - column_sum\n        for i in range(n):\n            matrix[i][j] += difference\n    \n    return matrix\n\nassert f(g([[2, 7, 6], [9, 5, 1], [4, 3, 8]]))\n",
        "idx_generation": 308,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if there exists a subset of the list that adds up to the target number.\n    Return True if such subset exists, otherwise return False.\n    \"\"\"\n    def subset_sum(nums, target):\n        n = len(nums)\n        dp = [[False] * (target + 1) for _ in range(n + 1)]\n        \n        for i in range(n + 1):\n            dp[i][0] = True\n        \n        for i in range(1, n + 1):\n            for j in range(1, target + 1):\n                if nums[i - 1] > j:\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n        \n        return dp[n][target]\n    \n    return subset_sum(nums, target)\n\ndef g():\n    nums = [2, 4, 6, 8, 10]\n    target = 16\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 423,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> List[str]:\n    \"\"\"Split a string into words and return a list of words in reverse order.\"\"\"\n    words = string.split()\n    return words[::-1]\n\ndef g():\n    return \"Hello, world! This is a test.\"\n\nassert f(g()) == [\"test.\", \"a\", \"is\", \"This\", \"world!\", \"Hello,\"]\n",
        "idx_generation": 455,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int], target: int) -> bool:\n    \"\"\"Check if there are two numbers in the list that sum up to the target.\"\"\"\n    numbers.sort()  # Sort the list in ascending order\n    left = 0\n    right = len(numbers) - 1\n\n    while left < right:\n        current_sum = numbers[left] + numbers[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    return ([7, 2, 5, 1, 3], 9)\n\nassert f(*g())\n",
        "idx_generation": 257,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find n such that n is a prime number and the sum of its digits is also a prime number.\"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    digit_sum = sum(map(int, str(n)))\n    return is_prime(n) and is_prime(digit_sum)\n\ndef g():\n    n = 2\n    while True:\n        if f(n):\n            return n\n        n += 1\n\nassert f(g()) == True\n",
        "idx_generation": 312,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Compute the nth Fibonacci number recursively.\"\"\"\n    if n <= 1:\n        return n\n    else:\n        return f(n-1) + f(n-2)\n\ndef g(n: int):\n    \"\"\"Generate an integer n.\"\"\"\n    return n\n\nassert f(g(6)) == 8\n",
        "idx_generation": 425,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[str]) -> bool:\n    \"\"\"Check if the given list of strings contains a string that is a palindrome.\"\"\"\n    for s in arr:\n        if s == s[::-1]:\n            return True\n    return False\n\ndef g():\n    arr = ['hello', 'world', 'madam', 'python']\n    return arr\n\nassert f(g())\n",
        "idx_generation": 461,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(arr: List[int], n: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, find if there exist two numbers in the list whose sum is equal to a given number n.\n    Implement a binary search algorithm to solve this problem.\n    \"\"\"\n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        if arr[low] + arr[high] == n:\n            return True\n        elif arr[low] + arr[high] < n:\n            low += 1\n        else:\n            high -= 1\n\n    return False\n\ndef g():\n    return [2, 4, 6, 8, 10, 12, 14], 16\n\nassert f(*g())\n",
        "idx_generation": 258,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given an array of integers and a target number, find two numbers in the array that add up to the target and return their indices.\"\"\"\n    num_to_index = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_to_index:\n            return [num_to_index[complement], i]\n        num_to_index[num] = i\n    return []\n\ndef g(target=9):\n    return [2, 7, 11, 15], target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 313,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n    A subsequence is a sequence that can be derived from another sequence by deleting some or no elements, without changing the order of the remaining elements.\n    An increasing subsequence is a subsequence in which the elements are in increasing order.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return nums\n\nassert f(g([10, 9, 2, 5, 3, 7, 101, 18])) == 4\n",
        "idx_generation": 425,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of words in the string.\n    Words in the string are separated by a single space.\n    Return the reversed string.\n    \"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    reversed_string = \" \".join(reversed_words)\n    return reversed_string\n\ndef g():\n    s = \"Hello World, I am Python\"\n    return s\n\nassert f(g()) == \"Python am I World, Hello\"\n\n",
        "idx_generation": 475,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a sorted matrix of integers, where each row and each column is sorted in ascending order,\n    determine if the target value is present in the matrix.\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return False\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n    row = 0\n    col = cols - 1\n\n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n\n    return False\n\ndef g():\n    return [[1, 4, 7], [2, 5, 8], [3, 6, 9]], 5\n\nassert f(*g())\n",
        "idx_generation": 258,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Calculate the maximum sum of a subgrid within a given grid.\n    The grid is represented as a list of lists, where each inner list represents a row.\n    Sample Input:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    Sample Output:\n    45\"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    max_sum = float('-inf')\n    for i in range(m):\n        for j in range(n):\n            for k in range(i, m):\n                for l in range(j, n):\n                    subgrid_sum = 0\n                    for x in range(i, k + 1):\n                        for y in range(j, l + 1):\n                            subgrid_sum += grid[x][y]\n                    max_sum = max(max_sum, subgrid_sum)\n    return max_sum\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g()) == 45\n",
        "idx_generation": 314,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if there is a subset of the list that adds up to the target value.\n    Return True if such subset exists, False otherwise.\n    \"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(1, n + 1):\n        for j in range(target + 1):\n            if nums[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n    return dp[n][target]\n\ndef g(target: int):\n    nums = [2, 4, 6, 8, 10]\n    return nums, target\n\nassert f(*g(14))\n",
        "idx_generation": 427,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Given two strings s1 and s2, determine if they are anagrams of each other.\n    Return True if they are anagrams, False otherwise.\n    \"\"\"\n\n    def count_chars(s: str) -> dict:\n        char_count = {}\n        for char in s:\n            char_count[char] = char_count.get(char, 0) + 1\n        return char_count\n\n    return count_chars(s1) == count_chars(s2)\n\ndef g():\n    return \"listen\", \"silent\"\n\nassert f(*g())\n",
        "idx_generation": 481,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, return True if there are three numbers in the list that sum up to the target number.\n    Otherwise, return False.\n    \"\"\"\n    nums.sort()  # Sort the list in ascending order\n    n = len(nums)\n    \n    for i in range(n - 2):\n        left = i + 1\n        right = n - 1\n        \n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            \n            if current_sum == target:\n                return True\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    \n    return False\n\ndef g(nums=[2, 4, 1, 5, 6, 3, 8], target=10):\n    \"\"\"\n    Generate a list of integers and a target number.\n    The list contains at least three numbers that sum up to the target number.\n    \"\"\"\n    return nums, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 260,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Given two strings 's1' and 's2', determine if 's2' can be formed by rearranging the characters of 's1',\n    but preserving the relative order of the characters. Return True if possible, False otherwise.\n    \"\"\"\n    s1_freq = [0] * 26\n    s2_freq = [0] * 26\n    \n    for char in s1:\n        s1_freq[ord(char) - ord('a')] += 1\n    \n    for char in s2:\n        s2_freq[ord(char) - ord('a')] += 1\n    \n    return s1_freq == s2_freq\n\ndef g():\n    \"\"\"\n    Generate two strings.\n    \"\"\"\n    s1 = \"race\"\n    s2 = \"care\"\n    \n    return s1, s2\n\nassert f(*g()) == True\n\n",
        "idx_generation": 319,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> int:\n    \"\"\"Find the number of unique paths from the top-left corner to the bottom-right corner in an n x m grid.\n    You can only move down or right at each step.\"\"\"\n    dp = [[0] * m for _ in range(n)]\n    \n    for i in range(n):\n        for j in range(m):\n            if i == 0 or j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[n-1][m-1]\n\ndef g():\n    return 3, 4\n\nassert f(*g()) == 10\n\n",
        "idx_generation": 427,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"\n    Determine if a string can be divided into k equal parts.\n    Return True if the string can be divided into k equal parts, False otherwise.\n    \"\"\"\n    n = len(s)\n    if n % k != 0:\n        return False\n    part_size = n // k\n    \n    for i in range(0, n, part_size):\n        if s[i:i+part_size] != s[0:part_size]:\n            return False\n    \n    return True\n\ndef g():\n    \"\"\"\n    Generate a string and a value for k.\n    \"\"\"\n    s = \"abcabcabc\"\n    k = 3\n    \n    return s, k\n\nassert f(*g())\n",
        "idx_generation": 487,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target integer k, determine if any two numbers in the list\n    sum up to k. Return True if there exists such pair, False otherwise.\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == k:\n            return True\n        elif curr_sum < k:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    nums = [2, 4, 6, 8, 10]\n    k = 12\n    return nums, k\n\nassert f(*g()) == True\n",
        "idx_generation": 261,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"Check if there exists a subarray of length k in the array arr, such that the sum of the subarray is divisible by k\"\"\"\n    prefix_sum = 0\n    remainder_count = {0: -1}\n    \n    for i, num in enumerate(arr):\n        prefix_sum = (prefix_sum + num) % k\n        \n        if prefix_sum in remainder_count:\n            if i - remainder_count[prefix_sum] >= k:\n                return True\n        else:\n            remainder_count[prefix_sum] = i\n    \n    return False\n\ndef g(arr: List[int], k: int) -> List[int]:\n    \"\"\"Generate an array with elements that satisfy the condition for f\"\"\"\n    return arr + [k] * (k - 1)\n\nassert f(g([1, 2, 3, 4, 5], 7), 7)\n",
        "idx_generation": 319,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the length of the longest increasing subsequence in the given list of integers.\"\"\"\n    n = len(nums)\n    lis = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n\n    return max(lis)\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"Return the given list of integers.\"\"\"\n    return nums\n\nassert f(g([10, 9, 2, 5, 3, 7, 101, 18])) == 4\n",
        "idx_generation": 427,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(sentence: str) -> str:\n    \"\"\"Given a sentence, reverse the order of the words in the sentence.\n    Return the reversed sentence.\n    Example:\n    sentence = \"Hello world, how are you?\"\n    The reversed sentence should be \"you? are how world, Hello\"\n    \"\"\"\n    words = sentence.split()\n    reversed_sentence = \" \".join(words[::-1])\n    return reversed_sentence\n\ndef g() -> str:\n    return \"Hello world, how are you?\"\n\nassert f(g()) == \"you? are how world, Hello\"\n",
        "idx_generation": 488,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, find the maximum difference between any two numbers in the list. The list will have at least two elements.\"\"\"\n    nums.sort()\n    return nums[-1] - nums[0]\n\ndef g():\n    return [1, 5, 3, 9, 2, 7]\n\nassert f(g()) == 8\n",
        "idx_generation": 262,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum sum of a subarray.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"Generate a list of random integers.\"\"\"\n    return [4, -3, 5, -2, -1, 2, 6, -2]\n\nassert f(g()) == 11\n",
        "idx_generation": 321,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given an integer n, find the nth Fibonacci number using recursion.\"\"\"\n    if n <= 1:\n        return n\n    else:\n        return f(n-1) + f(n-2)\n\ndef g(n: int) -> int:\n    return f(n)\n\nn = 7\nassert f(n) == g(n)\n",
        "idx_generation": 429,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> str:\n    \"\"\"Generate a string by repeating the given string 's' 'n' times.\"\"\"\n    return s * n\n\ndef g():\n    s = \"abc\"\n    n = 3\n    return s, n\n\nassert f(*g()) == \"abcabcabc\"\n",
        "idx_generation": 490,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(numbers: List[int], target: int) -> bool:\n    \"\"\"Given a list of numbers and a target value, determine if there exist two numbers in the list whose sum is equal to the target value.\"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if numbers[i] + numbers[j] == target:\n                return True\n    return False\n\ndef g():\n    numbers = [2, 4, 6, 8, 10]\n    target = 12\n    return numbers, target\n\nassert f(*g())\n",
        "idx_generation": 263,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"Check if the target string is a substring of the given string, s\"\"\"\n    return target in s\n\ndef g():\n    s = \"Hello, World!\"\n    target = \"World\"\n    return s, target\n\nassert f(*g())\n",
        "idx_generation": 322,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Find the shortest distance from the top-left cell to the bottom-right cell in a grid.\n    Each cell in the grid represents the cost to reach that cell.\n    You can only move down or right from each cell.\n    Return the minimum cost to reach the bottom-right cell.\n    \"\"\"\n\n    m, n = len(grid), len(grid[0])\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g():\n    return [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\nassert f(g()) == 7\n",
        "idx_generation": 431,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Given a string s, reverse the order of the words in the string while keeping the words themselves unchanged.\"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    reversed_sentence = \" \".join(reversed_words)\n    return reversed_sentence\n\ndef g():\n    s = \"Hello World! This is a test.\"\n    return s\n\nassert f(g()) == \"test. a is This World! Hello\"\n",
        "idx_generation": 493,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted array of integers and a target value, return the index of the target if it is found.\n    If the target is not found in the array, return the index where it would be inserted in order.\"\"\"\n    left, right = 0, len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left\n\ndef g():\n    return ([1, 3, 5, 6], 4)\n\nassert f(*g()) == 2\n",
        "idx_generation": 264,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the sum of all even numbers smaller than n.\n    Sample input:\n    n = 10\n    Sample output:\n    20 (2 + 4 + 6 + 8 = 20)\"\"\"\n    total = 0\n    for i in range(2, n, 2):\n        total += i\n    return total\n\ndef g():\n    return 10\n\nassert f(g()) == 20\n",
        "idx_generation": 323,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Given a square matrix of integers, find the length of the longest increasing path.\n    An increasing path is defined as a sequence of cells in the matrix where each cell's value is strictly greater\n    than the previous cell's value.\"\"\"\n    if not matrix:\n        return 0\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n    max_length = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    \n    def dfs(i, j):\n        if dp[i][j] != 0:\n            return dp[i][j]\n        max_path = 1\n        for dx, dy in directions:\n            x, y = i + dx, j + dy\n            if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                max_path = max(max_path, 1 + dfs(x, y))\n        dp[i][j] = max_path\n        return max_path\n    \n    for i in range(m):\n        for j in range(n):\n            max_length = max(max_length, dfs(i, j))\n    return max_length\n\ndef g(matrix: List[List[int]]):\n    return matrix\n\nassert f(g([[9, 9, 4],\n            [6, 6, 8],\n            [2, 1, 1]])) == 4\n\n",
        "idx_generation": 432,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given a positive integer n, determine if it is a prime number.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g(n: int) -> int:\n    \"\"\"Find the next prime number after the given number.\"\"\"\n    num = n + 1\n    while True:\n        if f(num):\n            return num\n        num += 1\n\nassert f(g(10))\n",
        "idx_generation": 267,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the sum of all positive integers smaller than n that are divisible by 3 or 5.\n    Sample input:\n    n = 10\n    Sample output:\n    23 (3 + 5 + 6 + 9 = 23)\"\"\"\n    total = 0\n    for i in range(1, n):\n        if i % 3 == 0 or i % 5 == 0:\n            total += i\n    return total\n\ndef g():\n    return 10\n\nassert f(g()) == 23\n",
        "idx_generation": 323,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of integers, determine if there exists a path from the top-left cell to the bottom-right cell,\n    where each cell value represents the maximum number of steps that can be taken from that cell.\n    The path can only move down or right.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    dp = [[False] * cols for _ in range(rows)]\n    dp[0][0] = True\n    for i in range(1, rows):\n        if dp[i-1][0] and matrix[i][0] > 0:\n            dp[i][0] = True\n    for j in range(1, cols):\n        if dp[0][j-1] and matrix[0][j] > 0:\n            dp[0][j] = True\n    for i in range(1, rows):\n        for j in range(1, cols):\n            if (dp[i-1][j] or dp[i][j-1]) and matrix[i][j] > 0:\n                dp[i][j] = True\n    return dp[rows-1][cols-1]\n\ndef g():\n    return [[1, 3, 2],\n            [2, 5, 1],\n            [6, 2, 1]]\n\nassert f(g())\n",
        "idx_generation": 433,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of integers is sorted in non-decreasing order.\"\"\"\n    return nums == sorted(nums)\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g())\n\n",
        "idx_generation": 268,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Find if there exists a pair of elements in the given array whose sum is equal to the target value.\"\"\"\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] + arr[j] == target:\n                return True\n    return False\n\ndef g():\n    \"\"\"Generate an array and target value such that there exists a pair of elements with the target sum.\"\"\"\n    return [1, 2, 3, 4, 5], 9\n\nassert f(*g())\n",
        "idx_generation": 325,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, find if there exists a subset of the integers that adds up to the target.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if nums[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[n][target]\n\n\ndef g(nums=[2, 4, 6, 8, 10], target=16):\n    return nums, target\n\n\nassert f(*g())\n",
        "idx_generation": 439,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there exists two numbers in the list whose sum equals the target value.\n    Return True if such numbers exist, and False otherwise.\"\"\"\n    \n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    return [-2, 1, 3, 5, 7, 9, 11]\n\nassert f(g(), target=10)\n",
        "idx_generation": 272,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Given two strings 's1' and 's2',\n    determine if they are isomorphic.\n    Two strings are isomorphic if the characters in 's1' can be replaced to get 's2'.\n    Return True if 's1' and 's2' are isomorphic, False otherwise.\n    Example:\n    s1 = \"paper\"\n    s2 = \"title\"\n    The characters in 's1' can be replaced as follows:\n    'p' -> 't', 'a' -> 'i', 'e' -> 'l', 'r' -> 'e'\n    Therefore, 's1' and 's2' are isomorphic and the answer is True.\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n    mapping = {}\n    for i in range(len(s1)):\n        if s1[i] in mapping:\n            if mapping[s1[i]] != s2[i]:\n                return False\n        else:\n            mapping[s1[i]] = s2[i]\n    return True\n\ndef g():\n    return \"paper\", \"title\"\n\nassert f(*g())\n",
        "idx_generation": 330,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the minimum number of steps required to navigate from the top-left corner to the bottom-right corner.\n    You can only move down or right, and you can only move to a cell containing a 0.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[float('inf')] * cols for _ in range(rows)]\n    dp[0][0] = 0\n    \n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 0:\n                if i > 0:\n                    dp[i][j] = min(dp[i][j], dp[i-1][j] + 1)\n                if j > 0:\n                    dp[i][j] = min(dp[i][j], dp[i][j-1] + 1)\n    \n    return dp[rows-1][cols-1]\n\ndef g():\n    \"\"\"\n    Generate a grid of random 0s and 1s where there is a valid path from the top-left corner to the bottom-right corner.\n    \"\"\"\n    grid = [[random.randint(0, 1) for _ in range(5)] for _ in range(5)]\n    grid[0][0] = 0\n    grid[-1][-1] = 0\n    return grid\n\nassert f(g()) >= 0\n",
        "idx_generation": 442,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, find if there are three distinct elements in the list whose sum is equal to the target.\n    Return True if such elements exist, False otherwise.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    for i in range(n - 2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            curr_sum = nums[i] + nums[left] + nums[right]\n            if curr_sum == target:\n                return True\n            elif curr_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 274,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given an array of integers nums and a target integer, find two numbers in the array\n    that add up to the target and return their indices.\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(i+1, n):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 330,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Determine if there is a path from the top-left to the bottom-right corner of the grid, where each step can only be made to the right or down.\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[False] * n for _ in range(m)]\n    \n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j] == 0\n            elif i == 0:\n                dp[i][j] = dp[i][j - 1] and grid[i][j] == 0\n            elif j == 0:\n                dp[i][j] = dp[i - 1][j] and grid[i][j] == 0\n            else:\n                dp[i][j] = (dp[i - 1][j] or dp[i][j - 1]) and grid[i][j] == 0\n    \n    return dp[-1][-1]\n\ndef g(grid=[[0, 0, 0], [0, 1, 0], [0, 0, 0]]):\n    return grid\n\nassert f(g())\n",
        "idx_generation": 442,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers that add up to the target value.\"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), 15)\n",
        "idx_generation": 276,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"Given a matrix of integers, return the elements of the matrix in spiral order, clockwise.\"\"\"\n\n    if not matrix:\n        return []\n\n    result = []\n    m, n = len(matrix), len(matrix[0])\n    top, bottom, left, right = 0, m - 1, 0, n - 1\n\n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result\n\ndef g():\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 330,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n    A subsequence of a list is obtained by deleting zero or more elements from the list while maintaining the order of the remaining elements.\n    Return the length of the longest increasing subsequence.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g():\n    return [10, 22, 9, 33, 21, 50, 41, 60, 80]\n\nassert f(g()) == 6\n",
        "idx_generation": 444,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers, find the index of the target value using binary search.\"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), 7) == 6\n",
        "idx_generation": 276,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Determine if there exists a subarray in nums that sums up to k.\"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum - k in prefix_sums:\n            return True\n        prefix_sums.add(prefix_sum)\n    return False\n\ndef g():\n    nums = [1, -2, 3, 5, -3, 2]\n    k = 4\n    return nums, k\n\nassert f(*g())\n",
        "idx_generation": 331,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, starting at the top-left corner, find the minimum cost to reach the bottom-right corner.\n    Each cell in the grid represents the cost to move to that cell.\n    Return the minimum cost.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(m):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j])\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j])\n\n    return dp[m-1][n-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 445,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers nums and a target value, determine if there exists two integers in the array such that their sum is equal to the target. Return True if such a pair exists, otherwise return False.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n            \n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5], 9\n\nassert f(*g())\n",
        "idx_generation": 277,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers 'nums' and a target number, determine if there exists a subarray in the list\n    whose sum is equal to the target number. Return True if such a subarray exists, False otherwise.\n    \"\"\"\n    n = len(nums)\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if prefix_sum[j] - prefix_sum[i] == target:\n                return True\n    return False\n\ndef g(target: int) -> List[int]:\n    \"\"\"\n    Generate a list of integers that contains a subarray whose sum is equal to the target number.\n    \"\"\"\n    return [1, 2, 3, target-6, 4, 5]\n\nassert f(g(6), 6) == True\n",
        "idx_generation": 332,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, find if there exists a subsequence whose elements sum up to the target.\n    Return True if such a subsequence exists, False otherwise.\n    \"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n    \n    for i in range(1, n + 1):\n        dp[i][0] = True\n        for j in range(1, target + 1):\n            if nums[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n    \n    return dp[n][target]\n\ndef g():\n    nums = [3, 1, 5, 9, 12]\n    target = 8\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 447,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers, find the index of the target value using binary search.\"\"\"\n    low = 0\n    high = len(nums) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\ndef g(target: int):\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(7), 7) == 6\n",
        "idx_generation": 278,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum sum of a subarray within the list.\n    Return the maximum sum.\n    Example input:\n    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Example output:\n    6\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in arr:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 333,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Given two positive integers n and k, determine if there exists a binary string of length n\n    such that the number of 1's is divisible by k.\"\"\"\n    def dfs(s, idx, count, target):\n        if idx == len(s):\n            return count % target == 0\n        if s[idx] == \"1\":\n            return dfs(s, idx + 1, count + 1, target)\n        elif s[idx] == \"0\":\n            return dfs(s, idx + 1, count, target) or dfs(s, idx + 1, count + 1, target)\n\n    # Generate all binary strings of length n\n    def generate_binary_strings(n):\n        if n == 0:\n            return [\"\"]\n        else:\n            strings = generate_binary_strings(n - 1)\n            return [s + \"0\" for s in strings] + [s + \"1\" for s in strings]\n\n    binary_strings = generate_binary_strings(n)\n\n    for s in binary_strings:\n        if dfs(s, 0, 0, k):\n            return True\n    return False\n\ndef g(n=4, k=3):\n    return n, k\n\nassert f(*g()) == True\n",
        "idx_generation": 448,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order using the bubble sort algorithm.\n    Return the sorted list.\n    \"\"\"\n    n = len(arr)\n    \n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    \n    return arr\n\ndef g(arr: List[int]) -> List[int]:\n    \"\"\"\n    Generate a list of integers for sorting.\n    \"\"\"\n    return arr\n\nassert f(g([9, 3, 7, 1, 5])) == [1, 3, 5, 7, 9]\n",
        "idx_generation": 278,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Given a string 's' and an integer 'k',\n    determine if it is possible to rearrange the characters in 's'\n    in such a way that the bitwise AND between any two adjacent characters is equal to 'k'.\n    Return True if it is possible, False otherwise.\n    Example:\n    s = \"abcabc\"\n    k = 1\n    The possible rearrangements are \"abacbc\", \"bacabc\", \"cbabac\", \"acbacb\", \"bcabac\".\n    All of these rearrangements have the bitwise AND between any two adjacent characters equal to 1.\n    Therefore, the answer is True.\n    \"\"\"\n    if len(set(s)) < k:\n        return False\n    return True\n\ndef g():\n    return \"abcabc\", 1\n\nassert f(*g())\n",
        "idx_generation": 334,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nimport itertools\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of 0s and 1s, check if it is possible to reach from the top-left corner to the bottom-right corner,\n    moving only right or down. Return True if it is possible, and False otherwise.\"\"\"\n    n = len(matrix)\n    m = len(matrix[0])\n    dp = [[False] * m for _ in range(n)]\n    dp[0][0] = True\n    \n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] == 1:\n                continue\n            \n            if i > 0:\n                dp[i][j] = dp[i][j] or dp[i-1][j]\n            if j > 0:\n                dp[i][j] = dp[i][j] or dp[i][j-1]\n    \n    return dp[n-1][m-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a random matrix.\"\"\"\n    matrix = [[0, 0, 1, 0, 0], [0, 0, 0, 0, 1], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0], [1, 1, 1, 0, 0]]\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 449,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if a target value exists in a sorted list of integers using binary search.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return False\n\ndef g():\n    return [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n\nassert f(g(), 9)\n",
        "idx_generation": 279,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, find the number of trailing zeros in n! (n factorial).\"\"\"\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n    return count\n\ndef g():\n    n = 25\n    return n\n\nassert f(g()) == 6\n",
        "idx_generation": 335,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, find the maximum sum path from the top-left to the bottom-right corner, allowing only right and down moves.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for row in range(1, rows):\n        dp[row][0] = dp[row - 1][0] + grid[row][0]\n\n    for col in range(1, cols):\n        dp[0][col] = dp[0][col - 1] + grid[0][col]\n\n    for row in range(1, rows):\n        for col in range(1, cols):\n            dp[row][col] = max(dp[row - 1][col], dp[row][col - 1]) + grid[row][col]\n\n    return dp[rows - 1][cols - 1]\n\ndef g():\n    n = 3\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return n, grid\n\nassert f(*g()) == 12\n",
        "idx_generation": 456,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target_sum: int) -> bool:\n    \"\"\"Given a list of integers and a target sum, find if there exists a pair of numbers in the list whose sum is equal to the target sum.\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target_sum:\n            return True\n        elif current_sum < target_sum:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 4, 5, 6, 8, 9, 10], 15\n\nassert f(*g())\n",
        "idx_generation": 280,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there are two integers in the list that add up to the target.\n    \n    Return True if such a pair exists, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 9\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 335,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, target: int, nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a subset of the integers that adds up to the target.\n    Return True if such a subset exists, False otherwise.\n    You may assume that the input list will not contain any negative integers.\n    Sample Input:\n    n = 5, target = 9, nums = [2, 4, 5, 6, 8]\n    Sample Output:\n    True\n    Explanation:\n    The subset [2, 4, 5] adds up to the target value 9.\"\"\"\n    def subsetSum(nums, target):\n        dp = [[False] * (target + 1) for _ in range(len(nums) + 1)]\n        for i in range(len(nums) + 1):\n            dp[i][0] = True\n        for i in range(1, len(nums) + 1):\n            for j in range(1, target + 1):\n                if j < nums[i - 1]:\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n        return dp[len(nums)][target]\n    \n    return subsetSum(nums, target)\n    \n\ndef g(n=5, target=9, nums=[2, 4, 5, 6, 8]):\n    return n, target, nums\n\nassert f(*g())\n",
        "idx_generation": 460,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target element if it exists in the list.\n    If the target element does not exist, return -1.\n    \"\"\"\n    low = 0\n    high = len(nums) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers and a target element.\n    \"\"\"\n    nums.sort()\n    return nums, target\n\nassert f(*g([1, 2, 3, 4, 5, 6, 7, 8, 9], 5)) == 4\n",
        "idx_generation": 281,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if the given grid is a valid Sudoku solution\"\"\"\n    # Check rows\n    for row in grid:\n        if len(set(row)) != len(row):\n            return False\n\n    # Check columns\n    for col in range(len(grid[0])):\n        column = [grid[row][col] for row in range(len(grid))]\n        if len(set(column)) != len(column):\n            return False\n\n    # Check 3x3 subgrids\n    for i in range(0, len(grid), 3):\n        for j in range(0, len(grid[0]), 3):\n            subgrid = [grid[r][c] for r in range(i, i+3) for c in range(j, j+3)]\n            if len(set(subgrid)) != len(subgrid):\n                return False\n\n    return True\n\ndef g():\n    # Valid Sudoku solution\n    valid_grid = [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9]\n    ]\n\n    # Invalid Sudoku solution (duplicate 6 in first row)\n    invalid_grid = [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 6, 9]  # Duplicate 6 in first row\n    ]\n\n    return valid_grid, invalid_grid\n\nassert f(g()[0])\nassert not f(g()[1])\n",
        "idx_generation": 341,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum path from the top-left corner to the bottom-right corner.\n    Return the minimum sum.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    # Initialize the minimum sum grid with the same dimensions as the input grid\n    min_sum_grid = [[0] * cols for _ in range(rows)]\n    \n    # Fill the first row and first column of the min_sum_grid\n    min_sum_grid[0][0] = grid[0][0]\n    for i in range(1, rows):\n        min_sum_grid[i][0] = min_sum_grid[i-1][0] + grid[i][0]\n    for j in range(1, cols):\n        min_sum_grid[0][j] = min_sum_grid[0][j-1] + grid[0][j]\n    \n    # Fill the rest of the min_sum_grid\n    for i in range(1, rows):\n        for j in range(1, cols):\n            min_sum_grid[i][j] = min(min_sum_grid[i-1][j], min_sum_grid[i][j-1]) + grid[i][j]\n    \n    return min_sum_grid[rows-1][cols-1]\n\ndef g():\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    \n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 461,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers 'nums' and a target value 'target',\n    find the index of the target value in the list using binary search.\n    If the target value is not found, return -1.\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 6\n    The target value 6 is found at index 5, so the output should be 5.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9], 6\n\nassert f(*g()) == 5\n",
        "idx_generation": 282,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers, determine if there exists two numbers such that their sum is equal to the target.\n    Return True if such numbers exist, False otherwise.\"\"\"\n    i = 0\n    j = len(nums) - 1\n\n    while i < j:\n        curr_sum = nums[i] + nums[j]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            i += 1\n        else:\n            j -= 1\n\n    return False\n\ndef g():\n    nums = sorted([1, 4, 5, 7, 8, 10])\n    target = 13\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 343,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of distinct binary strings of length n that do not contain consecutive 1s.\"\"\"\n    def countStrings(n: int) -> int:\n        a = [0] * (n + 1)\n        b = [0] * (n + 1)\n        a[1] = b[1] = 1\n        for i in range(2, n + 1):\n            a[i] = a[i - 1] + b[i - 1]\n            b[i] = a[i - 1]\n        return a[n] + b[n]\n    \n    return countStrings(n)\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == 13\n",
        "idx_generation": 461,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, check if the target value exists in the list.\n    Implement a binary search algorithm to solve this problem.\n    \"\"\"\n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return False\n\ndef g():\n    return [2, 4, 6, 8, 10, 12, 14], 10\n\nassert f(*g())\n",
        "idx_generation": 283,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, rotate it 90 degrees clockwise and return the rotated matrix.\n    \"\"\"\n    n = len(matrix)\n    rotated = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            rotated[j][n-1-i] = matrix[i][j]\n    return rotated\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers that can be rotated 90 degrees clockwise.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 345,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the length of the longest increasing subsequence in a given list of integers.\"\"\"\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g():\n    \"\"\"Generate a list of integers to find the length of the longest increasing subsequence.\"\"\"\n    nums = [10, 22, 9, 33, 21, 50, 41, 60]\n    return nums\n\nassert f(g()) == 5\n",
        "idx_generation": 462,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the missing number in a sorted list of consecutive integers.\"\"\"\n    for i in range(len(nums) - 1):\n        if nums[i+1] - nums[i] != 1:\n            return nums[i] + 1\n    return -1\n\ndef g():\n    return [1, 2, 3, 5, 6, 7, 8, 9]\n\nassert f(g()) == 4\n",
        "idx_generation": 285,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a pair of numbers in the list whose multiplication is equal to 0.\"\"\"\n    for num in nums:\n        if num == 0:\n            return True\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 0, 6, 7, 8, 9, 10]\n    return nums\n\nassert f(g())\n",
        "idx_generation": 348,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any non-adjacent elements.\n    \"\"\"\n    if len(arr) == 0:\n        return 0\n\n    if len(arr) == 1:\n        return arr[0]\n\n    if len(arr) == 2:\n        return max(arr[0], arr[1])\n\n    dp = [0] * len(arr)\n    dp[0] = arr[0]\n    dp[1] = max(arr[0], arr[1])\n\n    for i in range(2, len(arr)):\n        dp[i] = max(dp[i - 1], dp[i - 2] + arr[i])\n\n    return dp[-1]\n\ndef g(arr: List[int] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) -> int:\n    \"\"\"\n    Find the maximum sum of any non-adjacent elements in the given list of integers.\n    \"\"\"\n    return arr\n\nassert f(g()) == 30\n",
        "idx_generation": 465,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target=10) -> bool:\n    \"\"\"Find if there exist two elements in the array that sum up to the target value.\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g(target=10):\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nassert f(g())\n",
        "idx_generation": 286,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Find the sum of all the multiples of 3 or 5 below the given integer 'n'.\n    \"\"\"\n    sum = 0\n    for i in range(n):\n        if i % 3 == 0 or i % 5 == 0:\n            sum += i\n    return sum\n\ndef g():\n    \"\"\"\n    Generate an integer.\n    \"\"\"\n    n = 100\n    \n    return n\n\nassert f(g()) == 2318\n",
        "idx_generation": 348,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target=100) -> bool:\n    \"\"\"Determine if it is possible to obtain the target sum by selecting a subset of the given array.\"\"\"\n    n = len(arr)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(target + 1):\n            dp[i][j] = dp[i-1][j]\n            if j >= arr[i-1]:\n                dp[i][j] = dp[i][j] or dp[i-1][j-arr[i-1]]\n\n    return dp[n][target]\n\ndef g(target=100):\n    return [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\n\nassert f(g())\n",
        "idx_generation": 467,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers 'arr' and a target integer 'target', return a list of two numbers from 'arr' that add up to 'target'.\n    If there are multiple pairs that satisfy the condition, return the pair with the smallest difference between the two numbers.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    min_diff = float('inf')\n    res = []\n    \n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        diff = abs(curr_sum - target)\n        \n        if diff < min_diff:\n            min_diff = diff\n            res = [arr[left], arr[right]]\n        \n        if curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return res\n\ndef g(arr: List[int], target: int) -> List[int]:\n    arr.sort()\n    return f(arr, target)\n\narr = [1, 3, 4, 6, 8, 9]\ntarget = 10\nassert f(arr, target) == g(arr, target)\n",
        "idx_generation": 286,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, check if the list can be rearranged in such a way that the sum of any two adjacent\n    numbers is even.\n    Return True if it is possible, False otherwise.\n    \"\"\"\n    count_odd = 0\n    count_even = 0\n    \n    for num in nums:\n        if num % 2 == 0:\n            count_even += 1\n        else:\n            count_odd += 1\n    \n    return count_odd % 2 == 0 or count_even % 2 == 0\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g())\n",
        "idx_generation": 349,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, return True if the list can be partitioned into two subarrays such that\n    the sum of the elements in each subarray is equal. Return False otherwise.\"\"\"\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n    target_sum = total_sum // 2\n    n = len(nums)\n    dp = [[False] * (target_sum + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(1, n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target_sum + 1):\n            if nums[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j - nums[i - 1]] or dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[n][target_sum]\n\ndef g():\n    \"\"\"Generate a list of integers.\"\"\"\n    return [1, 5, 11, 5]\n\nassert f(g())\n",
        "idx_generation": 468,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, check if there exists three elements in the list that sum up to zero.\n    Sample input:\n    [1, -2, 3, -4, 5, -3]\n    Sample output:\n    True\"\"\"\n    nums.sort()\n    n = len(nums)\n    for i in range(n-2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            if nums[i] + nums[left] + nums[right] == 0:\n                return True\n            elif nums[i] + nums[left] + nums[right] < 0:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g():\n    return [1, -2, 3, -4, 5, -3]\n\nassert f(g()) == True\n",
        "idx_generation": 287,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, calculate the number of distinct characters in the string.\n    \"\"\"\n    return len(set(s))\n\ndef g(s: str):\n    return s\n\nassert f(g(\"abracadabra\")) == 5\n",
        "idx_generation": 349,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum subarray sum.\n    Return the maximum sum.\n    \"\"\"\n    max_sum = nums[0]\n    curr_sum = nums[0]\n    for i in range(1, len(nums)):\n        curr_sum = max(nums[i], curr_sum + nums[i])\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Return a list of integers.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 468,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers in ascending order and a target value, determine if there are two numbers in the list that sum up to the target.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    return [1, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n\nassert f(g(), 15)\n",
        "idx_generation": 288,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Given a list of integers, return the sum of all prime numbers in the list.\"\"\"\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    prime_sum = 0\n    for num in arr:\n        if is_prime(num):\n            prime_sum += num\n    return prime_sum\n\ndef g():\n    return [2, 7, 4, 9, 11, 6, 13, 15]\n\nassert f(g()) == 33\n",
        "idx_generation": 350,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> str:\n    \"\"\"Given two strings 's1' and 's2', find the longest common subsequence (LCS) between the two strings.\"\"\"\n    m, n = len(s1), len(s2)\n    dp = [[\"\" for _ in range(n+1)] for _ in range(m+1)]\n\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if s1[i-1] == s2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + s1[i-1]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1], key=len)\n\n    return dp[m][n]\n\ndef g():\n    return \"ABCDGH\", \"AEDFHR\"\n\nassert f(*g()) == \"ADH\"\n",
        "idx_generation": 469,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers 'nums' and a target number 'target',\n    find the index of the target number in the list using binary search.\n    Return -1 if the target number is not found.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g():\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    nums = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n    target = 11\n    \n    return nums, target\n\nassert f(*g()) == 5\n\n",
        "idx_generation": 290,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, return a new list with all the duplicates removed.\n    The order of the elements in the resulting list should be the same as the original list.\"\"\"\n    unique_nums = []\n    seen = set()\n    for num in nums:\n        if num not in seen:\n            unique_nums.append(num)\n            seen.add(num)\n    return unique_nums\n\ndef g():\n    return [1, 2, 3, 4, 3, 2, 5, 6, 1, 7, 8, 2, 9]\n\nassert f(g()) == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n",
        "idx_generation": 350,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the nth Fibonacci number\"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return f(n-1) + f(n-2)\n\ndef g(n=6):\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 469,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, find all pairs of numbers (a, b) such that a < b and a + b is divisible by 7.\n    Return True if at least one such pair exists, otherwise return False.\"\"\"\n    nums.sort()\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if (nums[i] + nums[j]) % 7 == 0:\n                return True\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7]  # Return a list of integers\n\nassert f(g()) == True\n",
        "idx_generation": 290,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], k=3) -> bool:\n    \"\"\"Find if there exists a subarray of length k in the given array that is sorted in non-decreasing order.\"\"\"\n    for i in range(len(arr) - k + 1):\n        subarray = arr[i:i+k]\n        if sorted(subarray) == subarray:\n            return True\n    return False\n\ndef g(k=3):\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g())\n",
        "idx_generation": 351,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(n: int) -> int:\n    \"\"\"Given an integer n, find the number of ways to climb to the top of a staircase.\n    Each time you can either climb 1 or 2 steps. Return the number of distinct ways.\"\"\"\n    if n <= 1:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    \n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    \n    return dp[n]\n\ndef g() -> int:\n    \"\"\"Generate an integer.\"\"\"\n    return 4\n\nassert f(g()) == 5\n",
        "idx_generation": 469,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, check if the target integer is present in the list using binary search.\"\"\"\n    low = 0\n    high = len(arr) - 1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return False\n\ndef g(arr=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target=7):\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 291,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, return a new list containing the maximum element from each subarray of consecutive odd integers.\n\n    Example: \n    Input: [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    Subarrays of consecutive odd integers: [1], [3], [5], [7], [9]\n    Maximum elements: 1, 3, 5, 7, 9\n    Output: [1, 3, 5, 7, 9]\n    \"\"\"\n    def is_odd(n: int) -> bool:\n        return n % 2 == 1\n\n    result = []\n    subarray = []\n    for num in nums:\n        if is_odd(num):\n            subarray.append(num)\n        else:\n            if subarray:\n                result.append(max(subarray))\n                subarray = []\n    if subarray:\n        result.append(max(subarray))\n    return result\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    return nums\n\nassert f(g()) == [1, 3, 5, 7, 9]\n",
        "idx_generation": 354,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the length of the longest increasing path.\n\n    Example:\n    Input: matrix = [\n                      [9, 9, 4],\n                      [6, 6, 8],\n                      [2, 1, 1]\n                    ]\n    Output: 4\n    Explanation: The longest increasing path is [1, 2, 6, 9].\n\n    \"\"\"\n\n    if not matrix:\n        return 0\n\n    rows, cols = len(matrix), len(matrix[0])\n    dp = [[0] * cols for _ in range(rows)]\n\n    def dfs(i: int, j: int) -> int:\n        if dp[i][j] != 0:\n            return dp[i][j]\n\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        max_length = 1\n\n        for dx, dy in directions:\n            x, y = i + dx, j + dy\n\n            if 0 <= x < rows and 0 <= y < cols and matrix[x][y] > matrix[i][j]:\n                max_length = max(max_length, 1 + dfs(x, y))\n\n        dp[i][j] = max_length\n        return max_length\n\n    ans = 0\n    for i in range(rows):\n        for j in range(cols):\n            ans = max(ans, dfs(i, j))\n\n    return ans\n\ndef g():\n    matrix = [\n                [9, 9, 4],\n                [6, 6, 8],\n                [2, 1, 1]\n             ]\n    return matrix\n\nassert f(g()) == 4\n",
        "idx_generation": 474,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there exists two numbers in the list that sum up to the target value.\n    Return True if such pair exists, False otherwise.\"\"\"\n    n = len(arr)\n    left = 0\n    right = n - 1\n    \n    while left < right:\n        current_sum = arr[left] + arr[right]\n        \n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Generate a sorted list of integers and a target value.\"\"\"\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    \n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 291,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine if a given number n is a prime number.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef g(n: int):\n    return n\n\nassert f(g(29))\n",
        "idx_generation": 355,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum sum that can be obtained by selecting non-adjacent elements from the list.\n    Return the maximum sum.\n    \"\"\"\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    if len(nums) == 2:\n        return max(nums[0], nums[1])\n    \n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    \n    for i in range(2, len(nums)):\n        dp[i] = max(nums[i] + dp[i-2], dp[i-1])\n    \n    return dp[-1]\n\ndef g():\n    nums = [1, 2, 3, 1]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 476,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find two numbers in a list that add up to a target value.\"\"\"\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []\n\ndef g():\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 293,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Find if there are two numbers in a given list that sum up to the target value.\n    Return True if there are two such numbers, and False otherwise.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        complement = target - num\n        if complement in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g():\n    return [2, 4, 7, 11, 15], 9\n\nassert f(*g())\n\n",
        "idx_generation": 356,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, return the number of distinct binary strings of length n that do not contain consecutive ones.\n    \"\"\"\n    if n == 1:\n        return 2\n    if n == 2:\n        return 3\n    \n    dp = [0] * (n+1)\n    dp[1] = 2\n    dp[2] = 3\n    \n    for i in range(3, n+1):\n        dp[i] = dp[i-1] + dp[i-2]\n    \n    return dp[n]\n\ndef g():\n    n = 4\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 476,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, check if there exists two numbers in the list whose sum equals the target.\n    Return True if such pair exists, False otherwise.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(target: int):\n    \"\"\"\n    Generate a sorted list of integers where there exists two numbers whose sum equals the target.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7]\n\nassert f(g(10), 11)\n",
        "idx_generation": 294,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a given number is a perfect number.\"\"\"\n    def get_divisors(num):\n        divisors = []\n        for i in range(1, num):\n            if num % i == 0:\n                divisors.append(i)\n        return divisors\n\n    divisors = get_divisors(n)\n    if sum(divisors) == n:\n        return True\n    return False\n\ndef g():\n    return 6\n\nassert f(g())\n",
        "idx_generation": 357,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of ways to reach the nth step in a staircase, where you can either take one step or two steps at a time.\"\"\"\n    if n <= 1:\n        return 1\n    dp = [0] * (n+1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n+1):\n        dp[i] = dp[i-1] + dp[i-2]\n    return dp[n]\n\ndef g():\n    return 5\n\nassert f(g()) == 8\n",
        "idx_generation": 478,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Determine if there exists a pair of numbers in the given list that sum up to the target value.\"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    nums = [2, 4, 6, 8, 10]\n    target = 12\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 296,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, check if it is a valid mountain array.\n    A mountain array is defined as an array that:\n    - Has at least 3 elements\n    - The elements are in increasing order up to a peak\n    - The elements are in decreasing order after the peak\n    Return True if the given array is a mountain array, False otherwise.\n    \"\"\"\n    n = len(nums)\n    if n < 3:\n        return False\n    \n    i = 0\n    while i < n-1 and nums[i] < nums[i+1]:\n        i += 1\n    \n    if i == 0 or i == n-1:\n        return False\n    \n    while i < n-1 and nums[i] > nums[i+1]:\n        i += 1\n    \n    return i == n-1\n\ndef g():\n    return [1, 3, 2]\n\nassert f(g())\n",
        "idx_generation": 358,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, nums: List[int]) -> bool:\n    \"\"\"\n    Given a target number n and a list of positive integers, find if it is possible to select a subset of numbers\n    that add up to the target number. Each number in the list can only be used once.\n    Return True if such subset exists, otherwise return False.\n    \"\"\"\n    nums.sort(reverse=True)  # Sort the numbers in descending order\n    return can_make_sum(n, nums, 0)\n\ndef can_make_sum(target, nums, index):\n    if target == 0:\n        return True\n    if index >= len(nums) or target < 0:\n        return False\n    if can_make_sum(target - nums[index], nums, index + 1):\n        return True\n    return can_make_sum(target, nums, index + 1)\n\ndef g():\n    return 10, [1, 3, 5, 7]\n\nassert f(*g())\n\n",
        "idx_generation": 480,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, find the median of the list.\n    The median is the middle value of a sorted list. If the list has an even number of elements, the median is the average of the two middle values.\n    Return the median value(s) as a list.\n    Sample input:\n    nums = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]\n    Sample output:\n    [5, 6]\"\"\"\n    nums.sort()\n    n = len(nums)\n    if n % 2 == 0:\n        return [nums[n//2-1], nums[n//2]]\n    else:\n        return [nums[n//2]]\n\ndef g():\n    return [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]\n\nassert f(g()) == [5, 6]\n\n",
        "idx_generation": 296,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, find if there are three distinct elements in the list whose sum is equal to the target.\n    Return True if such elements exist, False otherwise.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if arr[i] + arr[j] + arr[k] == target:\n                    return True\n    return False\n\ndef g(target: int):\n    arr = [1, 2, 3, 4, 5]\n    return arr, target\n\nassert f(*g(9))\n",
        "idx_generation": 359,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Given a list of integers nums and a target integer k, determine if it is possible to choose a non-empty subset of nums such that the sum of the subset is equal to k.\n    \"\"\"\n    def helper(nums, k, i):\n        if k == 0:\n            return True\n        if k < 0 or i >= len(nums):\n            return False\n        return helper(nums, k - nums[i], i + 1) or helper(nums, k, i + 1)\n    return helper(nums, k, 0)\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5]\n\nassert f(g(), 9)\n",
        "idx_generation": 481,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\n    Return True if such a pair exists, otherwise return False.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 297,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of integers is a valid mountain sequence.\"\"\"\n    n = len(nums)\n    if n < 3:\n        return False\n\n    i = 0\n    while i < n - 1 and nums[i] < nums[i + 1]:\n        i += 1\n\n    if i == 0 or i == n - 1:\n        return False\n\n    while i < n - 1 and nums[i] > nums[i + 1]:\n        i += 1\n\n    return i == n - 1\n\ndef g():\n    return [1, 3, 2]\n\nassert f(g())\n",
        "idx_generation": 361,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of positive integers, find the maximum sum of a subarray.\n    The subarray must have at least one element.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g(nums: List[int]) -> int:\n    \"\"\"\n    Find the maximum sum of a subarray in a list of positive integers.\n    \"\"\"\n    max_sum = 0\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(0, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\nassert f([1, -2, 3, 4, -1, 2, 1, -5, 4]) == g([1, -2, 3, 4, -1, 2, 1, -5, 4])\n",
        "idx_generation": 483,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers 'nums' and a target number,\n    find the index of the target number in the list using binary search.\n    If the target number is not in the list, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    return [1, 3, 5, 7, 9, 11], 7\n\nassert f(*g()) == 3\n",
        "idx_generation": 300,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the sum of all the elements in the given grid.\"\"\"\n    total = 0\n    for row in grid:\n        for num in row:\n            total += num\n    return total\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 45\n",
        "idx_generation": 363,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a non-empty subarray.\n    Return the maximum sum.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef g():\n    return [1, -2, 3, -4, 5, -6, 7, -8, 9]\n\nassert f(g()) == 9\n",
        "idx_generation": 484,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine if a given number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return (n & (n - 1)) == 0\n\ndef g():\n    return 16\n\nassert f(g())\n",
        "idx_generation": 301,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Count the number of ways to tile the floor of size 2 x n using 1 x 2 tiles and 2 x 1 tiles.\"\"\"\n    if n <= 2:\n        return n\n    a, b = 1, 2\n    for _ in range(3, n+1):\n        a, b = b, a + b\n    return b\ndef g(n=4):\n    \"\"\"Generate an integer n, where n represents the size of the floor.\"\"\"\n    return n\n\nassert f(g()) == 5\n",
        "idx_generation": 365,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers 'arr' and a target value 'target',\n    determine if it is possible to select a subset of the list such that\n    the sum of the subset is equal to the target value.\n    Return True if it is possible, False otherwise.\n    \"\"\"\n    n = len(arr)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j < arr[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n\n    return dp[n][target]\n\ndef g() -> List[int]:\n    return [2, 4, 6, 8, 10], 16\n\nassert f(*g()) == True\n",
        "idx_generation": 487,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"Given a grid of integers, rotate it 90 degrees clockwise.\"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    rotated_grid = [[0] * m for _ in range(n)]\n\n    for i in range(m):\n        for j in range(n):\n            rotated_grid[j][m - i - 1] = grid[i][j]\n\n    return rotated_grid\n\ndef g():\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\nassert f(g()) == [[7, 4, 1],\n                  [8, 5, 2],\n                  [9, 6, 3]]\n",
        "idx_generation": 301,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum subarray sum.\n    A subarray is a contiguous part of the array.\n    Return the sum of the maximum subarray.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 375,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], target: str) -> bool:\n    \"\"\"Check if it is possible to construct the target string using the given words.\n    Each word can be used only once and the order of concatenation matters.\n    \"\"\"\n    def dp(i, curr):\n        if curr == target:\n            return True\n        \n        if i == len(words):\n            return False\n        \n        if (i, curr) in memo:\n            return memo[(i, curr)]\n        \n        if curr + words[i] == target:\n            return True\n        \n        if curr + words[i] in target:\n            if dp(i + 1, curr + words[i]) or dp(i + 1, curr):\n                memo[(i, curr)] = True\n                return True\n        \n        if dp(i + 1, curr):\n            memo[(i, curr)] = True\n            return True\n        \n        memo[(i, curr)] = False\n        return False\n    \n    memo = {}\n    return dp(0, '')\n\ndef g():\n    \"\"\"Generate a list of words.\"\"\"\n    return ['apple', 'banana', 'cherry', 'date', 'elderberry', 'fig', 'grape', 'honeydew', 'kiwi', 'lemon']\n\nassert f(g(), 'applebananafig') == True\n",
        "idx_generation": 489,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers in ascending order, and a target value, determine if there are two numbers in the list\n    that add up to the target value. You may assume that each input would have exactly one solution.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        current_sum = arr[left] + arr[right]\n        \n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 13\n\nassert f(*g()) == True\n",
        "idx_generation": 301,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the sum of all positive integers less than n that are divisible by 3 or 5.\n    For example, for n = 10, the sum would be 3 + 5 + 6 + 9 = 23.\"\"\"\n    total_sum = 0\n    for i in range(n):\n        if i % 3 == 0 or i % 5 == 0:\n            total_sum += i\n    return total_sum\n\ndef g(n: int) -> int:\n    return f(n)\n\nn = 20\nassert f(n) == g(n)\n",
        "idx_generation": 375,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, return True if there exists a subarray of length 3 with the sum of its elements equal to 0, and False otherwise.\n\n    Example:\n    nums = [1, -2, 1, 0, 5]\n    Output: True\n    Explanation: The subarray [1, -2, 1] has a sum of 0.\n\n    Note:\n    The length of the given array is at most 1000.\n    -10^7 <= nums[i] <= 10^7\n    \"\"\"\n    n = len(nums)\n    for i in range(n-2):\n        for j in range(i+1, n-1):\n            for k in range(j+1, n):\n                if nums[i] + nums[j] + nums[k] == 0:\n                    return True\n    return False\n\ndef g():\n    return [1, -2, 1, 0, 5]\n\nassert f(g())\n",
        "idx_generation": 490,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the array that sum up to the target.\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr: List[int], target: int):\n    return arr, target\n\nassert f(*g([5, 3, 9, 2, 8, 1, 7], 10))\n",
        "idx_generation": 302,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, return a new list with all negative numbers removed, and all positive numbers\n    multiplied by 2.\"\"\"\n    return [num * 2 for num in nums if num > 0]\n\ndef g():\n    return [-3, -2, -1, 0, 1, 2, 3, 4, 5]\n\nassert f(g()) == [2, 4, 6, 8, 10]\n",
        "idx_generation": 375,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, calculate the number of unique binary search trees that can be constructed with nodes numbered from 1 to n.\"\"\"\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        for j in range(1, i + 1):\n            dp[i] += dp[j - 1] * dp[i - j]\n\n    return dp[n]\n\ndef g():\n    return 5\n\nassert f(g()) == 42\n",
        "idx_generation": 491,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there exists two numbers in the list such that their sum is equal to the target.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 8\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 304,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there are three numbers in the given list that sum up to the target value.\"\"\"\n    n = len(nums)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if nums[i] + nums[j] + nums[k] == target:\n                    return True\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 10\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 375,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Find a subarray in the given array that sums up to the target value.\"\"\"\n    n = len(arr)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j < arr[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n    return dp[n][target]\n    \ndef g(arr: List[int], target: int):\n    n = len(arr)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j < arr[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n    subarray = []\n    i, j = n, target\n    while i > 0 and j > 0:\n        if dp[i][j] != dp[i - 1][j]:\n            subarray.append(arr[i - 1])\n            j -= arr[i - 1]\n        i -= 1\n    return subarray[::-1]\n\nassert f(g([1, 2, 3, 4, 5], 9), 9)\n",
        "idx_generation": 491,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if the target is present in the list using binary search.\n    Return True if the target is found, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef g():\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    arr = [1, 3, 5, 7, 9, 11, 13, 15]\n    target = 7\n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 305,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start='A', end='D') -> bool:\n    \"\"\"Given a directed graph represented as an adjacency list, determine if there exists a path from start to end.\n    Return True if a path exists, otherwise return False.\n\n    Sample input:\n    graph = {'A': ['B', 'C'],\n             'B': ['C', 'D'],\n             'C': ['D'],\n             'D': []}\n    start = 'A'\n    end = 'D'\n    Sample output:\n    True\n    \"\"\"\n    visited = set()\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n        visited.add(node)\n\n        if node == end:\n            return True\n\n        for neighbor in graph.get(node, []):\n            if neighbor not in visited:\n                stack.append(neighbor)\n\n    return False\n\ndef g():\n    graph = {'A': ['B', 'C'],\n             'B': ['C', 'D'],\n             'C': ['D'],\n             'D': []}\n    return graph\n\nassert f(g())\n",
        "idx_generation": 378,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there exists a subset of the list that sums up to the target.\n    Return True if such a subset exists, otherwise return False.\n    \"\"\"\n    def subset_sum(nums, target, n):\n        if target == 0:\n            return True\n        if n == 0:\n            return False\n        if nums[n - 1] > target:\n            return subset_sum(nums, target, n - 1)\n        return subset_sum(nums, target, n - 1) or subset_sum(nums, target - nums[n - 1], n - 1)\n\n    return subset_sum(nums, target, len(nums))\n\ndef g():\n    nums = [1, 3, 5, 7, 9]\n    target = 12\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 495,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Find the index of the target number in a sorted list of numbers.\n    If the target number is not found, return -1.\"\"\"\n    lo, hi = 0, len(nums) - 1\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            lo = mid + 1\n        else:\n            hi = mid - 1\n    return -1\n\ndef g():\n    nums = [1, 3, 5, 7, 9, 11, 13]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 3\n",
        "idx_generation": 305,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string s, determine if it can be rearranged into a palindrome.\n    Return True if it can be rearranged into a palindrome, otherwise return False.\n\n    Sample input:\n    s = 'aabbc'\n    Sample output:\n    True\n    \"\"\"\n    char_counts = {}\n\n    for char in s:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    odd_count = 0\n\n    for count in char_counts.values():\n        if count % 2 != 0:\n            odd_count += 1\n\n    return odd_count <= 1\n\ndef g():\n    return 'aabbc'\n\nassert f(g())\n",
        "idx_generation": 378,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers 'nums', find the maximum sum of a subarray within the list.\n    Use Kadane's algorithm to solve this problem.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 496,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of non-negative integers, find the minimum sum path from the top left corner to the bottom right corner.\n    Return the minimum sum.\"\"\"\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[float('inf')] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(rows):\n        for j in range(cols):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j])\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j])\n    \n    return dp[rows-1][cols-1]\n\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 308,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of two distinct numbers in the list.\n    Return the maximum product.\n    \"\"\"\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n    return max_product\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g()) == 72\n",
        "idx_generation": 380,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a 2D grid of integers, find the length of the longest increasing path.\n    A path is considered increasing if each cell in the path is greater than the previous cell.\n    Example:\n    grid = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n    The longest increasing path is [1, 2, 6, 9].\n    Therefore, the answer is 4.\n    \"\"\"\n    if not grid:\n        return 0\n\n    rows, cols = len(grid), len(grid[0])\n    memo = [[0] * cols for _ in range(rows)]\n    longest_path = 0\n\n    def dfs(row, col):\n        if memo[row][col] != 0:\n            return memo[row][col]\n\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        for dx, dy in directions:\n            new_row, new_col = row + dx, col + dy\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] > grid[row][col]:\n                memo[row][col] = max(memo[row][col], dfs(new_row, new_col))\n        memo[row][col] += 1\n        return memo[row][col]\n\n    for row in range(rows):\n        for col in range(cols):\n            longest_path = max(longest_path, dfs(row, col))\n\n    return longest_path\n\ndef g():\n    return [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n\nassert f(g()) == 4\n",
        "idx_generation": 497,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers 'nums' and a target number 'target',\n    find the index of the first occurrence of the target number in the list.\n    If the target number is not found, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g():\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    nums = [2, 4, 6, 8, 10]\n    target = 6\n    \n    return nums, target\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 309,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]], target=10) -> bool:\n    \"\"\"Check if the target number exists in the matrix by searching row-wise and column-wise.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    for i in range(rows):\n        if target in matrix[i]:\n            return True\n    for j in range(cols):\n        if target in [matrix[i][j] for i in range(rows)]:\n            return True\n    return False\ndef g(rows=3, cols=4, target=10):\n    matrix = [[i * cols + j for j in range(cols)] for i in range(rows)]\n    return matrix\nassert f(g())\n",
        "idx_generation": 380,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers 'nums' and a target value 'target',\n    determine if there are two numbers in 'nums' that sum up to 'target'.\n    Return True if such pair exists, False otherwise.\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    The pair (1, 5) sums up to 6, so the answer is True.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5], 6\n\nassert f(*g())\n",
        "idx_generation": 310,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, target_sum: int) -> bool:\n    \"\"\"Find n numbers such that the sum of their squares is equal to the target sum.\"\"\"\n    return sum(i**2 for i in range(1, n+1)) == target_sum\ndef g(target_sum: int):\n    max_n = int(target_sum ** 0.5) + 1\n    for n in range(1, max_n):\n        if f(n, target_sum):\n            return n\n    return -1\nassert f(g(target_sum=55), target_sum=55)\n",
        "idx_generation": 381,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target number, determine if there are two numbers in the list that add up to the target.\"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    return arr, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 311,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a given number is a prime number.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    n = 23\n    return n\n\nassert f(g())\n",
        "idx_generation": 382,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers, check if there exists a pair of numbers in the array whose sum is equal to the target number.\n    Return True if such a pair exists, otherwise return False.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [-2, 0, 3, 5, 7, 9, 12, 15, 18]\n\nassert f(g(), 14)\n",
        "idx_generation": 314,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Given a matrix of m x n elements, return all elements of the matrix in spiral order.\"\"\"\n    spiral_order = []\n    if not matrix:\n        return spiral_order\n    top = 0\n    bottom = len(matrix) - 1\n    left = 0\n    right = len(matrix[0]) - 1\n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            spiral_order.append(matrix[top][i])\n        top += 1\n        for i in range(top, bottom + 1):\n            spiral_order.append(matrix[i][right])\n        right -= 1\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                spiral_order.append(matrix[bottom][i])\n            bottom -= 1\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                spiral_order.append(matrix[i][left])\n            left += 1\n    return spiral_order\n\ndef g(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"Return the matrix of integers\"\"\"\n    return matrix\n\nassert f(g(matrix=[[1,2,3],[4,5,6],[7,8,9]])) == [1,2,3,6,9,8,7,4,5]\n",
        "idx_generation": 385,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(l: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, find if there exists two numbers in the list whose sum is equal to the given target.\"\"\"\n    left = 0\n    right = len(l) - 1\n    while left < right:\n        current_sum = l[left] + l[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(target: int):\n    return [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25]  # Sorted list\n\nassert f(g(20), 14)\n",
        "idx_generation": 315,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the sum of all prime numbers up to the given number.\n    Return the sum of primes.\n    Sample input:\n    10\n    Sample output:\n    17\"\"\"\n    primes = []\n    for num in range(2, n+1):\n        is_prime = True\n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(num)\n    return sum(primes)\n\ndef g():\n    return 10\n\nassert f(g()) == 17\n\n",
        "idx_generation": 387,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, sort the list in non-decreasing order using the bubble sort algorithm.\n    Example:\n    Input: [5, 2, 8, 12, 1]\n    Output: [1, 2, 5, 8, 12]\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    return nums\n\ndef g():\n    nums = [5, 2, 8, 12, 1]\n    return nums\n\nassert f(g()) == [1, 2, 5, 8, 12]\n",
        "idx_generation": 315,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer, find the sum of all the positive integers less than or equal to the given integer that are divisible by either 3 or 5.\n    Return the sum.\n    \"\"\"\n    sum = 0\n\n    for i in range(1, n + 1):\n        if i % 3 == 0 or i % 5 == 0:\n            sum += i\n\n    return sum\n\ndef g():\n    return 100\n\nassert f(g()) == 2418\n\n",
        "idx_generation": 392,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, use binary search to determine if a target number is present in the list.\n    Return True if the target number is found, False otherwise.\n    \"\"\"\n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return False\n\ndef g():\n    arr = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n    target = 12\n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 316,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if a matrix is symmetric along its main diagonal.\"\"\"\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i+1, n):\n            if matrix[i][j] != matrix[j][i]:\n                return False\n    return True\n\ndef g(matrix: List[List[int]]):\n    \"\"\"Generate a symmetric matrix along its main diagonal.\"\"\"\n    n = len(matrix)\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] = 1\n            else:\n                matrix[i][j] = 0\n    return matrix\n\nassert f(g([[1, 0, 0], [0, 1, 0], [0, 0, 1]])) == True\n",
        "idx_generation": 394,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and a target number k, find all pairs of distinct elements whose sum is equal to k.\n    The pairs should be sorted in ascending order of their first element. If there are multiple pairs with the same\n    first element, sort them in ascending order of their second element.\n    Sample Input:\n    nums = [1, 5, 3, 2, 4]\n    k = 6\n    Sample Output:\n    [[1, 5], [2, 4]]\n    Explanation:\n    There are two pairs whose sum is 6: (1, 5) and (2, 4).\n    \"\"\"\n    nums.sort()\n    pairs = []\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        if nums[left] + nums[right] == k:\n            pairs.append([nums[left], nums[right]])\n            left += 1\n            right -= 1\n        elif nums[left] + nums[right] < k:\n            left += 1\n        else:\n            right -= 1\n    \n    return pairs\n\ndef g(nums: List[int], k: int):\n    return nums, k\n\nassert f(*g([1, 5, 3, 2, 4], 6)) == [[1, 5], [2, 4]]\n",
        "idx_generation": 317,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum subarray sum in the given list of numbers.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 396,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Check if there exists a pair of elements in the given array that sums up to the target value.\n    Return True if such pair exists, False otherwise.\n    \"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        \n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    \"\"\"\n    Generate an array of integers and a target value.\n    The array contains random integers and the target value is the sum of two elements in the array.\n    \"\"\"\n    arr = [1, 5, 2, 8, 4, 9, 3]\n    target = 7\n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 317,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given an m x n matrix, determine if it is a Toeplitz matrix.\n    A Toeplitz matrix is one where every diagonal from top-left to bottom-right has the same elements.\"\"\"\n    m, n = len(matrix), len(matrix[0])\n    for i in range(m-1):\n        for j in range(n-1):\n            if matrix[i][j] != matrix[i+1][j+1]:\n                return False\n    return True\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a matrix of integers.\"\"\"\n    matrix = [[1, 2, 3, 4],\n              [5, 1, 2, 3],\n              [6, 5, 1, 2]]\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 396,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers and a target value, find two numbers that sum up to the target value.\"\"\"\n    num_dict = {}\n    for index, num in enumerate(nums):\n        if target - num in num_dict:\n            return [num_dict[target - num], index]\n        num_dict[num] = index\n    return []\n\ndef g():\n    \"\"\"Generate a list of integers and a target value such that there exist two numbers that sum up to the target value.\"\"\"\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 320,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, return a new list where each element is the product of all the numbers in the original list except the one at that index.\"\"\"\n    product = 1\n    result = []\n    for num in nums:\n        product *= num\n    for num in nums:\n        result.append(product // num)\n    return result\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == [120, 60, 40, 30, 24]\n",
        "idx_generation": 400,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport random\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers arr and a target integer, determine if there exists a subarray of arr that sums up to the target.\"\"\"\n    prefix_sums = []\n    curr_sum = 0\n    for num in arr:\n        curr_sum += num\n        prefix_sums.append(curr_sum)\n    \n    for i in range(len(arr)):\n        for j in range(i, len(arr)):\n            subarray_sum = prefix_sums[j] - prefix_sums[i] + arr[i]\n            if subarray_sum == target:\n                return True\n    return False\n\ndef g(arr=[1, 2, 3, 4, 5], target=9):\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 320,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of numbers is a palindrome\"\"\"\n    return nums == nums[::-1]\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"Reverse the given list of numbers\"\"\"\n    return nums[::-1]\n\nassert f(g([1, 2, 3, 4, 5, 4, 3, 2, 1])) == True\n",
        "idx_generation": 401,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, check if there are two numbers that sum up to the target value.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(target: int) -> List[int]:\n    \"\"\"Generate a sorted list of integers.\"\"\"\n    return list(range(1, target+1))\n\nassert f(g(10), 9)\n",
        "idx_generation": 321,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Determine if there exists a subarray in the given list where the sum of all elements is a perfect square\"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(i, n):\n            subarray_sum = sum(nums[i:j+1])\n            if subarray_sum > 0 and int(subarray_sum**0.5)**2 == subarray_sum:\n                return True\n    return False\n\ndef g() -> List[int]:\n    \"\"\"Generate a list of random integers\"\"\"\n    import random\n    return [random.randint(-100, 100) for _ in range(10)]\n\nassert f(g())\n",
        "idx_generation": 402,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Sort the given list of integers in non-decreasing order\"\"\"\n    return sorted(nums)\n\ndef g():\n    nums = [9, 5, 2, 7, 1, 8, 4, 3, 6]\n    return nums\n\nassert f(g()) == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n",
        "idx_generation": 322,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"Given a matrix of integers, find the maximum element in each row and return them as a list.\"\"\"\n    result = []\n    for row in matrix:\n        max_element = max(row)\n        result.append(max_element)\n    return result\n\ndef g(matrix: List[List[int]]) -> List[int]:\n    return f(matrix)\n\nmatrix = [\n    [1, 4, 2],\n    [3, 9, 5],\n    [7, 6, 8]\n]\nassert f(matrix) == g(matrix)\n",
        "idx_generation": 402,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if it is sorted in non-decreasing order.\n    Return True if the list is sorted, otherwise return False.\n    Sample input:\n    nums = [1, 2, 3, 4, 5]\n    Sample output:\n    True\"\"\"\n    for i in range(1, len(nums)):\n        if nums[i] < nums[i-1]:\n            return False\n    return True\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == True\n",
        "idx_generation": 323,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the sum of all the even numbers up to the given number.\"\"\"\n    return sum([i for i in range(1, n+1) if i % 2 == 0])\n\ndef g():\n    n = 10\n    return n\n\nassert f(g()) == 30\n",
        "idx_generation": 403,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there are two numbers in the array that sum up to the target value.\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(arr=[1, 4, 6, 2, 9, 3], target=10):\n    \"\"\"Generate an array of integers and a target value.\"\"\"\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 324,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum sum of a subarray within the list.\n    Return the maximum sum.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    \n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 408,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"Check if there exists a subarray of length k in the given array that is sorted in non-decreasing order.\"\"\"\n    for i in range(len(arr) - k + 1):\n        if sorted(arr[i:i+k]) == arr[i:i+k]:\n            return True\n    return False\n\ndef g():\n    return ([5, 2, 7, 9, 1, 6], 3)\n\nassert f(*g()) == True\n",
        "idx_generation": 326,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if a string is a palindrome after removing all non-alphanumeric characters and ignoring case.\n    \"\"\"\n    import re\n    s = re.sub(r'\\W+', '', s.lower())\n    return s == s[::-1]\n\ndef g():\n    \"\"\"\n    Generate a random palindrome string with non-alphanumeric characters.\n    \"\"\"\n    import random\n    import string\n    letters = random.choices(string.ascii_letters + string.digits + string.punctuation, k=10)\n    s = ''.join(letters)\n    return s + s[::-1]\n\nassert f(g())\n",
        "idx_generation": 409,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers nums, find two numbers such that they add up to a specific target.\n    Return the indices of the two numbers in the input list.\n    - nums: a list of sorted integers\n    - target: the target sum\n    - return: a list of two indices\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g():\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 326,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if n is a prime number.\"\"\"\n    if n <= 1:\n        return False\n\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n\n    return True\n\ndef g(n=17):\n    \"\"\"Generate the next prime number after n.\"\"\"\n    i = n + 1\n    while not f(i):\n        i += 1\n\n    return i\n\nassert f(g())\n",
        "idx_generation": 410,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers 'arr' and a target integer 'target',\n    determine if there are two numbers in 'arr' whose sum is equal to 'target'.\n    Return True if such numbers exist, False otherwise.\n    Example:\n    arr = [2, 4, 6, 8, 10]\n    target = 12\n    The pair (2, 10) has a sum equal to 12, therefore the answer is True.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [2, 4, 6, 8, 10], 12\n\nassert f(*g())\n",
        "idx_generation": 327,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the sum of all numbers in the grid.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    total_sum = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            total_sum += grid[i][j]\n\n    return total_sum\n\ndef g(grid: List[List[int]]):\n    return grid\n\nassert f(g([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) == 45\n",
        "idx_generation": 412,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of integers in the given list whose sum is equal to the target value.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 328,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all odd numbers from 1 to n (inclusive).\n    \"\"\"\n    return sum([i for i in range(1, n+1) if i % 2 != 0])\n\ndef g():\n    return 10\n\nassert f(g()) == 25\n\n",
        "idx_generation": 412,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of integers is a permutation of the numbers from 1 to n.\"\"\"\n    nums.sort()\n    for i in range(len(nums)):\n        if nums[i] != i + 1:\n            return False\n    return True\n\ndef g():\n    nums = [4, 3, 1, 2]\n    return nums\n\nassert f(g())\n",
        "idx_generation": 328,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if the given matrix is a magic square.\"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n    for i in range(n):\n        row_sum = sum(matrix[i])\n        col_sum = sum(matrix[j][i] for j in range(n))\n        if row_sum != target_sum or col_sum != target_sum:\n            return False\n    diag_sum = sum(matrix[i][i] for i in range(n))\n    anti_diag_sum = sum(matrix[i][n-i-1] for i in range(n))\n    if diag_sum != target_sum or anti_diag_sum != target_sum:\n        return False\n    return True\n\ndef g():\n    \"\"\"Generate a 3x3 magic square.\"\"\"\n    return [[2, 7, 6],\n            [9, 5, 1],\n            [4, 3, 8]]\n\nassert f(g())\n",
        "idx_generation": 416,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, find if there exist two numbers in the list such that their XOR is equal to the target.\n    Return True if such pair of numbers exist, otherwise return False.\n    Sample input:\n    [1, 2, 3, 4, 5, 6], 7\n    Sample output:\n    True\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        xor = arr[left] ^ arr[right]\n        if xor == target:\n            return True\n        elif xor < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6], 7\n\nassert f(*g()) == True\n\n",
        "idx_generation": 328,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, rotate the matrix 90 degrees clockwise.\n    Return the rotated matrix.\n    \"\"\"\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n    return matrix\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a random matrix of integers.\n    \"\"\"\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 419,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of integers is sorted in non-decreasing order\"\"\"\n    return nums == sorted(nums)\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g())\n",
        "idx_generation": 330,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import Union\n\ndef f(n: int) -> Union[str, int]:\n    \"\"\"\n    Given an integer n, return the corresponding string representation of the number.\n    However, if n is divisible by 3, return \"Fizz\", if n is divisible by 5, return \"Buzz\",\n    and if n is divisible by both 3 and 5, return \"FizzBuzz\".\n    \n    Example:\n    Input: n = 15\n    Output: \"FizzBuzz\"\n    \"\"\"\n    if n % 3 == 0 and n % 5 == 0:\n        return \"FizzBuzz\"\n    elif n % 3 == 0:\n        return \"Fizz\"\n    elif n % 5 == 0:\n        return \"Buzz\"\n    else:\n        return n\n\ndef g(n: int) -> Union[str, int]:\n    \"\"\"\n    Return the corresponding string representation of a given number.\n    \"\"\"\n    if n % 3 == 0 and n % 5 == 0:\n        return \"FizzBuzz\"\n    elif n % 3 == 0:\n        return \"Fizz\"\n    elif n % 5 == 0:\n        return \"Buzz\"\n    else:\n        return n\n\nassert f(15) == g(15)\n",
        "idx_generation": 422,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers 'nums', determine if there exists three distinct indices i, j, k\n    such that nums[i] + nums[j] + nums[k] = 0. Return True if such indices exist, False otherwise.\n    \"\"\"\n    n = len(nums)\n    nums.sort()\n    for i in range(n - 2):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        left = i + 1\n        right = n - 1\n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n            if total == 0:\n                return True\n            elif total < 0:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers that contains three distinct numbers whose sum is equal to zero.\n    \"\"\"\n    return [1, -2, 3, -4, 5, -6]\n\nassert f(g()) == True\n",
        "idx_generation": 332,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest\n    sum and return its sum.\n    Sample Input:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Sample Output:\n    6\n    Explanation:\n    The contiguous subarray [4, -1, 2, 1] has the largest sum = 6.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(current_sum + num, num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g(nums: List[int]) -> int:\n    \"\"\"Find the sum of the contiguous subarray with the largest sum in a given integer array.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(current_sum + num, num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\nassert f([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == g([-2, 1, -3, 4, -1, 2, 1, -5, 4])\n",
        "idx_generation": 422,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, find if there exists a subarray of length 3 that forms an arithmetic progression.\n    An arithmetic progression is a sequence in which the difference between consecutive elements is constant.\n    Return True if such subarray exists, False otherwise.\n    Example:\n    arr = [1, 4, 7, 10, 13]\n    The subarray [4, 7, 10] forms an arithmetic progression with a common difference of 3.\n    Therefore, the answer is True.\n    \"\"\"\n    for i in range(len(arr) - 2):\n        if arr[i + 1] - arr[i] == arr[i + 2] - arr[i + 1]:\n            return True\n    return False\n\ndef g():\n    return [1, 4, 7, 10, 13]\n\nassert f(g())\n",
        "idx_generation": 333,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two numbers in the list.\n    \"\"\"\n    max_product = float('-inf')\n    n = len(nums)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_product = max(max_product, nums[i] * nums[j])\n\n    return max_product\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for testing the maximum product function.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 20\n\n",
        "idx_generation": 425,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there are two numbers in the list that sum up to the target.\n    Return True if such numbers exist, False otherwise.\n    Example input:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    Example output:\n    True\"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g(), 7)\n",
        "idx_generation": 333,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the product of all positive numbers in the list.\n    If there are no positive numbers, return -1.\n    \"\"\"\n    product = 1\n    has_positive = False\n    for num in nums:\n        if num > 0:\n            product *= num\n            has_positive = True\n    if has_positive:\n        return product\n    else:\n        return -1\n\ndef g(nums: List[int]) -> int:\n    \"\"\"\n    Find the product of all positive numbers in the given list.\n    If there are no positive numbers, return -1.\n    \"\"\"\n    product = 1\n    has_positive = False\n    for num in nums:\n        if num > 0:\n            product *= num\n            has_positive = True\n    if has_positive:\n        return product\n    else:\n        return -1\n\nassert f([-2, -1, 0, 1, 2, 3]) == g([-2, -1, 0, 1, 2, 3])\n",
        "idx_generation": 426,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of elements in the list that add up to the target value.\"\"\"\n    arr.sort()\n    left, right = 0, len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr=[2, 4, 6, 8, 10], target=12):\n    return arr, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 334,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Find the next permutation of the given list of integers in lexicographic order.\"\"\"\n    n = len(nums)\n    i = n - 2\n\n    # Find the first decreasing element from the right\n    while i >= 0 and nums[i] >= nums[i+1]:\n        i -= 1\n\n    if i >= 0:\n        j = n - 1\n        # Find the next greater element from the right\n        while nums[j] <= nums[i]:\n            j -= 1\n\n        # Swap the two elements\n        nums[i], nums[j] = nums[j], nums[i]\n\n    # Reverse the suffix\n    start = i + 1\n    end = n - 1\n    while start < end:\n        nums[start], nums[end] = nums[end], nums[start]\n        start += 1\n        end -= 1\n\n    return nums\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"Return the given list of integers.\"\"\"\n    return nums\n\nassert f(g([1, 2, 3])) == [1, 3, 2]\n",
        "idx_generation": 427,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if there exists a pair of numbers in the list whose sum is equal to the target.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    nums = [2, 4, 6, 8, 10]\n    target = 14\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 335,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Determine whether it is possible to rearrange the characters of the string s such that no two adjacent characters are the same, and the resulting string has at least k distinct characters.\"\"\"\n    freq = {}\n    for char in s:\n        freq[char] = freq.get(char, 0) + 1\n    max_freq = max(freq.values())\n    return (len(s) - max_freq) >= k\n\ndef g(s: str, k: int) -> bool:\n    return f(s, k)\n\ns = \"aabbcc\"\nk = 3\nassert f(s, k) == g(s, k)\n",
        "idx_generation": 429,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"Given a sorted array 'arr' in ascending order, and a target integer 'target',\n    find the index of the target using the Binary Search algorithm.\"\"\"\n    left, right = 0, len(arr)-1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g():\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g(), 4) == 3\n",
        "idx_generation": 336,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the number of subarrays whose sum is equal to the target.\n    Return the count of subarrays.\n    \"\"\"\n    prefix_sum = 0\n    count = 0\n    prefix_sum_counts = {0: 1}\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum - target in prefix_sum_counts:\n            count += prefix_sum_counts[prefix_sum - target]\n        if prefix_sum in prefix_sum_counts:\n            prefix_sum_counts[prefix_sum] += 1\n        else:\n            prefix_sum_counts[prefix_sum] = 1\n    return count\n\ndef g(nums=[1, 1, 1], target=2) -> Tuple[List[int], int]:\n    \"\"\"\n    Return the given list and target number.\n    \"\"\"\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 430,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if it is possible to find two numbers in the array that sum up to the target value.\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    arr = [1, 5, 3, 9, 2]\n    target = 8\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 337,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a prime number.\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n",
        "idx_generation": 434,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"Find the largest element in each row of a given matrix\"\"\"\n    result = []\n    for row in matrix:\n        max_element = float('-inf')\n        for num in row:\n            max_element = max(max_element, num)\n        result.append(max_element)\n    return result\n\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix\n\nassert f(g()) == [3, 6, 9]\n",
        "idx_generation": 337,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if the list is a valid arithmetic progression.\"\"\"\n    n = len(arr)\n    if n <= 2:\n        return True\n\n    diff = arr[1] - arr[0]\n    for i in range(2, n):\n        if arr[i] - arr[i-1] != diff:\n            return False\n\n    return True\n\ndef g() -> List[int]:\n    \"\"\"Generate a list of integers that forms a valid arithmetic progression.\"\"\"\n    import random\n    n = random.randint(3, 10)\n    start = random.randint(1, 10)\n    diff = random.randint(1, 5)\n    return [start + i*diff for i in range(n)]\n\nassert f(g())\n",
        "idx_generation": 437,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Sort a list of integers in ascending order.\"\"\"\n    return sorted(nums)\n\ndef g():\n    return [4, 2, 5, 1, 3]\n\nassert f(g()) == [1, 2, 3, 4, 5]\n",
        "idx_generation": 337,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(n: int) -> int:\n    \"\"\"Find the sum of all multiples of 3 or 5 below the given number n.\"\"\"\n    total = 0\n    for i in range(n):\n        if i % 3 == 0 or i % 5 == 0:\n            total += i\n    return total\n\ndef g():\n    return 100\n\nassert f(g()) == 2318\n",
        "idx_generation": 437,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers, find the index of the target element using binary search.\n    If the target is not found, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(nums: List[int] = [1, 3, 5, 7, 9, 11, 13], target: int = 7):\n    return nums, target\n\nassert f(*g()) == 3\n",
        "idx_generation": 338,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, find the sum of all positive integers less than n that are divisible by 3 or 5.\"\"\"\n    sum = 0\n    for i in range(n):\n        if i % 3 == 0 or i % 5 == 0:\n            sum += i\n    return sum\n\ndef g(n: int) -> int:\n    \"\"\"Returns the positive integer n\"\"\"\n    return n\n\nassert f(g(n=10)) == 23\n",
        "idx_generation": 443,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the largest sum of any contiguous subarray.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g(nums: List[int]) -> List[int]:\n    return nums\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nassert f(g(nums)) == 6\n",
        "idx_generation": 339,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"Given a matrix of integers, return the elements of the matrix in spiral order.\"\"\"\n    \n    if not matrix:\n        return []\n    \n    m, n = len(matrix), len(matrix[0])\n    top, bottom, left, right = 0, m-1, 0, n-1\n    spiral = []\n    \n    while top <= bottom and left <= right:\n        for i in range(left, right+1):\n            spiral.append(matrix[top][i])\n        top += 1\n        \n        for i in range(top, bottom+1):\n            spiral.append(matrix[i][right])\n        right -= 1\n        \n        if top <= bottom:\n            for i in range(right, left-1, -1):\n                spiral.append(matrix[bottom][i])\n            bottom -= 1\n        \n        if left <= right:\n            for i in range(bottom, top-1, -1):\n                spiral.append(matrix[i][left])\n            left += 1\n    \n    return spiral\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 444,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exist three numbers in the list whose sum is equal to the target.\"\"\"\n    \n    nums.sort()\n    \n    for i in range(len(nums) - 2):\n        left = i + 1\n        right = len(nums) - 1\n        \n        while left < right:\n            curr_sum = nums[i] + nums[left] + nums[right]\n            \n            if curr_sum == target:\n                return True\n            elif curr_sum < target:\n                left += 1\n            else:\n                right -= 1\n                \n    return False\n\ndef g(nums: List[int], target: int):\n    return nums, target\n\n# Example usage\nnums = [1, 2, 3, 4, 5, 6, 7]\ntarget = 12\n\nassert f(*g(nums, target))\n",
        "idx_generation": 341,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"Given a matrix of integers, return the elements in row-major order.\n    Row-major order means the elements are traversed row by row, starting from the top-left element.\"\"\"\n    result = []\n    for row in matrix:\n        result.extend(row)\n    return result\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n",
        "idx_generation": 446,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given an array of integers, find the length of the longest increasing subarray.\n    Return the length of the longest increasing subarray.\"\"\"\n    max_length = 1\n    curr_length = 1\n\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i-1]:\n            curr_length += 1\n            max_length = max(max_length, curr_length)\n        else:\n            curr_length = 1\n\n    return max_length\n\ndef g():\n    nums = [1, 2, 3, 2, 4, 5, 6, 7, 8]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 343,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of integers, check if it is a magic square.\n    A magic square is a square matrix where the sums of each row, each column, and both diagonals are the same.\n    Return True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check columns\n    for j in range(n):\n        column_sum = sum(matrix[i][j] for i in range(n))\n        if column_sum != target_sum:\n            return False\n    \n    # Check diagonals\n    diagonal_sum1 = sum(matrix[i][i] for i in range(n))\n    if diagonal_sum1 != target_sum:\n        return False\n    \n    diagonal_sum2 = sum(matrix[i][n-i-1] for i in range(n))\n    if diagonal_sum2 != target_sum:\n        return False\n    \n    return True\n\ndef g():\n    matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 447,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers in ascending order, determine if there are two numbers in the list that add up to the target number.\n    Return True if there are, False otherwise.\"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g() -> List[int]:\n    \"\"\"Generate a sorted list of integers in ascending order.\"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), 13) == True\n",
        "idx_generation": 344,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target integer k, find the kth missing positive integer in the list.\n\n    Example:\n    Input: nums = [2, 3, 4, 7, 11], k = 5\n    Output: 9\n    Explanation: The missing positive integers in the list are [1, 5, 6, 8, 9, 10, 12, ...].\n                 The 5th missing positive integer is 9.\n\n    \"\"\"\n\n    missing = []\n    num_set = set(nums)\n    i = 1\n\n    while len(missing) < k:\n        if i not in num_set:\n            missing.append(i)\n        i += 1\n\n    return missing[k-1]\n\ndef g():\n    nums = [2, 3, 4, 7, 11]\n    k = 5\n    return nums, k\n\nassert f(*g()) == 9\n",
        "idx_generation": 447,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a sorted list of integers, find two numbers that add up to the target.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [nums[left], nums[right]]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g(nums: List[int] = [2, 7, 11, 15], target: int = 9):\n    return (nums, target)\n\nassert f(*g()) == [2, 7]\n",
        "idx_generation": 344,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport re\n\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a valid password.\n    A valid password must satisfy the following conditions:\n    1. Have at least 8 characters.\n    2. Contain at least one uppercase letter.\n    3. Contain at least one lowercase letter.\n    4. Contain at least one digit.\n    5. Contain at least one special character, such as !@#$%^&*()-_=+[]{}|;:,.<>?\"\"\"\n    \n    # Check length\n    if len(s) < 8:\n        return False\n    \n    # Check uppercase letter\n    if not any(char.isupper() for char in s):\n        return False\n    \n    # Check lowercase letter\n    if not any(char.islower() for char in s):\n        return False\n    \n    # Check digit\n    if not any(char.isdigit() for char in s):\n        return False\n    \n    # Check special character\n    if not re.search(r'[!@#$%^&*()-_=+\\[\\]{}|;:,.<>?]', s):\n        return False\n    \n    return True\n\ndef g():\n    s = 'Password123!'\n    return s\n\nassert f(g())\n",
        "idx_generation": 449,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the number of pairs (a, b) such that a + b = target.\n    \"\"\"\n    count = 0\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            count += 1\n            left += 1\n            right -= 1\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return count\n\ndef g(nums=[1, 2, 3, 4, 5], target=6):\n    \"\"\"\n    Generate a sorted list of integers where the number of pairs (a, b) such that a + b = target is non-zero.\n    \"\"\"\n    return sorted(nums)\n\nassert f(g(), 6) > 0\n\n",
        "idx_generation": 345,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the sum of the maximum subarray in the given list.\n    A subarray is a contiguous subsequence of the array.\n    Sample Input:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Sample Output:\n    6\n    Explanation: The maximum subarray is [4, -1, 2, 1] with a sum of 6.\"\"\"\n    \n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]) -> List[int]:\n    \"\"\"Return the given list\"\"\"\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 449,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number k, determine if there exists a pair of numbers in the list\n    whose difference is equal to k. Return True if such a pair exists, False otherwise.\n    \"\"\"\n    arr.sort()\n    left, right = 0, 1\n    while right < len(arr):\n        diff = arr[right] - arr[left]\n        if diff == k:\n            return True\n        elif diff < k:\n            right += 1\n        else:\n            left += 1\n            if left == right:\n                right += 1\n    return False\n\ndef g(k: int) -> List[int]:\n    \"\"\"\n    Generate a list of integers that contains a pair whose difference is equal to the target number k.\n    \"\"\"\n    return [1, k+1]\n\nassert f(g(5), 5) == True\n",
        "idx_generation": 345,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the n-th Fibonacci number.\n    The Fibonacci sequence is defined as follows:\n    - The first two numbers are 0 and 1.\n    - Each subsequent number is the sum of the two preceding numbers.\n    \"\"\"\n    if n <= 1:\n        return n\n    else:\n        a, b = 0, 1\n        for _ in range(2, n+1):\n            a, b = b, a + b\n        return b\n\ndef g() -> int:\n    \"\"\"\n    Generate an integer n such that the n-th Fibonacci number is 55.\n    \"\"\"\n    return 10\n\nassert f(g()) == 55\n",
        "idx_generation": 449,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target=10) -> bool:\n    \"\"\"Find if there exists a pair of numbers in the given list that sum up to the target value\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(target=10):\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g())\n",
        "idx_generation": 346,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> bool:\n    \"\"\"\n    Given two integers 'n' and 'm', return True if 'n' is a multiple of 'm',\n    False otherwise.\n    \"\"\"\n    return n % m == 0\n\ndef g(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers 'n' and 'm', return the sum of 'n' and 'm'.\n    \"\"\"\n    return n + m\n\nassert f(g(10, 5), 5)\n",
        "idx_generation": 449,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Find the number of times the target element appears in the given list of numbers.\n    The list is sorted in ascending order.\n    Sample Input:\n    nums = [1, 2, 2, 3, 4, 4, 4, 5]\n    target = 4\n    Sample Output:\n    3\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            count = 1\n            i = mid - 1\n            while i >= 0 and nums[i] == target:\n                count += 1\n                i -= 1\n            i = mid + 1\n            while i < len(nums) and nums[i] == target:\n                count += 1\n                i += 1\n            return count\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return 0\n\ndef g(nums: List[int], target: int) -> Tuple[List[int], int]:\n    \"\"\"Return the list of numbers and the target element.\"\"\"\n    return nums, target\n\nassert f(*g(nums=[1, 2, 2, 3, 4, 4, 4, 5], target=4)) == 3\n",
        "idx_generation": 347,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, calculate the nth Fibonacci number.\n    The Fibonacci sequence starts with 0 and 1, and each subsequent number is the sum of the two preceding ones.\n    Sample input:\n    n = 6\n    Sample output:\n    8\"\"\"\n    fib = [0, 1]\n    for i in range(2, n+1):\n        fib.append(fib[i-1] + fib[i-2])\n    return fib[n]\n\ndef g():\n    n = 6\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 450,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, find if there exists two numbers in the list such that their sum equals to the target.\"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    nums = [-2, 1, 3, 5, 7, 9]\n    target = 10\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 348,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there exists a subarray (consecutive elements)\n    whose sum is equal to the target. Return True if such subarray exists, False otherwise.\n    \"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    \n    for num in nums:\n        prefix_sum += num\n        \n        if prefix_sum == target or prefix_sum - target in prefix_sums:\n            return True\n        \n        prefix_sums.add(prefix_sum)\n    \n    return False\n\ndef g():\n    return [3, 5, 2, -2, 4, 1, 8, -3]\n\nassert f(g(), 7) == True\n",
        "idx_generation": 456,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers 'nums' and a target integer 'target', \n    check if there exists a pair of integers in the list that sum up to the target.\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    \"\"\"\n    Generate a list of integers and a target integer.\n    \"\"\"\n    nums = [4, 2, 7, 9, 1, 5]\n    target = 10\n    \n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 348,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, find the spiral order of the matrix elements.\n    Return the elements in clockwise order starting from the top-left corner.\n    \"\"\"\n    if not matrix:\n        return []\n    \n    rows, cols = len(matrix), len(matrix[0])\n    top, bottom, left, right = 0, rows - 1, 0, cols - 1\n    direction = 0\n    spiral_order = []\n    \n    while top <= bottom and left <= right:\n        if direction == 0:\n            for col in range(left, right + 1):\n                spiral_order.append(matrix[top][col])\n            top += 1\n        elif direction == 1:\n            for row in range(top, bottom + 1):\n                spiral_order.append(matrix[row][right])\n            right -= 1\n        elif direction == 2:\n            for col in range(right, left - 1, -1):\n                spiral_order.append(matrix[bottom][col])\n            bottom -= 1\n        elif direction == 3:\n            for row in range(bottom, top - 1, -1):\n                spiral_order.append(matrix[row][left])\n            left += 1\n        \n        direction = (direction + 1) % 4\n    \n    return spiral_order\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 458,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"\n    Given a string s and an integer n, check if s is a palindrome of length n.\n    A palindrome is a string that remains the same when its characters are reversed.\n    \"\"\"\n    return s == s[::-1] and len(s) == n\n\ndef g(s: str, n: int):\n    return s[:n]\n\nassert f(g(\"racecar\", 7), 7)\n",
        "idx_generation": 349,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if a grid contains a valid Latin square, where each row and column contains unique integers from 1 to n.\"\"\"\n    n = len(grid)\n\n    # Check rows\n    for row in grid:\n        if len(set(row)) != n:\n            return False\n\n    # Check columns\n    for col in range(n):\n        if len(set(row[col] for row in grid)) != n:\n            return False\n\n    return True\n\ndef g():\n    return [[1, 2, 3], [2, 3, 1], [3, 1, 2]]\n\nassert f(g())\n",
        "idx_generation": 460,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, return a new list with only the unique elements in the original list.\"\"\"\n    unique_nums = []\n    for num in arr:\n        if num not in unique_nums:\n            unique_nums.append(num)\n    return unique_nums\n\ndef g():\n    return [2, 5, 3, 5, 7, 3, 8, 9, 2]\n\nassert f(g()) == [2, 5, 3, 7, 8, 9]\n",
        "idx_generation": 350,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Find the sum of all even numbers in the given list.\"\"\"\n    total = 0\n    for num in arr:\n        if num % 2 == 0:\n            total += num\n    return total\n\ndef g():\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return arr\n\nassert f(g()) == 30\n",
        "idx_generation": 461,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers 'nums' and a target number, determine if there are two numbers in the list that add up to the target.\n    Return True if such numbers exist, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        \n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    nums = [-2, 0, 3, 6, 8, 9]\n    target = 7\n    \n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 352,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[int]:\n    \"\"\"Generate the first n Fibonacci numbers and return them in a list.\"\"\"\n    fib = [0, 1]\n    if n <= 2:\n        return fib[:n]\n    for i in range(2, n):\n        fib.append(fib[i-1] + fib[i-2])\n    return fib\n\ndef g(n=5):\n    return n\n\nassert f(g()) == [0, 1, 1, 2, 3]\n",
        "idx_generation": 464,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers nums and a target value, find the index of the target value in the list using binary search. If the target value is not present, return -1.\"\"\"\n    left, right = 0, len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    nums = [2, 5, 7, 9, 11, 15]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 352,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"Given a matrix of integers, return the sum of each row in the matrix as a list.\"\"\"\n    row_sums = []\n    for row in matrix:\n        row_sum = sum(row)\n        row_sums.append(row_sum)\n    return row_sums\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a matrix of integers.\"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [6, 15, 24]\n",
        "idx_generation": 468,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a sorted list of integers nums and a target value, find the index of the target value in the list using interpolation search. If the target value is not present, return -1.\"\"\"\n    low, high = 0, len(nums) - 1\n\n    while low <= high and nums[low] <= target <= nums[high]:\n        pos = low + ((target - nums[low]) * (high - low)) // (nums[high] - nums[low])\n        if nums[pos] == target:\n            return pos\n        elif nums[pos] < target:\n            low = pos + 1\n        else:\n            high = pos - 1\n\n    return -1\n\ndef g():\n    nums = [2, 5, 7, 9, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == 3\n",
        "idx_generation": 352,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Generate a Pascal's triangle with n rows.\n    \"\"\"\n    triangle = []\n    \n    for i in range(n):\n        row = [1] * (i + 1)\n        \n        for j in range(1, i):\n            row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n        \n        triangle.append(row)\n    \n    return triangle\n\ndef g() -> int:\n    \"\"\"\n    Generate the number of rows n for Pascal's triangle.\n    \"\"\"\n    n = 5\n    return n\n\nassert f(g()) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n",
        "idx_generation": 474,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers and a target value, determine if there are two numbers in the array that add up to the target.\nSample Input:\narr = [1, 2, 3, 4, 5, 6, 7]\ntarget = 9\nSample Output:\nTrue\"\"\"\n    low = 0\n    high = len(arr) - 1\n    while low < high:\n        if arr[low] + arr[high] == target:\n            return True\n        elif arr[low] + arr[high] < target:\n            low += 1\n        else:\n            high -= 1\n    return False\n\ndef g(arr: List[int], target: int):\n    return arr, target\n\nassert f(*g([1, 2, 3, 4, 5, 6, 7], 9))\n",
        "idx_generation": 353,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Calculate the sum of all the numbers in the grid that are divisible by 3.\"\"\"\n    total = 0\n    for row in grid:\n        for num in row:\n            if num % 3 == 0:\n                total += num\n    return total\n\ndef g():\n    \"\"\"Generate a grid of numbers.\"\"\"\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return grid\n\nassert f(g()) == 18\n",
        "idx_generation": 477,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, find if there are two numbers that add up to the target value.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    return [-2, 1, 3, 5, 7, 9, 11, 13]\n\nassert f(g(), 10) == True\n",
        "idx_generation": 356,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum sum obtained by adding two adjacent elements.\n    Return the maximum sum.\n    \"\"\"\n\n    max_sum = float('-inf')\n    for i in range(len(nums) - 1):\n        current_sum = nums[i] + nums[i+1]\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g():\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g()) == 11\n",
        "idx_generation": 481,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers 'nums' and a target number, find the index of the target\n    using binary search. If the target is not found, return -1.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"Returns the list of integers and the target number\"\"\"\n    return nums, target\n\nassert f(*g(nums=[1, 2, 3, 4, 5], target=3)) == 2\n",
        "idx_generation": 357,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of numbers is a palindrome.\"\"\"\n    return nums == nums[::-1]\n\ndef g():\n    nums = [1, 2, 3, 2, 1]\n    return nums\n\nassert f(g())\n",
        "idx_generation": 483,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target number, find if there are two distinct elements in the list whose sum is equal to the target.\n    Return True if such elements exist, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(target: int):\n    nums = [1, 2, 3, 4, 5]\n    return nums, target\n\nassert f(*g(6))\n",
        "idx_generation": 358,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of integers, determine if it is a magic square.\n    A magic square is a square matrix in which the sums of the elements in each row,\n    each column, and both diagonals are the same.\n    Return True if it is a magic square, False otherwise.\n    Example:\n    matrix = [\n        [2, 7, 6],\n        [9, 5, 1],\n        [4, 3, 8]\n    ]\n    The sums of each row, column, and diagonal are all equal to 15,\n    so the output should be True.\n    \"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check columns\n    for j in range(n):\n        col_sum = sum(matrix[i][j] for i in range(n))\n        if col_sum != target_sum:\n            return False\n    \n    # Check diagonals\n    diagonal_sum1 = sum(matrix[i][i] for i in range(n))\n    diagonal_sum2 = sum(matrix[i][n-i-1] for i in range(n))\n    \n    if diagonal_sum1 != target_sum or diagonal_sum2 != target_sum:\n        return False\n    \n    return True\n\ndef g() -> List[List[int]]:\n    return [\n        [2, 7, 6],\n        [9, 5, 1],\n        [4, 3, 8]\n    ]\n\nassert f(g())\n",
        "idx_generation": 488,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Find the maximum number in the list that is less than or equal to the target.\"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    result = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] <= target:\n            result = nums[mid]\n            left = mid + 1\n        else:\n            right = mid - 1\n    return result\n\ndef g():\n    return [4, 10, 3, 8, 6, 2, 9]\n\nassert f(g(), 7) == 6\n",
        "idx_generation": 358,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, calculate the sum of all the numbers from 1 to n\n    that are divisible by either 3 or 5.\n    Return the sum of the divisible numbers.\n    Example:\n    n = 10\n    The numbers from 1 to 10 that are divisible by 3 or 5 are: 3, 5, 6, 9, 10.\n    The sum of these numbers is 3 + 5 + 6 + 9 + 10 = 33.\n    Therefore, the answer is 33.\n    \"\"\"\n    divisible_sum = 0\n    for num in range(1, n + 1):\n        if num % 3 == 0 or num % 5 == 0:\n            divisible_sum += num\n    return divisible_sum\n\ndef g():\n    return 10\n\nassert f(g()) == 33\n",
        "idx_generation": 488,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target value.\n    Sample input:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    Sample output:\n    True\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    return ([1, 2, 3, 4, 5], 7)\n\nassert f(*g())\n",
        "idx_generation": 358,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers 'nums' and an integer 'target',\n    find two numbers in the list that sum up to the target.\n    Return a list of indices of the two numbers.\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    The sum of the numbers at indices 0 and 1 is 2 + 7 = 9.\n    Therefore, the answer is [0, 1].\n    \"\"\"\n    num_set = set()\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_set:\n            return [nums.index(complement), i]\n        num_set.add(num)\n    return []\n\ndef g():\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 491,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int], target: int) -> bool:\n    \"\"\"\n    Determine if there exists a pair of numbers in the list that sum up to the target value.\n    \"\"\"\n    numbers.sort()\n    left, right = 0, len(numbers) - 1\n    while left < right:\n        current_sum = numbers[left] + numbers[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(numbers=[1, 2, 3, 4, 5], target=9):\n    \"\"\"\n    Generate a list of integers and a target value such that there exists a pair of numbers in the list that sum up to the target value.\n    \"\"\"\n    return numbers, target\n\nassert f(*g())\n",
        "idx_generation": 360,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Given an array of integers, return a new array where each element at index i is the product of all the numbers in the original array except the one at i.\n    Sample input:\n    arr = [1, 2, 3, 4, 5]\n    Sample output:\n    [120, 60, 40, 30, 24]\"\"\"\n    n = len(arr)\n    result = [1] * n\n    product = 1\n    for i in range(n):\n        result[i] *= product\n        product *= arr[i]\n    product = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= product\n        product *= arr[i]\n    return result\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [120, 60, 40, 30, 24]\n",
        "idx_generation": 494,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there are two numbers in the list that sum up to the target.\"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [2, 4, 6, 8, 10]\n\nassert f(g(), target=12)\n",
        "idx_generation": 360,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n    A subarray is defined as a contiguous subsequence of the original array.\n    Return the maximum sum.\n    \n    Sample Input:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    \n    Sample Output:\n    6\n    Explanation: The subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g() -> List[int]:\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 494,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Find the index of the target number in the given list using binary search.\"\"\"\n    left, right = 0, len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    return [-2, 0, 3, 5, 9, 12]\n\nassert f(g(), 9) == 4\n",
        "idx_generation": 361,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the sum of all numbers in the list that are divisible by 3 or 5.\"\"\"\n    sum = 0\n    for num in nums:\n        if num % 3 == 0 or num % 5 == 0:\n            sum += num\n    return sum\n\ndef g():\n    return ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],)\n\nassert f(*g()) == 33\n",
        "idx_generation": 495,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers and a target number, find a pair of numbers in the array\n    whose sum is equal to the target number. Return the pair of numbers.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return [arr[left], arr[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g(arr: List[int] = [1, 2, 3, 4, 5, 6, 7, 8, 9], target: int = 10) -> List[int]:\n    \"\"\"\n    Generate a sorted array of integers and a target number such that there exists a pair of numbers\n    in the array whose sum is equal to the target number.\n    \"\"\"\n    return arr, target\n\nassert f(g()[0], g()[1]) == [1, 9]\n",
        "idx_generation": 363,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers 'nums',\n    return a new list where each element is the product of all the elements in 'nums' except itself.\"\"\"\n    product = 1\n    for num in nums:\n        product *= num\n    return [product // num for num in nums]\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [120, 60, 40, 30, 24]\n",
        "idx_generation": 498,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"Sort the given list of words in lexicographic order and return the sorted list.\"\"\"\n    return sorted(words)\n\ndef g():\n    words = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"]\n    return words\n\nassert f(g()) == ['apple', 'banana', 'cherry', 'date', 'elderberry']\n",
        "idx_generation": 366,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[str]], target_word='python') -> bool:\n    \"\"\"Find the target_word in the grid by traversing horizontally, vertically, or diagonally.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == target_word[0]:\n                for dx, dy in [(1, 0), (0, 1), (1, 1), (-1, 1)]:\n                    word = ''\n                    x, y = i, j\n                    while 0 <= x < rows and 0 <= y < cols:\n                        word += grid[x][y]\n                        if word == target_word:\n                            return True\n                        x += dx\n                        y += dy\n    return False\ndef g(target_word='python'):\n    grid = [\n        ['p', 'y', 't', 'h', 'o', 'n'],\n        ['a', 'b', 'c', 'd', 'e', 'f'],\n        ['g', 'h', 'i', 'j', 'k', 'l'],\n        ['m', 'n', 'o', 'p', 'q', 'r'],\n        ['s', 't', 'u', 'v', 'w', 'x'],\n        ['y', 'z', 'a', 'b', 'c', 'd']\n    ]\n    return grid\nassert f(g())\n",
        "idx_generation": 499,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Find if there are two numbers in the given list that sum up to the target value.\n    Sample Input:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    Sample Output:\n    True\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        current_sum = arr[left] + arr[right]\n        \n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(arr=[1, 2, 3, 4, 5], target=7) -> List[int]:\n    \"\"\"Return the given list and target value\"\"\"\n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 370,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"Given a list of integers and a target integer, find the index of the target integer in the list using binary search.\n    If the target integer is not present in the list, return -1.\"\"\"\n    start = 0\n    end = len(arr) - 1\n\n    while start <= end:\n        mid = (start + end) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            start = mid + 1\n        else:\n            end = mid - 1\n\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Generate a sorted list of distinct integers and a target integer.\"\"\"\n    return [1, 2, 3, 4, 5], 3\n\nassert f(*g()) == 2\n",
        "idx_generation": 371,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers 'arr' and a target integer 'target',\n    return True if the target integer is present in the list, False otherwise.\n    Use binary search algorithm to solve the problem.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef g() -> List[int]:\n    arr = [1, 3, 5, 7, 9, 11, 13, 15]\n    target = 9\n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 373,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Find the index of the target value in the sorted list using binary search.\"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 6\n\nassert f(*g()) == 5\n",
        "idx_generation": 373,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the original list.\n    \"\"\"\n    complement_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complement_map:\n            return [complement_map[complement], i]\n        complement_map[num] = i\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return (nums, target)\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 374,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there exists two numbers in the list whose sum is equal to the target.\n    Return True if such numbers exist, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9], target=10):\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 374,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there are two numbers in the list\n    that add up to the target value. Return True if such numbers exist, and False otherwise.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 3, 5, 7, 9, 11, 13], 16\n\nassert f(*g())\n",
        "idx_generation": 375,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, check if there exists a pair of numbers in the list that sum up to the target.\n    Sample input:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    Sample output:\n    True\n    \"\"\"\n    low = 0\n    high = len(arr) - 1\n    while low < high:\n        current_sum = arr[low] + arr[high]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            low += 1\n        else:\n            high -= 1\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5], 7\n\nassert f(*g())\n",
        "idx_generation": 375,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum product that can be obtained by multiplying any three numbers from the list.\n    Return the maximum product.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3])\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [2, -3, 5, 1, -6]\n    return nums\n\nassert f(g()) == 90\n",
        "idx_generation": 376,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of distinct integers and a target number, determine if there are two numbers in the list that add up to the target.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums=[2, 4, 7, 11, 15], target=9):\n    return nums, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 377,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target number using binary search.\n    Return -1 if the target is not found.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g(nums: List[int] = [1, 3, 5, 7, 9, 11, 13], target: int = 7):\n    return nums, target\n\nassert f(*g()) == 3\n",
        "idx_generation": 377,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted array of distinct integers and a target value, return the index if the target is found.\n    If not, return the index where it would be if it were inserted in order.\"\"\"\n    low = 0\n    high = len(nums) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return low\n\ndef g():\n    return [1, 3, 5, 6]\n\nassert f(nums=g(), target=5) == 2\n",
        "idx_generation": 379,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers 'nums' and a target number 'target',\n    check if there are two numbers in the list that add up to the target.\n    Return True if such numbers exist, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    \n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 380,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum product of any three numbers in the list.\n    Return the maximum product.\n    \"\"\"\n    nums.sort()\n    \n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    \n    return nums\n\nassert f(g()) == 60\n",
        "idx_generation": 380,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers in ascending order, find if there are two numbers such that their sum is equal to the target.\n    Return True if such a pair exists, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 3, 5, 7, 9, 11, 13, 15]\n\nassert f(g(), 14) == True\n",
        "idx_generation": 380,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the second smallest element in the list.\n    \"\"\"\n    nums.sort()\n    return nums[1]\n\ndef g():\n    return [5, 3, 1, 7, 9, 2, 4, 6, 8]\n\nassert f(g()) == 2\n\n",
        "idx_generation": 382,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given an sorted array of integers nums and a target value, find the index of the target in the array.\n    If the target is not found, return -1.\"\"\"\n    \n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"Return a sorted array of integers and a target value.\"\"\"\n    nums.sort()\n    return nums, target\n\nassert f(*g(nums=[4, 5, 6, 7, 8, 9, 10], target=8)) == 4\n\n",
        "idx_generation": 383,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, check if there are two numbers in the list that sum up to the target number.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        current_sum = arr[left] + arr[right]\n        \n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g() -> List[int]:\n    return [1, 3, 5, 7, 9, 11, 13]\n\nassert f(g(), 16)\n",
        "idx_generation": 384,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the given array is a permutation of the numbers from 1 to n, where n is the length of the array.\n    Return True if it is a permutation, otherwise return False.\n    Sample input:\n    [3, 2, 1, 4]\n    Sample output:\n    True\"\"\"\n    n = len(arr)\n    # Sort the array\n    arr.sort()\n    # Check if the array is a permutation\n    for i in range(1, n+1):\n        if arr[i-1] != i:\n            return False\n    return True\n\ndef g():\n    return [3, 2, 1, 4]\n\nassert f(g()) == True\n\n",
        "idx_generation": 387,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, check if there are two numbers in the list that sum up to the target.\n    Return True if such numbers exist, False otherwise.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(target: int):\n    \"\"\"\n    Generate a sorted list of integers where there are two numbers that sum up to the given target.\n    \"\"\"\n    return [1, 3, 5, 7, 9, 11]\n\nassert f(g(10), 10)\n",
        "idx_generation": 388,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there exists a pair of numbers in the list that sum up to the target.\n    Return True if such pair exists, False otherwise.\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 15\n\nassert f(*g())\n",
        "idx_generation": 389,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, determine if the target number is present in the list\n    using binary search.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5, 6], target=4):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 390,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers in ascending order, find if there exists two numbers in the list such that their sum is equal to the given target.\n    Return True if such a pair exists, otherwise return False.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    return ([1, 2, 3, 4, 5, 6], 9)\n\nassert f(*g()) == True\n\n",
        "idx_generation": 392,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(arr: List[int], n: int) -> bool:\n    \"\"\"Check if there exists a pair of elements in arr whose product is equal to n.\"\"\"\n    def is_product(arr, n, left, right):\n        if left >= right:\n            return False\n        if arr[left] * arr[right] == n:\n            return True\n        elif arr[left] * arr[right] < n:\n            return is_product(arr, n, left+1, right)\n        else:\n            return is_product(arr, n, left, right-1)\n    \n    arr.sort()\n    return is_product(arr, n, 0, len(arr)-1)\n\ndef g():\n    arr = [2, 5, 7, 9, 12]\n    n = 63\n    return arr, n\n\nassert f(*g())\n",
        "idx_generation": 393,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of integers is sorted in non-decreasing order with no duplicates.\"\"\"\n    return sorted(set(nums)) == nums\n\ndef g():\n    \"\"\"Generate a list of sorted integers with no duplicates.\"\"\"\n    return list(range(1, 10))\n\nassert f(g())\n",
        "idx_generation": 393,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers, find the index of the target element using binary search.\"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\ndef g(arr: List[int], target: int) -> bool:\n    return f(arr, target)\n\narr = [1, 2, 4, 7, 11, 15]\ntarget = 7\nassert f(arr, target) == g(arr, target)\n",
        "idx_generation": 394,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, return True if the target value is present in the list, False otherwise.\"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 5\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 395,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, check if there exists two numbers in the list that add up to the target.\n    Return True if such a pair exists, otherwise return False.\"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Generate a sorted list of integers and a target value.\"\"\"\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 7\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 396,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a sorted array of integers, find two numbers in the array that add up to the target value.\"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [nums[left], nums[right]]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\ndef g(nums=[-2, -1, 0, 1, 2, 3, 4, 5], target=3):\n    return nums, target\n\nassert f(*g()) == [-2, 5]\n\n",
        "idx_generation": 398,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the list.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return (nums, target)\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 398,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Determine if there exists a pair of elements in a given array that sum up to the target value.\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr=[2, 7, 11, 15], target=9):\n    \"\"\"Generate an array of integers and a target value.\"\"\"\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 399,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if there exists a pair of numbers in the list whose sum is equal to the target.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    nums = [1, 3, 5, 2, 4]\n    target = 7\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 400,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there\n    exist two distinct indices i and j in the list, such that nums[i] + nums[j]\n    equals to the target value.\n    Return True if such indices exist, False otherwise.\n\n    Example:\n    nums = [-2, 1, 3, 4, 7, 11]\n    target = 9\n    There exist indices i = 2 and j = 4, such that nums[i] + nums[j] = 3 + 7 = 10,\n    which equals to the target value 9.\n    Therefore, the answer is True.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    return [-2, 1, 3, 4, 7, 11], 9\n\nassert f(*g())\n",
        "idx_generation": 401,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find two numbers in the list that sum up to the target.\n    Return the two numbers as a list in ascending order.\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [nums[left], nums[right]]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\ndef g():\n    nums = [2, 5, 7, 10, 12, 15, 18]\n    target = 17\n    return nums, target\n\nassert f(*g()) == [2, 15]\n",
        "idx_generation": 402,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list that sums up to the target.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums=[1, 4, 6, 3, 9, 2], target=8):\n    return nums\n\nassert f(g(), target=8)\n",
        "idx_generation": 403,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Calculate the product of all the numbers in the list.\"\"\"\n    product = 1\n    for num in nums:\n        product *= num\n    return product\n\ndef g(nums=[2, 4, 6, 8]):\n    return nums\n\nassert f(g()) == 384\n",
        "idx_generation": 403,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers 'arr' and a target value, return True if the target value is present in the list, \n    otherwise return False. Use a binary search algorithm to solve the problem.\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Generate a list of integers and a target value.\"\"\"\n    arr = [5, 10, 15, 20, 25, 30]\n    target = 15\n    return arr, target\n\nassert f(*g())\n\n\n",
        "idx_generation": 403,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers 'arr' and a target integer 'target', \n    determine if there exists a pair of distinct indices i and j in the list \n    such that arr[i] + arr[j] = target.\n\n    Return True if such a pair exists, False otherwise.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6], 9\n\nassert f(*g())\n",
        "idx_generation": 404,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target=10) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, return True if there are two numbers in the list that add up to the target, and False otherwise.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(arr=[1, 2, 4, 5, 7, 9]):\n    return arr\n\nassert f(g())\n",
        "idx_generation": 407,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers 'nums' and a target value,\n    find the index of the target value in the list using binary search.\n    If the target value is not found, return -1.\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7]\n    target = 4\n    The target value 4 is present in the list at index 3.\n    Therefore, the answer is 3.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7], 4\n\nassert f(*g()) == 3\n\n",
        "idx_generation": 407,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers 'nums' and a target integer, determine if there are two numbers in the list\n    that add up to the target.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    \"\"\"\n    Generate a sorted list of integers and a target integer.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    target = 8\n    \n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 410,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, determine if the target number is present in the list.\n    Use binary search algorithm to solve the problem.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\ndef g(arr=[1, 2, 3, 4, 5], target=3):\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 411,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list. Return True if the maximum product is greater than or equal to zero, False otherwise.\n    \"\"\"\n    nums.sort()\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1]) >= 0\n\ndef g(nums: List[int] = [-10, -2, -5, 1, 3, 2]) -> List[int]:\n    \"\"\"\n    Generate a list of integers that will result in a maximum product of any three numbers greater than or equal to zero.\n    \"\"\"\n    return nums\n\nassert f(g())\n",
        "idx_generation": 411,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target in the list using binary search.\n    If the target is not found, return -1.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g():\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    arr = [1, 3, 5, 7, 9, 11, 13]\n    target = 7\n    return arr, target\n\nassert f(*g()) == 3\n",
        "idx_generation": 412,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the given array is a palindrome.\"\"\"\n    return arr == arr[::-1]\n\ndef g():\n    arr = [1, 2, 3, 2, 1]\n    return arr\n\nassert f(g())\n",
        "idx_generation": 413,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the given array is sorted in non-decreasing order.\"\"\"\n    return arr == sorted(arr)\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    return arr\n\nassert f(g())\n",
        "idx_generation": 413,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers 'nums' and a target integer, determine if there are two numbers in the list that add up to the target.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"Generate a list of integers 'nums' and a target integer where there are two numbers in the list that add up to the target.\"\"\"\n    nums.sort()\n    return nums, target\n\nassert f(*g([1,2,3,4,5], 7))\n",
        "idx_generation": 413,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of non-negative integers, find the maximum product of two distinct numbers.\n    Return the maximum product.\n    \"\"\"\n    n = len(arr)\n    max_product = float('-inf')\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            product = arr[i] * arr[j]\n            max_product = max(max_product, product)\n    \n    return max_product\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of non-negative integers.\n    \"\"\"\n    arr = [2, 3, 4, 5, 6]\n    return arr\n\nassert f(g()) == 30\n\n",
        "idx_generation": 415,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, find if there are two numbers that sum up to the target.\"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    nums = [1, 3, 5, 7, 9]\n    target = 10\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 416,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, check if there exists a pair of numbers in the list whose sum is equal to the target number.\n    Sample input:\n    [1, 2, 3, 4, 5], 7\n    Sample output:\n    True\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5], 7\n\nassert f(*g())\n",
        "idx_generation": 416,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given an array of integers nums sorted in ascending order, find two numbers such that they add up to a specific\n    target number.\n    Return the indices of the two numbers (1-indexed) as a list of integers, where the first index is less than the\n    second index.\n    You may assume that each input would have exactly one solution and you may not use the same element twice.\n    Sample Input:\n    nums = [2, 7, 11, 15], target = 9\n    Sample Output:\n    [1, 2]\n    Explanation:\n    The sum of 2 and 7 is 9. Therefore, the indices of the two numbers are 1 and 2.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left + 1, right + 1]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find two numbers in a sorted array that add up to a specific target number.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left + 1, right + 1]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\nassert f([2, 7, 11, 15], 9) == g([2, 7, 11, 15], 9)\n",
        "idx_generation": 422,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, sort the list in non-decreasing order using the bubble sort algorithm.\n    Return the sorted list.\n    \"\"\"\n    def bubble_sort(nums):\n        n = len(nums)\n        for i in range(n):\n            for j in range(0, n - i - 1):\n                if nums[j] > nums[j + 1]:\n                    nums[j], nums[j + 1] = nums[j + 1], nums[j]\n        return nums\n    \n    return bubble_sort(nums)\n\ndef g():\n    nums = [9, 5, 2, 8, 1]\n    return nums\n\nassert f(g()) == [1, 2, 5, 8, 9]\n",
        "idx_generation": 423,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target value.\n    Return True if such a pair exists, False otherwise.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums: List[int], target: int):\n    \"\"\"Generate a sorted list of integers and a target value.\"\"\"\n    return sorted(nums), target\n\nassert f(*g([2, 7, 11, 15], 9))\n",
        "idx_generation": 425,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, determine if there exists two numbers in the list \n    whose sum is equal to the target number. Return True if such a pair exists, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(target: int) -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers that contains a pair whose sum is equal to the target number.\n    \"\"\"\n    return [1, target-1]\n\nassert f(g(5), 5) == True\n\n",
        "idx_generation": 425,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list is a permutation of the numbers from 1 to n, where n is the length of the list.\n    Sample Input:\n    nums = [4, 3, 2, 1]\n    Sample Output:\n    True\"\"\"\n    nums.sort()\n    for i in range(len(nums)):\n        if nums[i] != i + 1:\n            return False\n    return True\n\ndef g(nums: List[int] = [4, 3, 2, 1]) -> List[int]:\n    \"\"\"Return the given list\"\"\"\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 425,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers that add up to the target value.\n    Return True if such numbers exist, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] > target:\n            right -= 1\n        else:\n            left += 1\n    return False\n\ndef g(target: int):\n    nums = [-2, 0, 3, 5, 7, 9]\n    return nums, target\n\nassert f(*g(10))\n",
        "idx_generation": 427,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Given an array of integers, find the maximum product obtainable by multiplying two distinct numbers from the array.\"\"\"\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n    return max_product\n\ndef g(nums: List[int]) -> int:\n    return f(nums)\n\nnums = [1, 2, 3, 4, 5]\nassert f(nums) == g(nums)\n",
        "idx_generation": 429,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists two numbers in the given list that sum up to the target number.\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n            \n    return False\n\ndef g():\n    arr = [2, 7, 11, 15, 8]\n    target = 9\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 430,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers 'nums' and a target value 'target', determine whether there are two numbers\n    in the list that add up to the target. Return True if such two numbers exist, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9], target=10):\n    return nums\n\nassert f(g(), target=10)\n",
        "idx_generation": 432,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers 'nums' and a target value 'target', find two numbers in the list that add up to the target value.\n    Return the indices of the two numbers as a list.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        total = nums[left] + nums[right]\n        \n        if total == target:\n            return [left, right]\n        elif total < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g():\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    \n    return nums, target\n\nassert f(*g()) == [1, 4]\n",
        "idx_generation": 432,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums', remove all duplicate elements and return a new list with the unique elements in sorted order.\n    \"\"\"\n    unique_nums = list(set(nums))\n    unique_nums.sort()\n    \n    return unique_nums\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [3, 2, 1, 2, 4, 5, 3, 1]\n    \n    return nums\n\nassert f(g()) == [1, 2, 3, 4, 5]\n",
        "idx_generation": 432,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers, return the index of the target element in the array. If the target is not found, return -1.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\n\ndef g(arr: List[int] = [1, 2, 3, 4, 5, 6, 7, 8, 9], target: int = 6):\n    return arr, target\n\nassert f(*g()) == 5\n\n",
        "idx_generation": 433,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport random\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, use binary search to determine\n    if the target number is present in the list. Return True if it is,\n    and False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return False\n\ndef g():\n    \"\"\"Generate a sorted list of random numbers.\"\"\"\n    nums = sorted([random.randint(1, 100) for _ in range(10)])\n    target = random.choice(nums)\n    return nums, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 435,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there are two numbers in the list that sum up to the target.\n    Return True if such numbers exist, False otherwise.\"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    return [1, 2, 4, 7, 11, 15], 9\n\nassert f(*g()) == True\n",
        "idx_generation": 436,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum product of any three numbers in the list.\n    Return the maximum product.\"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g()) == 504\n\n",
        "idx_generation": 436,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are any two numbers in the list that add up to the target value.\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    Output: True\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return ([1, 2, 3, 4, 5], 7)\n\nassert f(*g())\n",
        "idx_generation": 439,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine if a number is a perfect square.\"\"\"\n    if n < 0:\n        return False\n    if n == 0:\n        return True\n    low, high = 1, n\n    while low <= high:\n        mid = (low + high) // 2\n        square = mid * mid\n        if square == n:\n            return True\n        elif square < n:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False\n\ndef g():\n    return 16\n\nassert f(g())\n",
        "idx_generation": 439,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum product of any two distinct numbers in the list.\"\"\"\n    max_product = float('-inf')\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            product = numbers[i] * numbers[j]\n            if product > max_product:\n                max_product = product\n    return max_product\n\ndef g():\n    numbers = [1, 4, 3, 6, 2, 5]\n    return numbers\n\nassert f(g()) == 30\n",
        "idx_generation": 440,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers in ascending order, find if there are two numbers whose sum equals to the target value.\"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums: List[int], target: int):\n    return sorted(nums)\n\nnums = [1, 2, 3, 4, 5, 6, 7]\ntarget = 8\nassert f(g(nums, target), target)\n",
        "idx_generation": 440,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers, find the index of the target value using binary search.\"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g(nums: List[int], target: int):\n    return sorted(nums)\n\nnums = [1, 2, 3, 4, 5, 6, 7]\ntarget = 4\nassert f(g(nums, target), target) == 3\n",
        "idx_generation": 440,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value k, determine if there are two distinct indices i and j in the array such that arr[i] + arr[j] = k.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        if arr[left] + arr[right] == k:\n            return True\n        elif arr[left] + arr[right] < k:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    \"\"\"\n    Generate a sorted array of random integers and a random target value.\n    \"\"\"\n    arr = sorted([random.randint(1, 10) for _ in range(10)])\n    k = random.randint(1, 20)\n    return arr, k\n\nassert f(*g())\n",
        "idx_generation": 442,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers that add up to a given target.\n\n    Return True if there are two numbers that add up to the target, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(nums: List[int], target: int) -> bool:\n    return f(nums, target)\n\nnums = [1, 2, 4, 6, 8, 10]\ntarget = 9\nassert f(nums, target) == g(nums, target)\n",
        "idx_generation": 442,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers in the list that add up to the given target.\n    You may assume that each input would have exactly one solution and you may not use the same element twice.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"Returns the sorted list of integers and the target number\"\"\"\n    return nums, target\n\nassert f(*g(nums=[-2, 0, 3, 5, 6, 7, 9, 11, 12, 15], target=10))\n",
        "idx_generation": 443,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers and a target number, return the index of the target number in the list using binary search. If the target number is not in the list, return -1.\"\"\"\n    \n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g():\n    return [1, 3, 5, 7, 9, 11, 13, 15, 17], 9\n\nassert f(*g()) == 4\n",
        "idx_generation": 444,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, find if there exists a pair of numbers in the list that add up to the target.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Generate a list of integers and a target number.\"\"\"\n    return [4, 2, 7, 1, 5], 9\n\nassert f(*g())\n",
        "idx_generation": 444,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers in ascending order, determine if there are two numbers in the array that sum up to a given target.\n    Return True if such numbers exist, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5, 6]\n    target = 8\n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 445,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a sorted array of integers, find two numbers such that they add up to a specific target number.\n    Return the indices of the two numbers in the array.\"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\ndef g():\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 446,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum product of any three numbers in the list.\"\"\"\n    nums.sort()\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 60\n",
        "idx_generation": 446,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there exist two numbers in the list whose sum is equal to the target.\n\n    Return True if such two numbers exist, False otherwise.\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 446,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the index of the target value in the list using Binary Search.\n    If the target value is not in the list, return -1.\n    \"\"\"\n    def binary_search(arr: List[int], low: int, high: int, target: int) -> int:\n        if high >= low:\n            mid = (low + high) // 2\n            if arr[mid] == target:\n                return mid\n            elif arr[mid] > target:\n                return binary_search(arr, low, mid - 1, target)\n            else:\n                return binary_search(arr, mid + 1, high, target)\n        else:\n            return -1\n    \n    return binary_search(nums, 0, len(nums) - 1, target)\n\ndef g():\n    nums = [2, 4, 6, 8, 10]\n    target = 6\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 447,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of integers is a permutation of the numbers from 1 to n.\"\"\"\n    nums.sort()\n    n = len(nums)\n    for i in range(n):\n        if nums[i] != i + 1:\n            return False\n    return True\n\ndef g(n=5):\n    \"\"\"Generate a list of integers representing a permutation of the numbers from 1 to n.\"\"\"\n    return list(range(1, n+1))\n\nassert f(g())\n",
        "idx_generation": 448,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers 'arr' and a target value 'target',\n    return True if the target is present in the array, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\ndef g(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers 'arr' and a target value 'target',\n    return the array 'arr' with the target value appended to it.\n    \"\"\"\n    arr.append(target)\n    return arr\n\nassert f(g([1, 2, 3, 4, 5], 3), 3)\n",
        "idx_generation": 449,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target_sum: int) -> List[int]:\n    \"\"\"Given a list of integers and a target sum, find two numbers in the list that add up to the target sum.\n    Returns the pair of numbers if found, otherwise returns an empty list.\n    Sample input:\n    nums = [2, 4, 6, 8, 10]\n    target_sum = 14\n    Sample output:\n    [4, 10]\"\"\"\n    nums.sort()  # Sort the list in ascending order\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target_sum:\n            return [nums[left], nums[right]]\n        elif current_sum < target_sum:\n            left += 1\n        else:\n            right -= 1\n    return []\n\ndef g():\n    nums = [2, 4, 6, 8, 10]\n    target_sum = 14\n    return nums, target_sum\n\nassert f(*g()) == [4, 10]\n",
        "idx_generation": 450,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum product of any three distinct numbers in the list.\"\"\"\n    nums.sort()  # Sort the list in ascending order\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g():\n    nums = [1, 3, 5, 2, 4]\n    return nums\n\nassert f(g()) == 60\n",
        "idx_generation": 450,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, use binary search to determine\n    if the target value is present in the list.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\ndef g():\n    return [-1, 0, 3, 5, 9, 12], 9\n\nassert f(*g())\n",
        "idx_generation": 450,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given an array of integers, find two numbers such that they add up to a specific target.\n\n    Args:\n        nums (List[int]): The input array of integers.\n        target (int): The target sum.\n\n    Returns:\n        List[int]: A list of two numbers that add up to the target sum.\n\n    Example:\n        Input: nums = [2, 7, 11, 15], target = 9\n        Output: [2, 7]\n    \"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n\n        if curr_sum == target:\n            return [nums[left], nums[right]]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g(nums: List[int], target: int) -> List[int]:\n    return f(nums, target)\n\nnums = [2, 7, 11, 15]\ntarget = 9\nassert f(nums, target) == g(nums, target)\n",
        "idx_generation": 450,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, check if the target value is present in the list using binary search.\"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Generate a sorted list of integers and a target value.\"\"\"\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    target = 7\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 451,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g():\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g()) == 120\n\n",
        "idx_generation": 452,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers, determine if there are two numbers that add up to a given target.\n    Return True if such numbers exist, False otherwise.\"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7], 10\n\nassert f(*g()) == True\n",
        "idx_generation": 452,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Find if there exists a pair of elements in the given array whose sum is equal to the target\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g(arr=[1, 4, 3, 7, 9, 2], target=11):\n    return arr, target\nassert f(*g())\n",
        "idx_generation": 453,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the minimum missing positive integer.\n    The list may contain duplicates and negative numbers.\n    Return the minimum missing positive integer.\n    \"\"\"\n    nums = sorted(set(nums))\n    missing = 1\n    \n    for num in nums:\n        if num == missing:\n            missing += 1\n        elif num > missing:\n            break\n    \n    return missing\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [3, 2, -1, 0, 5, 4, -2]\n    \n    return nums\n\nassert f(g()) == 1\n",
        "idx_generation": 454,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers and a target value, find if there exist two numbers in the array whose sum is equal to the target.\n    Return True if such a pair exists, otherwise return False.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        \n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5, 6]\n    target = 9\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 454,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums1: List[int], nums2: List[int]) -> List[int]:\n    \"\"\"\n    Given two sorted lists of integers, return a new sorted list that contains all the elements from both lists.\n    \"\"\"\n    i = 0\n    j = 0\n    merged = []\n    \n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] <= nums2[j]:\n            merged.append(nums1[i])\n            i += 1\n        else:\n            merged.append(nums2[j])\n            j += 1\n    \n    while i < len(nums1):\n        merged.append(nums1[i])\n        i += 1\n    \n    while j < len(nums2):\n        merged.append(nums2[j])\n        j += 1\n    \n    return merged\n\ndef g():\n    nums1 = [1, 3, 5, 7]\n    nums2 = [2, 4, 6, 8]\n    return (nums1, nums2)\n\nassert f(*g()) == [1, 2, 3, 4, 5, 6, 7, 8]\n",
        "idx_generation": 456,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if it is possible to find a pair of numbers in the given list that add up to the target.\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    arr = [3, 7, 2, 10, 4]\n    target = 14\n    return arr, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 457,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g():\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 458,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the sum of all prime numbers in the list.\"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                return False\n        return True\n\n    prime_sum = 0\n    for num in nums:\n        if is_prime(num):\n            prime_sum += num\n\n    return prime_sum\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return nums\n\nassert f(g()) == 17\n",
        "idx_generation": 458,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target element using binary search.\n    If the target element is not found, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target element.\n    \"\"\"\n    nums = [1, 3, 5, 7, 9, 11, 13, 15]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 3\n",
        "idx_generation": 458,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers and a target number, find three numbers in the list that add up to the target.\"\"\"\n    nums.sort()\n    n = len(nums)\n    for i in range(n - 2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            curr_sum = nums[i] + nums[left] + nums[right]\n            if curr_sum == target:\n                return [nums[i], nums[left], nums[right]]\n            elif curr_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return []\n\ndef g(nums=[-1, 0, 1, 2, -1, -4], target=0):\n    return nums, target\n\nassert f(*g()) == [-1, -1, 2]\n",
        "idx_generation": 459,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers in the list that sum up to the target value.\n    Return True if such pair exists, otherwise return False.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr: List[int], target: int) -> List[int]:\n    \"\"\"Returns a sorted list of integers and the target value\"\"\"\n    return arr, target\n\nassert f(*g(arr=[1, 2, 3, 4, 5], target=9))\n",
        "idx_generation": 461,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers that sum up to the target.\n    Return True if such numbers exist, False otherwise.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        \n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    return [1, 3, 5, 7, 9], 12\n\nassert f(*g())\n",
        "idx_generation": 462,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(matrix: List[List[int]], target: int) -> Tuple[int, int]:\n    \"\"\"Given a matrix of integers, find the indices of the first occurrence of the target value.\n    Return a tuple (row, column) representing the indices of the target value.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    for i in range(rows):\n        for j in range(cols):\n            if matrix[i][j] == target:\n                return (i, j)\n    \n    return (-1, -1)\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    target = 5\n    return matrix, target\n\nassert f(*g()) == (1, 1)\n",
        "idx_generation": 462,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if there exists a pair of integers in the list whose sum is equal to the target.\"\"\"\n    arr.sort()\n    left, right = 0, len(arr) - 1\n    \n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(arr=[1, 2, 3, 4, 5], target=9):\n    \"\"\"Generate a list of integers where there exists a pair whose sum is equal to the target value.\"\"\"\n    return arr\n\nassert f(g(), 9) == True\n",
        "idx_generation": 463,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Given a matrix of integers and a target value, determine if the target value exists in the matrix.\n    The matrix is sorted in non-decreasing order both row-wise and column-wise.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    # Start from the top-right corner of the matrix\n    row = 0\n    col = cols - 1\n    \n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] > target:\n            col -= 1\n        else:\n            row += 1\n    \n    return False\n\ndef g(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Generate a matrix with the given target value.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    # Set the target value in a random position\n    row = random.randint(0, rows - 1)\n    col = random.randint(0, cols - 1)\n    matrix[row][col] = target\n    \n    return matrix\n\nassert f(g([[1, 2, 3], [4, 5, 6], [7, 8, 9]], target=5), target=5)\n",
        "idx_generation": 463,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum product of any three numbers in the given list.\"\"\"\n    nums.sort()\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\n\ndef g():\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g()) == 120\n",
        "idx_generation": 464,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, sort the list in non-decreasing order using the Bubble Sort algorithm.\n    Return the sorted list.\n\n    Example:\n    nums = [5, 2, 8, 12, 3]\n    After applying the Bubble Sort algorithm, the sorted list is [2, 3, 5, 8, 12].\n    Therefore, the answer is [2, 3, 5, 8, 12].\n    \"\"\"\n    n = len(nums)\n    for i in range(n-1):\n        for j in range(n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    \n    return nums\n\ndef g() -> List[int]:\n    return [5, 2, 8, 12, 3]\n\nassert f(g()) == [2, 3, 5, 8, 12]\n\n",
        "idx_generation": 464,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers 'arr' and a target integer 'target', find the index of the target using binary search.\n    Return the index of the target if it exists in the list, otherwise return -1.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(arr: List[int] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target: int = 7) -> bool:\n    return arr\n\nassert f(g(), 7) == 6\n",
        "idx_generation": 465,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there are three integers in the list that sum up to the target number.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    for i in range(n-2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            curr_sum = nums[i] + nums[left] + nums[right]\n            if curr_sum == target:\n                return True\n            elif curr_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5], target=9):\n    \"\"\"\n    Generate a list of integers where there are three integers that sum up to the target number.\n    \"\"\"\n    return nums\n\nassert f(g(), 9) == True\n",
        "idx_generation": 465,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Find the pair of numbers from the given list that adds up to the target value\"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums=[4, 7, 2, 9, 1, 5], target=10):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 466,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers and a target value, return the index if the target is found.\n    If not, return the index where it would be if it were inserted in order.\n    You must write an algorithm with O(log n) runtime complexity.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n            \n    return left\n\ndef g():\n    return [1, 3, 5, 6], 5\n\nassert f(*g()) == 2\n",
        "idx_generation": 466,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if there exist two numbers in the list such that their sum is equal to the target.\"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums=[2, 4, 6, 8, 10], target=14):\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 467,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers that sum up to the target value.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    nums = [1, 3, 5, 7, 9]\n    target = 10\n    return nums, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 468,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers and a target value, find the number of pairs that sum up to the target.\"\"\"\n    count = 0\n    num_freq = {}\n    for num in nums:\n        complement = target - num\n        if complement in num_freq:\n            count += num_freq[complement]\n        num_freq[num] = num_freq.get(num, 0) + 1\n    return count\n\ndef g():\n    nums = [1, 3, 5, 2, 4]\n    target = 6\n    return nums, target\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 468,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target integer, determine if there exists a pair of elements in the list that sums up to the target.\n    Return True if such pair exists, False otherwise.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Generate a sorted list of integers and a target integer.\"\"\"\n    return [-2, 0, 3, 5, 7, 9], 12\n\nassert f(*g())\n",
        "idx_generation": 469,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the given list that sum up to the target value.\"\"\"\n    arr.sort()\n    left, right = 0, len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr: List[int], target: int):\n    return sorted(arr)\n\n# Example usage:\narr = [1, 4, 2, 8, 5]\ntarget = 9\nassert f(g(arr, target), target)\n",
        "idx_generation": 470,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers that add up to a given target.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5], 7\n\nassert f(*g()) == True\n",
        "idx_generation": 470,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Find if there exists a pair of numbers in the list whose sum is equal to the target value.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums=[2, 4, 6, 8, 10], target=12) -> List[int]:\n    \"\"\"Return the given list and target value.\"\"\"\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 471,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum product of any two numbers in the given list.\"\"\"\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n    return max_product\n\ndef g(nums=[1, 2, 3, 4, 5]) -> List[int]:\n    \"\"\"Return the given list.\"\"\"\n    return nums\n\nassert f(g()) == 20\n",
        "idx_generation": 471,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a sorted list of integers 'nums' and a target integer 'target',\n    find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the list.\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    The numbers 2 and 7 add up to 9, and their indices in the list are 0 and 1.\n    Therefore, the answer is [0, 1].\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        \n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g():\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 472,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"Sort the array using bubble sort algorithm in ascending order\"\"\"\n    n = len(arr)\n    for i in range(n-1):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr == sorted(arr)\ndef g():\n    return [5, 3, 8, 2, 1, 9, 4, 7, 6]\nassert f(g())\n",
        "idx_generation": 473,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if any two integers from the list add up to the target.\n    Return True if there are two integers that add up to the target, False otherwise.\n    \n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    Output: True\n    Explanation: 2 + 5 = 7\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5], 7\n\nassert f(*g()) == True\n",
        "idx_generation": 473,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers in ascending order and a target value,\n    return the index of the target value in the list using binary search.\n    If the target value is not found, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g():\n    nums = [1, 3, 5, 7, 9, 11]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 3\n",
        "idx_generation": 474,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers `arr` and a target value `target`,\n    find if there exists a pair of numbers in the list such that their sum is equal to the target.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr: List[int], target: int):\n    \"\"\"\n    Generate a sorted list of integers `arr` and a target value `target`\n    such that there exists a pair of numbers in the list such that their sum is equal to the target.\n    \"\"\"\n    arr.sort()\n    return arr, target\n\nassert f(*g([1, 2, 3, 4, 5], 7))\n",
        "idx_generation": 475,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers, check if a pair of elements in the array sums up to the target value.\n    Return True if such a pair exists, otherwise return False.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        \n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Generate a sorted array of integers and a target value.\"\"\"\n    arr = [1, 3, 5, 7, 9, 11]\n    target = 14\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 476,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given an array of integers, check if there exists a subarray whose sum is equal to the target value.\n    Return True if such a subarray exists, otherwise return False.\"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    \n    for num in arr:\n        prefix_sum += num\n        \n        if prefix_sum == target:\n            return True\n        \n        if prefix_sum - target in prefix_sums:\n            return True\n        \n        prefix_sums.add(prefix_sum)\n    \n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Generate an array of integers and a target value.\"\"\"\n    arr = [2, 4, -2, 1, 8, -5, 7]\n    target = 6\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 476,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Sort an array of integers in non-decreasing order using the Bubble Sort algorithm.\n    Return the sorted array.\"\"\"\n    n = len(arr)\n    \n    for i in range(n):\n        swapped = False\n        \n        for j in range(n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swapped = True\n        \n        if not swapped:\n            break\n    \n    return arr\n\ndef g() -> List[int]:\n    \"\"\"Generate an unsorted array of integers.\"\"\"\n    arr = [9, 5, 1, 3, 8, 2]\n    return arr\n\nassert f(g()) == sorted(g())\n",
        "idx_generation": 476,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Find the index of the target number in the given list of sorted numbers.\n    If the target is not found, return -1.\"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    \"\"\"Generate a sorted list of numbers.\"\"\"\n    nums = [1, 3, 5, 7, 9, 11, 13]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 3\n",
        "idx_generation": 477,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers 'nums' and a target value 'target', determine if the target value exists in the list.\n    Return True if the target value is found, otherwise return False.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef g(nums: List[int]) -> int:\n    \"\"\"Return the target value that needs to be searched in the sorted list 'nums'.\n    \"\"\"\n    return nums[0]\n\nassert f(nums=[1, 2, 3, 4, 5], target=g(nums=[1, 2, 3, 4, 5]))\n\n",
        "idx_generation": 477,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"Find the index of the target number in the given list using binary search. If the target number is not found, return -1.\"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(arr: List[int], target: int) -> int:\n    \"\"\"Find the index of the target number in the given list using linear search. If the target number is not found, return -1.\"\"\"\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return i\n    return -1\n\nassert f([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 6) == g([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 6)\n",
        "idx_generation": 480,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there are three integers in the list\n    that sum up to the target number. Return True if such a triplet exists, otherwise return False.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    \n    for i in range(n - 2):\n        left = i + 1\n        right = n - 1\n        \n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            \n            if current_sum == target:\n                return True\n            \n            if current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    \n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target number.\n    \"\"\"\n    nums = [1, 5, 3, 9, 2, 7, 4]\n    target = 14\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 481,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target element if it exists.\n    If the target element does not exist, return -1.\n    \"\"\"\n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1\n\ndef g(arr: List[int], target: int) -> int:\n    \"\"\"\n    Find the index of the target element in a sorted list of integers.\n    \"\"\"\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return i\n    return -1\n\nassert f([1, 2, 3, 4, 5, 6, 7, 8, 9], 5) == g([1, 2, 3, 4, 5, 6, 7, 8, 9], 5)\n",
        "idx_generation": 483,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers 'arr' and a target number 'target',\n    check if there exists a pair of numbers in the list whose sum is equal to the target.\n    Return True if such a pair exists, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    target = 12\n    \n    return arr, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 483,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers 'nums' and a target number, determine if there exist two numbers in the list that add up to the target.\n    Return True if such pair exists, otherwise return False.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    nums = [2, 4, 6, 8, 10]\n    target = 12\n    \n    return nums, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 484,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers 'nums', sort the list in non-decreasing order and return the sorted list.\"\"\"\n    nums.sort()\n    return nums\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"Return the given list of integers.\"\"\"\n    return nums\n\nassert f(g([4, 2, 7, 1, 9, 5])) == [1, 2, 4, 5, 7, 9]\n",
        "idx_generation": 485,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the given list that sums up to the target value.\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    arr = [2, 4, 6, 8, 10]\n    target = 12\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 490,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of sorted integers 'nums' and an integer 'target',\n    find the index of the target in the list using binary search.\n    If the target is not found, return -1.\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    The target 5 is found at index 2 in the list.\n    Therefore, the answer is 2.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g():\n    return [1, 3, 5, 7, 9], 5\n\nassert f(*g()) == 2\n",
        "idx_generation": 491,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers, determine if there exists two numbers in the array such that their sum is equal to the target.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), 12) == True\n",
        "idx_generation": 491,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of three numbers in the list.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3])\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [5, 10, 2, 8, 3]\n    return nums\n\nassert f(g()) == 400\n",
        "idx_generation": 492,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum product of any two distinct elements in the list.\"\"\"\n    max_product = float('-inf')\n    \n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n    \n    return max_product\n\ndef g() -> List[int]:\n    \"\"\"Generate a list of integers.\"\"\"\n    nums = [2, 3, -1, 4, -2, 5]\n    return nums\n\nassert f(g()) == 20\n",
        "idx_generation": 495,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Find if there exist two numbers in the list that sum up to the target.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return ([1, 5, 3, 9, 2], 8)\n\nassert f(*g())\n",
        "idx_generation": 495,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, sort the list in non-decreasing order and return the sorted list.\"\"\"\n    return sorted(arr)\n\ndef g():\n    return [5, 2, 9, 1, 7]\n\nassert f(g()) == [1, 2, 5, 7, 9]\n",
        "idx_generation": 496,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[str], target: str) -> bool:\n    \"\"\"Given a list of strings and a target string, check if the target string is present in the list.\n    Return True if found, False otherwise.\"\"\"\n    return target in arr\n\ndef g():\n    return [\"apple\", \"banana\", \"pear\", \"orange\"], \"banana\"\n\nassert f(*g()) == True\n",
        "idx_generation": 496,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers 'nums' and a target value, determine if there exists a pair of numbers in the list that adds up to the target value.\n    Use the two-pointer technique to solve this problem.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6], 9\n\nassert f(*g())\n",
        "idx_generation": 496,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target integer k, find all pairs of distinct numbers such that the absolute difference\n    between each pair is equal to k.\n\n    Example:\n    Input:\n    nums = [1, 7, 5, 9, 2, 12, 3]\n    k = 4\n    Output:\n    [(1, 5), (5, 9), (7, 3), (9, 5), (12, 8)]\n\n    Explanation:\n    The pairs with an absolute difference of 4 are: (1, 5), (5, 9), (7, 3), (9, 5), (12, 8).\n    \"\"\"\n\n    nums.sort()\n    pairs = set()\n    \n    for i in range(len(nums)):\n        if nums[i] + k in nums[i+1:]:\n            pairs.add((nums[i], nums[i] + k))\n        if nums[i] - k in nums[i+1:]:\n            pairs.add((nums[i] - k, nums[i]))\n    \n    return list(pairs)\n\ndef g(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Find all pairs of distinct numbers in a list such that the absolute difference between each pair is equal to k.\n    \"\"\"\n\n    nums.sort()\n    pairs = set()\n    \n    for i in range(len(nums)):\n        if nums[i] + k in nums[i+1:]:\n            pairs.add((nums[i], nums[i] + k))\n        if nums[i] - k in nums[i+1:]:\n            pairs.add((nums[i] - k, nums[i]))\n    \n    return list(pairs)\n\nassert f(nums=[1, 7, 5, 9, 2, 12, 3], k=4) == g(nums=[1, 7, 5, 9, 2, 12, 3], k=4)\n",
        "idx_generation": 496,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, find if there are two integers in the list that sum up to the target.\n    Sample input:\n    [1, 2, 3, 4, 5], 7\n    Sample output:\n    True\n    (Sample output hidden because showing sample output would give away too much information.)\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5], 7\n\nassert f(*g())\n",
        "idx_generation": 496,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers 'nums' and a target integer 'target',\n    return the minimum number of elements that need to be removed from 'nums'\n    to make the sum of the remaining elements greater than or equal to 'target'.\"\"\"\n    nums.sort(reverse=True)\n    current_sum = 0\n    count = 0\n    for num in nums:\n        current_sum += num\n        count += 1\n        if current_sum >= target:\n            return count\n    return -1\n\ndef g():\n    return [3, 1, 2, 5, 4], 7\n\nassert f(*g()) == 2\n",
        "idx_generation": 498,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5], target=7):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 498,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    }
]
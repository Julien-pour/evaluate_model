[
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where all the even numbers are squared.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n\n    Output:\n    [1, 4, 3, 16, 5, 36]\n\n    Explanation:\n    The even numbers in the list are 2, 4, and 6. Squaring these numbers gives [1, 4, 16, 36].\n    \"\"\"\n    squared_nums = []\n\n    for num in nums:\n        if num % 2 == 0:\n            squared_nums.append(num ** 2)\n        else:\n            squared_nums.append(num)\n\n    return squared_nums\n\ndef g(nums=[1, 2, 3, 4, 5, 6]):\n    return [nums]\n\nassert f(*g()) == [1, 4, 3, 16, 5, 36]\n\n",
        "idx_generation": 451,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Implement a stack that supports push, pop, and getMin operations in constant time.\n    Return the minimum element in the stack when getMin is called.\n    \"\"\"\n    class MinStack:\n        def __init__(self):\n            self.stack = []\n            self.min_stack = []\n            \n        def push(self, val):\n            self.stack.append(val)\n            if not self.min_stack or val <= self.min_stack[-1]:\n                self.min_stack.append(val)\n                \n        def pop(self):\n            if self.stack:\n                val = self.stack.pop()\n                if val == self.min_stack[-1]:\n                    self.min_stack.pop()\n                    \n        def getMin(self):\n            if self.min_stack:\n                return self.min_stack[-1]\n            else:\n                return None\n    \n    stack = MinStack()\n    for i in range(n):\n        stack.push(i)\n    \n    return stack.getMin()\n\ndef g(n = 5):\n    return n\n\nassert f(g()) == 0\n",
        "idx_generation": 171,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(m: int, n: int) -> int:\n    \"\"\"\n    Unique Paths in a Grid\n\n    Given a grid of size m x n, find the number of unique paths from the top-left corner to the bottom-right corner,\n    moving only right or down.\n\n    Example:\n    m = 3\n    n = 7\n    output: 28\n\n    Explanation: There are 28 unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1\n\n    for i in range(m):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n\n    return dp[m-1][n-1]\n\n\ndef g(m = 3, n = 7):\n    return m, n\n\n\nassert f(*g()) == 28\n",
        "idx_generation": 451,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray with the constraint that no two numbers in the subarray are adjacent.\n    Return the maximum sum.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n\n    if n == 1:\n        return nums[0]\n\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n    return dp[n - 1]\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 9\n",
        "idx_generation": 331,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if there is a path from the top-left corner to the bottom-right corner in a grid.\n\n    Sample Input:\n    grid = [[1, 1, 1, 1, 1],\n            [1, 0, 0, 0, 1],\n            [1, 1, 1, 0, 1],\n            [0, 0, 1, 1, 1],\n            [1, 1, 1, 1, 1]]\n\n    Sample Output:\n    True\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    visited = set()\n    queue = deque([(0, 0)])\n    while queue:\n        row, col = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return True\n        if (row, col) not in visited:\n            visited.add((row, col))\n            if row - 1 >= 0 and grid[row - 1][col] == 1:\n                queue.append((row - 1, col))\n            if row + 1 < rows and grid[row + 1][col] == 1:\n                queue.append((row + 1, col))\n            if col - 1 >= 0 and grid[row][col - 1] == 1:\n                queue.append((row, col - 1))\n            if col + 1 < cols and grid[row][col + 1] == 1:\n                queue.append((row, col + 1))\n    return False\n\ndef g():\n    grid = [[1, 1, 1, 1, 1],\n            [1, 0, 0, 0, 1],\n            [1, 1, 1, 0, 1],\n            [0, 0, 1, 1, 1],\n            [1, 1, 1, 1, 1]]\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 62,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Find if there is a path from the top-left corner to the bottom-right corner in the given grid\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[False] * n for _ in range(m)]\n    dp[0][0] = True\n\n    for i in range(m):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] |= dp[i-1][j]\n            if j > 0:\n                dp[i][j] |= dp[i][j-1]\n\n    return dp[m-1][n-1]\n\ndef g():\n    return [[1, 0, 0, 0], [1, 1, 0, 1], [0, 1, 1, 0], [1, 0, 1, 1]]\n\nassert f(g()) == True\n",
        "idx_generation": 2,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if a given grid has a closed loop of 1s\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Check if the grid has a closed loop of 1s\n    visited = set()\n    stack = []\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 1 and (r, c) not in visited:\n                if dfs(grid, r, c, rows, cols, visited):\n                    return True\n\n    return False\n\ndef dfs(grid: List[List[int]], r: int, c: int, rows: int, cols: int, visited: set) -> bool:\n    \"\"\"Perform a depth-first search to check for a closed loop\"\"\"\n    stack = [(r, c)]\n    while stack:\n        node = stack.pop()\n        if node in visited:\n            continue\n        visited.add(node)\n        nr, nc = node\n        neighbors = [(nr-1, nc), (nr+1, nc), (nr, nc-1), (nr, nc+1)]\n        for neighbor in neighbors:\n            nnr, nnc = neighbor\n            if 0 <= nnr < rows and 0 <= nnc < cols and grid[nnr][nnc] == 1:\n                if (nnr, nnc) == (r, c):\n                    return True\n                stack.append((nnr, nnc))\n\n    return False\n\ndef g(rows: int, cols: int) -> List[List[int]]:\n    \"\"\"Generate a grid with a closed loop of 1s\"\"\"\n    grid = [[0] * cols for _ in range(rows)]\n\n    # Create a closed loop of 1s in the grid\n    for r in range(rows):\n        for c in range(cols):\n            if r == 0 or r == rows - 1 or c == 0 or c == cols - 1:\n                grid[r][c] = 1\n\n    return grid\n\nassert f(g(3, 3))\n",
        "idx_generation": 95,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome when all non-alphanumeric characters are removed.\n\n    Example:\n    Input:\n    string = \"A man, a plan, a canal: Panama\"\n\n    Output: True\n\n    Explanation: The string \"A man, a plan, a canal: Panama\" is a palindrome when non-alphanumeric characters are removed.\n    \"\"\"\n\n    def is_palindrome(string: str) -> bool:\n        string = ''.join(filter(str.isalnum, string.lower()))\n        return string == string[::-1]\n\n    return is_palindrome(string)\n\ndef g():\n    string = \"A man, a plan, a canal: Panama\"\n    return string,\n\nassert f(*g()) == True\n",
        "idx_generation": 451,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n    \"\"\"\n    stack = []\n    for char in string:\n        stack.append(char)\n    reversed_string = \"\"\n    while stack:\n        reversed_string += stack.pop()\n    return string == reversed_string\n\ndef g(string=\"racecar\"):\n    \"\"\"\n    Return the given string.\n    \"\"\"\n    return string\n\nassert f(g()) == True\n",
        "idx_generation": 8,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome after deleting at most one character from it.\n\n    Example:\n    s = \"abca\"\n    Return True, as \"abca\" can be turned into a palindrome by removing the character 'b'.\n\n    Constraints:\n    - The input string s consists of lowercase English letters.\n    \"\"\"\n    def is_palindrome(s, left, right):\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n    \n    if len(s) <= 2:\n        return True\n    \n    left, right = 0, len(s) - 1\n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s, left+1, right) or is_palindrome(s, left, right-1)\n        left += 1\n        right -= 1\n    return True\n\ndef g():\n    return \"abca\"\n\nassert f(g()) == True\n",
        "idx_generation": 450,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a grid of integers and a target value, determine if the target value exists in the grid.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    target = 5\n\n    Output:\n    True\n\n    Explanation:\n    The target value 5 exists in the grid.\n    \"\"\"\n\n    # Check if the grid is empty\n    if len(grid) == 0 or len(grid[0]) == 0:\n        return False\n\n    # Iterate through the grid and check if the target value exists\n    for row in grid:\n        if target in row:\n            return True\n\n    return False\n\ndef g():\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n    target = 5\n    return grid, target\n\nassert f(*g()) == True\n",
        "idx_generation": 268,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[str]]) -> bool:\n    \"\"\"Check if a word exists in a given grid of characters by searching horizontally and vertically.\"\"\"\n    def search_word(word, row, col, direction):\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]):\n            return False\n        if grid[row][col] != word[0]:\n            return False\n        if len(word) == 1:\n            return True\n        if direction == 'right':\n            return search_word(word[1:], row, col+1, direction)\n        elif direction == 'down':\n            return search_word(word[1:], row+1, col, direction)\n        return False\n\n    word = \"CAT\"\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if search_word(word, i, j, 'right') or search_word(word, i, j, 'down'):\n                return True\n    return False\n\ndef g():\n    grid = [['C', 'A', 'T', 'D'],\n            ['O', 'G', 'R', 'E'],\n            ['S', 'T', 'R', 'I'],\n            ['N', 'G', 'S', 'E']]\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 25,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(arr: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    Given an array of integers, find the two numbers that have the minimum XOR value.\n\n    Example:\n    arr = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    (3, 2)\n\n    Explanation:\n    The pair of numbers (3, 2) has the minimum XOR value of 1.\n    \"\"\"\n    min_xor = float('inf')\n    num1, num2 = 0, 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            xor_val = arr[i] ^ arr[j]\n            if xor_val < min_xor:\n                min_xor = xor_val\n                num1, num2 = arr[i], arr[j]\n    return num1, num2\n\ndef g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == (3, 2)\n\n",
        "idx_generation": 478,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of bits set to 1 in its binary representation.\n\n    Sample Input:\n    n = 10\n\n    Sample Output:\n    2\n    \"\"\"\n    count = 0\n    while n > 0:\n        count += n & 1\n        n >>= 1\n    return count\n\n\ndef g(n=10):\n    return n\n\n\nassert f(g()) == 2\n",
        "idx_generation": 109,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target integer, determine if there are two numbers in the list that can be XORed together to get the target.\n\n    Example:\n    nums = [2, 4, 6, 8, 10]\n    target = 14\n\n    Output:\n    True\n\n    Explanation:\n    The numbers 6 and 8 can be XORed together to get 14.\n\n    Hint: Use a stack to store the XORed values and check if the target is present in the stack.\n    \"\"\"\n    stack = []\n    for num in nums:\n        if num ^ target in stack:\n            return True\n        stack.append(num)\n    return False\n\ndef g(nums=[2, 4, 6, 8, 10], target=14):\n    return nums, target\n\nassert f(g()[0], g()[1]) == True\n",
        "idx_generation": 96,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target integer, determine if it is possible to select k numbers from the list such that their bitwise XOR is equal to the target.\n    \"\"\"\n    def helper(nums, target, k, curr_xor, start):\n        if k == 0:\n            return curr_xor == target\n        if start >= len(nums):\n            return False\n        \n        # Include the current number in the XOR calculation\n        include = helper(nums, target, k - 1, curr_xor ^ nums[start], start + 1)\n        \n        # Exclude the current number from the XOR calculation\n        exclude = helper(nums, target, k, curr_xor, start + 1)\n        \n        return include or exclude\n\n    return helper(nums, target, k, 0, 0)\n\ndef g():\n    return ([1, 2, 3, 4, 5], 6, 3)\n\nassert f(*g())\n",
        "idx_generation": 56,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n  \n    Output:\n    28\n  \n    Explanation:\n    The maximum XOR value is achieved when 5 is XORed with 25, resulting in 28.\n\n    Hint: Use the Trie data structure to store and search for XOR prefixes.\n    \"\"\"\n    class TrieNode:\n        def __init__(self):\n            self.children = [None, None]\n\n    def insert(root, num):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if not node.children[bit]:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def find_max_xor(root, num):\n        node = root\n        xor = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if node.children[1 - bit]:\n                xor |= (1 << i)\n                node = node.children[1 - bit]\n            else:\n                node = node.children[bit]\n        return xor\n\n    root = TrieNode()\n    for num in nums:\n        insert(root, num)\n\n    max_xor = 0\n    for num in nums:\n        max_xor = max(max_xor, find_max_xor(root, num))\n\n    return max_xor\n\ndef g(nums=[3, 10, 5, 25, 2, 8]):\n    return [nums]\n\nassert f(*g()) == 28\n",
        "idx_generation": 158,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, find a subset of the list that sums up to the target value using bit manipulation.\n\n    Sample Input:\n    nums = [2, 4, 6, 8]\n    target = 10\n\n    Sample Output:\n    True\n\n    Explanation:\n    The subset [2, 8] sums up to the target value 10.\n    \"\"\"\n    n = len(nums)\n    for mask in range(1 << n):\n        subset = []\n        for i in range(n):\n            if mask & (1 << i):\n                subset.append(nums[i])\n        if sum(subset) == target:\n            return True\n    return False\n\ndef g(nums = [2, 4, 6, 8], target = 10):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 24,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the sum of all the even numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n\n    Output:\n    12\n\n    Explanation:\n    The even numbers in the list are 2, 4, and 6. Their sum is 12.\n    \"\"\"\n    even_sum = 0\n\n    for num in nums:\n        if num % 2 == 0:\n            even_sum += num\n\n    return even_sum\n\ndef g(nums=[1, 2, 3, 4, 5, 6]):\n    return [nums]\n\nassert f(*g()) == 12\n\n",
        "idx_generation": 451,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the factorial of a given number n.\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n    stack = [0] * (n + 1)\n    stack[0] = 1\n    for i in range(1, n + 1):\n        stack[i] = stack[i - 1] * i\n    return stack[n]\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 120\n\n",
        "idx_generation": 113,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there exists a subsequence of the list whose sum is equal to the target.\n    \"\"\"\n    stack = []\n    for num in nums:\n        stack.append(num)\n        while sum(stack) > target:\n            stack.pop(0)\n        if sum(stack) == target:\n            return True\n    return False\n\ndef g():\n    nums = [1, 3, 5, 7, 9]\n    target = 12\n    return nums, target\n\nassert f(*g())\n\n",
        "idx_generation": 42,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, target=10) -> bool:\n    \"\"\"Check if number 'n' can be obtained by performing arithmetic operations on the digits using recursion and stacks.\"\"\"\n    stack = []\n    def dfs(n, target):\n        if sum(stack) == target:\n            return True\n        elif sum(stack) > target:\n            stack.pop()\n        if n == 0:\n            return False\n        stack.append(n % 10)\n        return dfs(n // 10, target)\n    return dfs(n, target)\ndef g(target=10):\n    return 12345\nassert f(g()) == True\n",
        "idx_generation": 123,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum number of steps required to reach the bottom-right cell from the top-left cell.\n    You can only move down or right.\n\n    Sample input:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Sample output:\n    7\n\n    Explanation: The minimum number of steps to reach the bottom-right cell is 7 (1 + 3 + 1 + 1 + 1).\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g(grid: List[List[int]] = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return (grid,)\n\nassert f(*g()) == 7\n\n",
        "idx_generation": 62,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum of values along a path from the top-left corner to the bottom-right corner.\n\n    Example:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\n    Output:\n    7 (1 + 3 + 1 + 1 + 1 = 7)\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g():\n    \"\"\"\n    Generate a grid of random integers.\n    \"\"\"\n    return [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\nassert f(g()) == 7\n",
        "idx_generation": 384,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(m: int, n: int) -> bool:\n    \"\"\"\n    Check if there exists a path from top-left to bottom-right in a grid,\n    given that you can only move down or right.\n    \"\"\"\n    dp = [[False] * n for _ in range(m)]\n    dp[0][0] = True\n\n    for i in range(1, m):\n        dp[i][0] = True\n\n    for j in range(1, n):\n        dp[0][j] = True\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] or dp[i][j-1]\n\n    return dp[m-1][n-1]\n\ndef g(m: int, n: int) -> Tuple[int, int]:\n    \"\"\"\n    Find the dimensions of the grid with a path from top-left to bottom-right,\n    such that the number of paths is equal to m.\n    \"\"\"\n    dp = [[1] * n for _ in range(m)]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return (dp[m-1][n-1], m)\n\nm = 10\nn = 10\nassert f(*g(m, n))\n",
        "idx_generation": 39,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is possible to represent it as a sum of distinct powers of 2.\n\n    Sample input:\n    n = 10\n\n    Sample output:\n    True\n\n    Explanation: 10 can be represented as 2^1 + 2^3 = 2 + 8 = 10.\n    \"\"\"\n    powers = set()\n    for i in range(32):\n        powers.add(1 << i)\n    return any(n >= p and (n - p) in powers for p in powers)\n\ndef g(n=10):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 345,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique paths from the top-left cell to the bottom-right cell of an n x n grid.\n    You can only move down or right at any point in time.\n\n    Example:\n    Input: n = 3\n    Output: 6\n    Explanation: There are 6 unique paths from the top-left cell to the bottom-right cell of a 3 x 3 grid.\n\n    \"\"\"\n    def uniquePathsHelper(i: int, j: int, memo: List[List[int]]) -> int:\n        # Check if already computed\n        if memo[i][j] != -1:\n            return memo[i][j]\n        \n        # Base case: reached bottom-right cell\n        if i == n-1 and j == n-1:\n            return 1\n        \n        # Recursive cases: move down or right\n        downPaths = 0\n        rightPaths = 0\n        if i < n-1:\n            downPaths = uniquePathsHelper(i+1, j, memo)\n        if j < n-1:\n            rightPaths = uniquePathsHelper(i, j+1, memo)\n        \n        # Memoize the result\n        memo[i][j] = downPaths + rightPaths\n        \n        return memo[i][j]\n    \n    # Initialize memoization table\n    memo = [[-1] * n for _ in range(n)]\n    \n    return uniquePathsHelper(0, 0, memo)\n\ndef g() -> int:\n    n = 3\n    return n\n\nassert f(g()) == 6\n",
        "idx_generation": 452,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, t: str, graph = {'A': ['B', 'C'], 'B': ['C', 'D'], 'C': ['D'], 'D': []}) -> bool:\n    \"\"\"\n    Given a directed graph, represented as a dictionary where the keys are nodes and the values are lists of\n    the nodes that the key node points to, determine if there is a path from node s to node t.\n    \"\"\"\n    def dfs(node):\n        if node == t:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n        return False\n\n    visited = set()\n    return dfs(s)\n    \ndef g(graph = {'A': ['B', 'C'], 'B': ['C', 'D'], 'C': ['D'], 'D': []}):\n    s = 'A'\n    t = 'D'\n    return s, t\n\nassert f(*g()) == True\n",
        "idx_generation": 244,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> bool:\n    \"\"\"\n    Check if the given grid represents a valid path from start to end.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    stack = [(0, 0)]\n    visited = set()\n    \n    while stack:\n        i, j = stack.pop()\n        visited.add((i, j))\n        \n        if i == m - 1 and j == n - 1:\n            return True\n        \n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            x, y = i + dx, j + dy\n            if 0 <= x < m and 0 <= y < n and grid[x][y] != '#' and (x, y) not in visited:\n                stack.append((x, y))\n    \n    return False\n\ndef g() -> List[List[str]]:\n    grid = [\n        ['S', '.', '.', '#', '.', '.', '.'],\n        ['#', '#', '.', '#', '.', '#', '.'],\n        ['.', '#', '.', '.', '.', '#', '.'],\n        ['.', '#', '#', '#', '#', '#', '.'],\n        ['.', '.', '.', '.', '.', '#', 'E']\n    ]\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 131,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, determine the area of the largest island (connected component of 1s) in the grid.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    max_area = 0\n\n    def dfs(row: int, col: int) -> int:\n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] != 1:\n            return 0\n\n        grid[row][col] = -1\n        area = 1\n\n        area += dfs(row + 1, col)\n        area += dfs(row - 1, col)\n        area += dfs(row, col + 1)\n        area += dfs(row, col - 1)\n\n        return area\n\n    for row in range(rows):\n        for col in range(cols):\n            if grid[row][col] == 1:\n                max_area = max(max_area, dfs(row, col))\n\n    return max_area\n\ndef g():\n    # Creating a grid\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 0, 1, 1],\n        [0, 0, 0, 1, 1]\n    ]\n\n    return grid\n\nassert f(g()) == 4\n",
        "idx_generation": 118,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int:\n    \"\"\"\n    Given a grid of integers representing a maze, find the minimum number of steps required to reach the end position from the start position.\n    You can only move up, down, left, or right, and you cannot move through walls (represented by 1).\n\n    Example:\n    Input:\n    grid = [[0, 0, 0, 0, 0],\n            [0, 1, 1, 1, 0],\n            [0, 0, 0, 0, 0],\n            [0, 0, 1, 1, 1],\n            [0, 0, 0, 0, 0]]\n    start = (0, 0)\n    end = (4, 4)\n\n    Output:\n    8\n\n    Explanation:\n    The minimum number of steps required to reach the end position (4, 4) from the start position (0, 0) is 8.\n    \"\"\"\n\n    def bfs(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int:\n        queue = [(start, 0)]\n        visited = set()\n\n        while queue:\n            current, steps = queue.pop(0)\n            row, col = current\n\n            if current == end:\n                return steps\n\n            if current in visited:\n                continue\n\n            visited.add(current)\n\n            for direction in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_row, new_col = row + direction[0], col + direction[1]\n\n                if 0 <= new_row < len(grid) and 0 <= new_col < len(grid[0]) and grid[new_row][new_col] != 1:\n                    queue.append(((new_row, new_col), steps + 1))\n\n        return -1\n\n    return bfs(grid, start, end)\n\ndef g() -> Tuple[List[List[int]], Tuple[int, int], Tuple[int, int]]:\n    \"\"\"\n    Generate a grid, start position, and end position.\n    \"\"\"\n    return ([[0, 0, 0, 0, 0],\n             [0, 1, 1, 1, 0],\n             [0, 0, 0, 0, 0],\n             [0, 0, 1, 1, 1],\n             [0, 0, 0, 0, 0]], (0, 0), (4, 4))\n\nassert f(*g()) == 8\n",
        "idx_generation": 474,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(words: List[str], target_word=\"apple\") -> bool:\n    \"\"\"\n    Find the shortest path from the start word to the target word by changing one letter at a time.\n    \"\"\"\n    def is_adjacent(word1, word2):\n        diff_count = 0\n        for i in range(len(word1)):\n            if word1[i] != word2[i]:\n                diff_count += 1\n        return diff_count == 1\n\n    def find_shortest_path(words, start_word, target_word, visited):\n        if start_word == target_word:\n            return 0\n        visited.add(start_word)\n        shortest_path = float('inf')\n        for word in words:\n            if word not in visited and is_adjacent(start_word, word):\n                path_length = find_shortest_path(words, word, target_word, visited)\n                shortest_path = min(shortest_path, path_length + 1)\n        visited.remove(start_word)\n        return shortest_path\n\n    return find_shortest_path(words, words[0], target_word, set()) > 0\n\ndef g(target_word=\"apple\"):\n    return [\"ample\", \"apply\", \"apple\", \"ample\", \"ample\"]\n\nassert f(g()) == True\n",
        "idx_generation": 3,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start='A', end='C') -> bool:\n    \"\"\"Find the shortest path between two nodes in a directed graph\"\"\"\n    queue = [(start, 0)]\n    visited = set()\n    while queue:\n        node, distance = queue.pop(0)\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                queue.append((neighbor, distance + 1))\n    return False\n\ndef g(start='A', end='C'):\n    return {'A': ['B', 'C'], 'B': ['C'], 'C': ['A']}\n\nassert f(g()) == True\n",
        "idx_generation": 43,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between two numbers in the list.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The maximum XOR value between two numbers in the list.\n    \"\"\"\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.is_end = False\n\n    def insert(num, root):\n        node = root\n\n        for bit in range(31, -1, -1):\n            curr_bit = (num >> bit) & 1\n\n            if curr_bit not in node.children:\n                node.children[curr_bit] = TrieNode()\n\n            node = node.children[curr_bit]\n\n        node.is_end = True\n\n    def search(num, root):\n        node = root\n        xor_val = 0\n\n        for bit in range(31, -1, -1):\n            curr_bit = (num >> bit) & 1\n            opposite_bit = 1 - curr_bit\n\n            if opposite_bit in node.children:\n                xor_val |= (1 << bit)\n                node = node.children[opposite_bit]\n            else:\n                node = node.children[curr_bit]\n\n        return xor_val\n\n    root = TrieNode()\n    max_xor = 0\n\n    for num in nums:\n        insert(num, root)\n        max_xor = max(max_xor, search(num, root))\n\n    return max_xor\n\ndef g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n",
        "idx_generation": 271,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef f(root: Node, target=10) -> bool:\n    \"\"\"\n    Determine if there exists a path from the root to a leaf node in a binary tree that sums up to the target.\n    \"\"\"\n\n    def find_path(node, current_sum):\n        if node is None:\n            return False\n        current_sum += node.val\n        if node.left is None and node.right is None:\n            return current_sum == target\n        return find_path(node.left, current_sum) or find_path(node.right, current_sum)\n\n    return find_path(root, 0)\n\ndef g(target=10):\n    root = Node(5)\n    root.left = Node(3)\n    root.right = Node(7)\n    root.left.left = Node(2)\n    root.left.right = Node(4)\n    root.right.left = Node(6)\n    root.right.right = Node(8)\n    return root\n\nassert f(g()) == True\n",
        "idx_generation": 54,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target sum, find all unique combinations of numbers in the list that add up to the target.\n\n    Example:\n    nums = [2, 3, 6, 7]\n    target = 7\n\n    Output:\n    [[2, 2, 3], [7]]\n\n    Explanation:\n    The combinations [2, 2, 3] and [7] are the unique combinations that add up to the target sum of 7.\n\n    Hint: Use backtracking to generate all possible combinations.\n    \"\"\"\n\n    def backtrack(nums, target, path, res, start):\n        if target < 0:\n            return\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(start, len(nums)):\n            backtrack(nums, target - nums[i], path + [nums[i]], res, i)\n\n    res = []\n    nums.sort()\n    backtrack(nums, target, [], res, 0)\n\n    return res\n\ndef g() -> List:\n    nums = [2, 3, 6, 7]\n    target = 7\n    return [nums, target]\n\nassert f(*g()) == [[2, 2, 3], [7]]\n",
        "idx_generation": 439,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Given an integer n and a positive integer k, generate all possible combinations of k numbers out of the range [1, n].\n\n    Example:\n    n = 4\n    k = 2\n\n    Output:\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n\n    Hint: Use recursion and a backtracking approach to generate all combinations.\n    \"\"\"\n\n    def backtrack(start, curr_comb):\n        if len(curr_comb) == k:\n            result.append(curr_comb[:])\n            return\n        \n        for num in range(start, n + 1):\n            curr_comb.append(num)\n            backtrack(num + 1, curr_comb)\n            curr_comb.pop()\n\n    result = []\n    backtrack(1, [])\n    return result\n\ndef g():\n    return (4, 2)\n\nassert f(*g()) == [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n",
        "idx_generation": 100,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid. You can only move right or down at any point in time.\n\n    Example:\n    n = 3\n\n    Output:\n    6\n\n    Explanation:\n    There are 6 unique paths from the top-left corner to the bottom-right corner of a 3 x 3 grid.\n\n    Constraints:\n    - The input integer n will always be non-negative.\n    \"\"\"\n\n    def factorial(num):\n        if num == 0 or num == 1:\n            return 1\n        return num * factorial(num - 1)\n\n    return factorial(2 * n - 2) // (factorial(n - 1) * factorial(n - 1))\n\ndef g(n=3):\n    return n\n\nassert f(g()) == 6\n\n",
        "idx_generation": 356,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of pairs (i, j) where i < j and nums[i] + nums[j] is a power of 2.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The pairs (0, 2) and (1, 3) have a sum of 4, which is a power of 2. So the output should be 2.\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] + nums[j]) & (nums[i] + nums[j] - 1) == 0:\n                count += 1\n    return count\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return (nums,)\n\nassert f(*g()) == 2\n",
        "idx_generation": 498,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR value between two numbers in the array.\n\n    Example:\n    arr = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value between two numbers in the array is 28, which is the result of 25 XOR 5.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(32, -1, -1):\n        mask |= (1 << i)\n        prefixes = set()\n        for num in arr:\n            prefixes.add(num & mask)\n        target_xor = max_xor | (1 << i)\n        for prefix in prefixes:\n            if (prefix ^ target_xor) in prefixes:\n                max_xor = target_xor\n                break\n    return max_xor\n\ndef g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n\n",
        "idx_generation": 478,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, return the index of the target value if it is found in the list. \n    If the target value is not found, return -1.\n\n    Args:\n    - nums: A sorted list of integers.\n    - target: The target value to search for.\n\n    Returns:\n    - The index of the target value in the list, or -1 if it is not found.\n    \"\"\"\n    low = 0\n    high = len(nums) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1\n\ndef g():\n    nums = [1, 3, 5, 7, 9, 11, 13, 15]\n    target = 7\n    return (nums, target)\n\nassert f(*g()) == 3\n",
        "idx_generation": 452,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nimport math\n\ndef f(x: int, n=4) -> bool:\n    \"\"\"Check if x is a perfect square and its square root is divisible by n\"\"\"\n    sqrt_x = math.isqrt(x)\n    return sqrt_x * sqrt_x == x and sqrt_x % n == 0\n\ndef g(n=4):\n    x = n * n\n    return x\n\nassert f(g()) == True\n",
        "idx_generation": 48,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers, determine if there exists two numbers in the array whose sum is equal to the given target.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9], 10\n\nassert f(*g()) == True\n",
        "idx_generation": 52,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list using the merge sort algorithm.\n\n    Example:\n    arr = [5, 2, 8, 4, 1]\n\n    Output:\n    [1, 2, 4, 5, 8]\n\n    Explanation:\n    The list is sorted in ascending order.\n    \"\"\"\n    def merge_sort(arr: List[int]) -> List[int]:\n        if len(arr) <= 1:\n            return arr\n\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        left_half = merge_sort(left_half)\n        right_half = merge_sort(right_half)\n\n        return merge(left_half, right_half)\n\n    def merge(left: List[int], right: List[int]) -> List[int]:\n        merged = []\n        left_index = 0\n        right_index = 0\n\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n\n        return merged\n\n    return merge_sort(arr)\n\ndef g(arr=[5, 2, 8, 4, 1]):\n    return arr\n\nassert f(g()) == [1, 2, 4, 5, 8]\n\n",
        "idx_generation": 467,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine if a given number n is a perfect square. This function uses a recursive approach to perform a binary search \n    for the square root of n and checks if the square of the integer is equal to n.\n    \"\"\"\n    def search(left: int, right: int) -> bool:\n        if left > right:\n            return False\n        \n        mid = (left + right) // 2\n        square = mid * mid\n        \n        if square == n:\n            return True\n        elif square < n:\n            return search(mid + 1, right)\n        else:\n            return search(left, mid - 1)\n    \n    return search(0, n)\n\ndef g(n: int = 25):\n    \"\"\"\n    Generate a number n for the function f.\n    \"\"\"\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 26,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum of numbers along a path from the top-left cell to the\n    bottom-right cell. You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum sum path is 1 -> 3 -> 1 -> 1 -> 1, which gives a sum of 7.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g(grid: List[List[int]] = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return (grid,)\n\nassert f(*g()) == 7\n",
        "idx_generation": 125,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the maximum area of a rectangle that can be formed by 1s in the grid.\n\n    Args:\n    - grid: A 2D grid of 0s and 1s.\n\n    Returns:\n    - The maximum area of a rectangle that can be formed by 1s in the grid.\n\n    Example:\n    grid = [\n        [1, 0, 1, 1, 1],\n        [0, 1, 1, 1, 1],\n        [1, 1, 1, 0, 1]\n    ]\n\n    Output:\n    6\n\n    Explanation:\n    The maximum area of a rectangle that can be formed by 1s in the grid is 6.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    heights = [0] * cols\n    max_area = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 0:\n                heights[j] = 0\n            else:\n                heights[j] += 1\n\n        max_area = max(max_area, largestRectangleArea(heights))\n\n    return max_area\n\ndef largestRectangleArea(heights: List[int]) -> int:\n    stack = []\n    max_area = 0\n\n    i = 0\n    while i < len(heights):\n        if not stack or heights[i] >= heights[stack[-1]]:\n            stack.append(i)\n            i += 1\n        else:\n            top = stack.pop()\n            area = heights[top] * (i if not stack else i - stack[-1] - 1)\n            max_area = max(max_area, area)\n\n    while stack:\n        top = stack.pop()\n        area = heights[top] * (i if not stack else i - stack[-1] - 1)\n        max_area = max(max_area, area)\n\n    return max_area\n\ndef g():\n    grid = [\n        [1, 0, 1, 1, 1],\n        [0, 1, 1, 1, 1],\n        [1, 1, 1, 0, 1]\n    ]\n    return grid\n\nassert f(g()) == 6\n\n",
        "idx_generation": 422,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given an array of integers, find if there exists a subarray with a sum equal to the target value.\n    \"\"\"\n    n = len(arr)\n    prefix_sum = [0] * (n+1)\n    for i in range(1, n+1):\n        prefix_sum[i] = prefix_sum[i-1] + arr[i-1]\n    \n    stack = []\n    for i in range(n+1):\n        while stack and prefix_sum[i] - prefix_sum[stack[0]] > target:\n            stack.pop(0)\n        if stack and prefix_sum[i] - prefix_sum[stack[0]] == target:\n            return True\n        stack.append(i)\n    \n    return False\n\ndef g(target: int = 10):\n    return [4, 3, -1, 2, 1, -3]\n\nassert f(g(), 4)\n",
        "idx_generation": 44,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR value between any two numbers in the array.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The maximum XOR value between any two numbers in the array.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n\n        for num in nums:\n            prefix_set.add(num & mask)\n\n        temp_max_xor = max_xor | (1 << i)\n\n        for prefix in prefix_set:\n            if (temp_max_xor ^ prefix) in prefix_set:\n                max_xor = temp_max_xor\n                break\n\n    return max_xor\n\ndef g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n",
        "idx_generation": 128,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return a list containing all the elements of the matrix in spiral order.\n\n    Example:\n    matrix = [\n        [ 1, 2, 3 ],\n        [ 4, 5, 6 ],\n        [ 7, 8, 9 ]\n    ]\n\n    Output:\n    [1, 2, 3, 6, 9, 8, 7, 4, 5]\n    \"\"\"\n    if not matrix:\n        return []\n\n    result = []\n    rows, cols = len(matrix), len(matrix[0])\n    top, bottom, left, right = 0, rows-1, 0, cols-1\n\n    while top <= bottom and left <= right:\n        for i in range(left, right+1):\n            result.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom+1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        if top <= bottom:\n            for i in range(right, left-1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left <= right:\n            for i in range(bottom, top-1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result\n\ndef g():\n    matrix = [\n        [ 1, 2, 3 ],\n        [ 4, 5, 6 ],\n        [ 7, 8, 9 ]\n    ]\n    return matrix\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n",
        "idx_generation": 200,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target=6) -> bool:\n    \"\"\"Find a pair of numbers in a list that XOR to the given target\"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while left < right:\n        xor = nums[left] ^ nums[right]\n        if xor == target:\n            return True\n        elif xor < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums=[1, 3, 2, 5, 4]):\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 1,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if there exists a subset of numbers from the given list such that the XOR of all numbers in the subset is 0.\"\"\"\n\n    def helper(index, curr_sum):\n        if curr_sum == 0:\n            return True\n        if index >= len(nums):\n            return False\n        return helper(index+1, curr_sum) or helper(index+1, curr_sum ^ nums[index])\n\n    return helper(0, 0)\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 51,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all numbers that are multiples of either 3 or 5.\n\n    Example:\n    nums = [3, 5, 6, 9, 10, 12, 15]\n    The multiples of 3 or 5 are 3, 5, 6, 9, 10, 12, 15.\n    The sum of these numbers is 60.\n\n    Return the sum of all numbers that are multiples of either 3 or 5.\n\n    Hint: Use mathematical foundations and bit manipulation to solve this problem.\n    \"\"\"\n    sum_multiples = 0\n\n    for num in nums:\n        if num % 3 == 0 or num % 5 == 0:\n            sum_multiples += num\n\n    return sum_multiples\n\ndef g():\n    return [3, 5, 6, 9, 10, 12, 15]\n\nassert f(g()) == 60\n\n",
        "idx_generation": 477,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two numbers in the list.\n\n    Example:\n    arr = [1, 4, 2, 3]\n\n    Output:\n    12\n\n    Explanation:\n    The maximum product of any two numbers in the list is 4 * 3 = 12.\n\n    Hint: Sort the list in descending order and multiply the first two elements.\n    \"\"\"\n\n    arr.sort(reverse=True)\n    return arr[0] * arr[1]\n\ndef g() -> List[int]:\n    return [1, 4, 2, 3]\n\nassert f(g()) == 12\n",
        "idx_generation": 194,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers and a target value, find the index of the target in the array. If the target is not found, return -1.\n\n    Example:\n    nums = [-1, 0, 3, 5, 9, 12]\n    target = 9\n\n    Output:\n    4 (since the target value 9 is found at index 4 in the array)\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> List[int]:\n    return [-1, 0, 3, 5, 9, 12]\n\nassert f(g(), 9) == 4\n\n",
        "idx_generation": 303,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(points: List[Tuple[int, int]]) -> float:\n    \"\"\"\n    Calculate the area of a triangle given its three vertices.\n\n    Example:\n    points = [(0, 0), (3, 0), (0, 4)]\n\n    Output:\n    6.0\n\n    Explanation:\n    The area of the triangle with vertices (0, 0), (3, 0), and (0, 4) is 6.0.\n    \"\"\"\n    x1, y1 = points[0]\n    x2, y2 = points[1]\n    x3, y3 = points[2]\n    return abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2)\n\ndef g():\n    return [(0, 0), (3, 0), (0, 4)]\n\nassert f(g()) == 6.0\n",
        "idx_generation": 405,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the count of total set bits in all numbers from 1 to n.\n\n    Example:\n    n = 5\n\n    Output:\n    7\n\n    Explanation:\n    The numbers from 1 to 5 (inclusive) are 1, 2, 3, 4, 5.\n    The binary representation of these numbers are 1, 10, 11, 100, 101.\n    The total count of set bits in these binary representations is 7.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        count += bin(i).count('1')\n    \n    return count\n\ndef g() -> int:\n    \"\"\"\n    Generate a random positive integer.\n    \"\"\"\n    return 10\n\nassert f(g()) == 17\n\n",
        "idx_generation": 352,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of integers, return the sum of all elements in the grid.\n\n    Sample Input:\n    [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Sample Output:\n    45\n    \"\"\"\n    return sum(sum(row) for row in grid)\n\ndef g():\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g()) == 45\n",
        "idx_generation": 82,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if a number is a power of 4.\n    \"\"\"\n    return (n > 0) and ((n & (n - 1)) == 0) and (n & 0xAAAAAAAA) == 0\ndef g():\n    \"\"\"\n    Find the largest power of 4 that is less than 1000.\n    \"\"\"\n    n = 4\n    while (n * 4) < 1000:\n        n *= 4\n    return n\nassert f(g()) == True\n",
        "idx_generation": 8,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a 2D grid of integers and a target value, determine if the target value exists in the grid.\n    The grid is sorted in non-decreasing order from left to right and top to bottom.\n\n    Example:\n    grid = [\n        [1, 3, 5, 7],\n        [10, 11, 16, 20],\n        [23, 30, 34, 50]\n    ]\n    target = 3\n\n    Output:\n    True\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    # Start from the top-right corner of the grid\n    i = 0\n    j = n - 1\n    \n    while i < m and j >= 0:\n        if grid[i][j] == target:\n            return True\n        elif grid[i][j] < target:\n            i += 1\n        else:\n            j -= 1\n    \n    return False\n\ndef g():\n    return ([\n        [1, 3, 5, 7],\n        [10, 11, 16, 20],\n        [23, 30, 34, 50]\n    ], 3)\n\nassert f(*g())\n",
        "idx_generation": 37,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Check if a given grid is symmetric along its main diagonal.\n    Return True if the grid is symmetric, False otherwise.\n    \"\"\"\n    n = len(grid)\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if grid[i][j] != grid[j][i]:\n                return False\n\n    return True\n\ndef g(grid: List[List[int]] = [[1, 2, 3], [2, 4, 5], [3, 5, 6]]) -> List[List[int]]:\n    \"\"\"\n    Return the input grid.\n    \"\"\"\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 114,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size m x n, where each cell contains a non-negative integer,\n    find the minimum sum path from the top-left cell to the bottom-right cell.\n\n    The minimum sum path is defined as the path that minimizes the sum of the values\n    in the cells visited, while only moving down or right in the grid.\n\n    Return the minimum sum.\n\n    Example:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum sum path is 1 -> 3 -> 1 -> 1 -> 1, which gives a total sum of 7.\n    \"\"\"\n\n    def min_sum_path(grid, i, j, memo):\n        if i == 0 and j == 0:\n            return grid[i][j]\n        if i < 0 or j < 0:\n            return float('inf')\n        if (i, j) in memo:\n            return memo[(i, j)]\n        memo[(i, j)] = grid[i][j] + min(min_sum_path(grid, i-1, j, memo), min_sum_path(grid, i, j-1, memo))\n        return memo[(i, j)]\n\n    m = len(grid)\n    n = len(grid[0])\n    return min_sum_path(grid, m-1, n-1, {})\n\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    \"\"\"\n    Generate a grid of size m x n with random non-negative integers.\n    \"\"\"\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 66,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of integers, determine if it forms a square.\n    A square is a quadrilateral with four equal sides and four right angles.\n\n    Example:\n    grid = [[1, 1, 1, 1],\n            [1, 1, 1, 1],\n            [1, 1, 1, 1],\n            [1, 1, 1, 1]]\n\n    Output:\n    True\n\n    Explanation:\n    The grid forms a square, as all rows have the same length and all columns have the same length, \n    and the number of rows and columns are equal.\n    \"\"\"\n\n    # Check if the grid is empty\n    if len(grid) == 0 or len(grid[0]) == 0:\n        return False\n\n    # Get the length of the first row\n    row_length = len(grid[0])\n\n    # Check if all rows have the same length\n    for row in grid:\n        if len(row) != row_length:\n            return False\n\n    # Check if all columns have the same length\n    col_length = len(grid)\n    for col in zip(*grid):\n        if len(col) != col_length:\n            return False\n\n    # Check if the number of rows and columns are equal\n    if len(grid) != len(grid[0]):\n        return False\n\n    return True\n\ndef g():\n    grid = [[1, 1, 1, 1],\n            [1, 1, 1, 1],\n            [1, 1, 1, 1],\n            [1, 1, 1, 1]]\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 185,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if they are isomorphic.\n    Two strings are isomorphic if the characters in s can be replaced to get t.\n\n    Example:\n    s = \"egg\"\n    t = \"add\"\n\n    Output:\n    True\n\n    Explanation:\n    'e' can be replaced with 'a' and 'g' can be replaced with 'd' to get the string 'add'.\n    \"\"\"\n    if len(s) != len(t):\n        return False\n\n    s_to_t = {}\n    t_to_s = {}\n\n    for i in range(len(s)):\n        if s[i] in s_to_t and s_to_t[s[i]] != t[i]:\n            return False\n        if t[i] in t_to_s and t_to_s[t[i]] != s[i]:\n            return False\n        s_to_t[s[i]] = t[i]\n        t_to_s[t[i]] = s[i]\n\n    return True\n\ndef g():\n    s = \"egg\"\n    t = \"add\"\n    return (s, t)\n\nassert f(*g()) == True\n\n",
        "idx_generation": 337,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"\n    Determine if it is possible to split the string into k non-empty substrings, where each substring is a\n    palindrome.\n    \"\"\"\n    if k == 1:\n        return s == s[::-1]\n    if k > len(s):\n        return False\n\n    def is_palindrome(sub: str) -> bool:\n        return sub == sub[::-1]\n\n    def backtrack(start: int, count: int) -> bool:\n        if count == k:\n            return True\n        for i in range(start, len(s)):\n            sub = s[start:i+1]\n            if is_palindrome(sub) and backtrack(i+1, count+1):\n                return True\n        return False\n\n    return backtrack(0, 0)\n\ndef g(s: str, k: int) -> str:\n    \"\"\"\n    Generate a string that can be split into k non-empty palindromic substrings.\n    \"\"\"\n    if k == 1:\n        return s\n    if k > len(s):\n        return \"\"\n\n    def generate_palindrome(length: int) -> str:\n        return \"a\" * length\n\n    return generate_palindrome(len(s) // k) * k\n\nassert f(g(\"aaaa\", 2), 2)\n",
        "idx_generation": 124,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, rotate the matrix 90 degrees clockwise.\n    \"\"\"\n    n = len(matrix)\n    rotated_matrix = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        for j in range(n):\n            rotated_matrix[j][n-i-1] = matrix[i][j]\n\n    return rotated_matrix\n\ndef g():\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\nassert f(g()) == [[7, 4, 1],\n                  [8, 5, 2],\n                  [9, 6, 3]]\n",
        "idx_generation": 122,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value k, determine if there exists a sublist of the given list\n    whose XOR of elements is equal to k.\n    \"\"\"\n    prefix_xor = 0\n    xor_set = set()\n    for num in nums:\n        prefix_xor ^= num\n        if prefix_xor == k or (prefix_xor ^ k) in xor_set:\n            return True\n        xor_set.add(prefix_xor)\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), 9)\n",
        "idx_generation": 87,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    24\n\n    Explanation:\n    The maximum product of three numbers in the list is 2*3*4 = 24.\n\n    Hint: Sort the list in ascending order and consider the cases where the maximum product involves either the two smallest numbers and the largest number or the three largest numbers.\n    \"\"\"\n    nums.sort()\n\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\n\ndef g(nums: List[int] = [1, 2, 3, 4]):\n    return (nums,)\n\nassert f(*g()) == 24\n\n",
        "idx_generation": 467,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine if a number is a prime number.\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    \"\"\"\n    Generate a prime number.\n    \"\"\"\n    return 17\n\nassert f(g()) == True\n",
        "idx_generation": 98,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, return True if there exists a sublist in the list that sums up to zero.\n    \"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum in prefix_sums or prefix_sum == 0:\n            return True\n        prefix_sums.add(prefix_sum)\n    return False\n\ndef g(nums = [1, -2, 3, 4, -5]):\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 395,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nimport numpy as np\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if it is a magic square.\n\n    A magic square is a square matrix in which the sum of every row, every column, and both diagonals is the same.\n\n    Example:\n    matrix = [\n        [2, 7, 6],\n        [9, 5, 1],\n        [4, 3, 8]\n    ]\n\n    Output:\n    True\n\n    Explanation:\n    The sums of every row, every column, and both diagonals are all equal to 15.\n\n    Hint: Use numpy arrays to perform element-wise operations and calculate sums efficiently.\n    \"\"\"\n    matrix = np.array(matrix)\n    target_sum = np.sum(matrix[0, :])\n\n    # Check rows\n    if not all(np.sum(row) == target_sum for row in matrix):\n        return False\n\n    # Check columns\n    if not all(np.sum(column) == target_sum for column in matrix.T):\n        return False\n\n    # Check diagonals\n    if np.trace(matrix) != target_sum or np.trace(np.fliplr(matrix)) != target_sum:\n        return False\n\n    return True\n\ndef g():\n    matrix = [\n        [2, 7, 6],\n        [9, 5, 1],\n        [4, 3, 8]\n    ]\n    return matrix\n\nassert f(g()) == True\n",
        "idx_generation": 202,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Example:\n    arr = [1, 2, 3, 4]\n\n    Output:\n    12\n\n    Explanation:\n    The maximum product is achieved by multiplying 3 and 4, which results in 12.\n    \"\"\"\n\n    max_product = float('-inf')\n\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            product = arr[i] * arr[j]\n            max_product = max(max_product, product)\n\n    return max_product\n\ndef g():\n    arr = [1, 2, 3, 4]\n    return arr\n\nassert f(g()) == 12\n\n",
        "idx_generation": 395,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the target number in the list.\n    Return the index of the target number in the list.\n\n    Args:\n    - nums: A sorted list of integers.\n    - target: The target number.\n\n    Returns:\n    - The index of the target number in the list, or -1 if the target number is not found.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(nums = [1, 2, 3, 4, 5], target = 3):\n    return [1, 2, 3, 4, 5], 3\n\nassert f(*g()) == 2\n",
        "idx_generation": 258,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target integer k, determine if there exists a subarray with a sum divisible by k.\n    \"\"\"\n    if not nums:\n        return False\n    \n    n = len(nums)\n    prefix_sum = [0]\n    \n    for num in nums:\n        prefix_sum.append((prefix_sum[-1] + num) % k)\n    \n    seen = {}\n    \n    for i in range(n + 1):\n        if prefix_sum[i] in seen:\n            if i - seen[prefix_sum[i]] > 1:\n                return True\n        else:\n            seen[prefix_sum[i]] = i\n    \n    return False\n\ndef g():\n    return [4, 3, 2, 7, 8, 9], 6\n\nassert f(*g())\n",
        "idx_generation": 248,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Find if there exists a duplicate number in the given list\"\"\"\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(nums: List[int]):\n    return nums\n\nassert f(g([1, 2, 3, 4, 5, 5]))\n",
        "idx_generation": 75,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of distinct pairs with a specific sum.\n\n    Return the number of distinct pairs.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    2\n\n    Explanation:\n    There are two distinct pairs with a sum of 6: (1, 5) and (2, 4).\n    \"\"\"\n    count = 0\n    seen = set()\n\n    for num in nums:\n        complement = 6 - num\n        if complement in seen:\n            count += 1\n        seen.add(num)\n\n    return count\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 2\n\n",
        "idx_generation": 254,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, count the number of occurrences of a specific character in the grid.\n    \"\"\"\n    count = 0\n    target = 'a' # Change the target character here\n    for row in grid:\n        count += row.count(target)\n    return count\n\ndef g():\n    grid = [\n        ['a', 'b', 'c'],\n        ['d', 'e', 'f'],\n        ['g', 'h', 'i']\n    ]\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 35,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if the grid can be filled with numbers from 1 to n, where each row and column must contain unique numbers.\"\"\"\n    n = len(grid)\n    for i in range(n):\n        row_set = set()\n        col_set = set()\n        for j in range(n):\n            if grid[i][j] in row_set or grid[j][i] in col_set:\n                return False\n            row_set.add(grid[i][j])\n            col_set.add(grid[j][i])\n    return True\n\ndef g(grid=[[1, 2, 3],\n            [2, 3, 1],\n            [3, 1, 2]]):\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 388,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the sum of the digits of its binary representation.\n\n    Example:\n    n = 10\n\n    Output:\n    2 (since the binary representation of 10 is 1010 and the sum of its digits is 2)\n    \"\"\"\n    binary = bin(n)[2:]\n    return sum(int(digit) for digit in binary)\n\ndef g() -> int:\n    return 10\n\nassert f(g()) == 2\n",
        "idx_generation": 360,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort them in non-decreasing order using the counting sort algorithm.\n    \"\"\"\n\n    min_num = min(nums)\n    max_num = max(nums)\n    count = [0] * (max_num - min_num + 1)\n\n    for num in nums:\n        count[num - min_num] += 1\n\n    output = []\n    for i in range(len(count)):\n        output.extend([i + min_num] * count[i])\n\n    return output\n\ndef g(nums=[5, 2, 9, 1, 7, 6]):\n    \"\"\"\n    Generate a list of numbers to be sorted using counting sort.\n    \"\"\"\n    return nums\n\nassert f(g()) == [1, 2, 5, 6, 7, 9]\n",
        "idx_generation": 126,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, return True if n is a prime number. Otherwise, return False.\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n",
        "idx_generation": 33,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"\n    Determine if there exists a contiguous subarray in the given list, such that the sum of the elements in the\n    subarray is divisible by k.\n\n    Example:\n    arr = [4, 5, 7, 2, 3, 8]\n    k = 6\n    Output: True\n    Explanation: The subarray [5, 7, 2, 3] has a sum of 17 which is divisible by 6.\n\n    \"\"\"\n    assert len(arr) >= 1\n    assert 1 <= k <= 100\n    for i in range(len(arr)):\n        for j in range(i, len(arr)):\n            subarray = arr[i:j+1]\n            if sum(subarray) % k == 0:\n                return True\n    return False\ndef g(k=6):\n    arr = [4, 5, 7, 2, 3, 8]\n    return arr\nassert f(g(), k=6)\n",
        "idx_generation": 11,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if it is a magic square.\n\n    A magic square is a square matrix in which the sums of each row, each column, and both diagonals are all equal.\n\n    Example:\n    matrix = [[2, 7, 6],\n              [9, 5, 1],\n              [4, 3, 8]]\n\n    Output:\n    True\n\n    Explanation:\n    The sums of each row, each column, and both diagonals are all equal to 15.\n    \"\"\"\n\n    n = len(matrix)\n\n    # Calculate the sum of the first row\n    target_sum = sum(matrix[0])\n\n    # Check if the sum of each row is equal to the target sum\n    for i in range(1, n):\n        if sum(matrix[i]) != target_sum:\n            return False\n\n    # Check if the sum of each column is equal to the target sum\n    for j in range(n):\n        column_sum = sum(matrix[i][j] for i in range(n))\n        if column_sum != target_sum:\n            return False\n\n    # Check if the sum of the main diagonal is equal to the target sum\n    main_diagonal_sum = sum(matrix[i][i] for i in range(n))\n    if main_diagonal_sum != target_sum:\n        return False\n\n    # Check if the sum of the secondary diagonal is equal to the target sum\n    secondary_diagonal_sum = sum(matrix[i][n-i-1] for i in range(n))\n    if secondary_diagonal_sum != target_sum:\n        return False\n\n    return True\n\ndef g() -> List[List[int]]:\n    return [[2, 7, 6],\n            [9, 5, 1],\n            [4, 3, 8]]\n\nassert f(g()) == True\n",
        "idx_generation": 120,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a square matrix of size n x n, check if each row, column, and diagonal adds up to the same sum.\n    \"\"\" \n    target_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check columns\n    for j in range(n):\n        col_sum = 0\n        for i in range(n):\n            col_sum += matrix[i][j]\n        if col_sum != target_sum:\n            return False\n    \n    # Check main diagonal\n    diag_sum = 0\n    for i in range(n):\n        diag_sum += matrix[i][i]\n    if diag_sum != target_sum:\n        return False\n    \n    # Check secondary diagonal\n    diag_sum = 0\n    for i in range(n):\n        diag_sum += matrix[i][n-i-1]\n    if diag_sum != target_sum:\n        return False\n    \n    return True\n\ndef g() -> Tuple[int, List[List[int]]]:\n    n = 3\n    matrix = [\n        [4, 9, 2],\n        [3, 5, 7],\n        [8, 1, 6]\n    ]\n    return n, matrix\n\nassert f(*g()) == True\n",
        "idx_generation": 443,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Calculate the sum of all odd numbers in a given list of integers.\"\"\"\n    sum = 0\n    for num in nums:\n        if num % 2 == 1:\n            sum += num\n    return sum\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return nums\n\nassert f(g()) == 25\n",
        "idx_generation": 107,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[List[int]]) -> int:\n    \"\"\"\n    Given a list of lists representing a matrix, find the sum of all the elements in the matrix.\n\n    Sample input:\n    arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n    Sample output:\n    45\n    \"\"\"\n    total_sum = 0\n    \n    for row in arr:\n        for element in row:\n            total_sum += element\n    \n    return total_sum\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 45\n",
        "idx_generation": 25,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid, find the maximum XOR value that can be obtained by performing XOR operation on two elements in the grid.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    max_xor = 0\n    for r1 in range(rows):\n        for c1 in range(cols):\n            for r2 in range(rows):\n                for c2 in range(cols):\n                    xor = grid[r1][c1] ^ grid[r2][c2]\n                    if xor > max_xor:\n                        max_xor = xor\n\n    return max_xor\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid with random numbers.\n    \"\"\"\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\nassert f(g()) == 15\n",
        "idx_generation": 330,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Maximum XOR of Two Numbers in an Array\n\n    Given a list of integers nums, find the maximum XOR value of any two numbers in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n    output: 28\n\n    Explanation:\n    The maximum XOR value of any two numbers in the list is 28 (5 XOR 25).\n    \"\"\"\n\n    max_xor = 0\n    mask = 0\n\n    for i in range(30, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n\n        for num in nums:\n            prefix_set.add(num & mask)\n\n        max_xor_temp = max_xor | (1 << i)\n\n        for prefix in prefix_set:\n            if max_xor_temp ^ prefix in prefix_set:\n                max_xor = max_xor_temp\n                break\n\n    return max_xor\n\ndef g(nums=[3, 10, 5, 25, 2, 8]):\n    return nums\n\nassert f(g()) == 28\n",
        "idx_generation": 231,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if a given number is a perfect square and a power of 2.\n\n    Return True if the number is a perfect square and a power of 2, False otherwise.\n\n    Example:\n    n = 16\n\n    Output:\n    True\n\n    Explanation:\n    16 is a perfect square (4^2) and a power of 2 (2^4).\n    \"\"\"\n    def is_perfect_square(num):\n        return int(num ** 0.5) ** 2 == num\n\n    def is_power_of_two(num):\n        return num & (num - 1) == 0\n\n    return is_perfect_square(n) and is_power_of_two(n)\n\ndef g(n=16):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 206,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num1: int, num2: int) -> int:\n    \"\"\"\n    Given two integers, return the maximum XOR value of any two integers in the range [num1, num2].\n\n    Example:\n    Input: num1 = 2, num2 = 5\n    Output: 7\n    Explanation: The maximum XOR value can be obtained by taking the XOR of 5 and 2, which is 7.\n    \"\"\"\n    max_xor = 0\n    for i in range(num1, num2+1):\n        for j in range(i, num2+1):\n            xor = i ^ j\n            max_xor = max(max_xor, xor)\n    return max_xor\n\ndef g() -> Tuple[int, int]:\n    num1 = 2\n    num2 = 5\n    return num1, num2\n\nassert f(*g()) == 7\n",
        "idx_generation": 307,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, check if it is a magic square.\n    A magic square is a square grid of numbers that is filled with distinct positive integers in the range 1 to n^2,\n    where n is the number of rows (equal to the number of columns).\n    The sum of each row, each column, and each diagonal in the square must be equal.\n    \n    Example:\n    matrix = [\n        [2, 7, 6],\n        [9, 5, 1],\n        [4, 3, 8]\n    ]\n\n    Output:\n    True\n\n    Explanation:\n    The matrix forms a 3x3 magic square:\n    2 + 7 + 6 = 9 + 5 + 1 = 4 + 3 + 8 = 15 (sum of rows)\n    2 + 9 + 4 = 7 + 5 + 3 = 6 + 1 + 8 = 15 (sum of columns)\n    2 + 5 + 8 = 6 + 5 + 4 = 15 (sum of diagonals)\n\n    Hint: Use backtracking to generate all possible permutations of the numbers 1 to n^2 in the matrix.\n    Check if each permutation forms a magic square by checking the sums of rows, columns, and diagonals.\n    \"\"\"\n    def is_magic_square(matrix: List[List[int]]) -> bool:\n        n = len(matrix)\n        target_sum = n * (n**2 + 1) // 2\n\n        # Check rows\n        for row in matrix:\n            if sum(row) != target_sum:\n                return False\n\n        # Check columns\n        for col in range(n):\n            col_sum = sum(matrix[row][col] for row in range(n))\n            if col_sum != target_sum:\n                return False\n\n        # Check diagonals\n        diag1_sum = sum(matrix[i][i] for i in range(n))\n        diag2_sum = sum(matrix[i][n-i-1] for i in range(n))\n        if diag1_sum != target_sum or diag2_sum != target_sum:\n            return False\n\n        return True\n\n    return is_magic_square(matrix)\n\ndef g(matrix=[[2, 7, 6], [9, 5, 1], [4, 3, 8]]):\n    return matrix\n\nassert f(g()) == True\n",
        "idx_generation": 166,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(words: List[str], target: str) -> bool:\n    \"\"\"\n    Given a list of words, check if there exists a word that can be formed by concatenating any number of other words in the list.\n    \"\"\"\n    def dfs(word, words_set):\n        if word in words_set:\n            return True\n        for i in range(1, len(word)):\n            prefix = word[:i]\n            suffix = word[i:]\n            if prefix in words_set and dfs(suffix, words_set):\n                return True\n        return False\n\n    words_set = set(words)\n    return dfs(target, words_set)\n\ndef g():\n    words = [\"apple\", \"pie\", \"app\", \"le\", \"pi\"]\n    target = \"applepie\"\n    return words, target\n\nassert f(*g())\n",
        "idx_generation": 218,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a power of 2.\n\n    Sample Input:\n    n = 16\n\n    Sample Output:\n    True\n    \"\"\"\n    if n <= 0:\n        return False\n\n    return (n & (n - 1)) == 0\n\ndef g(n = 16):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 105,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of numbers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    24\n\n    Explanation:\n    The maximum product is 2 * 3 * 4 = 24.\n\n    Hint: You can solve this problem by sorting the list and considering the product of the three largest numbers or the two smallest numbers and the largest number.\n    \"\"\"\n    nums.sort()\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\n\ndef g(nums=[1, 2, 3, 4]):\n    return nums\n\nassert f(g()) == 24\n",
        "idx_generation": 190,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix, return True if there exists a path from the top-left corner to the bottom-right corner,\n    where the sum of all elements in the path is divisible by 3.\n\n    Sample Input:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Sample Output:\n    True\n\n    Explanation:\n    The path [1, 2, 3, 6, 9] has a sum of 21, which is divisible by 3.\n    \"\"\"\n\n    def dfs(row: int, col: int, curr_sum: int) -> bool:\n        if row == len(matrix) - 1 and col == len(matrix[0]) - 1:\n            return curr_sum % 3 == 0\n\n        if row < len(matrix) - 1 and dfs(row + 1, col, curr_sum + matrix[row + 1][col]):\n            return True\n\n        if col < len(matrix[0]) - 1 and dfs(row, col + 1, curr_sum + matrix[row][col + 1]):\n            return True\n\n        return False\n\n    return dfs(0, 0, matrix[0][0])\n\n\ndef g(matrix: List[List[int]] = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) -> List[List[int]]:\n    return matrix\n\n\nassert f(g())\n",
        "idx_generation": 376,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, check if it can be formed by concatenating words from a given dictionary.\n\n    Example:\n    s = \"leetcode\"\n    wordDict = [\"leet\", \"code\"]\n\n    Output:\n    True\n\n    Explanation:\n    The string \"leetcode\" can be formed by concatenating \"leet\" and \"code\" from the dictionary.\n\n    Hint: Use dynamic programming to check if a substring of s can be formed by concatenating words from the dictionary.\n    \"\"\"\n\n    def dp(i: int, memo: List[bool]) -> bool:\n        if i == len(s):\n            return True\n        if memo[i] is not None:\n            return memo[i]\n        \n        for j in range(i + 1, len(s) + 1):\n            if s[i:j] in wordDict and dp(j, memo):\n                memo[i] = True\n                return True\n        \n        memo[i] = False\n        return False\n\n    wordDict = [\"leet\", \"code\"]\n    memo = [None] * len(s)\n    return dp(0, memo)\n\ndef g() -> str:\n    \"\"\"\n    Generate a string that can be formed by concatenating words from a given dictionary.\n    \"\"\"\n    return \"leetcode\"\n\nassert f(g()) == True\n\n",
        "idx_generation": 417,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the shortest path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def dfs(row: int, col: int) -> int:\n        if row == rows - 1 and col == cols - 1:\n            return grid[row][col]\n        if row == rows - 1:\n            return grid[row][col] + dfs(row, col + 1)\n        if col == cols - 1:\n            return grid[row][col] + dfs(row + 1, col)\n        return grid[row][col] + min(dfs(row + 1, col), dfs(row, col + 1))\n\n    return dfs(0, 0)\n\ndef g(grid: List[List[int]] = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 210,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of integers, return True if the grid forms a valid magic square, and False otherwise.\n    A magic square is a square grid of numbers where the sum of each row, column, and diagonal is the same.\n    \"\"\"\n\n    def is_magic_square(grid):\n        n = len(grid)\n        target_sum = sum(grid[0])\n        # Check rows\n        for i in range(n):\n            if sum(grid[i]) != target_sum:\n                return False\n        # Check columns\n        for j in range(n):\n            column_sum = sum(grid[i][j] for i in range(n))\n            if column_sum != target_sum:\n                return False\n        # Check diagonals\n        diagonal_sum1 = sum(grid[i][i] for i in range(n))\n        diagonal_sum2 = sum(grid[i][n-i-1] for i in range(n))\n        if diagonal_sum1 != target_sum or diagonal_sum2 != target_sum:\n            return False\n        return True\n\n    return is_magic_square(grid)\n\ndef g(grid=[[2, 7, 6], [9, 5, 1], [4, 3, 8]]):\n    \"\"\"\n    Generate a grid of integers that forms a valid magic square.\n    \"\"\"\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 146,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers for the function f.\n    \"\"\"\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 12\n",
        "idx_generation": 72,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a prime number.\n\n    Example:\n    n = 7\n\n    Output:\n    True\n\n    Explanation:\n    7 is a prime number because it is only divisible by 1 and itself.\n\n    Hint: A prime number is a number greater than 1 that has no positive divisors other than 1 and itself.\n    \"\"\"\n\n    if n <= 1:\n        return False\n\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n\n    return True\n\ndef g() -> int:\n    return 7\n\nassert f(g()) == True\n\n",
        "idx_generation": 453,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string contains a valid arrangement of parentheses.\"\"\"\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g(s=\"((()))()\"):\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 7,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n    \"\"\"\n    max_sum = current_sum = nums[0]\n    \n    for i in range(1, len(nums)):\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n\n",
        "idx_generation": 452,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the nth Fibonacci number.\n\n    Example:\n    n = 6\n    The 6th Fibonacci number is 8.\n\n    Constraints:\n    - The input integer n will always be non-negative.\n    \"\"\"\n\n    def fibonacci(n: int, memo: List[int]) -> int:\n        if n <= 1:\n            return n\n        elif memo[n] != 0:\n            return memo[n]\n        else:\n            memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)\n            return memo[n]\n\n    memo = [0] * (n+1)\n    return fibonacci(n, memo)\n\ndef g(n=6):\n    return n\n\nassert f(g()) == 8\n\n",
        "idx_generation": 454,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, n=3, target=\"abc\") -> bool:\n    \"\"\"Check if the string 's' contains 'target' as a substring of length 'n' using recursion and stacks.\"\"\"\n    stack = []\n    def dfs(s, n, target):\n        if len(stack) == n:\n            if \"\".join(stack) == target:\n                return True\n            stack.pop(0)\n        stack.append(s[0])\n        return dfs(s[1:], n, target)\n    return dfs(s, n, target)\ndef g(n=3, target=\"abc\"):\n    return \"abccbaabc\"\nassert f(g()) == True\n",
        "idx_generation": 123,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if a grid contains a valid path from top-left to bottom-right using only stacks and queues\"\"\"\n    rows, cols = len(grid), len(grid[0])\n    stack = [(0, 0)]\n    visited = set()\n    while stack:\n        x, y = stack.pop()\n        if x == rows-1 and y == cols-1:\n            return True\n        visited.add((x, y))\n        for dx, dy in [(1, 0), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and grid[nx][ny] == 1:\n                stack.append((nx, ny))\n    return False\n\ndef g(grid: List[List[int]]):\n    return grid\n\nassert f(g([[1, 1, 1], [0, 1, 0], [0, 1, 1]]))\n",
        "idx_generation": 287,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if there exists a path in a grid from (0, 0) to (n, n) using only right and down steps.\"\"\"\n    def count_paths(x: int, y: int) -> int:\n        if x == 0 or y == 0:\n            return 1\n        return count_paths(x-1, y) + count_paths(x, y-1)\n\n    return count_paths(n, n) > 0\n\ndef g():\n    return 3\n\nassert f(g()) == True\n",
        "idx_generation": 16,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Count the number of islands in a given grid, where 1 represents land and 0 represents water.\"\"\"\n    def dfs(row, col):\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] == 0:\n            return\n        grid[row][col] = 0\n        dfs(row + 1, col)\n        dfs(row - 1, col)\n        dfs(row, col + 1)\n        dfs(row, col - 1)\n    \n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                count += 1\n                dfs(i, j)\n    \n    return count\n\ndef g():\n    grid = [[1, 1, 0, 0, 0],\n            [1, 1, 0, 0, 0],\n            [0, 0, 1, 0, 0],\n            [0, 0, 0, 1, 1]]\n    return grid\n\nassert f(g()) == 3\n",
        "idx_generation": 107,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of words in the string while preserving the order of characters within each word.\n    \"\"\"\n    words = s.split()\n    reversed_words = [word[::-1] for word in words]\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string\n\ndef g():\n    s = \"Hello World\"\n    return s\n\nassert f(g()) == \"olleH dlroW\"\n\n",
        "idx_generation": 452,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s that represents a simple calculator expression, evaluate the expression and return the result.\n    The expression consists of digits, '+', '-', '(', ')', and ' '. The expression does not contain leading or trailing spaces,\n    and the parentheses are always balanced.\n    \n    Example:\n    s = \"(1+(4+5+2)-3)+(6+8)\"\n\n    Output:\n    23\n\n    Explanation:\n    The expression is evaluated as follows:\n    (1+(4+5+2)-3)+(6+8) = (1+11-3)+(6+8) = 9+14 = 23.\n\n    Hint: Use two stacks, one for numbers and one for operators. Iterate through the string character by character and\n    perform the necessary calculations based on the current character and the top elements of the stacks.\n    \"\"\"\n    numbers = []\n    operators = []\n    num = 0\n    sign = 1\n    result = 0\n    \n    for char in s:\n        if char.isdigit():\n            num = num * 10 + int(char)\n        elif char == '+':\n            result += sign * num\n            num = 0\n            sign = 1\n        elif char == '-':\n            result += sign * num\n            num = 0\n            sign = -1\n        elif char == '(':\n            numbers.append(result)\n            operators.append(sign)\n            result = 0\n            sign = 1\n        elif char == ')':\n            result += sign * num\n            num = 0\n            result *= operators.pop()\n            result += numbers.pop()\n    \n    return result + (sign * num)\n\ndef g(s=\"(1+(4+5+2)-3)+(6+8)\"):\n    return s\n\nassert f(g()) == 23\n\n",
        "idx_generation": 79,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string, find the length of the longest substring without repeating characters.\n    \"\"\"\n    n = len(s)\n    longest_substring = 0\n    start = 0\n    seen = {}\n    \n    for end in range(n):\n        if s[end] in seen:\n            start = max(start, seen[s[end]] + 1)\n        seen[s[end]] = end\n        longest_substring = max(longest_substring, end - start + 1)\n    \n    return longest_substring\n\ndef g() -> str:\n    return \"abcabcbb\"\n\nassert f(g()) == 3\n",
        "idx_generation": 100,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[str]], target=\"ABC\") -> bool:\n    \"\"\"\n    Check if it is possible to find a path in the given grid that spells out the target word.\n    A valid path can move horizontally or vertically to adjacent cells, but cannot visit the same cell twice.\n    \"\"\"\n    def dfs(i, j, k):\n        if k == len(target):\n            return True\n        if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != target[k]:\n            return False\n        temp, grid[i][j] = grid[i][j], '#'\n        found = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)\n        grid[i][j] = temp\n        return found\n\n    m, n = len(grid), len(grid[0])\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == target[0] and dfs(i, j, 0):\n                return True\n\n    return False\n\ndef g(grid = [['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]):\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 74,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int) -> bool:\n    \"\"\"Check if a given number is a power of 2\"\"\"\n    if num <= 0:\n        return False\n    return num & (num - 1) == 0\n\ndef g(num=16):\n    return f(num)\n\nassert f(g())\n",
        "idx_generation": 479,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if a number is a power of two.\n    Return True if n is a power of two, False otherwise.\n    \"\"\"\n    return n > 0 and (n & (n - 1)) == 0\n\ndef g(n: int = 16) -> int:\n    \"\"\"\n    Return the number to check if it is a power of two.\n    \"\"\"\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 114,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Check if there exists a subarray in the given list whose bitwise AND is equal to the target value.\n    \"\"\"\n    n = len(arr)\n    prefix = [arr[0]]\n    for i in range(1, n):\n        prefix.append(prefix[-1] & arr[i])\n\n    for i in range(n):\n        for j in range(i, n):\n            if i == 0:\n                if prefix[j] == target:\n                    return True\n            else:\n                if (prefix[j] & (~prefix[i-1])) == target:\n                    return True\n    return False\n\ndef g(arr: List[int] = [5, 7, 9, 3, 6, 2, 8], target: int = 1) -> List[int]:\n    return arr, target\n\nassert f(g()[0], g()[1]) == True\n",
        "idx_generation": 119,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there exists a subset of the list\n    such that the bitwise XOR of all the elements in the subset is equal to the target value.\n    Return True if such subset exists, otherwise return False.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    target = 5\n\n    Output:\n    True\n\n    Explanation:\n    The subset [1, 4] has a bitwise XOR of 5, which is equal to the target value.\n\n    Hint: Use bitwise XOR operation to check if a subset exists.\n    \"\"\"\n\n    def subset_xor(nums: List[int], target: int) -> bool:\n        n = len(nums)\n        dp = [[False] * (target + 1) for _ in range(n + 1)]\n\n        for i in range(n + 1):\n            dp[i][0] = True\n\n        for i in range(1, n + 1):\n            for j in range(1, target + 1):\n                if nums[i - 1] <= j:\n                    dp[i][j] = dp[i - 1][j - nums[i - 1]] or dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n\n        return dp[n][target]\n\n    return subset_xor(nums, target)\n\n\ndef g() -> List[int]:\n    nums = [2, 4, 6, 8]\n    target = 10\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 132,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a subset whose XOR is equal to the target value.\n    XOR of a subset is the bitwise exclusive OR of all the numbers in the subset.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    Sample Output:\n    True\n    \"\"\"\n    def dfs(index, curr_xor):\n        if curr_xor == target:\n            return True\n        if index >= len(nums) or curr_xor > target:\n            return False\n\n        # Include the current element in the subset\n        if dfs(index + 1, curr_xor ^ nums[index]):\n            return True\n\n        # Exclude the current element from the subset\n        if dfs(index + 1, curr_xor):\n            return True\n\n        return False\n\n    return dfs(0, 0)\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g(), 7) == True\n",
        "idx_generation": 281,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(num: int) -> int:\n    \"\"\"\n    Given a positive integer, determine the number of bits required to represent it in binary form.\n    \"\"\"\n    binary_str = bin(num)[2:]\n    return len(binary_str)\n\ndef g(num=10):\n    return num\n\nassert f(g()) == 4\n\n",
        "idx_generation": 345,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n\n    Example:\n    Input: n = 5\n    Output: 5\n    Explanation: The 5th Fibonacci number is 5.\n\n    \"\"\"\n    # Base cases: 0th and 1st Fibonacci numbers are 0 and 1, respectively\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    \n    # Initialize the first two Fibonacci numbers\n    fib1 = 0\n    fib2 = 1\n    \n    # Find the nth Fibonacci number\n    for _ in range(2, n+1):\n        fib = fib1 + fib2\n        fib1 = fib2\n        fib2 = fib\n    \n    return fib\n\ndef g() -> int:\n    n = 5\n    return n\n\nassert f(g()) == 5\n",
        "idx_generation": 452,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Given two positive integers n and k, find if there exists a permutation of the numbers from 1 to n such that the\n    bitwise XOR of any two adjacent numbers is less than k.\n    \"\"\"\n    def helper(arr, n, k):\n        if n == 0:\n            return True\n        for i in range(n):\n            if i == 0 or (arr[i] ^ arr[i-1] < k):\n                arr[i], arr[n-1] = arr[n-1], arr[i]\n                if helper(arr, n-1, k):\n                    return True\n                arr[i], arr[n-1] = arr[n-1], arr[i]\n        return False\n\n    return helper(list(range(1, n+1)), n, k)\n\ndef g(n: int, k: int):\n    return n, k\n\nassert f(*g(3, 4))\n\n",
        "idx_generation": 187,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all even numbers up to and including n.\n    Return the sum.\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    def sum_even_helper(n, memo):\n        if n == 0:\n            return 0\n        if n in memo:\n            return memo[n]\n        \n        if n % 2 == 0:\n            current_sum = n + sum_even_helper(n - 2, memo)\n        else:\n            current_sum = sum_even_helper(n - 1, memo)\n        \n        memo[n] = current_sum\n        return current_sum\n\n    return sum_even_helper(n, {})\n\ndef g(n = 10):\n    return n\n\nassert f(g()) == 30\n",
        "idx_generation": 149,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of integers, determine if it is a magic square. A magic square is a square grid of numbers\n    where the sums of the numbers in each row, each column, and both diagonals are the same.\n\n    Sample Input:\n    [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n\n    Sample Output:\n    True\n    \"\"\"\n    target_sum = sum(grid[0])\n    \n    # Check rows\n    for row in grid:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check columns\n    for col in zip(*grid):\n        if sum(col) != target_sum:\n            return False\n    \n    # Check diagonals\n    diagonal1 = [grid[i][i] for i in range(len(grid))]\n    diagonal2 = [grid[i][len(grid)-1-i] for i in range(len(grid))]\n    if sum(diagonal1) != target_sum or sum(diagonal2) != target_sum:\n        return False\n    \n    return True\n\n\ndef g():\n    \"\"\"\n    Generate a magic square grid of size 3x3.\n    \"\"\"\n    return [[8, 1, 6], [3, 5, 7], [4, 9, 2]]\n\n\nassert f(g()) == True\n",
        "idx_generation": 106,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n\n    Return True if the maximum sum is greater than or equal to a given threshold, False otherwise.\n\n    Example:\n    grid = [\n        [1, 3, 2],\n        [4, 2, 1],\n        [2, 1, 5]\n    ]\n    threshold = 10\n\n    Output:\n    True\n\n    Explanation:\n    The maximum sum of a path from (0, 0) to (2, 2) is 1 + 3 + 2 + 1 + 5 = 12, which is greater than the threshold of 10.\n    \"\"\"\n    def find_max_path(grid, threshold):\n        rows = len(grid)\n        cols = len(grid[0])\n        dp = [[0] * cols for _ in range(rows)]\n        dp[0][0] = grid[0][0]\n\n        for i in range(1, rows):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n\n        for j in range(1, cols):\n            dp[0][j] = dp[0][j-1] + grid[0][j]\n\n        for i in range(1, rows):\n            for j in range(1, cols):\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n        return dp[rows-1][cols-1] >= threshold\n\n    return find_max_path(grid, 10)\n\ndef g(grid=[[1, 3, 2], [4, 2, 1], [2, 1, 5]]):\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 94,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers 'n' and 'm', find the number of unique paths from the top-left cell to the bottom-right cell\n    in a grid of size n x m. The path can only move right or down.\n\n    Example:\n    n = 3\n    m = 2\n\n    Output:\n    3\n\n    Explanation:\n    There are three unique paths: right -> right -> down, right -> down -> right, and down -> right -> right.\n    \"\"\"\n\n    dp = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n        dp[i][0] = 1\n\n    for j in range(m):\n        dp[0][j] = 1\n\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[n-1][m-1]\n\n\ndef g(n: int, m: int) -> List[int]:\n    return n, m\n\n\nassert f(*g(3, 2)) == 3\n",
        "idx_generation": 153,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest palindromic subsequence.\n\n    Example:\n    s = \"bbbab\"\n\n    Output:\n    4 (the longest palindromic subsequence is \"bbbb\")\n    \"\"\"\n\n    def longestPalindromicSubsequence(start: int, end: int) -> int:\n        # base case: when start and end indices are the same, there is only one character\n        if start == end:\n            return 1\n\n        # base case: when start index is greater than end index, it means we have crossed the center\n        if start > end:\n            return 0\n\n        # if the characters at the start and end indices are the same, we can include them in the subsequence\n        if s[start] == s[end]:\n            return 2 + longestPalindromicSubsequence(start + 1, end - 1)\n        else:\n            # if the characters are different, we have two options: include the character at the start index\n            # or include the character at the end index, and take the maximum length from both options\n            return max(longestPalindromicSubsequence(start + 1, end), longestPalindromicSubsequence(start, end - 1))\n\n    return longestPalindromicSubsequence(0, len(s) - 1)\n\ndef g(s: str):\n    return s\n\nassert f(g(\"bbbab\")) == 4\n\n",
        "idx_generation": 230,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, count the number of set bits (1s) in its binary representation.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g(n=10):\n    return n\n\nassert f(g()) == 2\n",
        "idx_generation": 46,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if n is a power of two.\n    \"\"\"\n    if n <= 0:\n        return False\n    while n % 2 == 0:\n        n //= 2\n    return n == 1\n\ndef g() -> int:\n    \"\"\"\n    Generate a power of two.\n    \"\"\"\n    return 16\n\nassert f(g()) == True\n",
        "idx_generation": 464,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> List[int]:\n    \"\"\"\n    Given a directed graph represented as an adjacency list, and two nodes start and end, return a list containing the shortest path from start to end.\n    If there is no path from start to end, return an empty list.\n    \"\"\"\n\n    # Perform breadth-first search to find the shortest path\n    queue = [(start, [start])]\n    visited = set([start])\n\n    while queue:\n        node, path = queue.pop(0)\n\n        if node == end:\n            return path\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, path + [neighbor]))\n\n    return []\n\n\ndef g():\n    \"\"\"\n    Generate a directed graph represented as an adjacency list, and two nodes start and end.\n    \"\"\"\n    graph = {1: [2, 3, 4], 2: [5], 3: [4, 5], 4: [5], 5: []}\n    start = 1\n    end = 5\n    return graph, start, end\n\n\nassert f(*g()) == [1, 2, 5]\n\n",
        "idx_generation": 456,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed acyclic graph (DAG) represented as an adjacency list and two nodes, start and end, determine if\n    there exists a path from start to end in the graph.\n\n    Example:\n    Input:\n    graph = [\n        [1, 2],\n        [3],\n        [3],\n        []\n    ]\n    start = 0\n    end = 3\n\n    Output: True\n    Explanation: There is a path from node 0 to node 3: 0 -> 2 -> 3.\n    \"\"\"\n    visited = set()\n    \n    def dfs(node):\n        if node == end:\n            return True\n        \n        visited.add(node)\n        \n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n        \n        return False\n    \n    return dfs(start)\n\ndef g():\n    graph = [\n        [1, 2],\n        [3],\n        [3],\n        []\n    ]\n    start = 0\n    end = 3\n\n    return graph, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 352,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(grid: List[List[str]]) -> bool:\n    \"\"\"\n    Given a grid of characters representing a maze, determine if it is possible to reach the bottom-right corner from the top-left corner.\n\n    Example:\n    grid = [\n        ['S', 'X', 'X', 'X', 'X'],\n        ['.', '.', '.', '.', 'X'],\n        ['X', 'X', 'X', '.', 'X'],\n        ['X', '.', '.', '.', 'X'],\n        ['X', 'X', 'X', 'E', 'X']\n    ]\n\n    Output:\n    True (S -> . -> . -> . -> E)\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up\n\n    def is_valid(x: int, y: int) -> bool:\n        return x >= 0 and x < m and y >= 0 and y < n and grid[x][y] != 'X'\n\n    def bfs() -> bool:\n        queue = deque([(0, 0)])\n        visited = set([(0, 0)])\n\n        while queue:\n            x, y = queue.popleft()\n\n            if grid[x][y] == 'E':\n                return True\n\n            for dx, dy in directions:\n                nx = x + dx\n                ny = y + dy\n\n                if is_valid(nx, ny) and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n\n        return False\n\n    return bfs()\n\ndef g() -> List[List[str]]:\n    return [\n        ['S', 'X', 'X', 'X', 'X'],\n        ['.', '.', '.', '.', 'X'],\n        ['X', 'X', 'X', '.', 'X'],\n        ['X', '.', '.', '.', 'X'],\n        ['X', 'X', 'X', 'E', 'X']\n    ]\n\nassert f(g()) == True\n",
        "idx_generation": 291,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the number of distinct islands.\n    An island is considered to be the same if they have the same shape and the same relative positions of 1s.\n    \"\"\"\n    def dfs(row, col, currPath, direction):\n        if row < 0 or col < 0 or row >= len(grid) or col >= len(grid[0]) or grid[row][col] != 1:\n            return\n        \n        currPath.append(direction)\n        grid[row][col] = -1\n        \n        dfs(row - 1, col, currPath, \"U\")\n        dfs(row + 1, col, currPath, \"D\")\n        dfs(row, col - 1, currPath, \"L\")\n        dfs(row, col + 1, currPath, \"R\")\n        currPath.append(\"B\")  # backtrack\n    \n    distinctIslands = set()\n    \n    for row in range(len(grid)):\n        for col in range(len(grid[0])):\n            if grid[row][col] == 1:\n                path = []\n                dfs(row, col, path, \"S\")\n                distinctIslands.add(tuple(path))\n    \n    return len(distinctIslands)\n\ndef g():\n    grid = [\n        [1, 1, 0],\n        [1, 0, 0],\n        [0, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 2\n",
        "idx_generation": 94,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int:\n    \"\"\"\n    Given a grid of integers, find the shortest path from a given start cell to a given end cell.\n    You can only move in four directions: up, down, left, and right.\n    \n    Example:\n    grid = [\n        [1, 1, 1, 0],\n        [0, 1, 1, 1],\n        [0, 0, 1, 0],\n        [1, 0, 1, 1]\n    ]\n    start = (0, 0)\n    end = (3, 3)\n    \n    Output:\n    6 (as the shortest path from (0, 0) to (3, 3) is: (0, 0) -> (1, 0) -> (2, 0) -> (2, 1) -> (2, 2) -> (3, 2) -> (3, 3))\n    \"\"\"\n    ROWS = len(grid)\n    COLS = len(grid[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def is_valid_cell(row: int, col: int) -> bool:\n        return 0 <= row < ROWS and 0 <= col < COLS\n\n    def bfs() -> int:\n        queue = [(start[0], start[1], 0)]\n        visited = set((start[0], start[1]))\n\n        while queue:\n            row, col, distance = queue.pop(0)\n\n            if (row, col) == end:\n                return distance\n\n            for dr, dc in directions:\n                new_row = row + dr\n                new_col = col + dc\n\n                if is_valid_cell(new_row, new_col) and (new_row, new_col) not in visited and grid[new_row][new_col] == 1:\n                    queue.append((new_row, new_col, distance + 1))\n                    visited.add((new_row, new_col))\n\n        return -1\n\n    return bfs()\n\ndef g():\n    grid = [\n        [1, 1, 1, 0],\n        [0, 1, 1, 1],\n        [0, 0, 1, 0],\n        [1, 0, 1, 1]\n    ]\n    start = (0, 0)\n    end = (3, 3)\n    return (grid, start, end)\n\nassert f(*g()) == 6\n",
        "idx_generation": 178,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a square matrix, determine if it is a symmetric matrix.\n\n    Args:\n    - matrix: The square matrix.\n\n    Returns:\n    - True if the matrix is symmetric, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i+1, n):\n            if matrix[i][j] != matrix[j][i]:\n                return False\n    return True\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [2, 4, 5],\n        [3, 5, 6]\n    ]\n    return matrix\n\nassert f(g()) == True\n",
        "idx_generation": 235,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> List[int]:\n    \"\"\"\n    Given the root of a binary tree, return the inorder traversal of its nodes' values.\n    \"\"\"\n    result = []\n    stack = []\n    curr = root\n\n    while curr or stack:\n        while curr:\n            stack.append(curr)\n            curr = curr.left\n\n        curr = stack.pop()\n        result.append(curr.val)\n        curr = curr.right\n\n    return result\n\ndef g():\n    # Creating a binary tree\n    root = TreeNode(1)\n    root.right = TreeNode(2)\n    root.right.left = TreeNode(3)\n\n    return root\n\nassert f(g()) == [1, 3, 2]\n",
        "idx_generation": 372,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef f(root: Node) -> bool:\n    \"\"\"\n    Given the root of a binary tree, determine if it is a binary search tree (BST).\n\n    A binary search tree (BST) is a binary tree where the value of each node is larger than the values in its left subtree\n    and smaller than the values in its right subtree.\n\n    Return True if the given binary tree is a binary search tree, otherwise return False.\n    \"\"\"\n    def is_bst(node: Node, min_val=float('-inf'), max_val=float('inf')) -> bool:\n        if node is None:\n            return True\n        if node.value <= min_val or node.value >= max_val:\n            return False\n        return is_bst(node.left, min_val, node.value) and is_bst(node.right, node.value, max_val)\n\n    return is_bst(root)\n\ndef g() -> Node:\n    root = Node(4)\n    root.left = Node(2)\n    root.right = Node(6)\n    root.left.left = Node(1)\n    root.left.right = Node(3)\n    root.right.left = Node(5)\n    root.right.right = Node(7)\n    return root\n\nassert f(g()) == True\n",
        "idx_generation": 65,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nimport heapq\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of integers, determine if there is a path from the top-left corner to the bottom-right corner\n    such that the sum of the values along the path is greater than or equal to a target value.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    target = sum(sum(row) for row in grid) // 2  # Target value is half of the sum of all values in the grid\n\n    def dfs(i, j, curr_sum):\n        if i == m - 1 and j == n - 1:\n            return curr_sum + grid[i][j] >= target\n        if i + 1 < m and dfs(i + 1, j, curr_sum + grid[i][j]):\n            return True\n        if j + 1 < n and dfs(i, j + 1, curr_sum + grid[i][j]):\n            return True\n        return False\n\n    return dfs(0, 0, 0)\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    This solution uses a dynamic programming approach to find the maximum sum path from the top-left corner to\n    the bottom-right corner of the grid.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    path = []\n    i, j = m - 1, n - 1\n    while i > 0 or j > 0:\n        path.append([i, j])\n        if i == 0:\n            j -= 1\n        elif j == 0:\n            i -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n\n    path.append([0, 0])\n    return path[::-1]\n\ngrid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\nassert f(g(grid))\n",
        "idx_generation": 10,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a list of words, determine if it is possible to break the string s into a space-separated\n    sequence of one or more dictionary words.\n\n    Example:\n    Input:\n    s = \"leetcode\"\n    words = [\"leet\", \"code\"]\n\n    Output: True\n\n    Explanation: \"leetcode\" can be broken into \"leet\" and \"code\"\n    \"\"\"\n\n    def word_break(s: str, words: List[str]) -> bool:\n        n = len(s)\n        dp = [False] * (n + 1)\n        dp[0] = True\n\n        for i in range(1, n + 1):\n            for word in words:\n                if i >= len(word) and dp[i - len(word)] and s[i - len(word):i] == word:\n                    dp[i] = True\n                    break\n\n        return dp[-1]\n\n    return word_break(s, words)\n\ndef g():\n    s = \"leetcode\"\n    words = [\"leet\", \"code\"]\n    return s, words\n\nassert f(*g()) == True\n",
        "idx_generation": 304,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique paths to reach the end point (n, n) in a grid of size n x n.\n    You can only move either down or right at any point in time.\n\n    Example:\n    n = 3\n\n    Output:\n    6\n\n    Explanation:\n    There are 6 unique paths to reach the end point (3, 3) in a 3 x 3 grid:\n    - Right -> Right -> Down -> Down\n    - Right -> Down -> Right -> Down\n    - Right -> Down -> Down -> Right\n    - Down -> Right -> Right -> Down\n    - Down -> Right -> Down -> Right\n    - Down -> Down -> Right -> Right\n    \"\"\"\n\n    def unique_paths(grid, row, col):\n        if row == 0 or col == 0:\n            return 1\n        else:\n            return unique_paths(grid, row - 1, col) + unique_paths(grid, row, col - 1)\n\n    grid = [[0] * n for _ in range(n)]\n    return unique_paths(grid, n - 1, n - 1)\n\ndef g() -> int:\n    return 3\n\nassert f(g()) == 6\n",
        "idx_generation": 161,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, find the number of k-combinations from a set of n elements.\n    \"\"\"\n    def factorial(num: int) -> int:\n        if num == 0 or num == 1:\n            return 1\n        return num * factorial(num - 1)\n\n    return factorial(n) // (factorial(k) * factorial(n - k))\n\ndef g(n: int = 5, k: int = 3):\n    \"\"\"\n    Generate two integers n and k.\n    \"\"\"\n    return n, k\n\nassert f(*g()) == 10\n",
        "idx_generation": 210,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string 's', count the number of distinct characters in the string.\n\n    Example:\n    s = \"hello\"\n\n    Output:\n    4\n\n    Explanation:\n    The distinct characters in the string \"hello\" are 'h', 'e', 'l', and 'o'. So, the count is 4.\n    \"\"\"\n\n    distinct_chars = set(s)\n    return len(distinct_chars)\n\ndef g():\n    s = \"hello\"\n    return s\n\nassert f(g()) == 4\n",
        "idx_generation": 272,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there exists a pair of integers in the list whose sum is equal to the target value.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n\n    Output:\n    True\n\n    Explanation:\n    There exists a pair of integers [2, 5] in the list whose sum is equal to the target value 7.\n    \"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        current_sum = arr[left] + arr[right]\n        \n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    return arr, target\n\nassert f(*g()) == True\n\n\n",
        "idx_generation": 453,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n    \"\"\"\n    nums.sort()\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 60\n",
        "idx_generation": 55,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there are two numbers that add up to a given target.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums = [1, 2, 3, 4, 5], target = 9):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 56,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the missing number in the sequence.\n\n    Example:\n    arr = [1, 2, 3, 5, 6, 7, 8]\n\n    Output:\n    4\n    \"\"\"\n    n = len(arr)\n    if arr[0] != 1:\n        return 1\n    if arr[n-1] != n+1:\n        return n+1\n    \n    left = 0\n    right = n-1\n    while left < right:\n        mid = left + (right-left)//2\n        if arr[mid] - mid == 1:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return arr[left] - 1\n\ndef g() -> List[int]:\n    return [1, 2, 3, 5, 6, 7, 8]\n\nassert f(g()) == 4\n\n",
        "idx_generation": 468,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a valid parentheses string. Return True if the string is valid, otherwise return False.\n    A valid parentheses string is defined as any combination of the characters '(' and ')', where each open parentheses '('\n    must have a corresponding close parentheses ')' and the parentheses must be properly nested.\n    \"\"\"\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g(s='(()())'):\n    \"\"\"\n    Generate a string that is a valid parentheses string. Return the generated string.\n    \"\"\"\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 31,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a 2D matrix of integers and a target value, determine if the target exists in the matrix.\n    The matrix has the following properties:\n    - Integers in each row are sorted in ascending order from left to right.\n    - Integers in each column are sorted in ascending order from top to bottom.\n\n    Example:\n    matrix = [\n        [1, 4, 7, 11, 15],\n        [2, 5, 8, 12, 19],\n        [3, 6, 9, 16, 22],\n        [10, 13, 14, 17, 24],\n        [18, 21, 23, 26, 30]\n    ]\n    target = 5\n\n    Output:\n    True\n\n    Explanation:\n    The target value 5 exists in the matrix.\n\n    Hint: Consider starting from the top-right corner of the matrix and iterate until the target is found or the boundary is reached.\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return False\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    row = 0\n    col = cols - 1\n\n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n\n    return False\n\ndef g(matrix=[[1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]], target=5):\n    return matrix, target\n\nassert f(*g())\n",
        "idx_generation": 73,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers nums sorted in ascending order, find the minimum path sum from the top left to the bottom right corner.\n\n    Args:\n    - grid: The grid of non-negative integers.\n\n    Returns:\n    - The minimum path sum from the top left to the bottom right corner.\n    \"\"\"\n    def min_path_sum(grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = grid[0][0]\n        for i in range(1, m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n        for j in range(1, n):\n            dp[0][j] = dp[0][j-1] + grid[0][j]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n        return dp[m-1][n-1]\n\n    return min_path_sum(grid)\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of non-negative integers.\n    \"\"\"\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 7\n\n",
        "idx_generation": 447,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the maximum area of a rectangle containing only 1s.\n    \"\"\"\n    def largest_rectangle(heights):\n        stack = []\n        max_area = 0\n        i = 0\n        while i < len(heights):\n            if not stack or heights[i] >= heights[stack[-1]]:\n                stack.append(i)\n                i += 1\n            else:\n                top = stack.pop()\n                area = heights[top] * (i - stack[-1] - 1 if stack else i)\n                max_area = max(max_area, area)\n        while stack:\n            top = stack.pop()\n            area = heights[top] * (i - stack[-1] - 1 if stack else i)\n            max_area = max(max_area, area)\n        return max_area\n\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    heights = [0] * n\n    max_area = 0\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                heights[j] += 1\n            else:\n                heights[j] = 0\n\n        area = largest_rectangle(heights)\n        max_area = max(max_area, area)\n\n    return max_area\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n    return grid\n\nassert f(g()) == 6\n",
        "idx_generation": 450,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome.\n\n    Sample Input:\n    string = \"racecar\"\n\n    Sample Output:\n    True\n    \"\"\"\n    stack = []\n    for char in string:\n        stack.append(char)\n    reversed_string = \"\"\n    while stack:\n        reversed_string += stack.pop()\n    return string == reversed_string\n\ndef g(string: str = \"racecar\") -> str:\n    return string\n\nassert f(g()) == True\n",
        "idx_generation": 2,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the smallest subarray whose sum is greater than or equal to the target value.\n    Return the length of the subarray.\n    If no such subarray exists, return 0.\n    \"\"\"\n    if not nums:\n        return 0\n\n    left = 0\n    right = 0\n    curr_sum = nums[0]\n    min_len = float('inf')\n\n    while right < len(nums):\n        if curr_sum >= target:\n            min_len = min(min_len, right - left + 1)\n            curr_sum -= nums[left]\n            left += 1\n        else:\n            right += 1\n            if right < len(nums):\n                curr_sum += nums[right]\n\n    return min_len if min_len != float('inf') else 0\n\ndef g(nums: List[int] = [1, 4, 3, 2, 5, 8], target: int = 9) -> List[int]:\n    \"\"\"\n    Generate a list of integers and a target value for the function f.\n    \"\"\"\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 146,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target = 10) -> bool:\n    \"\"\"Find two numbers from the list whose XOR is equal to the target value.\"\"\"\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] ^ nums[j] == target:\n                return True\n    return False\ndef g(nums = [2, 5, 8, 3, 7, 1]):\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] ^ nums[j] == 10:\n                return [nums[i], nums[j]]\n    return []\nassert f(g()) == True\n",
        "idx_generation": 12,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, return a list of all unique triplets that add up to zero.\n    Each triplet should be sorted in ascending order.\n    \"\"\"\n    nums.sort()\n    triplets = []\n    n = len(nums)\n\n    for i in range(n-2):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n\n        left = i + 1\n        right = n - 1\n\n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total == 0:\n                triplets.append([nums[i], nums[left], nums[right]])\n\n                while left < right and nums[left] == nums[left+1]:\n                    left += 1\n                while left < right and nums[right] == nums[right-1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n            elif total < 0:\n                left += 1\n            else:\n                right -= 1\n\n    return triplets\n\ndef g() -> List[int]:\n    return [-1, 0, 1, 2, -1, -4]\n\nassert f(g()) == [[-1, -1, 2], [-1, 0, 1]]\n\n",
        "idx_generation": 354,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if a given matrix is a valid adjacency matrix of a directed acyclic graph (DAG).\"\"\"\n    n = len(matrix)\n    if n != len(matrix[0]):\n        return False\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] < 0 or matrix[i][j] > 1:\n                return False\n            if matrix[i][j] == 1 and matrix[j][i] == 1:\n                return False\n            if matrix[i][j] == 1:\n                for k in range(n):\n                    if matrix[j][k] == 1 and matrix[i][k] == 0:\n                        return False\n    return True\n\ndef g():\n    return [[0, 1, 1],\n            [0, 0, 1],\n            [0, 0, 0]]\n\nassert f(g()) == True\n",
        "idx_generation": 16,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if it is a valid preorder traversal of a binary search tree.\n    \n    Example:\n    nums = [5, 2, 1, 3, 6]\n    \n    Output:\n    True (since [5, 2, 1, 3, 6] is a valid preorder traversal of the binary search tree: \n    5\n   / \\\n  2   6\n / \\\n1   3)\n    \"\"\"\n    stack = []\n    lower_bound = float('-inf')\n    for num in nums:\n        if num < lower_bound:\n            return False\n        while stack and num > stack[-1]:\n            lower_bound = stack.pop()\n        stack.append(num)\n    return True\n\ndef g():\n    return [5, 2, 1, 3, 6]\n\nassert f(g()) == True\n",
        "idx_generation": 205,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if there is a path from the top-left corner of the grid to the bottom-right corner.\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[False] * n for _ in range(m)]\n    dp[0][0] = True\n    \n    for i in range(1, m):\n        if grid[i][0] == 0:\n            dp[i][0] = dp[i-1][0]\n    for j in range(1, n):\n        if grid[0][j] == 0:\n            dp[0][j] = dp[0][j-1]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] == 0:\n                dp[i][j] = dp[i-1][j] or dp[i][j-1]\n    \n    return dp[m-1][n-1]\n\ndef g(grid: List[List[int]] = [[0, 0, 1, 1], [1, 0, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0]]) -> List[List[int]]:\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 71,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Find the maximum sum of a subgrid within the given grid.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    max_sum = float('-inf')\n    for i in range(m):\n        for j in range(n):\n            for k in range(i, m):\n                for l in range(j, n):\n                    subgrid_sum = 0\n                    for x in range(i, k+1):\n                        for y in range(j, l+1):\n                            subgrid_sum += grid[x][y]\n                    max_sum = max(max_sum, subgrid_sum)\n    return max_sum\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 45\n",
        "idx_generation": 201,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, find the maximum size of a square containing only 1s.\n    \"\"\"\n    if not grid:\n        return 0\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n    max_size = 0\n    \n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            if grid[i-1][j-1] == 1:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n                max_size = max(max_size, dp[i][j])\n    \n    return max_size * max_size\n\ndef g():\n    grid = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n    return grid\n\nassert f(g()) == 4\n\n",
        "idx_generation": 298,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the size of the largest square subgrid that contains only 1s.\n    Return the area of the largest square subgrid.\n\n    Sample Input:\n    grid = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n\n    Sample Output:\n    4\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    max_side = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if grid[i - 1][j - 1] == 1:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                max_side = max(max_side, dp[i][j])\n    return max_side ** 2\n\n\ndef g(grid = [[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]):\n    return grid\n\n\nassert f(g()) == 4\n",
        "idx_generation": 276,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, return the number of subarrays whose XOR is equal to the target.\n\n    Example:\n    nums = [4, 2, 2, 6, 4]\n    target = 6\n\n    Output:\n    4\n\n    Explanation:\n    The subarrays with XOR equal to 6 are [4, 2], [2, 2, 6], [6], and [4].\n    \"\"\"\n\n    prefix_xor = [0]\n    for num in nums:\n        prefix_xor.append(prefix_xor[-1] ^ num)\n\n    count = 0\n    xor_map = {}\n    for xor in prefix_xor:\n        if xor ^ target in xor_map:\n            count += xor_map[xor ^ target]\n        if xor in xor_map:\n            xor_map[xor] += 1\n        else:\n            xor_map[xor] = 1\n\n    return count\n\n\ndef g() -> Tuple[List[int], int]:\n    return [4, 2, 2, 6, 4], 6\n\n\nassert f(*g()) == 4\n",
        "idx_generation": 138,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, rotate the matrix 90 degrees clockwise and return the rotated matrix.\n\n    Sample Input:\n    [[1, 2, 3],\n     [4, 5, 6],\n     [7, 8, 9]]\n\n    Sample Output:\n    [[7, 4, 1],\n     [8, 5, 2],\n     [9, 6, 3]]\n    \"\"\"\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n    return matrix\n\ndef g(matrix: List[List[int]]):\n    return matrix\n\nassert f(g([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 135,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, rotate it 90 degrees clockwise.\n\n    Args:\n    - matrix: A list of lists representing the matrix.\n\n    Returns:\n    - The rotated matrix.\n    \"\"\"\n    n = len(matrix)\n    m = len(matrix[0])\n    rotated_matrix = [[0] * n for _ in range(m)]\n\n    for i in range(n):\n        for j in range(m):\n            rotated_matrix[j][n - 1 - i] = matrix[i][j]\n\n    return rotated_matrix\n\ndef g() -> List[List[int]]:\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n\n",
        "idx_generation": 157,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Find the maximum XOR value between any two numbers in the given list.\n    \"\"\"\n    class TrieNode:\n        def __init__(self):\n            self.children = [None, None]\n    \n    def insert(root, num):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if not node.children[bit]:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n    \n    def find_max_xor(root, num):\n        node = root\n        xor = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if node.children[1 - bit]:\n                xor |= (1 << i)\n                node = node.children[1 - bit]\n            else:\n                node = node.children[bit]\n        return xor\n    \n    root = TrieNode()\n    max_xor = 0\n    for num in nums:\n        insert(root, num)\n        max_xor = max(max_xor, find_max_xor(root, num))\n    \n    return max_xor\n\ndef g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n",
        "idx_generation": 186,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum path from the top-left cell to the bottom-right cell.\n    You can only move down or right at each step.\n    \"\"\"\n    if not grid:\n        return 0\n    \n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g():\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 167,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import itertools\nfrom typing import*\nfrom typing import *\nfrom itertools import combinations\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array nums of n integers and an integer target, find all unique combinations in nums where the candidate numbers sum to target.\n\n    Example:\n    Input:\n    nums = [2,3,6,7], target = 7\n    Output:\n    [\n      [7],\n      [2,2,3]\n    ]\n    Explanation:\n    The sum of 7 is the only solution, and the sum of 2+2+3 is also the only solution.\n    \"\"\"\n\n    def backtrack(remain, curr_combination, start):\n        if remain == 0:\n            result.append(list(curr_combination))\n            return\n        elif remain < 0:\n            return\n\n        for i in range(start, len(nums)):\n            curr_combination.append(nums[i])\n            backtrack(remain - nums[i], curr_combination, i)\n            curr_combination.pop()\n\n    result = []\n    nums.sort()\n    backtrack(target, [], 0)\n    return result\n\ndef g():\n    \"\"\"\n    Generate the list of numbers and target with the following structure:\n    nums = [2,3,6,7], target = 7\n    \"\"\"\n    return [2, 3, 6, 7], 7\n\nassert f(*g()) == [[2, 2, 3], [7]]\n\n",
        "idx_generation": 410,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Determine if a given grid is a valid Sudoku solution\"\"\"\n\n    def has_duplicates(arr: List[int]) -> bool:\n        \"\"\"Check if a list has any duplicate elements\"\"\"\n        seen = set()\n        for num in arr:\n            if num != 0 and num in seen:\n                return True\n            seen.add(num)\n        return False\n\n    # Checking rows\n    for row in grid:\n        if has_duplicates(row):\n            return False\n\n    # Checking columns\n    for col in zip(*grid):\n        if has_duplicates(col):\n            return False\n\n    # Checking subgrids\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            subgrid = [grid[x][y] for x in range(i, i+3) for y in range(j, j+3)]\n            if has_duplicates(subgrid):\n                return False\n\n    return True\n\ndef g():\n    return [[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]\n\nassert f(g()) == True\n",
        "idx_generation": 93,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, remove all duplicates and return a new list with the unique elements in the original order.\n\n    Example:\n    nums = [1, 2, 2, 3, 4, 4, 5]\n\n    Output:\n    [1, 2, 3, 4, 5]\n\n    Explanation:\n    The duplicate elements 2 and 4 are removed, and the unique elements are returned in the original order.\n    \"\"\"\n    seen = set()\n    result = []\n    for num in nums:\n        if num not in seen:\n            result.append(num)\n            seen.add(num)\n    return result\n\ndef g() -> List[int]:\n    return [1, 2, 2, 3, 4, 4, 5]\n\nassert f(g()) == [1, 2, 3, 4, 5]\n",
        "idx_generation": 162,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    nums = [2, 7, 11, 15], target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1 in the list add up to the target value of 9.\n\n    Hint: Use a dictionary to store the complement of each number as you iterate through the list. If the complement is found in the dictionary, return the indices of the current number and its complement.\n    \"\"\"\n\n    complement_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complement_dict:\n            return [complement_dict[complement], i]\n        complement_dict[num] = i\n\n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 489,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers, find two numbers that XOR to the target value.\n    \"\"\"\n    nums_set = set(nums)\n    \n    for num in nums:\n        complement = target ^ num\n        if complement in nums_set:\n            return True\n    \n    return False\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5, 6], target: int = 7):\n    \"\"\"\n    Generate a list of integers and a target number for the function f.\n    \"\"\"\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 111,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Check if the given list of integers is a palindrome when represented in binary form.\n    \"\"\"\n    binary_nums = [bin(num)[2:] for num in nums]\n    for i in range(len(binary_nums) // 2):\n        if binary_nums[i] != binary_nums[len(binary_nums) - 1 - i]:\n            return False\n    return True\n\ndef g():\n    nums = [5, 8, 3, 6, 9]\n    return nums\n\nassert f(g()) == False\n",
        "idx_generation": 148,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers, find two numbers such that they add up to a specific target number.\n\n    Args:\n    - nums: The array of integers.\n    - target: The target number.\n\n    Returns:\n    - A list of two numbers that add up to the target number.\n    \"\"\"\n    complements = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complements:\n            return [complements[complement], i]\n        complements[num] = i\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 235,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine if a given number is divisible by 3.\n    \"\"\"\n    if n % 3 == 0:\n        return True\n    else:\n        return False\n\ndef g() -> int:\n    \"\"\"\n    Generate a number that is divisible by 3.\n    \"\"\"\n    return 9\n\nassert f(g()) == True\n",
        "idx_generation": 116,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there is a subarray whose sum is equal to 0.\n    \"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum in prefix_sums or prefix_sum == 0:\n            return True\n        prefix_sums.add(prefix_sum)\n\n    return False\n\ndef g():\n    nums = [1, 2, -3, 4, 5]\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 64,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix consisting of 0's and 1's, find the size of the largest square submatrix that contains only 1's.\n\n    Example:\n    Input: \n    matrix = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n    Output: 4\n\n    Explanation:\n    The largest square submatrix that contains only 1's is:\n    [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n        [1, 1, 1, 1]\n    ]\n    \"\"\"\n\n    if not matrix:\n        return 0\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n    max_side = 0\n\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            if matrix[i - 1][j - 1] == 1:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                max_side = max(max_side, dp[i][j])\n\n    return max_side * max_side\n\ndef g():\n    \"\"\"\n    Generate a matrix consisting of 0's and 1's.\n    \"\"\"\n    return [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n\nassert f(g()) == 4\n\n",
        "idx_generation": 310,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix represented as a list of lists of integers, determine if it forms a magic square.\n    A magic square is a square matrix in which the sum of every row, column, and diagonal is the same.\n\n    Example:\n    matrix = [\n        [2, 7, 6],\n        [9, 5, 1],\n        [4, 3, 8]\n    ]\n    The sum of every row, column, and diagonal is 15, so it forms a magic square.\n\n    Return True if the matrix forms a magic square, else return False.\n    \"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for i in range(n):\n        col_sum = sum(matrix[j][i] for j in range(n))\n        if col_sum != target_sum:\n            return False\n\n    # Check diagonals\n    diag_sum1 = sum(matrix[i][i] for i in range(n))\n    if diag_sum1 != target_sum:\n        return False\n\n    diag_sum2 = sum(matrix[i][n - 1 - i] for i in range(n))\n    if diag_sum2 != target_sum:\n        return False\n\n    return True\n\n\ndef g():\n    matrix = [\n        [2, 7, 6],\n        [9, 5, 1],\n        [4, 3, 8]\n    ]\n    return matrix\n\n\nassert f(g()) == True\n",
        "idx_generation": 160,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, return True if it contains a repeated substring of length 2 or more. Otherwise, return False.\n    \"\"\"\n    for i in range(1, len(s) // 2 + 1):\n        for j in range(len(s) - i):\n            if s[j:j+i] == s[j+i:j+2*i]:\n                return True\n    return False\n\ndef g():\n    return \"abcabc\"\n\nassert f(g()) == True\n",
        "idx_generation": 81,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list that sums up to the target value.\"\"\"\n    seen = set()\n    for num in nums:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False\ndef g(target = 10):\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nassert f(g()) == True\n",
        "idx_generation": 15,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the sum of all the even numbers in the matrix.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    total = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            if matrix[i][j] % 2 == 0:\n                total += matrix[i][j]\n\n    return total\n\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    \"\"\"\n    Generate a matrix of integers.\n    \"\"\"\n    return matrix\n\nassert f(g()) == 20\n",
        "idx_generation": 274,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the missing number in the range from 0 to n where n is the length of the list.\n    \n    Args:\n    - nums: A list of integers\n    \n    Returns:\n    - The missing number\n    \"\"\"\n    missing = len(nums)\n    for i, num in enumerate(nums):\n        missing ^= i ^ num\n    return missing\n\ndef g():\n    nums = [0, 1, 2, 3, 5, 6, 7, 8, 9]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 272,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "import random\nfrom typing import*\ndef f(n: int) -> str:\n    \"\"\"\n    Convert the given decimal number to its binary representation as a string.\n    \"\"\"\n    return bin(n)[2:]\n\ndef g(n: int):\n    \"\"\"\n    Generate a random decimal number.\n    \"\"\"\n    return n\n\nassert f(g(10)) == \"1010\"\n",
        "idx_generation": 298,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an adjacency matrix representing a graph, return a list of the degrees of each vertex in the graph.\n    The degree of a vertex is the number of edges incident to it.\n    \"\"\"\n    degrees = []\n    for row in graph:\n        degrees.append(sum(row))\n    return degrees\n\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate the adjacency matrix for the graph.\n    \"\"\"\n    return [[0, 1, 1, 0],\n            [1, 0, 0, 1],\n            [1, 0, 0, 1],\n            [0, 1, 1, 0]]\n\n\nassert f(g()) == [2, 2, 2, 2]\n",
        "idx_generation": 187,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, return the indices of two numbers that add up to the target.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Hint: Use a dictionary to store the complement of each number as the key and its index as the value. Iterate through the list and check if the complement exists in the dictionary.\n    \"\"\"\n\n    complement_dict = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        if complement in complement_dict:\n            return [complement_dict[complement], i]\n        \n        complement_dict[num] = i\n        \n    return []\n\ndef g():\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 241,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique paths to reach the bottom-right corner of a n x n grid from the top-left corner.\n    You can only move either down or right at any point in time.\n\n    Sample Input:\n    n = 3\n\n    Sample Output:\n    6\n\n    Explanation:\n    There are 6 unique paths to reach the bottom-right corner.\n    \"\"\"\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][0] = 1\n        dp[0][i] = 1\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    return dp[n-1][n-1]\n\ndef g(n = 3):\n    return n\n\nassert f(g()) == 6\n\n",
        "idx_generation": 199,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of integers, return True if the grid contains a rectangle where all the elements are the same,\n    and False otherwise.\n    \"\"\"\n\n    def contains_rectangle(grid):\n        rows = len(grid)\n        cols = len(grid[0])\n        for i in range(rows):\n            for j in range(cols):\n                for k in range(i+1, rows):\n                    for l in range(j+1, cols):\n                        if all(grid[m][n] == grid[i][j] for m in range(i, k+1) for n in range(j, l+1)):\n                            return True\n        return False\n\n    return contains_rectangle(grid)\n\ndef g(grid=[[1, 1, 1], [1, 2, 2], [1, 2, 2]]):\n    \"\"\"\n    Generate a grid of integers that contains a rectangle where all the elements are the same.\n    \"\"\"\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 146,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target integer, determine if there exists a subset of nums that sums up to the target.\n\n    Example:\n    nums = [2, 4, 6, 8]\n    target = 10\n\n    Output:\n    True\n\n    Explanation:\n    The subset [2, 8] sums up to the target value of 10.\n    \"\"\"\n\n    def subset_sum(nums, target, index, curr_sum):\n        if curr_sum == target:\n            return True\n\n        if curr_sum > target or index >= len(nums):\n            return False\n\n        include = subset_sum(nums, target, index+1, curr_sum + nums[index])\n        exclude = subset_sum(nums, target, index+1, curr_sum)\n\n        return include or exclude\n\n    return subset_sum(nums, target, 0, 0)\n\ndef g(nums=[2, 4, 6, 8], target=10):\n    return nums, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 391,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the sum of the first n Fibonacci numbers.\n\n    Args:\n    - n: A positive integer.\n\n    Returns:\n    - The sum of the first n Fibonacci numbers.\n\n    Example:\n    f(1) => 1\n    f(5) => 12\n    f(10) => 143\n    \"\"\"\n\n    if n <= 0:\n        return 0\n\n    fib = [0, 1]\n    sum = 1\n    for i in range(2, n+1):\n        fib.append(fib[i-1] + fib[i-2])\n        sum += fib[i]\n\n    return sum\n\ndef g() -> int:\n    n = 7\n    return n\n\nassert f(g()) == 33\n\n",
        "idx_generation": 453,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string is a valid parentheses expression.\"\"\"\n    stack = []\n    for c in s:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g():\n    return \"()()\"\n\nassert f(g()) == True\n",
        "idx_generation": 16,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of a subarray.\n\n    Example:\n    nums = [2, 3, -2, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The maximum product subarray is [2, 3], which gives a product of 6.\n\n    Hint: Use dynamic programming to keep track of both the maximum and minimum product at each index.\n\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    max_product = nums[0]\n    min_product = nums[0]\n    max_result = nums[0]\n\n    for i in range(1, len(nums)):\n        num = nums[i]\n        if num < 0:\n            max_product, min_product = min_product, max_product\n\n        max_product = max(num, max_product * num)\n        min_product = min(num, min_product * num)\n\n        max_result = max(max_result, max_product)\n\n    return max_result\n\ndef g(nums: List[int] = [2, 3, -2, 4]):\n    return nums\n\nassert f(g()) == 6\n\n",
        "idx_generation": 454,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int], target=10) -> bool:\n    \"\"\"Check if there exists a subarray in 'arr' whose sum is equal to 'target' using recursion and queues.\"\"\"\n    queue = []\n    def bfs(arr, target):\n        if sum(queue) == target:\n            return True\n        elif sum(queue) > target:\n            queue.pop(0)\n        if len(arr) == 0:\n            return False\n        queue.append(arr[0])\n        return bfs(arr[1:], target)\n    return bfs(arr, target)\ndef g(target=10):\n    return [4, 3, 1, 2, 5, 7]\nassert f(g()) == True\n",
        "idx_generation": 123,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[str]]) -> bool:\n    \"\"\"\n    Determine if there exists a path from the top-left corner to the bottom-right corner in the given grid,\n    where '1' represents a valid path and '0' represents an obstacle.\n    \"\"\"\n    rows, cols = len(grid), len(grid[0])\n    dp = [[False] * cols for _ in range(rows)]\n    dp[0][0] = True\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == '0':\n                continue\n            if i > 0:\n                dp[i][j] = dp[i-1][j]\n            if j > 0:\n                dp[i][j] = dp[i][j-1]\n    return dp[rows-1][cols-1]\ndef g():\n    return [['1', '1', '1'], ['1', '0', '1'], ['1', '1', '1']]\nassert f(g()) == True\n",
        "idx_generation": 18,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if a 2D grid is reachable by a valid path\"\"\"\n    m, n = len(matrix), len(matrix[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def is_valid(x, y):\n        return 0 <= x < m and 0 <= y < n\n\n    def bfs(start):\n        queue = deque([start])\n        visited = set([start])\n        while queue:\n            x, y = queue.popleft()\n            if matrix[x][y] == 9:\n                return True\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if is_valid(nx, ny) and matrix[nx][ny] != 0 and (nx, ny) not in visited:\n                    queue.append((nx, ny))\n                    visited.add((nx, ny))\n        return False\n\n    start = None\n    for i in range(m):\n        for j in range(n):\n            if matrix[i][j] == 1:\n                start = (i, j)\n                break\n        if start:\n            break\n\n    return bfs(start)\n\ndef g():\n    matrix = [[1, 0, 0, 0, 0],\n              [1, 1, 0, 0, 0],\n              [0, 1, 1, 1, 0],\n              [0, 0, 0, 1, 0],\n              [0, 0, 0, 1, 9]]\n    return matrix\nassert f(g()) == True\n",
        "idx_generation": 159,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of words in the string.\n\n    Example:\n    s = \"Hello World\"\n\n    Output:\n    \"World Hello\"\n\n    Explanation:\n    Reverse the order of words in the string, resulting in \"World Hello\".\n    \"\"\"\n\n    words = s.split()\n    return ' '.join(reversed(words))\n\n\ndef g() -> str:\n    return \"Hello World\"\n\n\nassert f(g()) == \"World Hello\"\n",
        "idx_generation": 454,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if it is a palindrome.\n\n    Sample Input:\n    [1, 2, 3, 2, 1]\n\n    Sample Output:\n    True\n    \"\"\"\n    stack = []\n    for num in nums:\n        stack.append(num)\n    for num in nums:\n        if num != stack.pop():\n            return False\n    return True\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == False\n",
        "idx_generation": 182,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string of lowercase letters, return the length of the longest substring that contains at most two distinct characters.\n\n    Example:\n    s = \"abaccc\"\n\n    Output:\n    4\n\n    Explanation:\n    The longest substring that contains at most two distinct characters is \"abac\".\n    \"\"\"\n\n    def longest_substring(s: str) -> int:\n        if len(s) < 3:\n            return len(s)\n\n        longest = 0\n        start = 0\n        end = 0\n        char_count = {}\n        distinct_count = 0\n\n        while end < len(s):\n            char = s[end]\n            char_count[char] = char_count.get(char, 0) + 1\n\n            if char_count[char] == 1:\n                distinct_count += 1\n\n            while distinct_count > 2:\n                left_char = s[start]\n                char_count[left_char] -= 1\n\n                if char_count[left_char] == 0:\n                    distinct_count -= 1\n\n                start += 1\n\n            longest = max(longest, end - start + 1)\n            end += 1\n\n        return longest\n\n    return longest_substring(s)\n\n\ndef g() -> str:\n    s = \"abaccc\"\n    return [s]\n\nassert f(g()) == True\n",
        "idx_generation": 265,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[str]]) -> bool:\n    \"\"\"\n    Given a 2D grid of characters and a word, determine if the word exists in the grid.\n    The word can be constructed from adjacent letters (horizontally or vertically) in the grid.\n\n    Example:\n    grid = [\n        ['A', 'B', 'C', 'E'],\n        ['S', 'F', 'C', 'S'],\n        ['A', 'D', 'E', 'E']\n    ]\n\n    word = \"ABCCED\"\n\n    Output:\n    True\n\n    Hint: Use backtracking to search for the word in the grid.\n    \"\"\"\n\n    def backtrack(i, j, word_idx):\n        if word_idx == len(word):\n            return True\n\n        if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != word[word_idx]:\n            return False\n\n        temp = grid[i][j]\n        grid[i][j] = '#'\n\n        if backtrack(i+1, j, word_idx+1) or backtrack(i-1, j, word_idx+1) or backtrack(i, j+1, word_idx+1) or backtrack(i, j-1, word_idx+1):\n            return True\n\n        grid[i][j] = temp\n\n        return False\n\n    m = len(grid)\n    n = len(grid[0])\n    word = \"ABCCED\"\n\n    for i in range(m):\n        for j in range(n):\n            if backtrack(i, j, 0):\n                return True\n\n    return False\n\ndef g():\n    grid = [\n        ['A', 'B', 'C', 'E'],\n        ['S', 'F', 'C', 'S'],\n        ['A', 'D', 'E', 'E']\n    ]\n    return [grid]\n\nassert f(*g()) == True\n",
        "idx_generation": 490,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of set bits (i.e., 1s) in its binary representation.\n\n    Example:\n    n = 7\n\n    Output:\n    3 (since the binary representation of 7 is 111 and it has 3 set bits)\n    \"\"\"\n    count = 0\n    while n > 0:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g() -> int:\n    return 7\n\nassert f(g()) == 3\n\n",
        "idx_generation": 485,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if a given number n is a power of 2.\n\n    Example:\n    n = 16\n\n    Output:\n    True\n\n    Explanation:\n    16 is a power of 2 since 2^4 = 16.\n    \"\"\"\n\n    def is_power_of_two(n: int) -> bool:\n        return n != 0 and (n & (n - 1)) == 0\n\n    return is_power_of_two(n)\n\n\ndef g() -> int:\n    n = 16\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 293,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the bitwise complement of the corresponding element in the input list.\n\n    Example:\n    nums = [2, 5, 8]\n\n    Output:\n    [~2, ~5, ~8]\n    \"\"\"\n    complement_list = []\n\n    for num in nums:\n        complement_list.append(~num)\n\n    return complement_list\n\ndef g(nums: List[int] = [2, 5, 8]):\n    return nums\n\nassert f(g()) == [-3, -6, -9]\n",
        "idx_generation": 431,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, check if there exists a subset of the list whose elements XOR to the target number.\n    Return True if such a subset exists, False otherwise.\n    \"\"\"\n    def subset_xor(nums: List[int], target: int, index: int, xor_sum: int) -> bool:\n        if xor_sum == target:\n            return True\n        if index >= len(nums):\n            return False\n        \n        # Include the current element in the subset\n        if subset_xor(nums, target, index + 1, xor_sum ^ nums[index]):\n            return True\n        \n        # Exclude the current element from the subset\n        if subset_xor(nums, target, index + 1, xor_sum):\n            return True\n        \n        return False\n    \n    return subset_xor(nums, target, 0, 0)\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g(), 7) == True\n\n",
        "idx_generation": 191,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n    The maximum XOR value is 28, which is obtained by XORing 5 and 25 (5 XOR 25 = 28).\n    Return this maximum XOR value.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor_val = nums[i] ^ nums[j]\n            if xor_val > max_xor:\n                max_xor = xor_val\n    return max_xor\n\ndef g():\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n\n",
        "idx_generation": 449,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of the first n terms of the arithmetic sequence.\n\n    Example:\n    n = 5\n\n    Output:\n    15\n\n    Explanation:\n    The sum of the first 5 terms of the arithmetic sequence is 1 + 2 + 3 + 4 + 5 = 15.\n    \"\"\"\n    return n * (n + 1) // 2\n\ndef g(n: int = 5) -> int:\n    return n\n\nassert f(g()) == 15\n\n",
        "idx_generation": 453,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "import math\nfrom typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the sum of all positive integers less than n that are divisible by 3 or 5.\n\n    Example:\n    n = 10\n\n    Output:\n    23\n\n    Explanation:\n    The positive integers less than 10 that are divisible by 3 or 5 are 3, 5, 6, and 9. Their sum is 23.\n\n    Hint: Use mathematical foundations and optimization algorithms to solve this problem.\n    \"\"\"\n    \n    def sum_divisible_by_k(k: int, n: int) -> int:\n        p = (n - 1) // k\n        return k * (p * (p + 1)) // 2\n\n    return (sum_divisible_by_k(3, n) + sum_divisible_by_k(5, n) - sum_divisible_by_k(15, n))\n\ndef g(n=10):\n    return n\n\nassert f(g()) == 23\n",
        "idx_generation": 225,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, count the number of paths from the top-left corner\n    to the bottom-right corner. You can only move down or right.\n\n    Sample Input:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n\n    Sample Output:\n    6\n    \"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n\n    # Create a 2D DP table to store the number of paths\n    dp = [[0] * n for _ in range(m)]\n\n    # Initialize the first row and column with 1\n    for i in range(m):\n        dp[i][0] = 1\n    for j in range(n):\n        dp[0][j] = 1\n\n    # Calculate the number of paths for each cell\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    # Return the number of paths to the bottom-right corner\n    return dp[m-1][n-1]\n\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix\n\nassert f(g()) == 6\n",
        "idx_generation": 222,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> float:\n    \"\"\"\n    Given a list of 2D points, find the closest pair of points using the Euclidean distance formula.\n\n    Example:\n    f([[1, 2], [3, 4], [5, 6], [7, 8]]) returns 2.8284271247461903, as the closest pair of points is [3, 4] and [5, 6].\n\n    Note:\n    - The input list can contain duplicate points.\n    \"\"\"\n\n    # Calculate the Euclidean distance between each pair of points\n    min_distance = float('inf')\n\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            distance = ((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) ** 0.5\n            if distance < min_distance:\n                min_distance = distance\n\n    return min_distance\n\n\ndef g(points: List[List[int]] = [[1, 2], [3, 4], [5, 6], [7, 8]]) -> List[List[int]]:\n    \"\"\"\n    Generate a list of 2D points.\n\n    Example:\n    g() returns [[1, 2], [3, 4], [5, 6], [7, 8]].\n\n    Note:\n    - The input list can contain duplicate points.\n    \"\"\"\n\n    return points\n\n\nassert f(g()) == 2.8284271247461903\n",
        "idx_generation": 308,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, calculate the maximum sum of a path from the top-left cell\n    to the bottom-right cell. The path can only move down, right, or diagonally.\n\n    Return the maximum sum.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    Output:\n    29\n\n    Explanation:\n    The maximum sum path is 1 -> 4 -> 7 -> 8 -> 9, which gives a total sum of 29.\n    \"\"\"\n\n    def max_sum_path(grid):\n        n = len(grid)\n        m = len(grid[0])\n        memo = [[0] * m for _ in range(n)]\n        memo[0][0] = grid[0][0]\n\n        for i in range(1, n):\n            memo[i][0] = memo[i-1][0] + grid[i][0]\n\n        for j in range(1, m):\n            memo[0][j] = memo[0][j-1] + grid[0][j]\n\n        for i in range(1, n):\n            for j in range(1, m):\n                memo[i][j] = grid[i][j] + max(memo[i-1][j], memo[i][j-1], memo[i-1][j-1])\n\n        return memo[n-1][m-1]\n\n    return max_sum_path(grid)\n\ndef g(grid: List[List[int]]):\n    \"\"\"\n    Generate a grid of integers with random values.\n    \"\"\"\n    return grid\n\nassert f(g([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) == 29\n",
        "idx_generation": 124,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two positive integers n and m, return the number of unique paths from the top-left corner of a n x m grid to the bottom-right corner.\n    You can only move right or down at any point in time.\n\n    Example:\n    n = 3\n    m = 4\n\n    Output:\n    10\n\n    Explanation:\n    The grid is represented as follows:\n    1  1  1  1\n    1  2  3  4\n    1  3  6 10\n    \n    There are 10 unique paths from the top-left corner to the bottom-right corner.\n\n    Hint: Use dynamic programming to solve this problem.\n    \"\"\"\n\n    dp = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            if i == 0 or j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[n-1][m-1]\n\ndef g() -> List[int]:\n    n = 3\n    m = 4\n    return [n, m]\n\nassert f(*g()) == 10\n",
        "idx_generation": 473,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number is a power of two.\n\n    Sample Input:\n    n = 16\n\n    Sample Output:\n    True\n    \"\"\"\n    if n <= 0:\n        return False\n\n    while n % 2 == 0:\n        n /= 2\n\n    return n == 1\n\ndef g(n=16):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 102,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: dict, start_node='A', end_node='E', max_distance=10) -> bool:\n    \"\"\"\n    Given a graph represented as a dictionary and two nodes (start_node and end_node), find if there is a path\n    from start_node to end_node with a total distance less than or equal to max_distance.\n    \"\"\"\n    visited = set()\n    stack = [(start_node, 0)]\n    while stack:\n        current_node, distance = stack.pop()\n        if current_node == end_node and distance <= max_distance:\n            return True\n        visited.add(current_node)\n        for neighbor, edge_distance in graph[current_node]:\n            if neighbor not in visited and distance + edge_distance <= max_distance:\n                stack.append((neighbor, distance + edge_distance))\n    return False\n\ndef g(graph = {'A': [('B', 2), ('C', 3)],\n                'B': [('C', 1), ('D', 4)],\n                'C': [('D', 2)],\n                'D': [('E', 3)],\n                'E': []},\n       start_node = 'A',\n       end_node = 'E',\n       max_distance = 10):\n    return graph\nassert f(g()) == True\n",
        "idx_generation": 19,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    Given a directed graph represented as a list of edges, determine if the graph contains a cycle.\n\n    Args:\n    - n: The number of nodes in the graph.\n    - edges: A list of edges, where each edge is represented as a list [source, target].\n\n    Returns:\n    - True if the graph contains a cycle, False otherwise.\n    \"\"\"\n    def dfs(node, visited, stack):\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in edges[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, stack):\n                    return True\n            elif stack[neighbor]:\n                return True\n        \n        stack[node] = False\n        return False\n    \n    visited = [False] * n\n    stack = [False] * n\n\n    for node in range(n):\n        if not visited[node]:\n            if dfs(node, visited, stack):\n                return True\n    \n    return False\n\ndef g():\n    n = 4\n    edges = [[0, 1], [1, 2], [2, 3], [3, 1]]\n    return n, edges\n\nassert f(*g()) == True\n",
        "idx_generation": 457,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int:\n    \"\"\"\n    Given a grid of integers, find the shortest path from the start cell to the end cell.\n    The grid contains obstacles represented by 1 and empty cells represented by 0.\n    The path can only move up, down, left, or right, and cannot pass through obstacles.\n\n    Example:\n    grid = [\n        [0, 0, 1, 0],\n        [0, 0, 0, 0],\n        [0, 1, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = (0, 0)\n    end = (3, 3)\n\n    Output:\n    6\n\n    Explanation:\n    The shortest path from (0, 0) to (3, 3) is: (0, 0) -> (1, 0) -> (2, 0) -> (2, 1) -> (2, 2) -> (2, 3) -> (3, 3).\n    The total distance is 6.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    queue = [(start[0], start[1], 0)]\n    visited = set()\n\n    while queue:\n        row, col, distance = queue.pop(0)\n\n        if (row, col) == end:\n            return distance\n\n        for dr, dc in directions:\n            new_row = row + dr\n            new_col = col + dc\n\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 0 and (new_row, new_col) not in visited:\n                queue.append((new_row, new_col, distance + 1))\n                visited.add((new_row, new_col))\n\n    return -1\n\ndef g() -> Tuple[List[List[int]], Tuple[int, int], Tuple[int, int]]:\n    \"\"\"\n    Generate a grid of integers, start and end positions.\n    \"\"\"\n    grid = [\n        [0, 0, 1, 0],\n        [0, 0, 0, 0],\n        [0, 1, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = (0, 0)\n    end = (3, 3)\n    return grid, start, end\n\nassert f(*g()) == 6\n",
        "idx_generation": 320,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of 0s and 1s, find the shortest path from the top-left corner to the bottom-right corner,\n    where 0 represents an obstacle and 1 represents a valid path. You can only move down or right.\n    The shortest path is defined as the path that requires the minimum number of steps.\n\n    - grid is a 2D list of integers, where each element is either 0 or 1.\n    - Return the minimum number of steps required to reach the bottom-right corner, or -1 if there is no valid path.\n    \"\"\"\n\n    def find_shortest_path(grid: List[List[int]], x: int, y: int, steps: int) -> int:\n        # Base cases\n        if x == len(grid) - 1 and y == len(grid[0]) - 1:\n            return steps\n        if x >= len(grid) or y >= len(grid[0]) or grid[x][y] == 0:\n            return float('inf')\n        \n        # Recursive cases\n        return min(find_shortest_path(grid, x + 1, y, steps + 1), find_shortest_path(grid, x, y + 1, steps + 1))\n\n    steps = find_shortest_path(grid, 0, 0, 0)\n    return steps if steps != float('inf') else -1\n\ndef g(grid: List[List[int]]):\n    return grid\n\nassert f(g([[1, 1, 0], [1, 0, 1], [1, 1, 1]])) == 4\n",
        "idx_generation": 117,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size n x n, where each cell contains either 0 or 1, determine the number of islands in the grid.\n    An island is formed by connecting adjacent cells horizontally or vertically (not diagonally) that contain a value of 1.\n\n    Args:\n    - n: An integer representing the size of the grid\n    - grid: A 2D list of integers representing the grid\n\n    Returns:\n    - The number of islands in the grid\n\n    Example:\n    n = 4, grid = [\n        [1, 1, 0, 0],\n        [0, 1, 0, 0],\n        [1, 0, 0, 1],\n        [0, 0, 1, 0]\n    ]\n    The grid has 4 islands, so the output should be 4.\n    \"\"\"\n    def dfs(i, j):\n        if i < 0 or i >= n or j < 0 or j >= n or grid[i][j] != 1:\n            return\n        grid[i][j] = -1\n        dfs(i+1, j)\n        dfs(i-1, j)\n        dfs(i, j+1)\n        dfs(i, j-1)\n\n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                count += 1\n                dfs(i, j)\n    return count\n\ndef g():\n    n = 4\n    grid = [\n        [1, 1, 0, 0],\n        [0, 1, 0, 0],\n        [1, 0, 0, 1],\n        [0, 0, 1, 0]\n    ]\n    return n, grid\n\nassert f(*g()) == 4\n",
        "idx_generation": 329,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Path Sum\n\n    Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.\n\n    Example:\n    nums = [5, 4, 8, 11, None, 13, 4, 7, 2, None, None, None, None, None, 1]\n    target = 22\n    output: True\n\n    Explanation:\n    The binary tree is shown below, where the numbers represent the node values:\n            5\n           / \\\n          4   8\n         /   / \\\n        11  13  4\n       /  \\      \\\n      7    2      1\n\n    The sum of the root-to-leaf path with values 5 -> 4 -> 11 -> 2 equals 22, so the output is True.\n    \"\"\"\n    def hasPathSum(node, target):\n        if node is None:\n            return False\n        if node.left is None and node.right is None and node.val == target:\n            return True\n        return hasPathSum(node.left, target - node.val) or hasPathSum(node.right, target - node.val)\n\n    return hasPathSum(nums, target)\n\ndef g(nums=[5, 4, 8, 11, None, 13, 4, 7, 2, None, None, None, None, None, 1], target=22):\n    \"\"\"\n    Helper function to generate binary tree from list representation\n    \"\"\"\n    class TreeNode:\n        def __init__(self, val=0, left=None, right=None):\n            self.val = val\n            self.left = left\n            self.right = right\n\n    def buildTree(nums, root, i, n):\n        if i < n:\n            if nums[i] is not None:\n                temp = TreeNode(nums[i])\n                root = temp\n                root.left = buildTree(nums, root.left, 2 * i + 1, n)\n                root.right = buildTree(nums, root.right, 2 * i + 2, n)\n            else:\n                root = None\n        return root\n\n    return buildTree(nums, None, 0, len(nums))\n\nassert f(g(), 22) == True\n",
        "idx_generation": 189,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, k: int) -> bool:\n    \"\"\"\n    Check if there exists a path in the given graph from start to end with a sum of k, using at most k edges.\n    The graph is represented as an adjacency matrix.\n    \"\"\"\n\n    def dfs(node, path_sum, num_edges):\n        if node == end and path_sum == k:\n            return True\n        if num_edges == k:\n            return False\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] != 0:\n                if dfs(neighbor, path_sum + graph[node][neighbor], num_edges + 1):\n                    return True\n        return False\n\n    return dfs(start, 0, 0)\n\ndef g():\n    graph = [\n        [0, 2, 0, 0],\n        [0, 0, 1, 3],\n        [0, 0, 0, 2],\n        [0, 0, 0, 0]\n    ]\n    start = 1\n    end = 3\n    k = 3\n    return graph, start, end, k\n\nassert f(*g()) == True\n",
        "idx_generation": 165,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target integer, find all unique combinations of numbers in the list that add up to the target.\n\n    Return a list of lists containing the combinations.\n\n    Example:\n    nums = [2, 3, 6, 7]\n    target = 7\n\n    Output:\n    [[2, 2, 3], [7]]\n\n    Explanation:\n    There are two unique combinations that add up to 7: [2, 2, 3] and [7].\n    \"\"\"\n    def backtrack(start, target, path):\n        if target == 0:\n            result.append(path)\n            return\n        elif target < 0:\n            return\n\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            backtrack(i, target - nums[i], path + [nums[i]])\n\n    nums.sort()\n    result = []\n    backtrack(0, target, [])\n    return result\n\ndef g():\n    nums = [2, 3, 6, 7]\n    target = 7\n    return nums, target\n\nassert f(*g()) == [[2, 2, 3], [7]]\n",
        "idx_generation": 488,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, find if there exists a subsequence such that the sum of its elements is a perfect square.\n    \"\"\"\n    def is_perfect_square(n):\n        if n < 0:\n            return False\n        root = int(n ** 0.5)\n        return root * root == n\n\n    def helper(nums, target, index, memo):\n        if target == 0:\n            return True\n        if index >= len(nums) or target < 0:\n            return False\n        if (index, target) in memo:\n            return memo[(index, target)]\n        include = helper(nums, target - nums[index], index + 1, memo)\n        exclude = helper(nums, target, index + 1, memo)\n        memo[(index, target)] = include or exclude\n        return memo[(index, target)]\n\n    return helper(nums, sum(nums), 0, {}) or is_perfect_square(sum(nums))\n\ndef g(nums: List[int]):\n    return nums\n\nassert f(g([1, 2, 3, 4, 5]))\n\n",
        "idx_generation": 187,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, m: int, k=3) -> bool:\n    \"\"\"\n    Given two integers n and m, determine whether there exists a list of k integers such that the sum of any two\n    integers in the list is divisible by either n or m.\n    \"\"\"\n    def helper(arr, n, m, k):\n        if k == 0:\n            return True\n        for num in arr:\n            if (num + arr[0]) % n == 0 or (num + arr[0]) % m == 0:\n                if helper(arr[1:], n, m, k-1):\n                    return True\n        return False\n    \n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return helper(arr, n, m, k)\n\ndef g():\n    n = 3\n    m = 4\n    return n, m\n\nassert f(*g()) == True\n",
        "idx_generation": 70,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n    If the target value is not present in the list, return -1.\n\n    Args:\n    - arr: A sorted list of integers.\n    - target: The target value.\n\n    Returns:\n    - The index of the target value in the list, or -1 if not found.\n\n    Example:\n    f([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 6) returns 5\n    f([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 11) returns -1\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n\n    Returns:\n    - The generated list and the target value.\n\n    Example:\n    g() returns ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 6)\n    \"\"\"\n\n    return ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 6)\n\nassert f(*g()) == 5\n\n",
        "idx_generation": 455,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Determine if the given list of integers is sorted in non-decreasing order.\n    \"\"\"\n    return arr == sorted(arr)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of 5 integers in non-decreasing order.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == True\n",
        "idx_generation": 62,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string has balanced parentheses.\n\n    Sample Input:\n    s = \"((())())\"\n\n    Sample Output:\n    True\n    \"\"\"\n    stack = []\n    for char in s:\n        if char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g(s = \"((())())\"):\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 65,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the number of unique paths from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Args:\n    - grid: A 2D grid of non-negative integers.\n\n    Returns:\n    - The number of unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    return grid\n\nassert f(g()) == 6\n",
        "idx_generation": 472,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    Output:\n    4\n\n    Explanation:\n    The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n\n    Hint: Use dynamic programming to keep track of the longest increasing subsequence at each index.\n    \"\"\"\n    if not nums:\n        return 0\n\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g(nums=[10, 9, 2, 5, 3, 7, 101, 18]):\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 61,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers where each cell represents the elevation, find the highest point\n    in the grid and return its value.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    output: 9\n\n    Explanation:\n    The highest point in the grid is 9.\n    \"\"\"\n\n    max_elevation = float('-inf')\n\n    for row in grid:\n        for elevation in row:\n            if elevation > max_elevation:\n                max_elevation = elevation\n\n    return max_elevation\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g()) == 9\n",
        "idx_generation": 79,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome.\"\"\"\n    stack = []\n    for char in s:\n        stack.append(char)\n    reverse = \"\"\n    while stack:\n        reverse += stack.pop()\n    return reverse == s\n\ndef g(s=\"racecar\"):\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 9,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, li=[1, 2, 3, 4, 5]) -> bool:\n    \"\"\"Check if the sum of a list of numbers is equal to a given number.\"\"\"\n    return sum(li) == n\ndef g(n = 15, li = [1, 2, 3, 4, 5]):\n    return n\nassert f(g()) == True\n",
        "idx_generation": 48,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Find two numbers in the given list that add up to the target number.\n    Return the indices of the two numbers.\n    \"\"\"\n    num_dict = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        if complement in num_dict:\n            return [num_dict[complement], i]\n        \n        num_dict[num] = i\n    \n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 287,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, return True if there exists a pair of numbers (a, b) such that a XOR b is equal to the\n    maximum value in the list. Otherwise, return False.\n    \"\"\"\n    max_val = max(nums)\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] ^ nums[j] == max_val:\n                return True\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g()) == True\n",
        "idx_generation": 30,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target=10, k=3) -> bool:\n    \"\"\"Find a subgrid of size k x k that sums up to the target value.\"\"\"\n    def helper(grid, target, k, row, col, curr_sum):\n        if curr_sum == target and k == 0:\n            return True\n        if curr_sum > target or k == 0:\n            return False\n        if col >= len(grid[0]):\n            return helper(grid, target, k, row + 1, 0, 0)\n        if row >= len(grid):\n            return False\n        if helper(grid, target, k - 1, row, col + 1, curr_sum + grid[row][col]):\n            return True\n        return helper(grid, target, k, row, col + 1, curr_sum)\n\n    return helper(grid, target, k, 0, 0, 0)\n\ndef g(target = 10, k = 3):\n    grid = [\n        [1, 2, 3, 4],\n        [5, 6, 7, 8],\n        [9, 10, 11, 12],\n        [13, 14, 15, 16]\n    ]\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 33,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, check if there exists a pair of numbers in the list whose sum is equal to the target number.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums = [1, 2, 3, 4, 5, 6, 7, 8, 9], target = 10):\n    return nums\n\nassert f(g(), target=10) == True\n",
        "idx_generation": 39,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency list, determine if there exists a path from a given start node\n    to a given end node.\n\n    Return True if a path exists, and False otherwise.\n\n    Example:\n    graph = {1: [2, 3],\n             2: [4],\n             3: [4],\n             4: []}\n    start = 1, end = 4\n    The graph is represented as follows:\n    1 -> 2 -> 4\n     \\-> 3 -> 4\n    There exists a path from node 1 to node 4, so the function should return True.\n    \"\"\"\n    visited = set()\n    stack = deque([start])\n\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n\n    return False\n\ndef g():\n    return {1: [2, 3],\n            2: [4],\n            3: [4],\n            4: []}, 1, 4\n\nassert f(*g()) == True\n\n",
        "idx_generation": 483,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> List[int]:\n    \"\"\"\n    Find the shortest path from the start node to the end node in the given graph\n    \"\"\"\n    n = len(graph)\n    dist = [float('inf')] * n\n    dist[0] = 0\n\n    for _ in range(n-1):\n        for u in range(n):\n            for v in range(n):\n                if graph[u][v] != 0 and dist[u] + graph[u][v] < dist[v]:\n                    dist[v] = dist[u] + graph[u][v]\n\n    return dist\n\ndef g(graph = [[0, 4, 0, 0, 0, 0, 0, 8, 0], \n               [4, 0, 8, 0, 0, 0, 0, 11, 0], \n               [0, 8, 0, 7, 0, 4, 0, 0, 2], \n               [0, 0, 7, 0, 9, 14, 0, 0, 0], \n               [0, 0, 0, 9, 0, 10, 0, 0, 0], \n               [0, 0, 4, 14, 10, 0, 2, 0, 0], \n               [0, 0, 0, 0, 0, 2, 0, 1, 6], \n               [8, 11, 0, 0, 0, 0, 1, 0, 7], \n               [0, 0, 2, 0, 0, 0, 6, 7, 0]]):\n    return graph\n\nassert f(g()) == [0, 4, 12, 19, 21, 11, 9, 8, 14]\n",
        "idx_generation": 21,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom heapq import heappop, heappush\n\ndef f(n: int, edges: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Given a number n and a list of edges representing a weighted directed graph,\n    find the shortest path from node 0 to node n-1.\n    Return the length of the shortest path.\n    \"\"\"\n    graph = [[] for _ in range(n)]\n    for u, v, weight in edges:\n        graph[u].append((v, weight))\n    \n    dp = [-1] * n\n    dp[0] = 0\n    \n    heap = [(0, 0)]\n    while heap:\n        dist, node = heappop(heap)\n        if dp[node] < dist:\n            continue\n        for neighbor, weight in graph[node]:\n            if dp[neighbor] == -1 or dp[neighbor] > dist + weight:\n                dp[neighbor] = dist + weight\n                heappush(heap, (dp[neighbor], neighbor))\n    \n    return dp[n-1]\n\ndef g():\n    n = 5\n    edges = [(0, 1, 1), (1, 2, 2), (0, 3, 3), (3, 4, 4), (2, 4, 5)]\n    return (n, edges)\n\nassert f(*g()) == 7\n\n",
        "idx_generation": 82,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> bool:\n    \"\"\"\n    Given a list of 2D points, determine if they form a square.\n\n    Sample Input:\n    points = [[0, 0], [0, 1], [1, 1], [1, 0]]\n\n    Sample Output:\n    True\n\n    The points form a square with side length 1.\n    \"\"\"\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    if len(points) != 4:\n        return False\n\n    distances = set()\n    for i in range(3):\n        for j in range(i + 1, 4):\n            distances.add(distance(points[i], points[j]))\n\n    return len(distances) == 2\n\ndef g():\n    return [[0, 0], [0, 1], [1, 1], [1, 0]]\n\nassert f(g()) == True\n",
        "idx_generation": 280,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters representing a maze, find the minimum number of steps required to reach the target 'T' from the starting position 'S'.\n    The grid contains the following characters:\n    - 'S': starting position\n    - 'T': target position\n    - '.': empty cell\n    - '#': wall (cannot pass through)\n\n    You can only move up, down, left, or right from a given cell.\n    You cannot move diagonally or pass through walls.\n\n    Example:\n    grid = [\n        ['S', '.', '#', '#'],\n        ['#', '.', '.', '#'],\n        ['.', '#', '.', '.'],\n        ['#', '#', '.', 'T']\n    ]\n\n    Output:\n    6 (the minimum number of steps required is 6)\n\n    Explanation:\n    Start at position (0, 0).\n    Move right to (0, 1).\n    Move right to (0, 2).\n    Move down to (1, 2).\n    Move down to (2, 2).\n    Move right to (2, 3).\n    Reach the target at (3, 3).\n    \"\"\"\n    if not grid or not grid[0]:\n        return -1\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    \n    start = None\n    target = None\n    \n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'T':\n                target = (i, j)\n    \n    if not start or not target:\n        return -1\n    \n    visited = set()\n    queue = [(start, 0)]\n    \n    while queue:\n        curr_pos, steps = queue.pop(0)\n        i, j = curr_pos\n        \n        if curr_pos == target:\n            return steps\n        \n        if curr_pos in visited:\n            continue\n        \n        visited.add(curr_pos)\n        \n        if i > 0 and grid[i-1][j] != '#':\n            queue.append(((i-1, j), steps+1))\n        \n        if i < rows-1 and grid[i+1][j] != '#':\n            queue.append(((i+1, j), steps+1))\n        \n        if j > 0 and grid[i][j-1] != '#':\n            queue.append(((i, j-1), steps+1))\n        \n        if j < cols-1 and grid[i][j+1] != '#':\n            queue.append(((i, j+1), steps+1))\n    \n    return -1\n\ndef g() -> List[List[str]]:\n    return [\n        ['S', '.', '#', '#'],\n        ['#', '.', '.', '#'],\n        ['.', '#', '.', '.'],\n        ['#', '#', '.', 'T']\n    ]\n\nassert f(g()) == 6\n",
        "idx_generation": 329,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value between any two elements.\n\n    Return the maximum XOR value.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value is between 5 and 25, which is 28 (5 XOR 25 = 28).\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            max_xor = max(max_xor, nums[i] ^ nums[j])\n\n    return max_xor\n\ndef g(nums: List[int] = [3, 10, 5, 25, 2, 8]) -> List[int]:\n    return nums\n\nassert f(g()) == 28\n\n",
        "idx_generation": 269,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers, find two numbers such that they add up to a specific target.\n    Return their indices.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        if target - num in num_dict:\n            return [num_dict[target - num], i]\n        num_dict[num] = i\n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 152,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return the elements of the matrix in spiral order.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    Output: [1, 2, 3, 6, 9, 8, 7, 4, 5]\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    top = 0\n    bottom = rows - 1\n    left = 0\n    right = cols - 1\n    \n    spiral = []\n    \n    while top <= bottom and left <= right:\n        \n        for i in range(left, right + 1):\n            spiral.append(matrix[top][i])\n        \n        top += 1\n        \n        for i in range(top, bottom + 1):\n            spiral.append(matrix[i][right])\n        \n        right -= 1\n        \n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                spiral.append(matrix[bottom][i])\n        \n            bottom -= 1\n        \n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                spiral.append(matrix[i][left])\n        \n            left += 1\n    \n    return spiral\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 164,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Hint: Use a trie data structure to store the binary representation of the numbers.\n    \"\"\"\n\n    class TrieNode:\n        def __init__(self):\n            self.children = [None, None]\n\n    def insert(root, num):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if not node.children[bit]:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def find_max_xor(root, num):\n        node = root\n        xor = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if node.children[1 - bit]:\n                xor |= 1 << i\n                node = node.children[1 - bit]\n            else:\n                node = node.children[bit]\n        return xor\n\n    root = TrieNode()\n    for num in nums:\n        insert(root, num)\n\n    max_xor = float('-inf')\n    for num in nums:\n        max_xor = max(max_xor, find_max_xor(root, num))\n\n    return max_xor\n\ndef g(nums=[3, 10, 5, 25, 2, 8]):\n    return (nums,)\n\nassert f(*g()) == 28\n",
        "idx_generation": 413,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and an integer k, return True if there exists a subarray in nums that sums up to k,\n    otherwise return False.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    k = 9\n\n    Output:\n    True\n    \"\"\"\n    n = len(nums)\n    prefix_sum = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]\n\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            if prefix_sum[j] - prefix_sum[i] == k:\n                return True\n\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    k = 9\n    return nums, k\n\nassert f(*g()) == True\n",
        "idx_generation": 330,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers 'arr' and an integer 'k', find the maximum sum of any subarray of size k.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    k = 3\n\n    Output:\n    12\n\n    Explanation:\n    The subarrays of size 3 are [1, 2, 3], [2, 3, 4], and [3, 4, 5].\n    The maximum sum is 12, which is the sum of [3, 4, 5].\n\n    Hint: Use a sliding window approach to optimize the algorithm.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    window_start = 0\n\n    for window_end in range(len(arr)):\n        current_sum += arr[window_end]\n\n        if window_end >= k - 1:\n            max_sum = max(max_sum, current_sum)\n            current_sum -= arr[window_start]\n            window_start += 1\n\n    return max_sum\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g(), k=3) == 12\n",
        "idx_generation": 150,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, check if it is a magic square.\n    A magic square is a square matrix in which the sum of each row, each column, and both diagonals are equal.\n    Return True if the matrix is a magic square, False otherwise.\n    \"\"\"\n\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for j in range(n):\n        col_sum = 0\n        for i in range(n):\n            col_sum += matrix[i][j]\n        if col_sum != target_sum:\n            return False\n\n    # Check diagonal 1\n    diag1_sum = 0\n    for i in range(n):\n        diag1_sum += matrix[i][i]\n    if diag1_sum != target_sum:\n        return False\n\n    # Check diagonal 2\n    diag2_sum = 0\n    for i in range(n):\n        diag2_sum += matrix[i][n - i - 1]\n    if diag2_sum != target_sum:\n        return False\n\n    return True\n\ndef g(matrix=[[2, 7, 6], [9, 5, 1], [4, 3, 8]]):\n    return matrix\n\nassert f(g()) == True\n",
        "idx_generation": 267,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Generate Pascal's triangle up to the given number of rows.\n\n    Sample Input:\n    n = 5\n\n    Sample Output:\n    [\n        [1],\n        [1, 1],\n        [1, 2, 1],\n        [1, 3, 3, 1],\n        [1, 4, 6, 4, 1]\n    ]\n    \"\"\"\n    triangle = []\n\n    for i in range(n):\n        row = [1] * (i + 1)\n        for j in range(1, i):\n            row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n        triangle.append(row)\n\n    return triangle\n\ndef g():\n    return 5\n\nassert f(g()) == [\n    [1],\n    [1, 1],\n    [1, 2, 1],\n    [1, 3, 3, 1],\n    [1, 4, 6, 4, 1]\n]\n",
        "idx_generation": 160,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(string: str) -> str:\n    \"\"\"\n    Given a string, return the longest substring that contains only unique characters.\n\n    Sample Input:\n    string = \"abccdefg\"\n\n    Sample Output:\n    \"cdefg\"\n    \"\"\"\n    max_substring = \"\"\n    current_substring = \"\"\n    seen = set()\n\n    for char in string:\n        if char not in seen:\n            current_substring += char\n            seen.add(char)\n        else:\n            if len(current_substring) > len(max_substring):\n                max_substring = current_substring\n            current_substring = char\n            seen = {char}\n\n    if len(current_substring) > len(max_substring):\n        max_substring = current_substring\n\n    return max_substring\n\ndef g():\n    return [\"abccdefg\"]\n\nassert f(*g()) == \"cdefg\"\n\n",
        "idx_generation": 162,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the count of numbers that have exactly 3 set bits (1s) in their binary representation.\n\n    Example:\n    n = 8\n\n    Output:\n    1\n\n    Explanation:\n    The binary representation of 8 is 1000, which has only 1 set bit.\n    \"\"\"\n    count = 0\n    \n    for i in range(n+1):\n        if bin(i).count('1') == 3:\n            count += 1\n    \n    return count\n\ndef g(n: int = 8) -> int:\n    \"\"\"\n    Generate an integer for the function f.\n    \"\"\"\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 224,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum sum of a subarray in nums\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 142,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target integer, find two numbers in the list that sum up to the target.\n\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n\n    Sample Input:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Sample Output:\n    [2, 7]\n\n    Explanation: The sum of 2 and 7 is equal to 9.\n\n    Hint: Use a dictionary to store the complement of each number encountered in the list. Check if the complement exists in the dictionary to find the two numbers that sum up to the target.\n    \"\"\"\n    complement_map = {}\n    for num in nums:\n        complement = target - num\n        if complement in complement_map:\n            return [complement, num]\n        complement_map[num] = complement\n\n    return []\n\ndef g(nums: List[int] = [2, 7, 11, 15], target: int = 9) -> List[int]:\n    \"\"\"Generate a list of integers and a target integer.\"\"\"\n    return nums, target\n\nassert f(*g()) == [2, 7]\n\n",
        "idx_generation": 271,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers 'arr', determine if there exists a subarray whose sum is a perfect square.\n\n    Args:\n    - arr: A list of integers.\n\n    Returns:\n    - True if there exists a subarray whose sum is a perfect square, False otherwise.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n\n    Output:\n    True\n\n    Explanation:\n    The subarray [3, 4] has a sum of 7, which is a perfect square (3^2 = 9).\n    \"\"\"\n\n    prefix_sum = 0\n    sum_map = {0: 0}\n\n    for i in range(len(arr)):\n        prefix_sum += arr[i]\n        if prefix_sum in sum_map:\n            return True\n        sum_map[prefix_sum] = i + 1\n\n        for j in range(1, int(prefix_sum ** 0.5) + 1):\n            if (prefix_sum - j * j) in sum_map:\n                return True\n\n    return False\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for the function f.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == True\n\n",
        "idx_generation": 312,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if the given matrix is a magic square.\"\"\"\n    n = len(matrix)\n    target_sum = n * (n ** 2 + 1) // 2\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for j in range(n):\n        col_sum = 0\n        for i in range(n):\n            col_sum += matrix[i][j]\n        if col_sum != target_sum:\n            return False\n\n    # Check diagonals\n    diag1_sum = 0\n    diag2_sum = 0\n    for i in range(n):\n        diag1_sum += matrix[i][i]\n        diag2_sum += matrix[i][n - i - 1]\n    if diag1_sum != target_sum or diag2_sum != target_sum:\n        return False\n\n    return True\n\ndef g():\n    matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    return matrix\n\nassert f(g()) == True\n",
        "idx_generation": 224,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of all the elements except the\n    corresponding element in the original list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    [9, 8, 7, 6]\n\n    Explanation:\n    The sum of all the elements except 1 is 2 + 3 + 4 = 9.\n    The sum of all the elements except 2 is 1 + 3 + 4 = 8.\n    The sum of all the elements except 3 is 1 + 2 + 4 = 7.\n    The sum of all the elements except 4 is 1 + 2 + 3 = 6.\n    \"\"\"\n\n    total_sum = sum(nums)\n    n = len(nums)\n    new_nums = []\n    for num in nums:\n        new_nums.append(total_sum - num)\n    return new_nums\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == [9, 8, 7, 6]\n",
        "idx_generation": 361,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Determine if there exists a pair of numbers in the list whose sum equals the target.\n    \"\"\"\n    complements = set()\n    for num in nums:\n        if num in complements:\n            return True\n        complements.add(target - num)\n    return False\n\ndef g():\n    \"\"\"\n    Generate a list of numbers and a target sum.\n    \"\"\"\n    return [1, 2, 3, 4, 5], 9\n\nassert f(*g())\n",
        "idx_generation": 98,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> List[List[int]]:\n    \"\"\"\n    Given two integers n and m, generate a matrix of size n x m where each element is the product of its row number and column number.\n\n    Example:\n    n = 3, m = 4\n\n    Output:\n    [[0, 0, 0, 0],\n     [0, 1, 2, 3],\n     [0, 2, 4, 6]]\n\n    Explanation:\n    The matrix is generated as follows:\n    - The first row and first column contain all zeros.\n    - Each element in the matrix is the product of its row number and column number.\n\n    Hint: Use nested loops to iterate over the rows and columns of the matrix.\n    \"\"\"\n\n    matrix = []\n\n    for i in range(n):\n        row = []\n        for j in range(m):\n            row.append(i * j)\n        matrix.append(row)\n\n    return matrix\n\ndef g() -> List[int]:\n    n = 3\n    m = 4\n    return n, m\n\nassert f(*g()) == [[0, 0, 0, 0], [0, 1, 2, 3], [0, 2, 4, 6]]\n",
        "idx_generation": 386,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR value between any two elements in the array.\n\n    Example:\n    Input:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value is 28, which can be obtained by XORing 5 and 25 (5 XOR 25 = 28).\n    \"\"\"\n\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n\n    def insert(root: TrieNode, num: int):\n        node = root\n\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n\n            node = node.children[bit]\n\n    def findMaxXOR(root: TrieNode, num: int) -> int:\n        node = root\n        maxXOR = 0\n\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            oppositeBit = 1 - bit\n\n            if oppositeBit in node.children:\n                maxXOR |= (1 << i)\n                node = node.children[oppositeBit]\n            else:\n                node = node.children[bit]\n\n        return maxXOR\n\n    root = TrieNode()\n    maxXOR = 0\n\n    for num in nums:\n        insert(root, num)\n        maxXOR = max(maxXOR, findMaxXOR(root, num))\n\n    return maxXOR\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate an array of integers.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n",
        "idx_generation": 292,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Determine if a given matrix is a magic square.\n\n    A magic square is a square matrix in which the sum of every row, column, and diagonal is the same.\n\n    Return True if the matrix is a magic square, False otherwise.\n\n    Example:\n    matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n\n    Output:\n    True\n\n    Hint: Calculate the sum of the first row and use it as a reference to check the sums of the other rows, columns, and diagonals.\n    \"\"\"\n\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = 0\n        for row in matrix:\n            col_sum += row[col]\n        if col_sum != target_sum:\n            return False\n\n    # Check diagonal from top left to bottom right\n    diagonal_sum = 0\n    for i in range(n):\n        diagonal_sum += matrix[i][i]\n    if diagonal_sum != target_sum:\n        return False\n\n    # Check diagonal from top right to bottom left\n    diagonal_sum = 0\n    for i in range(n):\n        diagonal_sum += matrix[i][n-i-1]\n    if diagonal_sum != target_sum:\n        return False\n\n    return True\n\ndef g():\n    matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    return matrix\n\nassert f(g()) == True\n",
        "idx_generation": 363,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum that can be obtained by starting at the top-left cell and moving\n    either right or down at each step, until reaching the bottom-right cell.\n\n    The function should return the maximum sum.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 12\n",
        "idx_generation": 256,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the number of triplets (i, j, k) such that i < j < k and arr[i] < arr[j] < arr[k].\n\n    Args:\n    - arr: A list of integers.\n\n    Returns:\n    - The number of triplets satisfying the condition.\n    \"\"\"\n    n = len(arr)\n    count = 0\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if arr[i] < arr[j] < arr[k]:\n                    count += 1\n    return count\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    return arr\n\nassert f(g()) == 10\n",
        "idx_generation": 457,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(heights: List[int]) -> bool:\n    \"\"\"Determine the largest rectangle area in a histogram.\"\"\"\n    max_area = 0\n    stack = [-1]\n    for i in range(len(heights)):\n        while stack[-1] != -1 and heights[stack[-1]] >= heights[i]:\n            h = heights[stack.pop()]\n            w = i - 1 - stack[-1]\n            max_area = max(max_area, h * w)\n        stack.append(i)\n    while stack[-1] != -1:\n        h = heights[stack.pop()]\n        w = len(heights) - 1 - stack[-1]\n        max_area = max(max_area, h * w)\n    return max_area > 0\n\ndef g():\n    return [2, 1, 5, 6, 2, 3]\n\nassert f(g()) == True\n",
        "idx_generation": 20,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\n    You can only move either down or right at any point in time.\n\n    Example:\n    Input: 3\n    Output: 6\n    Explanation: There are 6 unique paths from (0, 0) to (2, 2).\n    \"\"\"\n\n    def unique_paths(m: int, n: int) -> int:\n        if m == 1 or n == 1:\n            return 1\n        return unique_paths(m - 1, n) + unique_paths(m, n - 1)\n\n    return unique_paths(n, n)\n\ndef g(n=3):\n    return n\n\nassert f(g()) == 6\n",
        "idx_generation": 455,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the minimum number of jumps required to reach the last index, starting from the first index.\n    Each element in the array represents the maximum number of steps that can be jumped from that position.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The minimum number of jumps required to reach the last index.\n    \"\"\"\n    n = len(nums)\n    jumps = [float('inf')] * n\n    jumps[0] = 0\n\n    for i in range(1, n):\n        for j in range(i):\n            if j + nums[j] >= i:\n                jumps[i] = min(jumps[i], jumps[j] + 1)\n\n    return jumps[-1]\n\ndef g():\n    nums = [2, 3, 1, 1, 4, 2, 1]\n    return nums\n\nassert f(g()) == 3\n",
        "idx_generation": 128,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    return grid\n\nassert f(g()) == 12\n",
        "idx_generation": 45,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the maximum area of a rectangle with all 1s.\n\n    Example:\n    grid = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n\n    Output:\n    6\n\n    Hint: Use dynamic programming to calculate the maximum area of a rectangle ending at each point in the grid.\n    \"\"\"\n\n    if not grid:\n        return 0\n    \n    m, n = len(grid), len(grid[0])\n    heights = [0] * n\n    max_area = 0\n    \n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                heights[j] = 0\n            else:\n                heights[j] += 1\n                \n        max_area = max(max_area, calculate_area(heights))\n        \n    return max_area\n    \ndef calculate_area(heights: List[int]) -> int:\n    stack = [-1]\n    max_area = 0\n    \n    for i in range(len(heights)):\n        while stack[-1] != -1 and heights[stack[-1]] >= heights[i]:\n            h = heights[stack.pop()]\n            w = i - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        stack.append(i)\n        \n    while stack[-1] != -1:\n        h = heights[stack.pop()]\n        w = len(heights) - stack[-1] - 1\n        max_area = max(max_area, h * w)\n        \n    return max_area\n\ndef g():\n    return [[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]\n\nassert f(g()) == 6\n\n",
        "idx_generation": 241,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"\n    Given a string, check if it is a palindrome.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n\n    Args:\n    - string: The input string.\n\n    Returns:\n    - True if the string is a palindrome, False otherwise.\n\n    Example:\n    f(\"racecar\") returns True\n    f(\"hello\") returns False\n    \"\"\"\n\n    return string == string[::-1]\n\ndef g() -> str:\n    \"\"\"\n    Generate a string.\n\n    Returns:\n    - The generated string.\n\n    Example:\n    g() returns \"racecar\"\n    \"\"\"\n\n    return \"racecar\"\n\nassert f(g()) == True\n\n",
        "idx_generation": 455,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "import math\nfrom typing import*\nfrom typing import List\n\ndef f(equation: str) -> bool:\n    \"\"\"\n    Given a mathematical equation as a string, determine if it is balanced.\n\n    Example:\n    equation = \"(2 + 3) * 4 - 5\"\n\n    Output:\n    True\n\n    Explanation:\n    The equation is balanced with matching opening and closing parentheses.\n\n    Hint: Use a stack to keep track of opening parentheses and check for balanced pairs.\n    \"\"\"\n    stack = []\n    for char in equation:\n        if char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if not stack or stack.pop() != \"(\":\n                return False\n    \n    return len(stack) == 0\n\ndef g(equation=\"(2 + 3) * 4 - 5\"):\n    return equation\n\nassert f(g()) == True\n",
        "idx_generation": 239,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome after removing at most one character.\n    Return True if the string is a palindrome after removal, False otherwise.\n\n    Example:\n    s = \"abca\"\n\n    Output:\n    True\n\n    Explanation:\n    Removing 'b' results in the string \"aca\", which is a palindrome.\n    \"\"\"\n\n    def is_palindrome(s, left, right):\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n\n    n = len(s)\n    left = 0\n    right = n - 1\n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s, left + 1, right) or is_palindrome(s, left, right - 1)\n        left += 1\n        right -= 1\n    return True\n\ndef g() -> str:\n    s = \"abca\"\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 361,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value between any two numbers in the list.\n    Return the maximum XOR value.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value is obtained by XORing 5 and 25, which gives 28.\n\n    Hint: Use the bit manipulation skill to find the maximum XOR value. Iterate through all possible prefixes of the numbers and check if there is a pair of numbers that XOR to a higher value.\n    \"\"\"\n\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = set()\n        for num in nums:\n            prefixes.add(num & mask)\n        max_possible_xor = max_xor | (1 << i)\n        for prefix in prefixes:\n            if prefix ^ max_possible_xor in prefixes:\n                max_xor = max_possible_xor\n                break\n\n    return max_xor\n\ndef g(nums=[3, 10, 5, 25, 2, 8]):\n    return nums\n\nassert f(g()) == 28\n\n",
        "idx_generation": 489,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two elements.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value can be obtained by XORing 5 and 25, which results in 28.\n\n    Hint: Use bitwise XOR to compare all pairs of numbers and keep track of the maximum XOR value.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor\n\ndef g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n\n",
        "idx_generation": 484,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find the two numbers that have the maximum XOR value.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    [5, 25]\n\n    Explanation:\n    The maximum XOR value is 28, which is achieved by XORing 5 and 25.\n    \"\"\"\n\n    max_xor = 0\n    result = []\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor_val = nums[i] ^ nums[j]\n            if xor_val > max_xor:\n                max_xor = xor_val\n                result = [nums[i], nums[j]]\n\n    return result\n\n\ndef g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]\n\n\nassert f(g()) == [5, 25]\n",
        "idx_generation": 454,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of unique combinations that can be obtained by bitwise OR operations on subsets of the array.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The number of unique combinations.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    8\n\n    Explanation:\n    The unique combinations that can be obtained by bitwise OR operations on subsets of the array are:\n    - 1\n    - 2\n    - 3\n    - 4\n    - 1 | 2 = 3\n    - 1 | 3 = 3\n    - 2 | 3 = 3\n    - 1 | 2 | 3 = 3\n\n    There are 8 unique combinations in total.\n\n    \"\"\"\n\n    n = len(nums)\n    if n == 0:\n        return 0\n\n    unique_combinations = set()\n    \n    def backtrack(index, combination):\n        unique_combinations.add(combination)\n        \n        for i in range(index, n):\n            new_combination = combination | nums[i]\n            backtrack(i + 1, new_combination)\n    \n    backtrack(0, 0)\n    \n    return len(unique_combinations)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for the function f.\n    \"\"\"\n    return [1, 2, 3, 4]\n\nassert f(g()) == 8\n\n",
        "idx_generation": 259,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the nth number in the Fibonacci sequence.\n\n    Args:\n    - n: A positive integer.\n\n    Returns:\n    - The nth number in the Fibonacci sequence.\n    \"\"\"\n\n    # Define base cases\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n\n    # Initialize variables\n    fib_1 = 0\n    fib_2 = 1\n\n    # Generate Fibonacci sequence\n    for i in range(2, n+1):\n        fib = fib_1 + fib_2\n        fib_1 = fib_2\n        fib_2 = fib\n\n    return fib\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 5\n\n",
        "idx_generation": 461,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, return the number of unique paths from the top-left corner to the bottom-right corner.\n    You can only move down or right at any point in time.\n\n    Args:\n    - matrix: A 2D matrix of integers.\n\n    Returns:\n    - The number of unique paths from the top-left corner to the bottom-right corner.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    6\n\n    Explanation:\n    The number of unique paths from the top-left corner to the bottom-right corner is 6.\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = 1\n\n    for i in range(1, rows):\n        dp[i][0] = 1\n\n    for j in range(1, cols):\n        dp[0][j] = 1\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[rows-1][cols-1]\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == 6\n\n",
        "idx_generation": 422,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, check if it is a magic square.\n\n    A magic square is a square grid of numbers such that the sums of the numbers in each row, each column, and both main diagonals are the same.\n\n    Example:\n    f([[2, 7, 6], [9, 5, 1], [4, 3, 8]]) returns True.\n\n    Note:\n    - The input matrix will always be a square matrix.\n    - The size of the matrix will always be odd.\n    \"\"\"\n\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for j in range(n):\n        column_sum = sum(matrix[i][j] for i in range(n))\n        if column_sum != target_sum:\n            return False\n\n    # Check main diagonal\n    if sum(matrix[i][i] for i in range(n)) != target_sum:\n        return False\n\n    # Check secondary diagonal\n    if sum(matrix[i][n-i-1] for i in range(n)) != target_sum:\n        return False\n\n    return True\n\n\ndef g(matrix: List[List[int]] = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]) -> List[List[int]]:\n    \"\"\"\n    Generate a square matrix of positive integers.\n\n    Example:\n    g() returns [[2, 7, 6], [9, 5, 1], [4, 3, 8]].\n\n    Note:\n    - The size of the matrix will always be odd.\n    \"\"\"\n\n    return matrix\n\n\nassert f(g()) == True\n",
        "idx_generation": 312,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Check if it is possible to reach the bottom-right cell of the grid starting from the top-left cell,\n    by moving only down or right, and the sum of the elements in the path is divisible by 3.\n    \"\"\"\n    def helper(grid: List[List[int]], row: int, col: int, current_sum: int) -> bool:\n        if row >= len(grid) or col >= len(grid[0]):\n            return False\n\n        if row == len(grid) - 1 and col == len(grid[0]) - 1:\n            return current_sum % 3 == 0\n\n        return helper(grid, row + 1, col, current_sum + grid[row][col]) or helper(grid, row, col + 1, current_sum + grid[row][col])\n\n    return helper(grid, 0, 0, 0)\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    return sorted(grid, key=lambda x: sum(x), reverse=True)\n\nassert f(g([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n",
        "idx_generation": 137,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine if n is a power of 2.\n    \"\"\"\n    if n <= 0:\n        return False\n    \n    while n > 1:\n        if n % 2 != 0:\n            return False\n        n = n // 2\n    \n    return True\n\ndef g(n=16):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 124,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of 0s and 1s, determine if there is a path from the top-left corner to the bottom-right\n    corner, where the path consists of only 1s and moves are allowed only to the right or down.\n    \"\"\"\n    def dfs(i, j):\n        if i == len(grid)-1 and j == len(grid[0])-1:\n            return True\n        if i < len(grid)-1 and grid[i+1][j] == 1:\n            if dfs(i+1, j):\n                return True\n        if j < len(grid[0])-1 and grid[i][j+1] == 1:\n            if dfs(i, j+1):\n                return True\n        return False\n    \n    return dfs(0, 0)\n\ndef g():\n    return [[1, 1, 0, 0],\n            [0, 1, 1, 0],\n            [0, 0, 1, 0],\n            [0, 0, 1, 1]]\n            \nassert f(g()) == True\n",
        "idx_generation": 44,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of unique paths from the top-left corner to the bottom-right corner of a grid of size n x n.\n    Return the number of unique paths.\n    \"\"\"\n    def count_paths(i, j):\n        if i == n - 1 and j == n - 1:\n            return 1\n        elif i >= n or j >= n:\n            return 0\n        \n        return count_paths(i + 1, j) + count_paths(i, j + 1)\n    \n    return count_paths(0, 0)\n\ndef g(n=3):\n    return n\n\nassert f(g()) == 6\n\n",
        "idx_generation": 460,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\n\nclass TreeNode:\n    def __init__(self, val: int = 0, left: 'TreeNode' = None, right: 'TreeNode' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef f(root: TreeNode) -> bool:\n    \"\"\"\n    Given a binary tree, determine if it is a valid binary search tree (BST).\n\n    Args:\n    - root: The root node of the binary tree.\n\n    Returns:\n    - True if the binary tree is a valid BST, False otherwise.\n\n    Example:\n    root = TreeNode(5)\n    root.left = TreeNode(3)\n    root.right = TreeNode(7)\n    root.left.left = TreeNode(2)\n    root.left.right = TreeNode(4)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(8)\n\n    Output:\n    True\n\n    Explanation:\n    The binary tree is a valid BST as each node's value is greater than all the values in its left subtree and less than all the values in its right subtree.\n    \"\"\"\n\n    def is_bst(node: TreeNode, min_val: float, max_val: float) -> bool:\n        if not node:\n            return True\n        if node.val <= min_val or node.val >= max_val:\n            return False\n        return is_bst(node.left, min_val, node.val) and is_bst(node.right, node.val, max_val)\n\n    return is_bst(root, float('-inf'), float('inf'))\n\n\ndef g() -> TreeNode:\n    root = TreeNode(5)\n    root.left = TreeNode(3)\n    root.right = TreeNode(7)\n    root.left.left = TreeNode(2)\n    root.left.right = TreeNode(4)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(8)\n    return root\n\n\nassert f(g()) == True\n\n",
        "idx_generation": 473,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 0 represents an empty cell and 1 represents an obstacle, find the shortest path from the top-left corner to the bottom-right corner.\n\n    Return the length of the shortest path.\n\n    Example:\n    grid = [\n        [0, 1, 0, 0, 0],\n        [0, 0, 0, 1, 0],\n        [1, 1, 0, 1, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 0, 1, 0]\n    ]\n\n    Output:\n    8\n\n    Explanation:\n    The shortest path from (0, 0) to (4, 4) is marked as X:\n    X 1 0 0 0\n    X X X 1 0\n    1 1 X 1 0\n    1 1 X X X\n    0 0 X 1 X\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    queue = [(0, 0, 0)]\n    visited = set((0, 0))\n\n    while queue:\n        x, y, dist = queue.pop(0)\n\n        if x == rows - 1 and y == cols - 1:\n            return dist\n\n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n\n            if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 0 and (nx, ny) not in visited:\n                queue.append((nx, ny, dist + 1))\n                visited.add((nx, ny))\n\n    return -1\n\ndef g(grid: List[List[int]] = [\n    [0, 1, 0, 0, 0],\n    [0, 0, 0, 1, 0],\n    [1, 1, 0, 1, 0],\n    [1, 1, 0, 0, 0],\n    [0, 0, 0, 1, 0]\n]) -> List[List[int]]:\n    return grid\n\nassert f(g()) == 8\n",
        "idx_generation": 415,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of paths from (0, 0) to (n, n) on a grid.\"\"\"\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(n + 1):\n        for j in range(n + 1):\n            if i > 0:\n                dp[i][j] += dp[i - 1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j - 1]\n\n    return dp[n][n]\n\ndef g():\n    n = 3\n    return (n,)\n\nassert f(*g()) == 20\n",
        "idx_generation": 121,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid, count the number of islands.\n    An island is represented by 1s and is surrounded by water (0s).\n    \"\"\"\n    def dfs(grid, i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:\n            return\n        grid[i][j] = 0\n        dfs(grid, i+1, j)\n        dfs(grid, i-1, j)\n        dfs(grid, i, j+1)\n        dfs(grid, i, j-1)\n    \n    if not grid:\n        return 0\n    \n    m, n = len(grid), len(grid[0])\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                dfs(grid, i, j)\n                count += 1\n    \n    return count\n\ndef g():\n    grid = [\n        [1, 1, 0, 0, 0],\n        [0, 1, 0, 0, 1],\n        [1, 0, 0, 1, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    return grid\n\nassert f(g()) == 3\n",
        "idx_generation": 382,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef f(root: Node) -> int:\n    \"\"\"\n    Given the root of a binary tree, return the sum of all the values in the tree.\n\n    Args:\n    - root: The root node of the binary tree.\n\n    Returns:\n    - The sum of all the values in the tree.\n    \"\"\"\n    if root is None:\n        return 0\n    return root.value + f(root.left) + f(root.right)\n\ndef g():\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n    return root\n\nassert f(g()) == 28\n\n",
        "idx_generation": 214,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a subsequence of length 4 such that the sum of the elements is a perfect square.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n\n    Output:\n    True\n\n    Hint: Use counting and combinatorics to generate all possible subsequences of length 4 and check if their sum is a perfect square.\n    \"\"\"\n\n    def is_perfect_square(num):\n        sqrt = int(num ** 0.5)\n        return sqrt * sqrt == num\n\n    def generate_subsequences(nums, length):\n        subsequences = []\n        generate_subsequence(nums, length, [], 0, subsequences)\n        return subsequences\n\n    def generate_subsequence(nums, length, current, index, subsequences):\n        if len(current) == length:\n            subsequences.append(current)\n            return\n\n        if index >= len(nums):\n            return\n\n        generate_subsequence(nums, length, current + [nums[index]], index + 1, subsequences)\n        generate_subsequence(nums, length, current, index + 1, subsequences)\n\n    subsequences = generate_subsequences(nums, 4)\n    for subsequence in subsequences:\n        if is_perfect_square(sum(subsequence)):\n            return True\n\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g()) == True\n\n",
        "idx_generation": 448,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique paths from the top-left corner to the bottom-right corner of a n x n grid, moving only right or down.\n\n    Args:\n    - n: The size of the grid.\n\n    Returns:\n    - The number of unique paths.\n\n    Example:\n    n = 3\n\n    Output:\n    6\n\n    Explanation:\n    There are 6 unique paths from the top-left corner to the bottom-right corner of a 3 x 3 grid:\n    - Right, Right, Down\n    - Right, Down, Right\n    - Down, Right, Right\n    - Right, Down, Down\n    - Down, Right, Down\n    - Down, Down, Right\n    \"\"\"\n\n    def backtrack(row, col):\n        if row == n - 1 and col == n - 1:\n            return 1\n        if row >= n or col >= n:\n            return 0\n        \n        return backtrack(row + 1, col) + backtrack(row, col + 1)\n    \n    return backtrack(0, 0)\n\ndef g(n=3):\n    return n\n\nassert f(g()) == 6\n\n",
        "idx_generation": 280,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(words: List[str], target: str) -> bool:\n    \"\"\"Check if the target word can be formed by concatenating words from the given list\"\"\"\n    word_dict = {}\n    for word in words:\n        if word in word_dict:\n            word_dict[word] += 1\n        else:\n            word_dict[word] = 1\n\n    def dfs(word):\n        if word == \"\":\n            return True\n        for i in range(1, len(word)+1):\n            if word[:i] in word_dict and word_dict[word[:i]] > 0:\n                word_dict[word[:i]] -= 1\n                if dfs(word[i:]):\n                    return True\n                word_dict[word[:i]] += 1\n        return False\n\n    return dfs(target)\n\ndef g():\n    words = [\"apple\", \"pen\", \"applepen\", \"pine\", \"pineapple\"]\n    target = \"pineapplepenapple\"\n    return words, target\n\nassert f(*g())\n",
        "idx_generation": 16,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, count the number of unique binary strings of length n that do not contain consecutive 1's.\n    Return the count.\n    \"\"\"\n    if n == 1:\n        return 2\n    if n == 2:\n        return 3\n\n    dp = [0] * (n + 1)\n    dp[1] = 2\n    dp[2] = 3\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\ndef g(n = 4):\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 102,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers and a target value, return the index of the target value in the array.\n    If the target is not found, return -1.\n\n    Example:\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 6\n\n    Output:\n    5\n\n    Explanation:\n    The target value 6 is found at index 5 in the array.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Generate a sorted array of integers and a target value.\n    \"\"\"\n    return arr, target\n\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ntarget = 6\n\nassert f(*g(arr, target)) == 5\n",
        "idx_generation": 456,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    output: 20\n\n    Explanation:\n    The maximum product is achieved by multiplying 4 and 5, which gives 20.\n    \"\"\"\n    nums.sort()\n    return nums[-1] * nums[-2]\n\ndef g(nums = [1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g()) == 20\n",
        "idx_generation": 115,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order using the bubble sort algorithm.\n\n    Sample Input:\n    arr = [5, 2, 8, 6, 3]\n\n    Sample Output:\n    [2, 3, 5, 6, 8]\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\n\ndef g():\n    return [[5, 2, 8, 6, 3]]\n\nassert f(*g()) == [2, 3, 5, 6, 8]\n",
        "idx_generation": 81,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a square subgrid.\n\n    Return the maximum sum.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    45\n\n    Explanation:\n    The maximum sum is obtained from the subgrid [5, 6, 8, 9], which sums up to 45.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    max_sum = float(\"-inf\")\n\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(i, rows):\n                for l in range(j, cols):\n                    subgrid_sum = 0\n                    for m in range(i, k+1):\n                        for n in range(j, l+1):\n                            subgrid_sum += grid[m][n]\n                    max_sum = max(max_sum, subgrid_sum)\n\n    return max_sum\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers.\n\n    Returns:\n    - The generated grid.\n\n    Example:\n    g() returns [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    \"\"\"\n\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 45\n",
        "idx_generation": 473,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int], target=5) -> bool:\n    \"\"\"Find the maximum sum of a subarray with a length less than or equal to the target\"\"\"\n    def max_subarray_sum(arr, target):\n        max_sum = float('-inf')\n        current_sum = 0\n        start = 0\n        for end in range(len(arr)):\n            current_sum += arr[end]\n            if end - start + 1 > target:\n                current_sum -= arr[start]\n                start += 1\n            max_sum = max(max_sum, current_sum)\n        return max_sum\n\n    return max_subarray_sum(arr, target) > 0\n\ndef g(target=5):\n    return [1, -2, 3, 4, -6, 2, 1]\n\nassert f(g()) == True\n",
        "idx_generation": 63,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a 2D grid of integers and a target value, determine if the target value exists in the grid.\n    The grid is sorted in non-decreasing order from left to right and top to bottom.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    i = 0\n    j = cols - 1\n    while i < rows and j >= 0:\n        if grid[i][j] == target:\n            return True\n        elif grid[i][j] < target:\n            i += 1\n        else:\n            j -= 1\n    return False\n\ndef g(grid=[[1, 3, 5], [2, 4, 6], [7, 8, 9]], target=4):\n    return grid, target\n\nassert f(*g()) == True\n",
        "idx_generation": 130,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string of parentheses, return True if the parentheses are balanced. Otherwise, return False.\n    \"\"\"\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g():\n    return \"()()()\"\n\nassert f(g()) == True\n",
        "idx_generation": 30,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome.\n\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n\n    Return True if s is a palindrome, False otherwise.\n\n    Example:\n    s = \"racecar\"\n\n    Output:\n    True\n\n    Explanation:\n    The string \"racecar\" is a palindrome because it reads the same forward and backward.\n    \"\"\"\n\n    def is_palindrome(s, start, end):\n        if start >= end:\n            return True\n        if s[start] != s[end]:\n            return False\n        return is_palindrome(s, start + 1, end - 1)\n\n    return is_palindrome(s, 0, len(s) - 1)\n\ndef g(s=\"racecar\"):\n    \"\"\"\n    Generate a string s.\n    \"\"\"\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 98,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Determine if a given string s is a palindrome.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n    \"\"\"\n    stack = []\n    queue = []\n    for c in s:\n        if c.isalnum():\n            stack.append(c.lower())\n            queue.append(c.lower())\n    \n    while stack and queue:\n        if stack.pop() != queue.pop(0):\n            return False\n    \n    return True\n\ndef g() -> str:\n    return \"A man, a plan, a canal: Panama\"\n\nassert f(g()) == True\n",
        "idx_generation": 314,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if the given number is a power of 2.\n    \"\"\"\n    return n > 0 and (n & (n - 1)) == 0\n\ndef g():\n    return 16\n\nassert f(g()) == True\n",
        "idx_generation": 31,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given a positive integer n, determine if it is a perfect square.\"\"\"\n    left = 1\n    right = n\n    while left <= right:\n        mid = (left + right) // 2\n        square = mid * mid\n        if square == n:\n            return True\n        elif square < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef g(n=16):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 7,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the minimum path sum from the top-left corner to the bottom-right corner.\n    The path can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7 (1 -> 3 -> 1 -> 1 -> 1)\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    # Create a 2D array to store the minimum path sum to each cell\n    dp = [[0] * n for _ in range(m)]\n    \n    # Base case: the minimum path sum to reach the top-left corner is the value of the top-left cell\n    dp[0][0] = grid[0][0]\n    \n    # Fill in the array with the minimum path sum to each cell\n    for i in range(m):\n        for j in range(n):\n            # The minimum path sum to reach the current cell is the minimum of the sum of the cell above and the cell to the left,\n            # plus the value of the current cell\n            if i > 0 and j > 0:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n            elif i > 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            elif j > 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n    \n    # The minimum path sum from the top-left corner to the bottom-right corner is the value in the bottom-right corner\n    return dp[m-1][n-1]\n\ndef g():\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n",
        "idx_generation": 37,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if the target integer exists in the list using binary search.\n    \"\"\"\n    def binary_search(nums, target, low, high):\n        if low > high:\n            return False\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            return binary_search(nums, target, mid + 1, high)\n        else:\n            return binary_search(nums, target, low, mid - 1)\n    \n    return binary_search(nums, target, 0, len(nums) - 1)\n\ndef g(nums=[1, 2, 3, 4, 5], target=3):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 46,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum of a path from the top-left corner to the bottom-right corner.\n    Each step in the path can only be taken down or right.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[rows - 1][cols - 1]\n\ndef g(grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 27,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nimport heapq\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    # Create a 2D array to store the minimum sum of a path from the top-left cell to each cell\n    min_sum = [[float('inf')] * cols for _ in range(rows)]\n    min_sum[0][0] = grid[0][0]\n    \n    # Create a priority queue to store the cells to be visited\n    pq = [(grid[0][0], 0, 0)]\n    \n    while pq:\n        curr_sum, row, col = heapq.heappop(pq)\n        \n        # Check if we have reached the bottom-right cell\n        if row == rows - 1 and col == cols - 1:\n            return curr_sum\n        \n        # Check if it is possible to move down\n        if row < rows - 1:\n            next_sum = curr_sum + grid[row + 1][col]\n            \n            # Update the minimum sum if necessary\n            if next_sum < min_sum[row + 1][col]:\n                min_sum[row + 1][col] = next_sum\n                heapq.heappush(pq, (next_sum, row + 1, col))\n        \n        # Check if it is possible to move right\n        if col < cols - 1:\n            next_sum = curr_sum + grid[row][col + 1]\n            \n            # Update the minimum sum if necessary\n            if next_sum < min_sum[row][col + 1]:\n                min_sum[row][col + 1] = next_sum\n                heapq.heappush(pq, (next_sum, row, col + 1))\n    \n    return -1\n\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 123,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> float:\n    \"\"\"\n    Given a list of 2D points, calculate the total perimeter of the convex hull.\n\n    Example:\n    points = [[0,0], [0,1], [1,0], [1,1], [0.5, 0.5]]\n\n    Output:\n    4.0 (the total perimeter of the convex hull is 4.0)\n    \"\"\"\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        elif val > 0:\n            return 1\n        else:\n            return 2\n\n    def convex_hull(points):\n        n = len(points)\n        if n < 3:\n            return []\n\n        hull = []\n\n        l = 0\n        for i in range(1, n):\n            if points[i][0] < points[l][0]:\n                l = i\n\n        p = l\n        q = 0\n        while True:\n            hull.append(points[p])\n            q = (p + 1) % n\n            for i in range(n):\n                if orientation(points[p], points[i], points[q]) == 2:\n                    q = i\n            p = q\n            if p == l:\n                break\n\n        return hull\n\n    hull_points = convex_hull(points)\n    perimeter = 0.0\n    for i in range(len(hull_points)):\n        p1 = hull_points[i]\n        p2 = hull_points[(i + 1) % len(hull_points)]\n        perimeter += ((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2) ** 0.5\n\n    return perimeter\n\ndef g():\n    return [[0,0], [0,1], [1,0], [1,1], [0.5, 0.5]]\n\nassert f(g()) == 4.0\n",
        "idx_generation": 457,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum subarray XOR.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    7\n\n    Explanation:\n    The maximum subarray XOR is achieved by selecting the subarray [3, 4] with XOR value of 7.\n\n    Hint: Use a Trie data structure to store the XOR values of subarrays.\n    \"\"\"\n\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n\n    def insert(num, root):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def findMaxXor(num, root):\n        node = root\n        xor = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if 1 - bit in node.children:\n                xor |= (1 << i)\n                node = node.children[1 - bit]\n            else:\n                node = node.children[bit]\n        return xor\n\n    root = TrieNode()\n    max_xor = 0\n    pre_xor = 0\n\n    for num in nums:\n        pre_xor ^= num\n        insert(pre_xor, root)\n        max_xor = max(max_xor, findMaxXor(pre_xor, root))\n\n    return max_xor\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return [nums]\n\nassert f(*g()) == 7\n",
        "idx_generation": 350,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given an n x n matrix, rotate the matrix 90 degrees clockwise.\n    \"\"\"\n    n = len(matrix)\n    \n    # Transpose the matrix\n    for i in range(n):\n        for j in range(i+1, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n    \n    # Reverse each row\n    for i in range(n):\n        matrix[i] = matrix[i][::-1]\n    \n    return matrix\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == [\n    [7, 4, 1],\n    [8, 5, 2],\n    [9, 6, 3]\n]\n",
        "idx_generation": 160,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if a given grid is valid, where each row and column must contain unique numbers.\"\"\"\n    for row in grid:\n        if len(row) != len(set(row)):\n            return False\n    for col in zip(*grid):\n        if len(col) != len(set(col)):\n            return False\n    return True\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == True\n",
        "idx_generation": 283,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Calculate the total amount of rainwater that can be trapped between the bars represented by the given heights.\n    \"\"\"\n    stack = []\n    water = 0\n    for i in range(len(heights)):\n        while stack and heights[i] > heights[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(heights[i], heights[stack[-1]]) - heights[top]\n            water += distance * bounded_height\n        \n        stack.append(i)\n    \n    return water\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of heights representing bars for the puzzle.\n    \"\"\"\n    heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\n    return heights\n\nassert f(g()) == 6\n",
        "idx_generation": 228,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a square matrix of integers, determine if it forms a magic square.\n    A magic square is a square matrix in which the sum of every row, column, and diagonal is the same.\n    Return True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n\n    # Check if all rows have the same sum\n    row_sum = sum(matrix[0])\n    for i in range(1, n):\n        if sum(matrix[i]) != row_sum:\n            return False\n\n    # Check if all columns have the same sum\n    for j in range(n):\n        col_sum = sum(matrix[i][j] for i in range(n))\n        if col_sum != row_sum:\n            return False\n\n    # Check if the diagonals have the same sum\n    diagonal_sum = sum(matrix[i][i] for i in range(n))\n    if diagonal_sum != row_sum:\n        return False\n\n    anti_diagonal_sum = sum(matrix[i][n-i-1] for i in range(n))\n    if anti_diagonal_sum != row_sum:\n        return False\n\n    return True\n\ndef g() -> List[List[int]]:\n    return [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n\nassert f(g()) == True\n\n",
        "idx_generation": 354,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string containing only parentheses, determine if the parentheses are balanced.\n    Return True if they are balanced, False otherwise.\n\n    Example:\n    s = \"((()))\"\n\n    Output:\n    True\n\n    Explanation:\n    The parentheses are balanced, as each opening parenthesis has a corresponding closing parenthesis.\n    \"\"\"\n\n    stack = []\n    opening_brackets = [\"(\", \"[\", \"{\"]\n    closing_brackets = [\")\", \"]\", \"}\"]\n\n    for char in s:\n        if char in opening_brackets:\n            stack.append(char)\n        elif char in closing_brackets:\n            if not stack:\n                return False\n            if opening_brackets.index(stack.pop()) != closing_brackets.index(char):\n                return False\n\n    return len(stack) == 0\n\ndef g(s=\"((()))\") -> str:\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 176,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers, convert it to a binary array where each element is the number of 1's in the binary representation of the corresponding element in the original array.\n    Return the binary array.\n    \"\"\"\n\n    def count_ones(num: int) -> int:\n        \"\"\"\n        Count the number of 1's in the binary representation of a number.\n        \"\"\"\n        count = 0\n        while num > 0:\n            if num % 2 == 1:\n                count += 1\n            num //= 2\n        return count\n\n    binary_array = []\n    for num in nums:\n        binary_array.append(count_ones(num))\n    return binary_array\n\ndef g():\n    return [3, 7, 2, 4, 5, 1]\n\nassert f(g()) == [2, 3, 1, 1, 2, 1]\n\n",
        "idx_generation": 431,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a number is a perfect square\"\"\"\n    if n < 0:\n        return False\n    i = 1\n    while n > 0:\n        n -= i\n        i += 2\n    return n == 0\n\ndef g():\n    n = 16\n    return n\nassert f(g()) == True\n",
        "idx_generation": 159,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the elements in the original list except the corresponding element.\n\n    Example:\n    Input: [1, 2, 3, 4]\n    Output: [24, 12, 8, 6]\n    Explanation: The product of all elements in the original list except 1 is 24, the product of all elements except 2 is 12, the product of all elements except 3 is 8, and the product of all elements except 4 is 6.\n    \"\"\"\n\n    n = len(nums)\n    left_prod = [1] * n\n    right_prod = [1] * n\n    result = [1] * n\n\n    for i in range(1, n):\n        left_prod[i] = left_prod[i-1] * nums[i-1]\n\n    for i in range(n-2, -1, -1):\n        right_prod[i] = right_prod[i+1] * nums[i+1]\n\n    for i in range(n):\n        result[i] = left_prod[i] * right_prod[i]\n\n    return result\n\ndef g():\n    return ([1, 2, 3, 4],)\n\nassert f(*g()) == [24, 12, 8, 6]\n",
        "idx_generation": 342,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the maximum sum of a subgrid within the given grid\"\"\"\n    maxSum = float('-inf')\n    rows = len(grid)\n    cols = len(grid[0])\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(i, rows):\n                for l in range(j, cols):\n                    subgridSum = getSubgridSum(grid, i, j, k, l)\n                    maxSum = max(maxSum, subgridSum)\n    return maxSum\n\ndef getSubgridSum(grid: List[List[int]], top: int, left: int, bottom: int, right: int) -> int:\n    subgridSum = 0\n    for i in range(top, bottom + 1):\n        for j in range(left, right + 1):\n            subgridSum += grid[i][j]\n    return subgridSum\n\ndef g(grid=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return grid\n\nassert f(g()) == 45\n",
        "idx_generation": 364,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if it is a magic square.\n    A magic square is a square matrix where the sums of each row, column, and diagonal are equal.\n\n    Example:\n    Input:\n    [[2, 7, 6],\n     [9, 5, 1],\n     [4, 3, 8]]\n\n    Output: True\n\n    Explanation:\n    The sums of each row, column, and diagonal are all equal to 15.\n\n    Hint: Use nested loops to calculate the sums of rows, columns, and diagonals.\n    \"\"\"\n\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = sum(matrix[row][col] for row in range(n))\n        if col_sum != target_sum:\n            return False\n\n    # Check diagonal\n    diagonal_sum = sum(matrix[i][i] for i in range(n))\n    if diagonal_sum != target_sum:\n        return False\n\n    # Check reverse diagonal\n    reverse_diagonal_sum = sum(matrix[i][n-i-1] for i in range(n))\n    if reverse_diagonal_sum != target_sum:\n        return False\n\n    return True\n\ndef g():\n    return [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n\nassert f(g()) == True\n",
        "idx_generation": 229,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, check if t is an anagram of s.\n\n    Args:\n    - s: A string.\n    - t: A string.\n\n    Returns:\n    - True if t is an anagram of s, False otherwise.\n    \"\"\"\n    if len(s) != len(t):\n        return False\n\n    count = [0] * 26\n\n    for i in range(len(s)):\n        count[ord(s[i]) - ord('a')] += 1\n        count[ord(t[i]) - ord('a')] -= 1\n\n    for c in count:\n        if c != 0:\n            return False\n\n    return True\n\ndef g(s: str, t: str):\n    return s, t[::-1]\n\nassert f(*g(\"anagram\", \"nagaram\"))\n",
        "idx_generation": 384,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nimport math\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if a given number is a perfect square and has exactly 3 digits.\n    \"\"\"\n    sqrt = math.isqrt(n)\n    return sqrt * sqrt == n and len(str(n)) == 3\n\ndef g():\n    n = 144\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 163,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Find the sum of all multiples of 3 or 5 below n.\n    \"\"\"\n    sum = 0\n    for i in range(n):\n        if i % 3 == 0 or i % 5 == 0:\n            sum += i\n    return sum\n\ndef g():\n    n = 100\n    return n\n\nassert f(g()) == 2318\n",
        "idx_generation": 186,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in a list.\n\n    Sample Input:\n    nums = [2, 4, 7, 11, 15]\n    target = 9\n\n    Sample Output:\n    [0, 2] (nums[0] + nums[2] = 2 + 7 = 9)\n    \"\"\"\n    num_dict = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []\n\ndef g():\n    return ([2, 4, 7, 11, 15], 9)\n\nassert f(*g()) == [0, 2]\n",
        "idx_generation": 160,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[str]]) -> bool:\n    \"\"\"\n    Given a 2D grid of characters, determine if it forms a valid word search.\n\n    A word search puzzle is a grid of letters with words hidden in different directions (horizontal, vertical, diagonal).\n    To solve the puzzle, the words must be found and can be read in any direction (left to right, right to left, top to bottom, bottom to top, diagonal).\n\n    Parameters:\n    grid (List[List[str]]): The 2D grid of characters representing the word search puzzle.\n\n    Returns:\n    bool: True if the grid forms a valid word search, False otherwise.\n    \"\"\"\n    def dfs(i, j, word):\n        if not word:\n            return True\n\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != word[0]:\n            return False\n\n        temp = grid[i][j]\n        grid[i][j] = \"#\"\n\n        res = dfs(i + 1, j, word[1:]) or dfs(i - 1, j, word[1:]) or dfs(i, j + 1, word[1:]) or dfs(i, j - 1, word[1:])\n\n        grid[i][j] = temp\n\n        return res\n\n    if not grid:\n        return False\n\n    m, n = len(grid), len(grid[0])\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, \"WORD\"):\n                return True\n\n    return False\n\n\ndef g(grid=[\n    [\"W\",\"R\",\"D\",\"R\"],\n    [\"O\",\"O\",\"O\",\"O\"],\n    [\"R\",\"D\",\"O\",\"O\"]\n]) -> List[List[str]]:\n    return grid\n\nassert f(g()) == True\n\n",
        "idx_generation": 463,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique paths to reach the bottom right corner of a n x n grid from the top left corner.\n    You can only move either down or right at any point in time.\n    \"\"\"\n    dp = [[1] * n] + [[1] + [0] * (n - 1) for _ in range(n - 1)]\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    return dp[-1][-1]\n\ndef g(n = 3):\n    return n\n\nassert f(g()) == 6\n",
        "idx_generation": 128,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the sum of the elements in the diagonal.\n\n    Example:\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n    Output:\n    15 (1 + 5 + 9)\n\n    Hint: Iterate over the rows of the matrix and add the diagonal elements to a running total.\n    \"\"\"\n\n    total = 0\n\n    for i in range(len(matrix)):\n        total += matrix[i][i]\n    \n    return total\n\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    \"\"\"\n    Generate a matrix of integers.\n    \"\"\"\n    return matrix\n\nassert f(g()) == 15\n\n\n",
        "idx_generation": 424,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix, find the maximum sum of a submatrix with dimensions m x n,\n    where m and n are positive integers.\n\n    Args:\n    - matrix: A 2D list of integers representing the matrix.\n\n    Returns:\n    - The maximum sum of a submatrix with dimensions m x n.\n    \"\"\"\n    def prefix_sum(matrix):\n        rows = len(matrix)\n        cols = len(matrix[0])\n\n        prefix_sum_matrix = [[0] * cols for _ in range(rows)]\n        prefix_sum_matrix[0][0] = matrix[0][0]\n\n        for i in range(1, rows):\n            prefix_sum_matrix[i][0] = prefix_sum_matrix[i-1][0] + matrix[i][0]\n\n        for j in range(1, cols):\n            prefix_sum_matrix[0][j] = prefix_sum_matrix[0][j-1] + matrix[0][j]\n\n        for i in range(1, rows):\n            for j in range(1, cols):\n                prefix_sum_matrix[i][j] = prefix_sum_matrix[i-1][j] + prefix_sum_matrix[i][j-1] - prefix_sum_matrix[i-1][j-1] + matrix[i][j]\n\n        return prefix_sum_matrix\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n    max_sum = float('-inf')\n\n    prefix_sum_matrix = prefix_sum(matrix)\n\n    for i in range(rows):\n        for j in range(cols):\n            for m in range(i, rows):\n                for n in range(j, cols):\n                    submatrix_sum = prefix_sum_matrix[m][n]\n\n                    if i > 0:\n                        submatrix_sum -= prefix_sum_matrix[i-1][n]\n\n                    if j > 0:\n                        submatrix_sum -= prefix_sum_matrix[m][j-1]\n\n                    if i > 0 and j > 0:\n                        submatrix_sum += prefix_sum_matrix[i-1][j-1]\n\n                    max_sum = max(max_sum, submatrix_sum)\n\n    return max_sum\n\ndef g() -> List[List[int]]:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == 45\n\n",
        "idx_generation": 348,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a given number is a prime number.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g() -> int:\n    return 13\n\nassert f(g()) == True\n",
        "idx_generation": 18,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Find the maximum sum of a subarray in the given array using Kadane's algorithm.\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in arr:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef g():\n    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return arr\n\nassert f(g()) == 6\n",
        "idx_generation": 460,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Find the target value in the list using a stack\"\"\"\n    stack = []\n    for num in nums:\n        if num == target:\n            return True\n        stack.append(num)\n    return False\n\ndef g(nums: List[int], target: int):\n    return nums, target\n\nnums = [1, 5, 2, 8, 7]\ntarget = 2\n\nassert f(*g(nums, target))\n",
        "idx_generation": 66,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Given an integer n, generate all possible combinations of n pairs of parentheses.\n    \"\"\"\n\n    def backtrack(output: List[str], curr: str, open_count: int, close_count: int, max_count: int):\n        if len(curr) == max_count * 2:\n            output.append(curr)\n            return\n\n        if open_count < max_count:\n            backtrack(output, curr + \"(\", open_count + 1, close_count, max_count)\n\n        if close_count < open_count:\n            backtrack(output, curr + \")\", open_count, close_count + 1, max_count)\n\n    output = []\n    backtrack(output, \"\", 0, 0, n)\n    return output\n\n\ndef g():\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    n = 3\n    return n\n\n\nassert f(g()) == [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\n\n",
        "idx_generation": 456,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the nth Fibonacci number using dynamic programming.\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    fib = [0] * (n + 1)\n    fib[1] = 1\n    \n    for i in range(2, n + 1):\n        fib[i] = fib[i - 1] + fib[i - 2]\n    \n    return fib[n]\n\ndef g() -> int:\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    return 10\n\nassert f(g()) == 55\n",
        "idx_generation": 148,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the minimum path sum from the top-left to the bottom-right corner of a grid.\"\"\"\n    def dfs(i, j):\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\n            return grid[i][j]\n        if i == len(grid) - 1:\n            return grid[i][j] + dfs(i, j + 1)\n        if j == len(grid[0]) - 1:\n            return grid[i][j] + dfs(i + 1, j)\n        return grid[i][j] + min(dfs(i + 1, j), dfs(i, j + 1))\n    \n    return dfs(0, 0)\n\ndef g():\n    grid = [[1, 3, 1], \n            [1, 5, 1], \n            [4, 2, 1]]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 45,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 0 represents an obstacle and 1 represents an open path,\n    find the length of the shortest path from the top-left cell to the bottom-right cell.\n    The robot can only move down or right.\n\n    Example:\n    grid = [\n        [1, 1, 1, 1],\n        [1, 0, 1, 0],\n        [1, 1, 1, 1],\n        [1, 1, 1, 1]\n    ]\n\n    Output:\n    6\n\n    Explanation:\n    The shortest path from the top-left cell to the bottom-right cell is:\n    Right -> Right -> Down -> Down -> Down -> Right\n    \"\"\"\n\n    def bfs(grid: List[List[int]]) -> int:\n        queue = [(0, 0, 0)]\n        visited = set()\n\n        while queue:\n            row, col, steps = queue.pop(0)\n\n            if row == len(grid) - 1 and col == len(grid[0]) - 1:\n                return steps\n\n            visited.add((row, col))\n\n            if col < len(grid[0]) - 1 and grid[row][col+1] == 1 and (row, col+1) not in visited:\n                queue.append((row, col+1, steps+1))\n\n            if row < len(grid) - 1 and grid[row+1][col] == 1 and (row+1, col) not in visited:\n                queue.append((row+1, col, steps+1))\n\n        return -1\n\n    return bfs(grid)\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of 0s and 1s.\n    \"\"\"\n    return [\n        [1, 1, 1, 1],\n        [1, 0, 1, 0],\n        [1, 1, 1, 1],\n        [1, 1, 1, 1]\n    ]\n\nassert f(g()) == 6\n",
        "idx_generation": 356,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"\n    Given a string s and a target string, determine if the target string is a substring of s.\n\n    Args:\n    - s: The original string.\n    - target: The target string.\n\n    Returns:\n    - True if the target string is a substring of s, False otherwise.\n    \"\"\"\n    return target in s\n\ndef g():\n    s = \"hello world\"\n    target = \"world\"\n    return s, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 457,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(string: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n\n    Sample Input:\n    string = \"racecar\"\n\n    Sample Output:\n    True\n    \"\"\"\n    stack = []\n    for char in string:\n        stack.append(char)\n    reverse_string = \"\"\n    while stack:\n        reverse_string += stack.pop()\n    return string == reverse_string\n\ndef g(string: str = \"racecar\") -> str:\n    return string\n\nassert f(g()) == True\n",
        "idx_generation": 291,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n    \n    Example:\n    s = \"abcabcbb\"\n    \n    Output:\n    3 (since the longest substring without repeating characters is \"abc\")\n    \"\"\"\n    max_length = 0\n    start = 0\n    char_dict = {}\n    \n    for i in range(len(s)):\n        if s[i] in char_dict:\n            start = max(start, char_dict[s[i]] + 1)\n        char_dict[s[i]] = i\n        max_length = max(max_length, i - start + 1)\n    \n    return max_length\n\ndef g() -> str:\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"abcabcbb\"\n\nassert f(g()) == 3\n",
        "idx_generation": 368,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a power of two.\n\n    Example:\n    n = 16\n\n    Output:\n    True\n\n    Explanation:\n    16 is a power of two because it can be expressed as 2^4.\n\n    Hint: Use bitwise operations to check if a number is a power of two.\n    \"\"\"\n\n    if n <= 0:\n        return False\n\n    return n & (n - 1) == 0\n\ndef g() -> int:\n    n = 32\n    return n\n\nassert f(g()) == True\n\n",
        "idx_generation": 492,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a subset whose XOR is equal to the target value.\n    XOR of a subset is the bitwise exclusive OR of all the numbers in the subset.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    Sample Output:\n    True\n    \"\"\"\n    def dfs(index, curr_xor):\n        if curr_xor == target:\n            return True\n        if index >= len(nums) or curr_xor > target:\n            return False\n\n        # Include the current element in the subset\n        if dfs(index + 1, curr_xor ^ nums[index]):\n            return True\n\n        # Exclude the current element from the subset\n        if dfs(index + 1, curr_xor):\n            return True\n\n        return False\n\n    return dfs(0, 0)\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g(), 7) == True\n",
        "idx_generation": 281,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of distinct prime factors of n.\n\n    Args:\n    - n: An integer\n\n    Returns:\n    - The number of distinct prime factors of n.\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    factors = set()\n    for i in range(2, n+1):\n        if n % i == 0 and is_prime(i):\n            factors.add(i)\n    return len(factors)\n\ndef g(n: int = 84):\n    return n\n\nassert f(g()) == 3\n\n",
        "idx_generation": 462,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray with the constraint that no two numbers in the subarray are adjacent.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The maximum sum of a subarray with the constraint that no two numbers in the subarray are adjacent.\n\n    Example:\n    nums = [1, 2, 3, 1]\n\n    Output:\n    4\n\n    Explanation:\n    The maximum sum of a subarray with the constraint that no two numbers in the subarray are adjacent is 4.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    n = len(nums)\n    if n == 1:\n        return nums[0]\n\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i-2] + nums[i], dp[i-1])\n\n    return dp[n-1]\n\ndef g():\n    nums = [1, 2, 3, 1]\n    return nums\n\nassert f(g()) == 4\n\n",
        "idx_generation": 422,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import Tuple\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two positive integers n and m, find the number of unique paths from the top-left corner to the bottom-right corner of an n x m grid.\n    You can only move either down or right at any point in time.\n\n    Example:\n    n = 3, m = 4\n    Output: 10\n\n    In a 3 x 4 grid, there are 10 unique paths from the top-left corner to the bottom-right corner:\n    ['R', 'R', 'R', 'D']\n    ['R', 'R', 'D', 'D']\n    ['D', 'D', 'R', 'R']\n    ['D', 'R', 'R', 'D']\n    ['D', 'R', 'D', 'R']\n    ['R', 'D', 'R', 'D']\n    ['R', 'D', 'D', 'R']\n    ['D', 'R', 'D', 'R']\n    ['R', 'D', 'R', 'R']\n    ['D', 'R', 'R', 'R']\n    \"\"\"\n\n    if n == 0 or m == 0:\n        return 0\n    \n    def unique_paths_helper(i, j, n, m, memo):\n        if i == n-1 and j == m-1:\n            return 1\n        if i >= n or j >= m:\n            return 0\n        if memo[i][j] != -1:\n            return memo[i][j]\n        \n        right_paths = unique_paths_helper(i, j+1, n, m, memo)\n        down_paths = unique_paths_helper(i+1, j, n, m, memo)\n        \n        memo[i][j] = right_paths + down_paths\n        return memo[i][j]\n    \n    memo = [[-1] * m for _ in range(n)]\n    return unique_paths_helper(0, 0, n, m, memo)\n\ndef g(n=3, m=4):\n    return n, m\n\nassert f(*g()) == 10\n\n",
        "idx_generation": 177,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if n is a power of 2\"\"\"\n    return n != 0 and (n & (n - 1)) == 0\n\ndef g():\n    return 16\n\nassert f(g()) == True\n",
        "idx_generation": 158,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Dict\n\nclass Graph:\n    def __init__(self, vertices: List[int]):\n        self.vertices = vertices\n        self.adj_list = {v: [] for v in vertices}\n\n    def add_edge(self, u: int, v: int):\n        self.adj_list[u].append(v)\n        self.adj_list[v].append(u)\n\n    def is_connected(self, u: int, v: int) -> bool:\n        visited = set()\n        stack = [u]\n\n        while stack:\n            curr = stack.pop()\n\n            if curr == v:\n                return True\n\n            visited.add(curr)\n\n            for neighbor in self.adj_list[curr]:\n                if neighbor not in visited:\n                    stack.append(neighbor)\n\n        return False\n\ndef f(graph: Dict[int, List[int]], u: int, v: int) -> bool:\n    \"\"\"\n    Given a graph and two vertices u and v, determine if there is a path between u and v.\n\n    Example:\n    graph = {\n        0: [1, 2],\n        1: [0, 3],\n        2: [0, 3],\n        3: [1, 2]\n    }\n    u = 0\n    v = 3\n\n    Output:\n    True (there is a path between 0 and 3: 0 -> 1 -> 3)\n    \"\"\"\n    g = Graph(list(graph.keys()))\n\n    for u, neighbors in graph.items():\n        for v in neighbors:\n            g.add_edge(u, v)\n\n    return g.is_connected(u, v)\n\ndef g():\n    graph = {\n        0: [1, 2],\n        1: [0, 3],\n        2: [0, 3],\n        3: [1, 2]\n    }\n    u = 0\n    v = 3\n\n    return graph, u, v\n\nassert f(*g())\n",
        "idx_generation": 79,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"Check if there is a path from the start node to the end node in the given graph.\"\"\"\n    visited = set()\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n\n    return False\n\ndef g(graph={\"A\": [\"B\", \"C\"], \"B\": [\"D\", \"E\"], \"C\": [\"F\"], \"D\": [], \"E\": [\"F\"], \"F\": []}, start=\"A\", end=\"F\"):\n    return graph, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 5,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\n\nclass Graph:\n    def __init__(self, num_vertices: int):\n        self.num_vertices = num_vertices\n        self.adj_list = [[] for _ in range(num_vertices)]\n\n    def add_edge(self, src: int, dest: int) -> None:\n        self.adj_list[src].append(dest)\n\n    def is_cyclic_util(self, v: int, visited: List[bool], stack: List[bool]) -> bool:\n        visited[v] = True\n        stack[v] = True\n\n        for neighbor in self.adj_list[v]:\n            if not visited[neighbor]:\n                if self.is_cyclic_util(neighbor, visited, stack):\n                    return True\n            elif stack[neighbor]:\n                return True\n\n        stack[v] = False\n        return False\n\n    def is_cyclic(self) -> bool:\n        visited = [False] * self.num_vertices\n        stack = [False] * self.num_vertices\n\n        for v in range(self.num_vertices):\n            if not visited[v]:\n                if self.is_cyclic_util(v, visited, stack):\n                    return True\n\n        return False\n\n\ndef f(graph: Graph) -> bool:\n    \"\"\"\n    Given a directed graph, determine if it contains a cycle.\n\n    Args:\n    - graph: The directed graph represented as an adjacency list.\n\n    Returns:\n    - True if the graph contains a cycle, False otherwise.\n\n    Example:\n    graph = Graph(4)\n    graph.add_edge(0, 1)\n    graph.add_edge(1, 2)\n    graph.add_edge(2, 0)\n    graph.add_edge(2, 3)\n\n    Output:\n    True\n\n    Explanation:\n    The graph contains a cycle: 0 -> 1 -> 2 -> 0.\n    \"\"\"\n\n    return graph.is_cyclic()\n\n\ndef g() -> Graph:\n    graph = Graph(4)\n    graph.add_edge(0, 1)\n    graph.add_edge(1, 2)\n    graph.add_edge(2, 0)\n    graph.add_edge(2, 3)\n    return graph\n\n\nassert f(g()) == True\n\n",
        "idx_generation": 473,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of 0s and 1s, determine if there is a path from the top-left corner to the bottom-right corner.\n\n    Sample input:\n    grid = [[1, 1, 0, 0],\n            [1, 1, 1, 1],\n            [0, 0, 1, 1],\n            [0, 0, 0, 1]]\n\n    Sample output:\n    True\n\n    Explanation:\n    There is a path from the top-left corner to the bottom-right corner: (0,0) -> (0,1) -> (1,1) -> (2,1) -> (2,2) -> (3,2) -> (3,3).\n\n    Hint: Use a depth-first search (DFS) algorithm to traverse the grid and check if a path exists.\n    \"\"\"\n\n    def dfs(i: int, j: int) -> bool:\n        if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0 or visited[i][j]:\n            return False\n        if i == m - 1 and j == n - 1:\n            return True\n\n        visited[i][j] = True\n\n        return dfs(i + 1, j) or dfs(i - 1, j) or dfs(i, j + 1) or dfs(i, j - 1)\n\n    if not grid:\n        return False\n\n    m = len(grid)\n    n = len(grid[0])\n    visited = [[False] * n for _ in range(m)]\n\n    return dfs(0, 0)\n\ndef g():\n    return [[1, 1, 0, 0],\n            [1, 1, 1, 1],\n            [0, 0, 1, 1],\n            [0, 0, 0, 1]]\n\nassert f(g()) == True\n",
        "idx_generation": 173,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, count the number of islands.\n    An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.\n    '1' represents land and '0' represents water.\n    \"\"\"\n    if not grid:\n        return 0\n\n    def dfs(row, col):\n        if row < 0 or col < 0 or row >= len(grid) or col >= len(grid[0]) or grid[row][col] != '1':\n            return\n        grid[row][col] = '0'\n        dfs(row + 1, col)\n        dfs(row - 1, col)\n        dfs(row, col + 1)\n        dfs(row, col - 1)\n\n    island_count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == '1':\n                island_count += 1\n                dfs(i, j)\n    return island_count\n\ndef g():\n    return [[\"1\",\"1\",\"1\",\"1\",\"0\"],\n            [\"1\",\"1\",\"0\",\"1\",\"0\"],\n            [\"1\",\"1\",\"0\",\"0\",\"0\"],\n            [\"0\",\"0\",\"0\",\"0\",\"0\"]]\n\nassert f(g()) == 1\n",
        "idx_generation": 414,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode, target: int) -> List[List[int]]:\n    \"\"\"\n    Given a binary tree and a target sum, find all root-to-leaf paths where each path's sum equals the given target.\n    Return a list of paths.\n    \"\"\"\n    def find_paths(node, current_sum, path, result):\n        if not node:\n            return\n        \n        current_sum += node.val\n        path.append(node.val)\n        \n        if not node.left and not node.right:\n            if current_sum == target:\n                result.append(path[:])\n        \n        find_paths(node.left, current_sum, path, result)\n        find_paths(node.right, current_sum, path, result)\n        \n        path.pop()\n    \n    result = []\n    find_paths(root, 0, [], result)\n    return result\n\ndef g():\n    root = TreeNode(5)\n    root.left = TreeNode(4)\n    root.right = TreeNode(8)\n    root.left.left = TreeNode(11)\n    root.left.left.left = TreeNode(7)\n    root.left.left.right = TreeNode(2)\n    root.right.left = TreeNode(13)\n    root.right.right = TreeNode(4)\n    root.right.right.left = TreeNode(5)\n    root.right.right.right = TreeNode(1)\n    target = 22\n    return root, target\n\nassert f(*g()) == [[5, 4, 11, 2], [5, 8, 4, 5]]\n",
        "idx_generation": 436,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target integer, find all unique combinations in the list\n    where the sum of the combination equals the target.\n\n    Example:\n    arr = [2, 3, 6, 7]\n    target = 7\n\n    Output:\n    [\n        [2, 2, 3],\n        [7]\n    ]\n    \"\"\"\n\n    def backtrack(combination, start, remainder):\n        if remainder == 0:\n            result.append(combination[:])\n            return\n        for i in range(start, len(arr)):\n            if arr[i] > remainder:\n                break\n            if i > start and arr[i] == arr[i-1]:\n                continue\n            combination.append(arr[i])\n            backtrack(combination, i, remainder - arr[i])\n            combination.pop()\n\n    arr.sort()\n    result = []\n    backtrack([], 0, target)\n    return result\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate the input for the function f.\n    \"\"\"\n    return ([2, 3, 6, 7], 7)\n\nassert f(*g()) == [[2, 2, 3], [7]]\n",
        "idx_generation": 421,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[str]], target: str, rows=3, cols=3) -> bool:\n    \"\"\"\n    Given a grid of characters and a target string, determine if the target string can be formed by concatenating characters from the grid.\n    The characters can be concatenated horizontally, vertically, or diagonally in any direction.\n    \"\"\"\n    def dfs(i, j, word):\n        if len(word) == 0:\n            return True\n        if i < 0 or i >= rows or j < 0 or j >= cols or grid[i][j] != word[0]:\n            return False\n        temp = grid[i][j]\n        grid[i][j] = \"#\"\n        found = dfs(i+1, j, word[1:]) or dfs(i-1, j, word[1:]) or dfs(i, j+1, word[1:]) or dfs(i, j-1, word[1:]) or dfs(i+1, j+1, word[1:]) or dfs(i-1, j-1, word[1:]) or dfs(i+1, j-1, word[1:]) or dfs(i-1, j+1, word[1:])\n        grid[i][j] = temp\n        return found\n\n    for i in range(rows):\n        for j in range(cols):\n            if dfs(i, j, target):\n                return True\n    return False\n\ndef g(grid = [[\"a\",\"b\",\"c\"],[\"d\",\"e\",\"f\"],[\"g\",\"h\",\"i\"]], target = \"aei\"):\n    return grid, target\n\nassert f(*g())\n",
        "idx_generation": 49,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of subsets with a given sum.\n    \"\"\"\n    def subset_sum(nums, target, curr, index):\n        if index == len(nums):\n            if sum(curr) == target:\n                return 1\n            else:\n                return 0\n            \n        count = subset_sum(nums, target, curr, index + 1)\n        count += subset_sum(nums, target, curr + [nums[index]], index + 1)\n        return count\n    \n    return subset_sum(nums, 8, [], 0)\n\ndef g(nums = [1, 2, 3, 4, 5]):\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 3\n",
        "idx_generation": 113,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort them in non-decreasing order.\n\n    Args:\n    - nums: The list of integers.\n\n    Returns:\n    - The sorted list of integers.\n    \"\"\"\n    return sorted(nums)\n\ndef g():\n    nums = [5, 2, 9, 1, 7]\n    return nums\n\nassert f(g()) == [1, 2, 5, 7, 9]\n\n",
        "idx_generation": 457,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums, check if the list is sorted in non-decreasing order.\n\n    Return True if the list is sorted, False otherwise.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    True\n\n    Explanation:\n    The list [1, 2, 3, 4, 5] is sorted in non-decreasing order.\n    \"\"\"\n\n    def is_sorted(nums):\n        for i in range(len(nums) - 1):\n            if nums[i] > nums[i + 1]:\n                return False\n        return True\n\n    return is_sorted(nums)\n\ndef g():\n    \"\"\"\n    Generate a list of integers in non-decreasing order.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == True\n",
        "idx_generation": 139,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Stack:\n    def __init__(self):\n        self.stack = []\n\n    def push(self, x):\n        self.stack.append(x)\n\n    def pop(self):\n        if not self.empty():\n            return self.stack.pop()\n        else:\n            return None\n\n    def top(self):\n        if not self.empty():\n            return self.stack[-1]\n        else:\n            return None\n\n    def empty(self):\n        return len(self.stack) == 0\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the largest rectangular area in a histogram created by the given heights.\"\"\"\n    stack = Stack()\n    max_area = 0\n    i = 0\n    while i < len(nums):\n        if stack.empty() or nums[i] >= nums[stack.top()]:\n            stack.push(i)\n            i += 1\n        else:\n            top = stack.pop()\n            area = nums[top] * (i if stack.empty() else (i - stack.top() - 1))\n            max_area = max(max_area, area)\n    while not stack.empty():\n        top = stack.pop()\n        area = nums[top] * (i if stack.empty() else (i - stack.top() - 1))\n        max_area = max(max_area, area)\n    return max_area\n\ndef g(nums=[2, 1, 5, 6, 2, 3]):\n    return nums\n\nassert f(g()) == 10\n",
        "idx_generation": 83,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list.\n    If the target is not found, return -1.\n\n    Example:\n    nums = [-1, 0, 3, 5, 9, 12]\n    target = 9\n\n    Output:\n    4\n\n    Explanation:\n    The target value 9 is found at index 4 in the list.\n\n    Hint: Consider using binary search to efficiently find the target value in the sorted list.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(nums: List[int] = [-1, 0, 3, 5, 9, 12], target: int = 9) -> int:\n    return nums, target\n\nassert f(*g()) == 4\n\n",
        "idx_generation": 474,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Check if it is possible to select a subarray from the given array 'arr' such that the sum of the subarray is\n    equal to the given target value.\n    \"\"\"\n    n = len(arr)\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + arr[i - 1]\n\n    stack = []\n    for i in range(n + 1):\n        while stack and prefix_sum[i] - prefix_sum[stack[0]] > target:\n            stack.pop(0)\n        if stack and prefix_sum[i] - prefix_sum[stack[0]] == target:\n            return True\n        stack.append(i)\n\n    return False\n\n\ndef g(arr=[1, 2, 3, 4, 5, 6], target=9):\n    return arr, target\n\n\nassert f(*g()) == True\n",
        "idx_generation": 108,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(string: str) -> str:\n    \"\"\"\n    Given a string, remove all duplicate characters and return the resulting string.\n    \"\"\"\n    stack = []\n    for char in string:\n        if char not in stack:\n            stack.append(char)\n    return \"\".join(stack)\n\ndef g() -> str:\n    \"\"\"\n    Generate a string with duplicate characters.\n    \"\"\"\n    return \"hello world\"\n\nassert f(g()) == \"helo wrd\"\n",
        "idx_generation": 134,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, find the longest word that can be built one character at a time\n    by other words in the list. If there are multiple answers, return the one with the smallest\n    lexicographical order.\n    \"\"\"\n    word_set = set(words)\n    longest_word = \"\"\n    \n    for word in words:\n        if len(word) > len(longest_word) or (len(word) == len(longest_word) and word < longest_word):\n            is_buildable = True\n            for i in range(1, len(word)):\n                if word[:i] not in word_set:\n                    is_buildable = False\n                    break\n            if is_buildable:\n                longest_word = word\n    \n    return longest_word\n\ndef g() -> List[str]:\n    return [\"w\", \"wo\", \"wor\", \"worl\", \"world\"]\n\nassert f(g()) == \"world\"\n",
        "idx_generation": 100,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value k, find two distinct numbers in the list that add up to k.\n\n    Example:\n    Input:\n    nums = [2, 4, 6, 8, 10]\n    k = 14\n\n    Output:\n    [4, 10]\n\n    Explanation:\n    The numbers 4 and 10 add up to 14.\n    \"\"\"\n\n    def findPairs(nums: List[int], k: int, index: int, path: List[int], result: List[List[int]]) -> None:\n        if k == 0 and len(path) == 2:\n            result.append(path)\n            return\n\n        if index >= len(nums) or k < 0 or len(path) >= 2:\n            return\n\n        findPairs(nums, k - nums[index], index + 1, path + [nums[index]], result)\n        findPairs(nums, k, index + 1, path, result)\n\n    result = []\n    findPairs(nums, k, 0, [], result)\n    return result[0]\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return [2, 4, 6, 8, 10], 14\n\nassert f(*g()) == [4, 10]\n",
        "idx_generation": 338,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there exists a pair of distinct numbers in the list\n    whose bitwise XOR equals the given target value.\n    \"\"\"\n    n = len(arr)\n    i, j = 0, 1\n    while i < n and j < n:\n        if arr[j] - arr[i] == target:\n            return True\n        elif arr[j] - arr[i] < target:\n            j += 1\n        else:\n            i += 1\n            if i == j:\n                j += 1\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), 6)\n",
        "idx_generation": 87,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nimport math\n\ndef f(n: int, result: str) -> bool:\n    \"\"\"Check if the given number is the result of taking the square root of any positive integer.\"\"\"\n    return math.isqrt(n) ** 2 == n and str(n) == result\ndef g():\n    return 49 ** 2\nassert f(g(), \"2401\")\n",
        "idx_generation": 21,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a perfect square.\n    \"\"\"\n    if n < 0:\n        return False\n    if n == 0 or n == 1:\n        return True\n    left = 0\n    right = n\n    while left <= right:\n        mid = (left + right) // 2\n        if mid * mid == n:\n            return True\n        elif mid * mid < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef g(n = 16):\n    return f(n)\n\nassert f(g()) == True\n",
        "idx_generation": 123,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, find all unique triplets in the list that sum up to zero.\n    Each triplet should be sorted in ascending order.\n\n    Example:\n    nums = [-1, 0, 1, 2, -1, -4]\n\n    Output:\n    [\n        [-1, -1, 2],\n        [-1, 0, 1]\n    ]\n\n    Explanation:\n    The unique triplets that sum up to zero are [-1, -1, 2] and [-1, 0, 1].\n    \"\"\"\n    n = len(nums)\n    triplets = []\n    nums.sort()\n    \n    for i in range(n - 2):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        \n        left = i + 1\n        right = n - 1\n        \n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n            \n            if total == 0:\n                triplets.append([nums[i], nums[left], nums[right]])\n                \n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                \n                left += 1\n                right -= 1\n            elif total < 0:\n                left += 1\n            else:\n                right -= 1\n    \n    return triplets\n\ndef g():\n    return ([-1, 0, 1, 2, -1, -4],)\n\nassert f(*g()) == [[-1, -1, 2], [-1, 0, 1]]\n\n",
        "idx_generation": 400,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> bool:\n    \"\"\"\n    Determine if a binary tree is a valid binary search tree.\n    \"\"\"\n    def is_valid(node, min_val, max_val):\n        if node is None:\n            return True\n        if node.val <= min_val or node.val >= max_val:\n            return False\n        return is_valid(node.left, min_val, node.val) and is_valid(node.right, node.val, max_val)\n    \n    return is_valid(root, float('-inf'), float('inf'))\n\ndef g():\n    \"\"\"\n    Create a binary tree to check if it is a valid binary search tree.\n    \"\"\"\n    root = TreeNode(2)\n    root.left = TreeNode(1)\n    root.right = TreeNode(3)\n    return root\n\nassert f(g()) == True\n",
        "idx_generation": 78,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size n x n, where each cell contains a non-negative integer, find the minimum path sum from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    n = 3\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7 (since the minimum path sum is 1 -> 3 -> 1 -> 1 -> 1, which sums up to 7)\n    \"\"\"\n\n    def dp(i: int, j: int, dp_table: List[List[int]]) -> int:\n        if i == 0 and j == 0:\n            return grid[i][j]\n        if dp_table[i][j] != -1:\n            return dp_table[i][j]\n        if i == 0:\n            dp_table[i][j] = grid[i][j] + dp(i, j-1, dp_table)\n        elif j == 0:\n            dp_table[i][j] = grid[i][j] + dp(i-1, j, dp_table)\n        else:\n            dp_table[i][j] = grid[i][j] + min(dp(i-1, j, dp_table), dp(i, j-1, dp_table))\n        return dp_table[i][j]\n\n    dp_table = [[-1] * n for _ in range(n)]\n    return dp(n-1, n-1, dp_table)\n\ndef g():\n    return 3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(*g()) == 7\n\n",
        "idx_generation": 140,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return the spiral order of the matrix.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n    Explanation:\n    The spiral order of the matrix is [1, 2, 3, 6, 9, 8, 7, 4, 5].\n\n    Hint: You can solve this problem using a combination of recursion and iteration, where you traverse the matrix in a spiral order by moving in a clockwise direction.\n    \"\"\"\n    if not matrix:\n        return []\n    \n    result = []\n    rows, cols = len(matrix), len(matrix[0])\n    top, bottom = 0, rows - 1\n    left, right = 0, cols - 1\n    \n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n        \n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n        \n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n        \n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n    \n    return result\n\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 190,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return the elements of the matrix in spiral order.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    [1, 2, 3, 6, 9, 8, 7, 4, 5]\n    \"\"\"\n\n    if not matrix or not matrix[0]:\n        return []\n\n    rows, cols = len(matrix), len(matrix[0])\n    top, bottom, left, right = 0, rows - 1, 0, cols - 1\n    \n    result = []\n\n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate the input for the function f.\n    \"\"\"\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 464,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of ways to climb n stairs if you can take either 1 or 2 steps at a time.\n\n    Example:\n    n = 4\n\n    Output:\n    5\n\n    Explanation:\n    There are 5 ways to climb 4 stairs:\n    - 1 step + 1 step + 1 step + 1 step\n    - 1 step + 1 step + 2 steps\n    - 1 step + 2 steps + 1 step\n    - 2 steps + 1 step + 1 step\n    - 2 steps + 2 steps\n    \"\"\"\n    if n <= 2:\n        return n\n\n    dp = [0] * (n+1)\n    dp[1] = 1\n    dp[2] = 2\n\n    for i in range(3, n+1):\n        dp[i] = dp[i-1] + dp[i-2]\n\n    return dp[n]\n\ndef g():\n    n = 4\n    return n\n\nassert f(g()) == 5\n\n",
        "idx_generation": 275,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers.\n    \"\"\"\n    num_map = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n        \n    return []\n\ndef g(nums = [2, 7, 11, 15], target = 9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 198,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int], target=50) -> bool:\n    \"\"\"Check if there exists two numbers in the list whose sum is equal to the target value.\"\"\"\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] + arr[j] == target:\n                return True\n    return False\n    \ndef g(arr=[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]):\n    return arr\n    \nassert f(g()) == True\n",
        "idx_generation": 1,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum subarray sum\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 72,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Determine if the number n is a perfect power of k.\n    A perfect power is a positive integer that can be expressed as an integer power of another positive integer.\n\n    Example:\n    n = 16, k = 2\n    16 can be expressed as 2^4, so the output should be True.\n\n    n = 27, k = 3\n    27 cannot be expressed as an integer power of 3, so the output should be False.\n    \"\"\"\n    if n == 1:\n        return True\n    for i in range(2, int(n ** 0.5) + 1):\n        power = i\n        while power <= n:\n            power *= i\n            if power == n:\n                return True\n    return False\n\ndef g(n=16, k=2):\n    return n, k\n\nassert f(*g()) == True\n",
        "idx_generation": 170,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers, find the number of subarrays where the sum is equal to the target value.\n    Return the number of subarrays.\n\n    Example:\n    nums = [1, 1, 1]\n    target = 2\n\n    Output:\n    2\n\n    Explanation:\n    The subarrays with sum equal to 2 are [1, 1] and [1, 1].\n\n    Hint: Use a hash table to store the prefix sums and their frequencies as you iterate through the list.\n    \"\"\"\n\n    prefix_sums = {0: 1}\n    curr_sum = 0\n    count = 0\n\n    for num in nums:\n        curr_sum += num\n\n        if curr_sum - target in prefix_sums:\n            count += prefix_sums[curr_sum - target]\n\n        if curr_sum in prefix_sums:\n            prefix_sums[curr_sum] += 1\n        else:\n            prefix_sums[curr_sum] = 1\n\n    return count\n\ndef g():\n    nums = [1, 1, 1]\n    target = 2\n    return nums, target\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 440,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums', return a new list where each element is repeated twice.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    [1, 1, 2, 2, 3, 3, 4, 4, 5, 5]\n    \"\"\"\n    return [num for num in nums for _ in range(2)]\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [1, 1, 2, 2, 3, 3, 4, 4, 5, 5]\n\n",
        "idx_generation": 288,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, wordDict: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a dictionary of words wordDict, determine if s can be segmented into a space-separated\n    sequence of one or more dictionary words.\n\n    Example:\n    s = \"leetcode\"\n    wordDict = [\"leet\", \"code\"]\n    Output: True\n\n    s = \"applepenapple\"\n    wordDict = [\"apple\", \"pen\"]\n    Output: True\n\n    s = \"catsandog\"\n    wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\n    Output: False\n    \"\"\"\n    n = len(s)\n    dp = [False] * (n + 1)\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for word in wordDict:\n            if i >= len(word) and s[i - len(word):i] == word:\n                dp[i] = dp[i] or dp[i - len(word)]\n\n    return dp[n]\n\ndef g(s: str = \"leetcode\", wordDict: List[str] = [\"leet\", \"code\"]):\n    return (s, wordDict)\n\nassert f(*g()) == True\n",
        "idx_generation": 211,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the sum of all the even numbers in the list.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The sum of all the even numbers in the list.\n    \"\"\"\n    even_sum = 0\n    for num in nums:\n        if num % 2 == 0:\n            even_sum += num\n    return even_sum\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6]\n    return nums\n\nassert f(g()) == 12\n\n",
        "idx_generation": 164,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum that can be obtained by selecting a subarray with a length of at least one.\n\n    Sample Input:\n    nums = [1, -2, 3, -4, 5]\n\n    Sample Output:\n    5\n\n    Explanation:\n    The maximum sum that can be obtained by selecting the subarray [5] with a length of one.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum\n\n\ndef g():\n    nums = [1, -2, 3, -4, 5]\n    return nums\n\nassert f(g()) == 5\n\n",
        "idx_generation": 317,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in the list that add up to the target.\n    Return their indices in a list.\n\n    Example:\n    nums = [2, 7, 11, 15], target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The sum of nums[0] and nums[1] is 2 + 7 = 9, therefore their indices are [0, 1].\n\n    Hint: Use a dictionary to store the complement of each number as you iterate through the list.\n    \"\"\"\n    if not nums:\n        return []\n\n    complement_map = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complement_map:\n            return [complement_map[complement], i]\n        complement_map[num] = i\n\n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 61,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if it is a magic square.\n    A magic square is a square matrix in which the sum of each row, each column, and both diagonals are equal.\n\n    Return True if the matrix is a magic square, otherwise return False.\n    \"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for j in range(n):\n        column_sum = 0\n        for i in range(n):\n            column_sum += matrix[i][j]\n        if column_sum != target_sum:\n            return False\n\n    # Check diagonals\n    diagonal_sum1 = 0\n    diagonal_sum2 = 0\n    for i in range(n):\n        diagonal_sum1 += matrix[i][i]\n        diagonal_sum2 += matrix[i][n-i-1]\n    if diagonal_sum1 != target_sum or diagonal_sum2 != target_sum:\n        return False\n\n    return True\n\ndef g(matrix=[[2, 7, 6], [9, 5, 1], [4, 3, 8]]):\n    return matrix\n\nassert f(g()) == True\n",
        "idx_generation": 460,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string of parentheses, return the length of the longest valid parentheses substring.\n    \n    Example:\n    s = \"(()\"\n\n    Output:\n    2\n\n    Explanation:\n    The longest valid parentheses substring is \"()\".\n\n    Hint: Use a stack to keep track of the indices of opening parentheses. When a closing parenthesis is encountered,\n    calculate the length of the valid substring by subtracting the index of the last opening parenthesis from the current index.\n    \"\"\"\n    stack = []\n    max_length = 0\n    start_index = -1\n    \n    for i in range(len(s)):\n        if s[i] == '(':\n            stack.append(i)\n        else:\n            if stack:\n                stack.pop()\n                if stack:\n                    max_length = max(max_length, i - stack[-1])\n                else:\n                    max_length = max(max_length, i - start_index)\n            else:\n                start_index = i\n    \n    return max_length\n\ndef g(s=\")()())\"):\n    return s\n\nassert f(g()) == 4\n\n",
        "idx_generation": 79,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, t: str) -> int:\n    \"\"\"\n    Given two strings s and t, return the length of the longest common subsequence (LCS) of s and t.\n\n    Example:\n    s = \"abcde\"\n    t = \"ace\"\n\n    Output:\n    3\n\n    Explanation:\n    The LCS of \"abcde\" and \"ace\" is \"ace\" with a length of 3.\n    \"\"\"\n\n    m, n = len(s), len(t)\n    dp = [[0] * (n+1) for _ in range(m+1)]\n\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if s[i-1] == t[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n\n    return dp[m][n]\n\ndef g():\n    s = \"abcde\"\n    t = \"ace\"\n    return (s, t)\n\nassert f(*g()) == 3\n",
        "idx_generation": 459,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, find the maximum area of a rectangle containing only 1s.\n\n    Example:\n    grid = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n\n    Output:\n    6\n\n    Explanation:\n    The maximum area of a rectangle containing only 1s is formed by the subgrid:\n    [\n        [1, 1, 1],\n        [1, 1, 1]\n    ], which has an area of 6.\n\n    Hint: Use dynamic programming to calculate the maximum area at each cell.\n    \"\"\"\n    def largest_rectangle_area(heights):\n        stack = [-1]\n        max_area = 0\n        for i, h in enumerate(heights):\n            while stack[-1] != -1 and h <= heights[stack[-1]]:\n                height = heights[stack.pop()]\n                width = i - stack[-1] - 1\n                max_area = max(max_area, height * width)\n            stack.append(i)\n        while stack[-1] != -1:\n            height = heights[stack.pop()]\n            width = len(heights) - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        return max_area\n\n    m = len(grid)\n    n = len(grid[0])\n\n    heights = [0] * n\n    max_area = 0\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                heights[j] += 1\n            else:\n                heights[j] = 0\n\n        max_area = max(max_area, largest_rectangle_area(heights))\n\n    return max_area\n\ndef g(grid=[[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]):\n    return [grid]\n\nassert f(*g()) == 6\n",
        "idx_generation": 158,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Determine if there exists a subgrid in the given 2D grid, such that the sum of all its elements is equal to the target.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n    target = 12\n    Output: True\n    Explanation: The subgrid [[3, 4],\n                              [6, 2]] has a sum of 12.\n\n    \"\"\"\n    assert len(grid) >= 1\n    assert len(grid[0]) >= 1\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            for m in range(i, len(grid)):\n                for n in range(j, len(grid[0])):\n                    subgrid = [row[j:n+1] for row in grid[i:m+1]]\n                    if sum(sum(row) for row in subgrid) == target:\n                        return True\n    return False\ndef g(target=12):\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n    return grid\nassert f(g(), target=12)\n",
        "idx_generation": 11,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers n and m, return the number of unique paths from the top-left corner to the bottom-right corner\n    of an n x m grid. You can only move down or right at any point in time.\n\n    Example:\n    Input: n = 3, m = 7\n    Output: 28\n\n    Explanation:\n    We start at the top-left corner of a 3x7 grid. To reach the bottom-right corner, we need to take a total of 3 steps\n    down and 7 steps right. The total number of unique paths is 28.\n    \"\"\"\n    dp = [[0] * m for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][0] = 1\n    \n    for j in range(m):\n        dp[0][j] = 1\n    \n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[n-1][m-1]\n\ndef g():\n    return 3, 7\n\nassert f(*g()) == 28\n",
        "idx_generation": 46,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size n x m, find the minimum cost to reach the bottom-right cell from the top-left cell.\n    You can only move down or right.\n    \"\"\"\n    dp = [[float('inf')] * m for _ in range(n)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(n):\n        for j in range(m):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j])\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j])\n\n    return dp[n-1][m-1]\n\ndef g() -> Tuple[int, int, List[List[int]]]:\n    n = 3\n    m = 3\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return n, m, grid\n\nassert f(*g()) == 7\n",
        "idx_generation": 443,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome after removing at most one character.\n    \"\"\"\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    left = 0\n    right = len(s) - 1\n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s, left + 1, right) or is_palindrome(s, left, right - 1)\n        left += 1\n        right -= 1\n    return True\n\ndef g():\n    s = \"abca\"\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 459,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Determine if a string is a palindrome.\n\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n    Only alphanumeric characters are considered, and the case is ignored.\n\n    Example:\n    f(\"A man, a plan, a canal: Panama\") returns True\n\n    Note:\n    - Empty strings are considered palindromes.\n    - Special characters and spaces are ignored.\n    \"\"\"\n\n    # Remove special characters and spaces, and convert to lowercase\n    s = ''.join(ch.lower() for ch in s if ch.isalnum())\n\n    # Use a deque to efficiently check if the string is a palindrome\n    char_deque = deque(s)\n    while len(char_deque) > 1:\n        if char_deque.popleft() != char_deque.pop():\n            return False\n\n    return True\n\n\ndef g() -> str:\n    \"\"\"\n    Generate a string that may or may not be a palindrome.\n\n    Example:\n    g() returns \"A man, a plan, a canal: Panama\"\n\n    Note:\n    - The generated string may contain special characters and spaces.\n    \"\"\"\n\n    return \"A man, a plan, a canal: Panama\"\n\n\nassert f(g()) == True\n",
        "idx_generation": 296,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, find the longest substring without repeating characters.\n\n    Sample Input:\n    s = \"abcabcbb\"\n\n    Sample Output:\n    3\n    \"\"\"\n    start = 0\n    max_length = 0\n    visited = {}\n\n    for end, char in enumerate(s):\n        if char in visited and start <= visited[char]:\n            start = visited[char] + 1\n        else:\n            max_length = max(max_length, end - start + 1)\n        visited[char] = end\n\n    return max_length\n\ndef g():\n    s = \"abcabcbb\"\n    return s\n\nassert f(g()) == 3\n\n",
        "idx_generation": 445,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of bits that are set to 1 in its binary representation.\n\n    Example:\n    n = 27\n\n    Output:\n    4\n\n    Explanation:\n    The binary representation of 27 is 11011, which has 4 bits set to 1.\n\n    Hint: Use bit manipulation to solve this problem.\n    \"\"\"\n\n    count = 0\n\n    while n > 0:\n        count += n & 1\n        n >>= 1\n\n    return count\n\ndef g() -> int:\n    n = 27\n    return n\n\nassert f(g()) == 4\n",
        "idx_generation": 492,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given an array of integers arr and a target integer, determine if there exists a subset of the array\n    such that the bitwise XOR of all its elements is equal to the target.\n\n    Example:\n    Input:\n    arr = [1, 2, 3, 4]\n    target = 5\n\n    Output:\n    True\n\n    Explanation:\n    The subset [1, 4] has a bitwise XOR of 1 ^ 4 = 5, which is equal to the target.\n    \"\"\"\n    def subset_sum(arr: List[int], target: int) -> bool:\n        n = len(arr)\n        dp = [[False] * (target + 1) for _ in range(n + 1)]\n        \n        for i in range(n + 1):\n            dp[i][0] = True\n        \n        for i in range(1, n + 1):\n            for j in range(1, target + 1):\n                if arr[i - 1] <= j:\n                    dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        \n        return dp[n][target]\n    \n    return subset_sum(arr, target)\n\ndef g():\n    \"\"\"\n    Generate an array of integers and a target integer with the following structure:\n    arr = [1, 2, 3, 4]\n    target = 5\n    \"\"\"\n    return [1, 2, 3, 4], 5\n\nassert f(*g()) == True\n",
        "idx_generation": 295,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\nfrom math import factorial\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the factorial of n.\n\n    Example:\n    n = 5\n\n    Output:\n    120\n    \"\"\"\n    return factorial(n)\n\ndef g():\n    return 5\n\nassert f(g()) == 120\n",
        "idx_generation": 464,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Find the nth Fibonacci number.\n\n    - n is the index of the Fibonacci number to find.\n    - The Fibonacci sequence starts with 0 and 1, and each subsequent number is the sum of the two previous numbers.\n    \"\"\"\n    if n <= 1:\n        return n\n\n    a, b = 0, 1\n\n    for _ in range(n - 1):\n        a, b = b, a + b\n\n    return b\n\ndef g(n = 6):\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 458,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the minimum cost to reach the bottom-right cell of the grid from the top-left cell.\"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(m):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j])\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j])\n    \n    return dp[m-1][n-1]\n\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 7\n",
        "idx_generation": 197,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, find the number of 1 bits it has.\n    \"\"\"\n    count = 0\n    while n > 0:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g():\n    return 11\n\nassert f(g()) == 3\n\n",
        "idx_generation": 166,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid containing 1s and 0s, where 1 represents a land and 0 represents water, find the number of islands in the grid.\n    An island is formed by connecting adjacent lands horizontally or vertically.\n\n    Args:\n    - grid: A list of lists representing the grid.\n\n    Returns:\n    - The number of islands in the grid.\n    \"\"\"\n    def dfs(row, col):\n        if row < 0 or col < 0 or row >= len(grid) or col >= len(grid[0]) or grid[row][col] != 1:\n            return\n        grid[row][col] = -1\n        dfs(row - 1, col)\n        dfs(row + 1, col)\n        dfs(row, col - 1)\n        dfs(row, col + 1)\n\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                dfs(i, j)\n                count += 1\n\n    return count\n\ndef g():\n    grid = [[1, 1, 0, 0, 0],\n            [1, 1, 0, 0, 0],\n            [0, 0, 1, 0, 0],\n            [0, 0, 0, 1, 1]]\n    return grid\n\nassert f(g()) == 3\n",
        "idx_generation": 101,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, paths=[(1, 2), (2, 3), (2, 4), (3, 5), (4, 5), (5, 6)], target=6) -> bool:\n    \"\"\"Check if there is a path from node 1 to node target in a given graph.\"\"\"\n    visited = [False] * (target + 1)\n    stack = [1]\n    while stack:\n        node = stack.pop()\n        visited[node] = True\n        if node == target:\n            return True\n        for neighbor in paths:\n            if neighbor[0] == node and not visited[neighbor[1]]:\n                stack.append(neighbor[1])\n    return False\n\ndef g(paths=[(1, 2), (2, 3), (2, 4), (3, 5), (4, 5), (5, 6)], target=6):\n    return f(len(paths), paths, target)\n\nassert f(g()) == True\n",
        "idx_generation": 7,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> int:\n    \"\"\"\n    Given a binary tree, calculate the sum of all the odd-valued nodes in the tree.\n\n    Sample Input:\n    root = TreeNode(1)\n                1\n               / \\\n              2   3\n             / \\ / \\\n            4  5 6  7\n\n    Sample Output:\n    16\n    \"\"\"\n    def dfs(node: TreeNode) -> int:\n        if not node:\n            return 0\n        \n        current = 0\n        if node.val % 2 == 1:\n            current = node.val\n        \n        left_sum = dfs(node.left)\n        right_sum = dfs(node.right)\n        \n        return current + left_sum + right_sum\n    \n    return dfs(root)\n\ndef g():\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    \n    return root\n\nassert f(g()) == 16\n\n",
        "idx_generation": 474,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid filled with non-negative numbers representing the height of each unit cell,\n    determine if it is possible to reach the bottom-right corner from the top-left corner by moving only right or down.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[m-1][n-1] <= 100\n\ndef g(grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 179,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if the given grid is a magic square.\"\"\"\n    n = len(grid)\n    row_sums = [sum(row) for row in grid]\n    col_sums = [sum(col) for col in zip(*grid)]\n    diag_sum_1 = sum(grid[i][i] for i in range(n))\n    diag_sum_2 = sum(grid[i][n-i-1] for i in range(n))\n    \n    if len(set(row_sums)) == 1 and len(set(col_sums)) == 1 and diag_sum_1 == diag_sum_2:\n        return True\n    return False\n\ndef g(n=3):\n    \"\"\"Generate a magic square of size n x n.\"\"\"\n    grid = [[0] * n for _ in range(n)]\n    num = 1\n    i, j = 0, n // 2\n\n    while num <= n ** 2:\n        grid[i][j] = num\n        num += 1\n        new_i = (i - 1) % n\n        new_j = (j + 1) % n\n\n        if grid[new_i][new_j] != 0:\n            i = (i + 1) % n\n        else:\n            i = new_i\n            j = new_j\n\n    return grid\n\nassert f(g())\n",
        "idx_generation": 450,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"\n    Given a string s and a target string, return True if it is possible to form the target string by concatenating\n    subsequences of the string s. Otherwise, return False.\n    \"\"\"\n    def dfs(s: str, target: str, index: int) -> bool:\n        if index == len(target):\n            return True\n        if not s:\n            return False\n        if s[0] == target[index]:\n            if dfs(s[1:], target, index+1):\n                return True\n        return dfs(s[1:], target, index)\n    \n    return dfs(s, target, 0)\n\ndef g():\n    return \"abcabcabc\"\n\nassert f(g(), \"aba\") == True\n\n",
        "idx_generation": 68,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nimport itertools\n\ndef f(n: int, k=3, target=6) -> bool:\n    \"\"\"\n    Determine if there exists a combination of numbers from 1 to n that sums up to the target.\n    The combination must consist of k numbers and can include duplicates.\n    \"\"\"\n    numbers = list(range(1, n+1))\n    combinations = list(itertools.combinations_with_replacement(numbers, k))\n    \n    for combo in combinations:\n        if sum(combo) == target:\n            return True\n    return False\n\ndef g(k=3, target=6):\n    return target // k\n\nassert f(g()) == True\n",
        "idx_generation": 54,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, determine the number of distinct prime factors of n.\n\n    Example:\n    n = 36\n\n    Output:\n    2\n\n    Explanation:\n    The distinct prime factors of 36 are 2 and 3.\n\n    Hint: Use prime factorization and counting techniques to solve the problem.\n    \"\"\"\n    if n < 2:\n        return 0\n    count = 0\n    for i in range(2, n + 1):\n        if n % i == 0:\n            count += 1\n            while n % i == 0:\n                n //= i\n    return count\n\ndef g(n=36):\n    return n\n\nassert f(g()) == 2\n",
        "idx_generation": 309,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums', sort the list in non-decreasing order using bubble sort algorithm.\n\n    Example:\n    nums = [5, 2, 9, 1, 3]\n\n    Output:\n    [1, 2, 3, 5, 9]\n    \"\"\"\n\n    n = len(nums)\n    for i in range(n):\n        for j in range(n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n\n    return nums\n\ndef g() -> List[int]:\n    return [5, 2, 9, 1, 3]\n\nassert f(g()) == [1, 2, 3, 5, 9]\n",
        "idx_generation": 457,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and a target value, find all unique combinations of three numbers in the array that sum up to the target value. Return a list of lists containing the combinations.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7]\n    target = 10\n\n    Output:\n    [[1, 2, 7], [1, 3, 6], [1, 4, 5], [2, 3, 5]] (since 1 + 2 + 7 = 10, 1 + 3 + 6 = 10, 1 + 4 + 5 = 10, and 2 + 3 + 5 = 10)\n    \"\"\"\n    nums.sort()\n    result = []\n    for i in range(len(nums) - 2):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n        left = i + 1\n        right = len(nums) - 1\n        while left < right:\n            curr_sum = nums[i] + nums[left] + nums[right]\n            if curr_sum == target:\n                result.append([nums[i], nums[left], nums[right]])\n                left += 1\n                right -= 1\n                while left < right and nums[left] == nums[left-1]:\n                    left += 1\n                while left < right and nums[right] == nums[right+1]:\n                    right -= 1\n            elif curr_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return result\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7], 10\n\nassert f(*g()) == [[1, 2, 7], [1, 3, 6], [1, 4, 5], [2, 3, 5]]\n\n",
        "idx_generation": 219,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, sort the list in non-decreasing order.\n    \"\"\"\n\n    n = len(nums)\n    for i in range(n):\n        for j in range(n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n\n    return nums\n\ndef g():\n    nums = [5, 2, 8, 1, 9, 3]\n    return nums\n\nassert f(g()) == [1, 2, 3, 5, 8, 9]\n\n",
        "idx_generation": 84,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find two numbers whose sum is equal to the target number.\n    Return the indices of the two numbers in the list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    Output: [0, 1]\n    Explanation: The sum of nums[0] + nums[1] = 2 + 7 = 9, and their indices are 0 and 1.\n\n    Hint: You can solve this problem using a two-pointer approach.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        \n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 480,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray.\n    A subarray is a contiguous part of the array.\n\n    Return the maximum sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The subarray with the maximum sum is [4, -1, 2, 1], which gives a sum of 6.\n    \"\"\"\n    def max_subarray_sum(nums: List[int], start: int, end: int) -> int:\n        if start == end:\n            return nums[start]\n\n        mid = (start + end) // 2\n\n        max_left_sum = max_subarray_sum(nums, start, mid)\n        max_right_sum = max_subarray_sum(nums, mid+1, end)\n\n        left_sum = float('-inf')\n        sum = 0\n\n        for i in range(mid, start-1, -1):\n            sum += nums[i]\n            left_sum = max(left_sum, sum)\n\n        right_sum = float('-inf')\n        sum = 0\n\n        for i in range(mid+1, end+1):\n            sum += nums[i]\n            right_sum = max(right_sum, sum)\n\n        return max(max_left_sum, max_right_sum, left_sum + right_sum)\n\n    return max_subarray_sum(nums, 0, len(nums)-1)\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\n\nassert f(g()) == 6\n\n",
        "idx_generation": 133,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers from the list whose sum is equal to the target value.\n    \"\"\"\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 147,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with the binary representation of each number.\n    \"\"\"\n    def decimal_to_binary(n):\n        binary = []\n        while n > 0:\n            binary.append(n % 2)\n            n //= 2\n        binary.reverse()\n        return binary\n\n    binary_list = []\n    for num in nums:\n        binary_list.append(decimal_to_binary(num))\n    return binary_list\n\ndef g() -> List[int]:\n    return [10, 5, 12, 8]\n\nassert f(g()) == [[1, 0, 1, 0], [1, 0, 1], [1, 1, 0, 0], [1, 0, 0, 0]]\n\n",
        "idx_generation": 151,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find two numbers in the list that sum up to the target.\n    Return the indices of the two numbers in the list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Hint: Use a two-pointer approach to search for the pair of numbers.\n    \"\"\"\n\n    def two_sum(nums, target):\n        num_dict = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in num_dict:\n                return [num_dict[complement], i]\n            num_dict[num] = i\n        return []\n\n    return two_sum(nums, target)\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return (nums, target)\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 487,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a pair of numbers in the list\n    whose bitwise AND equals the given target value.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] & arr[j] == target:\n                return True\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), 6)\n",
        "idx_generation": 113,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list is a valid mountain array.\"\"\"\n    if len(nums) < 3:\n        return False\n    \n    increasing = True\n    \n    for i in range(1, len(nums)):\n        if nums[i] == nums[i-1]:\n            return False\n        elif increasing:\n            if nums[i] < nums[i-1]:\n                increasing = False\n        else:\n            if nums[i] >= nums[i-1]:\n                return False\n    \n    return not increasing\n\ndef g() -> List[int]:\n    nums = [0, 3, 2, 1]\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 40,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list contains a consecutive sequence of numbers that adds up to a target value\"\"\"\n    nums.sort()\n    target = sum(nums)\n    prefix_sum = 0\n    \n    for i in range(len(nums)):\n        prefix_sum += nums[i]\n        \n        if prefix_sum == target:\n            return True\n        \n        while prefix_sum > target and nums[i] > 0:\n            prefix_sum -= nums[i]\n            i -= 1\n    \n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 134,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a matrix of integers sorted in ascending order in each row, and each column is also sorted in ascending order,\n    determine if the target number is present in the matrix.\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return False\n    \n    rows, cols = len(matrix), len(matrix[0])\n    row, col = 0, cols - 1\n    \n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n    \n    return False\n\ndef g(matrix=[[1, 4, 7], [2, 5, 8], [3, 6, 9]], target=5):\n    return (matrix, target)\n\nassert f(*g()) == True\n\n",
        "idx_generation": 407,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "import random\nfrom typing import*\nimport math\nfrom typing import List\n\ndef f(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size n x m, where each cell contains a non-negative integer,\n    calculate the maximum sum of a path from the top-left cell to the bottom-right cell.\n\n    A path can only move down or right and cannot visit the same cell twice.\n\n    Return the maximum sum.\n\n    Example:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\n    Output:\n    12\n\n    Explanation:\n    The maximum sum path is 1 -> 3 -> 5 -> 2 -> 1, which gives a total sum of 12.\n    \"\"\"\n\n    def max_sum_path(grid, i, j, memo):\n        if i == 0 and j == 0:\n            return grid[i][j]\n        if i < 0 or j < 0:\n            return 0\n        if (i, j) in memo:\n            return memo[(i, j)]\n        memo[(i, j)] = grid[i][j] + max(max_sum_path(grid, i-1, j, memo), max_sum_path(grid, i, j-1, memo))\n        return memo[(i, j)]\n\n    return max_sum_path(grid, n-1, m-1, memo={})\n\ndef g(n: int, m: int, grid: List[List[int]]):\n    \"\"\"\n    Generate a grid of size n x m with random non-negative integers.\n    \"\"\"\n    return n, m, grid\n\nassert f(*g(3, 3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]])) == 12\n",
        "idx_generation": 97,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the length of the shortest path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    Input:\n    [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 7\n    Explanation: The path is [1, 3, 1, 1, 1].\n\n    Note:\n    - You can assume that the grid doesn't contain any negative numbers.\n    - You can assume that the grid is rectangular (i.e. has the same number of rows and columns).\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    # Initialize first row and first column\n    dp[0][0] = grid[0][0]\n    for i in range(1, n):\n        dp[0][i] = dp[0][i - 1] + grid[0][i]\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    # Calculate shortest path lengths\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[m - 1][n - 1]\n\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 7\n",
        "idx_generation": 169,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a list containing the next greater element for each element in the input list.\n\n    The next greater element for an element x is the first element on the right side of x in the input list that is greater than x.\n    If there is no such element, the output should be -1.\n\n    Example:\n    nums = [4, 5, 2, 25, 10, 8]\n\n    Output:\n    [5, 25, 25, -1, -1, -1]\n    \"\"\"\n    stack = []\n    result = [-1] * len(nums)\n\n    for i in range(len(nums)-1, -1, -1):\n        while stack and nums[i] >= stack[-1]:\n            stack.pop()\n        if stack:\n            result[i] = stack[-1]\n        stack.append(nums[i])\n\n    return result\n\ndef g():\n    nums = [4, 5, 2, 25, 10, 8]\n    return nums\n\nassert f(g()) == [5, 25, 25, -1, -1, -1]\n\n",
        "idx_generation": 200,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return the elements of the matrix in spiral order.\n    \n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    \n    Output:\n    [1, 2, 3, 6, 9, 8, 7, 4, 5]\n    \n    Explanation:\n    The elements of the matrix are traversed in the following order: \n    1, 2, 3, 6, 9, 8, 7, 4, 5\n    \"\"\"\n    \n    if not matrix:\n        return []\n    \n    result = []\n    top = 0\n    bottom = len(matrix) - 1\n    left = 0\n    right = len(matrix[0]) - 1\n    \n    while top <= bottom and left <= right:\n        # Traverse top row\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n        \n        # Traverse right column\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n        \n        # Traverse bottom row\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n        \n        # Traverse left column\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n    \n    return result\n\ndef g():\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 477,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers nums and an integer target, find the maximum length of a subarray that sums up to the target.\n\n    Example:\n    Input: nums = [1, -1, 5, -2, 3], target = 3\n    Output: 4\n\n    Explanation: The subarray [1, -1, 5, -2] has a sum of 3 and is the longest subarray that sums up to the target.\n    \"\"\"\n\n    prefix_sum = {0: -1}\n    curr_sum = 0\n    max_length = 0\n    for i, num in enumerate(nums):\n        curr_sum += num\n        if curr_sum - target in prefix_sum:\n            max_length = max(max_length, i - prefix_sum[curr_sum - target])\n        if curr_sum not in prefix_sum:\n            prefix_sum[curr_sum] = i\n    return max_length\n\ndef g():\n    nums = [1, -1, 5, -2, 3]\n    target = 3\n    return nums, target\n\nassert f(*g()) == 4\n",
        "idx_generation": 394,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given an array arr of integers, return a new array where each element is the sum of all the even numbers in arr that are greater than or equal to that element.\n\n    Example:\n    arr = [1, 2, 3, 4, 5, 6]\n    The even numbers greater than or equal to 1 are [2, 4, 6], their sum is 12.\n    The even numbers greater than or equal to 2 are [2, 4, 6], their sum is 12.\n    The even numbers greater than or equal to 3 are [4, 6], their sum is 10.\n    The even numbers greater than or equal to 4 are [4, 6], their sum is 10.\n    The even numbers greater than or equal to 5 are [6], their sum is 6.\n    The even numbers greater than or equal to 6 are [6], their sum is 6.\n\n    Therefore, the expected output is [12, 12, 10, 10, 6, 6].\n    \"\"\"\n    even_nums = [num for num in arr if num % 2 == 0]\n    result = []\n    for num in arr:\n        sum_even = sum(even for even in even_nums if even >= num)\n        result.append(sum_even)\n    return result\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g()) == [12, 12, 10, 10, 6, 6]\n",
        "idx_generation": 205,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there exists a subarray of the list whose sum is equal to the target.\n    \"\"\"\n    stack = []\n    for num in nums:\n        stack.append(num)\n        while sum(stack) > target:\n            stack.pop(0)\n        if sum(stack) == target:\n            return True\n    return False\n\ndef g():\n    nums = [3, 6, 9, 12, 15]\n    target = 18\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 42,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import Tuple\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all even numbers in the range from 1 to n (inclusive).\n\n    Sample Input:\n    n = 10\n\n    Sample Output:\n    30\n    \"\"\"\n    if n <= 0:\n        return 0\n    if n % 2 != 0:\n        return f(n-1)\n    return n + f(n-2)\n\ndef g():\n    return [10]\n\nassert f(*g()) == 30\n",
        "idx_generation": 81,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray.\n\n    Example:\n    Input: [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n\n    Explanation: The subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n    def max_subarray_sum(nums: List[int]) -> int:\n        if not nums:\n            return 0\n        max_sum = current_sum = nums[0]\n        for num in nums[1:]:\n            current_sum = max(num, current_sum + num)\n            max_sum = max(max_sum, current_sum)\n        return max_sum\n\n    return max_subarray_sum(nums)\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\n\nassert f(g()) == 6\n\n",
        "idx_generation": 293,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if they are isomorphic.\n\n    Two strings are isomorphic if the characters in s can be replaced to get t.\n\n    All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.\n\n    Args:\n    - s: The first string.\n    - t: The second string.\n\n    Returns:\n    - True if the two strings are isomorphic, False otherwise.\n\n    Example:\n    f(\"egg\", \"add\") returns True\n    f(\"foo\", \"bar\") returns False\n    \"\"\"\n\n    if len(s) != len(t):\n        return False\n\n    s_to_t = {}\n    t_to_s = {}\n\n    for i in range(len(s)):\n        if s[i] in s_to_t:\n            if s_to_t[s[i]] != t[i]:\n                return False\n        else:\n            s_to_t[s[i]] = t[i]\n\n        if t[i] in t_to_s:\n            if t_to_s[t[i]] != s[i]:\n                return False\n        else:\n            t_to_s[t[i]] = s[i]\n\n    return True\n\ndef g() -> Tuple[str, str]:\n    \"\"\"\n    Generate two strings.\n\n    Returns:\n    - The generated two strings.\n\n    Example:\n    g() returns (\"egg\", \"add\")\n    \"\"\"\n\n    return (\"egg\", \"add\")\n\nassert f(*g()) == True\n",
        "idx_generation": 406,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return a list of the same length where each element is the product of all elements in nums except the element at that index.\n\n    Sample Input:\n    nums = [1, 2, 3, 4]\n\n    Sample Output:\n    [24, 12, 8, 6]\n\n    Explanation:\n    The product of all elements in nums except the element at index 0 is 2 * 3 * 4 = 24.\n    The product of all elements in nums except the element at index 1 is 1 * 3 * 4 = 12.\n    The product of all elements in nums except the element at index 2 is 1 * 2 * 4 = 8.\n    The product of all elements in nums except the element at index 3 is 1 * 2 * 3 = 6.\n    \"\"\"\n\n    n = len(nums)\n    left_products = [1] * n\n    right_products = [1] * n\n    result = [1] * n\n\n    for i in range(1, n):\n        left_products[i] = left_products[i-1] * nums[i-1]\n\n    for i in range(n-2, -1, -1):\n        right_products[i] = right_products[i+1] * nums[i+1]\n\n    for i in range(n):\n        result[i] = left_products[i] * right_products[i]\n\n    return result\n\ndef g(nums: List[int] = [1, 2, 3, 4]) -> List[int]:\n    return nums\n\nassert f(g()) == [24, 12, 8, 6]\n\n",
        "idx_generation": 215,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all the even numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    Output:\n    30\n\n    Explanation:\n    The sum of the even numbers (2, 4, 6, 8, 10) in the list is 30.\n\n    Hint: Use list comprehension to filter the even numbers and then calculate the sum.\n    \"\"\"\n    return sum([num for num in nums if num % 2 == 0])\n\ndef g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]):\n    return nums\n\nassert f(g()) == 30\n\n",
        "idx_generation": 365,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(expression: str) -> bool:\n    \"\"\"\n    Check if the given arithmetic expression is balanced.\n    A balanced expression has matching opening and closing parentheses/brackets.\n    \"\"\"\n    stack = []\n    for char in expression:\n        if char in ['(', '[', '{']:\n            stack.append(char)\n        elif char in [')', ']', '}']:\n            if not stack:\n                return False\n            if char == ')' and stack[-1] == '(':\n                stack.pop()\n            elif char == ']' and stack[-1] == '[':\n                stack.pop()\n            elif char == '}' and stack[-1] == '{':\n                stack.pop()\n            else:\n                return False\n\n    return len(stack) == 0\n\ndef g(expression: str) -> str:\n    \"\"\"\n    Remove all the spaces from the given arithmetic expression.\n    \"\"\"\n    return expression.replace(\" \", \"\")\n\nexpression = \"(1 + 2) * 3 - {4 / [5 - 6]}\"\nassert f(g(expression))\n",
        "idx_generation": 354,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(prices: List[int]) -> int:\n    \"\"\"\n    Given a list of prices, find the maximum profit that can be obtained by buying and selling stocks.\n    You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).\n\n    Sample input:\n    prices = [7, 1, 5, 3, 6, 4]\n\n    Sample output:\n    7\n\n    Explanation: The maximum profit that can be obtained is 7 (buy at price 1 and sell at price 5, then buy at price 3 and sell at price 6).\n    \"\"\"\n\n    max_profit = 0\n\n    for i in range(1, len(prices)):\n        if prices[i] > prices[i-1]:\n            max_profit += prices[i] - prices[i-1]\n\n    return max_profit\n\ndef g(prices: List[int] = [7, 1, 5, 3, 6, 4]):\n    return (prices,)\n\nassert f(*g()) == 7\n\n",
        "idx_generation": 62,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and a target sum, find two numbers in the array that add up to the target.\n    The function should return the indices of the two numbers.\n\n    Args:\n    - nums: List of integers.\n    - target: Target sum.\n\n    Returns:\n    - List of indices of the two numbers that add up to the target.\n    \"\"\"\n\n    # Initialize a dictionary to store the complement of each number\n    complement_dict = {}\n\n    # Iterate through the array\n    for i, num in enumerate(nums):\n        # Check if the complement of the current number exists in the dictionary\n        if num in complement_dict:\n            # Return the indices of the two numbers\n            return [complement_dict[num], i]\n        else:\n            # Add the complement of the current number to the dictionary\n            complement_dict[target - num] = i\n\n    # If no solution is found, return an empty list\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 461,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string containing only the characters '(' and ')', determine if the input string is valid.\n    An input string is valid if:\n    1. Open brackets must be closed by the same type of brackets.\n    2. Open brackets must be closed in the correct order.\n    \n    Example:\n    s = \"()[]{}\"\n\n    Output:\n    True\n\n    Explanation:\n    The string is valid because the brackets are closed in the correct order.\n\n    Hint: Use a stack to keep track of the opening brackets. When a closing bracket is encountered, check if the\n    corresponding opening bracket is at the top of the stack.\n    \"\"\"\n    stack = []\n    brackets = {\n        ')': '(',\n        ']': '[',\n        '}': '{'\n    }\n    \n    for char in s:\n        if char in brackets.values():\n            stack.append(char)\n        elif char in brackets.keys():\n            if not stack or brackets[char] != stack.pop():\n                return False\n    \n    return len(stack) == 0\n\ndef g(s=\"()[]{}\"):\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 79,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of ways to climb to the top of a staircase.\n    You can climb either 1 or 2 steps at a time.\n\n    Example:\n    n = 3\n\n    Output:\n    3 (as there are 3 ways to climb to the top: 1+1+1, 1+2, 2+1)\n    \"\"\"\n    if n <= 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\ndef g() -> int:\n    n = 3\n    return n\n\nassert f(g()) == 3\n",
        "idx_generation": 459,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n    \"\"\"\n    max_xor = 0\n    \n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor_val = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor_val)\n    \n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of 5 integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 7\n\n",
        "idx_generation": 170,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "import random\nfrom typing import*\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Check if the target number is present in the grid.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    for i in range(rows):\n        if target in grid[i]:\n            return True\n    return False\n\ndef g(rows = 5, cols = 5, target = 10):\n    \"\"\"\n    Generate a grid with random numbers and the target number.\n    \"\"\"\n    import random\n    grid = [[random.randint(1, 20) for _ in range(cols)] for _ in range(rows)]\n    grid[random.randint(0, rows-1)][random.randint(0, cols-1)] = target\n    return grid\n\nassert f(g(), target=10)\n",
        "idx_generation": 40,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, determine the number of unique paths to reach the end\n    of an m x n grid from the top-left cell to the bottom-right cell.\n\n    You can only move down or right at any point in time.\n\n    Return the number of unique paths.\n\n    Example:\n    n = 3\n\n    Output:\n    6\n\n    Explanation:\n    There are 6 unique paths to reach the end of a 3 x 3 grid.\n    \"\"\"\n\n    def unique_paths(m, n, i, j, memo):\n        if i == m-1 and j == n-1:\n            return 1\n        if i >= m or j >= n:\n            return 0\n        if (i, j) in memo:\n            return memo[(i, j)]\n        memo[(i, j)] = unique_paths(m, n, i+1, j, memo) + unique_paths(m, n, i, j+1, memo)\n        return memo[(i, j)]\n\n    m = n\n    return unique_paths(m, n, 0, 0, {})\n\ndef g(n=3):\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    return n\n\nassert f(g()) == 6\n",
        "idx_generation": 66,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the minimum path sum from the top-left corner to the bottom-right corner.\n    The minimum path sum is the sum of all the numbers along the path with the smallest sum.\n    You can only move down or right at any point in time.\n\n    Return the minimum path sum.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n\n",
        "idx_generation": 488,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, words: List[str]) -> List[str]:\n    \"\"\"\n    Given a string and a list of words, find all words from the list that are present in the string.\n    Return a list of the matching words.\n    \"\"\"\n    matching_words = []\n    \n    for word in words:\n        if word in s:\n            matching_words.append(word)\n    \n    return matching_words\n\ndef g(s=\"hello world\", words=[\"hello\", \"hi\", \"world\"]):\n    return s, words\n\nassert f(*g()) == [\"hello\", \"world\"]\n\n",
        "idx_generation": 460,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, s: str) -> str:\n    \"\"\"\n    Given a positive integer n and a string s, find the lexicographically smallest subsequence of length n that can be formed from the characters of s.\n\n    Example:\n    n = 3\n    s = \"abcd\"\n\n    Output:\n    \"abc\"\n\n    Explanation:\n    The lexicographically smallest subsequence of length 3 that can be formed from the characters of \"abcd\" is \"abc\".\n    \"\"\"\n    stack = []\n    remaining = len(s)\n    \n    for i, char in enumerate(s):\n        while stack and stack[-1] > char and remaining - len(stack) >= n:\n            stack.pop()\n        \n        if len(stack) < n:\n            stack.append(char)\n            remaining -= 1\n        \n        if remaining == 0 or len(stack) == n:\n            break\n    \n    return ''.join(stack)\n\ndef g(n: int = 3, s: str = \"abcd\"):\n    return (n, s,)\n\nassert f(*g()) == \"abc\"\n\n",
        "idx_generation": 313,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n    \n    Output:\n    28\n    \"\"\"\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n    \n    return max_xor\n\ndef g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n\n",
        "idx_generation": 497,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"\n    Given a positive integer, count the number of set bits (1s) in its binary representation using recursion.\n\n    Example:\n    Input:\n    num = 10\n\n    Output:\n    2\n    \"\"\"\n\n    def count_set_bits(num: int) -> int:\n        if num == 0:\n            return 0\n        else:\n            return (num & 1) + count_set_bits(num >> 1)\n\n    return count_set_bits(num)\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return 10\n\nassert f(g()) == 2\n\n",
        "idx_generation": 343,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int]) -> int:\n    \"\"\"\n    Given a list of numbers, find the product of all the positive numbers in the list.\n    Return the product.\n\n    Example:\n    numbers = [2, -5, 3, -7, 4]\n\n    Output:\n    24 (2 * 3 * 4)\n\n    Hint: Iterate through the list and multiply all the positive numbers together.\n    \"\"\"\n\n    product = 1\n\n    for number in numbers:\n        if number > 0:\n            product *= number\n    \n    return product\n\ndef g() -> List[int]:\n    \"\"\"\n    Return a list of numbers.\n    \"\"\"\n    return [2, -5, 3, -7, 4]\n\nassert f(g()) == 24\n\n",
        "idx_generation": 472,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique paths in a grid of size n x n.\n    Each step, you can either move to the right or down.\n    \"\"\"\n    if n <= 1:\n        return 1\n    \n    dp = [[0] * n for _ in range(n)]\n    \n    # Base case\n    for i in range(n):\n        dp[i][0] = 1\n        dp[0][i] = 1\n    \n    # Dynamic programming approach\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[n-1][n-1]\n\ndef g(n: int):\n    return n\n\nassert f(g(3)) == 6\n\n",
        "idx_generation": 200,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(a: int, b: int) -> int:\n    \"\"\"\n    Given two integers a and b, count the number of bits that need to be flipped to convert a to b.\n\n    Example:\n    Input:\n    a = 7, b = 10\n\n    Output:\n    3\n    Explanation:\n    Flipping the bits of 7 (0111) to match 10 (1010) requires flipping 3 bits.\n    \"\"\"\n    xor_result = a ^ b\n    bit_count = 0\n    while xor_result != 0:\n        bit_count += xor_result & 1\n        xor_result >>= 1\n    return bit_count\n\ndef g() -> Tuple[int, int]:\n    return 7, 10\n\nassert f(*g()) == 3\n",
        "idx_generation": 170,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> List[int]:\n    \"\"\"\n    Given the root of a binary tree, return the inorder traversal of its nodes' values.\n    \"\"\"\n    result = []\n    stack = []\n    current = root\n\n    while current or stack:\n        while current:\n            stack.append(current)\n            current = current.left\n        current = stack.pop()\n        result.append(current.val)\n        current = current.right\n\n    return result\n\ndef g():\n    # Creating a binary tree\n    root = TreeNode(1)\n    root.right = TreeNode(2)\n    root.right.left = TreeNode(3)\n\n    return root\n\nassert f(g()) == [1, 3, 2]\n",
        "idx_generation": 118,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start='A', end='D') -> bool:\n    \"\"\"\n    Find a path from the start node to the end node in the given graph\n    \"\"\"\n    stack = [(start, [start])]\n    while stack:\n        node, path = stack.pop()\n        if node == end:\n            return True\n        for neighbor in graph[node]:\n            if neighbor not in path:\n                stack.append((neighbor, path + [neighbor]))\n    return False\n\ndef g(start='A', end='D'):\n    return {'A': ['B', 'C'], 'B': ['C', 'D'], 'C': ['D']}\n\nassert f(g()) == True\n",
        "idx_generation": 10,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the longest increasing subsequence (LIS) in the list.\n\n    Example:\n    nums = [10, 22, 9, 33, 21, 50, 41, 60, 80]\n    The longest increasing subsequence is [10, 22, 33, 50, 60, 80], which has a length of 6.\n    Return the length of the longest increasing subsequence.\n\n    Hint: Use dynamic programming to solve this problem.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g():\n    return [10, 22, 9, 33, 21, 50, 41, 60, 80]\n\nassert f(g()) == 6\n\n",
        "idx_generation": 477,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum path sum from the top-left corner to the bottom-right corner.\n\n    You can only move either down or right at any point in time.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum path sum from the top-left corner (1) to the bottom-right corner (1) is 7 (1 -> 3 -> 1 -> 1 -> 1).\n\n    Hint: Use dynamic programming and grid problems to solve this problem.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[rows - 1][cols - 1]\n\ndef g(grid=[\n    [1, 3, 1],\n    [1, 5, 1],\n    [4, 2, 1]\n]):\n    return grid\n\nassert f(g()) == 7\n\n",
        "idx_generation": 199,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the number of connected regions of 1s.\n\n    Example:\n    Input: grid = [[1, 1, 0, 0, 0],\n                   [0, 1, 0, 0, 1],\n                   [1, 0, 0, 1, 1],\n                   [0, 0, 0, 0, 0],\n                   [1, 0, 1, 0, 1]]\n    Output: 6\n    Explanation:\n    The grid contains 6 connected regions of 1s: [(0, 0), (0, 1)], [(1, 1)], [(2, 0)], [(2, 3), (2, 4)], [(4, 0)], [(4, 2)], [(4, 4)]\n    \"\"\"\n    def dfs(i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:\n            return\n        grid[i][j] = -1\n        dfs(i + 1, j)\n        dfs(i - 1, j)\n        dfs(i, j + 1)\n        dfs(i, j - 1)\n\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                count += 1\n                dfs(i, j)\n    return count\n\ndef g() -> List[List[int]]:\n    return [[1, 1, 0, 0, 0],\n            [0, 1, 0, 0, 1],\n            [1, 0, 0, 1, 1],\n            [0, 0, 0, 0, 0],\n            [1, 0, 1, 0, 1]]\n\nassert f(g()) == 6\n",
        "idx_generation": 467,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"\n    Given a string and a list of words, determine if the string can be segmented into a space-separated sequence of one or more words from the list.\n\n    Sample input:\n    s = \"applepenapple\"\n    words = [\"apple\", \"pen\"]\n\n    Sample output:\n    True\n\n    The string \"applepenapple\" can be segmented into \"apple pen apple\".\n    \"\"\"\n    def is_word_breakable(s: str, words: List[str], memo: List[bool]) -> bool:\n        if not s:\n            return True\n        if memo[len(s)] != -1:\n            return memo[len(s)]\n        for word in words:\n            if s.startswith(word) and is_word_breakable(s[len(word):], words, memo):\n                memo[len(s)] = True\n                return True\n        memo[len(s)] = False\n        return False\n\n    memo = [-1] * (len(s) + 1)\n    return is_word_breakable(s, words, memo)\n\ndef g():\n    return \"applepenapple\", [\"apple\", \"pen\"]\n\nassert f(*g()) == True\n",
        "idx_generation": 129,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Calculate the number of ways to choose m items from a set of n items without repetition and order.\n    \"\"\"\n    def factorial(n: int) -> int:\n        if n == 0 or n == 1:\n            return 1\n        return n * factorial(n - 1)\n\n    return factorial(n) // (factorial(m) * factorial(n - m))\n\ndef g():\n    \"\"\"\n    Generate the input values for the function f.\n    \"\"\"\n    return (5, 3)\n\nassert f(*g()) == 10\n",
        "idx_generation": 95,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the number of ways to arrange n pairs of parentheses in a valid combination.\n\n    Example:\n    n = 3\n\n    Output:\n    5\n\n    Explanation:\n    The valid combinations of arranging 3 pairs of parentheses are: \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\". There are 5 valid combinations.\n    \"\"\"\n    dp = [0] * (n+1)\n    dp[0] = 1\n    for i in range(1, n+1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i-j-1]\n    return dp[n]\n\ndef g(n=3):\n    return n\n\nassert f(g()) == 5\n\n",
        "idx_generation": 477,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three elements in the list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    24\n\n    Explanation:\n    The maximum product is 2 * 3 * 4 = 24.\n\n    Hint: Sort the list in ascending order and consider the cases where the maximum product involves negative numbers.\n    \"\"\"\n\n    nums.sort()\n\n    n = len(nums)\n\n    return max(nums[0] * nums[1] * nums[n - 1], nums[n - 3] * nums[n - 2] * nums[n - 1])\n\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [1, 2, 3, 4]\n    return nums\n\n\nassert f(g()) == 24\n",
        "idx_generation": 458,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, return True if the target value is present in the list, and False otherwise.\n    \"\"\"\n    low = 0\n    high = len(nums) - 1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    target = 7\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 281,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the given array that sum up to the target value.\"\"\"\n    arr.sort()\n    left, right = 0, len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr=[1, 2, 3, 4, 5], target=9):\n    return arr\n\nassert f(g(), 9) == True\n",
        "idx_generation": 91,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR subset sum.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The maximum XOR subset sum.\n    \"\"\"\n    def xor_subset_sum(nums: List[int], index: int, xor_sum: int) -> int:\n        if index == len(nums):\n            return xor_sum\n        else:\n            # Include current number in XOR sum\n            include_sum = xor_subset_sum(nums, index + 1, xor_sum ^ nums[index])\n            # Exclude current number from XOR sum\n            exclude_sum = xor_subset_sum(nums, index + 1, xor_sum)\n            # Return the maximum of the two sums\n            return max(include_sum, exclude_sum)\n\n    return xor_subset_sum(nums, 0, 0)\n\ndef g():\n    nums = [2, 5, 8, 10]\n    return nums\n\nassert f(g()) == 15\n",
        "idx_generation": 493,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value using binary search.\n    If the target value is not found, return -1.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(nums: List[int] = [1, 3, 5, 7, 9], target: int = 5):\n    return (nums, target)\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 153,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Find a pair of numbers from the list that add up to the target value.\"\"\"\n    stack = []\n    for num in nums:\n        if target - num in stack:\n            return True\n        stack.append(num)\n    return False\ndef g(nums=[2, 4, 6, 8, 10], target=14):\n    return nums, target\nassert f(*g())\n",
        "idx_generation": 195,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"\n    Check if the given string is a palindrome.\n    \"\"\"\n    return string == string[::-1]\n\ndef g(string: str) -> str:\n    \"\"\"\n    Return the longest palindrome substring of the given string.\n    \"\"\"\n    def expand_from_center(s: str, left: int, right: int) -> str:\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left+1:right]\n\n    longest_palindrome = \"\"\n    for i in range(len(string)):\n        # check for odd length palindromes\n        odd_palindrome = expand_from_center(string, i, i)\n        if len(odd_palindrome) > len(longest_palindrome):\n            longest_palindrome = odd_palindrome\n        # check for even length palindromes\n        even_palindrome = expand_from_center(string, i, i+1)\n        if len(even_palindrome) > len(longest_palindrome):\n            longest_palindrome = even_palindrome\n\n    return longest_palindrome\n\nstring = \"babad\"\nassert f(g(string))\n",
        "idx_generation": 158,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR value of any two elements in the array.\n\n    Sample Input:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Sample Output:\n    28\n\n    Explanation:\n    The maximum XOR value can be obtained by taking the XOR of 5 and 25, which gives 28.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            max_xor = max(max_xor, nums[i] ^ nums[j])\n\n    return max_xor\n\n\ndef g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n",
        "idx_generation": 141,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums, return True if there is a subarray of length 3 that forms an arithmetic progression.\n    Otherwise, return False.\n    \"\"\"\n    nums.sort()\n    for i in range(len(nums) - 2):\n        if nums[i+1] - nums[i] == nums[i+2] - nums[i+1]:\n            return True\n    return False\n\ndef g():\n    return [1, 3, 5, 2, 4, 6, 8]\n\nassert f(g()) == True\n",
        "idx_generation": 81,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of all the other elements except itself.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    [9, 8, 7, 6]\n\n    Explanation:\n    The sum of all the other elements except 1 is 2 + 3 + 4 = 9.\n    The sum of all the other elements except 2 is 1 + 3 + 4 = 8.\n    The sum of all the other elements except 3 is 1 + 2 + 4 = 7.\n    The sum of all the other elements except 4 is 1 + 2 + 3 = 6.\n\n    Hint: Use prefix and suffix sums.\n    \"\"\"\n\n    n = len(nums)\n    prefix_sum = [0] * n\n    suffix_sum = [0] * n\n\n    prefix_sum[0] = nums[0]\n    suffix_sum[n - 1] = nums[n - 1]\n\n    for i in range(1, n):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[i]\n\n    for i in range(n - 2, -1, -1):\n        suffix_sum[i] = suffix_sum[i + 1] + nums[i]\n\n    result = [prefix_sum[i - 1] + suffix_sum[i + 1] if i > 0 and i < n - 1 else prefix_sum[i - 1] if i > 0 else suffix_sum[i + 1] for i in range(n)]\n\n    return result\n\ndef g():\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == [9, 8, 7, 6]\n",
        "idx_generation": 173,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, determine if there are two numbers in the list that add up to the target.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5], target = 7\n    Output: True\n\n    Explanation: There are two numbers in the list, 2 and 5, that add up to the target 7.\n\n    Hint: Use two pointers to iterate through the list and check if the sum of the current pair of numbers is equal to the target.\n\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5], target=7):\n    return nums, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 486,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the length of the longest increasing path.\n    A path is considered increasing if each cell in the path is greater than the previous cell.\n\n    Example:\n    Input:\n    matrix = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n\n    Output:\n    4\n    Explanation:\n    The longest increasing path is [1, 2, 6, 9].\n    \"\"\"\n    def dfs(matrix: List[List[int]], i: int, j: int, memo: List[List[int]]) -> int:\n        if memo[i][j] != 0:\n            return memo[i][j]\n        \n        rows, cols = len(matrix), len(matrix[0])\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        maxPath = 1\n        \n        for dx, dy in directions:\n            x, y = i + dx, j + dy\n            if x >= 0 and x < rows and y >= 0 and y < cols and matrix[x][y] > matrix[i][j]:\n                maxPath = max(maxPath, 1 + dfs(matrix, x, y, memo))\n        \n        memo[i][j] = maxPath\n        \n        return maxPath\n    \n    rows, cols = len(matrix), len(matrix[0])\n    memo = [[0] * cols for _ in range(rows)]\n    maxLength = 0\n    \n    for i in range(rows):\n        for j in range(cols):\n            maxLength = max(maxLength, dfs(matrix, i, j, memo))\n    \n    return maxLength\n\ndef g() -> List[List[int]]:\n    return [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n\nassert f(g()) == 4\n",
        "idx_generation": 275,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum number of steps required to reach the bottom right cell from the top left cell,\n    moving only down or right.\n\n    Sample Input:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\n    Sample Output:\n    7\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[rows-1][cols-1]\n\ndef g():\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n    return (grid,)\n\nassert f(*g()) == 7\n\n",
        "idx_generation": 169,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a 2D matrix, return the elements of the matrix in spiral order.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    [1, 2, 3, 6, 9, 8, 7, 4, 5]\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return []\n    \n    m = len(matrix)\n    n = len(matrix[0])\n    top = 0\n    bottom = m - 1\n    left = 0\n    right = n - 1\n    result = []\n    \n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n        \n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n        \n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n        \n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n    \n    return result\n\ndef g():\n    return ([\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ])\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 210,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the sum of all multiples of 3 or 5 below n.\n    \"\"\"\n    sum = 0\n    for i in range(n):\n        if i % 3 == 0 or i % 5 == 0:\n            sum += i\n    return sum\n\ndef g() -> int:\n    n = 100\n    return n\n\nassert f(g()) == 2318\n",
        "idx_generation": 425,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string 's' containing only brackets ( '(', ')', '{', '}', '[', ']'), determine if the brackets are balanced. For every opening bracket, there must be a corresponding closing bracket of the same type.\n\n    Sample Input:\n    s = \"(([]))\"\n\n    Sample Output:\n    True\n    \"\"\"\n    stack = []\n    bracket_map = {\n        '(': ')',\n        '{': '}',\n        '[': ']'\n    }\n\n    for char in s:\n        if char in bracket_map:\n            stack.append(char)\n        elif char in bracket_map.values():\n            if not stack or bracket_map[stack.pop()] != char:\n                return False\n\n    return len(stack) == 0\n\ndef g(s: str = \"(([]))\"):\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 224,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n\n    Sample Input:\n    s = \"abcabcbb\"\n\n    Sample Output:\n    3 (the longest substring without repeating characters is \"abc\")\n    \"\"\"\n    max_length = 0\n    start = 0\n    seen = {}\n\n    for i in range(len(s)):\n        if s[i] in seen and start <= seen[s[i]]:\n            start = seen[s[i]] + 1\n        else:\n            max_length = max(max_length, i - start + 1)\n\n        seen[s[i]] = i\n\n    return max_length\n\ndef g():\n    return \"abcabcbb\"\n\nassert f(g()) == 3\n",
        "idx_generation": 143,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find if the given number is a power of two\"\"\"\n    if n <= 0:\n        return False\n    while n % 2 == 0:\n        n //= 2\n    return n == 1\n\ndef g(n = 16):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 13,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers 'nums' and an integer 'k', determine if there exists a subarray of length k in 'nums' with a sum divisible by k.\n\n    Sample Input:\n    nums = [4, 5, 7, 2, 8]\n    k = 3\n\n    Sample Output:\n    True\n    \"\"\"\n    prefix_sum = [0]\n\n    for num in nums:\n        prefix_sum.append((prefix_sum[-1] + num) % k)\n\n    seen = {}\n\n    for i, prefix in enumerate(prefix_sum):\n        if prefix in seen and i - seen[prefix] >= 2:\n            return True\n        elif prefix not in seen:\n            seen[prefix] = i\n\n    return False\n\ndef g(nums = [4, 5, 7, 2, 8], k = 3):\n    return nums, k\n\nassert f(*g())\n",
        "idx_generation": 81,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum using the Kadane's algorithm.\n    The maximum subarray sum is the sum of the contiguous subarray with the largest sum.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g():\n    nums = [-2, -3, 4, -1, -2, 1, 5, -3]\n    return nums\n\nassert f(g()) == 7\n\n",
        "idx_generation": 311,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target integer, find two numbers in the list that add up to the target.\n\n    Args:\n    - nums: A list of integers.\n    - target: The target integer.\n\n    Returns:\n    - A list of two numbers that add up to the target.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [2, 7]\n\n    Explanation:\n    The numbers 2 and 7 add up to the target value of 9.\n    \"\"\"\n\n    # Initialize a dictionary to store the complement of each number\n    complement_dict = {}\n\n    # Iterate through the list of integers\n    for num in nums:\n        # Calculate the complement\n        complement = target - num\n\n        # Check if the complement exists in the dictionary\n        if complement in complement_dict:\n            # Return the two numbers\n            return [complement_dict[complement], num]\n\n        # Add the number and its index to the dictionary\n        complement_dict[num] = num\n\n    return []\n\ndef g(nums: List[int] = [2, 7, 11, 15], target: int = 9) -> List[int]:\n    return nums, target\n\nassert f(*g()) == [2, 7]\n",
        "idx_generation": 218,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers 'nums' and an integer 'target',\n    find two numbers such that they add up to 'target'.\n\n    Return the indices of the two numbers in the array.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation:\n    The sum of nums[0] and nums[1] is 2 + 7 = 9, which is equal to the target.\n    The indices of the two numbers are 0 and 1.\n    \"\"\"\n    complement_map = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complement_map:\n            return [complement_map[complement], i]\n        complement_map[num] = i\n\n    return []\n\ndef g(nums = [2, 7, 11, 15], target = 9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 377,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Node:\n    def __init__(self, val: int):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef f(root: Node, target: int) -> List[int]:\n    \"\"\"\n    Given a binary tree and a target value, find all root-to-leaf paths where each path's sum equals the given target.\n\n    Example:\n    root = Node(5)\n    root.left = Node(4)\n    root.right = Node(8)\n    root.left.left = Node(11)\n    root.left.left.left = Node(7)\n    root.left.left.right = Node(2)\n    root.right.left = Node(13)\n    root.right.right = Node(4)\n    root.right.right.left = Node(5)\n    root.right.right.right = Node(1)\n    target = 22\n\n    Output:\n    [[5, 4, 11, 2], [5, 8, 4, 5]]\n    \"\"\"\n    result = []\n\n    def dfs(node: Node, path: List[int], path_sum: int):\n        if not node:\n            return\n\n        path.append(node.val)\n        path_sum += node.val\n\n        if not node.left and not node.right:\n            if path_sum == target:\n                result.append(path[:])\n\n        dfs(node.left, path, path_sum)\n        dfs(node.right, path, path_sum)\n\n        path.pop()\n        path_sum -= node.val\n\n    dfs(root, [], 0)\n    return result\n\ndef g() -> Node:\n    root = Node(5)\n    root.left = Node(4)\n    root.right = Node(8)\n    root.left.left = Node(11)\n    root.left.left.left = Node(7)\n    root.left.left.right = Node(2)\n    root.right.left = Node(13)\n    root.right.right = Node(4)\n    root.right.right.left = Node(5)\n    root.right.right.right = Node(1)\n    return root, 22\n\nassert f(*g()) == [[5, 4, 11, 2], [5, 8, 4, 5]]\n",
        "idx_generation": 397,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a subarray with a sum equal to 0.\n\n    Return True if such a subarray exists, False otherwise.\n\n    Example:\n    nums = [4, -2, -1, 1, 2, 3]\n\n    Output:\n    True\n\n    Explanation:\n    The subarray [4, -2, -1, 1, 2, 3] has a sum of 0.\n    \"\"\"\n    prefix_sum = 0\n    sum_set = set()\n\n    for num in nums:\n        prefix_sum += num\n\n        if prefix_sum == 0 or prefix_sum in sum_set:\n            return True\n\n        sum_set.add(prefix_sum)\n\n    return False\n\ndef g(nums=[4, -2, -1, 1, 2, 3]):\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 88,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the sum of all multiples of 3 or 5 below n.\n\n    Args:\n    n (int): The upper limit.\n\n    Returns:\n    int: The sum of all multiples of 3 or 5 below n.\n    \"\"\"\n    sum = 0\n    for i in range(n):\n        if i % 3 == 0 or i % 5 == 0:\n            sum += i\n    return sum\n\ndef g(n=10):\n    \"\"\"\n    Generate an integer for calculating the sum of all multiples of 3 or 5 below n.\n    \"\"\"\n    return (n,)\n\nassert f(*g()) == 23\n",
        "idx_generation": 461,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"Check if a given string is a palindrome using a stack\"\"\"\n    stack = []\n    for char in s:\n        stack.append(char)\n    \n    reversed_s = \"\"\n    while stack:\n        reversed_s += stack.pop()\n    \n    return s == reversed_s\n\ndef g(s=\"racecar\"):\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 86,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray such that no two elements in the subarray are adjacent.\n\n    Example:\n    nums = [2, 7, 9, 3, 1]\n\n    Output:\n    12 (as the maximum sum subarray is [2, 9, 1])\n\n    \"\"\"\n    if not nums:\n        return 0\n\n    n = len(nums)\n    if n == 1:\n        return nums[0]\n\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])\n\n    return dp[n - 1]\n\ndef g() -> List[int]:\n    nums = [2, 7, 9, 3, 1]\n    return (nums,)\n\nassert f(*g()) == 12\n",
        "idx_generation": 459,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of positive integers, find the maximum sum of non-adjacent elements in the list.\n    \"\"\"\n    if not nums:\n        return 0\n\n    n = len(nums)\n    if n == 1:\n        return nums[0]\n\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, n):\n        dp[i] = max(nums[i] + dp[i-2], dp[i-1])\n\n    return dp[-1]\n\ndef g():\n    nums = [1, 2, 3, 1, 5, 3]\n    return nums\n\nassert f(g()) == 9\n",
        "idx_generation": 204,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(points: List[Tuple[int, int]]) -> bool:\n    \"\"\"\n    Determine if the given list of points forms a convex polygon.\n    \"\"\"\n    def orientation(p, q, r):\n        value = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if value == 0:\n            return 0\n        elif value > 0:\n            return 1\n        else:\n            return 2\n\n    n = len(points)\n    if n < 3:\n        return False\n\n    prev = orientation(points[0], points[1], points[2])\n    for i in range(1, n):\n        curr = orientation(points[i], points[(i+1) % n], points[(i+2) % n])\n        if curr != prev:\n            return False\n        prev = curr\n\n    return True\n\ndef g():\n    return [(0, 0), (0, 1), (1, 1), (1, 0)]\n\nassert f(g()) == True\n",
        "idx_generation": 83,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Calculate the maximum sum of a path in a grid.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    # Create a 2D array to store the maximum sum at each cell\n    dp = [[0] * cols for _ in range(rows)]\n    \n    # Initialize the first row and column of the dp array\n    dp[0][0] = grid[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    # Calculate the maximum sum at each cell\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    # Return the maximum sum at the bottom right cell\n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 12\n",
        "idx_generation": 70,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> str:\n    \"\"\"\n    Given a positive integer n, return its binary representation as a string.\n\n    Example:\n    Input: 5\n    Output: \"101\"\n\n    Hint: Use the built-in bin() function to convert an integer to its binary representation.\n    \"\"\"\n    return bin(n)[2:]\n\ndef g() -> int:\n    return 5\n\nassert f(g()) == \"101\"\n",
        "idx_generation": 461,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if the parentheses in the given string are balanced.\n\n    Example:\n    s = \"((())())\"\n    Output:\n    True\n\n    Hint: Use a stack to keep track of the opening parentheses and check if the closing parentheses match the top of the stack.\n    \"\"\"\n\n    stack = []\n\n    for char in s:\n        if char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if len(stack) == 0:\n                return False\n            stack.pop()\n\n    return len(stack) == 0\n\ndef g() -> str:\n    return \"((())())\"\n\nassert f(g())\n",
        "idx_generation": 336,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(num: int, k: int) -> bool:\n    \"\"\"Check if a given number has its kth bit set to 1.\"\"\"\n    mask = 1 << (k - 1)\n    return (num & mask) != 0\n\ndef g(k: int) -> int:\n    return 2 ** (k - 1)\n\nassert f(g(3), 3) == True\n",
        "idx_generation": 34,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers 'nums' and a target integer 'target', check if it is possible to obtain the target\n    by performing the bitwise OR operation on a subset of 'nums' elements.\n\n    Return True if it is possible, otherwise return False.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    target = 7\n\n    Output:\n    True\n\n    Explanation:\n    The bitwise OR operation of [3, 4] gives 7, which is equal to the target.\n\n    \"\"\"\n\n    def dfs(index: int, curr: int) -> bool:\n        if curr == target:\n            return True\n        if index == len(nums):\n            return False\n\n        return dfs(index + 1, curr | nums[index]) or dfs(index + 1, curr)\n\n    return dfs(0, 0)\n\ndef g() -> tuple:\n    nums = [1, 2, 3, 4]\n    target = 7\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 404,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the number of unique spanning trees in a complete graph with n vertices.\n\n    Example:\n    Input: n = 4\n    Output: 16\n\n    Hint: Use Cayley's formula to calculate the number of spanning trees in a complete graph.\n    \"\"\"\n\n    return n ** (n - 2)\n\ndef g(n: int = 4) -> int:\n    \"\"\"\n    Generate the value of n for the function f.\n    \"\"\"\n    return n\n\nassert f(g()) == 16\n",
        "idx_generation": 475,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    Output: 29\n    Explanation: The maximum sum of a path is 1 + 4 + 7 + 8 + 9 = 29.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g()) == 29\n",
        "idx_generation": 270,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a power of two.\n    \n    Example:\n    n = 8\n    \n    Output:\n    True (since 8 is a power of two)\n    \"\"\"\n    if n <= 0:\n        return False\n    return n & (n - 1) == 0\n\ndef g():\n    return 8\n\nassert f(g()) == True\n",
        "idx_generation": 205,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if there exists a path from the top-left corner to the bottom-right corner,\n    where each step can only move to the right or down. However, some cells in the matrix are blocked and cannot be traversed.\n\n    Sample Input:\n    matrix = [\n        [1, 1, 1, 0],\n        [1, 0, 1, 1],\n        [1, 1, 0, 1],\n        [0, 1, 1, 1]\n    ]\n\n    Sample Output:\n    True\n\n    Explanation:\n    The path from (0, 0) to (3, 3) can be taken as (0, 0) -> (0, 1) -> (1, 1) -> (1, 2) -> (2, 2) -> (3, 2) -> (3, 3).\n    \"\"\"\n\n    def dfs(row: int, col: int) -> bool:\n        if row == len(matrix) - 1 and col == len(matrix[0]) - 1:\n            return True\n\n        if row < len(matrix) - 1 and matrix[row + 1][col] == 1 and dfs(row + 1, col):\n            return True\n\n        if col < len(matrix[0]) - 1 and matrix[row][col + 1] == 1 and dfs(row, col + 1):\n            return True\n\n        return False\n\n    return dfs(0, 0)\n\n\ndef g():\n    matrix = [\n        [1, 1, 1, 0],\n        [1, 0, 1, 1],\n        [1, 1, 0, 1],\n        [0, 1, 1, 1]\n    ]\n    return matrix\n\nassert f(g()) == True\n",
        "idx_generation": 141,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start: int, target: int) -> bool:\n    \"\"\"\n    Check if a path exists in a directed graph from the start node to the target node.\n    \n    - graph is a dictionary representing the graph where the keys are the nodes and the values are lists of\n      the nodes that can be reached from each key node.\n    - start is the starting node in the graph.\n    - target is the target node to reach.\n    \"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == target:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    return False\ndef g(graph = {1: [2, 3], 2: [4], 3: [4], 4: []}, start = 1, target = 4):\n    return graph, start, target\nassert f(*g())\n",
        "idx_generation": 12,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> int:\n    \"\"\"\n    Given a binary tree, calculate the sum of all the numbers formed by concatenating\n    the root-to-leaf paths.\n\n    Args:\n    - root: The root node of the binary tree.\n\n    Returns:\n    - The sum of all the numbers formed by concatenating the root-to-leaf paths.\n\n    Example:\n    Input:\n         1\n        / \\\n       2   3\n\n    Output: 25\n\n    Explanation:\n    The root-to-leaf paths are \"1->2\" and \"1->3\". The numbers formed by concatenating\n    these paths are 12 and 13 respectively. The sum of these numbers is 25.\n\n    Hint: Use a recursive helper function to traverse the tree and calculate the sum.\n    \"\"\"\n\n    def helper(node: TreeNode, path_sum: int) -> int:\n        if node is None:\n            return 0\n\n        path_sum = (path_sum * 10) + node.val\n\n        if node.left is None and node.right is None:\n            return path_sum\n\n        return helper(node.left, path_sum) + helper(node.right, path_sum)\n\n    return helper(root, 0)\n\ndef g() -> TreeNode:\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    return root\n\nassert f(g()) == 25\n",
        "idx_generation": 479,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: dict, start_node='A', end_node='E') -> bool:\n    \"\"\"\n    Given a graph represented as a dictionary and two nodes (start_node and end_node), find the shortest path\n    from start_node to end_node using Dijkstra's algorithm.\n    \"\"\"\n    distances = {node: float('inf') for node in graph}\n    distances[start_node] = 0\n    visited = set()\n    while True:\n        min_node = None\n        min_distance = float('inf')\n        for node in graph:\n            if node not in visited and distances[node] < min_distance:\n                min_node = node\n                min_distance = distances[node]\n        if min_node is None:\n            break\n        visited.add(min_node)\n        for neighbor, edge_distance in graph[min_node]:\n            new_distance = distances[min_node] + edge_distance\n            if new_distance < distances[neighbor]:\n                distances[neighbor] = new_distance\n    return distances[end_node] != float('inf')\n\ndef g(graph = {'A': [('B', 2), ('C', 3)],\n                'B': [('C', 1), ('D', 4)],\n                'C': [('D', 2)],\n                'D': [('E', 3)],\n                'E': []},\n       start_node = 'A',\n       end_node = 'E'):\n    return graph\nassert f(g()) == True\n",
        "idx_generation": 19,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, count the number of islands. An island is a group of connected 1s,\n    where a connection is defined as adjacent 1s horizontally or vertically.\n\n    Sample Input:\n    grid = [[1, 1, 0, 0, 0],\n            [1, 1, 0, 0, 0],\n            [0, 0, 1, 0, 0],\n            [0, 0, 0, 1, 1]]\n\n    Sample Output:\n    3\n    \"\"\"\n    def dfs(grid, i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:\n            return\n        grid[i][j] = -1\n        dfs(grid, i+1, j)\n        dfs(grid, i-1, j)\n        dfs(grid, i, j+1)\n        dfs(grid, i, j-1)\n\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                count += 1\n                dfs(grid, i, j)\n\n    return count\n\ndef g():\n    grid = [[1, 1, 0, 0, 0],\n            [1, 1, 0, 0, 0],\n            [0, 0, 1, 0, 0],\n            [0, 0, 0, 1, 1]]\n    return grid\n\nassert f(g()) == 3\n",
        "idx_generation": 242,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int], target=10) -> bool:\n    \"\"\"\n    Find the number of combinations of elements in the given array that sum up to the target value.\n    \"\"\"\n    def count_combinations(arr, target, i):\n        if target == 0:\n            return 1\n        if target < 0 or i >= len(arr):\n            return 0\n        include = count_combinations(arr, target - arr[i], i)\n        exclude = count_combinations(arr, target, i + 1)\n        return include + exclude\n    \n    return count_combinations(arr, target, 0) > 0\n\ndef g(target=10):\n    return [2, 3, 5, 6, 8, 9]\n\nassert f(g()) == True\n",
        "idx_generation": 3,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(string: str) -> str:\n    \"\"\"\n    Find the longest substring in the given string that contains only unique characters.\n    If multiple substrings have the same length, return the lexicographically smallest one.\n    \"\"\"\n    max_length = 0\n    max_substring = \"\"\n    \n    for i in range(len(string)):\n        seen = set()\n        substring = \"\"\n        \n        for j in range(i, len(string)):\n            if string[j] not in seen:\n                seen.add(string[j])\n                substring += string[j]\n            else:\n                break\n        \n        if len(substring) > max_length:\n            max_length = len(substring)\n            max_substring = substring\n        elif len(substring) == max_length:\n            max_substring = min(max_substring, substring)\n    \n    return max_substring\n\ndef g(string: str):\n    return string\n\nassert f(g(\"abcabcbb\")) == \"abc\"\n",
        "idx_generation": 130,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "import math\nfrom typing import*\ndef f(n: int, k=3) -> bool:\n    \"\"\"Find the number of ways to choose k items from a set of n items.\"\"\"\n    from math import comb\n    return comb(n, k) % 2 == 0\ndef g(n = 5, k = 3):\n    return n\nassert f(g()) == True\n",
        "idx_generation": 125,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n    If the target value is not found in the list, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output:\n    2\n\n    Explanation:\n    The target value 5 is found at index 2 in the list.\n\n    Hint: Use the binary search algorithm to divide the search space in half at each step.\n    \"\"\"\n\n    low = 0\n    high = len(nums) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1\n\n\ndef g():\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target\n\n\nassert f(*g()) == 2\n",
        "idx_generation": 458,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product that can be obtained by multiplying any three numbers from the list.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The maximum product of three numbers.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g():\n    nums = [-10, -3, 1, 2, 3, 4]\n    return nums\n\nassert f(g()) == 120\n\n",
        "idx_generation": 410,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers in ascending order, determine if there exists a pair of numbers that sum up to the target.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr = [1, 2, 3, 4, 5], target = 9):\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 105,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers in non-decreasing order and a target value,\n    return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\n    Example:\n    nums = [1, 3, 5, 6]\n    target = 5\n\n    Output:\n    2\n\n    Explanation:\n    The target value 5 is found in the array at index 2.\n\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left\n\ndef g(nums=[1, 3, 5, 6], target=5):\n    return nums, target\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 495,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list using the merge sort algorithm.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left = f(left)\n    right = f(right)\n\n    return merge(left, right)\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    merged = []\n    i = j = 0\n\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n\n    while i < len(left):\n        merged.append(left[i])\n        i += 1\n\n    while j < len(right):\n        merged.append(right[j])\n        j += 1\n\n    return merged\n\ndef g(arr: List[int] = [9, 6, 2, 5, 8, 1, 4, 7, 3]):\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return arr\n\nassert f(g()) == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n",
        "idx_generation": 203,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, check if it is a valid parentheses sequence.\n    \n    Example:\n    s = \"(([]))\"\n    \n    Output:\n    True (since \"(([]))\" is a valid parentheses sequence)\n    \"\"\"\n    stack = []\n    for c in s:\n        if c in '([{':\n            stack.append(c)\n        elif c in ')]}':\n            if not stack:\n                return False\n            if (c == ')' and stack[-1] != '(') or (c == ']' and stack[-1] != '[') or (c == '}' and stack[-1] != '{'):\n                return False\n            stack.pop()\n    return not stack\n\ndef g():\n    return \"(([]))\"\n\nassert f(g()) == True\n",
        "idx_generation": 205,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers and a target integer k, find the number of subarrays whose sum is divisible by k.\n\n    Args:\n    - nums: A list of integers.\n    - k: An integer representing the target value.\n\n    Returns:\n    - The number of subarrays whose sum is divisible by k.\n\n    Example:\n    nums = [4, 5, 0, -2, -3, 1]\n    k = 5\n\n    Output:\n    7\n\n    Explanation:\n    The subarrays whose sum is divisible by 5 are:\n    - [4, 5, 0, -2, -3, 1]\n    - [5, 0]\n    - [5, 0, -2, -3]\n    - [0, -2, -3, 1]\n    - [5, 0, -2]\n    - [0, -2, -3]\n    - [5, 0, -2, -3, 1]\n    \"\"\"\n\n    # Initialize a dictionary to store the remainder count\n    remainder_count = {0: 1}\n\n    # Initialize variables\n    prefix_sum = 0\n    count = 0\n\n    # Iterate through the list of integers\n    for num in nums:\n        # Calculate the prefix sum\n        prefix_sum = (prefix_sum + num) % k\n\n        # Check if the remainder exists in the dictionary\n        if prefix_sum in remainder_count:\n            # Increment the count by the value in the dictionary\n            count += remainder_count[prefix_sum]\n\n        # Increment the remainder count in the dictionary\n        remainder_count[prefix_sum] = remainder_count.get(prefix_sum, 0) + 1\n\n    return count\n\ndef g(nums: List[int] = [4, 5, 0, -2, -3, 1], k: int = 5) -> int:\n    return nums, k\n\nassert f(*g()) == 7\n",
        "idx_generation": 218,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Find the number that appears only once in a list of integers, where every other number appears twice.\n\n    Parameters:\n    nums (List[int]): A list of integers.\n\n    Returns:\n    int: The number that appears only once.\n    \"\"\"\n    result = 0\n    for num in nums:\n        result ^= num\n    return result\n\ndef g(nums=[2, 2, 1, 4, 4]):\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 155,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Find the median of the given list of numbers.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    if n % 2 == 0:\n        return (nums[n//2 - 1] + nums[n//2]) / 2\n    else:\n        return nums[n//2]\n\ndef g():\n    return [9, 5, 2, 7, 1, 6, 3]\n\nassert f(g()) == 5\n",
        "idx_generation": 83,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer 'n', calculate the nth Fibonacci number.\n\n    Example:\n    n = 6\n\n    Output:\n    8\n\n    Explanation:\n    The 6th Fibonacci number is 8.\n    The Fibonacci sequence starts with 0 and 1, and each subsequent number is the sum of the two preceding ones.\n    0, 1, 1, 2, 3, 5, 8, ...\n    \"\"\"\n\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n\n    fib = [0, 1]\n    for i in range(2, n+1):\n        fib.append(fib[i-1] + fib[i-2])\n    return fib[n]\n\ndef g():\n    n = 6\n    return n\n\nassert f(g()) == 8\n\n",
        "idx_generation": 239,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the shortest path from the top-left corner to the bottom-right corner,\n    while minimizing the sum of values along the path.\n\n    Example:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n    output: 7\n\n    Explanation:\n    The shortest path is 1 -> 3 -> 1 -> 1 -> 1, with a total sum of 7.\n\n    Constraints:\n    - The input grid will always have at least one cell.\n    - Each cell in the grid contains a non-negative integer.\n    \"\"\"\n    rows, cols = len(grid), len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[rows-1][cols-1]\n\ndef g():\n    return [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\nassert f(g()) == 7\n",
        "idx_generation": 294,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the number of islands. An island is a group of connected 1s formed by\n    horizontally or vertically adjacent 1s. You may assume all four edges of the grid are surrounded by water (0s).\n\n    Sample Input:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n\n    Sample Output:\n    3\n    Explanation: There are 3 islands in the grid.\n    \"\"\"\n    def dfs(i: int, j: int):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:\n            return\n\n        grid[i][j] = -1\n\n        dfs(i + 1, j)\n        dfs(i - 1, j)\n        dfs(i, j + 1)\n        dfs(i, j - 1)\n\n    count = 0\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                dfs(i, j)\n                count += 1\n\n    return count\n\ndef g():\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 3\n",
        "idx_generation": 223,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum path sum from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 7\n    Explanation: The minimum path sum is 1 + 3 + 1 + 1 + 1 = 7.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 270,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Given two integers n and k, determine if there exists a string of length n that contains\n    exactly k distinct characters.\n\n    Sample Input:\n    n = 6\n    k = 3\n\n    Sample Output:\n    True\n    \"\"\"\n    if n <= k:\n        return False\n\n    return True\n\ndef g(n=6, k=3):\n    return n, k\n\nassert f(*g()) == True\n",
        "idx_generation": 27,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the list.\n    \n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    \n    Output:\n    [0, 1]\n    \n    Explanation:\n    The numbers at indices 0 and 1 (2 and 7) add up to the target value of 9.\n    \"\"\"\n    \n    seen = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    \n    return []\n\ndef g():\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 477,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(pattern: str, string: str) -> bool:\n    \"\"\"\n    Given a pattern string and a target string, determine if the pattern can be matched to the target string.\n\n    The pattern string consists of lowercase English letters and the target string consists of lowercase English letters\n    separated by spaces. Each letter in the pattern string corresponds to a word in the target string.\n\n    Return True if the pattern can be matched to the target string, False otherwise.\n\n    Example:\n    pattern = \"abba\"\n    string = \"dog cat cat dog\"\n\n    Output:\n    True\n\n    Explanation:\n    The pattern \"abba\" can be matched to the string \"dog cat cat dog\" by assigning 'a' to \"dog\" and 'b' to \"cat\".\n    \"\"\"\n    words = string.split()\n    if len(pattern) != len(words):\n        return False\n    \n    char_to_word = {}\n    word_to_char = {}\n    \n    for char, word in zip(pattern, words):\n        if char in char_to_word:\n            if char_to_word[char] != word:\n                return False\n        else:\n            char_to_word[char] = word\n        \n        if word in word_to_char:\n            if word_to_char[word] != char:\n                return False\n        else:\n            word_to_char[word] = char\n    \n    return True\n\ndef g():\n    pattern = \"abba\"\n    string = \"dog cat cat dog\"\n    return pattern, string\n\nassert f(*g())\n",
        "idx_generation": 261,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find the maximum sum subarray (contiguous subsequence) within the list.\n    Return the subarray.\n\n    Sample input:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Sample output:\n    [4, -1, 2, 1]\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    start_index = 0\n    end_index = 0\n    current_start = 0\n\n    for i, num in enumerate(nums):\n        current_sum += num\n        if current_sum > max_sum:\n            max_sum = current_sum\n            start_index = current_start\n            end_index = i\n        if current_sum < 0:\n            current_sum = 0\n            current_start = i + 1\n\n    return nums[start_index:end_index+1]\n\ndef g():\n    return ([-2, 1, -3, 4, -1, 2, 1, -5, 4],)\n\nassert f(*g()) == [4, -1, 2, 1]\n",
        "idx_generation": 163,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the missing number. The list contains numbers from 0 to n, but\n    one number is missing.\n\n    Example:\n    nums = [0, 1, 3, 4, 5]\n\n    Output:\n    2 (since the number 2 is missing from the list)\n    \"\"\"\n    n = len(nums)\n    missing_sum = n * (n + 1) // 2\n    actual_sum = sum(nums)\n    return missing_sum - actual_sum\n\ndef g():\n    return [0, 1, 3, 4, 5]\n\nassert f(g()) == 2\n",
        "idx_generation": 41,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find if n is a prime number\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n",
        "idx_generation": 87,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray with length at most k.\n    \"\"\"\n    n = len(nums)\n    max_sum = 0\n    current_sum = 0\n    start = 0\n    k = 3\n\n    for i in range(n):\n        current_sum += nums[i]\n        if i - start + 1 > k:\n            current_sum -= nums[start]\n            start += 1\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == 27\n",
        "idx_generation": 332,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in the list that add up to the target. Return the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    output: [0, 1]\n    \"\"\"\n    complement_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complement_map:\n            return [complement_map[complement], i]\n        complement_map[num] = i\n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 263,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1 (2 and 7) add up to the target number 9.\n    \"\"\"\n\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n\n    return []\n\ndef g() -> List[int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return (nums, target)\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 443,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find the two numbers in the list that add up to the target value.\n    Return the indices of the two numbers as a list.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return (nums, target)\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 101,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the sum of the squares of the even numbers.\n\n    Args:\n    - nums: A list of integers\n\n    Returns:\n    - The sum of the squares of the even numbers.\n    \"\"\"\n    return sum([num**2 for num in nums if num % 2 == 0])\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]):\n    return nums\n\nassert f(g()) == 220\n\n",
        "idx_generation": 462,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string consisting of parentheses ('(' and ')'), determine the length of the longest valid parentheses substring.\n\n    Example:\n    f(\")()())\") returns 4, as the longest valid parentheses substring is \"()()\".\n\n    Note:\n    - The input string can contain characters other than parentheses.\n    - The input string can be empty.\n    \"\"\"\n\n    stack = []\n    max_length = 0\n    stack.append(-1)\n\n    for i in range(len(s)):\n        if s[i] == '(':\n            stack.append(i)\n        else:\n            stack.pop()\n            if len(stack) != 0:\n                max_length = max(max_length, i - stack[-1])\n            else:\n                stack.append(i)\n\n    return max_length\n\n\ndef g(s: str = \")()())\") -> str:\n    \"\"\"\n    Generate a string containing parentheses ('(' and ')').\n\n    Example:\n    g() returns \")()())\".\n\n    Note:\n    - The input string can contain characters other than parentheses.\n    - The input string can be empty.\n    \"\"\"\n\n    return s\n\n\nassert f(g()) == 4\n",
        "idx_generation": 99,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\n\n    Example:\n    Input: 3\n    Output: 6\n\n    Explanation:\n    The unique paths are: [\"RRR\", \"DRR\", \"DDR\", \"RDR\", \"RDD\", \"DDR\"]\n\n    Hint: Use dynamic programming to calculate the number of unique paths efficiently.\n    \"\"\"\n    def uniquePathsHelper(x, y, memo):\n        if x < 0 or y < 0:\n            return 0\n        if x == 0 and y == 0:\n            return 1\n        if memo[x][y] != -1:\n            return memo[x][y]\n        memo[x][y] = uniquePathsHelper(x - 1, y, memo) + uniquePathsHelper(x, y - 1, memo)\n        return memo[x][y]\n\n    memo = [[-1] * n for _ in range(n)]\n    return uniquePathsHelper(n - 1, n - 1, memo)\n\ndef g() -> int:\n    return 3\n\nassert f(g()) == 6\n",
        "idx_generation": 461,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"Find the nth number in the Fibonacci sequence using dynamic programming.\"\"\"\n    if n <= 1:\n        return n\n    \n    dp = [0] * (n+1)\n    dp[1] = 1\n    \n    for i in range(2, n+1):\n        dp[i] = dp[i-1] + dp[i-2]\n    \n    return dp[n]\n\ndef g():\n    n = 6\n\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 234,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]], target: int) -> Tuple[int, int]:\n    \"\"\"\n    Find the position of the target number in the given grid.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == target:\n                return i, j\n\n    return -1, -1\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]], 5\n\nassert f(*g()) == (1, 1)\n",
        "idx_generation": 83,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid represented by a list of lists of integers, find the minimum path sum from the top-left cell to the bottom-right cell using recursion and dynamic programming.\n    \"\"\"\n    def min_path_sum(grid, i, j):\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\n            return grid[i][j]\n        elif i == len(grid) - 1:\n            return grid[i][j] + min_path_sum(grid, i, j + 1)\n        elif j == len(grid[0]) - 1:\n            return grid[i][j] + min_path_sum(grid, i + 1, j)\n        else:\n            right_sum = grid[i][j] + min_path_sum(grid, i, j + 1)\n            down_sum = grid[i][j] + min_path_sum(grid, i + 1, j)\n            return min(right_sum, down_sum)\n    \n    return min_path_sum(grid, 0, 0)\n\ndef g(grid: List[List[int]] = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(g()) == 7\n\n",
        "idx_generation": 82,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of characters in each word within the string while still preserving whitespace and initial word order.\n\n    Example:\n    s = \"hello world\"\n\n    Output:\n    \"olleh dlrow\"\n\n    Explanation:\n    The word \"hello\" is reversed to \"olleh\" and the word \"world\" is reversed to \"dlrow\".\n\n    Hint: Split the string into words, reverse each word, and then join them back together.\n    \"\"\"\n\n    # Split the string into words by whitespace\n    words = s.split()\n\n    # Reverse each word using slicing and join them back together with whitespace\n    return ' '.join([word[::-1] for word in words])\n\ndef g():\n    s = \"hello world\"\n    return s\n\nassert f(g()) == \"olleh dlrow\"\n\n",
        "idx_generation": 462,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"\n    Check if a string s can be formed by concatenating words from a given list of words.\n\n    The words can be concatenated in any order and any word can be used multiple times.\n    \"\"\"\n\n    # Create a dictionary to store the frequency of each word\n    word_freq = {}\n    for word in words:\n        if word in word_freq:\n            word_freq[word] += 1\n        else:\n            word_freq[word] = 1\n\n    # Check if s can be formed by concatenating words\n    stack = [(\"\", s)]\n    while stack:\n        prefix, remaining = stack.pop()\n        if remaining == \"\":\n            return True\n        for word in words:\n            if remaining.startswith(word):\n                new_prefix = prefix + word\n                new_remaining = remaining[len(word):]\n                if word_freq[word] > 1:\n                    stack.append((new_prefix, new_remaining))\n                else:\n                    stack.append((new_prefix, new_remaining))\n\n    return False\n\ndef g(s: str = \"leetcode\", words: List[str] = [\"leet\", \"code\"]):\n    \"\"\"\n    Generate a string and a list of words that can form the string by concatenation.\n    \"\"\"\n    return s, words\n\nassert f(*g()) == True\n",
        "idx_generation": 358,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"Count the number of set bits in a given integer\"\"\"\n    count = 0\n    while num:\n        count += num & 1\n        num >>= 1\n    return count\n\ndef g():\n    num = 10\n    return (num,)\n\nassert f(*g()) == 2\n",
        "idx_generation": 41,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(a: int, b: int) -> int:\n    \"\"\"\n    Given two integers a and b, compute the bitwise XOR of all integers in the range [a, b].\n\n    Return the result.\n\n    Example:\n    a = 5\n    b = 8\n\n    Output:\n    12\n\n    Explanation:\n    The bitwise XOR of 5, 6, 7, and 8 is 12 (101 XOR 110 XOR 111 XOR 1000 = 1100).\n    \"\"\"\n\n    def xor_range(a: int, b: int) -> int:\n        result = 0\n        for i in range(a, b + 1):\n            result ^= i\n        return result\n\n    return xor_range(a, b)\n\ndef g(a: int, b: int):\n    \"\"\"\n    Generate two integers.\n    \"\"\"\n    return a, b\n\nassert f(*g(5, 8)) == 12\n\n",
        "idx_generation": 436,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> float:\n    \"\"\"\n    Given a list of 2D points, calculate the area of the triangle formed by three points.\n\n    Example:\n    points = [[0, 0], [3, 0], [0, 4]]\n\n    Output:\n    6.0\n\n    Explanation:\n    The points form a triangle with base 3 and height 4, resulting in an area of 6.\n    \"\"\"\n\n    # Function to calculate area of triangle given 3 points\n    def calculate_area(p1, p2, p3):\n        return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2)\n\n    # Extract points\n    p1, p2, p3 = points[0], points[1], points[2]\n\n    # Calculate area of triangle\n    area = calculate_area(p1, p2, p3)\n\n    return area\n\ndef g() -> List[List[int]]:\n    return [[0, 0], [3, 0], [0, 4]]\n\nassert f(g()) == 6.0\n",
        "idx_generation": 487,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of positive integers, find the maximum sum of a path starting from the top-left corner and ending at the bottom-right corner. You can only move down or right.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    Output:\n    1 + 4 + 7 + 8 + 9 = 29\n\n    Explanation:\n    The maximum sum path is 1 -> 4 -> 7 -> 8 -> 9, which gives a total sum of 29.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g():\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n    return grid\n\nassert f(g()) == 29\n\n",
        "idx_generation": 275,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(string: str) -> int:\n    \"\"\"\n    Given a string of digits, return the sum of all the digits squared.\n    \n    Sample Input:\n    string = \"12345\"\n    \n    Sample Output:\n    55\n    \"\"\"\n    total = 0\n    for digit in string:\n        num = int(digit)\n        total += math.pow(num, 2)\n    return int(total)\n\ndef g() -> str:\n    string = \"12345\"\n    return string\n\nassert f(g()) == 55\n\n",
        "idx_generation": 316,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR value of any two elements in the array.\n\n    Example:\n    f([3, 10, 5, 25, 2, 8]) returns 28, as the maximum XOR value is between 5 and 25 (5 XOR 25 = 28).\n\n    Note:\n    - The input array can contain duplicates.\n    - The input array can be empty.\n    \"\"\"\n\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n\n        for num in nums:\n            prefix_set.add(num & mask)\n\n        temp_max_xor = max_xor | (1 << i)\n\n        for prefix in prefix_set:\n            if temp_max_xor ^ prefix in prefix_set:\n                max_xor = temp_max_xor\n                break\n\n    return max_xor\n\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate an array of integers.\n\n    Example:\n    g() returns [3, 10, 5, 25, 2, 8]\n\n    Note:\n    - The generated array can contain duplicates.\n    - The generated array can be empty.\n    \"\"\"\n\n    return [3, 10, 5, 25, 2, 8]\n\n\nassert f(g()) == 28\n\n",
        "idx_generation": 209,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency matrix and two nodes, start and end,\n    check if there is a path from start to end in the graph.\n\n    Return True if there is a path, False otherwise.\n\n    Example:\n    graph = [[0, 1, 1, 0],\n             [1, 0, 0, 1],\n             [1, 0, 0, 0],\n             [0, 1, 0, 0]]\n    start = 0\n    end = 3\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 0 to node 3 in the graph.\n    \"\"\"\n\n    visited = set()\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n\n        if node == end:\n            return True\n\n        visited.add(node)\n\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] == 1 and neighbor not in visited:\n                stack.append(neighbor)\n\n    return False\n\ndef g(graph: List[List[int]], start: int, end: int) -> List[List[int]]:\n    \"\"\"\n    Modify the graph by adding an edge from start to end.\n\n    Return the modified graph.\n    \"\"\"\n\n    graph[start][end] = 1\n\n    return graph\n\ngraph = [[0, 1, 1, 0],\n         [1, 0, 0, 1],\n         [1, 0, 0, 0],\n         [0, 1, 0, 0]]\nstart = 0\nend = 3\n\nassert f(g(graph, start, end), start, end) == True\n",
        "idx_generation": 222,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: List[List[int]], start=0, end=3) -> bool:\n    \"\"\"Check if there exists a path from start to end in the given graph.\"\"\"\n    visited = [False] * len(graph)\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if not visited[node]:\n            visited[node] = True\n            stack.extend(graph[node])\n    return False\ndef g(graph = [[1, 2], [2], [3], []], start = 0, end = 3):\n    return graph\nassert f(g()) == True\n",
        "idx_generation": 15,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> int:\n    \"\"\"\n    Given a binary tree, find its maximum depth.\n\n    The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n    Example:\n    Input:\n        3\n       / \\\n      9  20\n        /  \\\n       15   7\n    Output: 3\n\n    Hint: Use depth-first search (DFS) to traverse the tree. Recursively calculate the depth of the left and right subtrees and return the maximum depth.\n    \"\"\"\n\n    if not root:\n        return 0\n\n    left_depth = f(root.left)\n    right_depth = f(root.right)\n\n    return max(left_depth, right_depth) + 1\n\ndef g():\n    root = TreeNode(3)\n    root.left = TreeNode(9)\n    root.right = TreeNode(20)\n    root.right.left = TreeNode(15)\n    root.right.right = TreeNode(7)\n    return root\n\nassert f(g()) == 3\n\n",
        "idx_generation": 484,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, determine if there exists a path from the start node \n    to the end node using a depth-first search algorithm.\n    - graph: directed graph represented as an adjacency matrix\n    - start: start node\n    - end: end node\n    \"\"\"\n\n    def dfs(node):\n        visited[node] = True\n        if node == end:\n            return True\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] and not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n        return False\n\n    visited = [False] * len(graph)\n    return dfs(start)\n\ndef g(graph=[[0, 1, 0, 1], [0, 0, 1, 0], [0, 0, 0, 1], [0, 0, 0, 0]]):\n    \"\"\"\n    Construct a directed graph represented as an adjacency matrix.\n    \"\"\"\n    return graph\n\nassert f(g(), start=0, end=3)\n",
        "idx_generation": 19,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given a grid of size n x m, where each cell represents the number of ways to reach that cell,\n    find the total number of unique paths from the top-left cell to the bottom-right cell.\n\n    You can only move down or right.\n\n    Example:\n    n = 3, m = 3\n\n    Output:\n    6\n\n    Explanation:\n    There are 6 unique paths to reach the bottom-right cell:\n    (0, 0) -> (1, 0) -> (2, 0) -> (2, 1) -> (2, 2)\n    (0, 0) -> (0, 1) -> (0, 2) -> (1, 2) -> (2, 2)\n    (0, 0) -> (0, 1) -> (1, 1) -> (2, 1) -> (2, 2)\n    (0, 0) -> (1, 0) -> (1, 1) -> (2, 1) -> (2, 2)\n    (0, 0) -> (1, 0) -> (1, 1) -> (1, 2) -> (2, 2)\n    (0, 0) -> (0, 1) -> (1, 1) -> (1, 2) -> (2, 2)\n    \"\"\"\n\n    dp = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n        dp[i][0] = 1\n\n    for j in range(m):\n        dp[0][j] = 1\n\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[n - 1][m - 1]\n\ndef g(n=3, m=3):\n    return n, m\n\nassert f(*g()) == 6\n\n",
        "idx_generation": 253,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there exists a subset of the list that adds up to the target number.\n    \"\"\"\n    def subset_sum(nums, target, index, current_sum):\n        if current_sum == target:\n            return True\n        if current_sum > target or index >= len(nums):\n            return False\n        return subset_sum(nums, target, index + 1, current_sum + nums[index]) or subset_sum(nums, target, index + 1, current_sum)\n\n    return subset_sum(nums, target, 0, 0)\n\ndef g(nums=[1, 3, 5, 7, 9], target=12):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 5,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> int:\n    \"\"\"\n    Given a list of words, find the longest word that can be formed by combining other words in the list.\n    - A word can only be formed by concatenating the other words in the list.\n    - The same word may be used multiple times to form the target word.\n    - If multiple words can be formed with the same length, return the word that occurs first in the list.\n\n    Example:\n    words = [\"cat\", \"banana\", \"dog\", \"nana\", \"walk\", \"walker\", \"dogwalker\"]\n\n    Output:\n    \"dogwalker\"\n\n    Explanation:\n    The word \"dogwalker\" can be formed by concatenating \"dog\" and \"walker\".\n\n    Hint: Use a recursive approach to check all possible combinations of words.\n    \"\"\"\n    def is_concatenation(word: str, word_list: List[str]) -> bool:\n        if word in word_list:\n            return True\n        for i in range(1, len(word)):\n            prefix = word[:i]\n            suffix = word[i:]\n            if prefix in word_list and is_concatenation(suffix, word_list):\n                return True\n        return False\n\n    longest_word = \"\"\n    for word in words:\n        if len(word) > len(longest_word) and is_concatenation(word, words):\n            longest_word = word\n\n    return longest_word\n\ndef g(words: List[str] = [\"cat\", \"banana\", \"dog\", \"nana\", \"walk\", \"walker\", \"dogwalker\"]):\n    return words\n\nassert f(g()) == \"dogwalker\"\n",
        "idx_generation": 168,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, find the number of k-combinations from a set of n elements.\n    \"\"\"\n    def factorial(num):\n        if num == 0 or num == 1:\n            return 1\n        else:\n            return num * factorial(num - 1)\n    \n    return factorial(n) // (factorial(k) * factorial(n - k))\n\ndef g() -> Tuple[int, int]:\n    \"\"\"\n    Generate two integers n and k.\n    \"\"\"\n    n = 6\n    k = 3\n    return n, k\n\nassert f(*g()) == 20\n",
        "idx_generation": 132,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of distinct integers and a target value, return the index if the target is found.\n    If not, return the index where it would be if it were inserted in order.\n\n    Example:\n    arr = [1, 3, 5, 6]\n    target = 5\n\n    Output:\n    2 (as the target is found at index 2)\n\n    Example:\n    arr = [1, 3, 5, 6]\n    target = 2\n\n    Output:\n    1 (as the target would be inserted at index 1)\n\n    \"\"\"\n    left, right = 0, len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left\n\ndef g() -> List[int]:\n    arr = [1, 3, 5, 6]\n    target = 5\n    return (arr, target)\n\nassert f(*g()) == 2\n",
        "idx_generation": 459,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix, rotate it 90 degrees clockwise in-place.\n    \"\"\"\n    def rotate(matrix: List[List[int]], n: int) -> None:\n        for i in range(n // 2):\n            for j in range(i, n - i - 1):\n                temp = matrix[i][j]\n                matrix[i][j] = matrix[n - 1 - j][i]\n                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j]\n                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i]\n                matrix[j][n - 1 - i] = temp\n\n    n = len(matrix)\n    rotate(matrix, n)\n    return matrix\n\ndef g():\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 421,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there exists a pair of distinct numbers in the list\n    whose sum equals the given target value.\n    \"\"\"\n    n = len(arr)\n    left = 0\n    right = n - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), 11)\n",
        "idx_generation": 121,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list\n    using binary search. If the target value is not present in the list, return -1.\n\n    Example:\n    Input: nums = [1, 3, 5, 7, 9], target = 5\n    Output: 2\n    Explanation:\n    The target value 5 is present at index 2 in the list.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    return ([1, 3, 5, 7, 9], 5)\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 495,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of heights representing the height of bars in a histogram, find the largest rectangle that can be formed by the bars.\n\n    Example:\n    heights = [2, 1, 5, 6, 2, 3]\n\n    Output:\n    10 (largest rectangle can be formed by the bars with heights [5, 6, 2])\n    \"\"\"\n    n = len(heights)\n    stack = []\n    max_area = 0\n\n    for i in range(n):\n        while stack and heights[stack[-1]] >= heights[i]:\n            height = heights[stack.pop()]\n            width = i if not stack else i - stack[-1] - 1\n            area = height * width\n            max_area = max(max_area, area)\n        stack.append(i)\n\n    while stack:\n        height = heights[stack.pop()]\n        width = n if not stack else n - stack[-1] - 1\n        area = height * width\n        max_area = max(max_area, area)\n\n    return max_area\n\ndef g():\n    heights = [2, 1, 5, 6, 2, 3]\n    return heights\n\nassert f(g()) == 10\n",
        "idx_generation": 247,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, return a list of indices of two\n    elements in the list that add up to the target. If there are multiple solutions,\n    return any one of them.\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(i+1, n):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 206,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"\n    Given a string s and an integer k, determine if it is possible to divide the string into k equal parts such that each part is a palindrome.\n    \"\"\"\n    return helper(s, k, 0, len(s)-1)\n\ndef helper(s: str, k: int, start: int, end: int) -> bool:\n    if k == 1:\n        return is_palindrome(s, start, end)\n    if k > len(s):\n        return False\n\n    for i in range(start, end):\n        if is_palindrome(s, start, i):\n            if helper(s, k-1, i+1, end):\n                return True\n    return False\n\ndef is_palindrome(s: str, start: int, end: int) -> bool:\n    while start < end:\n        if s[start] != s[end]:\n            return False\n        start += 1\n        end -= 1\n    return True\n\ndef g(s: str, k: int) -> str:\n    \"\"\"\n    Generate a string with k palindromic substrings.\n    \"\"\"\n    return s * k\n\nassert f(g(\"abcd\", 2), 2) == False\n",
        "idx_generation": 264,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there exists a pair of distinct numbers in the list\n    whose bitwise XOR equals the given target value. Use binary search to optimize the solution.\n    \"\"\"\n    def binary_search(arr: List[int], target: int) -> bool:\n        low = 0\n        high = len(arr) - 1\n\n        while low <= high:\n            mid = (low + high) // 2\n            if arr[mid] == target:\n                return True\n            elif arr[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n\n        return False\n\n    n = len(arr)\n    for i in range(n):\n        if binary_search(arr, arr[i] ^ target):\n            return True\n\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), 6)\n",
        "idx_generation": 157,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a perfect square.\n\n    Sample Input:\n    n = 16\n\n    Sample Output:\n    True\n    \"\"\"\n    if n == 0:\n        return False\n\n    left = 1\n    right = n\n\n    while left <= right:\n        mid = left + (right - left) // 2\n        square = mid * mid\n\n        if square == n:\n            return True\n        elif square < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\ndef g(n=16):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 92,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine if a number n is a perfect square\"\"\"\n    def is_perfect_square(n):\n        if n < 0:\n            return False\n        if n == 0:\n            return True\n        left, right = 1, n\n        while left <= right:\n            mid = left + (right - left) // 2\n            square = mid * mid\n            if square == n:\n                return True\n            elif square < n:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False\n\n    return is_perfect_square(n)\n\ndef g():\n    n = 16\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 245,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given an m x n matrix filled with non-negative integers, find the number of unique paths from the top-left corner to the bottom-right corner. Each movement can only go either down or right.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n    \n    for i in range(m):\n        for j in range(n):\n            if i == 0 or j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    return [[1, 1, 1], [1, 2, 1], [1, 1, 1]]\n\nassert f(g()) == 6\n",
        "idx_generation": 300,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or to the right.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    1 + 4 + 7 + 8 + 9 = 29\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g()) == 29\n",
        "idx_generation": 237,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell. You can only move down or right.\n\n    Args:\n    - grid: A 2D grid of integers.\n\n    Returns:\n    - The maximum sum of a path from the top-left cell to the bottom-right cell.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g(grid=[[1,3,1],[1,5,1],[4,2,1]]):\n    return grid\n\nassert f(g()) == 12\n\n",
        "idx_generation": 383,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Determine if a given list of integers is a permutation.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return False\n    nums.sort()\n    for i in range(n):\n        if nums[i] != i + 1:\n            return False\n    return True\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers that is a permutation.\n    \"\"\"\n    return [i + 1 for i in range(5)]\n\nassert f(g()) == True\n",
        "idx_generation": 116,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Given two integers n and k, determine if it is possible to write n as a sum of k distinct positive integers.\n\n    Return True if it is possible, False otherwise.\n\n    Example:\n    n = 10\n    k = 3\n\n    Output:\n    True\n\n    Explanation:\n    The sum of 1, 2, and 7 is equal to 10, and these numbers are distinct.\n    \"\"\"\n    def count_distinct_sums(n, k):\n        dp = [[0] * (n + 1) for _ in range(k + 1)]\n        dp[0][0] = 1\n\n        for i in range(1, k + 1):\n            for j in range(i, n + 1):\n                dp[i][j] = dp[i][j - i] + dp[i - 1][j - 1]\n\n        return dp[k][n] > 0\n\n    return count_distinct_sums(n, k)\n\ndef g(n = 10, k = 3):\n    return n, k\n\nassert f(*g())\n",
        "idx_generation": 6,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target integer, return True if there are two numbers in the list that sum up to the target.\n\n    Example:\n    arr = [2, 4, 6, 8]\n    target = 10\n    Output: True\n    \"\"\"\n\n    seen = set()\n    for num in arr:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate the input for the function f.\n    \"\"\"\n    return ([2, 4, 6, 8], 10)\n\nassert f(*g()) == True\n\n",
        "idx_generation": 354,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of all the even numbers in the original list up to that index.\n\n    Sample input:\n    nums = [1, 2, 3, 4, 5, 6]\n\n    Sample output:\n    [0, 2, 2, 6, 6, 12]\n\n    Explanation: The sum of all the even numbers in the original list up to index 0 is 0. Up to index 1 is 2. Up to index 2 is 2. Up to index 3 is 6. Up to index 4 is 6. Up to index 5 is 12.\n    \"\"\"\n\n    even_sum = 0\n    result = []\n\n    for num in nums:\n        if num % 2 == 0:\n            even_sum += num\n        result.append(even_sum)\n\n    return result\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5, 6]):\n    return (nums,)\n\nassert f(*g()) == [0, 2, 2, 6, 6, 12]\n\n",
        "idx_generation": 181,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, ans: List[int]) -> bool:\n    \"\"\"Check if ans contains all the prime numbers up to n\"\"\"\n    primes = []\n    for i in range(2, n+1):\n        is_prime = True\n        for j in range(2, int(i**0.5)+1):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    primes.sort()\n    return primes == ans\ndef g(n=20):\n    primes = []\n    for i in range(2, n+1):\n        is_prime = True\n        for j in range(2, int(i**0.5)+1):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\nassert f(n=20, ans=g())\n",
        "idx_generation": 42,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum using the Kadane's algorithm.\n    A subarray is a contiguous subsequence of the original array.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 132,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return a new list where each element is the product of all the elements in nums except the corresponding element.\n    The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer without overflowing.\n    You must write an algorithm that runs in O(n) time and without using the division operation.\n    \"\"\"\n\n    n = len(nums)\n    output = [1] * n\n    left_product = 1\n    right_product = 1\n\n    for i in range(n):\n        output[i] *= left_product\n        left_product *= nums[i]\n\n    for i in range(n - 1, -1, -1):\n        output[i] *= right_product\n        right_product *= nums[i]\n\n    return output\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == [120, 60, 40, 30, 24]\n\n",
        "idx_generation": 340,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a valid palindrome by deleting at most one character.\n\n    Example:\n    Input:\n    s = \"abca\"\n\n    Output:\n    True\n\n    Explanation:\n    By deleting 'b', the string becomes \"aca\" which is a valid palindrome.\n    \"\"\"\n\n    def is_palindrome(left, right):\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n\n    left = 0\n    right = len(s) - 1\n\n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(left + 1, right) or is_palindrome(left, right - 1)\n        left += 1\n        right -= 1\n\n    return True\n\ndef g():\n    \"\"\"\n    Generate a string with the following structure:\n    \"abca\"\n    \"\"\"\n    return \"abca\"\n\nassert f(g()) == True\n",
        "idx_generation": 284,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome after removing exactly one character.\n    \"\"\"\n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    for i in range(len(s)):\n        temp = s[:i] + s[i+1:]\n        if is_palindrome(temp):\n            return True\n    return False\n\ndef g():\n    s = \"level\"\n    return s\n\nassert f(g())\n",
        "idx_generation": 495,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    start = 0\n    end = 0\n    n = len(nums)\n    \n    for i in range(n):\n        if curr_sum <= 0:\n            curr_sum = nums[i]\n            start = i\n        else:\n            curr_sum += nums[i]\n            \n        if curr_sum > max_sum:\n            max_sum = curr_sum\n            end = i\n            \n    return nums[start:end+1]\n\ndef g() -> List[int]:\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == [4, -1, 2, 1]\n",
        "idx_generation": 105,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the sum of the elements in the diagonal from top-left to bottom-right.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    15\n\n    Explanation:\n    The diagonal elements are 1, 5, and 9. Their sum is 15.\n\n    Hint: Use the mathematical property that the row and column indices of the diagonal elements are the same (i.e., matrix[i][i]).\n    \"\"\"\n\n    diagonal_sum = 0\n\n    for i in range(len(matrix)):\n        diagonal_sum += matrix[i][i]\n\n    return diagonal_sum\n\ndef g(matrix: List[List[int]] = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix\n\nassert f(g()) == 15\n",
        "idx_generation": 462,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Reverse a given string using a stack.\n    \"\"\"\n    stack = []\n    for char in s:\n        stack.append(char)\n    reversed_str = \"\"\n    while stack:\n        reversed_str += stack.pop()\n    return reversed_str\n\ndef g(s=\"hello\"):\n    return s\n\nassert f(g()) == \"olleh\"\n\n",
        "idx_generation": 113,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum sum of a subarray where the subarray must contain at least one positive integer.\n    The function should return the maximum sum.\n\n    Args:\n    - arr: List of integers.\n\n    Returns:\n    - The maximum sum of a subarray.\n    \"\"\"\n\n    # Initialize variables\n    max_sum = 0\n    current_sum = 0\n\n    # Iterate through the array\n    for num in arr:\n        # If the current sum becomes negative, reset it to 0\n        if current_sum < 0:\n            current_sum = 0\n        # Add the current number to the current sum\n        current_sum += num\n        # Update the maximum sum if the current sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n\n    return max_sum\n\ndef g():\n    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return arr\n\nassert f(g()) == 6\n\n",
        "idx_generation": 461,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the n-th Fibonacci number using dynamic programming.\"\"\"\n    if n <= 1:\n        return n\n    fib = [0] * (n + 1)\n    fib[1] = 1\n    for i in range(2, n + 1):\n        fib[i] = fib[i - 1] + fib[i - 2]\n    return fib[n]\ndef g():\n    n = 6\n    return n\nassert f(g()) == 8\n",
        "idx_generation": 247,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the sum of all the elements in a 2D grid using grid-related problems.\"\"\"\n    return sum(sum(row) for row in grid)\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"Multiply all elements in the 2D grid by 2 using grid-related problems.\"\"\"\n    return [[2 * element for element in row] for row in grid]\n\nassert f(g([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) == 90\n",
        "idx_generation": 101,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid represented as a 2D list of integers,\n    find the minimum distance from the top-left cell to the bottom-right cell.\n    Return the minimum distance.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n            \n    return dp[m-1][n-1]\n\ndef g(grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 87,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, check if it is a palindrome.\n\n    Example:\n    s = \"racecar\"\n\n    Output:\n    True\n    \"\"\"\n    # Remove all non-alphanumeric characters from the string\n    s = ''.join(c.lower() for c in s if c.isalnum())\n\n    # Check if the string is equal to its reverse\n    return s == s[::-1]\n\ndef g():\n    return \"racecar\"\n\nassert f(g()) == True\n",
        "idx_generation": 464,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nclass Stack:\n    def __init__(self):\n        self.stack = []\n\n    def push(self, val: int) -> None:\n        \"\"\"\n        Pushes the given value onto the stack.\n        \"\"\"\n        self.stack.append(val)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes and returns the topmost value from the stack.\n        \"\"\"\n        return self.stack.pop()\n\n    def top(self) -> int:\n        \"\"\"\n        Returns the topmost value from the stack without removing it.\n        \"\"\"\n        return self.stack[-1]\n\n    def is_empty(self) -> bool:\n        \"\"\"\n        Returns True if the stack is empty, False otherwise.\n        \"\"\"\n        return len(self.stack) == 0\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome by using a stack.\n    Return True if s is a palindrome, False otherwise.\n    \"\"\"\n    stack = Stack()\n    for c in s:\n        stack.push(c)\n\n    reversed_s = \"\"\n    while not stack.is_empty():\n        reversed_s += stack.pop()\n\n    return s == reversed_s\n\ndef g(s = \"madam\"):\n    \"\"\"\n    Return the input string.\n    \"\"\"\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 380,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a given string is a palindrome.\"\"\"\n    i, j = 0, len(s) - 1\n    while i < j:\n        if s[i] != s[j]:\n            return False\n        i += 1\n        j -= 1\n    return True\n\ndef g():\n    return \"racecar\"\n\nassert f(g()) == True\n",
        "idx_generation": 20,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a number is a power of 2 using bit manipulation.\"\"\"\n    return n & (n-1) == 0\ndef g():\n    return 16\nassert f(g()) == True\n",
        "idx_generation": 48,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num1: int, num2: int) -> int:\n    \"\"\"Calculate the product of two numbers using recursion and bit manipulation.\n\n    Sample Input:\n    num1 = 4\n    num2 = 5\n\n    Sample Output:\n    20\n    \"\"\"\n    if num2 == 0:\n        return 0\n    if num2 % 2 == 0:\n        return (f(num1, num2 // 2) << 1)\n    else:\n        return (f(num1, num2 // 2) << 1) + num1\n\ndef g(num1=4, num2=5):\n    return num1, num2\n\nassert f(*g()) == 20\n",
        "idx_generation": 438,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Count the number of digits in the factorial of a given number n.\n    \"\"\"\n    count = 0\n    factorial = 1\n\n    for i in range(1, n + 1):\n        factorial *= i\n\n    while factorial > 0:\n        count += 1\n        factorial //= 10\n\n    return count\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 3\n",
        "idx_generation": 488,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum you can obtain by starting at the top-left cell and moving only right or down to the bottom-right cell.\n\n    Example:\n    Input: grid = [[1, 3, 1],\n                    [1, 5, 1],\n                    [4, 2, 1]]\n    Output: 12\n\n    Explanation: The maximum sum path is 1 -> 3 -> 5 -> 2 -> 1, which gives a total sum of 12.\n\n    Hint: Use dynamic programming to store the maximum sum at each cell.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g():\n    return [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\nassert f(g()) == 12\n",
        "idx_generation": 372,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> str:\n    \"\"\"\n    Given a string s and an integer n, rotate the string to the right by n positions.\n\n    Example:\n    s = \"abcdefg\"\n    n = 3\n\n    Output:\n    \"efgabcd\"\n\n    Explanation:\n    The string is rotated to the right by 3 positions, resulting in \"efgabcd\".\n    \"\"\"\n    if n == 0:\n        return s\n\n    n = n % len(s)\n    rotated = s[-n:] + s[:-n]\n    return rotated\n\ndef g(s=\"abcdefg\", n=3):\n    return s, n\n\nassert f(*g()) == \"efgabcd\"\n",
        "idx_generation": 472,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given integer is a power of two.\"\"\"\n    return n > 0 and (n & (n - 1)) == 0\n\ndef g():\n    n = 16\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 224,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Dict\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency list and two nodes start and end,\n    check if there is a path from start to end in the graph.\n\n    Example:\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D'],\n        'D': ['E'],\n        'E': []\n    }\n    start = 'A'\n    end = 'E'\n\n    Output:\n    True\n    \"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g() -> Tuple[Dict[str, List[str]], str, str]:\n    \"\"\"\n    Generate a directed graph represented as an adjacency list and two nodes start and end.\n    \"\"\"\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D'],\n        'D': ['E'],\n        'E': []\n    }\n    start = 'A'\n    end = 'E'\n    return graph, start, end\n\nassert f(*g())\n",
        "idx_generation": 264,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: dict, start='A', end='E') -> bool:\n    \"\"\"Find if there is a path from the start node to the end node in a given graph.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g():\n    graph = {'A': ['B', 'C'],\n             'B': ['D', 'E'],\n             'C': ['F'],\n             'D': [],\n             'E': [],\n             'F': []}\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 25,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Graph:\n    def __init__(self, num_vertices: int):\n        self.num_vertices = num_vertices\n        self.adj_list = [[] for _ in range(num_vertices)]\n    \n    def add_edge(self, u: int, v: int):\n        self.adj_list[u].append(v)\n    \n    def is_cyclic_util(self, v: int, visited: List[bool], stack: List[bool]) -> bool:\n        visited[v] = True\n        stack[v] = True\n        \n        for neighbor in self.adj_list[v]:\n            if not visited[neighbor]:\n                if self.is_cyclic_util(neighbor, visited, stack):\n                    return True\n            elif stack[neighbor]:\n                return True\n        \n        stack[v] = False\n        return False\n    \n    def is_cyclic(self) -> bool:\n        visited = [False] * self.num_vertices\n        stack = [False] * self.num_vertices\n        \n        for v in range(self.num_vertices):\n            if not visited[v]:\n                if self.is_cyclic_util(v, visited, stack):\n                    return True\n        \n        return False\n\ndef f(edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given a list of directed edges, check if the graph contains a cycle.\n    \"\"\"\n    num_vertices = max(max(edge) for edge in edges) + 1\n    graph = Graph(num_vertices)\n    \n    for edge in edges:\n        u, v = edge\n        graph.add_edge(u, v)\n    \n    return graph.is_cyclic()\n\ndef g():\n    edges = [[0, 1], [1, 2], [2, 0]]\n    return edges\n\nassert f(g()) == True\n\n",
        "idx_generation": 491,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], source: int, target: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency list and two vertices, source and target,\n    determine if there is a path from source to target in the graph.\n\n    Sample Input:\n    graph = [[1, 2], [2], [3], [0]]\n    source = 0\n    target = 2\n\n    Sample Output:\n    True\n    \"\"\"\n    visited = set()\n    stack = [source]\n\n    while stack:\n        node = stack.pop()\n        visited.add(node)\n\n        if node == target:\n            return True\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    \n    return False\n\ndef g(graph=[[1, 2], [2], [3], [0]], source=0, target=2):\n    return graph, source, target\n\nassert f(*g()) == True\n",
        "idx_generation": 24,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers representing a maze, find the minimum number of steps required to reach the bottom-right corner of the maze from the top-left corner. Each cell in the grid represents a room in the maze, where 0 represents an open room that can be traversed and 1 represents a blocked room that cannot be traversed.\n\n    Example:\n    grid = [\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 0, 1],\n        [1, 1, 0, 1, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 0, 1, 0]\n    ]\n\n    Output:\n    8\n\n    Explanation:\n    The minimum number of steps required to reach the bottom-right corner from the top-left corner is 8.\n\n    Constraints:\n    - The grid will always be a rectangular shape.\n    - The grid will always have at least one row and one column.\n    - The grid will only contain 0 and 1.\n    - The top-left corner of the grid will always be a 0.\n    - The bottom-right corner of the grid will always be a 0.\n    - It is guaranteed that there is a path from the top-left corner to the bottom-right corner of the grid.\n    \"\"\"\n\n    def dfs(i, j, steps):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 1:\n            return float('inf')\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\n            return steps\n\n        grid[i][j] = 1\n        min_steps = min(dfs(i+1, j, steps+1), dfs(i-1, j, steps+1), dfs(i, j+1, steps+1), dfs(i, j-1, steps+1))\n        grid[i][j] = 0\n\n        return min_steps\n\n    return dfs(0, 0, 0)\n\ndef g():\n    grid = [\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 0, 1],\n        [1, 1, 0, 1, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 0, 1, 0]\n    ]\n    return grid\n\nassert f(g()) == 8\n\n",
        "idx_generation": 356,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Determine if there exists a combination of 'k' integers from the range [1, n]\n    such that the sum of the combination is divisible by 'k'.\n    \"\"\"\n    if n < k or k <= 0:\n        return False\n\n    dp = [False] * (k + 1)\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for j in range(k, 0, -1):\n            dp[j] = dp[j] or dp[(j - i) % k]\n\n    return dp[k]\n\ndef g(n: int, k: int) -> bool:\n    \"\"\"\n    Generate a pair of integers 'n' and 'k' such that there exists a combination\n    of 'k' integers from the range [1, n] whose sum is divisible by 'k'.\n    \"\"\"\n    return n, k\n\nn = 10\nk = 3\nassert f(*g(n, k))\n",
        "idx_generation": 36,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(string: str, k: int) -> bool:\n    \"\"\"\n    Check if the given string can be rearranged into a palindrome by changing at most k characters.\n\n    Args:\n    - string: A string.\n    - k: An integer representing the maximum number of characters that can be changed.\n\n    Returns:\n    - True if the string can be rearranged into a palindrome by changing at most k characters, False otherwise.\n    \"\"\"\n    char_count = {}\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    odd_count = 0\n    for count in char_count.values():\n        if count % 2 != 0:\n            odd_count += 1\n    \n    return odd_count // 2 <= k\n\ndef g(string='aab', k=1):\n    return string, k\n\nassert f(*g()) == True\n",
        "idx_generation": 231,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, r: int) -> int:\n    \"\"\"\n    Calculate the number of combinations of n objects taken r at a time.\n    \"\"\"\n    def factorial(n: int) -> int:\n        if n == 0 or n == 1:\n            return 1\n        else:\n            return n * factorial(n - 1)\n\n    return factorial(n) // (factorial(r) * factorial(n - r))\n\ndef g(n: int, r: int) -> Tuple[int, int]:\n    \"\"\"\n    Generate values for n and r where the number of combinations is a positive even integer.\n    \"\"\"\n    return (n, r)\n\nassert f(*g(4, 2)) % 2 == 0\n",
        "idx_generation": 161,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers and a target value, find two numbers in the array that sum up to the target.\n    Return the indices of the two numbers in the array.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        \n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 460,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target element using binary search.\n\n    Example:\n    Input:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    Output:\n    2\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(nums: List[int] = [1, 3, 5, 7, 9], target: int = 5):\n    return (nums, target)\n\nassert f(*g()) == 2\n",
        "idx_generation": 435,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Find the index of the target number in a sorted list using binary search\"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g(nums=[1, 3, 5, 7, 9], target=5):\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 129,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of the first n natural numbers.\n\n    Args:\n    - n: A positive integer\n\n    Returns:\n    - The sum of the first n natural numbers.\n    \"\"\"\n    if n == 1:\n        return 1\n    else:\n        return n + f(n-1)\n\ndef g() -> int:\n    n = 5\n    return n\n\nassert f(g()) == 15\n",
        "idx_generation": 496,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, use binary search to determine if the target value is present in the list.\n\n    Example:\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 5\n\n    Output:\n    True\n\n    Explanation:\n    The target value 5 is present in the list [1, 2, 3, 4, 5, 6, 7, 8, 9].\n    \"\"\"\n    def binary_search(arr: List[int], target: int) -> bool:\n        left = 0\n        right = len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == target:\n                return True\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False\n\n    return binary_search(arr, target)\n\ndef g(arr: List[int] = [1, 2, 3, 4, 5, 6, 7, 8, 9], target: int = 5):\n    return (arr, target)\n\nassert f(*g()) == True\n\n",
        "idx_generation": 282,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with the elements in reversed order.\n\n    Sample Input:\n    arr = [1, 2, 3, 4, 5]\n\n    Sample Output:\n    [5, 4, 3, 2, 1]\n    \"\"\"\n    return arr[::-1]\n\n\ndef g(arr: List[int] = [1, 2, 3, 4, 5]) -> List[int]:\n    return arr\n\n\nassert f(g()) == [5, 4, 3, 2, 1]\n\n",
        "idx_generation": 287,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string 's', determine if it is a palindrome.\n\n    Example:\n    s = \"racecar\"\n\n    Output:\n    True (since \"racecar\" is a palindrome)\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        if len(s) <= 1:\n            return True\n        if s[0] != s[-1]:\n            return False\n        return is_palindrome(s[1:-1])\n\n    return is_palindrome(s)\n\ndef g():\n    return \"racecar\"\n\nassert f(g()) == True\n",
        "idx_generation": 293,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Check if there exists a pair of numbers in the given list whose XOR is equal to the target number.\n    \"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while left < right:\n        xor = nums[left] ^ nums[right]\n        if xor == target:\n            return True\n        elif xor < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), 13) == True\n",
        "idx_generation": 201,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The maximum product of any three numbers in the list.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 60\n\n",
        "idx_generation": 132,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum product of a subarray.\n\n    Example:\n    nums = [2, 3, -2, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The subarray [2, 3] has the maximum product of 6.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    max_product = nums[0]\n    min_product = nums[0]\n    overall_max_product = max_product\n\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            max_product, min_product = min_product, max_product\n\n        max_product = max(nums[i], max_product * nums[i])\n        min_product = min(nums[i], min_product * nums[i])\n        overall_max_product = max(overall_max_product, max_product)\n\n    return overall_max_product\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for the function f.\n    \"\"\"\n    return [2, 3, -2, 4]\n\nassert f(g()) == 6\n\n",
        "idx_generation": 274,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, find the minimum spanning tree (MST) weight.\n    \"\"\"\n    n = len(graph)\n    \n    parent = [-1] * n\n    key = [float('inf')] * n\n    key[0] = 0\n    mstSet = [False] * n\n    \n    for _ in range(n):\n        u = -1\n        for i in range(n):\n            if not mstSet[i] and (u == -1 or key[i] < key[u]):\n                u = i\n        \n        mstSet[u] = True\n        \n        for v in range(n):\n            if graph[u][v] != 0 and not mstSet[v] and graph[u][v] < key[v]:\n                parent[v] = u\n                key[v] = graph[u][v]\n    \n    mstWeight = 0\n    for i in range(1, n):\n        mstWeight += graph[i][parent[i]]\n    \n    return mstWeight\n\ndef g() -> List[List[int]]:\n    graph = [\n        [0, 2, 0, 6, 0],\n        [2, 0, 3, 8, 5],\n        [0, 3, 0, 0, 7],\n        [6, 8, 0, 0, 9],\n        [0, 5, 7, 9, 0],\n    ]\n    return graph\n\nassert f(g()) == 16\n",
        "idx_generation": 322,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, where 1 represents land and 0 represents water, count the number of islands.\n    An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.\n\n    Example:\n    Input:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n\n    Output:\n    3\n\n    Explanation:\n    The grid contains 3 islands.\n    \"\"\"\n\n    def dfs(grid, i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:\n            return\n\n        grid[i][j] = -1\n\n        dfs(grid, i-1, j)\n        dfs(grid, i+1, j)\n        dfs(grid, i, j-1)\n        dfs(grid, i, j+1)\n\n    if not grid:\n        return 0\n\n    count = 0\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                dfs(grid, i, j)\n                count += 1\n\n    return count\n\ndef g():\n    \"\"\"\n    Generate a 2D grid with the following structure:\n    [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    \"\"\"\n    return [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n\nassert f(g()) == 3\n",
        "idx_generation": 260,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum that can be obtained by traversing from the top-left corner to the bottom-right corner.\n    Each move can only be made to the right or down.\n\n    Example:\n    Input: grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 7\n    Explanation: The minimum sum can be obtained by following the path 1 -> 3 -> 1 -> 1 -> 1.\n\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[m - 1][n - 1]\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n\n",
        "idx_generation": 410,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, return the index of the target value in the list using binary search.\n    If the target value is not in the list, return -1.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), 5) == 4\n",
        "idx_generation": 134,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int, prime_factors: List[int]) -> bool:\n    \"\"\"Check if there exists a number from 1 to n (inclusive) that has exactly k prime factors\"\"\"\n    def count_prime_factors(num):\n        count = 0\n        for i in prime_factors:\n            if num % i == 0:\n                count += 1\n        return count\n\n    for i in range(1, n+1):\n        if count_prime_factors(i) == k:\n            return True\n    return False\n\ndef g(n=100, k=2, prime_factors=[2, 3]):\n    return n, k, prime_factors\n\nassert f(*g())\n",
        "idx_generation": 10,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number,\n    check if there exists a pair of integers in the list\n    whose sum is equal to the target number.\n    Return True if such a pair exists, False otherwise.\n    \"\"\"\n    complements = set()\n    for num in nums:\n        complement = target - num\n        if complement in complements:\n            return True\n        complements.add(num)\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5, 6], target=9):\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 362,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Return a list of distinct elements from the input list\"\"\"\n    distinct_nums = []\n    for num in nums:\n        if num not in distinct_nums:\n            distinct_nums.append(num)\n    return distinct_nums\n\ndef g():\n    return [1, 2, 2, 3, 4, 4, 5]\n\nassert f(g()) == [1, 2, 3, 4, 5]\n",
        "idx_generation": 227,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if n is a prime number\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef g():\n    return 17\nassert f(g()) == True\n",
        "idx_generation": 52,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Check if there exists a subset of nums that sums up to k\"\"\"\n    n = len(nums)\n    dp = [[False] * (k + 1) for _ in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            if j >= nums[i - 1]:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[n][k]\n\ndef g(k: int) -> List[int]:\n    nums = [1, 5, 9, 2, 7, 3]\n    return (nums, k)\n\nassert f(*g(10)) == True\n",
        "idx_generation": 142,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum sum of a subarray.\n\n    Example:\n    Input: [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n    Explanation: The subarray with the maximum sum is [4, -1, 2, 1], which has a sum of 6.\n    \"\"\"\n    n = len(nums)\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for i in range(n):\n        curr_sum = max(nums[i], curr_sum + nums[i])\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g(nums: List[int] = [-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 296,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a prime number.\n\n    Example:\n    n = 7\n    The number 7 is prime, so the output should be True.\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g(n=7):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 121,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> float:\n    \"\"\"\n    Given a list of points in 2D space, find the minimum distance between any two points.\n\n    Example:\n    points = [[1, 1], [3, 3], [2, 2], [4, 4]]\n\n    Output:\n    1.4142135623730951\n\n    Explanation:\n    The minimum distance is the square root of 2, which is approximately 1.4142135623730951.\n    \"\"\"\n    min_distance = float('inf')\n    \n    for i in range(len(points)):\n        for j in range(i+1, len(points)):\n            distance = ((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) ** 0.5\n            min_distance = min(min_distance, distance)\n    \n    return min_distance\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a list of random points in 2D space.\n    \"\"\"\n    return [[1, 1], [3, 3], [2, 2], [4, 4], [5, 5]]\n\nassert f(g()) == 1.4142135623730951\n",
        "idx_generation": 463,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string of numbers and arithmetic operations, evaluate the expression and return the result.\n\n    Sample input:\n    s = \"2 + 4 * 3 - 1\"\n\n    Sample output:\n    13\n\n    The expression is evaluated as follows: 2 + 4 * 3 - 1 = 2 + 12 - 1 = 14 - 1 = 13.\n    \"\"\"\n    stack = []\n    num = 0\n    operation = \"+\"\n    for i in range(len(s)):\n        if s[i].isdigit():\n            num = num * 10 + int(s[i])\n        if not s[i].isdigit() and s[i] != \" \" or i == len(s) - 1:\n            if operation == \"+\":\n                stack.append(num)\n            elif operation == \"-\":\n                stack.append(-num)\n            elif operation == \"*\":\n                stack.append(stack.pop() * num)\n            elif operation == \"/\":\n                stack.append(int(stack.pop() / num))\n            num = 0\n            operation = s[i]\n    return sum(stack)\n\ndef g():\n    return \"2 + 4 * 3 - 1\"\n\nassert f(g()) == 13\n",
        "idx_generation": 129,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum value that can be obtained by summing the elements along a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    1 + 4 + 7 + 8 + 9 = 29\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = matrix[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix\n\nassert f(g()) == 29\n\n",
        "idx_generation": 463,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth number in the Fibonacci sequence.\n\n    Example:\n    n = 6\n\n    Output:\n    8\n\n    Hint: Use dynamic programming to store previously calculated Fibonacci numbers.\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    fib = [0] * (n + 1)\n    fib[1] = 1\n\n    for i in range(2, n + 1):\n        fib[i] = fib[i - 1] + fib[i - 2]\n\n    return fib[n]\n\n\ndef g(n=6):\n    return (n,)\n\n\nassert f(*g()) == 8\n",
        "idx_generation": 308,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> int:\n    \"\"\"\n    Given a list of points in a 2D plane, find the minimum distance between any two points.\n\n    Example:\n    points = [[1, 3], [5, 6], [2, 4], [1, 2]]\n\n    Output:\n    1\n\n    Explanation:\n    The minimum distance is between points [1, 2] and [1, 3] with a distance of 1.\n    \"\"\"\n    min_distance = float('inf')\n    n = len(points)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            distance = ((points[i][0] - points[j][0])**2 + (points[i][1] - points[j][1])**2)**0.5\n            min_distance = min(min_distance, distance)\n\n    return min_distance\n\ndef g(points=[[1, 3], [5, 6], [2, 4], [1, 2]]):\n    return points\n\nassert f(g()) == True\n",
        "idx_generation": 119,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid represented by a List of List of integers, check if there exists a path from the top-left corner\n    to the bottom-right corner, such that the path only consists of 1s and each cell in the path is adjacent to its\n    neighboring cells.\n\n    Return True if such path exists, False otherwise.\n\n    Example:\n    grid = [\n        [1, 1, 1, 1],\n        [1, 0, 0, 1],\n        [1, 1, 1, 1]\n    ]\n\n    Output:\n    True\n    \"\"\"\n    rows, cols = len(grid), len(grid[0])\n    visited = set()\n\n    def dfs(row, col):\n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] == 0 or (row, col) in visited:\n            return\n        visited.add((row, col))\n        dfs(row - 1, col)\n        dfs(row + 1, col)\n        dfs(row, col - 1)\n        dfs(row, col + 1)\n\n    dfs(0, 0)\n    return (rows - 1, cols - 1) in visited\n\ndef g():\n    grid = [\n        [1, 1, 1, 1],\n        [1, 0, 0, 1],\n        [1, 1, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 100,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target: str) -> int:\n    \"\"\"\n    Given a string s and a target string, count the number of occurrences of the target string in s.\n\n    Example:\n    s = \"abababa\"\n    target = \"aba\"\n\n    Output:\n    3\n    \"\"\"\n    count = 0\n    start = 0\n\n    while True:\n        index = s.find(target, start)\n        if index == -1:\n            break\n        count += 1\n        start = index + 1\n\n    return count\n\ndef g():\n    return \"abababa\", \"aba\"\n\nassert f(*g()) == 3\n",
        "idx_generation": 464,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Stack:\n    def __init__(self):\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x onto stack.\n        \"\"\"\n        self.stack.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element on top of the stack and returns that element.\n        \"\"\"\n        return self.stack.pop()\n\n    def top(self) -> int:\n        \"\"\"\n        Get the top element of the stack.\n        \"\"\"\n        return self.stack[-1]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the stack is empty.\n        \"\"\"\n        return len(self.stack) == 0\n\ndef f(operations: List[str], values: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a list of operations and their corresponding values, perform the operations on a stack and return the results.\n\n    Example:\n    operations = [\"push\", \"push\", \"pop\", \"push\", \"top\", \"empty\"]\n    values = [[1], [2], [], [3], [], []]\n    Output: [None, None, 2, None, 3, False]\n    Explanation: The operations and corresponding values are as follows:\n    - push(1) --> stack becomes [1]\n    - push(2) --> stack becomes [1, 2]\n    - pop() --> stack becomes [1] and returns 2\n    - push(3) --> stack becomes [1, 3]\n    - top() --> returns 3\n    - empty() --> returns False\n\n    Hint: Implement the stack using a list and perform the operations accordingly.\n    \"\"\"\n\n    stack = Stack()\n    results = []\n\n    for op, vals in zip(operations, values):\n        if op == \"push\":\n            stack.push(vals[0])\n            results.append(None)\n        elif op == \"pop\":\n            results.append(stack.pop())\n        elif op == \"top\":\n            results.append(stack.top())\n        elif op == \"empty\":\n            results.append(stack.empty())\n\n    return results\n\ndef g(operations: List[str] = [\"push\", \"push\", \"pop\", \"push\", \"top\", \"empty\"], values: List[List[int]] = [[1], [2], [], [3], [], []]):\n    return operations, values\n\nassert f(*g()) == [None, None, 2, None, 3, False]\n\n",
        "idx_generation": 381,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(words: List[str], target: str) -> bool:\n    \"\"\"\n    Word Transformation\n\n    Given a list of words and a target word, determine if it is possible to transform the target word\n    into any other word in the list by changing one letter at a time. The transformation must go through\n    valid words in the list.\n\n    Example:\n    words = [\"cat\", \"hat\", \"bat\", \"bit\", \"big\"]\n    target = \"bit\"\n    output: True\n\n    Explanation:\n    \"bit\" can be transformed to \"bat\" by changing the 'i' to 'a', and then transformed to \"cat\" by changing the 'b' to 'c'.\n    \"\"\"\n    def dfs(word, target, visited):\n        if word == target:\n            return True\n        visited.add(word)\n        for i in range(len(word)):\n            for j in range(26):\n                c = chr(ord('a') + j)\n                new_word = word[:i] + c + word[i+1:]\n                if new_word in words and new_word not in visited:\n                    if dfs(new_word, target, visited):\n                        return True\n        return False\n\n    visited = set()\n    return dfs(target, target, visited)\n\ndef g(words = [\"cat\", \"hat\", \"bat\", \"bit\", \"big\"], target = \"bit\"):\n    return words, target\n\nassert f(*g())\n",
        "idx_generation": 41,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of bits required to represent n in binary form.\n    \"\"\"\n    count = 0\n    while n > 0:\n        n >>= 1\n        count += 1\n    return count\n\ndef g():\n    return 42\n\nassert f(g()) == 6\n",
        "idx_generation": 52,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given an array of positive integers and a target number, determine if it is possible to obtain the target number\n    by performing bitwise OR operations on the elements of the array. Each element can be used multiple times.\n\n    Return True if it is possible to obtain the target number, False otherwise.\n\n    Example:\n    arr = [2, 4, 8]\n    target = 10\n\n    Output:\n    True\n\n    Explanation:\n    The target number 10 can be obtained by performing the bitwise OR operation on 2 (2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2) = 10.\n\n    Hint: Use dynamic programming to build the solution incrementally by checking if the target number can be obtained\n    using the previous results.\n    \"\"\"\n    dp = [False] * (target + 1)\n    dp[0] = True\n\n    for i in range(1, target + 1):\n        for num in arr:\n            if i >= num and dp[i - num]:\n                dp[i] = True\n                break\n\n    return dp[target]\n\ndef g():\n    arr = [2, 4, 8]\n    target = 10\n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 498,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the elements in the original list\n    except for the current element.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    The product of all the elements in the original list except for 1 is 2 * 3 * 4 = 24, so the first element in the new\n    list is 24.\n    The product of all the elements in the original list except for 2 is 1 * 3 * 4 = 12, so the second element in the new\n    list is 12.\n    The product of all the elements in the original list except for 3 is 1 * 2 * 4 = 8, so the third element in the new\n    list is 8.\n    The product of all the elements in the original list except for 4 is 1 * 2 * 3 = 6, so the fourth element in the new\n    list is 6.\n\n    Therefore, the function should return [24, 12, 8, 6].\n    \"\"\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n\n    new_nums = []\n    for num in nums:\n        new_nums.append(total_product // num)\n\n    return new_nums\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == [24, 12, 8, 6]\n",
        "idx_generation": 495,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Find the minimum number of moves required to move from the top-left corner to the bottom-right corner of a grid, given that each cell contains a non-negative integer representing the cost to move to that cell.\n\n    Example:\n    Input:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n    Explanation:\n    The minimum number of moves required to move from the top-left corner (1) to the bottom-right corner (1) is 7, following the path: 1 -> 3 -> 1 -> 1 -> 1.\n\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[float('inf')] * (n + 1) for _ in range(m + 1)]\n    dp[m][n - 1] = 0\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            dp[i][j] = min(dp[i + 1][j], dp[i][j + 1]) + grid[i][j]\n\n    return dp[0][0]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 384,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the sum of the first n numbers that can be represented as a power of 2.\n\n    Example:\n    n = 5\n\n    Output:\n    31\n\n    Explanation:\n    The first 5 numbers that can be represented as a power of 2 are:\n    1, 2, 4, 8, 16\n    Their sum is 31.\n    \"\"\"\n\n    def is_power_of_two(number):\n        return number & (number - 1) == 0\n\n    sum_of_powers_of_two = 0\n    count = 0\n    number = 1\n\n    while count < n:\n        if is_power_of_two(number):\n            sum_of_powers_of_two += number\n            count += 1\n\n        number += 1\n\n    return sum_of_powers_of_two\n\ndef g():\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    return 5\n\nassert f(g()) == 31\n",
        "idx_generation": 228,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> List[int]:\n    \"\"\"\n    Given the root of a binary tree, return a list containing the values of the nodes at each level.\n    \n    Example:\n    Input:\n        3\n       / \\\n      9  20\n        /  \\\n       15   7\n    Output:\n    [[3], [9, 20], [15, 7]]\n    \n    Hint: Use a queue data structure and perform level order traversal.\n    \"\"\"\n    if not root:\n        return []\n    \n    result = []\n    queue = [root]\n    \n    while queue:\n        level = []\n        size = len(queue)\n        \n        for _ in range(size):\n            node = queue.pop(0)\n            level.append(node.val)\n            \n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        result.append(level)\n    \n    return result\n\ndef g():\n    root = TreeNode(3)\n    root.left = TreeNode(9)\n    root.right = TreeNode(20)\n    root.right.left = TreeNode(15)\n    root.right.right = TreeNode(7)\n    return root\n\nassert f(g()) == [[3], [9, 20], [15, 7]]\n",
        "idx_generation": 317,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(adj_list: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given an adjacency list representing a directed graph, determine if there exists a path from start to end.\n\n    Args:\n    - adj_list: A list of lists representing the adjacency list of the graph.\n    - start: The starting node.\n    - end: The ending node.\n\n    Returns:\n    - True if there exists a path from start to end, False otherwise.\n    \"\"\"\n    stack = [start]\n    visited = set()\n\n    while stack:\n        node = stack.pop()\n\n        if node == end:\n            return True\n\n        visited.add(node)\n\n        for neighbor in adj_list[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n\n    return False\n\ndef g():\n    adj_list = [[1, 2], [2, 3], [4], [1], []]\n    start = 0\n    end = 4\n    return adj_list, start, end\n\nassert f(*g()) == True\n\n",
        "idx_generation": 56,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: dict, node='A') -> bool:\n    \"\"\"\n    Determine if a graph is connected starting from a given node.\n    \"\"\"\n    visited = set()\n    stack = [node]\n    while stack:\n        current = stack.pop()\n        visited.add(current)\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    return len(visited) == len(graph)\ndef g():\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['A', 'D'],\n        'C': ['A', 'D'],\n        'D': ['B', 'C']\n    }\n    return graph\nassert f(g()) == True\n",
        "idx_generation": 26,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Check if the given graph is a valid tree.\n    \"\"\"\n    n = len(graph)\n    visited = set()\n    stack = [(0, -1)]\n    \n    while stack:\n        node, parent = stack.pop()\n        if node in visited:\n            return False\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                stack.append((neighbor, node))\n    \n    return len(visited) == n\n\ndef g():\n    graph = [[1, 2], [0, 3, 4], [0, 5], [1], [1, 6], [2], [4]]\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 33,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Grid Paths\n\n    Given a grid of size n x n, starting from the top-left corner, you can only move right or down.\n    Find the number of unique paths to reach the bottom-right corner from the top-left corner.\n\n    Example:\n    n = 3\n    output: 6\n    Explanation: There are 6 unique paths to reach the bottom-right corner:\n    R -> R -> D -> D\n    R -> D -> R -> D\n    R -> D -> D -> R\n    D -> R -> R -> D\n    D -> R -> D -> R\n    D -> D -> R -> R\n    \"\"\"\n    def count_paths(i: int, j: int, n: int) -> int:\n        if i == n-1 and j == n-1:\n            return 1\n        if i >= n or j >= n:\n            return 0\n        return count_paths(i+1, j, n) + count_paths(i, j+1, n)\n\n    return count_paths(0, 0, len(arr))\n\ndef g(n = 3):\n    return [1] * n\n\nassert f(g()) == 6\n",
        "idx_generation": 380,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, return True if there exists a combination of the numbers in the list\n    that adds up to the target value, and False otherwise.\n    \"\"\"\n    def combination_sum(nums, target, n):\n        if target == 0:\n            return True\n        if n == 0:\n            return False\n        if nums[n-1] > target:\n            return combination_sum(nums, target, n-1)\n        return combination_sum(nums, target-nums[n-1], n-1) or combination_sum(nums, target, n-1)\n\n    return combination_sum(nums, target, len(nums))\n\ndef g(nums=[5, 2, 3, 1, 4], target=10):\n    \"\"\"\n    Generate a combination of the numbers in the given list that adds up to the target value.\n    \"\"\"\n    def generate_combination(nums, target, n):\n        if target == 0:\n            return []\n        if n == 0:\n            return None\n        if nums[n-1] > target:\n            return generate_combination(nums, target, n-1)\n        combination = generate_combination(nums, target-nums[n-1], n-1)\n        if combination is not None:\n            combination.append(nums[n-1])\n            return combination\n        return generate_combination(nums, target, n-1)\n\n    combination = generate_combination(nums, target, len(nums))\n    return combination if combination is not None else []\n\nassert f(g()) == True\n",
        "idx_generation": 45,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, wordDict: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a dictionary of words wordDict, \n    determine if s can be segmented into a space-separated sequence of one or more dictionary words.\n\n    Args:\n    - s: The input string.\n    - wordDict: A list of words in the dictionary.\n\n    Returns:\n    - True if s can be segmented into a sequence of dictionary words, False otherwise.\n    \"\"\"\n\n    n = len(s)\n    dp = [False] * (n + 1)\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for j in range(i - 1, -1, -1):\n            if dp[j] and s[j:i] in wordDict:\n                dp[i] = True\n                break\n\n    return dp[n]\n\ndef g(s = \"leetcode\", wordDict = [\"leet\", \"code\"]):\n    return \"leetcode\", [\"leet\", \"code\"]\n\nassert f(*g()) == True\n",
        "idx_generation": 242,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int, m: int) -> bool:\n    \"\"\"\n    Given three integers n, k, and m, determine if it is possible to arrange n distinct objects into k groups\n    such that each group contains at least m objects.\n\n    Return True if it is possible, and False otherwise.\n    \"\"\"\n    # Calculate the total number of objects required\n    total_objects = k * m\n\n    # Check if it is possible to arrange n objects into k groups\n    return n >= total_objects\n\ndef g(n=20, k=4, m=3):\n    return n, k, m\n\nassert f(*g())\n",
        "idx_generation": 165,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers and a target number, return the index of the target number in the array.\n    If the target number is not found, return -1.\n\n    Example:\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output:\n    2\n\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n    return arr, target\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 460,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers 'arr' and a target integer 'target', find two numbers in the list that sum up to the target.\n    Return the indices of the two numbers in a list.\n\n    Example:\n    arr = [2, 3, 5, 7, 9]\n    target = 10\n\n    Output:\n    [1, 3] (2 + 7 = 10, and their indices in the list are 1 and 3)\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g(arr=[2, 3, 5, 7, 9], target=10):\n    return arr, target\n\nassert f(*g()) == [1, 3]\n\n",
        "idx_generation": 463,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of 10 integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), 12)\n",
        "idx_generation": 134,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n\n    Args:\n    - nums: A sorted list of integers\n    - target: The target value to search for\n\n    Returns:\n    - The index of the target value in the list, or -1 if the target value is not found.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 496,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, sort the list in non-decreasing order.\n\n    Example:\n    nums = [5, 2, 9, 1, 7]\n\n    Output:\n    [1, 2, 5, 7, 9]\n\n    Note: Do not use built-in sort functions like sorted() or sort().\n    \"\"\"\n\n    def merge_sort(nums: List[int]) -> List[int]:\n        if len(nums) <= 1:\n            return nums\n\n        mid = len(nums) // 2\n        left = merge_sort(nums[:mid])\n        right = merge_sort(nums[mid:])\n\n        return merge(left, right)\n\n    def merge(left: List[int], right: List[int]) -> List[int]:\n        merged = []\n        i = 0\n        j = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n\n        while i < len(left):\n            merged.append(left[i])\n            i += 1\n\n        while j < len(right):\n            merged.append(right[j])\n            j += 1\n\n        return merged\n\n    return merge_sort(nums)\n\n\ndef g():\n    return [5, 2, 9, 1, 7]\n\n\nassert f(g()) == [1, 2, 5, 7, 9]\n",
        "idx_generation": 292,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string containing only parentheses, brackets, and curly braces, \n    determine if the input string is valid or not. The string is considered valid if:\n    1. Open brackets must be closed by the same type of brackets.\n    2. Open brackets must be closed in the correct order.\n    \n    Return True if the string is valid, False otherwise.\n    \"\"\"\n    stack = []\n    brackets = {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\n    \n    for char in s:\n        if char in brackets:\n            stack.append(char)\n        elif char in brackets.values():\n            if not stack:\n                return False\n            if brackets[stack.pop()] != char:\n                return False\n    \n    return not stack\n\ndef g(s=\"([]){}\"):\n    return s\n\nassert f(g()) == True\n\n",
        "idx_generation": 345,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum xor value between any two numbers in the list.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The maximum xor value between any two numbers in the list.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= 1 << i\n        prefix_set = set()\n        for num in nums:\n            prefix_set.add(num & mask)\n\n        target_xor = max_xor | (1 << i)\n        for prefix in prefix_set:\n            if target_xor ^ prefix in prefix_set:\n                max_xor = target_xor\n                break\n\n    return max_xor\n\ndef g(nums = [1, 2, 3, 4, 5]):\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 7\n",
        "idx_generation": 239,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"\n    Given an integer num, return the sum of all positive divisors of num.\n\n    Sample Input:\n    num = 12\n\n    Sample Output:\n    28\n\n    Explanation:\n    The positive divisors of 12 are 1, 2, 3, 4, 6, and 12. Their sum is 1 + 2 + 3 + 4 + 6 + 12 = 28.\n    \"\"\"\n\n    def get_divisors(n: int) -> List[int]:\n        divisors = []\n        for i in range(1, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divisors.append(i)\n                if i != n // i:\n                    divisors.append(n // i)\n        return divisors\n\n    return sum(get_divisors(num))\n\ndef g(num: int = 12) -> int:\n    return num\n\nassert f(g()) == 28\n",
        "idx_generation": 142,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n    \"\"\"\n    if n <= 0:\n        return -1\n    \n    if n == 1 or n == 2:\n        return 1\n    \n    fib = [0] * (n+1)\n    fib[1] = 1\n    fib[2] = 1\n    \n    for i in range(3, n+1):\n        fib[i] = fib[i-1] + fib[i-2]\n    \n    return fib[n]\n\ndef g(n: int = 6):\n    \"\"\"\n    Generate a positive integer for the function f.\n    \"\"\"\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 279,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters representing a map, find the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.\n\n    Example:\n    Input:\n    grid = [\n        ['1', '1', '0', '0', '0'],\n        ['1', '1', '0', '0', '0'],\n        ['0', '0', '1', '0', '0'],\n        ['0', '0', '0', '1', '1'],\n    ]\n\n    Output:\n    3\n\n    Explanation:\n    In this example, there are 3 islands, represented by the '1' characters. The first island is formed by the top left '1's, the second island is formed by the bottom right '1's, and the third island is formed by the bottom right '1'.\n    \"\"\"\n\n    def dfs(grid, row, col):\n        if row < 0 or col < 0 or row >= len(grid) or col >= len(grid[0]) or grid[row][col] == '0':\n            return\n        grid[row][col] = '0'\n        dfs(grid, row+1, col)\n        dfs(grid, row-1, col)\n        dfs(grid, row, col+1)\n        dfs(grid, row, col-1)\n\n    n = len(grid)\n    m = len(grid[0])\n    count = 0\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '1':\n                count += 1\n                dfs(grid, i, j)\n\n    return count\n\ndef g():\n    grid = [\n        ['1', '1', '0', '0', '0'],\n        ['1', '1', '0', '0', '0'],\n        ['0', '0', '1', '0', '0'],\n        ['0', '0', '0', '1', '1'],\n    ]\n    return (grid,)\n\nassert f(*g()) == 3\n\n",
        "idx_generation": 335,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of 0s and 1s, determine the number of islands.\n    An island is a group of connected 1s (horizontally or vertically) in the grid.\n    Return the total number of islands in the grid.\n\n    Example:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n\n    Output:\n    3\n\n    Explanation:\n    There are 3 islands in the grid:\n    - Island 1: (0, 0), (0, 1), (1, 0), (1, 1)\n    - Island 2: (2, 2)\n    - Island 3: (3, 3), (3, 4)\n\n    Hint: Use depth-first search (DFS) to traverse the grid and mark all connected 1s as visited.\n    Count the number of DFS calls needed to visit all islands.\n    \"\"\"\n    def dfs(row, col):\n        nonlocal visited, grid\n\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or visited[row][col] or grid[row][col] == 0:\n            return\n\n        visited[row][col] = True\n\n        dfs(row-1, col)\n        dfs(row+1, col)\n        dfs(row, col-1)\n        dfs(row, col+1)\n\n    m, n = len(grid), len(grid[0])\n    visited = [[False] * n for _ in range(m)]\n    count = 0\n\n    for row in range(m):\n        for col in range(n):\n            if not visited[row][col] and grid[row][col] == 1:\n                dfs(row, col)\n                count += 1\n\n    return count\n\ndef g(grid=[[1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1]]):\n    return grid\n\nassert f(g()) == 3\n",
        "idx_generation": 270,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return the elements in spiral order.\n\n    Parameters:\n    matrix (List[List[int]]): The input matrix.\n\n    Returns:\n    List[int]: The elements in spiral order.\n    \"\"\"\n    result = []\n    if not matrix:\n        return result\n    m, n = len(matrix), len(matrix[0])\n    top, bottom, left, right = 0, m-1, 0, n-1\n    direction = 0\n    while top <= bottom and left <= right:\n        if direction == 0:\n            for i in range(left, right+1):\n                result.append(matrix[top][i])\n            top += 1\n        elif direction == 1:\n            for i in range(top, bottom+1):\n                result.append(matrix[i][right])\n            right -= 1\n        elif direction == 2:\n            for i in range(right, left-1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n        elif direction == 3:\n            for i in range(bottom, top-1, -1):\n                result.append(matrix[i][left])\n            left += 1\n        direction = (direction + 1) % 4\n    return result\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers.\n\n    Returns:\n    List[List[int]]: A matrix of integers.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n",
        "idx_generation": 468,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the number of inversions in the array.\n    An inversion occurs when two elements in the array are out of order.\n    \"\"\"\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n    return count\n\ndef g() -> List[int]:\n    arr = [4, 3, 2, 1]\n    return arr\n\nassert f(g()) == 6\n",
        "idx_generation": 144,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Find if there exists a subset of nums that adds up to the target value\n    \"\"\"\n    n = len(nums)\n    dp = [[False] * (target+1) for _ in range(n+1)]\n    dp[0][0] = True\n\n    for i in range(1, n+1):\n        dp[i][0] = True\n\n    for i in range(1, n+1):\n        for j in range(1, target+1):\n            if nums[i-1] <= j:\n                dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i-1]]\n            else:\n                dp[i][j] = dp[i-1][j]\n\n    return dp[n][target]\n\ndef g(nums = [1, 5, 3, 2, 4], target = 7):\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 21,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of the words.\n\n    A word is defined as a sequence of non-space characters. The input string does not contain leading or trailing spaces and the words are always separated by a single space.\n\n    Example:\n    Input: \"hello world\"\n    Output: \"world hello\"\n    \"\"\"\n    stack = []\n    word = \"\"\n    for char in s:\n        if char == \" \":\n            stack.append(word)\n            word = \"\"\n        else:\n            word += char\n    stack.append(word)\n\n    result = \"\"\n    while stack:\n        result += stack.pop() + \" \"\n    return result.rstrip()\n\ndef g() -> str:\n    return \"hello world\"\n\nassert f(g()) == \"world hello\"\n",
        "idx_generation": 405,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s1: str, s2: str, k: int) -> bool:\n    \"\"\"Check if two strings can be made equal by performing k operations.\"\"\"\n    if len(s1) + len(s2) <= k:\n        return True\n    common = 0\n    for i in range(min(len(s1), len(s2))):\n        if s1[i] == s2[i]:\n            common += 1\n        else:\n            break\n    if (len(s1) + len(s2) - 2 * common) <= k and (len(s1) + len(s2) - 2 * common) % 2 == k % 2:\n        return True\n    return False\n\ndef g():\n    s1 = \"abcd\"\n    s2 = \"abef\"\n    k = 6\n    return s1, s2, k\n\nassert f(*g())\n",
        "idx_generation": 45,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Two Sum\n\n    Given a list of integers nums and a target value, return indices of the two numbers such that they add up to the target.\n\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The sum of nums[0] and nums[1] is 2 + 7 = 9, so the indices are 0 and 1.\n    \"\"\"\n\n    num_map = {}\n\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[nums[i]] = i\n\n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 240,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Find the number of trailing zeros in the factorial of a given number n.\n    \"\"\"\n    count = 0\n    i = 5\n    while n // i >= 1:\n        count += n // i\n        i *= 5\n    return count\n\ndef g():\n    n = 10\n    return n\n\nassert f(g()) == 2\n",
        "idx_generation": 70,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of trailing zeroes in n!.\n\n    Example:\n    n = 5\n\n    Output:\n    1\n\n    Explanation:\n    5! = 120, so there is 1 trailing zero.\n    \"\"\"\n    count = 0\n    power_of_5 = 5\n    while n >= power_of_5:\n        count += n // power_of_5\n        power_of_5 *= 5\n    return count\n\ndef g() -> int:\n    n = 10\n    return n\n\nassert f(g()) == 2\n",
        "idx_generation": 143,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(prices: List[int]) -> int:\n    \"\"\"\n    Given an array prices representing the stock prices of a company in chronological order, \n    find the maximum profit you can make from one transaction (i.e., buy one and sell one share of the stock).\n\n    You must buy before you sell.\n\n    Parameters:\n    prices (List[int]): A list of integers representing the stock prices.\n\n    Returns:\n    int: The maximum profit you can make from one transaction.\n    \"\"\"\n    if len(prices) < 2:\n        return 0\n\n    max_profit = 0\n    min_price = prices[0]\n\n    for i in range(1, len(prices)):\n        min_price = min(min_price, prices[i])\n        max_profit = max(max_profit, prices[i] - min_price)\n\n    return max_profit\n\ndef g(prices=[7, 1, 5, 3, 6, 4]):\n    return prices\n\nassert f(g()) == 5\n",
        "idx_generation": 321,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and a target value, find two numbers in the array that add up to the target.\n    Return the indices of the two numbers as a list.\n    \"\"\"\n    # Create a dictionary to store the complement of each element (target - element) and its index\n    complements = {}\n    \n    for i, num in enumerate(arr):\n        complement = target - num\n        \n        # Check if the complement exists in the dictionary\n        if complement in complements:\n            return [complements[complement], i]\n        \n        # Add the current element and its index to the dictionary\n        complements[num] = i\n    \n    return []\n\ndef g(arr=[2, 7, 11, 15], target=9):\n    return arr, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 123,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of prime numbers less than or equal to n.\n\n    Example:\n    n = 10\n\n    Output:\n    4\n\n    Explanation:\n    There are 4 prime numbers less than or equal to 10: 2, 3, 5, 7.\n\n    Hint: Use the Sieve of Eratosthenes algorithm to efficiently find all prime numbers up to n.\n    \"\"\"\n    primes = [True] * (n + 1)\n    primes[0] = primes[1] = False\n\n    p = 2\n    while p * p <= n:\n        if primes[p] == True:\n            for i in range(p * p, n + 1, p):\n                primes[i] = False\n        p += 1\n\n    return sum(primes)\n\ndef g(n: int = 10):\n    return (n,)\n\nassert f(*g()) == 4\n\n",
        "idx_generation": 467,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the maximum area of a rectangle that can be formed\n    by connecting 1s in the grid. The rectangle must be aligned with the grid's rows\n    and columns.\n\n    Return the maximum area.\n\n    Example:\n    grid = [[1, 0, 1, 0],\n            [1, 1, 1, 1],\n            [1, 1, 1, 0]]\n\n    Output:\n    6\n\n    Explanation:\n    The maximum area rectangle that can be formed is:\n    1 0 1 0\n    1 1 1 1\n    1 1 1 0\n    which has an area of 6.\n    \"\"\"\n\n    def largest_rectangle_area(heights):\n        stack = []\n        max_area = 0\n        i = 0\n\n        while i < len(heights):\n            if not stack or heights[i] >= heights[stack[-1]]:\n                stack.append(i)\n                i += 1\n            else:\n                height = heights[stack.pop()]\n                width = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, height * width)\n\n        while stack:\n            height = heights[stack.pop()]\n            width = i if not stack else len(heights) - stack[-1] - 1\n            max_area = max(max_area, height * width)\n\n        return max_area\n\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    heights = [0] * n\n    max_area = 0\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                heights[j] = 0\n            else:\n                heights[j] += 1\n\n        max_area = max(max_area, largest_rectangle_area(heights))\n\n    return max_area\n\ndef g(grid: List[List[int]]):\n    \"\"\"\n    Generate a grid of 0s and 1s with random values.\n    \"\"\"\n    return grid\n\nassert f(g([[1, 0, 1, 0], [1, 1, 1, 1], [1, 1, 1, 0]])) == 6\n\n",
        "idx_generation": 135,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray using Kadane's algorithm.\n\n    Example:\n    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The subarray with the maximum sum is [4, -1, 2, 1], which has a sum of 6.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g(arr=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return arr\n\nassert f(g()) == 6\n\n",
        "idx_generation": 467,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size n x m, determine the minimum number of steps required to reach the bottom-right corner\n    from the top-left corner. Each step can be taken in any of the four cardinal directions (up, down, left, right).\n    \"\"\"\n    if grid[0][0] == 1 or grid[n-1][m-1] == 1:\n        return -1\n    \n    dp = [[float('inf')] * m for _ in range(n)]\n    dp[0][0] = 0\n    \n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    queue = [(0, 0)]\n    \n    while queue:\n        i, j = queue.pop(0)\n        \n        for di, dj in directions:\n            ni, nj = i + di, j + dj\n            \n            if ni >= 0 and ni < n and nj >= 0 and nj < m and grid[ni][nj] == 0 and dp[i][j] + 1 < dp[ni][nj]:\n                dp[ni][nj] = dp[i][j] + 1\n                queue.append((ni, nj))\n    \n    if dp[n-1][m-1] == float('inf'):\n        return -1\n    else:\n        return dp[n-1][m-1]\n\ndef g() -> Tuple[int, int, List[List[int]]]:\n    \"\"\"\n    Generate a grid and its dimensions.\n    \"\"\"\n    n = 3\n    m = 3\n    grid = [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]\n    return n, m, grid\n\nassert f(*g()) == 4\n",
        "idx_generation": 366,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return the elements of the matrix in spiral order.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n\n    Output:\n    [1, 2, 3, 6, 9, 8, 7, 4, 5]\n    \"\"\"\n\n    if not matrix:\n        return []\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    top = 0\n    bottom = rows - 1\n    left = 0\n    right = cols - 1\n\n    spiral_order = []\n\n    while top <= bottom and left <= right:\n        # Traverse from left to right\n        for i in range(left, right + 1):\n            spiral_order.append(matrix[top][i])\n        top += 1\n\n        # Traverse from top to bottom\n        for i in range(top, bottom + 1):\n            spiral_order.append(matrix[i][right])\n        right -= 1\n\n        # Traverse from right to left\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                spiral_order.append(matrix[bottom][i])\n            bottom -= 1\n\n        # Traverse from bottom to top\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                spiral_order.append(matrix[i][left])\n            left += 1\n\n    return spiral_order\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n",
        "idx_generation": 146,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, k: int, grid: List[List[int]]) -> bool:\n    \"\"\"\n    Determine if it is possible to reach the bottom-right cell of a grid by starting from the top-left cell,\n    moving only right or down, and making exactly k moves. Each cell in the grid contains either 0 or 1,\n    where 0 represents an obstacle and 1 represents an open path.\n    \"\"\"\n    def dfs(i: int, j: int, moves: int) -> bool:\n        if i == n-1 and j == m-1:\n            return moves == k\n        if i >= n or j >= m or grid[i][j] == 0 or moves > k:\n            return False\n        return dfs(i+1, j, moves+1) or dfs(i, j+1, moves+1)\n    \n    return dfs(0, 0, 0)\n\ndef g():\n    n = 3\n    m = 3\n    k = 4\n    grid = [[1, 0, 1],\n            [1, 1, 1],\n            [0, 1, 1]]\n    return n, m, k, grid\n\nassert f(*g())\n",
        "idx_generation": 103,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the number of palindromic substrings in s.\n\n    Example:\n    s = \"abc\"\n\n    Output:\n    3\n\n    Explanation:\n    The palindromic substrings in s are \"a\", \"b\", and \"c\".\n\n    Hint: Use string manipulation techniques to check if the substrings are palindromes.\n    \"\"\"\n\n    count = 0\n\n    # Check each character in the string as the center of a palindrome\n    for i in range(len(s)):\n        count += expand_from_center(s, i, i)  # Odd length palindromes\n        count += expand_from_center(s, i, i + 1)  # Even length palindromes\n\n    return count\n\ndef expand_from_center(s: str, left: int, right: int) -> int:\n    \"\"\"\n    Helper function to expand the palindrome from the center outwards.\n    \"\"\"\n\n    count = 0\n\n    # Expand the palindrome until the characters at the left and right pointers are no longer equal\n    while left >= 0 and right < len(s) and s[left] == s[right]:\n        count += 1\n        left -= 1\n        right += 1\n\n    return count\n\ndef g(s=\"abc\"):\n    return s\n\nassert f(g()) == 3\n\n",
        "idx_generation": 465,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of words in the string.\n\n    A word is defined as a sequence of non-space characters separated by a single space.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: The string with words reversed.\n    \"\"\"\n\n    words = s.split()\n    reversed_words = words[::-1]\n\n    return \" \".join(reversed_words)\n\n\ndef g(s=\"Hello World!\") -> str:\n    return s\n\nassert f(g()) == \"World! Hello\"\n\n",
        "idx_generation": 463,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "import random\nfrom typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome\"\"\"\n    return s == s[::-1]\n\ndef g() -> str:\n    \"\"\"Generate a palindrome string of length 10\"\"\"\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    n = 5\n    prefix = ''.join(random.choice(letters) for _ in range(n))\n    return prefix + prefix[::-1]\n\nassert f(g()) == True\n",
        "idx_generation": 51,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Check if there exists a pair of numbers in the given list that XOR to zero.\n    \"\"\"\n    def has_zero_xor(nums: List[int], current_xor: int, index: int) -> bool:\n        if index == len(nums):\n            return current_xor == 0\n\n        return has_zero_xor(nums, current_xor ^ nums[index], index + 1) or has_zero_xor(nums, current_xor, index + 1)\n\n    return has_zero_xor(nums, 0, 0)\n\ndef g():\n    \"\"\"\n    Generate a list of numbers where there exists a pair that XOR to zero.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 55,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if n is a perfect square\"\"\"\n    return int(n**0.5)**2 == n\ndef g():\n    return 25\nassert f(g())\n",
        "idx_generation": 360,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers where each cell represents the cost to move to that cell, find the minimum cost to reach the bottom-right cell from the top-left cell. \n    You can only move down or right.\n\n    Args:\n    - grid: A 2D grid of integers.\n\n    Returns:\n    - The minimum cost to reach the bottom-right cell from the top-left cell.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[float('inf')] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g(grid=[[1,3,1],[1,5,1],[4,2,1]]):\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 390,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(num: int) -> bool:\n    \"\"\"\n    Given an integer, determine if it is a power of two.\n\n    Example:\n    num = 16\n\n    Output:\n    True\n\n    Explanation:\n    16 is a power of two (2^4).\n    \"\"\"\n\n    # Check if the number is positive and greater than zero\n    if num <= 0:\n        return False\n\n    # Check if the number is a power of two\n    return num & (num - 1) == 0\n\ndef g():\n    num = 16\n    return num\n\nassert f(g()) == True\n",
        "idx_generation": 268,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[Tuple[int, int]]) -> List[List[int]]:\n    \"\"\"\n    Given the number of nodes and a list of edges between nodes, construct and return an adjacency list representing a tree.\n\n    Example:\n    Input:\n    n = 5\n    edges = [(0, 1), (0, 2), (0, 3), (2, 4)]\n\n    Output:\n    [[1, 2, 3], [0], [0, 4], [0], [2]]\n\n    Explanation:\n    The input represents a tree with 5 nodes and the following edges:\n    0 - 1\n    | \\\n    2  3\n    |\n    4\n\n    The output is the adjacency list representation of the tree.\n    \"\"\"\n\n    def buildTree(n: int, edges: List[Tuple[int, int]]) -> List[List[int]]:\n        adj_list = [[] for _ in range(n)]\n\n        for u, v in edges:\n            adj_list[u].append(v)\n            adj_list[v].append(u)\n\n        return adj_list\n\n    return buildTree(n, edges)\n\ndef g() -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Generate the number of nodes and a list of edges between nodes.\n    \"\"\"\n    return (5, [(0, 1), (0, 2), (0, 3), (2, 4)])\n\nassert f(*g()) == [[1, 2, 3], [0], [0, 4], [0], [2]]\n\n",
        "idx_generation": 334,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom collections import defaultdict\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"\n    Given a graph represented as a dictionary of lists, check if there exists a path from start to end.\n    \"\"\"\n    visited = defaultdict(bool)\n    visited[start] = True\n    queue = [start]\n    while queue:\n        node = queue.pop(0)\n        if node == end:\n            return True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n    return False\n\ndef g():\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['E'],\n        'D': [],\n        'E': []\n    }\n    start = 'A'\n    end = 'E'\n    return graph, start, end\n\nassert f(*g())\n",
        "idx_generation": 59,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start='A', end='D') -> bool:\n    \"\"\"Find the shortest path from start to end in the given graph.\"\"\"\n    def shortest_path(graph, start, end, path=[]):\n        path = path + [start]\n        if start == end:\n            return path\n        if start not in graph:\n            return None\n        shortest = None\n        for node in graph[start]:\n            if node not in path:\n                newpath = shortest_path(graph, node, end, path)\n                if newpath:\n                    if not shortest or len(newpath) < len(shortest):\n                        shortest = newpath\n        return shortest\n    \n    return shortest_path(graph, start, end)\n\ndef g(graph = {'A': ['B', 'C'], 'B': ['A', 'D'], 'C': ['A', 'D'], 'D': ['B', 'C']}):\n    return graph\n\nassert f(g()) == ['A', 'B', 'D']\n",
        "idx_generation": 28,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"Find the maximum score by concatenating strings in the grid.\"\"\"\n    max_score = 0\n\n    # Recursive function to find the maximum score\n    def dfs(row: int, col: int, score: int, visited: List[List[bool]]) -> None:\n        nonlocal max_score\n\n        # Base case: out of bounds\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]):\n            return\n\n        # Base case: already visited\n        if visited[row][col]:\n            return\n\n        # Update the score\n        score += int(grid[row][col])\n        max_score = max(max_score, score)\n\n        # Mark the current cell as visited\n        visited[row][col] = True\n\n        # Recursive calls in all four directions\n        dfs(row + 1, col, score, visited)\n        dfs(row - 1, col, score, visited)\n        dfs(row, col + 1, score, visited)\n        dfs(row, col - 1, score, visited)\n\n        # Mark the current cell as unvisited (backtrack)\n        visited[row][col] = False\n\n    # Initialize the visited matrix\n    visited = [[False] * len(grid[0]) for _ in range(len(grid))]\n\n    # Start the DFS from each cell in the grid\n    for row in range(len(grid)):\n        for col in range(len(grid[0])):\n            dfs(row, col, 0, visited)\n\n    return max_score\n\ndef g(grid = [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']]):\n    return grid\n\nassert f(g()) == 45\n",
        "idx_generation": 53,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid represented by a list of lists, find the number of islands.\n\n    An island is a group of connected 1s, where a cell is considered connected to its adjacent cells\n    horizontally or vertically. Cells connected diagonally are not considered connected.\n\n    Example:\n    grid = [[1, 1, 0, 0, 0],\n            [1, 1, 0, 0, 0],\n            [0, 0, 1, 0, 0],\n            [0, 0, 0, 1, 1]]\n    output: 3\n\n    Explanation:\n    There are 3 islands in the grid: one with 4 cells, one with 2 cells, and one with 2 cells.\n    \"\"\"\n    def dfs(grid, row, col):\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] != 1:\n            return\n        \n        grid[row][col] = -1\n        \n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        for dr, dc in directions:\n            new_row, new_col = row + dr, col + dc\n            dfs(grid, new_row, new_col)\n    \n    count = 0\n    for row in range(len(grid)):\n        for col in range(len(grid[0])):\n            if grid[row][col] == 1:\n                dfs(grid, row, col)\n                count += 1\n    \n    return count\n\ndef g():\n    return [[1, 1, 0, 0, 0],\n            [1, 1, 0, 0, 0],\n            [0, 0, 1, 0, 0],\n            [0, 0, 0, 1, 1]]\n\nassert f(g()) == 3\n",
        "idx_generation": 387,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the number of unique permutations of nums\"\"\"\n    nums.sort()\n    return permute(nums, 0)\n\ndef permute(nums: List[int], start: int) -> int:\n    if start == len(nums)-1:\n        return 1\n    count = 0\n    for i in range(start, len(nums)):\n        if i != start and nums[i] == nums[start]:\n            continue\n        nums[i], nums[start] = nums[start], nums[i]\n        count += permute(nums, start+1)\n        nums[i], nums[start] = nums[start], nums[i]\n    return count\n\ndef g(nums=[1, 1, 2]):\n    return nums\n\nassert f(g()) == 3\n",
        "idx_generation": 47,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "import itertools\nfrom typing import*\nfrom itertools import permutations\n\ndef f(word: str) -> bool:\n    \"\"\"\n    Given a word, determine if it can be rearranged to form a palindrome.\n\n    Example:\n    word = \"racecar\"\n\n    Output:\n    True\n\n    Explanation:\n    The letters in the word can be rearranged to form the palindrome \"racecar\".\n    \"\"\"\n\n    # Generate all permutations of the word\n    perms = permutations(word)\n\n    # Check if any permutation is a palindrome\n    for perm in perms:\n        if perm == perm[::-1]:\n            return True\n\n    return False\n\ndef g():\n    word = \"racecar\"\n    return word\n\nassert f(g()) == True\n",
        "idx_generation": 268,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of ways to choose k elements from a set of n elements.\n\n    Sample Input:\n    n = 5\n    k = 3\n\n    Sample Output:\n    10\n    \"\"\"\n    if k > n:\n        return 0\n\n    numerator = 1\n    denominator = 1\n\n    for i in range(1, k + 1):\n        numerator *= n - i + 1\n        denominator *= i\n\n    return numerator // denominator\n\ndef g(n=5, k=3):\n    return n, k\n\nassert f(*g()) == 10\n",
        "idx_generation": 215,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list containing only the even numbers in the original list.\n    The new list should be sorted in ascending order.\n\n    Example:\n    arr = [2, 5, 1, 8, 3, 10]\n\n    Output:\n    [2, 8, 10]\n\n    Explanation:\n    The even numbers in the original list are 2, 8, and 10.\n    The new list is sorted in ascending order.\n    \"\"\"\n\n    even_numbers = [num for num in arr if num % 2 == 0]\n    even_numbers.sort()\n\n    return even_numbers\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, 5, 1, 8, 3, 10]\n\nassert f(g()) == [2, 8, 10]\n",
        "idx_generation": 462,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the index of the target number in the list. If the target number is not in the list, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g() -> (List[int], int):\n    \"\"\"\n    Generate a list of integers and a target number. The target number is guaranteed to be in the list.\n    \"\"\"\n    nums = [2, 5, 7, 9, 12, 15, 18]\n    target = 9\n    return nums, target\n\nassert f(*g()) == 3\n",
        "idx_generation": 470,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, use binary search to find the index of the target number.\n\n    Args:\n    nums (List[int]): A sorted list of integers.\n    target (int): The number to search for.\n\n    Returns:\n    int: The index of the target number in the list, or -1 if it is not found.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target=6):\n    \"\"\"\n    Generate a sorted list of numbers and a target number for binary search.\n    \"\"\"\n    return nums, target\n\nassert f(*g()) == 5\n",
        "idx_generation": 137,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, check if there exists a pair of numbers that sum up to the target value.\"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums = [1, 2, 3, 4, 5], target = 8):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 23,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of integer heights representing the height of bars in a bar chart, calculate the area of the largest rectangle that can be formed within the chart.\n    The width of each bar is 1.\n    \"\"\"\n\n    stack = []\n    max_area = 0\n    n = len(heights)\n\n    for i in range(n):\n        while stack and heights[i] < heights[stack[-1]]:\n            height = heights[stack.pop()]\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        stack.append(i)\n\n    while stack:\n        height = heights[stack.pop()]\n        width = n if not stack else n - stack[-1] - 1\n        max_area = max(max_area, height * width)\n\n    return max_area\n\ndef g():\n    heights = [2, 1, 5, 6, 2, 3]\n    return heights\n\nassert f(g()) == 10\n\n",
        "idx_generation": 340,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(expression: str) -> bool:\n    \"\"\"\n    Check if a given arithmetic expression is balanced or not. \n    The expression is considered balanced if every opening parenthesis has a corresponding closing parenthesis and they are properly nested.\n    \"\"\"\n    stack = []\n    opening = '({['\n    closing = ')}]'\n    for char in expression:\n        if char in opening:\n            stack.append(char)\n        elif char in closing:\n            if not stack:\n                return False\n            if closing.index(char) != opening.index(stack.pop()):\n                return False\n    return len(stack) == 0\n\ndef g(expression: str) -> str:\n    \"\"\"\n    Return the arithmetic expression to check if it is balanced or not.\n    \"\"\"\n    return expression\n\nassert f(g(\"3 + 5 * (2 - 4)\")) == True\n",
        "idx_generation": 370,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two elements in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value is obtained by XORing 5 and 25, which gives a result of 28.\n    \"\"\"\n\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = set()\n        for num in nums:\n            prefixes.add(num & mask)\n        candidate = max_xor | (1 << i)\n        for prefix in prefixes:\n            if candidate ^ prefix in prefixes:\n                max_xor = candidate\n                break\n\n    return max_xor\n\ndef g():\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n\n",
        "idx_generation": 317,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum product of any three numbers in the list.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3])\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 60\n\n",
        "idx_generation": 150,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum sum of a subsequence such that no two elements in the subsequence are adjacent.\n\n    Example:\n    Input:\n    nums = [4, 1, 2, 7, 5, 3]\n\n    Output:\n    14\n\n    Explanation:\n    The maximum sum of a non-adjacent subsequence is 14, which can be obtained by selecting the numbers 4, 7, and 3 (4 + 7 + 3 = 14).\n    \"\"\"\n\n    def maxSumNoAdjacent(nums: List[int]) -> int:\n        if not nums:\n            return 0\n\n        n = len(nums)\n\n        if n == 1:\n            return nums[0]\n\n        dp = [0] * n\n        dp[0] = nums[0]\n        dp[1] = max(nums[0], nums[1])\n\n        for i in range(2, n):\n            dp[i] = max(nums[i] + dp[i - 2], dp[i - 1])\n\n        return dp[n - 1]\n\n    return maxSumNoAdjacent(nums)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate an array of integers.\n    \"\"\"\n    return [4, 1, 2, 7, 5, 3]\n\nassert f(g()) == 14\n",
        "idx_generation": 292,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of 0s and 1s, determine if it is possible to reach the bottom-right cell from the top-left cell\n    by only moving downwards or rightwards. The cells containing 0 represent obstacles that cannot be crossed.\n\n    Sample input:\n    matrix = [\n        [1, 0, 0],\n        [1, 1, 1],\n        [0, 0, 1]\n    ]\n\n    Sample output:\n    True\n\n    Explanation: It is possible to reach the bottom-right cell (matrix[2][2]) by moving downwards and rightwards.\n    \"\"\"\n    rows = len(matrix)\n    if rows == 0:\n        return False\n    cols = len(matrix[0])\n    if cols == 0:\n        return False\n\n    dp = [[False] * cols for _ in range(rows)]\n    dp[0][0] = True\n\n    for i in range(rows):\n        for j in range(cols):\n            if matrix[i][j] == 1:\n                if i > 0:\n                    dp[i][j] |= dp[i-1][j]\n                if j > 0:\n                    dp[i][j] |= dp[i][j-1]\n\n    return dp[rows-1][cols-1]\n\ndef g(matrix=[[1, 0, 0], [1, 1, 1], [0, 0, 1]]):\n    return matrix\n\nassert f(g()) == True\n",
        "idx_generation": 345,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum along a path from the top-left corner to the bottom-right corner.\n    You can only move down or right at any point in time.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    output: 12\n    Explanation: The maximum sum path is: 1 -> 3 -> 1 -> 1 -> 1\n\n    \"\"\"\n\n    if not grid:\n        return 0\n\n    n = len(grid)\n    m = len(grid[0])\n\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, m):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[n - 1][m - 1]\n\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(g()) == 12\n",
        "idx_generation": 302,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list.\n    If the target value is not found in the list, return -1.\n    \n    Sample Input:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    \n    Sample Output:\n    2\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g():\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 158,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int], target=100) -> bool:\n    \"\"\"Find the number of combinations that sum up to the target value\"\"\"\n    def count_combinations(arr, target):\n        n = len(arr)\n        dp = [[0] * (target + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            dp[i][0] = 1\n            for j in range(1, target + 1):\n                if arr[i - 1] > j:\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - arr[i - 1]]\n        return dp[n][target]\n    \n    return count_combinations(sorted(arr), target) > 0\n\ndef g(target=100):\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == True\n",
        "idx_generation": 63,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string of parentheses, determine if the string is valid.\n    A valid string of parentheses must have matching opening and closing parentheses.\n\n    Example:\n    s = \"((())())\"\n\n    Output:\n    True\n\n    Explanation:\n    The string of parentheses is valid because it has matching opening and closing parentheses.\n    \"\"\"\n\n    stack = []\n\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack or stack[-1] != '(':\n                return False\n            stack.pop()\n\n    return len(stack) == 0\n\ndef g() -> str:\n    return \"((())())\"\n\nassert f(g()) == True\n",
        "idx_generation": 449,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Check if it is possible to form a string s by concatenating k copies of a substring.\"\"\"\n    n = len(s)\n    for i in range(1, n//k + 1):\n        if s[:i] * k == s:\n            return True\n    return False\n\ndef g(s = \"ababab\", k = 3):\n    return s, k\n\nassert f(*g())\n",
        "idx_generation": 131,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in nums that sum up to target.\"\"\"\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] + nums[j] == target:\n                return True\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5], target=9):\n    return nums\n\nassert f(g(), 9) == True\n",
        "idx_generation": 248,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, return the number of prime numbers less than or equal to n.\n\n    Sample Input:\n    10\n\n    Sample Output:\n    4\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2, n+1):\n        if is_prime(i):\n            count += 1\n    return count\n\ndef g():\n    return 10\n\nassert f(g()) == 4\n",
        "idx_generation": 82,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine if a given number is prime.\n    Return True if the number is prime, otherwise return False.\n\n    Example:\n    n = 7\n    Output: True\n\n    n = 15\n    Output: False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g(n=7):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 192,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find the maximum subarray sum and return the subarray with that sum.\n    \"\"\"\n    def max_subarray(nums: List[int]) -> List[int]:\n        n = len(nums)\n        max_sum = float('-inf')\n        curr_sum = 0\n        start = 0\n        end = 0\n\n        for i in range(n):\n            if curr_sum < 0:\n                curr_sum = nums[i]\n                start = i\n            else:\n                curr_sum += nums[i]\n\n            if curr_sum > max_sum:\n                max_sum = curr_sum\n                end = i\n\n        return nums[start:end+1]\n\n    return max_subarray(nums)\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == [4, -1, 2, 1]\n\n",
        "idx_generation": 326,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of any submatrix in the matrix.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    max_sum = float('-inf')\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(i, rows):\n                for l in range(j, cols):\n                    submatrix_sum = 0\n                    for p in range(i, k+1):\n                        for q in range(j, l+1):\n                            submatrix_sum += matrix[p][q]\n                    if submatrix_sum > max_sum:\n                        max_sum = submatrix_sum\n    return max_sum\n\ndef g() -> List[List[int]]:\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix\n\nassert f(g()) == 45\n\n",
        "idx_generation": 150,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the sum of all the elements.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n\n    Output:\n    45\n\n    Explanation:\n    The sum of all the elements in the matrix is 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45.\n    \"\"\"\n    total_sum = 0\n    for row in matrix:\n        for num in row:\n            total_sum += num\n    return total_sum\n\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix\n\nassert f(g()) == 45\n\n",
        "idx_generation": 470,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "import math\nfrom typing import*\nfrom typing import List\n\ndef f(equation: str) -> bool:\n    \"\"\"\n    Given a mathematical equation as a string, determine if it is balanced.\n    A balanced equation has an equal number of opening and closing brackets.\n\n    Example:\n    equation = \"(2 + 3) * (4 - 5)\"\n\n    Output:\n    True\n\n    Explanation:\n    The equation is balanced as it has 2 opening brackets and 2 closing brackets.\n\n    Hint: Use a stack to keep track of opening brackets and check if the stack is empty at the end.\n    \"\"\"\n\n    stack = []\n    for char in equation:\n        if char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if len(stack) == 0:\n                return False\n            stack.pop()\n\n    return len(stack) == 0\n\ndef g(equation=\"(2 + 3) * (4 - 5)\"):\n    return equation\n\nassert f(g()) == True\n",
        "idx_generation": 142,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n\n    Example:\n    Input: 6\n    Output: 8\n\n    Explanation:\n    The 6th Fibonacci number is 8, where the Fibonacci sequence is [0, 1, 1, 2, 3, 5, 8, ...]\n    \"\"\"\n\n    if n <= 1:\n        return n\n\n    fib = [0, 1]\n\n    for i in range(2, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2])\n\n    return fib[n]\n\ndef g() -> int:\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 468,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of non-negative integers, find the maximum sum of a contiguous subarray.\n    Return the maximum sum.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for num in nums:\n        curr_sum = max(curr_sum + num, num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum\n\ndef g() -> List[int]:\n    return [1, -3, 2, 1, -1, 4, -2, 5]\n\nassert f(g()) == 9\n",
        "idx_generation": 392,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers where each integer represents the height of a building, find the maximum height of a building that can be seen from each column.\n\n    Sample Input:\n    grid = [\n        [3, 5, 2, 1],\n        [2, 4, 7, 3],\n        [1, 2, 3, 4],\n        [3, 1, 5, 2]\n    ]\n\n    Sample Output:\n    [3, 5, 7, 4]\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    max_heights = [0] * n\n\n    for j in range(n):\n        max_height = 0\n        for i in range(m):\n            max_height = max(max_height, grid[i][j])\n        max_heights[j] = max_height\n\n    return max_heights\n\ndef g(grid=[[3, 5, 2, 1], [2, 4, 7, 3], [1, 2, 3, 4], [3, 1, 5, 2]]):\n    return grid\n\nassert f(g()) == [3, 5, 7, 4]\n",
        "idx_generation": 184,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid filled with non-negative integers, find the maximum sum along a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n            \n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 12\n",
        "idx_generation": 105,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of words in the string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: The string with reversed order of words.\n    \"\"\"\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)\n\ndef g() -> str:\n    \"\"\"\n    Generate a string.\n\n    Returns:\n    str: A string.\n    \"\"\"\n    return \"Hello World\"\n\nassert f(g()) == \"World Hello\"\n\n",
        "idx_generation": 468,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(string: str) -> int:\n    \"\"\"\n    Given a string of parentheses, consisting of only '(' and ')', determine the minimum number of parentheses that need to be removed in order to make the string valid.\n\n    A string is considered valid if it contains a balanced number of opening and closing parentheses, and if any opening parentheses is followed by a corresponding closing parentheses.\n\n    Return the minimum number of parentheses that need to be removed to make the string valid.\n\n    Sample Input:\n    string = \"())(\"\n\n    Sample Output:\n    2\n\n    Explanation:\n    The string can be made valid by removing the parentheses at indices 0 and 3, resulting in the string \"()\".\n    \"\"\"\n\n    stack = []\n    count = 0\n\n    for char in string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if stack and stack[-1] == '(':\n                stack.pop()\n            else:\n                count += 1\n\n    return count + len(stack)\n\ndef g(string: str = \"())(\"):\n    return string\n\nassert f(g()) == 2\n\n",
        "idx_generation": 482,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"Check if the target string can be formed by concatenating subsequences of the given string.\"\"\"\n    def is_subsequence(s: str, target: str) -> bool:\n        i, j = 0, 0\n        while i < len(s) and j < len(target):\n            if s[i] == target[j]:\n                j += 1\n            i += 1\n        return j == len(target)\n    \n    def can_form(s: str, target: str) -> bool:\n        if len(target) == 0:\n            return True\n        if len(s) == 0:\n            return False\n        \n        # Check if target can be formed by taking a single character at a time from s\n        if is_subsequence(s, target):\n            return True\n        \n        # Check if target can be formed by concatenating subsequences of s\n        for i in range(1, len(s)):\n            if is_subsequence(s[:i], target) and can_form(s[i:], target):\n                return True\n        \n        return False\n\n    return can_form(s, target)\n\ndef g():\n    s = \"abcde\"\n    target = \"ace\"\n    return s, target\n\nassert f(*g()) == True\n",
        "idx_generation": 69,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number is a power of 2\"\"\"\n    return n > 0 and (n & (n - 1)) == 0\n\ndef g():\n    return 16\n\nassert f(g()) == True\n",
        "idx_generation": 55,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of the first n Fibonacci numbers.\n    \"\"\"\n\n    if n <= 0:\n        return 0\n\n    fib = [0] * (n + 1)\n    fib[1] = 1\n\n    for i in range(2, n + 1):\n        fib[i] = fib[i - 1] + fib[i - 2]\n\n    return sum(fib)\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == 12\n\n",
        "idx_generation": 364,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Find if it is possible to partition the given list of numbers into two subsets such that the sum of elements\n    in each subset is equal to the target value.\n    \"\"\"\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n    target_sum = total_sum // 2\n    return can_partition(nums, target_sum)\n\ndef can_partition(nums: List[int], target: int) -> bool:\n    dp = [False] * (target + 1)\n    dp[0] = True\n    for num in nums:\n        for i in range(target, num - 1, -1):\n            dp[i] = dp[i] or dp[i - num]\n    return dp[target]\n\ndef g():\n    nums = [1, 5, 11, 5]\n    target = 11\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 0,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum path sum from the top left to the bottom right, moving only right and down.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum path sum is 1 + 3 + 1 + 1 + 1 = 7.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    for i in range(1, rows):\n        grid[i][0] += grid[i-1][0]\n\n    for j in range(1, cols):\n        grid[0][j] += grid[0][j-1]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            grid[i][j] += min(grid[i-1][j], grid[i][j-1])\n\n    return grid[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n",
        "idx_generation": 397,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the count of the total number of set bits in all numbers from 1 to n.\n\n    Example:\n    f(5) returns 7, as the set bits in the numbers from 1 to 5 are as follows:\n    - 1: 1\n    - 2: 10\n    - 3: 11\n    - 4: 100\n    - 5: 101\n    The total count of set bits is 7.\n\n    Note:\n    - 0 <= n <= 10^9\n    \"\"\"\n\n    if n == 0:\n        return 0\n\n    power_of_two = 1\n    count = 0\n\n    while power_of_two <= n:\n        count += (n // (2 * power_of_two)) * power_of_two\n        if n % (2 * power_of_two) >= power_of_two:\n            count += n % (2 * power_of_two) - power_of_two + 1\n        power_of_two *= 2\n\n    return count\n\n\ndef g():\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n\n    return 5\n\n\nassert f(g()) == 7\n\n",
        "idx_generation": 341,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target: int, rows=3, cols=3) -> bool:\n    \"\"\"\n    Given a grid of integers and a target number, determine if the target number can be obtained by traversing the grid.\n    The target number can be obtained by starting at any cell in the grid and moving to adjacent cells (up, down, left, or right),\n    summing the values along the path. Return True if the target number can be obtained, False otherwise.\n    \"\"\"\n    def dfs(i, j, target):\n        if target == 0:\n            return True\n        if i < 0 or i >= rows or j < 0 or j >= cols or grid[i][j] == -1:\n            return False\n        temp = grid[i][j]\n        grid[i][j] = -1\n        found = dfs(i+1, j, target - temp) or dfs(i-1, j, target - temp) or dfs(i, j+1, target - temp) or dfs(i, j-1, target - temp)\n        grid[i][j] = temp\n        return found\n\n    for i in range(rows):\n        for j in range(cols):\n            if dfs(i, j, target):\n                return True\n    return False\n\ndef g(grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], target = 15):\n    return grid, target\n\nassert f(*g())\n",
        "idx_generation": 366,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start: int, target: int) -> bool:\n    \"\"\"\n    Given a directed graph and two nodes, determine if there exists a path from the start node to the target node.\n\n    Example:\n    graph = {1: [2, 3], 2: [4], 3: [5], 4: [], 5: []}\n    start = 1\n    target = 5\n    Output: True\n    Explanation: There is a path from node 1 to node 5 in the graph.\n\n    \"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == target:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    return False\n\ndef g(start=1, target=5):\n    graph = {1: [2, 3], 2: [4], 3: [5], 4: [], 5: []}\n    return graph, start, target\n\nassert f(*g())\n",
        "idx_generation": 72,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef f(root: Node) -> bool:\n    \"\"\"Check if the given binary tree is a valid binary search tree\"\"\"\n    def validate(node, lower=float('-inf'), upper=float('inf')):\n        if not node:\n            return True\n        if node.value <= lower or node.value >= upper:\n            return False\n        return validate(node.left, lower, node.value) and validate(node.right, node.value, upper)\n    \n    return validate(root)\n\ndef g():\n    root = Node(4)\n    root.left = Node(2)\n    root.right = Node(6)\n    root.left.left = Node(1)\n    root.left.right = Node(3)\n    root.right.left = Node(5)\n    root.right.right = Node(7)\n    return root\n\nassert f(g()) == True\n",
        "idx_generation": 30,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nimport math\n\ndef f(graph: dict) -> bool:\n    \"\"\"Check if the given directed graph is a tree\"\"\"\n    num_nodes = len(graph)\n    num_edges = sum(len(edges) for edges in graph.values())\n    \n    if num_edges != num_nodes - 1:\n        return False\n    \n    visited = set()\n    stack = [next(iter(graph))]\n    \n    while stack:\n        node = stack.pop()\n        visited.add(node)\n        \n        for neighbor in graph[node]:\n            if neighbor in visited:\n                return False\n            stack.append(neighbor)\n    \n    return len(visited) == num_nodes\n\ndef g():\n    graph = {1: [2, 3], 2: [4], 3: [5], 4: [], 5: []}\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 55,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, find the number of islands.\n    An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.\n    You may assume all four edges of the grid are all surrounded by water.\n\n    Example:\n    Input: grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    Output: 3\n\n    Explanation: In the given grid, there are 3 islands.\n    \"\"\"\n    def dfs(grid, i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0:\n            return\n        grid[i][j] = 0\n        dfs(grid, i+1, j)\n        dfs(grid, i-1, j)\n        dfs(grid, i, j+1)\n        dfs(grid, i, j-1)\n\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                count += 1\n                dfs(grid, i, j)\n    return count\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n\nassert f(g()) == 3\n",
        "idx_generation": 420,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find all unique combinations of numbers in the list that sum up to the target.\n    Each number in the list can be used multiple times.\n    \"\"\"\n    def helper(nums, target, curr_comb, curr_sum, start, result):\n        if curr_sum == target:\n            result.append(curr_comb[:])\n            return\n        if curr_sum > target or start >= len(nums):\n            return\n        \n        for i in range(start, len(nums)):\n            curr_comb.append(nums[i])\n            helper(nums, target, curr_comb, curr_sum + nums[i], i, result)\n            curr_comb.pop()\n\n    result = []\n    helper(nums, target, [], 0, 0, result)\n    return result\n\ndef g():\n    return ([2, 3, 6, 7], 7)\n\nassert f(*g()) == [[2, 2, 3], [7]]\n",
        "idx_generation": 56,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given an integer n and a list of integers nums, return all possible combinations of length n from the list.\n\n    Example:\n    Input:\n    n = 2\n    nums = [1, 2, 3]\n\n    Output:\n    [[1, 2], [1, 3], [2, 3]]\n    \"\"\"\n\n    def backtrack(curr_comb: List[int], start: int) -> None:\n        if len(curr_comb) == n:\n            result.append(curr_comb.copy())\n            return\n        for i in range(start, len(nums)):\n            curr_comb.append(nums[i])\n            backtrack(curr_comb, i + 1)\n            curr_comb.pop()\n\n    result = []\n    backtrack([], 0)\n    return result\n\ndef g():\n    n = 2\n    nums = [1, 2, 3]\n    return (n, nums)\n\nassert f(*g()) == [[1, 2], [1, 3], [2, 3]]\n",
        "idx_generation": 283,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, r: int, modulus: int) -> int:\n    \"\"\"\n    Calculate the value of nCr (combination) modulo a given modulus.\n    \"\"\"\n    if r > n - r:\n        r = n - r\n\n    numerator = 1\n    denominator = 1\n\n    for i in range(r):\n        numerator = (numerator * (n - i)) % modulus\n        denominator = (denominator * (i + 1)) % modulus\n\n    return (numerator * pow(denominator, modulus - 2, modulus)) % modulus\n\ndef g(n: int = 10, r: int = 3, modulus: int = 1000000007) -> Tuple[int, int, int]:\n    \"\"\"\n    Generate values for n, r, and modulus for the function f.\n    \"\"\"\n    return n, r, modulus\n\nassert f(*g()) == 120\n",
        "idx_generation": 286,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value, determine if there exists a pair of elements in the array whose sum is equal to the target value.\n    \n    Args:\n    - arr: A list of integers in ascending order.\n    - target: The target sum value.\n    \n    Returns:\n    - A boolean value indicating whether there exists a pair of elements in the array whose sum is equal to the target value.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g() -> Tuple[List[int], int]:\n    arr = [1, 2, 3, 4, 5, 6]\n    target = 8\n    return arr, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 464,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the index of the target value using binary search.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output:\n    2\n\n    Explanation:\n    The target value 5 is found at index 2 in the list [1, 3, 5, 7, 9].\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    return ([1, 3, 5, 7, 9], 5)\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 475,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers, find two numbers such that they add up to a specific target number.\n    Return the indices of the two numbers in the array.\n\n    Sample Input:\n    nums = [2, 7, 11, 15], target = 9\n\n    Sample Output:\n    [0, 1]\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 140,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nimport math\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given an array of integers 'arr' and a target value 'target', find if there are three integers in the\n    array whose sum is equal to the target value.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 9\n\n    Output:\n    True (since 2 + 3 + 4 = 9)\n    \"\"\"\n    arr.sort()\n    n = len(arr)\n    \n    for i in range(n - 2):\n        left = i + 1\n        right = n - 1\n        \n        while left < right:\n            current_sum = arr[i] + arr[left] + arr[right]\n            \n            if current_sum == target:\n                return True\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    \n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5], 9\n\nassert f(*g())\n",
        "idx_generation": 29,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return the list sorted in non-decreasing order using the merge sort algorithm.\n\n    Example:\n    nums = [6, 3, 8, 2, 10]\n\n    Output:\n    [2, 3, 6, 8, 10]\n\n    Hint: Use recursion to divide the list into smaller subarrays and merge them back together in sorted order.\n    \"\"\"\n\n    def merge(left, right):\n        merged = []\n        i, j = 0, 0\n\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n\n        while i < len(left):\n            merged.append(left[i])\n            i += 1\n\n        while j < len(right):\n            merged.append(right[j])\n            j += 1\n\n        return merged\n\n    def merge_sort(nums):\n        if len(nums) <= 1:\n            return nums\n\n        mid = len(nums) // 2\n        left = merge_sort(nums[:mid])\n        right = merge_sort(nums[mid:])\n        return merge(left, right)\n\n    return merge_sort(nums)\n\ndef g(nums=[6, 3, 8, 2, 10]):\n    return (nums,)\n\nassert f(*g()) == [2, 3, 6, 8, 10]\n",
        "idx_generation": 367,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum area of a rectangle formed by the height of the bars in the histogram.\n\n    Args:\n    nums (List[int]): The list of integers representing the heights of the bars.\n\n    Returns:\n    int: The maximum area of the rectangle.\n    \"\"\"\n    n = len(nums)\n    stack = []\n    max_area = 0\n    i = 0\n\n    while i < n:\n        if not stack or nums[i] >= nums[stack[-1]]:\n            stack.append(i)\n            i += 1\n        else:\n            top = stack.pop()\n            width = i if not stack else i - stack[-1] - 1\n            area = nums[top] * width\n            max_area = max(max_area, area)\n\n    while stack:\n        top = stack.pop()\n        width = i if not stack else n - stack[-1] - 1\n        area = nums[top] * width\n        max_area = max(max_area, area)\n\n    return max_area\n\ndef g(nums=[2, 1, 5, 6, 2, 3]):\n    \"\"\"\n    Generate a list of integers for finding the maximum area of a histogram.\n    \"\"\"\n    return (nums,)\n\nassert f(*g()) == 10\n",
        "idx_generation": 396,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given an integer n, find the kth largest element in the range [1, n].\n\n    Args:\n    - n: An integer.\n    - k: An integer.\n\n    Returns:\n    - The kth largest element in the range [1, n].\n    \"\"\"\n    def count_bits(num):\n        count = 0\n\n        while num:\n            count += num & 1\n            num >>= 1\n\n        return count\n\n    def compare(x, y):\n        count_x = count_bits(x)\n        count_y = count_bits(y)\n\n        if count_x != count_y:\n            return count_x - count_y\n        else:\n            return x - y\n\n    nums = list(range(1, n+1))\n    nums.sort(key=lambda x: compare(x, k-1))\n\n    return nums[k-1]\n\ndef g() -> Tuple[int, int]:\n    n = 10\n    k = 4\n    return (n, k)\n\nassert f(*g()) == 8\n\n",
        "idx_generation": 348,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a sorted array of integers, find the missing number in the array.\n    \n    Example:\n    arr = [1, 2, 3, 5, 6]\n    \n    Output:\n    4 (as 4 is the missing number in the array)\n    \"\"\"\n    n = len(arr) + 1\n    total_sum = (n * (n + 1)) // 2\n    arr_sum = sum(arr)\n    missing_number = total_sum - arr_sum\n    return missing_number\n\ndef g():\n    return [1, 2, 3, 5, 6]\n\nassert f(g()) == 4\n",
        "idx_generation": 178,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of perfect squares less than or equal to n.\n\n    Example:\n    n = 10\n    There are 3 perfect squares less than or equal to 10: 1, 4, and 9.\n    Return 3.\n\n    Constraints:\n    - The input integer n will always be greater than or equal to 0.\n    \"\"\"\n    count = 0\n    i = 1\n\n    while i * i <= n:\n        count += 1\n        i += 1\n\n    return count\n\ndef g() -> int:\n    return 16\n\nassert f(g()) == 4\n\n",
        "idx_generation": 453,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the number of unique paths from the top-left to the bottom-right cell,\n    where you can only move down or right.\n\n    Example:\n    Input: grid = [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]\n    Output: 2\n    Explanation:\n    The unique paths are: [0, 0, 0, 0, 0], [0, 0, 0, 1, 0].\n    Therefore, the number of unique paths is 2.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1\n    \n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                continue\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n    \n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    return [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]\n\nassert f(g()) == 2\n\n",
        "idx_generation": 365,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid filled with non-negative integers, find the minimum path sum from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    Input:\n    [\n      [1,3,1],\n      [1,5,1],\n      [4,2,1]\n    ]\n    Output: 7\n    Explanation: Because the path 1\u21923\u21921\u21921\u21921 minimizes the sum.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    \n    # Create a dp table to store the minimum path sum for each cell\n    dp = [[0] * n for _ in range(m)]\n    \n    # Initialize the first row and first column of the dp table\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    # Fill in the rest of the dp table using dynamic programming\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    # Return the minimum path sum for the bottom-right corner\n    return dp[m-1][n-1]\n\ndef g(grid = [[1,3,1],[1,5,1],[4,2,1]]):\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 306,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list is a permutation of the first n natural numbers, where n is the length of the list.\"\"\"\n\n    nums.sort()\n    n = len(nums)\n    for i in range(n):\n        if nums[i] != i + 1:\n            return False\n    return True\n\ndef g():\n    return [3, 2, 1]\n\nassert f(g()) == True\n",
        "idx_generation": 165,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"\n    Calculate the factorial of a given number.\n    \"\"\"\n    if num == 0:\n        return 1\n    else:\n        return num * f(num - 1)\n\ndef g():\n    return 5\n\nassert f(g()) == 120\n",
        "idx_generation": 74,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\nclass Stack:\n    def __init__(self):\n        self.stack = []\n\n    def push(self, x):\n        self.stack.append(x)\n\n    def pop(self):\n        if self.stack:\n            return self.stack.pop()\n        else:\n            return None\n\n    def top(self):\n        if self.stack:\n            return self.stack[-1]\n        else:\n            return None\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string 's' containing only parentheses '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n    An input string is valid if:\n    1. Open brackets must be closed by the same type of brackets.\n    2. Open brackets must be closed in the correct order.\n\n    Example:\n    s = \"([]){}\"\n\n    Output:\n    True\n\n    Explanation:\n    The input string is valid because all open brackets are correctly closed in the right order.\n    \"\"\"\n\n    stack = Stack()\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n\n    for char in s:\n        if char in mapping:\n            if stack.is_empty() or stack.pop() != mapping[char]:\n                return False\n        else:\n            stack.push(char)\n\n    return stack.is_empty()\n\ndef g() -> str:\n    s = \"([]){}\"\n    return s\n\nassert f(g()) == True\n\n",
        "idx_generation": 496,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the string s can be split into a list of words from a given dictionary.\"\"\"\n    dictionary = {'apple', 'banana', 'cherry', 'date'}\n    n = len(s)\n    if n == 0:\n        return True\n    for i in range(1, n+1):\n        if s[:i] in dictionary and f(s[i:]):\n            return True\n    return False\n\ndef g(s = \"applebananacherry\"):\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 131,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Find two numbers in the given list that add up to the target value.\n    \"\"\"\n\n    num_map = {}\n\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[nums[i]] = i\n\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 305,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Find the number of distinct subsets of arr that have a sum divisible by 3.\n    Return True if the count is greater than 0, False otherwise.\n    \"\"\"\n    n = len(arr)\n    count = 0\n\n    for i in range(1, 1 << n):\n        subset_sum = sum(arr[j] for j in range(n) if (i & (1 << j)) > 0)\n        if subset_sum % 3 == 0:\n            count += 1\n\n    return count > 0\n\n\ndef g(arr = [1, 2, 3, 4, 5]):\n    \"\"\"\n    Return the input array.\n    \"\"\"\n    return arr\n\nassert f(g()) == True\n",
        "idx_generation": 87,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all prime numbers less than or equal to n.\n\n    Example:\n    n = 10\n\n    Output:\n    17 (since the prime numbers less than or equal to 10 are 2, 3, 5, 7 and their sum is 17)\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    prime_sum = 0\n    for i in range(2, n + 1):\n        if is_prime(i):\n            prime_sum += i\n\n    return prime_sum\n\ndef g(n: int = 10) -> int:\n    \"\"\"Generate a positive integer.\"\"\"\n    return n\n\nassert f(g()) == 17\n\n\n",
        "idx_generation": 196,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, determine the length of the longest substring without repeating characters.\n\n    Args:\n    - s: A string\n\n    Returns:\n    - The length of the longest substring without repeating characters\n\n    Example:\n    s = \"abcabcbb\"\n    The longest substring without repeating characters is \"abc\", so the output should be 3.\n    \"\"\"\n    max_len = 0\n    start = 0\n    char_dict = {}\n    for i, char in enumerate(s):\n        if char in char_dict and start <= char_dict[char]:\n            start = char_dict[char] + 1\n        else:\n            max_len = max(max_len, i - start + 1)\n        char_dict[char] = i\n    return max_len\n\ndef g():\n    s = \"abcabcbb\"\n    return s\n\nassert f(g()) == 3\n",
        "idx_generation": 329,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom functools import reduce\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of positive integers, find the product of all the elements except the current element.\n\n    Example:\n    arr = [1, 2, 3, 4]\n    Output: [24, 12, 8, 6]\n    \"\"\"\n\n    n = len(arr)\n    prefix_products = [0] * n\n    suffix_products = [0] * n\n    output = [0] * n\n\n    prefix_products[0] = arr[0]\n    suffix_products[n-1] = arr[n-1]\n\n    for i in range(1, n):\n        prefix_products[i] = prefix_products[i-1] * arr[i]\n\n    for i in range(n-2, -1, -1):\n        suffix_products[i] = suffix_products[i+1] * arr[i]\n\n    for i in range(n):\n        if i == 0:\n            output[i] = suffix_products[i+1]\n        elif i == n-1:\n            output[i] = prefix_products[i-1]\n        else:\n            output[i] = prefix_products[i-1] * suffix_products[i+1]\n\n    return output\n\ndef g():\n    return [1, 2, 3, 4]\n\nassert f(g()) == [24, 12, 8, 6]\n",
        "idx_generation": 173,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all positive integers less than n that are divisible by 3 or 5.\n    \"\"\"\n    total = 0\n    for i in range(1, n):\n        if i % 3 == 0 or i % 5 == 0:\n            total += i\n    return total\n\ndef g():\n    n = 20\n    return n\n\nassert f(g()) == 78\n",
        "idx_generation": 470,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "import math\nfrom typing import*\ndef f(expression: str) -> bool:\n    \"\"\"\n    Given a string representing a mathematical expression, determine if the expression is balanced.\n    An expression is balanced if it contains equal number of opening and closing brackets.\n    Return True if the expression is balanced, False otherwise.\n    \"\"\"\n    stack = []\n    for char in expression:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g():\n    expression = \"((2+3)*4)/5\"\n    return expression\n\nassert f(g()) == True\n",
        "idx_generation": 143,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the minimum path sum from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum path is 1 -> 3 -> 1 -> 1 -> 1, which gives a total sum of 7.\n\n    Hint: Use dynamic programming to solve this problem.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 473,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(string: str) -> List[str]:\n    \"\"\"\n    Given a string, return all possible permutations of the characters in the string.\n\n    Example:\n    Input: \"abc\"\n    Output: [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n\n    Hint: Use recursion to generate all possible permutations.\n    \"\"\"\n    def backtrack(string, permutation, visited, result):\n        if len(permutation) == len(string):\n            result.append(\"\".join(permutation))\n            return\n\n        for i in range(len(string)):\n            if visited[i]:\n                continue\n\n            visited[i] = True\n            permutation.append(string[i])\n            backtrack(string, permutation, visited, result)\n            visited[i] = False\n            permutation.pop()\n\n    visited = [False] * len(string)\n    permutation = []\n    result = []\n\n    backtrack(string, permutation, visited, result)\n\n    return result\n\ndef g(string=\"abc\"):\n    return string\n\nassert f(g()) == [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n\n",
        "idx_generation": 416,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of integers, determine if it forms a rectangle.\n    A rectangle is a quadrilateral with four right angles.\n\n    Example:\n    grid = [[1, 2, 3, 4],\n            [5, 6, 7, 8],\n            [9, 10, 11, 12]]\n\n    Output:\n    True\n\n    Explanation:\n    The grid forms a rectangle, as all rows have the same length and all columns have the same length.\n    \"\"\"\n\n    # Check if the grid is empty\n    if len(grid) == 0 or len(grid[0]) == 0:\n        return False\n\n    # Get the length of the first row\n    row_length = len(grid[0])\n\n    # Check if all rows have the same length\n    for row in grid:\n        if len(row) != row_length:\n            return False\n\n    # Check if all columns have the same length\n    col_length = len(grid)\n    for col in zip(*grid):\n        if len(col) != col_length:\n            return False\n\n    return True\n\ndef g():\n    grid = [[1, 2, 3, 4],\n            [5, 6, 7, 8],\n            [9, 10, 11, 12]]\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 185,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Determine if there exists a path from the top-left corner to the bottom-right corner of the grid, \n    where each cell can only be traversed if its value is greater than or equal to 0.\n    \"\"\"\n    def dfs(i: int, j: int) -> bool:\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\n            return True\n        if i >= len(grid) or j >= len(grid[0]) or grid[i][j] < 0:\n            return False\n        return dfs(i + 1, j) or dfs(i, j + 1)\n    \n    return dfs(0, 0)\n\ndef g():\n    \"\"\"\n    Generate a grid with random values.\n    \"\"\"\n    return [[1, 2, 3], [4, -1, 2], [3, 4, 5]]\n\nassert f(g()) == True\n",
        "idx_generation": 106,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n\n    Output:\n    3\n\n    Explanation:\n    The longest substring without repeating characters is \"abc\", which has a length of 3.\n\n    Hint: Use a sliding window approach to find the longest substring without repeating characters.\n    \"\"\"\n\n    if len(s) == 0:\n        return 0\n\n    max_length = 0\n    start = 0\n    char_map = {}\n\n    for end in range(len(s)):\n        if s[end] in char_map:\n            start = max(start, char_map[s[end]] + 1)\n        char_map[s[end]] = end\n        max_length = max(max_length, end - start + 1)\n\n    return max_length\n\ndef g():\n    return \"abcabcbb\"\n\nassert f(g()) == 3\n",
        "idx_generation": 474,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if they are isomorphic.\n\n    Two strings are isomorphic if the characters in s can be replaced to get t.\n\n    Parameters:\n    s (str): The first input string.\n    t (str): The second input string.\n\n    Returns:\n    bool: True if the strings are isomorphic, False otherwise.\n    \"\"\"\n    if len(s) != len(t):\n        return False\n\n    map_s = {}\n    map_t = {}\n\n    for i in range(len(s)):\n        if s[i] in map_s:\n            if map_s[s[i]] != t[i]:\n                return False\n        else:\n            map_s[s[i]] = t[i]\n\n        if t[i] in map_t:\n            if map_t[t[i]] != s[i]:\n                return False\n        else:\n            map_t[t[i]] = s[i]\n\n    return True\n\ndef g(s=\"egg\", t=\"add\"):\n    \"\"\"\n    Generate two strings.\n\n    Returns:\n    Tuple[str, str]: Two strings.\n    \"\"\"\n    return s, t\n\nassert f(*g()) == True\n",
        "idx_generation": 489,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(string: str, k: int) -> bool:\n    \"\"\"\n    Given a string and an integer k, determine if it is possible to split the string into k non-empty substrings such that each substring is a palindrome.\n    \"\"\"\n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    def backtrack(string, k, start, curr):\n        if k == 0:\n            return True\n        \n        if start == len(string):\n            return False\n        \n        for end in range(start, len(string)):\n            substr = string[start:end+1]\n            if is_palindrome(substr):\n                curr.append(substr)\n                if backtrack(string, k-1, end+1, curr):\n                    return True\n                curr.pop()\n        \n        return False\n    \n    return backtrack(string, k, 0, [])\n\ndef g(string = \"abcbaabcba\", k = 3):\n    return string, k\n\nassert f(*g())\n",
        "idx_generation": 76,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number is a power of 2.\"\"\"\n    return n & (n - 1) == 0\n\ndef g():\n    return 16\n\nassert f(g()) == True\n",
        "idx_generation": 60,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the sum of all positive integers less than or equal to n.\n\n    Args:\n    - n: An integer.\n\n    Returns:\n    - The sum of all positive integers less than or equal to n.\n    \"\"\"\n    if n <= 0:\n        return 0\n    return (n * (n + 1)) // 2\n\ndef g() -> int:\n    \"\"\"\n    Generate a random positive integer.\n    \"\"\"\n    n = 10\n    return n\n\nassert f(g()) == 55\n",
        "idx_generation": 365,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine if a given integer 'n' is a power of two.\n    \"\"\"\n    if n <= 0:\n        return False\n    while n > 1:\n        if n % 2 != 0:\n            return False\n        n = n // 2\n    return True\n\ndef g(n: int) -> int:\n    \"\"\"\n    Generate an integer 'n' that is a power of two.\n    \"\"\"\n    return 2 ** n\n\nn = 8\nassert f(g(n))\n",
        "idx_generation": 6,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the minimum cost to reach the bottom-right cell from the top-left cell\n    by moving only right or down.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum cost path is 1 -> 3 -> 1 -> 1 -> 1, with a total cost of 7.\n\n    Hint: Use dynamic programming to calculate the minimum cost for each cell.\n    \"\"\"\n\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[m - 1][n - 1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid with random integers.\n    \"\"\"\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 402,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of positive integers not exceeding n that have the same number of 1 bits in their binary representation as n.\n\n    Sample Input:\n    n = 5\n\n    Sample Output:\n    2\n\n    Explanation:\n    There are two positive integers not exceeding 5 that have the same number of 1 bits as 5: 3 and 5.\n    \"\"\"\n    def count_ones(num: int) -> int:\n        count = 0\n        while num:\n            count += 1\n            num &= num - 1\n        return count\n\n    count = 0\n    for i in range(n + 1):\n        if count_ones(i) == count_ones(n):\n            count += 1\n    return count\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 2\n",
        "idx_generation": 402,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef f(root: TreeNode) -> bool:\n    \"\"\"\n    Given the root of a binary tree, determine if it is a valid binary search tree (BST).\n    A valid BST is defined as follows:\n    - The left subtree of a node contains only nodes with keys less than the node's key.\n    - The right subtree of a node contains only nodes with keys greater than the node's key.\n    - Both the left and right subtrees must also be binary search trees.\n\n    Args:\n    - root: The root of the binary tree.\n\n    Returns:\n    - True if the binary tree is a valid BST, False otherwise.\n\n    Example:\n    f(TreeNode(2, TreeNode(1), TreeNode(3))) returns True\n    f(TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6)))) returns False\n    \"\"\"\n\n    def is_valid_bst(node, min_val, max_val):\n        if not node:\n            return True\n\n        if node.val <= min_val or node.val >= max_val:\n            return False\n\n        return is_valid_bst(node.left, min_val, node.val) and is_valid_bst(node.right, node.val, max_val)\n\n    return is_valid_bst(root, float('-inf'), float('inf'))\n\n\ndef g() -> TreeNode:\n    \"\"\"\n    Generate a binary tree.\n\n    Returns:\n    - The generated binary tree.\n\n    Example:\n    g() returns TreeNode(2, TreeNode(1), TreeNode(3))\n    \"\"\"\n\n    return TreeNode(2, TreeNode(1), TreeNode(3))\n\nassert f(g()) == True\n",
        "idx_generation": 368,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom collections import deque\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef f(root: Node) -> List[int]:\n    \"\"\"Perform a level order traversal on a binary tree\"\"\"\n    if not root:\n        return []\n\n    result = []\n    queue = deque([root])\n\n    while queue:\n        level_size = len(queue)\n        current_level = []\n        for _ in range(level_size):\n            node = queue.popleft()\n            current_level.append(node.val)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        result.append(current_level)\n\n    return result\n\ndef g():\n    # Creating a binary tree\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    return root\n\nassert f(g()) == [[1], [2, 3], [4, 5]]\n",
        "idx_generation": 72,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid represented as a 2D list of integers, check if it is possible to reach the bottom-right cell from the top-left cell by only moving down or right, and the sum of numbers encountered along the path is greater than or equal to a target value.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1] >= 10\ndef g(grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return grid\nassert f(g()) == True\n",
        "idx_generation": 32,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: List[List[int]], start=0, end=1) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, determine if there is a path from start to end.\n    Return True if a path exists, False otherwise.\n    \"\"\"\n    visited = [False] * len(graph)\n    return dfs(graph, start, end, visited)\n\ndef dfs(graph, node, end, visited):\n    \"\"\"\n    Depth-first search helper function to check if there is a path from start to end.\n    \"\"\"\n    if node == end:\n        return True\n    visited[node] = True\n    for neighbor in range(len(graph[node])):\n        if graph[node][neighbor] == 1 and not visited[neighbor]:\n            if dfs(graph, neighbor, end, visited):\n                return True\n    return False\n\ndef g(graph=[[0, 1, 0, 0, 0],\n             [0, 0, 1, 0, 0],\n             [0, 0, 0, 1, 0],\n             [0, 0, 0, 0, 1],\n             [0, 0, 0, 0, 0]]):\n    \"\"\"\n    Generate a directed graph represented as an adjacency matrix.\n    \"\"\"\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 61,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, obstacles: List[List[int]]) -> int:\n    \"\"\"\n    Robot in a Grid\n\n    Given a grid of size m x n, where some cells are blocked and cannot be visited, find the number of unique paths\n    from the top-left corner to the bottom-right corner, moving only right or down.\n\n    The robot can only move to the right or down, and cannot move through blocked cells.\n\n    Example:\n    n = 3\n    obstacles = [[0, 0, 0],\n                 [0, 1, 0],\n                 [0, 0, 0]]\n    output: 2\n\n    Explanation: There are two possible paths from the top-left corner to the bottom-right corner:\n    1. Right -> Right -> Down -> Down\n    2. Down -> Down -> Right -> Right\n    \"\"\"\n    m = len(obstacles)\n    if m == 0:\n        return 0\n    n = len(obstacles[0])\n    if n == 0:\n        return 0\n    if obstacles[0][0] == 1 or obstacles[m-1][n-1] == 1:\n        return 0\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1\n\n    for i in range(m):\n        for j in range(n):\n            if obstacles[i][j] == 0:\n                if i > 0 and obstacles[i-1][j] == 0:\n                    dp[i][j] += dp[i-1][j]\n                if j > 0 and obstacles[i][j-1] == 0:\n                    dp[i][j] += dp[i][j-1]\n\n    return dp[m-1][n-1]\n\n\ndef g(n = 3, obstacles = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]):\n    return n, obstacles\n\n\nassert f(*g()) == 2\n",
        "idx_generation": 451,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Given two integers n and k, determine if there exists a set of k numbers such that the sum of their factorials is equal to n.\n\n    Sample input:\n    n = 145, k = 3\n\n    Sample output:\n    True\n\n    Explanation: The factorials of the numbers 1, 2, and 4 sum up to 145, so the answer is True.\n    \"\"\"\n    def factorial(num):\n        if num <= 1:\n            return 1\n        else:\n            return num * factorial(num - 1)\n\n    def find_combinations(n, k):\n        if k == 0:\n            return [[]]\n        if n == 0:\n            return []\n        if n < k:\n            return []\n        combinations = []\n        for i in range(1, n + 1):\n            if factorial(i) <= n:\n                sub_combinations = find_combinations(n - factorial(i), k - 1)\n                for sub_combination in sub_combinations:\n                    combinations.append([i] + sub_combination)\n        return combinations\n\n    combinations = find_combinations(n, k)\n    return len(combinations) > 0\ndef g(n = 145, k = 3):\n    return n, k\nassert f(*g())\n",
        "idx_generation": 63,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> List[str]:\n    \"\"\"\n    Given a string s, return a list of all possible permutations of the characters in the string.\n\n    Example:\n    s = \"abc\"\n    Possible permutations are [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n\n    Return a list of all possible permutations of the characters in the string.\n    \"\"\"\n    def backtrack(curr_str: str, remaining_chars: List[str], result: List[str]):\n        if not remaining_chars:\n            result.append(curr_str)\n            return\n        \n        for i in range(len(remaining_chars)):\n            new_str = curr_str + remaining_chars[i]\n            new_remaining = remaining_chars[:i] + remaining_chars[i+1:]\n            backtrack(new_str, new_remaining, result)\n\n    result = []\n    backtrack(\"\", list(s), result)\n    return result\n\ndef g() -> str:\n    return \"abc\"\n\nassert f(g()) == [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n",
        "idx_generation": 302,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two positive integers n and k, compute the number of combinations (n choose k).\n\n    \"\"\"\n    def factorial(n: int) -> int:\n        if n == 0 or n == 1:\n            return 1\n        return n * factorial(n-1)\n\n    return factorial(n) // (factorial(k) * factorial(n-k))\n\ndef g():\n    return 5, 2\n\nassert f(*g()) == 10\n",
        "idx_generation": 300,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order using the bubble sort algorithm.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The sorted list of integers.\n\n    Example:\n    nums = [5, 2, 8, 3, 1]\n\n    Output:\n    [1, 2, 3, 5, 8]\n    \"\"\"\n    n = len(nums)\n\n    for i in range(n-1):\n        for j in range(n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n\n    return nums\n\ndef g():\n    nums = [5, 2, 8, 3, 1]\n    return nums\n\nassert f(g()) == [1, 2, 3, 5, 8]\n",
        "idx_generation": 466,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Sort the given list of integers using bubble sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    return nums\n    \ndef g():\n    return [5, 2, 8, 6, 1, 9, 3]\n\nassert f(g()) == [1, 2, 3, 5, 6, 8, 9]\n",
        "idx_generation": 153,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums sorted in ascending order, and a target value, find two numbers in the array\n    that add up to the target value. Return their indices.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1 (2 and 7) add up to the target value 9.\n\n    Hint: Consider using two pointers to traverse the array from both ends towards the middle.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return [left, right]\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 30,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums', find the next greater element for each element in the list.\n    The next greater element for an element x is the first greater element to its right in the list.\n    If there is no such element, consider it as -1.\n\n    Return a list of the next greater elements.\n\n    Example:\n    nums = [4, 5, 2, 25]\n\n    Output:\n    [5, 25, 25, -1]\n\n    Explanation:\n    For the element 4, the next greater element is 5.\n    For the element 5, the next greater element is 25.\n    For the element 2, there is no greater element to its right, so it is -1.\n    For the element 25, there is no greater element to its right, so it is -1.\n\n    Hint: Use a stack to keep track of the next greater elements.\n    \"\"\"\n    stack = []\n    result = [-1] * len(nums)\n\n    for i in range(len(nums)):\n        while stack and nums[i] > nums[stack[-1]]:\n            index = stack.pop()\n            result[index] = nums[i]\n        stack.append(i)\n\n    return result\n\ndef g(nums=[4, 5, 2, 25]):\n    return nums\n\nassert f(g()) == [5, 25, 25, -1]\n\n",
        "idx_generation": 378,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(expression: str) -> int:\n    \"\"\"\n    Given an expression string consisting of digits and operators (+, -, *, /), evaluate the expression and return the result.\n\n    Example:\n    expression = \"3 + 4 * 2 - 1\"\n\n    Output:\n    10\n\n    \"\"\"\n\n    def calculate(expression):\n        stack = []\n        current_number = 0\n        operator = '+'\n\n        for i in range(len(expression)):\n            if expression[i].isdigit():\n                current_number = (current_number * 10) + int(expression[i])\n\n            if (not expression[i].isdigit() and not expression[i].isspace()) or i == len(expression) - 1:\n                if operator == '+':\n                    stack.append(current_number)\n                elif operator == '-':\n                    stack.append(-current_number)\n                elif operator == '*':\n                    stack.append(stack.pop() * current_number)\n                elif operator == '/':\n                    stack.append(int(stack.pop() / current_number))\n\n                operator = expression[i]\n                current_number = 0\n\n        return sum(stack)\n\n    return calculate(expression)\n\ndef g():\n    expression = \"3 + 4 * 2 - 1\"\n    return expression\n\nassert f(g()) == 10\n\n",
        "idx_generation": 423,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the maximum XOR value between two numbers in the array.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value between two numbers in the array is achieved by XORing 5 and 25, resulting in 28.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n        for num in nums:\n            prefix_set.add(num & mask)\n        max_candidate = max_xor | (1 << i)\n        for prefix in prefix_set:\n            if max_candidate ^ prefix in prefix_set:\n                max_xor = max_candidate\n                break\n    return max_xor\n\ndef g(nums=[3, 10, 5, 25, 2, 8]):\n    return nums\n\nassert f(g()) == 28\n\n",
        "idx_generation": 477,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, return True if the target value is present in the list, False otherwise.\n    \"\"\"\n    start = 0\n    end = len(arr) - 1\n\n    while start <= end:\n        mid = (start + end) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            start = mid + 1\n        else:\n            end = mid - 1\n\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 7\n\nassert f(*g()) == True\n",
        "idx_generation": 187,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(adj_list: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given an adjacency list representing a directed graph and two nodes start and end, determine whether there is a path from start to end.\n\n    Example:\n    adj_list = [[1, 2], [3], [4], [], [5], []]\n    start = 0\n    end = 5\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 0 to node 5 in the directed graph.\n\n    Hint: Use depth-first search (DFS) to traverse the graph and check if there is a path from start to end.\n    \"\"\"\n\n    visited = [False] * len(adj_list)\n\n    def dfs(node):\n        if node == end:\n            return True\n\n        visited[node] = True\n\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n\n        return False\n\n    return dfs(start)\n\ndef g():\n    adj_list = [[1, 2], [3], [4], [], [5], []]\n    start = 0\n    end = 5\n    return adj_list, start, end\n\nassert f(*g()) == True\n\n",
        "idx_generation": 366,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid, count the number of connected components in the grid.\n    Each cell in the grid can be connected to its adjacent cells (up, down, left, and right).\n    \"\"\"\n    def dfs(i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:\n            return\n        grid[i][j] = 0\n        dfs(i+1, j)\n        dfs(i-1, j)\n        dfs(i, j+1)\n        dfs(i, j-1)\n\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                dfs(i, j)\n                count += 1\n\n    return count\n\ndef g():\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 3\n\n",
        "idx_generation": 311,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if it is a permutation of the range from 1 to n, where n is the length of the list.\n    Return True if it is a permutation, False otherwise.\n\n    Example:\n    nums = [3, 1, 2]\n\n    Output:\n    True\n\n    Explanation:\n    The list [3, 1, 2] is a permutation of the range from 1 to 3.\n\n    Hint: Sort the list and check if it is equal to the range from 1 to n.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return nums == list(range(1, n+1))\n\ndef g(nums=[3, 1, 2]):\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 270,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Find if there exists a subset of the given list that adds up to the target\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if nums[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n    return dp[n][target]\n\ndef g(nums: List[int], target: int):\n    return nums, target\n\nassert f(*g([2, 4, 6, 8], 10))\n",
        "idx_generation": 75,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the list.\n\n    Args:\n    - nums: A list of integers.\n    - target: The target value.\n\n    Returns:\n    - A list containing the indices of the two numbers that add up to the target.\n    \"\"\"\n    complement_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complement_map:\n            return [complement_map[complement], i]\n        complement_map[num] = i\n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9) -> List[int]:\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 497,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if n is a perfect square and its square root is a palindrome.\"\"\"\n    if n < 0:\n        return False\n    sqrt = int(n ** 0.5)\n    return sqrt * sqrt == n and str(sqrt) == str(sqrt)[::-1]\n\ndef g() -> int:\n    i = 0\n    while True:\n        if f(i):\n            return i\n        i += 1\n\nassert f(g()) == True\n",
        "idx_generation": 144,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest consecutive sequence of elements in the list.\n    A consecutive sequence is a sequence of elements in which each element appears exactly once and follows the previous element by a difference of 1.\n\n    Example:\n    nums = [100, 4, 200, 1, 3, 2]\n\n    Output:\n    4 (the longest consecutive sequence is [1, 2, 3, 4])\n    \"\"\"\n    if not nums:\n        return 0\n    \n    nums_set = set(nums)\n    max_length = 0\n    \n    for num in nums:\n        if num - 1 not in nums_set:\n            curr_num = num\n            curr_length = 1\n            \n            while curr_num + 1 in nums_set:\n                curr_num += 1\n                curr_length += 1\n            \n            max_length = max(max_length, curr_length)\n    \n    return max_length\n\ndef g() -> List[int]:\n    return [100, 4, 200, 1, 3, 2]\n\nassert f(g()) == 4\n",
        "idx_generation": 329,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the number of distinct pairs (a, b) such that a + b is divisible by 3.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    \n    Output:\n    12\n    \n    Explanation:\n    The distinct pairs (a, b) such that a + b is divisible by 3 are:\n    (1, 2), (1, 5), (1, 8), (2, 1), (2, 4), (2, 7), (3, 6), (4, 2), (5, 1), (5, 4), (5, 7), (6, 3)\n    \"\"\"\n\n    count = 0\n    remainder_count = [0, 0, 0]\n\n    for num in nums:\n        remainder_count[num % 3] += 1\n\n    count += (remainder_count[0] * (remainder_count[0] - 1)) // 2  # Count pairs from the same remainder group\n    count += remainder_count[1] * remainder_count[2]  # Count pairs from different remainder groups\n\n    return count\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g()) == 12\n",
        "idx_generation": 94,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of unique BSTs (binary search trees) that store values from 1 to n.\n    \"\"\"\n    if n <= 1:\n        return 1\n    \n    dp = [0] * (n+1)\n    dp[0] = 1\n    dp[1] = 1\n    \n    # Dynamic programming approach\n    for i in range(2, n+1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i-j-1]\n    \n    return dp[n]\n\ndef g(n: int):\n    return n\n\nassert f(g(4)) == 14\n\n",
        "idx_generation": 200,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of all the previous elements in the original list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    [1, 3, 6, 10, 15]\n    \"\"\"\n    result = []\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        result.append(current_sum)\n    return result\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [1, 3, 6, 10, 15]\n",
        "idx_generation": 360,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, return True if there exists a subarray in the list that sums up to zero.\n\n    Example:\n    nums = [4, -2, -3, 1, 6]\n    \n    Output:\n    True\n    \"\"\"\n\n    prefix_sum = 0\n    prefix_sums = set()\n\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum in prefix_sums or prefix_sum == 0:\n            return True\n        prefix_sums.add(prefix_sum)\n\n    return False\n\ndef g() -> List[int]:\n    return [4, -2, -3, 1, 6]\n\nassert f(g()) == True\n",
        "idx_generation": 180,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a list of the square roots of the positive even numbers.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - A list of square roots of the positive even numbers in the input list.\n\n    Example:\n    Input:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    Output:\n    [1.4142135623730951, 2.0, 2.449489742783178, 2.8284271247461903, 3.1622776601683795]\n\n    Explanation:\n    The positive even numbers in the input list are [2, 4, 6, 8, 10].\n    The square roots of these numbers are [1.4142135623730951, 2.0, 2.449489742783178, 2.8284271247461903, 3.1622776601683795].\n    \"\"\"\n\n    even_nums = [num for num in nums if num % 2 == 0 and num > 0]\n    square_roots = [math.sqrt(num) for num in even_nums]\n\n    return square_roots\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return nums\n\nassert f(g()) == [1.4142135623730951, 2.0, 2.449489742783178, 2.8284271247461903, 3.1622776601683795]\n",
        "idx_generation": 471,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Find the maximum area of a rectangle in a binary matrix.\"\"\"\n    if not matrix:\n        return 0\n    \n    m, n = len(matrix), len(matrix[0])\n    heights = [0] * n\n    max_area = 0\n    \n    for i in range(m):\n        for j in range(n):\n            if matrix[i][j] == 0:\n                heights[j] = 0\n            else:\n                heights[j] += 1\n                \n        max_area = max(max_area, calculate_area(heights))\n        \n    return max_area\n    \ndef calculate_area(heights: List[int]) -> int:\n    stack = [-1]\n    max_area = 0\n    \n    for i in range(len(heights)):\n        while stack[-1] != -1 and heights[stack[-1]] >= heights[i]:\n            h = heights[stack.pop()]\n            w = i - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        stack.append(i)\n        \n    while stack[-1] != -1:\n        h = heights[stack.pop()]\n        w = len(heights) - stack[-1] - 1\n        max_area = max(max_area, h * w)\n        \n    return max_area\n    \ndef g():\n    return [[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]\n\nassert f(g()) == 6\n",
        "idx_generation": 153,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the nth Fibonacci number.\n\n    Example:\n    n = 6\n\n    Output:\n    8\n\n    Explanation:\n    The 6th Fibonacci number is 8.\n\n    Hint: Use a recursive approach to calculate the Fibonacci numbers.\n    \"\"\"\n\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return f(n-1) + f(n-2)\n\ndef g():\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 474,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number using dynamic programming.\n\n    Args:\n    - n: The index of the Fibonacci number to calculate.\n\n    Returns:\n    - The n-th Fibonacci number.\n\n    Example:\n    Input:\n    n = 6\n\n    Output:\n    8\n\n    Explanation:\n    The 6th Fibonacci number is 8.\n    \"\"\"\n\n    if n <= 1:\n        return n\n\n    fib = [0] * (n + 1)\n    fib[1] = 1\n\n    for i in range(2, n + 1):\n        fib[i] = fib[i - 1] + fib[i - 2]\n\n    return fib[n]\n\ndef g() -> int:\n    \"\"\"\n    Generate an integer.\n    \"\"\"\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 472,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> float:\n    \"\"\"\n    Given a list of 2D points, find the maximum distance between any two points.\n    \"\"\"\n    def distance(p1: List[int], p2: List[int]) -> float:\n        return ((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2) ** 0.5\n\n    max_distance = 0\n    for i in range(len(points)):\n        for j in range(i+1, len(points)):\n            max_distance = max(max_distance, distance(points[i], points[j]))\n\n    return max_distance\n\ndef g():\n    return [[1, 2], [3, 4], [5, 6], [7, 8]]\n\nassert f(g()) == 8.48528137423857\n",
        "idx_generation": 207,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "import random\nfrom typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool:\n    \"\"\"\n    Determine if it is possible to reach the end point from the start point in the grid, \n    where each cell can only be traversed if its value is greater than or equal to 0.\n    \"\"\"\n    def dfs(i: int, j: int) -> bool:\n        if (i, j) == end:\n            return True\n        if i >= len(grid) or j >= len(grid[0]) or grid[i][j] < 0:\n            return False\n        return dfs(i + 1, j) or dfs(i, j + 1)\n    \n    return dfs(start[0], start[1])\n\ndef g():\n    \"\"\"\n    Generate a grid with random values, a random start point, and a random end point.\n    \"\"\"\n    grid = [[1, 2, 3], [4, -1, 2], [3, 4, 5]]\n    start = (0, 0)\n    end = (2, 2)\n    return grid, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 106,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of the words in the string.\n\n    Example:\n    s = \"hello world\"\n\n    Output:\n    \"world hello\"\n\n    Explanation:\n    The words in the string \"hello world\" are \"hello\" and \"world\". By reversing the order of the words,\n    we get the string \"world hello\".\n    \"\"\"\n\n    # Split the string into a list of words\n    words = s.split()\n\n    # Reverse the order of the words\n    words.reverse()\n\n    # Join the words back into a string\n    reversed_string = \" \".join(words)\n\n    return reversed_string\n\ndef g(s=\"hello world\"):\n    \"\"\"\n    Generate a string with multiple words.\n    \"\"\"\n    return s\n\nassert f(g()) == \"world hello\"\n\n",
        "idx_generation": 476,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome after removing at most one character from it.\"\"\"\n    def is_palindrome(s: str, left: int, right: int, removed: int) -> bool:\n        while left < right:\n            if s[left] != s[right]:\n                if removed == 1:\n                    return False\n                else:\n                    return is_palindrome(s, left + 1, right, removed + 1) or is_palindrome(s, left, right - 1, removed + 1)\n            left += 1\n            right -= 1\n        return True\n\n    return is_palindrome(s, 0, len(s) - 1, 0)\n\ndef g() -> str:\n    return \"racecar\"\n\nassert f(g()) == True\n",
        "idx_generation": 76,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers nums, every element appears twice except for one.\n    Find that single one and return it.\n\n    You must implement a solution with a linear runtime complexity and use only constant extra space.\n\n    Example:\n    Input: nums = [4, 1, 2, 1, 2]\n    Output: 4\n    \"\"\"\n    result = 0\n    for num in nums:\n        result ^= num\n    return result\n\ndef g() -> List[int]:\n    return [4, 1, 2, 1, 2]\n\nassert f(g()) == 4\n",
        "idx_generation": 65,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a subarray where the sum of all elements is even.\n\n    Return True if such a subarray exists, otherwise return False.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    True\n\n    Explanation:\n    The subarray [2, 3, 4] has a sum of 9, which is even.\n    \"\"\"\n\n    prefix_sum = 0\n\n    for num in nums:\n        prefix_sum += num\n\n        if prefix_sum % 2 == 0:\n            return True\n\n    return False\n\ndef g(nums: List[int]):\n    \"\"\"\n    Generate a list of integers where there exists a subarray with an even sum.\n    \"\"\"\n    return nums\n\nassert f(g([1, 2, 3, 4])) == True\n\n",
        "idx_generation": 366,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine if a given number is a power of 2 using recursion.\"\"\"\n    if n == 1:\n        return True\n    if n % 2 == 0:\n        return f(n // 2)\n    return False\n\ndef g():\n    return 16\n\nassert f(g()) == True\n",
        "idx_generation": 25,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two positive integers n and m, return the number of unique paths from the top-left corner to the bottom-right corner of an n x m grid.\n    You can only move either down or right at any point in time.\n\n    Example:\n    n = 3\n    m = 2\n\n    Output:\n    3 (There are 3 unique paths: right -> right -> down, right -> down -> right, down -> right -> right)\n    \"\"\"\n    memo = [[0] * m for _ in range(n)]\n    \n    for i in range(n):\n        memo[i][0] = 1\n    \n    for j in range(m):\n        memo[0][j] = 1\n    \n    for i in range(1, n):\n        for j in range(1, m):\n            memo[i][j] = memo[i-1][j] + memo[i][j-1]\n    \n    return memo[n-1][m-1]\n\ndef g() -> List[int]:\n    n = 3\n    m = 2\n    return [n, m]\n\nassert f(*g()) == 3\n",
        "idx_generation": 409,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, determine if the graph is cyclic.\n    \"\"\"\n    def is_cyclic(node, visited, parent):\n        visited[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if is_cyclic(neighbor, visited, node):\n                    return True\n            elif parent != neighbor:\n                return True\n        \n        return False\n    \n    visited = [False] * len(graph)\n    \n    for node in range(len(graph)):\n        if not visited[node]:\n            if is_cyclic(node, visited, -1):\n                return True\n    \n    return False\n\ndef g(graph=[[1,2],[0,2],[0,1]]):\n    \"\"\"\n    Generate an undirected graph represented as an adjacency list.\n    \"\"\"\n    return graph\n\nassert f(g()) == True\n\n",
        "idx_generation": 385,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Determine if there is a path from the start node to the end node in a directed graph.\n    \"\"\"\n    visited = [False] * len(graph)\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if not visited[node]:\n            visited[node] = True\n            stack.extend(graph[node])\n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a directed graph with 5 nodes and random edges.\n    \"\"\"\n    return [[1, 2], [2, 3], [3, 4], [4, 0], [0, 1], [1, 3]]\n\nassert f(g(), 0, 4)\n",
        "idx_generation": 78,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given a graph with n nodes and a list of edges, determine if the graph is a tree.\n    \"\"\"\n    if len(edges) != n - 1:\n        return False\n    \n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    visited = [False] * n\n    def dfs(node, parent):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node):\n                    return True\n            elif neighbor != parent:\n                return True\n        return False\n    \n    return not dfs(0, -1)\n\ndef g(n: int, edges: List[List[int]]):\n    return n, edges\n\nassert f(*g(5, [[0, 1], [0, 2], [0, 3], [0, 4]]))\n",
        "idx_generation": 32,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there is a path from start to end in a directed graph.\n\n    Sample Input:\n    graph = {0: [1, 2],\n             1: [3, 4],\n             2: [5, 6],\n             3: [7],\n             4: [],\n             5: [],\n             6: [],\n             7: []}\n    start = 0\n    end = 7\n\n    Sample Output:\n    True\n    \"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g():\n    graph = {0: [1, 2],\n             1: [3, 4],\n             2: [5, 6],\n             3: [7],\n             4: [],\n             5: [],\n             6: [],\n             7: []}\n    start = 0\n    end = 7\n    return graph, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 65,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool:\n    \"\"\"\n    Given a grid of integers, a start coordinate, and an end coordinate,\n    determine if it is possible to reach the end coordinate from the start coordinate using only right and down movements.\n\n    Return True if it is possible, otherwise return False.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    start = (0, 0)\n    end = (2, 2)\n\n    Output:\n    True\n\n    Explanation:\n    It is possible to reach the end coordinate (2, 2) from the start coordinate (0, 0) by moving right and down.\n    \"\"\"\n\n    def dfs(row, col):\n        if row == end[0] and col == end[1]:\n            return True\n\n        if row < end[0] and grid[row+1][col] != -1:\n            if dfs(row+1, col):\n                return True\n\n        if col < end[1] and grid[row][col+1] != -1:\n            if dfs(row, col+1):\n                return True\n\n        return False\n\n    return dfs(start[0], start[1])\n\ndef g() -> Tuple[List[List[int]], Tuple[int, int], Tuple[int, int]]:\n    \"\"\"\n    Generate a grid of integers, a start coordinate, and an end coordinate.\n\n    Returns:\n    - The generated grid, start coordinate, and end coordinate.\n\n    Example:\n    g() returns ([[1, 2, 3], [4, 5, 6], [7, 8, 9]], (0, 0), (2, 2))\n    \"\"\"\n\n    return ([[1, 2, 3], [4, 5, 6], [7, 8, 9]], (0, 0), (2, 2))\n\nassert f(*g()) == True\n",
        "idx_generation": 473,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int, target: int) -> bool:\n    \"\"\"\n    Given a list of integers 'nums', an integer 'k', and a target integer 'target', determine if it is possible to divide the list into k non-empty subarrays such that the sum of each subarray is equal to the target.\n\n    Sample Input:\n    nums = [2, 3, 5, 1, 4, 1]\n    k = 3\n    target = 5\n\n    Sample Output:\n    True\n    \"\"\"\n    n = len(nums)\n\n    if k == 0 or target == 0 or n % k != 0:\n        return False\n\n    target_sum = sum(nums) // k\n    visited = [False] * n\n\n    def backtrack(start: int, k: int, current_sum: int) -> bool:\n        if k == 1:\n            return True\n\n        if current_sum == target_sum:\n            return backtrack(0, k - 1, 0)\n\n        for i in range(start, n):\n            if not visited[i] and current_sum + nums[i] <= target_sum:\n                visited[i] = True\n\n                if backtrack(i + 1, k, current_sum + nums[i]):\n                    return True\n\n                visited[i] = False\n\n        return False\n\n    return backtrack(0, k, 0)\n\ndef g(nums = [2, 3, 5, 1, 4, 1], k = 3, target = 5):\n    return nums, k, target\n\nassert f(*g())\n",
        "idx_generation": 81,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the length of the longest substring that contains at most two distinct characters.\n\n    Example:\n    s = \"eceba\"\n\n    Output:\n    3\n\n    Explanation:\n    The longest substring with at most two distinct characters is \"ece\".\n    \"\"\"\n\n    if len(s) < 3:\n        return len(s)\n\n    max_length = 2\n    left = 0\n    right = 0\n    char_map = {}\n\n    while right < len(s):\n        char_map[s[right]] = right\n        right += 1\n\n        if len(char_map) == 3:\n            # remove the leftmost character\n            del_idx = min(char_map.values())\n            del char_map[s[del_idx]]\n            left = del_idx + 1\n\n        max_length = max(max_length, right - left)\n\n    return max_length\n\ndef g():\n    s = \"eceba\"\n    return s\n\nassert f(g()) == 3\n",
        "idx_generation": 320,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Given an integer n, generate the Pascal's triangle up to the nth row.\n\n    Example:\n    n = 5\n    The Pascal's triangle up to the 5th row is:\n    [\n        [1],\n        [1, 1],\n        [1, 2, 1],\n        [1, 3, 3, 1],\n        [1, 4, 6, 4, 1]\n    ]\n\n    Constraints:\n    - The input integer n will always be non-negative.\n    \"\"\"\n    triangle = []\n    \n    for i in range(n):\n        row = [1] * (i+1)\n        \n        for j in range(1, i):\n            row[j] = triangle[i-1][j-1] + triangle[i-1][j]\n        \n        triangle.append(row)\n    \n    return triangle\n\ndef g(n=5):\n    return n\n\nassert f(g()) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n",
        "idx_generation": 326,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers, find two numbers such that they add up to a specific target. Return the indices of the two numbers in the array.\n\n    Example:\n    nums = [2, 7, 11, 15], target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The sum of 2 and 7 is 9, and their indices in the array are 0 and 1 respectively.\n\n    Constraints:\n    - The input list will always be sorted in ascending order.\n    - The input list will not contain any duplicate elements.\n    - The target number will always be obtainable by summing two numbers from the input list.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 466,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Calculate the total area of a stack of rectangles with different heights.\n\n    Parameters:\n    heights (List[int]): A list of integers representing the heights of the rectangles.\n\n    Returns:\n    int: The total area of the stack of rectangles.\n    \"\"\"\n    stack = []\n    max_area = 0\n\n    for i, height in enumerate(heights):\n        while stack and heights[stack[-1]] > height:\n            h = heights[stack.pop()]\n            w = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        stack.append(i)\n\n    while stack:\n        h = heights[stack.pop()]\n        w = len(heights) if not stack else len(heights) - stack[-1] - 1\n        max_area = max(max_area, h * w)\n\n    return max_area\n\ndef g(heights=[2, 1, 5, 6, 2, 3]):\n    return heights\n\nassert f(g()) == 10\n",
        "idx_generation": 155,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there exists two numbers in the list whose sum is equal to the target.\n    This function uses two pointers to scan from both ends of the list towards the middle to find the sum.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        \n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5, 6], target: int = 9):\n    \"\"\"\n    Generate a list of integers and a target number for the function f.\n    \"\"\"\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 34,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Check if there is a path from the top-left corner to the bottom-right corner of the grid, where each step can only go right or down.\n    Return True if there is a path, False otherwise.\n\n    Example:\n    grid = [\n        [1, 1, 1, 1],\n        [1, 0, 0, 1],\n        [1, 1, 1, 1]\n    ]\n    Output: True\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[False] * n for _ in range(m)]\n    dp[0][0] = True\n\n    for i in range(1, m):\n        if grid[i][0] == 1 and dp[i - 1][0]:\n            dp[i][0] = True\n\n    for j in range(1, n):\n        if grid[0][j] == 1 and dp[0][j - 1]:\n            dp[0][j] = True\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] == 1:\n                dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n\n    return dp[m - 1][n - 1]\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    return grid\n\nassert f(g([[1, 1, 1, 1], [1, 0, 0, 1], [1, 1, 1, 1]])) == True\n",
        "idx_generation": 390,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with all duplicates removed.\n\n    Example:\n    nums = [1, 2, 3, 3, 4, 4, 5]\n\n    Output:\n    [1, 2, 3, 4, 5]\n    \"\"\"\n\n    stack = []\n\n    for num in nums:\n        if not stack or num != stack[-1]:\n            stack.append(num)\n\n    return stack\n\ndef g():\n    nums = [1, 2, 3, 3, 4, 4, 5]\n    return nums\n\nassert f(g()) == [1, 2, 3, 4, 5]\n\n",
        "idx_generation": 423,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(a: int, b: int, c: int) -> int:\n    \"\"\"Find the maximum value among a, b, and c\"\"\"\n    return max(a, b, c)\n\ndef g():\n    a = 10\n    b = 5\n    c = 7\n    return a, b, c\n\nassert f(*g()) == 10\n",
        "idx_generation": 198,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport heapq\nfrom collections import defaultdict\nfrom typing import List, Tuple\n\ndef f(times: List[Tuple[int, int, int]], N: int, K: int) -> int:\n    \"\"\"\n    There are N network nodes, labelled 1 to N.\n\n    Given times, a list of travel times as directed edges times[i] = (u, v, w),\n    where u is the source node, v is the target node, and w is the time it takes for a signal to travel from source to target.\n\n    Now, we send a signal from a certain node K. How long will it take for all nodes to receive the signal?\n    If it is impossible, return -1.\n\n    \"\"\"\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n    \n    pq = [(0, K)]\n    dist = {}\n    \n    while pq:\n        time, node = heapq.heappop(pq)\n        if node in dist:\n            continue\n        dist[node] = time\n        \n        for neighbor, neighbor_time in graph[node]:\n            heapq.heappush(pq, (time + neighbor_time, neighbor))\n            \n    if len(dist) == N:\n        return max(dist.values())\n    \n    return -1\n\ndef g():\n    times = [(2, 1, 1), (2, 3, 1), (3, 4, 1)]\n    N = 4\n    K = 2\n    return times, N, K\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 403,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid consisting of 0s and 1s, where 0 represents an empty cell and 1 represents an obstacle,\n    find the length of the shortest path from the top-left corner to the bottom-right corner of the grid,\n    while only moving horizontally or vertically.\n\n    Return the length of the shortest path.\n\n    Example:\n    grid = [\n        [0, 1, 0, 0, 0],\n        [0, 1, 0, 1, 0],\n        [0, 0, 0, 0, 0],\n        [0, 1, 1, 1, 0],\n        [0, 0, 0, 0, 0]\n    ]\n\n    Output:\n    8\n\n    Explanation:\n    The shortest path from the top-left corner (0, 0) to the bottom-right corner (4, 4) is:\n    (0, 0) -> (1, 0) -> (2, 0) -> (2, 1) -> (2, 2) -> (3, 2) -> (4, 2) -> (4, 3) -> (4, 4),\n    which has a length of 8.\n\n    Hint: Use breadth-first search (BFS) algorithm to find the shortest path.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def bfs(grid: List[List[int]], start: tuple, end: tuple) -> int:\n        queue = [(start, 0)]\n        visited = set()\n        visited.add(start)\n        while queue:\n            curr, distance = queue.pop(0)\n            if curr == end:\n                return distance\n            for dx, dy in directions:\n                new_x = curr[0] + dx\n                new_y = curr[1] + dy\n                if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] == 0 and (new_x, new_y) not in visited:\n                    queue.append(((new_x, new_y), distance + 1))\n                    visited.add((new_x, new_y))\n        return -1\n\n    return bfs(grid, (0, 0), (rows - 1, cols - 1))\n\ndef g() -> List[List[int]]:\n    grid = [\n        [0, 1, 0, 0, 0],\n        [0, 1, 0, 1, 0],\n        [0, 0, 0, 0, 0],\n        [0, 1, 1, 1, 0],\n        [0, 0, 0, 0, 0]\n    ]\n    return grid\n\nassert f(g()) == 8\n\n",
        "idx_generation": 348,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique combinations of three numbers that sum to zero.\n\n    Args:\n    - nums: The input list of integers.\n\n    Returns:\n    - The number of unique combinations of three numbers that sum to zero.\n    \"\"\"\n    nums.sort()\n    count = 0\n    n = len(nums)\n\n    for i in range(n - 2):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n        left = i + 1\n        right = n - 1\n\n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n            if total == 0:\n                count += 1\n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                left += 1\n                right -= 1\n            elif total < 0:\n                left += 1\n            else:\n                right -= 1\n\n    return count\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    nums = [-1, 0, 1, 2, -1, -4]\n    return nums\n\nassert f(g()) == 2\n\n",
        "idx_generation": 299,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there is a pair of numbers in the list whose sum is divisible by 4.\n    \"\"\"\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if (arr[i] + arr[j]) % 4 == 0:\n                return True\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == True\n",
        "idx_generation": 76,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if the given string is a palindrome after removing all non-alphanumeric characters and ignoring case.\n    \"\"\"\n    def is_palindrome(s):\n        # Remove non-alphanumeric characters and convert to lowercase\n        s = ''.join(c.lower() for c in s if c.isalnum())\n        # Check if the string is a palindrome\n        return s == s[::-1]\n    \n    return is_palindrome(s)\n\ndef g(s=\"A man, a plan, a canal: Panama!\"):\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 77,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums', return the list with the duplicate numbers removed.\n\n    Example:\n    nums = [1, 2, 3, 2, 4, 3, 5]\n    \n    Output:\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    unique_nums = []\n\n    for num in nums:\n        if num not in unique_nums:\n            unique_nums.append(num)\n    \n    return unique_nums\n\ndef g() -> List[int]:\n    return [1, 2, 3, 2, 4, 3, 5]\n\nassert f(g()) == [1, 2, 3, 4, 5]\n\n",
        "idx_generation": 497,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"\n    Given a string and a list of words, determine if the string can be constructed by concatenating the words in the list.\n    Each word can be used multiple times if necessary.\n    \"\"\"\n    if not s or not words:\n        return False\n    \n    n = len(s)\n    dp = [False] * (n + 1)\n    dp[0] = True\n    \n    for i in range(1, n + 1):\n        for word in words:\n            if i >= len(word) and dp[i - len(word)] and s[i - len(word):i] == word:\n                dp[i] = True\n                break\n    \n    return dp[-1]\n\ndef g():\n    return \"leetcode\", [\"leet\", \"code\"]\n\nassert f(*g())\n",
        "idx_generation": 248,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of the words in the string.\n\n    Words are separated by a single space and the string does not contain leading or trailing spaces.\n    \"\"\"\n\n    # Split the string into words\n    words = s.split()\n\n    # Reverse the order of the words\n    reversed_words = words[::-1]\n\n    # Join the reversed words with a space separator\n    reversed_string = \" \".join(reversed_words)\n\n    return reversed_string\n\ndef g(s: str = \"hello world\"):\n    \"\"\"\n    Generate a string with words in a specific order.\n    \"\"\"\n    return s\n\nassert f(g()) == \"world hello\"\n",
        "idx_generation": 358,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nimport math\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a prime number.\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g() -> int:\n    \"\"\"\n    Generate a prime number greater than 100.\n    \"\"\"\n    num = 101\n    while not f(num):\n        num += 1\n    return num\n\nassert f(g()) == True\n",
        "idx_generation": 95,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Check if n can be expressed as a sum of k prime numbers.\"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    primes = []\n    i = 2\n    while len(primes) < k:\n        if is_prime(i):\n            primes.append(i)\n        i += 1\n    \n    dp = [False] * (n + 1)\n    dp[0] = True\n    \n    for prime in primes:\n        for i in range(prime, n + 1):\n            dp[i] = dp[i] or dp[i - prime]\n    \n    return dp[n]\n\ndef g():\n    return 10, 3\n\nassert f(*g()) == True\n",
        "idx_generation": 226,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of numbers and a target sum, find two numbers in the list that add up to the target sum.\n    Return the indices of the two numbers.\n\n    Example:\n    numbers = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1] (since numbers[0] + numbers[1] = 2 + 7 = 9)\n    \"\"\"\n\n    complement_map = {}\n    for i, num in enumerate(numbers):\n        complement = target - num\n        if complement in complement_map:\n            return [complement_map[complement], i]\n        complement_map[num] = i\n\n    return []\n\ndef g(numbers: List[int] = [2, 7, 11, 15], target: int = 9) -> List[int]:\n    \"\"\"\n    Generate a list of numbers and a target sum.\n    \"\"\"\n    return numbers, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 388,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of numbers, find the maximum sum subarray.\n    A subarray is a contiguous part of the array.\n    \"\"\"\n    if not nums:\n        return 0\n    max_sum = nums[0]\n    curr_sum = nums[0]\n    for i in range(1, len(nums)):\n        curr_sum = max(nums[i], curr_sum + nums[i])\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef g(nums: List[int] = [-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 201,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums' and a target value 'target',\n    find two numbers in the list that sum up to the target.\n\n    Args:\n    - nums: A list of integers.\n    - target: The target value.\n\n    Returns:\n    - A list of two numbers that sum up to the target.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [2, 7]\n\n    Explanation:\n    The numbers 2 and 7 sum up to the target value 9.\n    \"\"\"\n\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 471,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the maximum area of a rectangle in the grid that contains only 0s.\n    \"\"\"\n    if not grid or not grid[0]:\n        return 0\n    rows, cols = len(grid), len(grid[0])\n    max_area = 0\n    heights = [0] * cols\n    for row in range(rows):\n        for col in range(cols):\n            if grid[row][col] == 0:\n                heights[col] += 1\n            else:\n                heights[col] = 0\n        max_area = max(max_area, largest_rectangle_area(heights))\n    return max_area\n\ndef largest_rectangle_area(heights: List[int]) -> int:\n    stack = [-1]\n    max_area = 0\n    for i, h in enumerate(heights):\n        while stack[-1] != -1 and heights[stack[-1]] >= h:\n            height = heights[stack.pop()]\n            width = i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        stack.append(i)\n    while stack[-1] != -1:\n        height = heights[stack.pop()]\n        width = len(heights) - stack[-1] - 1\n        max_area = max(max_area, height * width)\n    return max_area\n\ndef g():\n    return [[0, 1, 0, 0, 0],\n            [0, 0, 0, 1, 1],\n            [0, 0, 0, 0, 0],\n            [0, 1, 1, 0, 0],\n            [0, 0, 0, 0, 0]]\n\nassert f(g()) == 6\n",
        "idx_generation": 197,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(prices: List[int]) -> int:\n    \"\"\"\n    Given a list of prices representing the stock prices on different days, find the maximum profit that can be obtained by buying and selling the stock.\n\n    Example:\n    prices = [7, 1, 5, 3, 6, 4]\n\n    Output:\n    5\n\n    Explanation:\n    The maximum profit can be obtained by buying the stock on day 2 and selling it on day 5. The maximum profit is 5.\n\n    Hint: Use dynamic programming to keep track of the minimum price and maximum profit so far.\n    \"\"\"\n\n    if len(prices) == 0:\n        return 0\n\n    min_price = prices[0]\n    max_profit = 0\n\n    for price in prices:\n        min_price = min(min_price, price)\n        max_profit = max(max_profit, price - min_price)\n\n    return max_profit\n\ndef g():\n    return [7, 1, 5, 3, 6, 4]\n\nassert f(g()) == 5\n",
        "idx_generation": 474,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, return the sum of all the numbers that lie on the diagonal from the top left to the bottom right.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    Output:\n    15\n\n    Explanation:\n    The diagonal elements are 1, 5, and 9, and their sum is 15.\n    \"\"\"\n    diagonal_sum = 0\n    for i in range(len(grid)):\n        diagonal_sum += grid[i][i]\n    return diagonal_sum\n\ndef g():\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n    return grid\n\nassert f(g()) == 15\n\n",
        "idx_generation": 235,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Count the number of unique paths from the top-left corner to the bottom-right corner in a grid of size n x m.\n    You can only move down or right at each step.\n    \"\"\"\n    dp = [[0] * m for _ in range(n)]\n    for i in range(n):\n        dp[i][0] = 1\n    for j in range(m):\n        dp[0][j] = 1\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    return dp[n - 1][m - 1]\n\ndef g():\n    n = 3\n    m = 4\n    return n, m\n\nassert f(*g()) == 10\n",
        "idx_generation": 125,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string of lowercase letters, find the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n\n    Output:\n    3\n\n    Explanation:\n    The longest substring without repeating characters is \"abc\", which has a length of 3.\n    \"\"\"\n\n    # Create a set to store the unique characters in the current substring\n    unique_chars = set()\n\n    # Initialize variables to keep track of the start and end indices of the current substring\n    start = 0\n    end = 0\n\n    # Initialize variable to store the length of the longest substring\n    longest_length = 0\n\n    # Iterate through the string\n    while end < len(s):\n        # If the current character is not in the set, add it to the set and move the end index forward\n        if s[end] not in unique_chars:\n            unique_chars.add(s[end])\n            end += 1\n            # Update the longest length if necessary\n            longest_length = max(longest_length, end - start)\n        # If the current character is already in the set, remove the character from the set and move the start index forward\n        else:\n            unique_chars.remove(s[start])\n            start += 1\n\n    return longest_length\n\ndef g(s=\"abcabcbb\"):\n    \"\"\"\n    Generate a string with repeated characters to find the length of the longest substring without repeating characters.\n    \"\"\"\n    return s\n\nassert f(g()) == 3\n\n",
        "idx_generation": 476,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"\n    Determine if a string is a palindrome.\n    \"\"\"\n    return string == string[::-1]\n\ndef g():\n    \"\"\"\n    Generate a palindrome string to check if it is indeed a palindrome.\n    \"\"\"\n    return \"racecar\"\n\nassert f(g()) == True\n",
        "idx_generation": 78,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a power of two.\n    Return True if n is a power of two, otherwise return False.\n    \"\"\"\n    if n <= 0:\n        return False\n    return (n & (n - 1)) == 0\n\ndef g(n = 16):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 69,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all positive integers less than or equal to n.\n\n    Example:\n    n = 5\n\n    Output:\n    15\n\n    Explanation:\n    The sum of all positive integers less than or equal to 5 is 1 + 2 + 3 + 4 + 5 = 15.\n\n    Hint: Use the formula for the sum of an arithmetic series.\n    \"\"\"\n\n    return n * (n + 1) // 2\n\ndef g(n = 5):\n    return n\n\nassert f(g()) == 15\n\n",
        "idx_generation": 375,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine if a given number n is a prime number. This function uses a recursive approach to check if n is divisible by \n    any number less than its square root.\n    \"\"\"\n    if n <= 1:\n        return False\n    \n    def is_divisible(divisor: int, number: int) -> bool:\n        if number % divisor == 0:\n            return True\n        elif divisor * divisor > number:\n            return False\n        else:\n            return is_divisible(divisor + 1, number)\n    \n    return not is_divisible(2, n)\n\ndef g(n: int = 17):\n    \"\"\"\n    Generate a number n for the function f.\n    \"\"\"\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 26,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum that can be obtained by traversing from the top-left corner to the bottom-right corner.\n    Each move can only be made to the right or down.\n\n    Example:\n    Input: grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 12\n    Explanation: The maximum sum can be obtained by following the path 1 -> 3 -> 5 -> 2 -> 1.\n\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[m - 1][n - 1]\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 12\n\n",
        "idx_generation": 410,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nclass TreeNode:\n    def __init__(self, val: int):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef f(root: TreeNode, k: int) -> bool:\n    \"\"\"\n    Given the root of a binary search tree (BST) and an integer k, determine if there exists two elements in the BST such that their sum is equal to k.\n\n    Example:\n    root = TreeNode(5)\n    root.left = TreeNode(3)\n    root.right = TreeNode(6)\n    root.left.left = TreeNode(2)\n    root.left.right = TreeNode(4)\n    root.right.right = TreeNode(7)\n    k = 9\n\n    Output:\n    True\n\n    Explanation:\n    There exists two elements in the BST (2 and 7) that sum up to 9.\n\n    Hint: Use a set to store the difference between k and each node value in the tree.\n    \"\"\"\n\n    def dfs(node, target):\n        if not node:\n            return False\n        if target - node.val in seen:\n            return True\n        seen.add(node.val)\n        return dfs(node.left, target) or dfs(node.right, target)\n\n    seen = set()\n    return dfs(root, k)\n\ndef g() -> Tuple[TreeNode, int]:\n    root = TreeNode(5)\n    root.left = TreeNode(3)\n    root.right = TreeNode(6)\n    root.left.left = TreeNode(2)\n    root.left.right = TreeNode(4)\n    root.right.right = TreeNode(7)\n    k = 9\n    return root, k\n\nassert f(*g()) == True\n",
        "idx_generation": 389,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: dict, start: str, end: str) -> bool:\n    \"\"\"\n    Given a graph represented as a dictionary of nodes and their neighbors, determine if there is a path from\n    start to end.\n    \"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    return False\ndef g():\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['A', 'D'],\n        'C': ['A', 'E'],\n        'D': ['B', 'F'],\n        'E': ['C'],\n        'F': ['D']\n    }\n    return graph, 'A', 'F'\nassert f(*g())\n",
        "idx_generation": 80,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"Determine if a given graph is a tree\"\"\"\n    if n != len(edges) + 1:  # Number of vertices must be 1 more than the number of edges for a tree\n        return False\n    \n    graph = {i: [] for i in range(n)}\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    visited = [False] * n\n    \n    def dfs(node: int, parent: int) -> bool:\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if not dfs(neighbor, node):\n                    return False\n            elif neighbor != parent:\n                return False\n        return True\n    \n    return dfs(0, -1) and all(visited)\n\ndef g():\n    n = 4\n    edges = [[0, 1], [0, 2], [0, 3]]\n    return (n, edges)\n\nassert f(*g()) == True\n",
        "idx_generation": 41,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start=0, end=4, path_length=3) -> bool:\n    \"\"\"\n    Find a path from the start node to the end node in the given graph, with a maximum length of path_length.\n    graph is represented as a dictionary where the keys are the nodes and the values are lists of neighboring nodes.\n    \"\"\"\n    stack = [(start, [start])]\n    while stack:\n        node, path = stack.pop()\n        if node == end and len(path) == path_length + 1:\n            return True\n        if len(path) <= path_length:\n            for neighbor in graph[node]:\n                stack.append((neighbor, path + [neighbor]))\n    return False\n\ndef g(start = 0, end = 4, path_length = 3):\n    graph = {\n        0: [1, 2],\n        1: [2, 3],\n        2: [3, 4],\n        3: [4],\n        4: []\n    }\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 67,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"Find all unique combinations of nums that sum up to target.\"\"\"\n    def backtrack(remain, current_combination, start):\n        if remain == 0:\n            result.append(list(current_combination))\n            return\n        elif remain < 0:\n            return\n        for i in range(start, len(nums)):\n            current_combination.append(nums[i])\n            backtrack(remain - nums[i], current_combination, i)\n            current_combination.pop()\n    \n    result = []\n    nums.sort()\n    backtrack(target, [], 0)\n    return result\n\ndef g(nums=[2,3,6,7], target=7):\n    return nums, target\n\nassert f(*g()) == [[2, 2, 3], [7]]\n",
        "idx_generation": 83,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, check if it can be formed by concatenating words from a list of words.\n    The words can be concatenated in any order and any number of times.\n\n    Return True if the string s can be formed by concatenating words from the list, False otherwise.\n\n    Example:\n    s = \"applebananaorange\"\n\n    Output:\n    True\n\n    Explanation:\n    The string s can be formed by concatenating the words \"apple\", \"banana\", and \"orange\".\n    \"\"\"\n\n    def can_form_string(s, words):\n        if s == \"\":\n            return True\n\n        for word in words:\n            if s.startswith(word) and can_form_string(s[len(word):], words):\n                return True\n\n        return False\n\n    words = ['apple', 'banana', 'orange']\n    return can_form_string(s, words)\n\ndef g(s: str = \"applebananaorange\"):\n    return s\n\nassert f(g())\n\n",
        "idx_generation": 386,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of trailing zeros in n!\n\n    Example:\n    f(5) returns 1, as 5! = 120, which has 1 trailing zero.\n\n    Note:\n    - The input integer n will be greater than or equal to 0.\n    \"\"\"\n\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n\n    return count\n\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer.\n\n    Example:\n    g() returns 5\n\n    Note:\n    - The generated integer will be greater than or equal to 0.\n    \"\"\"\n\n    return 5\n\n\nassert f(g()) == 1\n\n\n",
        "idx_generation": 353,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two numbers in the list.\n\n    Example:\n    nums = [2, 3, 4, 5]\n\n    Output:\n    20\n\n    Hint: The maximum product is either the product of the two largest positive numbers or the product of the two smallest negative numbers and the largest positive number.\n    \"\"\"\n    nums.sort()\n    return max(nums[-1] * nums[-2], nums[0] * nums[1])\n\ndef g():\n    return [2, 3, 4, 5]\n\nassert f(g()) == 20\n\n",
        "idx_generation": 466,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value, determine if there are two numbers in the array that add up to the target.\n    Return True if such pair exists, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    target = 9\n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 155,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in a given sorted array whose sum is equal to a target number.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        current_sum = arr[left] + arr[right]\n        \n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), 13) == True\n",
        "idx_generation": 34,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, perform a binary search to find the index of the target element.\n    If the target is not found, return -1.\n\n    Example:\n    Input:\n    nums = [1, 2, 3, 4, 5]\n    target = 3\n\n    Output:\n    2\n    \"\"\"\n\n    def binarySearch(nums: List[int], target: int, left: int, right: int) -> int:\n        if left > right:\n            return -1\n\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            return binarySearch(nums, target, mid + 1, right)\n        else:\n            return binarySearch(nums, target, left, mid - 1)\n\n    return binarySearch(nums, target, 0, len(nums) - 1)\n\ndef g() -> tuple:\n    \"\"\"\n    Generate a sorted list of integers and a target element.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    target = 3\n    return nums, target\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 403,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Stack:\n    def __init__(self):\n        self.items = []\n\n    def is_empty(self):\n        return len(self.items) == 0\n\n    def push(self, item):\n        self.items.append(item)\n\n    def pop(self):\n        if self.is_empty():\n            return None\n        return self.items.pop()\n\n    def peek(self):\n        if self.is_empty():\n            return None\n        return self.items[-1]\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string containing only parentheses, braces, and brackets, determine if the string is valid.\n    A string is valid if all parentheses, braces, and brackets are properly closed.\n\n    Example:\n    s = \"([{}])\"\n    Output: True\n    Explanation: The string is valid since all parentheses, braces, and brackets are properly closed.\n\n    Hint: You can solve this problem using a stack to keep track of opening and closing brackets.\n    \"\"\"\n    stack = Stack()\n    pairs = {')': '(', ']': '[', '}': '{'}\n    \n    for char in s:\n        if char in pairs.values():\n            stack.push(char)\n        elif char in pairs.keys():\n            if stack.is_empty() or stack.pop() != pairs[char]:\n                return False\n    \n    return stack.is_empty()\n\ndef g(s=\"([{}])\"):\n    \"\"\"\n    Generate a string containing only parentheses, braces, and brackets.\n    \"\"\"\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 480,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of distinct integers and a target value, return the index if the target is found.\n    If not, return the index where it would be if it were inserted in order.\n    You must write an algorithm with O(log n) runtime complexity.\n\n    Example:\n    nums = [1,3,5,6], target = 5\n    Output: 2\n\n    nums = [1,3,5,6], target = 2\n    Output: 1\n\n    nums = [1,3,5,6], target = 7\n    Output: 4\n\n    nums = [1,3,5,6], target = 0\n    Output: 0\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left\n\ndef g(nums=[1,3,5,6], target=5):\n    return [nums, target]\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 200,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom collections import defaultdict\n\ndef f(numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.\n\n    Example:\n    Input:\n    numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\n    Output: [0,1,2,3] or [0,2,1,3]\n    Explanation: There are a total of 4 courses to take. To take course 3, you should have finished courses 1 and 2. Both courses 1 and 2 should be taken after course 0. So a valid course order is [0,1,2,3]. Another valid ordering is [0,2,1,3].\n    \"\"\"\n\n    # Create adjacency list\n    graph = defaultdict(list)\n    for prerequisite in prerequisites:\n        course, pre = prerequisite\n        graph[pre].append(course)\n\n    visited = [0] * numCourses\n    result = []\n\n    def dfs(course):\n        if visited[course] == -1:\n            return False\n        if visited[course] == 1:\n            return True\n\n        visited[course] = -1\n\n        for neighbor in graph[course]:\n            if not dfs(neighbor):\n                return False\n\n        visited[course] = 1\n        result.append(course)\n        return True\n\n    for course in range(numCourses):\n        if not dfs(course):\n            return []\n\n    return result[::-1]\n\ndef g():\n    \"\"\"\n    Generate the number of courses and prerequisites with the following structure:\n    numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\n    \"\"\"\n    return 4, [[1, 0], [2, 0], [3, 1], [3, 2]]\n\nassert f(*g()) == [0, 2, 1, 3]\n\n",
        "idx_generation": 410,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the length of the shortest path from the top-left cell to the bottom-right cell.\n    You can only move down or right at each step.\n    \n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    \n    Output:\n    7 (the shortest path is 1 -> 3 -> 1 -> 1 -> 1)\n    \"\"\"\n    if not grid:\n        return 0\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    \n    dp[0][0] = grid[0][0]\n    \n    # Fill the first row\n    for col in range(1, cols):\n        dp[0][col] = dp[0][col-1] + grid[0][col]\n    \n    # Fill the first column\n    for row in range(1, rows):\n        dp[row][0] = dp[row-1][0] + grid[row][0]\n    \n    # Fill the remaining cells\n    for row in range(1, rows):\n        for col in range(1, cols):\n            dp[row][col] = min(dp[row-1][col], dp[row][col-1]) + grid[row][col]\n    \n    return dp[rows-1][cols-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n\n",
        "idx_generation": 358,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique combinations of three numbers that add up to zero.\n\n    Parameters:\n    nums (List[int]): A list of integers.\n\n    Returns:\n    int: The number of unique combinations of three numbers that add up to zero.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    count = 0\n    for i in range(n-2):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n        left = i + 1\n        right = n - 1\n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n            if total < 0:\n                left += 1\n            elif total > 0:\n                right -= 1\n            else:\n                count += 1\n                while left < right and nums[left] == nums[left+1]:\n                    left += 1\n                while left < right and nums[right] == nums[right-1]:\n                    right -= 1\n                left += 1\n                right -= 1\n    return count\n\ndef g(nums=[-1, 0, 1, 2, -1, -4]):\n    return nums\n\nassert f(g()) == 2\n",
        "idx_generation": 305,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Find the nth number in the Fibonacci sequence.\n    \"\"\"\n\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n\n    a, b = 0, 1\n\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n\n    return b\n\ndef g(n=6):\n    \"\"\"\n    Generate a number to find its position in the Fibonacci sequence.\n    \"\"\"\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 126,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct elements in the list.\n    \"\"\"\n    return len(set(nums))\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5, 1, 2, 3]\n    return [nums]\n\nassert f(*g()) == 5\n\n",
        "idx_generation": 93,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, return the longest palindromic substring in s.\n\n    Args:\n    - s: A string\n\n    Returns:\n    - The longest palindromic substring in s.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    longest_palindrome = \"\"\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            substr = s[i:j]\n            if is_palindrome(substr) and len(substr) > len(longest_palindrome):\n                longest_palindrome = substr\n    \n    return longest_palindrome\n\ndef g() -> str:\n    return \"babad\"\n\nassert f(g()) == \"bab\"\n",
        "idx_generation": 282,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(s: str) -> int:\n    \"\"\"\n    Return the length of the longest valid parentheses substring in the given string.\n\n    Args:\n    - s: A string containing parentheses.\n\n    Returns:\n    - An integer representing the length of the longest valid parentheses substring.\n    \"\"\"\n    stack = [-1]\n    max_length = 0\n\n    for i in range(len(s)):\n        if s[i] == \"(\":\n            stack.append(i)\n        else:\n            stack.pop()\n            if stack:\n                max_length = max(max_length, i - stack[-1])\n            else:\n                stack.append(i)\n\n    return max_length\n\ndef g():\n    s = \"(()))()()())\"\n    return s\n\nassert f(g()) == 6\n\n",
        "idx_generation": 379,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if n is a perfect square and if its square root is an integer.\n    \"\"\"\n    root = int(n ** 0.5)\n    return root * root == n\n\ndef g():\n    return 16\n\nassert f(g()) == True\n",
        "idx_generation": 98,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int]) -> bool:\n    \"\"\"\n    Given a list of numbers, determine if there exists a substring of consecutive numbers whose product is a perfect square.\n\n    Sample input:\n    numbers = [2, 3, 4, 5, 6, 7]\n\n    Sample output:\n    True\n\n    The substring [4, 5, 6] has a product of 120, which is a perfect square (10^2).\n    \"\"\"\n    def is_perfect_square(n):\n        return int(n ** 0.5) ** 2 == n\n\n    def has_consecutive_substring(numbers):\n        for i in range(len(numbers)):\n            product = 1\n            for j in range(i, len(numbers)):\n                product *= numbers[j]\n                if is_perfect_square(product):\n                    return True\n        return False\n\n    return has_consecutive_substring(numbers)\n\ndef g():\n    return [2, 3, 4, 5, 6, 7]\n\nassert f(g()) == True\n",
        "idx_generation": 231,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n    Output: 3\n\n    Explanation:\n    The longest substring without repeating characters is \"abc\", which has a length of 3.\n    \"\"\"\n\n    if len(s) == 0:\n        return 0\n\n    max_length = 0\n    start = 0\n    seen = {}\n\n    for end in range(len(s)):\n        if s[end] in seen and start <= seen[s[end]]:\n            start = seen[s[end]] + 1\n        else:\n            max_length = max(max_length, end - start + 1)\n        \n        seen[s[end]] = end\n    \n    return max_length\n\ndef g():\n    s = \"abcabcbb\"\n    return s\n\nassert f(g()) == 3\n",
        "idx_generation": 437,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return the spiral order of the matrix elements.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n\n    Output:\n    [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n    Explanation:\n    The spiral order of the matrix elements is:\n    1 -> 2 -> 3\n             |\n             6\n             |\n             9 <- 8 <- 7\n                   |\n                   4 -> 5\n\n    Hint: Use a combination of iteration and recursion to traverse the matrix in a spiral order.\n    \"\"\"\n    if not matrix:\n        return []\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    spiral_order = []\n\n    def traverse(row_start, row_end, col_start, col_end):\n        if row_start > row_end or col_start > col_end:\n            return\n\n        # Traverse top row\n        for j in range(col_start, col_end + 1):\n            spiral_order.append(matrix[row_start][j])\n\n        # Traverse right column\n        for i in range(row_start + 1, row_end + 1):\n            spiral_order.append(matrix[i][col_end])\n\n        # Traverse bottom row\n        if row_start < row_end:\n            for j in range(col_end - 1, col_start - 1, -1):\n                spiral_order.append(matrix[row_end][j])\n\n        # Traverse left column\n        if col_start < col_end:\n            for i in range(row_end - 1, row_start, -1):\n                spiral_order.append(matrix[i][col_start])\n\n        # Recursively traverse the inner submatrix\n        traverse(row_start + 1, row_end - 1, col_start + 1, col_end - 1)\n\n    traverse(0, rows - 1, 0, cols - 1)\n\n    return spiral_order\n\ndef g():\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 203,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix represented by a list of lists, where each inner list represents a row, find the maximum value in the matrix.\n    \"\"\"\n    max_value = float('-inf')\n    for row in matrix:\n        for num in row:\n            if num > max_value:\n                max_value = num\n    return max_value\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Return a matrix represented by a list of lists.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 9\n",
        "idx_generation": 479,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the string using a stack data structure.\n    \"\"\"\n    stack = []\n    for char in s:\n        stack.append(char)\n\n    reversed_str = \"\"\n    while stack:\n        reversed_str += stack.pop()\n\n    return reversed_str\n\ndef g(s: str = \"Hello, World!\"):\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return s\n\nassert f(g()) == \"!dlroW ,olleH\"\n",
        "idx_generation": 203,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target integer, return the number of ways to reach the target by adding or subtracting the elements in the list.\n\n    Example:\n    nums = [1, 1, 1, 1, 1]\n    target = 3\n\n    Output:\n    5\n\n    Explanation:\n    There are 5 ways to reach the target by adding or subtracting the elements in the list:\n    1 + 1 + 1 + 1 - 1\n    1 + 1 - 1 + 1 + 1\n    1 - 1 + 1 + 1 + 1\n    -1 + 1 + 1 + 1 + 1\n    1 + 1 + 1 - 1 + 1\n    \"\"\"\n\n    def ways_to_reach_target(nums, target, curr_sum, curr_index):\n        if curr_index == len(nums):\n            if curr_sum == target:\n                return 1\n            else:\n                return 0\n\n        ways = ways_to_reach_target(nums, target, curr_sum + nums[curr_index], curr_index + 1) + ways_to_reach_target(nums, target, curr_sum - nums[curr_index], curr_index + 1)\n        return ways\n\n    return ways_to_reach_target(nums, target, 0, 0)\n\ndef g(nums=[1, 1, 1, 1, 1], target=3):\n    return nums, target\n\nassert f(*g()) == 5\n",
        "idx_generation": 475,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(points: List[Tuple[int, int]]) -> float:\n    \"\"\"\n    Given a list of points in 2D space, calculate the perimeter of the convex hull formed by the points.\n    The convex hull is the smallest convex polygon that contains all the points.\n\n    Example:\n    points = [(0, 0), (0, 1), (1, 0), (1, 1)]\n    The convex hull formed by the points is a square with side length 1.\n    The perimeter of the square is 4.\n\n    Return the perimeter of the convex hull as a float.\n    \"\"\"\n    def orientation(p1, p2, p3):\n        \"\"\"\n        Find the orientation of three points.\n        Returns:\n            0 if the points are collinear\n            1 if the points are clockwise\n            2 if the points are counterclockwise\n        \"\"\"\n        val = (p2[1] - p1[1]) * (p3[0] - p2[0]) - (p2[0] - p1[0]) * (p3[1] - p2[1])\n        if val == 0:\n            return 0\n        elif val > 0:\n            return 1\n        else:\n            return 2\n\n    def convex_hull(points):\n        \"\"\"\n        Compute the convex hull of a set of points using the Graham's scan algorithm.\n        \"\"\"\n        n = len(points)\n        if n < 3:\n            return []\n\n        hull = []\n\n        # Find the leftmost point\n        leftmost = min(points, key=lambda point: point[0])\n\n        p = 0\n        q = 0\n        while True:\n            hull.append(points[p])\n            q = (p + 1) % n\n            for i in range(n):\n                if orientation(points[p], points[i], points[q]) == 2:\n                    q = i\n            p = q\n\n            if p == 0:\n                break\n\n        return hull\n\n    hull_points = convex_hull(points)\n    perimeter = 0.0\n    n = len(hull_points)\n    for i in range(n):\n        p1 = hull_points[i]\n        p2 = hull_points[(i + 1) % n]\n        dx = p2[0] - p1[0]\n        dy = p2[1] - p1[1]\n        perimeter += (dx ** 2 + dy ** 2) ** 0.5\n\n    return perimeter\n\n\ndef g() -> List[Tuple[int, int]]:\n    points = [(0, 0), (0, 1), (1, 0), (1, 1)]\n    return points\n\n\nassert f(g()) == 4.0\n\n",
        "idx_generation": 244,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum cost to reach the bottom-right cell from the top-left cell,\n    with the restriction that you can only move down or right.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[float('inf')] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(rows):\n        for j in range(cols):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j])\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j])\n    \n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    return grid\n\nassert f(g()) == 7\n\n",
        "idx_generation": 130,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of the words in the string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: The string with the order of words reversed.\n    \"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)\n\ndef g() -> str:\n    \"\"\"\n    Generate a random string.\n\n    Returns:\n    str: A random string.\n    \"\"\"\n    return \"Hello, world!\"\n\nassert f(g()) == \"world! Hello,\"\n\n",
        "idx_generation": 481,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(string: str, pattern: str) -> bool:\n    \"\"\"Determine if a given string matches a given pattern where each '*' character can be replaced with any number of characters.\"\"\"\n    def match(s_index: int, p_index: int) -> bool:\n        if s_index == len(string) and p_index == len(pattern):\n            return True\n        if p_index == len(pattern):\n            return False\n        if pattern[p_index] == '*':\n            for i in range(s_index, len(string) + 1):\n                if match(i, p_index + 1):\n                    return True\n        elif s_index < len(string) and (pattern[p_index] == '?' or pattern[p_index] == string[s_index]):\n            if match(s_index + 1, p_index + 1):\n                return True\n        return False\n    \n    return match(0, 0)\n\ndef g():\n    string = \"abccba\"\n    pattern = \"a*c*a\"\n    return string, pattern\n\nassert f(*g())\n",
        "idx_generation": 107,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR value between any two numbers in the array.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            max_xor = max(max_xor, arr[i] ^ arr[j])\n    return max_xor\n\ndef g():\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return arr\n\nassert f(g()) == 15\n",
        "idx_generation": 70,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums, determine if there exists a subsequence of length 3 that forms an arithmetic progression.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n\n    Output:\n    True\n\n    Explanation:\n    The subsequence [1, 3, 5] forms an arithmetic progression with a common difference of 2.\n    \"\"\"\n\n    def is_arithmetic(nums):\n        if len(nums) < 3:\n            return False\n\n        diff = nums[1] - nums[0]\n\n        for i in range(2, len(nums)):\n            if nums[i] - nums[i-1] != diff:\n                return False\n\n        return True\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                if is_arithmetic([nums[i], nums[j], nums[k]]):\n                    return True\n\n    return False\n\ndef g(nums=[1, 3, 5, 7, 9]):\n    return nums\n\nassert f(g()) == True\n\n",
        "idx_generation": 391,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer 'n', determine if it can be expressed as the sum of consecutive positive integers.\n    \n    Example:\n    n = 15\n    \n    Output:\n    True (since 15 can be expressed as 1 + 2 + 3 + 4 + 5)\n    \"\"\"\n    i = 1\n    while (i * (i + 1)) // 2 <= n:\n        if (n - (i * (i + 1)) // 2) % i == 0:\n            return True\n        i += 1\n    return False\n\ndef g():\n    return 15\n\nassert f(g()) == True\n",
        "idx_generation": 43,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    12\n\n    Explanation:\n    The maximum sum of a path from the top-left cell (1) to the bottom-right cell (1) is 12, which is obtained by following the path: 1 -> 3 -> 5 -> 2 -> 1.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 12\n\n",
        "idx_generation": 430,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, determine if it contains a cycle.\n\n    Args:\n    - graph: The adjacency matrix representing the graph.\n\n    Returns:\n    - True if the graph contains a cycle, False otherwise.\n    \"\"\"\n    visited = [False] * len(graph)\n    for node in range(len(graph)):\n        if not visited[node]:\n            if is_cyclic(graph, node, visited, -1):\n                return True\n    return False\n\ndef is_cyclic(graph: List[List[int]], node: int, visited: List[bool], parent: int) -> bool:\n    visited[node] = True\n    for neighbor in range(len(graph)):\n        if graph[node][neighbor] == 1:\n            if not visited[neighbor]:\n                if is_cyclic(graph, neighbor, visited, node):\n                    return True\n            elif parent != neighbor:\n                return True\n    return False\n\ndef g():\n    graph = [\n        [0, 1, 0, 0],\n        [1, 0, 1, 1],\n        [0, 1, 0, 1],\n        [0, 1, 1, 0]\n    ]\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 395,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(adj_matrix: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given an adjacency matrix representing a directed graph, determine if there is a path from start to end.\n    \"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor, weight in enumerate(adj_matrix[node]):\n            if weight != 0 and neighbor not in visited:\n                stack.append(neighbor)\n    return False\ndef g():\n    adj_matrix = [\n        [0, 1, 1, 0],\n        [1, 0, 0, 1],\n        [1, 0, 0, 0],\n        [0, 1, 0, 0]\n    ]\n    return adj_matrix, 0, 3\nassert f(*g())\n",
        "idx_generation": 80,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of 0s and 1s, determine if there is a path from the top-left corner to the bottom-right corner,\n    where 0 represents an obstacle and 1 represents a valid path. You can only move down or right.\n\n    - grid is a 2D list of integers, where each element is either 0 or 1.\n    - Return True if there is a valid path, False otherwise.\n    \"\"\"\n\n    def can_reach_end(x: int, y: int) -> bool:\n        # Base cases\n        if x == len(grid) - 1 and y == len(grid[0]) - 1:\n            return True\n        if x >= len(grid) or y >= len(grid[0]) or grid[x][y] == 0:\n            return False\n        \n        # Recursive cases\n        return can_reach_end(x + 1, y) or can_reach_end(x, y + 1)\n\n    return can_reach_end(0, 0)\n\ndef g(grid: List[List[int]]):\n    return grid\n\nassert f(g([[1, 1, 0], [1, 0, 1], [1, 1, 1]]))\n",
        "idx_generation": 42,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(adj_matrix: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given an adjacency matrix representing a graph, find if there exists a path from\n    the start node to the end node.\n    \"\"\"\n    visited = set()\n    stack = [start]\n    \n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor, connected in enumerate(adj_matrix[node]):\n            if connected and neighbor not in visited:\n                stack.append(neighbor)\n    \n    return False\n\ndef g(adj_matrix: List[List[int]], start: int, end: int):\n    \"\"\"\n    Generate an adjacency matrix where there exists a path from the start node to the end node.\n    \"\"\"\n    num_nodes = len(adj_matrix)\n    adj_matrix[start][end] = 1\n    return adj_matrix\n\nadj_matrix = [\n    [0, 1, 1, 0],\n    [1, 0, 0, 1],\n    [1, 0, 0, 0],\n    [0, 1, 0, 0]\n]\nstart = 0\nend = 3\n\nassert f(g(adj_matrix, start, end), start, end)\n",
        "idx_generation": 71,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums, generate all possible subsets of nums, including the empty set.\n    Return a list of lists, where each inner list represents a subset.\n    \"\"\"\n    def backtrack(start, path):\n        res.append(path[:])\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            backtrack(i + 1, path)\n            path.pop()\n\n    res = []\n    backtrack(0, [])\n    return res\n\ndef g(nums = [1, 2, 3]):\n    return nums\n\nassert f(g()) == [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]\n",
        "idx_generation": 102,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target sum, find all unique combinations of numbers where the sum of the combinations is equal to the target.\n    Each number in the list may only be used once in each combination.\n\n    Example:\n    Input: nums = [10, 1, 2, 7, 6, 1, 5], target = 8\n    Output: [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n\n    Note:\n    - The solution set must not contain duplicate combinations.\n    - The order of combinations does not matter.\n    \"\"\"\n\n    def backtrack(nums: List[int], target: int, start: int, path: List[int], result: List[List[int]]) -> None:\n        if target < 0:\n            return\n        if target == 0:\n            result.append(path)\n            return\n\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            backtrack(nums, target - nums[i], i + 1, path + [nums[i]], result)\n\n    nums.sort()\n    result = []\n    backtrack(nums, target, 0, [], result)\n    return result\n\ndef g(nums = [10, 1, 2, 7, 6, 1, 5], target = 8):\n    return nums, target\n\nassert f(*g()) == [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n",
        "idx_generation": 411,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of trailing zeros in n factorial.\n    \"\"\"\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n    return count\n\ndef g():\n    return 25\n\nassert f(g()) == 6\n",
        "idx_generation": 359,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Parameters:\n    nums (List[int]): The list of integers.\n\n    Returns:\n    int: The maximum product of any two distinct numbers in the list.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1], nums[n-2] * nums[n-1])\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n\n    Returns:\n    List[int]: A list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 20\n\n",
        "idx_generation": 468,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\nimport heapq\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and an integer k, find the k largest elements in nums in sorted order.\n    \"\"\"\n\n    heap = []\n    for num in nums:\n        heapq.heappush(heap, num)\n        if len(heap) > k:\n            heapq.heappop(heap)\n\n    return sorted(heap)\n\ndef g():\n    nums = [1, 3, 5, 2, 4]\n    k = 3\n    return nums, k\n\nassert f(*g()) == [3, 4, 5]\n\n",
        "idx_generation": 166,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, return True if there exists two numbers in the list that sum up to the given target.\n    Otherwise, return False.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g(), 10) == True\n",
        "idx_generation": 37,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Sort the given list of integers in ascending order using a stack and merge sort algorithm.\n    \"\"\"\n    def merge_sort(nums):\n        if len(nums) <= 1:\n            return nums\n        mid = len(nums) // 2\n        left = merge_sort(nums[:mid])\n        right = merge_sort(nums[mid:])\n        return merge(left, right)\n    \n    def merge(left, right):\n        merged = []\n        i, j = 0, 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged\n    \n    return merge_sort(nums)\n\ndef g():\n    return [9, 5, 2, 7, 1, 3, 6, 8, 4]\n\nassert f(g()) == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n",
        "idx_generation": 434,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a 2D matrix of integers and a target integer, determine if the target value exists in the matrix.\n\n    Example:\n    matrix = [\n        [1, 4, 7, 11, 15],\n        [2, 5, 8, 12, 19],\n        [3, 6, 9, 16, 22],\n        [10, 13, 14, 17, 24],\n        [18, 21, 23, 26, 30]\n    ]\n    target = 9\n\n    Output:\n    True\n\n    Explanation:\n    The target value 9 exists in the matrix.\n\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    # Start from top right corner of the matrix\n    row = 0\n    col = cols - 1\n\n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n\n    return False\n\ndef g(matrix=[\n    [1, 4, 7, 11, 15],\n    [2, 5, 8, 12, 19],\n    [3, 6, 9, 16, 22],\n    [10, 13, 14, 17, 24],\n    [18, 21, 23, 26, 30]\n], target=9):\n    return matrix, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 495,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    \n    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 60\n",
        "idx_generation": 206,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target integer, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the original list.\n    \"\"\"\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    \"\"\"\n    Return the given list of integers and the target integer.\n    \"\"\"\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 428,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there are k integers in the list that\n    sum up to the target value. Return True if such k-sums exist, otherwise return False.\n\n    Example:\n    arr = [1, 4, 2, 8, 3, 5]\n    target = 10\n    k = 3\n\n    Output:\n    True\n\n    Explanation:\n    The triplets [1, 2, 7] and [4, 3, 3] sum up to the target value 10.\n\n    Hint: Use a combination of sorting, searching, and counting techniques to find the k-sums.\n    \"\"\"\n    arr.sort()\n    return find_k_sum(arr, target, k)\n\ndef find_k_sum(arr: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Helper function to find if there are k integers in the list that sum up to the target value.\n    \"\"\"\n    if k == 0:\n        return target == 0\n    if k == 1:\n        return target in arr\n    for i in range(len(arr) - k + 1):\n        if i > 0 and arr[i] == arr[i - 1]:\n            continue\n        if find_k_sum(arr[i + 1:], target - arr[i], k - 1):\n            return True\n    return False\n\ndef g(arr=[1, 4, 2, 8, 3, 5], target=10, k=3):\n    return arr, target, k\n\nassert f(*g()) == True\n",
        "idx_generation": 309,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence (not necessarily contiguous).\n    Return the length of the longest increasing subsequence.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    \n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 126,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, substr: str) -> bool:\n    \"\"\"\n    Check if the given string 's' can be formed by concatenating multiple occurrences of the substring 'substr'.\n    \"\"\"\n    n = len(s)\n    m = len(substr)\n    if n % m != 0:\n        return False\n    count = n // m\n    if substr * count == s:\n        return True\n    return False\n\n\ndef g(s=\"abcabcabc\", substr=\"abc\"):\n    return s, substr\n\n\nassert f(*g()) == True\n",
        "idx_generation": 108,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string, find the number of palindromic substrings.\n    \"\"\"\n    count = 0\n\n    def expand(left, right):\n        nonlocal count\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            count += 1\n            left -= 1\n            right += 1\n\n    for i in range(len(s)):\n        expand(i, i)  # odd length palindromes\n        expand(i, i + 1)  # even length palindromes\n\n    return count\n\ndef g(s: str):\n    return s\n\nassert f(g(\"abcba\")) == 7\n",
        "idx_generation": 304,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find two numbers in the list that add up to the target number.\n    Return the indices of the two numbers in ascending order.\n\n    Example:\n    Input:\n    nums = [2, 7, 11, 15]\n    target = 9\n    Output: [0, 1]\n    Explanation: The numbers at indices 0 and 1 (2 and 7) add up to the target number 9.\n    \"\"\"\n\n    # Create a dictionary to store the complement of each number and its index\n    complements = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complements:\n            return [complements[complement], i]\n        complements[num] = i\n\n    return []\n\ndef g(nums: List[int] = [2, 7, 11, 15], target: int = 9):\n    return (nums, target)\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 406,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Find the Missing Number\n\n    Given a list of integers from 0 to n, with one number missing, return the missing number.\n\n    Example:\n    nums = [3, 0, 1]\n    output: 2\n\n    Explanation:\n    The missing number is 2.\n    \"\"\"\n    n = len(nums)\n    expected_sum = (n * (n + 1)) // 2\n    actual_sum = sum(nums)\n    return expected_sum - actual_sum\n\ndef g(nums = [3, 0, 1]):\n    return nums\n\nassert f(g()) == 2\n",
        "idx_generation": 115,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all the multiples of 3 or 5 below n.\n\n    Example:\n    n = 10\n\n    Output:\n    23\n\n    Explanation:\n    The multiples of 3 or 5 below 10 are: 3, 5, 6, and 9. Their sum is 23.\n    \"\"\"\n    sum = 0\n\n    for i in range(n):\n        if i % 3 == 0 or i % 5 == 0:\n            sum += i\n\n    return sum\n\ndef g(n=10):\n    return n\n\nassert f(g()) == 23\n",
        "idx_generation": 260,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a subarray whose sum is zero.\n\n    Example:\n    nums = [4, 2, -3, 1, 6]\n    \n    Output:\n    True\n    \n    Explanation:\n    The subarray with sum zero is [2, -3, 1].\n    \"\"\"\n    prefix_sum = 0\n    prefix_sum_set = set()\n    \n    for num in nums:\n        prefix_sum += num\n        if prefix_sum == 0 or prefix_sum in prefix_sum_set:\n            return True\n        prefix_sum_set.add(prefix_sum)\n    \n    return False\n\ndef g() -> List[int]:\n    return [4, 2, -3, 1, 6]\n\nassert f(g()) == True\n",
        "idx_generation": 441,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in the list that add up to the target and return their indices.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The sum of nums[0] and nums[1] is 2 + 7 = 9, so the output is [0, 1].\n\n    Hint: Use a dictionary to store the complement of each number in nums and check if the complement exists in the dictionary.\n    \"\"\"\n\n    complement_dict = {}\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in complement_dict:\n            return [complement_dict[complement], i]\n        complement_dict[nums[i]] = i\n\n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return nums, target\n\nassert f(g()[0], g()[1]) == [0, 1]\n",
        "idx_generation": 206,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n\n    Example:\n    n = 6\n\n    Output:\n    8\n\n    Explanation:\n    The 6th Fibonacci number is 8 (0, 1, 1, 2, 3, 5, 8).\n    \"\"\"\n\n    if n <= 1:\n        return n\n\n    fib = [0, 1]\n    for i in range(2, n+1):\n        fib.append(fib[i-1] + fib[i-2])\n\n    return fib[n]\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    return 6\n\nassert f(g()) == 8\n\n",
        "idx_generation": 480,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return the list in reverse order using a stack.\n    \"\"\"\n    stack = []\n    for num in nums:\n        stack.append(num)\n    reversed_nums = []\n    while stack:\n        reversed_nums.append(stack.pop())\n    return reversed_nums\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g()) == [5, 4, 3, 2, 1]\n",
        "idx_generation": 206,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the shortest path from the top-left cell to the bottom-right cell. Each cell in the grid represents the cost to move to that cell. You can only move down or right.\n\n    Example:\n    Input: grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    Output: 7\n\n    Explanation:\n    The shortest path is 1 -> 3 -> 1 -> 1 -> 1, which has a total cost of 7.\n\n    Hint: Use dynamic programming to calculate the minimum cost to reach each cell.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[m - 1][n - 1]\n\ndef g(grid: List[List[int]] = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) -> List[List[int]]:\n    \"\"\"\n    Generate the value of grid for the function f.\n    \"\"\"\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 475,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the total perimeter of a polygon given its vertices.\n    The vertices are given in clockwise order.\n    \"\"\"\n    perimeter = 0\n\n    for i in range(len(points)):\n        x1, y1 = points[i]\n        x2, y2 = points[(i + 1) % len(points)]\n        distance = ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n        perimeter += distance\n\n    return perimeter\n\ndef g(points=[[0, 0], [0, 1], [1, 1], [1, 0]]):\n    return points\n\nassert f(g()) == 4\n",
        "idx_generation": 247,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum along a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n\n    for i in range(1, n):\n        grid[0][i] += grid[0][i-1]\n    for i in range(1, m):\n        grid[i][0] += grid[i-1][0]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            grid[i][j] += max(grid[i-1][j], grid[i][j-1])\n\n    return grid[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate the input grid for the function f.\n    \"\"\"\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 12\n",
        "idx_generation": 130,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome.\n\n    Example:\n    s = \"racecar\"\n\n    Output:\n    True\n\n    Explanation:\n    The string \"racecar\" is a palindrome.\n\n    Hint: Compare the string with its reverse to check if it is a palindrome.\n    \"\"\"\n\n    return s == s[::-1]\n\ndef g(s: str):\n    return s\n\nassert f(g(\"hello\")) == False\n",
        "idx_generation": 483,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the length of the longest substring without repeating characters.\n\n    Example:\n    Input: \"abcabcbb\"\n    Output: 3\n    Explanation: The longest substring without repeating characters is \"abc\", which has a length of 3.\n    \"\"\"\n    if len(s) < 2:\n        return len(s)\n    max_length = 0\n    start = 0\n    seen = {}\n    for end in range(len(s)):\n        if s[end] in seen and start <= seen[s[end]]:\n            start = seen[s[end]] + 1\n        else:\n            max_length = max(max_length, end - start + 1)\n        seen[s[end]] = end\n    return max_length\n\ndef g():\n    return \"abcabcbb\"\n\nassert f(g()) == 3\n\n",
        "idx_generation": 109,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a number n is a power of two.\"\"\"\n    if n == 0:\n        return False\n    return n & (n - 1) == 0\n\ndef g(n=16):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 73,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number is a perfect square\"\"\"\n    return n**0.5 % 1 == 0\n\ndef g() -> int:\n    \"\"\"\n    Generate the smallest perfect square greater than 1000.\n    \"\"\"\n    def find_perfect_square(n: int) -> int:\n        if f(n):\n            return n\n        return find_perfect_square(n + 1)\n\n    return find_perfect_square(32)\n\nassert f(g()) == True\n",
        "idx_generation": 51,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of numbers, find the minimum path sum from the top-left to the bottom-right cell.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g():\n    grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    return grid\n\nassert f(g()) == 7\n\n",
        "idx_generation": 452,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> List[int]:\n    \"\"\"\n    Given the root of a binary tree, return the inorder traversal of its nodes' values.\n\n    Example:\n    Input: [1,null,2,3]\n       1\n        \\\n         2\n        /\n       3\n\n    Output: [1,3,2]\n    \"\"\"\n    stack = []\n    inorder = []\n\n    while stack or root:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        inorder.append(root.val)\n        root = root.right\n\n    return inorder\n\ndef g():\n    root = TreeNode(1)\n    root.right = TreeNode(2)\n    root.right.left = TreeNode(3)\n    return root\n\nassert f(g()) == [1, 3, 2]\n",
        "idx_generation": 399,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Find if the target number is present in the matrix.\"\"\"\n    if not matrix or not matrix[0]:\n        return False\n    m, n = len(matrix), len(matrix[0])\n    queue = deque([(0, 0)])\n    visited = set()\n    while queue:\n        x, y = queue.popleft()\n        if matrix[x][y] == target:\n            return True\n        visited.add((x, y))\n        if x < m - 1 and (x + 1, y) not in visited:\n            queue.append((x + 1, y))\n        if y < n - 1 and (x, y + 1) not in visited:\n            queue.append((x, y + 1))\n    return False\n\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]], target=5):\n    return matrix, target\n\nassert f(*g())\n",
        "idx_generation": 88,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target=10) -> bool:\n    \"\"\"Find if there exists a path in a grid that sums up to the target\"\"\"\n    def dfs(i, j, curr_sum):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]):\n            return False\n        curr_sum += grid[i][j]\n        if curr_sum == target:\n            return True\n        return dfs(i + 1, j, curr_sum) or dfs(i, j + 1, curr_sum)\n    \n    return dfs(0, 0, 0)\n    \ndef g(grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], target = 10):\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 43,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(adj_list: Dict[int, List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency list representing an undirected graph, determine if the graph is bipartite.\n    A graph is bipartite if it is possible to split its nodes into two independent sets such that\n    there is no edge between nodes of the same set.\n    \"\"\"\n    colors = {}\n    def dfs(node, color):\n        colors[node] = color\n        for neighbor in adj_list[node]:\n            if neighbor not in colors:\n                if not dfs(neighbor, not color):\n                    return False\n            elif colors[neighbor] == color:\n                return False\n        return True\n\n    for node in adj_list:\n        if node not in colors:\n            if not dfs(node, True):\n                return False\n    return True\n\ndef g():\n    adj_list = {\n        1: [2, 3],\n        2: [1, 4],\n        3: [1, 4],\n        4: [2, 3]\n    }\n    return adj_list\n\nassert f(g()) == True\n",
        "idx_generation": 73,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, find all unique combinations in the list that sum up to a target number.\n    Each number in the list can be used multiple times.\n    \"\"\"\n    def backtrack(nums, target, path, res):\n        if target < 0:\n            return\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(len(nums)):\n            backtrack(nums[i:], target - nums[i], path + [nums[i]], res)\n\n    res = []\n    backtrack(nums, target, [], res)\n    return res\n\ndef g():\n    nums = [2, 3, 6, 7]\n    target = 7\n    return nums, target\n\nassert f(*g()) == [[2, 2, 3], [7]]\n",
        "idx_generation": 110,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], target: str) -> bool:\n    \"\"\"\n    Given a list of words and a target word, determine if the target word is present in the list.\n    The target word can be formed by concatenating two or more words from the list in any order.\n\n    Example:\n    words = [\"coding\", \"is\", \"fun\"]\n    target = \"codingfun\"\n\n    Output:\n    True (since \"codingfun\" can be formed by concatenating \"coding\" and \"fun\" from the list)\n\n    Note:\n    - The target word can only be formed by concatenating words from the list, and no other characters can be included.\n    \"\"\"\n\n    def dfs(word: str, visited: List[bool]) -> bool:\n        if word == \"\":\n            return True\n\n        for i in range(len(words)):\n            if visited[i]:\n                continue\n\n            if word.startswith(words[i]):\n                visited[i] = True\n                if dfs(word[len(words[i]):], visited):\n                    return True\n                visited[i] = False\n\n        return False\n\n    visited = [False] * len(words)\n    return dfs(target, visited)\n\n\ndef g():\n    return ([\"coding\", \"is\", \"fun\"], \"codingfun\")\n\n\nassert f(*g()) == True\n\n",
        "idx_generation": 458,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of ways to arrange k items out of n, considering that the order matters.\n    \"\"\"\n    def factorial(num):\n        if num == 0 or num == 1:\n            return 1\n        else:\n            return num * factorial(num - 1)\n    \n    return factorial(n) // factorial(n - k)\n\ndef g(n=5, k=3):\n    \"\"\"\n    Generate two integers n and k such that there exists a valid number of ways to arrange k items out of n.\n    \"\"\"\n    return n, k\n\nassert f(*g()) == 60\n\n",
        "idx_generation": 385,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there exists a pair of numbers whose sum is equal to a target value.\n    \"\"\"\n    def binary_search(arr, start, end, target):\n        if start > end:\n            return False\n        mid = (start + end) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            return binary_search(arr, mid+1, end, target)\n        else:\n            return binary_search(arr, start, mid-1, target)\n\n    target_sum = 10\n    for i in range(len(arr)):\n        complement = target_sum - arr[i]\n        if binary_search(arr, i+1, len(arr)-1, complement):\n            return True\n    return False\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    return arr\n\nassert f(g()) == True\n",
        "idx_generation": 469,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order using the bubble sort algorithm.\n    \"\"\"\n    n = len(nums)\n    \n    for i in range(n - 1):\n        for j in range(n - i - 1):\n            if nums[j] > nums[j + 1]:\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n    \n    return nums\n\ndef g(nums: List[int] = [5, 2, 8, 1, 3]):\n    \"\"\"\n    Generate a list of integers for the function f.\n    \"\"\"\n    return nums\n\nassert f(g()) == [1, 2, 3, 5, 8]\n\n",
        "idx_generation": 182,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there are two numbers in the list that add up to the target\"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    nums = [2, 4, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 38,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted (in ascending order) integer array nums and a target value, find the starting and ending position of a given target value in the array.\n\n    Your algorithm's runtime complexity must be in the order of O(log n).\n\n    If the target is not found in the array, return [-1, -1].\n\n    Example:\n    nums = [5,7,7,8,8,10]\n    target = 8\n\n    Output:\n    [3, 4]\n\n    Explanation:\n    The value 8 appears at indices 3 and 4 in the array.\n    \"\"\"\n    def binary_search(nums, target, left):\n        low = 0\n        high = len(nums) - 1\n\n        while low <= high:\n            mid = (low + high) // 2\n            if nums[mid] > target or (left and nums[mid] == target):\n                high = mid - 1\n            else:\n                low = mid + 1\n\n        return low\n\n    left_idx = binary_search(nums, target, True)\n    if left_idx >= len(nums) or nums[left_idx] != target:\n        return [-1, -1]\n\n    right_idx = binary_search(nums, target, False) - 1\n\n    return [left_idx, right_idx]\n\ndef g(nums: List[int] = [5,7,7,8,8,10], target: int = 8):\n    return (nums, target,)\n\nassert f(*g()) == [3, 4]\n\n",
        "idx_generation": 494,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    24 (the maximum product can be obtained by multiplying 2, 3, and 4)\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3])\n\ndef g(nums: List[int] = [1, 2, 3, 4]):\n    return (nums,)\n\nassert f(*g()) == 24\n",
        "idx_generation": 209,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, return the length of the shortest path from the top-left corner to the bottom-right corner.\n    You can only move right or down.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n    \"\"\"\n\n    def shortest_path(grid):\n        rows = len(grid)\n        cols = len(grid[0])\n        dp = [[0] * cols for _ in range(rows)]\n\n        dp[0][0] = grid[0][0]\n        for i in range(1, rows):\n            dp[i][0] = dp[i - 1][0] + grid[i][0]\n        for j in range(1, cols):\n            dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n        for i in range(1, rows):\n            for j in range(1, cols):\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n        return dp[rows - 1][cols - 1]\n\n    return shortest_path(grid)\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n\n",
        "idx_generation": 444,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, determine the number of pairs of integers in the list that have a difference of exactly 1.\n\n    Example:\n    arr = [1, 4, 2, 8, 3, 5]\n\n    Output:\n    4\n\n    Explanation:\n    The pairs with a difference of 1 are (1, 2), (1, 3), (4, 5), and (8, 9).\n\n    Hint: Use sorting and counting techniques to find the pairs.\n    \"\"\"\n    arr.sort()\n    count = 0\n    for i in range(len(arr) - 1):\n        if arr[i + 1] - arr[i] == 1:\n            count += 1\n    return count\n\ndef g(arr=[1, 4, 2, 8, 3, 5]):\n    return arr\n\nassert f(g()) == 4\n",
        "idx_generation": 309,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a subset whose sum is equal to the target value.\n\n    Return True if such a subset exists, False otherwise.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n\n    Output:\n    True\n\n    Explanation:\n    There exists a subset [2, 3, 4] whose sum is equal to the target value of 9.\n    \"\"\"\n    def subset_sum(nums, target, index, curr_sum):\n        if curr_sum == target:\n            return True\n        if index >= len(nums):\n            return False\n        \n        include = subset_sum(nums, target, index+1, curr_sum + nums[index])\n        exclude = subset_sum(nums, target, index+1, curr_sum)\n        \n        return include or exclude\n    \n    return subset_sum(nums, target, 0, 0)\n\ndef g(nums=[1, 2, 3, 4, 5], target=9):\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 127,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return the list with all even numbers removed and the remaining numbers sorted in descending order.\n\n    Example:\n    nums = [3, 7, 12, 5, 8, 9, 2]\n\n    Output:\n    [9, 7, 5, 3]\n    \"\"\"\n\n    def remove_even_sort_descending(nums):\n        odd_nums = [num for num in nums if num % 2 != 0]\n        odd_nums.sort(reverse=True)\n        return odd_nums\n\n    return remove_even_sort_descending(nums)\n\ndef g():\n    nums = [3, 7, 12, 5, 8, 9, 2]\n    return nums\n\nassert f(g()) == [9, 7, 5, 3]\n",
        "idx_generation": 113,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it can be segmented into a space-separated sequence of one or more dictionary words.\n\n    Example:\n    s = \"leetcode\"\n\n    Output:\n    True\n\n    Explanation:\n    The string \"leetcode\" can be segmented into \"leet\" and \"code\", both of which are dictionary words.\n    \"\"\"\n\n    def backtrack(start):\n        if start == len(s):\n            return True\n\n        for end in range(start + 1, len(s) + 1):\n            if s[start:end] in dictionary and backtrack(end):\n                return True\n\n        return False\n\n    # Dictionary of valid words\n    dictionary = {\"leet\", \"code\"}\n\n    return backtrack(0)\n\ndef g(s=\"leetcode\"):\n    return s\n\nassert f(g()) == True\n\n",
        "idx_generation": 311,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum product of any two distinct numbers in the array.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    20\n\n    Explanation:\n    The maximum product of two distinct numbers in the array is 5 * 4 = 20.\n\n    \"\"\"\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n    return max_product\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 20\n",
        "idx_generation": 410,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the maximum product of two positive integers whose sum is n.\n    \"\"\"\n    def find_max_product(n):\n        max_product = 0\n\n        for i in range(1, n):\n            j = n - i\n            product = i * j\n            max_product = max(max_product, product)\n\n        return max_product\n\n    return find_max_product(n)\n\ndef g(n: int = 10) -> int:\n    \"\"\"Generate a positive integer.\"\"\"\n    return n\n\nassert f(g()) == 25\n\n",
        "idx_generation": 117,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the minimum number of operations required to make the sum of the list equal to the target value.\n    The possible operations are:\n    - Add a positive integer to the list\n    - Subtract a positive integer from the list\n\n    Args:\n    - nums: The list of integers.\n    - target: The target value.\n\n    Returns:\n    - The minimum number of operations required to make the sum of the list equal to the target value.\n    \"\"\"\n    n = len(nums)\n    dp = [[float('inf')] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(target + 1):\n            if nums[i - 1] <= j:\n                dp[i][j] = min(dp[i - 1][j], 1 + dp[i][j - nums[i - 1]])\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[n][target]\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    target = 10\n    return nums, target\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 288,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the numbers in the original list except the corresponding element.\n    \"\"\"\n    n = len(arr)\n    product = 1\n    for num in arr:\n        product *= num\n    \n    result = []\n    for num in arr:\n        result.append(product // num)\n    \n    return result\n\ndef g(arr: List[int] = [2, 3, 4, 5]):\n    return arr\n\nassert f(g()) == [60, 40, 30, 24]\n",
        "idx_generation": 447,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and a target value, find two numbers in the array that sum up to the target value.\n    Return the indices of the two numbers.\n\n    Example:\n    f([2, 7, 11, 15], 9) returns [0, 1], as nums[0] + nums[1] = 2 + 7 = 9.\n\n    Note:\n    - The input array is guaranteed to have exactly one solution.\n    - The same element cannot be used twice.\n    \"\"\"\n\n    complement_map = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n\n        if complement in complement_map:\n            return [complement_map[complement], i]\n\n        complement_map[num] = i\n\n    return []\n\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate an array of integers and a target value.\n\n    Example:\n    g() returns ([2, 7, 11, 15], 9)\n\n    Note:\n    - The generated array is guaranteed to have at least two elements.\n    - The generated target value should be a valid target for the array.\n    \"\"\"\n\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    return nums, target\n\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 209,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the factorial of n.\n\n    Example:\n    n = 5\n\n    Output:\n    120\n\n    Explanation:\n    The factorial of 5 is 5 * 4 * 3 * 2 * 1 = 120.\n    \"\"\"\n\n    if n == 0:\n        return 1\n\n    factorial = 1\n    for i in range(1, n+1):\n        factorial *= i\n\n    return factorial\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    return 5\n\nassert f(g()) == 120\n\n",
        "idx_generation": 480,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "import math\nfrom typing import*\ndef f(expression: str) -> bool:\n    \"\"\"\n    Given a mathematical expression, check if the parentheses are balanced.\n    \"\"\"\n    stack = []\n    opening_brackets = ['(', '[', '{']\n    closing_brackets = [')', ']', '}']\n\n    for char in expression:\n        if char in opening_brackets:\n            stack.append(char)\n        elif char in closing_brackets:\n            if len(stack) == 0:\n                return False\n            else:\n                top = stack.pop()\n                if opening_brackets.index(top) != closing_brackets.index(char):\n                    return False\n\n    return len(stack) == 0\n\n\ndef g(expression: str = \"((2 + 3) * 5) - (4 / 2)\"):\n    \"\"\"\n    Check if the parentheses in the expression are balanced.\n    \"\"\"\n    return expression\n\n\nassert f(g()) == True\n",
        "idx_generation": 214,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n\n    Example:\n    n = 3\n    There are 3 ways to climb to the top: 1 -> 1 -> 1, 1 -> 2, 2 -> 1.\n\n    Hint: Use dynamic programming to calculate the number of ways to climb to each step.\n    \"\"\"\n    if n <= 2:\n        return n\n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\ndef g(n: int = 3) -> int:\n    \"\"\"Generate a positive integer n.\"\"\"\n    return n\n\nassert f(g()) == 3\n",
        "idx_generation": 476,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a 2D grid of integers, rotate the grid 90 degrees clockwise.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    [\n        [7, 4, 1],\n        [8, 5, 2],\n        [9, 6, 3]\n    ]\n\n    Hint: Use a two-step process to rotate the grid. First, transpose the grid by swapping elements along the main diagonal. Then, reverse each row of the transposed grid.\n    \"\"\"\n\n    if not grid:\n        return grid\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Transpose the grid\n    for i in range(rows):\n        for j in range(i, cols):\n            grid[i][j], grid[j][i] = grid[j][i], grid[i][j]\n\n    # Reverse each row of the transposed grid\n    for i in range(rows):\n        grid[i] = grid[i][::-1]\n\n    return grid\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a 2D grid of integers.\n    \"\"\"\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g()) == [\n    [7, 4, 1],\n    [8, 5, 2],\n    [9, 6, 3]\n]\n\n",
        "idx_generation": 251,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers n and m, find the number of unique paths from the top-left corner to the bottom-right corner of an n x m grid.\n    You can only move down or right at any point in time.\n    Return the number of unique paths.\n    \"\"\"\n    dp = [[0] * m for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][0] = 1\n    \n    for j in range(m):\n        dp[0][j] = 1\n    \n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[n-1][m-1]\n\ndef g():\n    n = 3\n    m = 7\n    return n, m\n\nassert f(*g()) == 28\n",
        "idx_generation": 138,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s consisting of lowercase English letters, return the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n\n    Output:\n    3 (as the longest substring without repeating characters is \"abc\")\n\n    \"\"\"\n    if not s:\n        return 0\n    \n    max_length = 0\n    start = 0\n    seen = {}\n    \n    for end in range(len(s)):\n        if s[end] in seen and start <= seen[s[end]]:\n            start = seen[s[end]] + 1\n        else:\n            max_length = max(max_length, end - start + 1)\n        \n        seen[s[end]] = end\n\n    return max_length\n\ndef g(s = \"pwwkew\"):\n    return s\n\nassert f(g()) == 3\n\n",
        "idx_generation": 485,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, check if it can be generated by a recursive function.\n    \"\"\"\n    def is_recursive(s):\n        if s == \"A\":\n            return True\n        if len(s) >= 3 and s[0] == \"B\" and s[-1] == \"C\":\n            return is_recursive(s[1:-1])\n        return False\n    \n    return is_recursive(s)\n\ndef g():\n    s = \"BAC\"\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 120,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(num1: int, num2: int) -> int:\n    \"\"\"Perform the XOR operation on two integers num1 and num2.\"\"\"\n    return num1 ^ num2\n\ndef g(num1=10, num2=5):\n    return num1, num2\n\nassert f(*g()) == 15\n",
        "idx_generation": 73,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if n is a perfect square\"\"\"\n    if n < 0:\n        return False\n    sqrt = int(n**0.5)\n    return sqrt * sqrt == n\ndef g():\n    return 64\nassert f(g()) == True\n",
        "idx_generation": 52,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the maximum sum you can obtain by starting at the top-left corner and ending at the bottom-right corner.\n    You can only move down or right.\n\n    Args:\n    - grid: A 2D grid of integers.\n\n    Returns:\n    - The maximum sum you can obtain by starting at the top-left corner and ending at the bottom-right corner.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    return grid\n\nassert f(g()) == 12\n\n",
        "idx_generation": 464,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given an undirected graph and two nodes, determine if there is a path between the two nodes.\n\n    Args:\n    - graph: An adjacency list representation of the undirected graph.\n    - start: The starting node.\n    - end: The ending node.\n\n    Returns:\n    - True if there is a path between the two nodes, False otherwise.\n\n    Example:\n    f([[1,2],[0,2,3],[0,1,3],[2]], 0, 3) returns True\n    f([[1,3],[0,2],[1,3],[0,2]], 0, 2) returns False\n    \"\"\"\n\n    def dfs(node, visited):\n        if node == end:\n            return True\n        \n        visited.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited):\n                    return True\n        \n        return False\n\n    visited = set()\n    return dfs(start, visited)\n\ndef g() -> Tuple[List[List[int]], int, int]:\n    \"\"\"\n    Generate an undirected graph and two nodes.\n\n    Returns:\n    - The generated graph and the two nodes.\n\n    Example:\n    g() returns ([[1,2],[0,2,3],[0,1,3],[2]], 0, 3)\n    \"\"\"\n\n    return ([[1,2],[0,2,3],[0,1,3],[2]], 0, 3)\n\nassert f(*g()) == True\n",
        "idx_generation": 406,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, target: int) -> bool:\n    \"\"\"Check if there is a path from the start node to the target node in a given graph.\"\"\"\n    visited = set()\n    stack = [start]\n    \n    while stack:\n        node = stack.pop()\n        visited.add(node)\n        \n        if node == target:\n            return True\n        \n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    \n    return False\n\ndef g():\n    graph = [[1, 2], [3], [4, 5], [6], [], [7], [8], [9], [], []]\n    start = 0\n    target = 9\n    return graph, start, target\n\nassert f(*g()) == True\n",
        "idx_generation": 107,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Node:\n    def __init__(self, val: int) -> None:\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef f(root: Node) -> bool:\n    \"\"\"Check if the binary tree is symmetric\"\"\"\n    def is_symmetric(left: Node, right: Node) -> bool:\n        if not left and not right:\n            return True\n        if not left or not right:\n            return False\n        return left.val == right.val and is_symmetric(left.left, right.right) and is_symmetric(left.right, right.left)\n    \n    return is_symmetric(root.left, root.right)\n\ndef g() -> Node:\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(2)\n    root.left.left = Node(3)\n    root.left.right = Node(4)\n    root.right.left = Node(4)\n    root.right.right = Node(3)\n    return root\n\nassert f(g()) == True\n",
        "idx_generation": 47,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the length of the longest increasing path.\n    A path is considered increasing if each number in the path is greater than the previous number.\n    \"\"\"\n    if not matrix:\n        return 0\n\n    rows, cols = len(matrix), len(matrix[0])\n    dp = [[0] * cols for _ in range(rows)]\n    max_length = 0\n\n    def dfs(row, col):\n        if dp[row][col] != 0:\n            return dp[row][col]\n\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        length = 1\n\n        for dx, dy in directions:\n            new_row, new_col = row + dx, col + dy\n            if 0 <= new_row < rows and 0 <= new_col < cols and matrix[new_row][new_col] > matrix[row][col]:\n                length = max(length, 1 + dfs(new_row, new_col))\n\n        dp[row][col] = length\n        return length\n\n    for i in range(rows):\n        for j in range(cols):\n            max_length = max(max_length, dfs(i, j))\n\n    return max_length\n\ndef g():\n    matrix = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n    return matrix\n\nassert f(g()) == 4\n",
        "idx_generation": 79,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "import itertools\nfrom typing import*\nfrom itertools import combinations\n\ndef f(n: int, k: int, c: int, a=[1,2,3,4,5,6]) -> bool:\n    \"\"\"\n    Given a list of integers, find if there exists a combination of k integers that sums up to a given number n, \n    such that the sum of the selected integers is divisible by c.\n\n    Sample input:\n    n = 8\n    k = 3\n    c = 2\n    a = [1,2,3,4,5,6]\n\n    Sample output:\n    True\n\n    We can select the integers [2, 3, 3] from the list [1,2,3,4,5,6] such that their sum is 8 and it is divisible by 2.\n    \"\"\"\n    for comb in combinations(a, k):\n        if sum(comb) == n and sum(comb) % c == 0:\n            return True\n    return False\n\ndef g(n = 8, k = 3, c = 2, a = [1,2,3,4,5,6]):\n    return n, k, c, a\n\nassert f(*g())\n",
        "idx_generation": 0,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Find the number of unique subsets that can be formed from the given list of integers.\n    \"\"\"\n\n    def count_subsets(nums: List[int], index: int, subset: int) -> int:\n        if index == len(nums):\n            return 1\n\n        count = count_subsets(nums, index + 1, subset)  # exclude current element\n        count += count_subsets(nums, index + 1, subset ^ nums[index])  # include current element\n\n        return count\n\n    return count_subsets(nums, 0, 0)\n\ndef g(nums=[1, 2, 3]):\n    \"\"\"\n    Generate a list of numbers to find the number of unique subsets that can be formed.\n    \"\"\"\n    return nums\n\nassert f(g()) == 8\n",
        "idx_generation": 111,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the minimum number of cuts needed to partition the string into palindromic substrings.\n\n    Example:\n    s = \"aab\"\n\n    Output:\n    1\n\n    Explanation:\n    The string \"aab\" can be partitioned into \"aa\" and \"b\", which requires 1 cut.\n    \"\"\"\n\n    def is_palindrome(s):\n        left = 0\n        right = len(s) - 1\n\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n\n        return True\n\n    def min_cuts(s, start, end):\n        if start >= end or is_palindrome(s[start:end+1]):\n            return 0\n\n        min_cuts_needed = float('inf')\n        for i in range(start, end):\n            if is_palindrome(s[start:i+1]):\n                min_cuts_needed = min(min_cuts_needed, 1 + min_cuts(s, i+1, end))\n\n        return min_cuts_needed\n\n    return min_cuts(s, 0, len(s)-1)\n\ndef g(s = \"aab\"):\n    return s\n\nassert f(g()) == 1\n",
        "idx_generation": 475,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, find the number of ways to choose k elements from a set of n elements.\n\n    Sample Input:\n    n = 5\n    k = 3\n\n    Sample Output:\n    10\n    \"\"\"\n\n    def factorial(x: int) -> int:\n        if x == 0 or x == 1:\n            return 1\n        return x * factorial(x-1)\n\n    return factorial(n) // (factorial(k) * factorial(n-k))\n\ndef g(n=5, k=3):\n    return n, k\n\nassert f(*g()) == 10\n",
        "idx_generation": 416,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    20\n\n    Explanation:\n    The maximum product of any two distinct numbers in the list is 5 * 4 = 20.\n\n    Hint: Sort the list in descending order and multiply the first two numbers.\n    \"\"\"\n\n    nums.sort(reverse=True)\n    return nums[0] * nums[1]\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return [nums]\n\nassert f(*g()) == 20\n",
        "idx_generation": 469,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, return True if there exists two numbers in the list\n    whose sum is equal to the target value, and False otherwise.\n    \"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum > target:\n            right -= 1\n        else:\n            left += 1\n    return False\n\ndef g(arr=[1, 5, 3, 7, 9], target=12):\n    \"\"\"\n    Generate a list of integers and a target value such that there exists two numbers\n    in the list whose sum is equal to the target value.\n    \"\"\"\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 211,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Minimum Absolute Difference\n\n    Given a list of numbers, find the pair of numbers with the minimum absolute difference\n    that add up to the given target number. Return the sum of the pair.\n\n    Example:\n    nums = [1, 5, 3, 9, 10]\n    target = 8\n    output: 8\n\n    Explanation:\n    The pair with the minimum absolute difference that adds up to 8 is (1, 9), and their sum is 8.\n    \"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    min_diff = float('inf')\n    res = 0\n\n    while left < right:\n        diff = abs(nums[left] + nums[right] - target)\n        if diff < min_diff:\n            min_diff = diff\n            res = nums[left] + nums[right]\n        if nums[left] + nums[right] == target:\n            return res\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return res\n\ndef g(nums = [1, 5, 3, 9, 10], target = 8):\n    return nums, target\n\nassert f(*g()) == 8\n",
        "idx_generation": 41,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers from the list.\n\n    Example:\n    Input: nums = [-10, -3, 1, 2, 3, 4]\n    Output: 120\n\n    Explanation:\n    The maximum product can be obtained by multiplying -10, -3, and 4, resulting in 120.\n    \"\"\"\n    if len(nums) < 3:\n        return 0\n\n    nums.sort()\n\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\n\ndef g():\n    return [-10, -3, 1, 2, 3, 4]\n\nassert f(g()) == 120\n",
        "idx_generation": 239,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representing a weighted graph, find the minimum spanning tree using Prim's algorithm.\n\n    Example:\n    graph = [\n        [0, 2, 0, 6, 0],\n        [2, 0, 3, 8, 5],\n        [0, 3, 0, 0, 7],\n        [6, 8, 0, 0, 9],\n        [0, 5, 7, 9, 0]\n    ]\n\n    Output:\n    16\n\n    Explanation:\n    The minimum spanning tree has the following edges: [(0, 1), (1, 2), (0, 3), (1, 4)], with a total weight of 16.\n\n    Constraints:\n    - The input graph will be represented as a square matrix.\n    - The weight of each edge will be a non-negative integer.\n    \"\"\"\n\n    num_vertices = len(graph)\n    mst = [False] * num_vertices\n    key = [float('inf')] * num_vertices\n    parent = [None] * num_vertices\n    key[0] = 0\n\n    for _ in range(num_vertices):\n        min_key = float('inf')\n        min_vertex = None\n        for v in range(num_vertices):\n            if not mst[v] and key[v] < min_key:\n                min_key = key[v]\n                min_vertex = v\n        mst[min_vertex] = True\n\n        for v in range(num_vertices):\n            if graph[min_vertex][v] > 0 and not mst[v] and graph[min_vertex][v] < key[v]:\n                key[v] = graph[min_vertex][v]\n                parent[v] = min_vertex\n\n    return sum(graph[v][parent[v]] for v in range(1, num_vertices))\n\ndef g():\n    graph = [\n        [0, 2, 0, 6, 0],\n        [2, 0, 3, 8, 5],\n        [0, 3, 0, 0, 7],\n        [6, 8, 0, 0, 9],\n        [0, 5, 7, 9, 0]\n    ]\n    return graph\n\nassert f(g()) == 16\n\n",
        "idx_generation": 476,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if a given list of integers is a permutation of the first n natural numbers.\"\"\"\n    nums.sort()\n    for i in range(len(nums)):\n        if nums[i] != i + 1:\n            return False\n    return True\n\ndef g():\n    return [3, 1, 2]\nassert f(g())\n",
        "idx_generation": 319,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of inversions in the list.\n    An inversion occurs when two elements in the list are out of order.\n    Return the count of inversions in the list.\n\n    Example:\n    nums = [2, 4, 1, 3, 5]\n    Output:\n    3\n    Explanation:\n    There are 3 inversions: (2, 1), (4, 1), and (4, 3).\n    \"\"\"\n\n    def merge_sort(nums: List[int]) -> int:\n        if len(nums) <= 1:\n            return 0\n\n        mid = len(nums) // 2\n        left = nums[:mid]\n        right = nums[mid:]\n\n        inversions = merge_sort(left) + merge_sort(right)\n\n        i = j = k = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                nums[k] = left[i]\n                i += 1\n            else:\n                nums[k] = right[j]\n                j += 1\n                inversions += len(left) - i\n            k += 1\n\n        while i < len(left):\n            nums[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            nums[k] = right[j]\n            j += 1\n            k += 1\n\n        return inversions\n\n    return merge_sort(nums)\n\ndef g() -> List[int]:\n    return [2, 4, 1, 3, 5]\n\nassert f(g()) == 3\n",
        "idx_generation": 156,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string, count the number of distinct substrings that can be formed from the string.\n    Return the count.\n\n    Example:\n    s = \"abc\"\n\n    Output:\n    6\n\n    Explanation:\n    The distinct substrings that can be formed from \"abc\" are:\n    \"a\", \"ab\", \"abc\", \"b\", \"bc\", \"c\".\n\n    Hint: Use a combination of sorting and counting techniques to find the distinct substrings.\n    \"\"\"\n    n = len(s)\n    substrings = set()\n    for i in range(n):\n        for j in range(i+1, n+1):\n            substrings.add(s[i:j])\n    return len(substrings)\n\ndef g(s=\"abc\"):\n    return s\n\nassert f(g()) == 6\n",
        "idx_generation": 114,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> str:\n    \"\"\"\n    Given a positive integer n, return the nth term of the Look-and-say sequence.\n    The Look-and-say sequence starts with 1, and each subsequent term is formed by \"saying\" the previous term.\n    To \"say\" a term, count the number of consecutive digits and append the count followed by the digit.\n    \n    Sample Input:\n    n = 5\n    \n    Sample Output:\n    \"111221\"\n    \n    Explanation:\n    The Look-and-say sequence up to the 5th term is:\n    1\n    11\n    21\n    1211\n    111221\n    The 5th term is \"111221\".\n    \"\"\"\n    if n == 1:\n        return \"1\"\n    \n    prev_term = f(n-1)\n    count = 0\n    digit = prev_term[0]\n    result = \"\"\n    \n    for i in range(len(prev_term)):\n        if prev_term[i] == digit:\n            count += 1\n        else:\n            result += str(count) + digit\n            count = 1\n            digit = prev_term[i]\n    \n    result += str(count) + digit\n    return result\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == \"111221\"\n",
        "idx_generation": 330,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two distinct numbers in the list that \n    add up to the target value. Return the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1 are 2 and 7, and their sum is 9.\n    \"\"\"\n\n    num_dict = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9) -> List[int]:\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 415,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the other elements except itself.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    [24, 12, 8, 6]\n\n    Explanation:\n    The product of all the other elements except 1 is 2 * 3 * 4 = 24.\n    The product of all the other elements except 2 is 1 * 3 * 4 = 12.\n    The product of all the other elements except 3 is 1 * 2 * 4 = 8.\n    The product of all the other elements except 4 is 1 * 2 * 3 = 6.\n\n    Hint: Use prefix and suffix products.\n    \"\"\"\n\n    n = len(nums)\n    prefix_product = [1] * n\n    suffix_product = [1] * n\n\n    for i in range(1, n):\n        prefix_product[i] = prefix_product[i - 1] * nums[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        suffix_product[i] = suffix_product[i + 1] * nums[i + 1]\n\n    result = [prefix_product[i] * suffix_product[i] for i in range(n)]\n\n    return result\n\ndef g():\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == [24, 12, 8, 6]\n",
        "idx_generation": 173,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the numbers in the original list except the one at the same index.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n\n    Sample Output:\n    [120, 60, 40, 30, 24]\n    \"\"\"\n    n = len(nums)\n    prefix_products = [1] * n\n    suffix_products = [1] * n\n\n    for i in range(1, n):\n        prefix_products[i] = prefix_products[i - 1] * nums[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        suffix_products[i] = suffix_products[i + 1] * nums[i + 1]\n\n    result = [prefix_products[i] * suffix_products[i] for i in range(n)]\n    return result\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [120, 60, 40, 30, 24]\n\n",
        "idx_generation": 288,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome after removing at most one character.\n\n    Example:\n    Input: \"abcdcb\"\n    Output: True\n    Explanation: Remove 'd' to get \"abcba\", which is a palindrome.\n\n    Input: \"abcde\"\n    Output: False\n    Explanation: No character can be removed to form a palindrome.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    if is_palindrome(s):\n        return True\n\n    left, right = 0, len(s) - 1\n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s[left:right]) or is_palindrome(s[left+1:right+1])\n        left += 1\n        right -= 1\n\n    return True\n\ndef g(s=\"abcdcb\"):\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 455,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums' and a target integer 'target', find the two numbers in the list that add up to the target. Return the indices of the two numbers in ascending order.\n\n    Sample Input:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Sample Output:\n    [0, 1]\n    \"\"\"\n    n = len(nums)\n    num_map = {}\n\n    for i in range(n):\n        complement = target - nums[i]\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[nums[i]] = i\n\n    return []\n\ndef g(nums: List[int] = [2, 7, 11, 15], target: int = 9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 224,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all the numbers that are divisible by 3 or 5.\n\n    Parameters:\n    nums (List[int]): The list of integers.\n\n    Returns:\n    int: The sum of all the numbers that are divisible by 3 or 5.\n    \"\"\"\n    return sum(num for num in nums if num % 3 == 0 or num % 5 == 0)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n\n    Returns:\n    List[int]: A list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == 33\n\n",
        "idx_generation": 481,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the maximum area of a rectangle in the grid that contains only 1s.\n    \"\"\"\n    def largestRectangleArea(heights):\n        stack = [-1]\n        max_area = 0\n        for i in range(len(heights)):\n            while stack[-1] != -1 and heights[stack[-1]] >= heights[i]:\n                h = heights[stack.pop()]\n                w = i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n        while stack[-1] != -1:\n            h = heights[stack.pop()]\n            w = len(heights) - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        return max_area\n    \n    if not grid:\n        return 0\n    m, n = len(grid), len(grid[0])\n    heights = [0] * n\n    max_area = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                heights[j] = 0\n            else:\n                heights[j] += 1\n        max_area = max(max_area, largestRectangleArea(heights))\n    return max_area\n\ndef g(grid: List[List[int]] = [[1, 0, 1, 0, 0],\n                               [1, 0, 1, 1, 1],\n                               [1, 1, 1, 1, 1],\n                               [1, 0, 0, 1, 0]]):\n    return grid\n\nassert f(g()) == 6\n",
        "idx_generation": 217,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n\n    Parameters:\n    n (int): The number of steps in the staircase.\n\n    Returns:\n    int: The number of ways to climb to the top of the staircase.\n    \"\"\"\n    if n <= 1:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    \n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    \n    return dp[n]\n\ndef g() -> int:\n    \"\"\"\n    Generate a random integer n.\n\n    Returns:\n    int: A random integer.\n    \"\"\"\n    return 5\n\nassert f(g()) == 8\n\n",
        "idx_generation": 481,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> int:\n    \"\"\"\n    Given a list of 2D points, find the area of the largest rectangle that can be formed by any four points in the list.\n    The area of a rectangle is calculated as the product of the length and width.\n\n    Return the area of the largest rectangle.\n\n    Example:\n    points = [[1, 1], [1, 3], [3, 1], [3, 3], [2, 2]]\n\n    Output:\n    4\n\n    Explanation:\n    The largest rectangle can be formed by the points (1, 1), (1, 3), (3, 1), and (3, 3).\n    The length of the rectangle is |1 - 3| = 2 and the width is |1 - 3| = 2.\n    The area of the rectangle is 2 * 2 = 4.\n    \"\"\"\n    min_x = float('inf')\n    max_x = float('-inf')\n    min_y = float('inf')\n    max_y = float('-inf')\n\n    for point in points:\n        x, y = point\n        min_x = min(min_x, x)\n        max_x = max(max_x, x)\n        min_y = min(min_y, y)\n        max_y = max(max_y, y)\n\n    length = abs(max_x - min_x)\n    width = abs(max_y - min_y)\n\n    return length * width\n\ndef g() -> List[List[int]]:\n    return [[1, 1], [1, 3], [3, 1], [3, 3], [2, 2]]\n\nassert f(g()) == 4\n\n",
        "idx_generation": 254,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import Tuple\n\ndef f(grid: Tuple[Tuple[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum cost to reach the bottom-right corner from the top-left corner.\n    Each cell in the grid represents the cost to move to that cell. You can only move down or right.\n\n    Example:\n    Input:\n    grid = ((1, 3, 1), \n            (1, 5, 1), \n            (4, 2, 1))\n    Output:\n    7\n\n    Explanation:\n    The minimum cost path is 1 -> 3 -> 1 -> 1 -> 1, which sums up to 7.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g():\n    return ((1, 3, 1), (1, 5, 1), (4, 2, 1))\n\nassert f(g()) == 7\n",
        "idx_generation": 144,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nimport re\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, check if it is a valid email address.\n    \"\"\"\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return bool(re.match(pattern, s))\n\ndef g():\n    return \"john.doe@example.com\"\n\nassert f(g()) == True\n\n",
        "idx_generation": 491,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, check if it is a palindrome.\n\n    Return True if s is a palindrome, False otherwise.\n\n    Example:\n    s = \"racecar\"\n\n    Output:\n    True\n\n    Explanation:\n    The string \"racecar\" is a palindrome.\n    \"\"\"\n\n    def is_palindrome(s):\n        i, j = 0, len(s) - 1\n        while i < j:\n            if s[i] != s[j]:\n                return False\n            i += 1\n            j -= 1\n        return True\n\n    return is_palindrome(s)\n\ndef g(s: str):\n    \"\"\"\n    Generate a palindrome string.\n    \"\"\"\n    return s\n\nassert f(g(\"racecar\")) == True\n",
        "idx_generation": 138,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of bits set to 1 in the binary representation of n.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g():\n    return 15\n\nassert f(g()) == 4\n",
        "idx_generation": 76,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the maximum sum of a path from the top-left corner to the bottom-right corner in a grid.\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 12\n",
        "idx_generation": 59,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(grid: List[List[int]], k: int) -> int:\n    \"\"\"\n    Given a grid of integers and an integer k, find the maximum sum of a subgrid of size k x k within the grid.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    k = 2\n\n    Output:\n    28\n\n    Explanation:\n    The maximum sum of a 2x2 subgrid within the grid is 28, which is obtained by selecting the subgrid [5, 6, 8, 9].\n\n    Hint: Use dynamic programming to calculate the maximum sum of subgrids.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    max_sum = float('-inf')\n\n    for i in range(rows - k + 1):\n        for j in range(cols - k + 1):\n            subgrid_sum = 0\n            for x in range(i, i + k):\n                for y in range(j, j + k):\n                    subgrid_sum += grid[x][y]\n            max_sum = max(max_sum, subgrid_sum)\n\n    return max_sum\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    k = 2\n    return (grid, k)\n\nassert f(*g()) == 28\n",
        "idx_generation": 465,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(graph: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, return the topological ordering of the graph.\n    The topological order is a linear ordering of the vertices such that for every directed edge (u, v),\n    vertex u comes before v in the ordering.\n\n    Args:\n    - graph: A list of lists representing the adjacency list of the graph.\n\n    Returns:\n    - The topological ordering of the graph as a list of integers.\n\n    Example:\n    graph = [[1, 2], [3], [3], []]\n\n    Output:\n    [0, 1, 2, 3]\n\n    Explanation:\n    The topological ordering of the graph is [0, 1, 2, 3].\n\n    Note:\n    - The input graph will be a valid directed acyclic graph (DAG).\n    - The graph can have multiple valid topological orderings.\n    \"\"\"\n\n    # Step 1: Count the number of incoming edges for each vertex\n    incoming_edges = [0] * len(graph)\n    for node in graph:\n        for neighbor in node:\n            incoming_edges[neighbor] += 1\n\n    # Step 2: Initialize a queue and enqueue nodes with no incoming edges\n    queue = []\n    for i in range(len(graph)):\n        if incoming_edges[i] == 0:\n            queue.append(i)\n\n    # Step 3: Perform topological sorting\n    topological_order = []\n    while queue:\n        node = queue.pop(0)\n        topological_order.append(node)\n        for neighbor in graph[node]:\n            incoming_edges[neighbor] -= 1\n            if incoming_edges[neighbor] == 0:\n                queue.append(neighbor)\n\n    return topological_order\n\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate an adjacency list for a directed acyclic graph (DAG).\n    \"\"\"\n    return [[1, 2], [3], [3], []]\n\nassert f(g()) == [0, 1, 2, 3]\n",
        "idx_generation": 409,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"\n    Check if there is a cycle in the given directed graph that starts and ends at the specified nodes.\n    \"\"\"\n    visited = set()\n    stack = [(start, [start])]\n\n    while stack:\n        node, path = stack.pop()\n        if node == end and len(path) > 1:\n            return True\n        if node not in visited:\n            visited.add(node)\n            for neighbor in graph[node]:\n                stack.append((neighbor, path + [neighbor]))\n\n    return False\n\n\ndef g(graph={\"A\": [\"B\", \"C\"], \"B\": [\"D\", \"E\"], \"C\": [\"F\"], \"D\": [\"A\"], \"E\": [\"F\"], \"F\": [\"A\"]}, start=\"A\", end=\"A\"):\n    return graph, start, end\n\n\nassert f(*g()) == True\n",
        "idx_generation": 108,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if there exists a path from the top-left cell to the bottom-right cell in the grid\"\"\"\n    def dfs(grid, row, col):\n        if row == len(grid)-1 and col == len(grid[0])-1:\n            return True\n        if row >= len(grid) or col >= len(grid[0]) or grid[row][col] == 1:\n            return False\n        return dfs(grid, row+1, col) or dfs(grid, row, col+1)\n    \n    return dfs(grid, 0, 0)\n\ndef g(grid=[[0,0,0],[0,1,0],[0,0,0]]):\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 50,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list,\n    determine whether the graph is bipartite or not.\n    Return True if the graph is bipartite, False otherwise.\n    \"\"\"\n    n = len(graph)\n    colors = [-1] * n\n    queue = []\n    \n    def bfs(node):\n        colors[node] = 0\n        queue.append(node)\n        \n        while queue:\n            curr_node = queue.pop(0)\n            \n            for neighbor in graph[curr_node]:\n                if colors[neighbor] == -1:\n                    colors[neighbor] = 1 - colors[curr_node]\n                    queue.append(neighbor)\n                elif colors[neighbor] == colors[curr_node]:\n                    return False\n                    \n        return True\n    \n    for i in range(n):\n        if colors[i] == -1:\n            if not bfs(i):\n                return False\n                \n    return True\n\ndef g(graph = [[1, 3], [0, 2], [1, 3], [0, 2]]):\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 87,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Check if s1 and s2 are anagrams of each other.\n    Return True if they are anagrams, False otherwise.\n    \"\"\"\n    def count_chars(s: str) -> Dict[str, int]:\n        char_count = {}\n        for char in s:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n        return char_count\n\n    char_count_s1 = count_chars(s1)\n    char_count_s2 = count_chars(s2)\n\n    return char_count_s1 == char_count_s2\n\ndef g(s1 = \"listen\", s2 = \"silent\"):\n    \"\"\"\n    Return the input strings.\n    \"\"\"\n    return s1, s2\n\nassert f(*g())\n",
        "idx_generation": 36,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target value, find all unique combinations in the list that sum up to the target.\n    Each number in the list can be used multiple times.\n\n    Sample Input:\n    nums = [2, 3, 6, 7]\n    target = 7\n\n    Sample Output:\n    [[2, 2, 3], [7]]\n    \"\"\"\n    def backtrack(nums: List[int], target: int, curr_comb: List[int], result: List[List[int]]) -> None:\n        if target == 0:\n            result.append(curr_comb[:])\n            return\n        elif target < 0:\n            return\n        \n        for i in range(len(nums)):\n            curr_comb.append(nums[i])\n            backtrack(nums[i:], target - nums[i], curr_comb, result)\n            curr_comb.pop()\n    \n    nums.sort()\n    result = []\n    backtrack(nums, target, [], result)\n    return result\n\n\ndef g(nums=[2, 3, 6, 7], target=7):\n    return nums, target\n\n\nassert f(*g()) == [[2, 2, 3], [7]]\n",
        "idx_generation": 116,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the number of distinct palindromic subsequences in the string.\n\n    Args:\n    - s: A string.\n\n    Returns:\n    - The number of distinct palindromic subsequences in the string.\n    \"\"\"\n\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        dp[i][i] = 1\n\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n\n            if s[i] == s[j]:\n                left = i + 1\n                right = j - 1\n\n                while left <= right and s[left] != s[i]:\n                    left += 1\n\n                while left <= right and s[right] != s[i]:\n                    right -= 1\n\n                if left > right:\n                    dp[i][j] = dp[i + 1][j - 1] * 2 + 2\n                elif left == right:\n                    dp[i][j] = dp[i + 1][j - 1] * 2 + 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1] * 2 - dp[left + 1][right - 1]\n\n            else:\n                dp[i][j] = dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1]\n\n    return dp[0][n - 1]\n\ndef g() -> str:\n    \"\"\"\n    Generate the input for the function f.\n    \"\"\"\n    return \"bccb\"\n\nassert f(g()) == 6\n\n",
        "idx_generation": 499,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two positive integers n and k, return the number of k-permutations of n.\n    \"\"\"\n    def factorial(n):\n        if n == 0 or n == 1:\n            return 1\n        else:\n            return n * factorial(n - 1)\n\n    return factorial(n) // factorial(n - k)\n\ndef g():\n    n = 5\n    k = 3\n    return n, k\n\nassert f(*g()) == 60\n",
        "idx_generation": 426,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the minimum absolute difference between any two numbers in the list.\n\n    Example:\n    nums = [4, 2, 8, 6, 10]\n\n    Output:\n    2\n\n    Explanation:\n    The minimum absolute difference between any two numbers in the list is 2 (between 4 and 6).\n\n    Hint: Sort the list in ascending order and compare adjacent numbers to find the minimum difference.\n    \"\"\"\n\n    nums.sort()\n    min_diff = float('inf')\n    for i in range(1, len(nums)):\n        diff = abs(nums[i] - nums[i-1])\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff\n\ndef g() -> List[int]:\n    nums = [4, 2, 8, 6, 10]\n    return [nums]\n\nassert f(*g()) == 2\n",
        "idx_generation": 469,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order using the bubble sort algorithm.\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    \n    return nums\n\ndef g():\n    \"\"\"\n    Generate a list of random integers.\n    \"\"\"\n    return [3, 1, 4, 1, 5, 9, 2, 6, 5]\n\nassert f(g()) == [1, 1, 2, 3, 4, 5, 5, 6, 9]\n",
        "idx_generation": 220,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Determine if there are three elements in nums such that their sum is equal to target.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    for i in range(n-2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            curr_sum = nums[i] + nums[left] + nums[right]\n            if curr_sum == target:\n                return True\n            elif curr_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g(nums = [1, 2, 3, 4, 5], target = 9):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 60,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two numbers in the list.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5]\n    Output: 20\n    Explanation:\n    The maximum product is achieved by multiplying 4 and 5, which gives 20.\n    \"\"\"\n    nums.sort()\n    return max(nums[-1] * nums[-2], nums[0] * nums[1])\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 20\n",
        "idx_generation": 245,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target number, find the index of the target number in the list using binary search.\n\n    Example:\n    Input: nums = [1, 3, 5, 7, 9], target = 5\n    Output: 2\n\n    Explanation: The target number 5 is located at index 2 in the list.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(nums=[1, 3, 5, 7, 9], target=5):\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 342,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\nimport itertools\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find all unique combinations in nums where the sum of the numbers is equal to target.\n    Each number in nums may only be used once in the combination.\n    \"\"\"\n\n    nums.sort()\n    combinations = []\n\n    def backtrack(remain, curr_comb, start):\n        if remain == 0:\n            combinations.append(list(curr_comb))\n            return\n        elif remain < 0:\n            return\n\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            curr_comb.append(nums[i])\n            backtrack(remain - nums[i], curr_comb, i + 1)\n            curr_comb.pop()\n\n    backtrack(target, [], 0)\n\n    return combinations\n\ndef g():\n    nums = [10, 1, 2, 7, 6, 1, 5]\n    target = 8\n    return nums, target\n\nassert f(*g()) == [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n\n",
        "idx_generation": 166,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\n\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Given two strings s1 and s2, check if s2 can be formed by rearranging the characters of s1.\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n\n    count1 = [0] * 26\n    count2 = [0] * 26\n\n    for char in s1:\n        count1[ord(char) - ord('a')] += 1\n\n    for char in s2:\n        count2[ord(char) - ord('a')] += 1\n\n    for i in range(26):\n        if count1[i] != count2[i]:\n            return False\n\n    return True\n\ndef g() -> Tuple[str, str]:\n    return (\"listen\", \"silent\")\n\nassert f(*g()) == True\n",
        "idx_generation": 175,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a list of words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.\n\n    Sample Input:\n    s = \"leetcode\"\n    words = [\"leet\", \"code\"]\n\n    Sample Output:\n    True\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return False\n    \n    dp = [False] * (n+1)\n    dp[0] = True\n\n    for i in range(1, n+1):\n        for word in words:\n            if i >= len(word) and s[i-len(word):i] == word:\n                dp[i] = dp[i] or dp[i-len(word)]\n\n    return dp[n]\n\ndef g():\n    return [\"leetcode\", [\"leet\", \"code\"]]\n\nassert f(*g())\n",
        "idx_generation": 393,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if it is a magic square.\n    A magic square is a square matrix where the sum of each row, each column, and each diagonal is the same.\n\n    Example:\n    matrix = [\n        [2, 7, 6],\n        [9, 5, 1],\n        [4, 3, 8]\n    ]\n\n    Output:\n    True (The sum of each row, column, and diagonal is 15)\n    \"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n    \n    # Check rows\n    for i in range(n):\n        if sum(matrix[i]) != target_sum:\n            return False\n    \n    # Check columns\n    for j in range(n):\n        if sum(matrix[i][j] for i in range(n)) != target_sum:\n            return False\n    \n    # Check diagonals\n    if sum(matrix[i][i] for i in range(n)) != target_sum:\n        return False\n    if sum(matrix[i][n-i-1] for i in range(n)) != target_sum:\n        return False\n    \n    return True\n\ndef g():\n    return [\n        [2, 7, 6],\n        [9, 5, 1],\n        [4, 3, 8]\n    ]\n\nassert f(g()) == True\n",
        "idx_generation": 174,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of trailing zeros in n!.\n\n    Example:\n    n = 5\n\n    Output:\n    1\n\n    Explanation:\n    5! = 120, which has 1 trailing zero.\n    \"\"\"\n\n    count = 0\n    i = 5\n\n    while n // i >= 1:\n        count += n // i\n        i *= 5\n\n    return count\n\ndef g() -> int:\n    \"\"\"\n    Generate the input for the function f.\n    \"\"\"\n    return 5\n\nassert f(g()) == True\n",
        "idx_generation": 294,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, calculate the sum of all the even numbers in the list.\n\n    Example:\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    Output:\n    20\n\n    Explanation:\n    The sum of all the even numbers in the list is 20 (2 + 4 + 6 + 8).\n    \"\"\"\n\n    total = 0\n\n    for num in arr:\n        if num % 2 == 0:\n            total += num\n\n    return total\n\ndef g(arr: List[int]) -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return arr\n\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g(arr)) == 20\n",
        "idx_generation": 456,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers, find two numbers such that they add up to a specific target number.\n\n    Return the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    nums[0] + nums[1] = 2 + 7 = 9, so the indices are [0, 1].\n    \"\"\"\n\n    # Create a dictionary to store the complement of each number and its index\n    complements = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n\n        if complement in complements:\n            return [complements[complement], i]\n\n        complements[num] = i\n\n    return []\n\ndef g(nums: List[int] = [2, 7, 11, 15], target: int = 9):\n    \"\"\"\n    Generate an array of integers and a target number.\n    \"\"\"\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 236,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\nimport math\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the sum of all the numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    15 (since 1 + 2 + 3 + 4 + 5 = 15)\n    \"\"\"\n    return sum(nums)\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 15\n",
        "idx_generation": 484,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool:\n    \"\"\"\n    Check if it is possible to reach the end point from the start point in the given grid.\n\n    Example:\n    grid = [\n        [1, 1, 1, 1],\n        [0, 1, 0, 1],\n        [1, 1, 0, 1],\n        [0, 1, 1, 1]\n    ]\n    start = (0, 0)\n    end = (3, 3)\n    Output: True\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = [(start[0], start[1])]\n    visited[start[0]][start[1]] = True\n\n    while queue:\n        x, y = queue.pop(0)\n        if x == end[0] and y == end[1]:\n            return True\n        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 1 and not visited[nx][ny]:\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n\n    return False\n\ndef g():\n    return ([\n        [1, 1, 1, 1],\n        [0, 1, 0, 1],\n        [1, 1, 0, 1],\n        [0, 1, 1, 1]\n    ], (0, 0), (3, 3))\n\nassert f(*g()) == True\n",
        "idx_generation": 220,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique paths from the top-left corner to the bottom-right corner\n    of an n x n grid. You can only move down or right.\n\n    Example:\n    n = 3\n\n    Output:\n    6\n\n    Explanation:\n    There are 6 unique paths from the top-left corner to the bottom-right corner of a 3 x 3 grid.\n\n    Hint: Use dynamic programming to store the number of unique paths at each cell.\n    \"\"\"\n\n    dp = [[0] * n for _ in range(n)]\n    dp[0][0] = 1\n\n    for i in range(1, n):\n        dp[i][0] = 1\n\n    for j in range(1, n):\n        dp[0][j] = 1\n\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[n-1][n-1]\n\ndef g() -> int:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    return 3\n\nassert f(g()) == 6\n\n",
        "idx_generation": 482,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(board: List[List[str]]) -> bool:\n    \"\"\"\n    Check if a given Sudoku board is valid.\n    Return True if the board is valid, False otherwise.\n\n    Example:\n    board = [\n        [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n        [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n        [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n        [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n        [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n        [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n        [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n        [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n        [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"]\n    ]\n    Output: True\n    \"\"\"\n    rows = [set() for _ in range(9)]\n    cols = [set() for _ in range(9)]\n    boxes = [set() for _ in range(9)]\n\n    for i in range(9):\n        for j in range(9):\n            if board[i][j] != '.':\n                num = int(board[i][j])\n                box_index = (i // 3) * 3 + j // 3\n                if num in rows[i] or num in cols[j] or num in boxes[box_index]:\n                    return False\n                rows[i].add(num)\n                cols[j].add(num)\n                boxes[box_index].add(num)\n\n    return True\n\ndef g(board: List[List[str]]) -> List[List[str]]:\n    return board\n\nassert f(g([\n    [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n    [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n    [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n    [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n    [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n    [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n    [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n    [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n    [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"]\n])) == True\n",
        "idx_generation": 390,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, find the largest square containing only 1s and return its area.\n\n    Example:\n    grid = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n\n    Output:\n    4\n\n    Explanation:\n    The largest square containing only 1s is:\n    [\n        [1, 1],\n        [1, 1]\n    ]\n\n    Hint: Use dynamic programming to find the largest square.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    max_len = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if grid[i - 1][j - 1] == 1:\n                dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\n                max_len = max(max_len, dp[i][j])\n\n    return max_len ** 2\n\ndef g():\n    grid = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n    return grid\n\nassert f(g()) == 4\n\n",
        "idx_generation": 147,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(number: int) -> str:\n    \"\"\"\n    Given a positive integer, convert it to a Roman numeral and return the Roman numeral as a string.\n\n    Example:\n    number = 37\n    Output: \"XXXVII\"\n\n    number = 99\n    Output: \"XCIX\"\n\n    Constraints:\n    - The input number will be between 1 and 3999.\n    \"\"\"\n\n    roman_numerals = {\n        1000: 'M',\n        900: 'CM',\n        500: 'D',\n        400: 'CD',\n        100: 'C',\n        90: 'XC',\n        50: 'L',\n        40: 'XL',\n        10: 'X',\n        9: 'IX',\n        5: 'V',\n        4: 'IV',\n        1: 'I'\n    }\n\n    result = \"\"\n\n    for value, symbol in roman_numerals.items():\n        while number >= value:\n            result += symbol\n            number -= value\n\n    return result\n\ndef g(number=37):\n    return number\n\nassert f(g()) == \"XXXVII\"\n",
        "idx_generation": 492,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(s: str, words: List[str]) -> List[List[str]]:\n    \"\"\"\n    Given a string s and a list of words, find all possible word combinations that can be formed from the characters of s.\n    Each word in the combination must be present in the words list.\n    Return a list of all valid word combinations.\n    \"\"\"\n    def backtrack(start: int, path: List[str]):\n        if start == len(s):\n            result.append(path)\n            return\n        \n        for i in range(start, len(s)):\n            if s[start:i+1] in words:\n                backtrack(i+1, path + [s[start:i+1]])\n    \n    result = []\n    backtrack(0, [])\n    return result\n\ndef g():\n    s = \"catsanddog\"\n    words = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"]\n    return s, words\n\nassert f(*g()) == [['cat', 'sand', 'dog'], ['cats', 'and', 'dog']]\n",
        "idx_generation": 152,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray XOR using bit manipulation.\n    \"\"\"\n    max_xor = float('-inf')\n    for i in range(len(nums)):\n        xor = 0\n        for j in range(i, len(nums)):\n            xor ^= nums[j]\n            max_xor = max(max_xor, xor)\n    return max_xor\n\ndef g(nums: List[int] = [4, 6, 8, 2, 3, 1, 7]):\n    return nums\n\nassert f(g()) == 15\n\n",
        "idx_generation": 82,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the factorial of a given number.\"\"\"\n    if n == 0:  # Base case: if n is 0, return 1\n        return 1\n    else:  # Recursive case: calculate the factorial of (n-1) and multiply it by n\n        return f(n - 1) * n\n\ndef g() -> int:\n    return 5\n\nassert f(g()) == 120\n",
        "idx_generation": 67,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\n\n    You can only move down or right at any point in time.\n\n    Example:\n    n = 3\n\n    Output:\n    6\n\n    Explanation:\n    There are 6 unique paths from the top-left corner to the bottom-right corner of a 3 x 3 grid.\n\n    Hint: Use dynamic programming to build up the number of unique paths for each cell in the grid.\n    \"\"\"\n\n    dp = [[0] * n for _ in range(n)]\n    dp[0][0] = 1\n\n    for i in range(n):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] += dp[i - 1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j - 1]\n\n    return dp[n - 1][n - 1]\n\ndef g(n=3):\n    return n\n\nassert f(g()) == 6\n",
        "idx_generation": 465,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, determine if there is a cycle in the graph.\n\n    Return True if there is a cycle, False otherwise.\n\n    Example:\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 0, 0, 0]\n    ]\n    \n    Output:\n    True\n\n    Explanation:\n    The graph has a cycle: 0 -> 1 -> 2 -> 3 -> 0.\n    \"\"\"\n\n    def dfs(node, visited, stack):\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1:\n                if not visited[neighbor]:\n                    if dfs(neighbor, visited, stack):\n                        return True\n                elif stack[neighbor]:\n                    return True\n\n        stack[node] = False\n        return False\n\n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n    stack = [False] * num_nodes\n\n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(node, visited, stack):\n                return True\n\n    return False\n\ndef g(graph=[[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [1, 0, 0, 0]]):\n    return graph\n\nassert f(g())\n",
        "idx_generation": 426,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency list, determine if there exists a path from the start node to the end node.\n\n    Sample Input:\n    graph = [[1, 2], [3], [3], []]\n    start = 0\n    end = 3\n\n    Sample Output:\n    True\n    \"\"\"\n    visited = [False] * len(graph)\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if not visited[node]:\n            visited[node] = True\n            stack.extend(graph[node])\n    return False\n\ndef g(graph = [[1, 2], [3], [3], []], start = 0, end = 3):\n    return graph, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 115,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(adj_matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representing a weighted directed graph, find the shortest path from the start node to the end node using Dijkstra's algorithm.\n\n    Args:\n    - adj_matrix: A list of lists representing the adjacency matrix of the graph.\n\n    Returns:\n    - The shortest path from the start node to the end node.\n    \"\"\"\n    def dijkstra(start, end):\n        nonlocal dist\n        nonlocal prev\n        nonlocal visited\n\n        dist[start] = 0\n\n        while True:\n            min_dist = float('inf')\n            min_node = -1\n\n            for i in range(len(adj_matrix)):\n                if not visited[i] and dist[i] < min_dist:\n                    min_dist = dist[i]\n                    min_node = i\n\n            if min_node == -1:\n                break\n\n            visited[min_node] = True\n\n            for i in range(len(adj_matrix[min_node])):\n                if adj_matrix[min_node][i] != 0 and dist[min_node] + adj_matrix[min_node][i] < dist[i]:\n                    dist[i] = dist[min_node] + adj_matrix[min_node][i]\n                    prev[i] = min_node\n\n        path = []\n        node = end\n\n        while node != -1:\n            path.append(node)\n            node = prev[node]\n\n        return path[::-1]\n\n    start = 0\n    end = len(adj_matrix) - 1\n    dist = [float('inf')] * len(adj_matrix)\n    prev = [-1] * len(adj_matrix)\n    visited = [False] * len(adj_matrix)\n\n    shortest_path = dijkstra(start, end)\n\n    return shortest_path\n\ndef g():\n    adj_matrix = [[0, 1, 4, 0, 0, 0],\n                  [1, 0, 2, 5, 0, 0],\n                  [4, 2, 0, 0, 3, 0],\n                  [0, 5, 0, 0, 1, 4],\n                  [0, 0, 3, 1, 0, 2],\n                  [0, 0, 0, 4, 2, 0]]\n    return adj_matrix\n\nassert f(g()) == [0, 1, 2, 4, 5]\n\n",
        "idx_generation": 56,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Dict\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"\n    Given a graph represented as a dictionary of nodes and their adjacent nodes,\n    and a start and end node, determine if there is a path from the start node to\n    the end node in the graph.\n\n    Sample Input:\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D'],\n        'D': ['E'],\n        'E': []\n    }\n    start = 'A'\n    end = 'E'\n\n    Sample Output:\n    True\n    \"\"\"\n    visited = set()\n\n    def dfs(node):\n        if node == end:\n            return True\n\n        visited.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n\n        return False\n\n    return dfs(start)\n\n\ndef g():\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D'],\n        'D': ['E'],\n        'E': []\n    }\n    start = 'A'\n    end = 'E'\n    return graph, start, end\n\n\nassert f(*g()) == True\n\n",
        "idx_generation": 90,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the number of unique permutations of a list of integers\"\"\"\n    def backtrack(nums: List[int], path: List[int], used: List[bool], res: List[List[int]]) -> None:\n        if len(path) == len(nums):\n            res.append(path[:])\n            return\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n            if i > 0 and nums[i] == nums[i-1] and not used[i-1]:\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(nums, path, used, res)\n            used[i] = False\n            path.pop()\n    \n    nums.sort()\n    res = []\n    backtrack(nums, [], [False] * len(nums), res)\n    return len(res)\n\ndef g():\n    nums = [1, 2, 2]\n    return (nums,)\n\nassert f(*g()) == 3\n",
        "idx_generation": 41,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[int]:\n    \"\"\"\n    Generate all possible combinations of k numbers out of 1 to n.\n    \"\"\"\n    def backtrack(start: int, path: List[int]) -> None:\n        if len(path) == k:\n            res.append(path[:])\n            return\n        for i in range(start, n + 1):\n            path.append(i)\n            backtrack(i + 1, path)\n            path.pop()\n    \n    res = []\n    backtrack(1, [])\n    return res\n\ndef g() -> List[int]:\n    n = 4\n    k = 2\n    return n, k\n\nassert f(*g()) == [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n",
        "idx_generation": 119,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of trailing zeros in n!.\n\n    Example:\n    n = 5\n\n    Output:\n    1\n\n    Explanation:\n    5! = 5 * 4 * 3 * 2 * 1 = 120, which has 1 trailing zero.\n\n    Hint: Count the number of factors of 5 in the prime factorization of n!\n    \"\"\"\n\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n\n    return count\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 1\n\n",
        "idx_generation": 435,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there are two integers in the list that\n    sum up to the target value. Return True if such pairs exist, otherwise return False.\n\n    Example:\n    arr = [1, 4, 2, 8, 3, 5]\n    target = 10\n\n    Output:\n    True\n\n    Explanation:\n    The pairs [2, 8] and [4, 6] sum up to the target value 10.\n\n    Hint: Use a combination of sorting and searching to find the pairs.\n    \"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr=[1, 4, 2, 8, 3, 5], target=10):\n    return arr, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 470,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order using the bubble sort algorithm.\n\n    Sample Input:\n    nums = [5, 3, 8, 2, 1]\n\n    Sample Output:\n    [1, 2, 3, 5, 8]\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    return nums\n\ndef g() -> List[int]:\n    return [5, 3, 8, 2, 1]\n\nassert f(g()) == [1, 2, 3, 5, 8]\n\n",
        "idx_generation": 232,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if the target number is present in the sorted array\"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\ndef g(arr=[1, 3, 5, 7, 9], target=5):\n    return arr\n\nassert f(g(), target=5) == True\n",
        "idx_generation": 67,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the largest product of any three numbers in the list.\n\n    Return the largest product.\n\n    Example:\n    nums = [-10, -10, 1, 3, 2]\n\n    Output:\n    300\n\n    Explanation:\n    The largest product of any three numbers in the list is -10 * -10 * 3 = 300.\n    \"\"\"\n    nums.sort()\n\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\n\ndef g(nums: List[int] = [-10, -10, 1, 3, 2]) -> int:\n    \"\"\"Generate a list of integers.\"\"\"\n    return nums\n\nassert f(g()) == 300\n",
        "idx_generation": 262,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique combinations of three numbers that sum up to zero.\n\n    Example:\n    nums = [-1, 0, 1, 2, -1, -4]\n\n    Output:\n    2\n\n    Explanation:\n    The unique combinations that sum up to zero are [-1, 0, 1] and [-1, -1, 2].\n\n    Hint: Use sorting and two-pointer technique to find the combinations.\n    \"\"\"\n    nums.sort()\n    count = 0\n    n = len(nums)\n    for i in range(n - 2):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        left = i + 1\n        right = n - 1\n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n            if total < 0:\n                left += 1\n            elif total > 0:\n                right -= 1\n            else:\n                count += 1\n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                left += 1\n                right -= 1\n    return count\n\ndef g(nums=[-1, 0, 1, 2, -1, -4]):\n    return nums\n\nassert f(g()) == 2\n",
        "idx_generation": 351,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a subset whose sum is divisible by 6.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    True\n\n    Explanation:\n    The subset [1, 2, 3] has a sum of 6, which is divisible by 6.\n    \"\"\"\n    def subset_sum(nums, target):\n        n = len(nums)\n        dp = [[False] * (target + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][0] = True\n        for i in range(1, n + 1):\n            for j in range(1, target + 1):\n                if j < nums[i - 1]:\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n        return dp[n][target]\n\n    total_sum = sum(nums)\n    if total_sum % 6 == 0:\n        return True\n    if total_sum < 6:\n        return False\n    return subset_sum(nums, total_sum // 6)\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return (nums,)\n\nassert f(*g()) == True\n",
        "idx_generation": 179,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it can be formed by concatenating a subsequence of the string \"abc\" multiple times.\n    Return True if s can be formed, otherwise return False.\n    \"\"\"\n    pattern = \"abc\"\n    i = 0\n    for char in s:\n        if char == pattern[i]:\n            i += 1\n            if i == len(pattern):\n                i = 0\n    return i == 0\n\ndef g(s = \"abcabcabc\"):\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 216,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(s: str, target: str) -> List[int]:\n    \"\"\"\n    Given a string and a target substring, find all the starting indices of the target substring in the string.\n\n    Example:\n    Input:\n    s = \"abababa\"\n    target = \"aba\"\n\n    Output:\n    [0, 2, 4]\n\n    Explanation:\n    The target substring \"aba\" starts at indices 0, 2, and 4 in the string \"abababa\".\n    \"\"\"\n\n    def search(s: str, target: str) -> List[int]:\n        indices = []\n\n        for i in range(len(s) - len(target) + 1):\n            if s[i:i+len(target)] == target:\n                indices.append(i)\n\n        return indices\n\n    return search(s, target)\n\ndef g() -> Tuple[str, str]:\n    \"\"\"\n    Generate a string and a target substring.\n    \"\"\"\n    return (\"abababa\", \"aba\")\n\nassert f(*g()) == [0, 2, 4]\n",
        "idx_generation": 474,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of trailing zeros in n!\n\n    Return the count of trailing zeros.\n\n    Example:\n    n = 10\n\n    Output:\n    2\n\n    Explanation:\n    10! = 3628800, which has 2 trailing zeros.\n    \"\"\"\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n    return count\n\ndef g(n = 10):\n    return n\n\nassert f(g()) == 2\n",
        "idx_generation": 178,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of trailing zeros in n!.\n\n    Example:\n    n = 5\n    5! = 120\n    The number of trailing zeros in 120 is 1.\n\n    Return the number of trailing zeros in n!\n    \"\"\"\n    count = 0\n    power_of_5 = 5\n\n    while power_of_5 <= n:\n        count += n // power_of_5\n        power_of_5 *= 5\n\n    return count\n\ndef g() -> int:\n    return 20\n\nassert f(g()) == 4\n\n",
        "idx_generation": 302,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where all the negative numbers are moved to the front of the list.\n    The new list should maintain the relative order of the positive numbers and negative numbers.\n\n    Example:\n    arr = [4, -2, 7, -5, -1, 3, -6]\n\n    Output:\n    [-2, -5, -1, -6, 4, 7, 3]\n\n    Explanation:\n    The negative numbers in the original list are -2, -5, -1, and -6.\n    The new list has the negative numbers moved to the front and the positive numbers at the end.\n    The relative order of the numbers is maintained.\n    \"\"\"\n\n    negative_numbers = [num for num in arr if num < 0]\n    positive_numbers = [num for num in arr if num >= 0]\n\n    return negative_numbers + positive_numbers\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [4, -2, 7, -5, -1, 3, -6]\n\nassert f(g()) == [-2, -5, -1, -6, 4, 7, 3]\n",
        "idx_generation": 462,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum sum of a subarray within the given list.\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\nassert f(g()) == 6\n",
        "idx_generation": 247,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Two Sum\n\n    Given an array of integers, return the indices of two numbers such that they add up to a specific target.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    output: [0, 1]\n\n    Explanation:\n    nums[0] + nums[1] = 2 + 7 = 9\n    \"\"\"\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []\n\ndef g(nums = [2, 7, 11, 15], target = 9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 486,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\n\ndef f(parentheses: str) -> bool:\n    \"\"\"\n    Given a string containing only parentheses (i.e. '(' and ')'), determine if the parentheses are balanced.\n    A string of parentheses is considered balanced if every opening parenthesis has a corresponding closing parenthesis and vice versa.\n\n    Example:\n    f(\"()\") -> True\n    f(\"()[]{}\") -> True\n    f(\"(]\") -> False\n\n    Return True if the parentheses are balanced, else return False.\n    \"\"\"\n    stack = []\n    opening_brackets = [\"(\", \"[\", \"{\"]\n    closing_brackets = [\")\", \"]\", \"}\"]\n    for char in parentheses:\n        if char in opening_brackets:\n            stack.append(char)\n        elif char in closing_brackets:\n            if not stack:\n                return False\n            last_opening_bracket = stack.pop()\n            if opening_brackets.index(last_opening_bracket) != closing_brackets.index(char):\n                return False\n    return len(stack) == 0\n\n\ndef g():\n    parentheses = \"()(())\"\n    return parentheses\n\n\nassert f(g()) == True\n",
        "idx_generation": 246,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum cost to reach the bottom-right cell from the top-left cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum cost path is: 1 -> 3 -> 1 -> 1 -> 1, which has a total cost of 7.\n\n    Hint: Use dynamic programming to store the minimum cost at each cell.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n\n",
        "idx_generation": 482,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, find the area of the largest square containing only 1s.\n\n    Example:\n    Input:\n    [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n\n    Output:\n    4\n\n    Explanation:\n    The largest square containing only 1s has an area of 4 (2x2 square in the top-right corner).\n    \"\"\"\n\n    if not grid:\n        return 0\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    max_side = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                side = 1\n                while i+side < rows and j+side < cols:\n                    found_zero = False\n                    for k in range(i, i+side+1):\n                        if grid[k][j+side] == 0:\n                            found_zero = True\n                            break\n                    for k in range(j, j+side):\n                        if grid[i+side][k] == 0:\n                            found_zero = True\n                            break\n                    if found_zero:\n                        break\n                    side += 1\n                max_side = max(max_side, side)\n\n    return max_side * max_side\n\ndef g(grid = [\n    [1, 0, 1, 0, 0],\n    [1, 0, 1, 1, 1],\n    [1, 1, 1, 1, 1],\n    [1, 0, 0, 1, 0]\n]):\n    return grid\n\nassert f(g()) == 4\n",
        "idx_generation": 393,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the minimum number of steps required to reach the bottom-right corner from the top-left corner.\n    You can only move down or right.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[float('inf')] * (n+1) for _ in range(m+1)]\n    dp[0][1] = 0\n    \n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i-1][j-1]\n    \n    return dp[-1][-1]\n\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 147,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if they are isomorphic.\n\n    Two strings are isomorphic if the characters in s can be replaced to get t.\n\n    Example:\n    s = \"egg\"\n    t = \"add\"\n\n    Output:\n    True\n\n    Explanation:\n    The characters 'e' and 'a' can be mapped to 'a'.\n    The characters 'g' and 'd' can be mapped to 'd'.\n\n    Therefore, the strings are isomorphic.\n\n    Hint: Use dictionaries to map characters from s to t and vice versa, and check if the mappings are valid.\n    \"\"\"\n\n    if len(s) != len(t):\n        return False\n\n    s_to_t = {}\n    t_to_s = {}\n\n    for i in range(len(s)):\n        if s[i] in s_to_t:\n            if s_to_t[s[i]] != t[i]:\n                return False\n        else:\n            s_to_t[s[i]] = t[i]\n\n        if t[i] in t_to_s:\n            if t_to_s[t[i]] != s[i]:\n                return False\n        else:\n            t_to_s[t[i]] = s[i]\n\n    return True\n\ndef g() -> Tuple[str, str]:\n    s = \"paper\"\n    t = \"title\"\n    return s, t\n\nassert f(*g()) == True\n\n",
        "idx_generation": 492,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it can be segmented into a space-separated sequence of one or more dictionary words.\n    You may assume the dictionary does not contain duplicate words.\n    \"\"\"\n    def helper(s: str, dictionary: List[str]) -> bool:\n        if not s:\n            return True\n\n        for word in dictionary:\n            if s.startswith(word) and helper(s[len(word):], dictionary):\n                return True\n\n        return False\n\n    dictionary = [\"apple\", \"banana\", \"cat\", \"dog\"]\n    return helper(s, dictionary)\n\ndef g(s: str) -> str:\n    \"\"\"\n    Generate a string that can be segmented into dictionary words.\n    \"\"\"\n    return s\n\nassert f(g(\"applebanana\")) == True\n",
        "idx_generation": 176,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(num: int) -> bool:\n    \"\"\"Check if a number is a power of two.\"\"\"\n    if num <= 0:\n        return False\n    else:\n        return (num & (num - 1)) == 0\n\ndef g(num = 16):\n    return num\n\nassert f(g()) == True\n",
        "idx_generation": 86,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Find the shortest path from the top-left corner to the bottom-right corner in a grid.\n    Each cell in the grid represents the cost to move to that cell.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    # Initializing the dp table\n    dp = [[float('inf')] * cols for _ in range(rows)]\n    \n    # Setting the starting point\n    dp[0][0] = grid[0][0]\n    \n    # Using dynamic programming to find the shortest path\n    for i in range(rows):\n        for j in range(cols):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j])\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j])\n    \n    return dp[rows-1][cols-1]\n\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 7\n",
        "idx_generation": 74,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\n\n    Example:\n    Input: n = 3\n    Output: 6\n    Explanation:\n    There are 6 unique paths from the top-left corner to the bottom-right corner in a 3 x 3 grid:\n    1. right -> right -> down\n    2. right -> down -> right\n    3. down -> right -> right\n    4. right -> down -> down\n    5. down -> right -> down\n    6. down -> down -> right\n    \"\"\"\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][0] = 1\n        dp[0][i] = 1\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    return dp[n - 1][n - 1]\n\ndef g(n = 3):\n    return n\n\nassert f(g()) == 6\n",
        "idx_generation": 467,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representation of a directed graph, determine if the graph contains any cycles.\n\n    Example:\n    graph = [[0, 1, 0, 0],\n             [0, 0, 1, 0],\n             [0, 0, 0, 1],\n             [1, 0, 0, 0]]\n\n    Output:\n    True\n\n    Explanation:\n    The graph contains a cycle: 0 -> 1 -> 2 -> 3 -> 0.\n    \"\"\"\n\n    def dfs(node: int, visited: List[bool], recursion_stack: List[bool]) -> bool:\n        visited[node] = True\n        recursion_stack[node] = True\n\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1:\n                if not visited[neighbor]:\n                    if dfs(neighbor, visited, recursion_stack):\n                        return True\n                elif recursion_stack[neighbor]:\n                    return True\n\n        recursion_stack[node] = False\n        return False\n\n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n    recursion_stack = [False] * num_nodes\n\n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(node, visited, recursion_stack):\n                return True\n\n    return False\n\n\ndef g() -> List[List[int]]:\n    return [[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [1, 0, 0, 0]]\n\n\nassert f(g()) == True\n\n",
        "idx_generation": 433,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(adjacency_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Determine if a given graph is connected.\n    \"\"\"\n    n = len(adjacency_matrix)\n    visited = [False] * n\n    stack = []\n    stack.append(0)\n    visited[0] = True\n    while stack:\n        node = stack.pop()\n        for neighbor in range(n):\n            if adjacency_matrix[node][neighbor] == 1 and not visited[neighbor]:\n                stack.append(neighbor)\n                visited[neighbor] = True\n    return all(visited)\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate an adjacency matrix for a connected graph.\n    \"\"\"\n    return [[0, 1, 0, 0],\n            [1, 0, 1, 0],\n            [0, 1, 0, 1],\n            [0, 0, 1, 0]]\n\nassert f(g()) == True\n",
        "idx_generation": 116,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(adj_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representing a directed graph, determine if there is a cycle in the graph.\n    \"\"\"\n    n = len(adj_matrix)\n    visited = [False] * n\n    stack = [False] * n\n\n    def dfs(node):\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in range(n):\n            if adj_matrix[node][neighbor]:\n                if not visited[neighbor]:\n                    if dfs(neighbor):\n                        return True\n                elif stack[neighbor]:\n                    return True\n\n        stack[node] = False\n        return False\n\n    for node in range(n):\n        if not visited[node]:\n            if dfs(node):\n                return True\n\n    return False\n\ndef g():\n    adj_matrix = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 0, 0, 0],\n    ]\n    return adj_matrix\n\nassert f(g()) == True\n",
        "idx_generation": 56,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(n: int, edges: List[Tuple[int, int]]) -> bool:\n    \"\"\"\n    Given an undirected graph with n nodes and a list of edges, determine if the graph contains a cycle.\n    \"\"\"\n    parent = [-1] * n\n\n    def find_parent(node: int) -> int:\n        if parent[node] == -1:\n            return node\n        return find_parent(parent[node])\n\n    def union(node1: int, node2: int) -> None:\n        parent_node1 = find_parent(node1)\n        parent_node2 = find_parent(node2)\n        parent[parent_node2] = parent_node1\n\n    for edge in edges:\n        parent_node1 = find_parent(edge[0])\n        parent_node2 = find_parent(edge[1])\n        if parent_node1 == parent_node2:\n            return True\n        union(parent_node1, parent_node2)\n\n    return False\n\ndef g():\n    \"\"\"\n    Generate the input values for the function f.\n    \"\"\"\n    return (4, [(0, 1), (1, 2), (2, 3)])\n\nassert f(*g()) == False\n",
        "idx_generation": 93,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a list of words, determine if s can be formed by concatenating the words in the list.\n    Each word can be used multiple times or not at all.\n    \"\"\"\n    def dfs(s):\n        if s == \"\":\n            return True\n        for word in words:\n            if s.startswith(word):\n                if dfs(s[len(word):]):\n                    return True\n        return False\n    \n    return dfs(s)\n\ndef g(s = \"leetcode\", words = [\"leet\", \"code\"]):\n    return s, words\n\nassert f(*g())\n",
        "idx_generation": 56,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Given two integers n and k, determine if there exists a combination of k numbers from the range 1 to n\n    such that the sum of the numbers is divisible by k.\n\n    Example:\n    n = 5, k = 3\n\n    Possible combinations: [1, 2, 3], [2, 3, 1], [3, 1, 2], [1, 3, 1], [2, 1, 2], [3, 2, 3]\n    The sum of each combination is divisible by k (3), so the output should be True.\n    \"\"\"\n    def dfs(curr_sum, curr_count):\n        if curr_count == k and curr_sum % k == 0:\n            return True\n        if curr_count == k:\n            return False\n        for i in range(1, n+1):\n            if dfs(curr_sum + i, curr_count + 1):\n                return True\n        return False\n    \n    return dfs(0, 0)\n\ndef g(n=5, k=3):\n    return n, k\n\nassert f(*g()) == True\n",
        "idx_generation": 121,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a subsequence of length 3 such that the product of the elements is a perfect square.\n\n    Example:\n    nums = [2, 3, 4, 5, 6, 7]\n\n    Output:\n    True\n\n    Hint: Use counting and combinatorics to generate all possible subsequences of length 3 and check if their product is a perfect square.\n    \"\"\"\n\n    def is_perfect_square(num):\n        sqrt = int(num ** 0.5)\n        return sqrt * sqrt == num\n\n    def generate_subsequences(nums, length):\n        subsequences = []\n        generate_subsequence(nums, length, [], 0, subsequences)\n        return subsequences\n\n    def generate_subsequence(nums, length, current, index, subsequences):\n        if len(current) == length:\n            subsequences.append(current)\n            return\n\n        if index >= len(nums):\n            return\n\n        generate_subsequence(nums, length, current + [nums[index]], index + 1, subsequences)\n        generate_subsequence(nums, length, current, index + 1, subsequences)\n\n    subsequences = generate_subsequences(nums, 3)\n    for subsequence in subsequences:\n        product = subsequence[0] * subsequence[1] * subsequence[2]\n        if is_perfect_square(product):\n            return True\n\n    return False\n\ndef g():\n    return [2, 3, 4, 5, 6, 7]\n\nassert f(g()) == True\n\n",
        "idx_generation": 448,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Given an array of integers and a target value, find if there are k integers in the array that sum up to the target.\n    \"\"\"\n    arr.sort()\n    return any(sum(arr[i:i+k]) == target for i in range(len(arr)-k+1))\n\ndef g():\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 15\n    k = 3\n    return arr, target, k\n\nassert f(*g())\n",
        "idx_generation": 470,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element at index i of the new list\n    is the next greater element in the original list to the right of nums[i].\n    If there is no such element, consider it as -1.\n    \"\"\"\n    n = len(nums)\n    stack = []\n    result = [-1] * n\n    \n    for i in range(n):\n        while stack and nums[i] > nums[stack[-1]]:\n            idx = stack.pop()\n            result[idx] = nums[i]\n        stack.append(i)\n    \n    return result\n\ndef g():\n    nums = [4, 5, 2, 25, 8, 7]\n    return nums\n\nassert f(g()) == [5, 25, 25, -1, -1, -1]\n",
        "idx_generation": 233,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array of integers nums and a target integer, find all unique quadruplets in the array\n    which gives the sum of target. The solution set must not contain duplicate quadruplets.\n    \"\"\"\n    nums.sort()\n    result = []\n\n    def backtrack(start, target, path):\n        if len(path) == 4 and target == 0:\n            result.append(path)\n            return\n\n        if len(path) > 4:\n            return\n\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n\n            if nums[i] > target:\n                break\n\n            backtrack(i+1, target-nums[i], path+[nums[i]])\n\n    backtrack(0, target, [])\n    return result\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate an array of integers and a target integer for the function f.\n    \"\"\"\n    return ([1, 0, -1, 0, -2, 2], 0)\n\nassert f(*g()) == [\n    [-2, -1, 1, 2],\n    [-2,  0, 0, 2],\n    [-1,  0, 0, 1]\n]\n",
        "idx_generation": 72,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if the list is a valid arithmetic progression.\n\n    Return True if the list is a valid arithmetic progression, False otherwise.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n\n    Output:\n    True\n\n    Explanation:\n    The list is a valid arithmetic progression with a common difference of 2.\n    \"\"\"\n    nums.sort()\n    diff = nums[1] - nums[0]\n    for i in range(2, len(nums)):\n        if nums[i] - nums[i-1] != diff:\n            return False\n    return True\n\ndef g():\n    return [1, 3, 5, 7, 9]\n\nassert f(g()) == True\n",
        "idx_generation": 277,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target in the list using binary search.\n    If the target is not found, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g():\n    return [1, 3, 5, 7, 9], 5\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 357,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique BSTs (binary search trees) that store values from 1 to n.\n    \"\"\"\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        for j in range(1, i + 1):\n            dp[i] += dp[j - 1] * dp[i - j]\n\n    return dp[n]\n\ndef g(n: int = 3):\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return n\n\nassert f(g()) == 5\n\n",
        "idx_generation": 189,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the sum of all the numbers present in the string.\n    \"\"\"\n    import re\n    nums = re.findall(r'\\d+', s)\n    return sum(int(num) for num in nums)\n\ndef g(s: str = \"abc123def456\"):\n    return s\n\nassert f(g()) == 579\n\n",
        "idx_generation": 225,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum product of any two distinct numbers in the array.\n    Return the maximum product.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n\n    Output:\n    20 (since the maximum product is 5 * 4 = 20)\n    \"\"\"\n    max_product = float('-inf')\n    \n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            product = arr[i] * arr[j]\n            max_product = max(max_product, product)\n    \n    return max_product\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 20\n\n",
        "idx_generation": 187,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all even Fibonacci numbers less than or equal to n.\n\n    Args:\n    - n: A positive integer.\n\n    Returns:\n    - The sum of all even Fibonacci numbers less than or equal to n.\n    \"\"\"\n    if n < 2:\n        return 0\n\n    fib_nums = [0, 1]\n    even_sum = 0\n\n    while fib_nums[-1] <= n:\n        if fib_nums[-1] % 2 == 0:\n            even_sum += fib_nums[-1]\n        fib_nums.append(fib_nums[-1] + fib_nums[-2])\n\n    return even_sum\n\ndef g(n=100):\n    return n\n\nassert f(g()) == 44\n",
        "idx_generation": 352,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the other elements.\n\n    Parameters:\n    nums (List[int]): The input list of integers.\n\n    Returns:\n    List[int]: A new list where each element is the product of all the other elements.\n    \"\"\"\n    n = len(nums)\n    result = [1] * n\n\n    left_product = 1\n    for i in range(n):\n        result[i] *= left_product\n        left_product *= nums[i]\n\n    right_product = 1\n    for i in range(n-1, -1, -1):\n        result[i] *= right_product\n        right_product *= nums[i]\n\n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n\n    Returns:\n    List[int]: A list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [120, 60, 40, 30, 24]\n",
        "idx_generation": 471,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers, find two numbers such that they add up to a specific target.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The sum of nums[0] and nums[1] is 2 + 7 = 9, and their indices are 0 and 1 respectively.\n    \"\"\"\n\n    complement_map = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complement_map:\n            return [complement_map[complement], i]\n        complement_map[num] = i\n\ndef g():\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 268,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, calculate the length of the longest substring without repeating characters.\n\n    Args:\n    - s: A string.\n\n    Returns:\n    - The length of the longest substring without repeating characters.\n\n    Example:\n    Input: s = \"abcabcbb\"\n    Output: 3\n\n    Explanation: The longest substring without repeating characters is \"abc\".\n    \"\"\"\n\n    start = 0\n    max_len = 0\n    char_map = {}\n\n    for end in range(len(s)):\n        if s[end] in char_map:\n            start = max(start, char_map[s[end]] + 1)\n        char_map[s[end]] = end\n        max_len = max(max_len, end - start + 1)\n\n    return max_len\n\ndef g():\n    s = \"abcabcbb\"\n    return s\n\nassert f(g()) == 3\n\n",
        "idx_generation": 487,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, find the maximum area of a rectangle that can be formed by only 1s.\n    Return the maximum area.\n\n    Sample input:\n    grid = [\n        [1, 0, 0, 1, 1],\n        [1, 1, 1, 1, 0],\n        [0, 1, 1, 1, 1],\n        [0, 0, 1, 1, 0]\n    ]\n\n    Sample output:\n    6 (rectangle formed by the 1s in rows 2 and 3)\n    \"\"\"\n    def get_max_area(heights):\n        stack = []\n        max_area = 0\n        i = 0\n        while i < len(heights):\n            if not stack or heights[i] >= heights[stack[-1]]:\n                stack.append(i)\n                i += 1\n            else:\n                top = stack.pop()\n                area = heights[top] * (i if not stack else i - stack[-1] - 1)\n                max_area = max(max_area, area)\n        \n        while stack:\n            top = stack.pop()\n            area = heights[top] * (i if not stack else i - stack[-1] - 1)\n            max_area = max(max_area, area)\n        \n        return max_area\n    \n    if not grid:\n        return 0\n    \n    m, n = len(grid), len(grid[0])\n    heights = [0] * n\n    max_area = 0\n    \n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                heights[j] = 0\n            else:\n                heights[j] += 1\n        \n        max_area = max(max_area, get_max_area(heights))\n    \n    return max_area\n\ndef g():\n    return [\n        [1, 0, 0, 1, 1],\n        [1, 1, 1, 1, 0],\n        [0, 1, 1, 1, 1],\n        [0, 0, 1, 1, 0]\n    ]\n\nassert f(g()) == 6\n",
        "idx_generation": 258,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the nth Fibonacci number.\n\n    Example:\n    n = 6\n\n    Output:\n    8\n\n    Explanation:\n    The 6th Fibonacci number is 8.\n\n    Hint: Use recursion to calculate the Fibonacci numbers.\n    \"\"\"\n\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return f(n - 1) + f(n - 2)\n\ndef g(n: int):\n    return n\n\nassert f(g(10)) == 55\n",
        "idx_generation": 483,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, return the maximum sum of a subgrid.\n\n    Args:\n    - grid: A 2D list of integers.\n\n    Returns:\n    - The maximum sum of a subgrid.\n\n    Example:\n    f([[1, 2, 3],\n       [4, 5, 6],\n       [7, 8, 9]]) -> 45\n    Explanation: The maximum sum is obtained by taking the entire grid.\n\n    f([[1, -2, 3],\n       [4, -5, 6],\n       [-7, 8, 9]]) -> 20\n    Explanation: The maximum sum is obtained by taking the subgrid [[4, -5, 6], [-7, 8, 9]].\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    prefix_sum = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            prefix_sum[i][j] = prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1] + grid[i - 1][j - 1]\n\n    max_sum = float('-inf')\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(i, m + 1):\n                for l in range(j, n + 1):\n                    subgrid_sum = prefix_sum[k][l] - prefix_sum[i - 1][l] - prefix_sum[k][j - 1] + prefix_sum[i - 1][j - 1]\n                    max_sum = max(max_sum, subgrid_sum)\n\n    return max_sum\n\n\ndef g() -> List[List[int]]:\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n\nassert f(g()) == 45\n",
        "idx_generation": 427,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the minimum path sum from the top-left to the bottom-right corner of a grid.\"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[m-1][n-1]\n\ndef g(grid: List[List[int]]):\n    return grid\n\nassert f(g([[1, 3, 1], [1, 5, 1], [4, 2, 1]])) == 7\n",
        "idx_generation": 165,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(s: str, k: int) -> int:\n    \"\"\"\n    Given a string 's' consisting of lowercase English letters, return the length of the longest substring that contains at most 'k' distinct characters.\n\n    Example:\n    s = \"abaccc\"\n    k = 2\n\n    Output:\n    4\n\n    Explanation:\n    The longest substring with at most 2 distinct characters is \"abac\", which has a length of 4.\n    \"\"\"\n\n    if k == 0:\n        return 0\n\n    counts = {}\n    max_length = 0\n    left = 0\n    right = 0\n\n    while right < len(s):\n        counts[s[right]] = counts.get(s[right], 0) + 1\n\n        if len(counts) <= k:\n            max_length = max(max_length, right - left + 1)\n        else:\n            counts[s[left]] -= 1\n            if counts[s[left]] == 0:\n                del counts[s[left]]\n            left += 1\n\n        right += 1\n\n    return max_length\n\ndef g() -> Tuple[str, int]:\n    s = \"abaccc\"\n    k = 2\n    return s, k\n\nassert f(*g()) == 4\n\n",
        "idx_generation": 496,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string 's', find the length of the longest substring without repeating characters.\n    Return the length of the longest substring.\n\n    Example:\n    s = \"abcabcbb\"\n\n    Output:\n    3 (since the longest substring without repeating characters is \"abc\")\n    \"\"\"\n    max_length = 0\n    start = 0\n    char_map = {}\n    \n    for i in range(len(s)):\n        if s[i] in char_map and char_map[s[i]] >= start:\n            start = char_map[s[i]] + 1\n        char_map[s[i]] = i\n        max_length = max(max_length, i - start + 1)\n    \n    return max_length\n\ndef g():\n    return \"abcabcbb\"\n\nassert f(g()) == 3\n\n",
        "idx_generation": 187,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of set bits (1s) in its binary representation.\n    Return the count of set bits.\n    \"\"\"\n    count = 0\n    \n    while n:\n        count += n & 1\n        n >>= 1\n        \n    return count\n\ndef g(n = 10):\n    return n\n\nassert f(g()) == 2\n",
        "idx_generation": 87,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of ways to climb n stairs by taking either 1 or 2 steps at a time\"\"\"\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    return f(n-1) + f(n-2)\n\ndef g():\n    return 5\n\nassert f(g()) == 8\n",
        "idx_generation": 93,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the minimum sum path from the top-left corner to the bottom-right corner.\n    Only down and right movements are allowed.\n\n    Return the minimum sum.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum sum path is 1 -> 3 -> 1 -> 1 -> 1.\n    \"\"\"\n    if not grid:\n        return 0\n\n    rows, cols = len(grid), len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    \n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[-1][-1]\n\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 499,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\nfrom collections import deque\n\ndef f(graph: List[List[int]], start: int, target: int) -> bool:\n    \"\"\"\n    Given a directed graph as an adjacency matrix and two vertices start and target,\n    determine if there is a path from start to target in the graph.\n    \"\"\"\n    n = len(graph)\n    visited = [False] * n\n\n    def dfs(v):\n        if v == target:\n            return True\n        visited[v] = True\n        for i in range(n):\n            if graph[v][i] == 1 and not visited[i]:\n                if dfs(i):\n                    return True\n        return False\n\n    return dfs(start)\n\ndef g() -> List[List[int]]:\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    return graph, 0, 3\n\nassert f(*g()) == True\n",
        "idx_generation": 450,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there exists a path from start to end in a directed graph.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph.get(node, []))\n    return False\n\ndef g():\n    # Constructing a directed graph\n    graph = {1: [2, 3], 2: [3, 4], 3: [4], 4: [5, 6], 5: [6], 6: []}\n    start = 1\n    end = 6\n    return graph, start, end\n\nassert f(*g())\n",
        "idx_generation": 131,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(adj_matrix: List[List[int]]) -> bool:\n    \"\"\"Check if the given adjacency matrix represents a directed acyclic graph (DAG).\"\"\"\n    n = len(adj_matrix)\n    visited = [False] * n\n    stack = [False] * n\n\n    def is_cyclic(node):\n        if visited[node] == False:\n            visited[node] = True\n            stack[node] = True\n\n            for i in range(n):\n                if adj_matrix[node][i] == 1:\n                    if visited[i] == False and is_cyclic(i):\n                        return True\n                    elif stack[i] == True:\n                        return True\n\n        stack[node] = False\n        return False\n\n    for i in range(n):\n        if is_cyclic(i):\n            return False\n\n    return True\n\ndef g():\n    return [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n\nassert f(g()) == True\n",
        "idx_generation": 61,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix 'graph', determine if a cycle exists in the graph.\n\n    Example:\n    graph = [[0, 1, 0, 0],\n             [0, 0, 1, 0],\n             [0, 0, 0, 1],\n             [1, 0, 0, 0]]\n\n    Output:\n    True\n\n    Explanation:\n    The graph contains a cycle: 0 -> 1 -> 2 -> 3 -> 0\n    \"\"\"\n\n    def dfs(node: int, visited: List[bool], stack: List[bool]) -> bool:\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1:\n                if visited[neighbor] and stack[neighbor]:\n                    return True\n                elif not visited[neighbor] and dfs(neighbor, visited, stack):\n                    return True\n\n        stack[node] = False\n        return False\n\n    visited = [False] * len(graph)\n    stack = [False] * len(graph)\n\n    for node in range(len(graph)):\n        if not visited[node] and dfs(node, visited, stack):\n            return True\n\n    return False\n\ndef g() -> List[List[int]]:\n    return [[0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1],\n            [1, 0, 0, 0]]\n\nassert f(g()) == True\n",
        "idx_generation": 94,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nimport itertools\n\ndef f(n: int, k: int) -> List[List[int]]:\n    \"\"\"Generate all combinations of length k from the range 1 to n\"\"\"\n    nums = list(range(1, n+1))\n    return list(itertools.combinations(nums, k))\n\ndef g(n=5, k=2):\n    return n, k\n\nassert f(*g()) == [(1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 5)]\n\n",
        "idx_generation": 60,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the number of ways to combine the numbers in the list\n    such that their sum is equal to the target value. Each number in the list can be used multiple times.\n\n    Example:\n    nums = [1, 2, 3]\n    target = 4\n\n    Output:\n    7\n\n    Explanation:\n    There are 7 ways to combine the numbers in the list [1, 2, 3] to get the target value 4:\n    1 + 1 + 1 + 1\n    1 + 1 + 2\n    1 + 3\n    2 + 2\n    2 + 1 + 1\n    3 + 1\n    4\n    \"\"\"\n    def helper(nums: List[int], target: int) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        count = 0\n        for num in nums:\n            count += helper(nums, target - num)\n        return count\n\n    return helper(nums, target)\n\ndef g(nums: List[int] = [1, 2, 3], target: int = 4):\n    return (nums, target)\n\nassert f(*g()) == 7\n",
        "idx_generation": 125,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\nfrom math import comb\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of ways to choose k items from a set of n items.\n\n    Args:\n    - n: A non-negative integer.\n\n    Returns:\n    - The number of ways to choose k items from a set of n items.\n\n    Example:\n    f(5, 2) => 10\n    f(10, 3) => 120\n    f(7, 5) => 21\n    \"\"\"\n\n    k = 2\n    return comb(n, k)\n\ndef g() -> int:\n    n = 6\n    return n\n\nassert f(g()) == 15\n\n",
        "idx_generation": 453,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum product of any two numbers in the list.\n\n    Parameters:\n    nums (List[int]): The input list of integers.\n\n    Returns:\n    int: The maximum product of any two numbers in the list.\n    \"\"\"\n    if len(nums) < 2:\n        return 0\n\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n\n    return max_product\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n\n    Returns:\n    List[int]: A list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 20\n",
        "idx_generation": 471,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value, determine if there exists a pair of numbers in the array\n    that add up to the target value. You may assume that each input would have exactly one solution and you may not\n    use the same element twice.\n\n    Return True if there exists a pair of numbers that add up to the target value, False otherwise.\n\n    Example:\n    arr = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    True\n\n    Explanation:\n    The pair (2, 7) adds up to the target value of 9.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        total = arr[left] + arr[right]\n        if total == target:\n            return True\n        elif total < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(arr=[2, 7, 11, 15], target=9):\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 252,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if the target number is present in the sorted array\"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\ndef g(arr=[1, 3, 5, 7, 9], target=5):\n    return arr\n\nassert f(g(), target=5) == True\n",
        "idx_generation": 86,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Determine whether the given string is a palindrome.\"\"\"\n    s = s.lower()\n    s = ''.join(c for c in s if c.isalnum())\n    return s == s[::-1]\ndef g():\n    return \"A man, a plan, a canal: Panama!\"\nassert f(g()) == True\n",
        "idx_generation": 13,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, \n    determine if the target number is present in the list.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef g():\n    nums = [1, 3, 5, 7, 9, 11, 13, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 279,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the number of distinct pairs (a, b) such that a + b is divisible by 3.\n    Return the count of such pairs.\n\n    Example:\n    Input: [1, 2, 3, 4, 5, 6]\n    Output: 5\n    Explanation: The distinct pairs (1, 2), (2, 4), (1, 5), (3, 6), and (4, 5) have a sum divisible by 3.\n    \"\"\"\n\n    count = 0\n    remainder_count = [0] * 3\n\n    for num in arr:\n        remainder = num % 3\n        remainder_count[remainder] += 1\n\n    count += (remainder_count[0] * (remainder_count[0] - 1)) // 2  # Count pairs of numbers with remainder 0\n    count += remainder_count[1] * remainder_count[2]  # Count pairs of numbers with remainders 1 and 2\n\n    return count\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g()) == 5\n",
        "idx_generation": 392,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, return True if there exists a subset\n    of the list that sums up to the target value, and False otherwise.\n    \"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j < nums[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n\n    return dp[n][target]\n\ndef g():\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    nums = [2, 4, 6, 8, 10]\n    target = 14\n\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 191,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, p: str) -> bool:\n    \"\"\"\n    Check if string p is a permutation of string s.\n\n    Return True if p is a permutation of s, False otherwise.\n\n    Example:\n    s = \"abc\"\n    p = \"bca\"\n\n    Output:\n    True\n\n    Explanation:\n    \"bca\" is a permutation of \"abc\".\n    \"\"\"\n    if len(s) != len(p):\n        return False\n    \n    freq_s = [0] * 26\n    freq_p = [0] * 26\n    \n    for i in range(len(s)):\n        freq_s[ord(s[i]) - ord('a')] += 1\n        freq_p[ord(p[i]) - ord('a')] += 1\n    \n    return freq_s == freq_p\n\ndef g():\n    return \"abc\", \"bca\"\n\nassert f(*g()) == True\n",
        "idx_generation": 243,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of trailing zeros in n!.\n\n    Example:\n    n = 10\n\n    Output:\n    2 (since 10! = 3628800, which has 2 trailing zeros)\n    \"\"\"\n    count = 0\n    i = 5\n\n    while n // i >= 1:\n        count += n // i\n        i *= 5\n\n    return count\n\ndef g():\n    n = 10\n    return n\n\nassert f(g()) == 2\n",
        "idx_generation": 221,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there exists a subset of the list\n    whose sum is equal to the target value.\n\n    Example:\n    nums = [2, 3, 5, 6, 8, 10]\n    target = 9\n\n    Output:\n    True (the subset [2, 3, 4] has a sum of 9)\n    \"\"\"\n    def subset_sum(index: int, curr_sum: int) -> bool:\n        if curr_sum == target:\n            return True\n        if index >= len(nums) or curr_sum > target:\n            return False\n        \n        # Choose the current number\n        if subset_sum(index + 1, curr_sum + nums[index]):\n            return True\n        \n        # Do not choose the current number\n        if subset_sum(index + 1, curr_sum):\n            return True\n        \n        return False\n    \n    return subset_sum(0, 0)\n\ndef g():\n    nums = [2, 3, 5, 6, 8, 10]\n    target = 9\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 374,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\nfrom typing import List\n\ndef f(expression: str) -> bool:\n    \"\"\"\n    Given a mathematical expression as a string, determine if the parentheses in the expression are balanced.\n    Return True if the parentheses are balanced, False otherwise.\n\n    Example:\n    expression = \"(3 + 5) * (4 - 2)\"\n    Output: True\n\n    expression = \"(3 + 5) * (4 - 2))\"\n    Output: False\n\n    Constraints:\n    - The expression will only contain parentheses, numbers, and arithmetic operators (+, -, *, /).\n    - The expression will be a valid mathematical expression.\n    \"\"\"\n\n    stack = []\n\n    for char in expression:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n\n    return len(stack) == 0\n\ndef g(expression=\"(3 + 5) * (4 - 2)\"):\n    return expression\n\nassert f(g()) == True\n",
        "idx_generation": 492,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums, check if there exists a subarray with a sum equal to zero.\n\n    Example:\n    nums = [4, 2, -3, 1, 6]\n\n    Output:\n    True\n\n    Explanation:\n    The subarray [2, -3, 1] has a sum of 0.\n    \"\"\"\n\n    prefix_sum = 0\n    prefix_sums = set()\n\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum in prefix_sums or prefix_sum == 0:\n            return True\n        prefix_sums.add(prefix_sum)\n\n    return False\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for the function f.\n    \"\"\"\n    return [4, 2, -3, 1, 6]\n\nassert f(g()) == True\n",
        "idx_generation": 274,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the maximum sum of a contiguous subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The subarray with maximum sum is [4, -1, 2, 1] with a sum of 6.\n\n    Hint: Use Kadane's algorithm to solve this problem.\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\n\nassert f(g()) == 6\n\n",
        "idx_generation": 487,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the element that appears more than n/2 times, where n is the length of the list.\n\n    Example:\n    nums = [2, 3, 4, 2, 2, 2, 5, 2, 2]\n\n    Output:\n    2\n\n    Explanation:\n    The element 2 appears more than n/2 times in the list.\n    \"\"\"\n    stack = []\n    for num in nums:\n        if len(stack) == 0 or stack[-1] == num:\n            stack.append(num)\n        else:\n            stack.pop()\n    \n    return stack[-1]\n\ndef g():\n    return [2, 3, 4, 2, 2, 2, 5, 2, 2]\n\nassert f(g()) == 2\n\n",
        "idx_generation": 259,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the shortest path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    matrix = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The shortest path is 1 -> 3 -> 1 -> 1 -> 1, which gives a sum of 7.\n    \"\"\"\n\n    m = len(matrix)\n    n = len(matrix[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = matrix[0][0]\n\n    for i in range(1, n):\n        dp[0][i] = dp[0][i-1] + matrix[0][i]\n    for j in range(1, m):\n        dp[j][0] = dp[j-1][0] + matrix[j][0]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers.\n    \"\"\"\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n",
        "idx_generation": 486,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]], target: int) -> Tuple[int, int]:\n    \"\"\"\n    Given a 2D grid of integers and a target value, return the indices (row and column) of the first occurrence of the target value in the grid.\n\n    Sample input:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    target = 5\n\n    Sample output:\n    (1, 1)\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == target:\n                return (i, j)\n    \n    return (-1, -1)\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    target = 5\n    return grid, target\n\nassert f(*g()) == (1, 1)\n",
        "idx_generation": 429,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid represented by a list of lists, where each element is either 0 or 1,\n    determine the minimum number of steps required to traverse from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[float('inf')] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(rows):\n        for j in range(cols):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j])\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j])\n    return dp[rows-1][cols-1]\n\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 7\n",
        "idx_generation": 168,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], pattern: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a pattern string, return a new list of words that match the pattern.\n    A word matches the pattern if there is a one-to-one mapping between its characters and the pattern characters,\n    such that the same pattern character is always mapped to the same word character.\n\n    Args:\n    - words: A list of strings.\n    - pattern: The pattern string.\n\n    Returns:\n    - A new list of words that match the pattern.\n    \"\"\"\n    def match(word, pattern):\n        if len(word) != len(pattern):\n            return False\n        word_to_pattern = {}\n        pattern_to_word = {}\n        for w, p in zip(word, pattern):\n            if w in word_to_pattern and word_to_pattern[w] != p:\n                return False\n            if p in pattern_to_word and pattern_to_word[p] != w:\n                return False\n            word_to_pattern[w] = p\n            pattern_to_word[p] = w\n        return True\n\n    return [word for word in words if match(word, pattern)]\n\ndef g(words=[\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern=\"abb\") -> List[str]:\n    return words, pattern\n\nassert f(*g()) == [\"mee\", \"aqq\"]\n",
        "idx_generation": 497,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome after removing at most one character.\n    \"\"\"\n    def is_palindrome(s: str, left: int, right: int, removed: int) -> bool:\n        while left < right:\n            if s[left] != s[right]:\n                if removed == 1:\n                    return False\n                else:\n                    return is_palindrome(s, left+1, right, 1) or is_palindrome(s, left, right-1, 1)\n            left += 1\n            right -= 1\n        return True\n\n    return is_palindrome(s, 0, len(s)-1, 0)\n\ndef g() -> str:\n    \"\"\"\n    Generate a string for the function f.\n    \"\"\"\n    return \"abca\"\n\nassert f(g()) == True\n",
        "idx_generation": 202,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Find the maximum XOR value between two numbers in the given list.\"\"\"\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask = mask | (1 << i)\n        prefix_set = set()\n\n        for num in nums:\n            prefix = num & mask\n            prefix_set.add(prefix)\n\n        greedy_max_xor = max_xor | (1 << i)\n\n        for prefix in prefix_set:\n            if (prefix ^ greedy_max_xor) in prefix_set:\n                max_xor = greedy_max_xor\n                break\n\n    return max_xor\n\ndef g(nums=[3, 10, 5, 25, 2, 8]):\n    return nums\n\nassert f(g()) == 28\n",
        "idx_generation": 91,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of different ways to climb to the top of a staircase,\n    where each step can be taken either 1 or 2 steps at a time.\n    \"\"\"\n    if n == 1:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    \n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    \n    return dp[n]\n\ndef g() -> int:\n    n = 4\n    return n\n\nassert f(g()) == 5\n\n",
        "idx_generation": 98,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    Given a directed acyclic graph represented as a list of edges, find the longest path from a source node to a target node.\n\n    Args:\n    - n: The number of nodes in the graph.\n    - edges: A list of edges, where each edge is represented as a list [source, target].\n\n    Returns:\n    - The length of the longest path from a source node to a target node.\n    \"\"\"\n    # Create an adjacency list representation of the graph\n    graph = [[] for _ in range(n + 1)]\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n    \n    # Helper function to perform DFS and calculate the longest path\n    def dfs(node):\n        if not graph[node]:\n            return 0\n        else:\n            max_path = 0\n            for neighbor in graph[node]:\n                max_path = max(max_path, dfs(neighbor) + 1)\n            return max_path\n    \n    return dfs(1)\n\ndef g():\n    n = 5\n    edges = [[1, 2], [2, 3], [3, 4], [4, 5]]\n    return n, edges\n\nassert f(*g()) == 4\n",
        "idx_generation": 455,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool:\n    \"\"\"\n    Given a grid of integers and the start and end positions, determine if there exists a path from the start to the end that only moves right or down.\n\n    Sample Input:\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    start = (0, 0)\n    end = (2, 2)\n\n    Sample Output:\n    True\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    queue = [(start, grid[start[0]][start[1]])]\n    visited = set()\n\n    while queue:\n        current, total = queue.pop(0)\n        visited.add(current)\n\n        if current == end:\n            return True\n\n        x, y = current\n        if x+1 < m and (x+1, y) not in visited:\n            queue.append(((x+1, y), total + grid[x+1][y]))\n        if y+1 < n and (x, y+1) not in visited:\n            queue.append(((x, y+1), total + grid[x][y+1]))\n\n    return False\n\ndef g():\n    return [[[1, 2, 3], [4, 5, 6], [7, 8, 9]], (0, 0), (2, 2)]\n\nassert f(*g())\n\n",
        "idx_generation": 162,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Find if there is a path from start to end in a graph.\n\n    Sample Input:\n    graph = [[0, 1, 1, 0, 0],\n             [0, 0, 1, 1, 0],\n             [0, 0, 0, 0, 1],\n             [0, 0, 0, 0, 1],\n             [0, 0, 0, 0, 0]]\n    start = 0\n    end = 4\n\n    Sample Output:\n    True\n    \"\"\"\n    visited = [False] * len(graph)\n    return dfs(graph, start, end, visited)\n\ndef dfs(graph: List[List[int]], curr: int, end: int, visited: List[bool]) -> bool:\n    if curr == end:\n        return True\n    visited[curr] = True\n    for neighbor in range(len(graph[curr])):\n        if graph[curr][neighbor] == 1 and not visited[neighbor]:\n            if dfs(graph, neighbor, end, visited):\n                return True\n    return False\n\ndef g():\n    graph = [[0, 1, 1, 0, 0],\n             [0, 0, 1, 1, 0],\n             [0, 0, 0, 0, 1],\n             [0, 0, 0, 0, 1],\n             [0, 0, 0, 0, 0]]\n    start = 0\n    end = 4\n    return (graph, start, end)\n\nassert f(*g())\n",
        "idx_generation": 62,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"\n    Given a directed graph represented as a dictionary, determine if there is a path from a start node\n    to an end node. Return True if a path exists, otherwise return False.\n\n    Example:\n    graph = {\n        \"A\": [\"B\", \"C\"],\n        \"B\": [\"D\", \"E\"],\n        \"C\": [\"F\"],\n        \"D\": [],\n        \"E\": [\"F\"],\n        \"F\": []\n    }\n    start = \"A\"\n    end = \"F\"\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node \"A\" to node \"F\" in the given graph.\n\n    Hint: Use a combination of recursion and depth-first search to find the path.\n    \"\"\"\n    stack = [start]\n    visited = set()\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    return False\n\ndef g(graph={\n    \"A\": [\"B\", \"C\"],\n    \"B\": [\"D\", \"E\"],\n    \"C\": [\"F\"],\n    \"D\": [],\n    \"E\": [\"F\"],\n    \"F\": []\n}, start=\"A\", end=\"F\"):\n    return graph, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 114,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int, target_sum: int) -> bool:\n    \"\"\"\n    Given a list of positive integers and a target sum, find the number of ways to obtain the target sum\n    by selecting exactly k integers from the list, where repetition is allowed.\n\n    For example, given the list [1, 2, 3] and the target sum 4, with k = 2, the function should return 3,\n    as there are 3 ways to select 2 integers from the list [1, 2, 3] that sum up to 4: [1, 3], [2, 2], [3, 1].\n    \"\"\"\n    def count_ways(n, k, target_sum):\n        if k == 0:\n            return 1 if target_sum == 0 else 0\n        elif n == 0:\n            return 0\n        else:\n            ways = 0\n            for i in range(target_sum // n + 1):\n                ways += count_ways(n - 1, k - 1, target_sum - i * n)\n            return ways\n    \n    return count_ways(n, k, target_sum) > 0\n\ndef g():\n    n = 3\n    k = 2\n    target_sum = 4\n    return n, k, target_sum\n\nassert f(*g())\n",
        "idx_generation": 61,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of unique combinations of elements that add up to a target sum.\n\n    Example:\n    nums = [1, 2, 3]\n    target = 4\n\n    Output:\n    7 (since there are 7 unique combinations that add up to 4: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2], [3, 1], [1, 3])\n    \"\"\"\n    def helper(target, nums):\n        if target == 0:\n            return 1\n        if target < 0:\n            return 0\n        count = 0\n        for i in range(len(nums)):\n            count += helper(target - nums[i], nums[:i+1])\n        return count\n\n    return helper(sum(nums), nums)\n\ndef g():\n    return [1, 2, 3]\n\nassert f(g()) == 7\n\n",
        "idx_generation": 135,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two positive integers n and k, calculate the number of different permutations of choosing k elements from a set of n elements.\n\n    Sample Input:\n    n = 5\n    k = 3\n\n    Sample Output:\n    60\n    Explanation: There are 60 different permutations of choosing 3 elements from a set of 5 elements.\n    \"\"\"\n    def factorial(num: int) -> int:\n        fact = 1\n        for i in range(1, num+1):\n            fact *= i\n        return fact\n\n    return factorial(n) // factorial(n-k)\n\ndef g(n=5, k=3):\n    return n, k\n\nassert f(*g()) == 60\n\n",
        "idx_generation": 477,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct pairs that sum up to a target value.\n\n    Parameters:\n    nums (List[int]): The input list of integers.\n\n    Returns:\n    int: The number of distinct pairs that sum up to a target value.\n    \"\"\"\n    count = 0\n    seen = set()\n\n    for num in nums:\n        target = -num\n        if target in seen:\n            count += 1\n        seen.add(num)\n\n    return count\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n\n    Returns:\n    List[int]: A list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 0\n",
        "idx_generation": 471,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, return a list of all pairs of numbers in the list that add up to the target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 7\n\n    Output:\n    [[1, 6], [2, 5], [3, 4]]\n    \"\"\"\n    pairs = []\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n\n        if curr_sum == target:\n            pairs.append([nums[left], nums[right]])\n            left += 1\n            right -= 1\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return pairs\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5, 6], target: int = 7):\n    \"\"\"\n    Generate a list of integers and a target number for the function f.\n    \"\"\"\n    return nums, target\n\nassert f(*g()) == [[1, 6], [2, 5], [3, 4]]\n",
        "idx_generation": 269,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array of distinct integers and a target sum, find all unique combinations of numbers that\n    sum up to the target. Each number in the array may only be used once in the combination.\n    \"\"\"\n    nums.sort()\n    result = []\n    \n    def backtrack(start, combination, target):\n        if target == 0:\n            result.append(combination)\n            return\n        if target < 0:\n            return\n        \n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            backtrack(i+1, combination + [nums[i]], target - nums[i])\n    \n    backtrack(0, [], target)\n    return result\n\ndef g() -> Tuple[List[int], int]:\n    nums = [10, 1, 2, 7, 6, 1, 5]\n    target = 8\n    return nums, target\n\nassert f(*g()) == [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n\n",
        "idx_generation": 98,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Union\n\ndef f(arr: List[Union[int, str]]) -> List[Union[int, str]]:\n    \"\"\"\n    Given a list of integers and strings, sort the list in non-decreasing order. Integers should be sorted in ascending order,\n    followed by strings sorted in lexicographical order.\n\n    Sample input:\n    arr = [3, 'apple', 1, 'banana', 2, 'cat']\n\n    Sample output:\n    [1, 2, 3, 'apple', 'banana', 'cat']\n    \"\"\"\n    integers = []\n    strings = []\n    \n    for element in arr:\n        if isinstance(element, int):\n            integers.append(element)\n        elif isinstance(element, str):\n            strings.append(element)\n    \n    integers.sort()\n    strings.sort()\n    \n    return integers + strings\n\ndef g():\n    return [3, 'apple', 1, 'banana', 2, 'cat']\n\nassert f(g()) == [1, 2, 3, 'apple', 'banana', 'cat']\n",
        "idx_generation": 15,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two numbers in the list.\n    Return the maximum product.\n    \"\"\"\n    nums.sort()\n    return max(nums[-1] * nums[-2], nums[0] * nums[1])\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return nums\n\nassert f(g()) == 90\n\n",
        "idx_generation": 291,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums' and a target integer 'target', find two numbers in the list that add up to the target.\n    Return a list of the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1 in the list add up to the target 9.\n    \"\"\"\n\n    # Sort the list in ascending order\n    nums.sort()\n\n    # Use two pointers to find the two numbers that add up to the target\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 399,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Find the sum of all positive integers less than or equal to n that are divisible by either 3 or 5.\n    \"\"\"\n    return sum(i for i in range(1, n+1) if i % 3 == 0 or i % 5 == 0)\n\ndef g(n=20):\n    return n\n\nassert f(g()) == 98\n",
        "idx_generation": 197,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(words: List[str], k: int) -> List[str]:\n    \"\"\"\n    Given a list of words and an integer k, return the k most frequent words in the list.\n\n    Example:\n    Input: words = [\"apple\", \"banana\", \"cherry\", \"apple\", \"banana\", \"apple\"], k = 2\n    Output: [\"apple\", \"banana\"]\n    Explanation:\n    The most frequent words in the list are \"apple\" and \"banana\", both appearing 3 times.\n    \"\"\"\n    count = {}\n    for word in words:\n        count[word] = count.get(word, 0) + 1\n\n    sorted_words = sorted(count, key=lambda x: (-count[x], x))\n    return sorted_words[:k]\n\ndef g() -> Tuple[List[str], int]:\n    return [\"apple\", \"banana\", \"cherry\", \"apple\", \"banana\", \"apple\"], 2\n\nassert f(*g()) == [\"apple\", \"banana\"]\n",
        "idx_generation": 245,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "import math\nfrom typing import*\nfrom typing import *\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all multiples of 3 or 5 below n.\n\n    Example:\n    n = 10\n\n    Output:\n    23\n\n    Explanation:\n    The multiples of 3 or 5 below 10 are 3, 5, 6, and 9. Their sum is 23.\n\n    Hint: Use the mathematical formula for the sum of an arithmetic series.\n    \"\"\"\n    def arithmetic_sum(n: int) -> int:\n        return (n * (n + 1)) // 2\n\n    sum_of_multiples = 0\n    n -= 1\n    sum_of_multiples += 3 * arithmetic_sum(n // 3)\n    sum_of_multiples += 5 * arithmetic_sum(n // 5)\n    sum_of_multiples -= 15 * arithmetic_sum(n // 15)\n    return sum_of_multiples\n\ndef g(n=10):\n    return n\n\nassert f(g()) == 23\n",
        "idx_generation": 225,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the factorial of n.\n\n    Args:\n    - n: A positive integer.\n\n    Returns:\n    - The factorial of n.\n    \"\"\"\n    if n == 0:\n        return 1\n    return n * f(n-1)\n\ndef g() -> int:\n    \"\"\"\n    Generate a random positive integer.\n    \"\"\"\n    n = 5\n    return n\n\nassert f(g()) == 120\n",
        "idx_generation": 401,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers, determine if there exists a subarray with a sum equal to zero.\n\n    Example:\n    arr = [4, 2, -3, 1, 6]\n\n    Output:\n    True\n\n    Explanation:\n    There exists a subarray [2, -3, 1] whose sum is zero.\n    \"\"\"\n\n    prefix_sum = set()\n    curr_sum = 0\n\n    for num in arr:\n        curr_sum += num\n\n        if curr_sum == 0 or curr_sum in prefix_sum:\n            return True\n\n        prefix_sum.add(curr_sum)\n\n    return False\n\ndef g():\n    return [4, 2, -3, 1, 6]\n\nassert f(g()) == True\n",
        "idx_generation": 281,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a subsequence of length 3 such that the sum of the three elements is 0.\n\n    Parameters:\n    nums (List[int]): The input list of integers.\n\n    Returns:\n    bool: True if there exists a subsequence of length 3 with sum 0, False otherwise.\n    \"\"\"\n    n = len(nums)\n    for i in range(n-2):\n        for j in range(i+1, n-1):\n            for k in range(j+1, n):\n                if nums[i] + nums[j] + nums[k] == 0:\n                    return True\n    return False\n\ndef g(nums=[-1, 2, 1, -4, 3]):\n    \"\"\"\n    Generate a list of integers.\n\n    Returns:\n    List[int]: A list of integers.\n    \"\"\"\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 489,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, use a stack to find the maximum difference between two adjacent elements.\n\n    Example:\n    nums = [5, 2, 9, 1, 7]\n\n    Output:\n    7 (since the maximum difference between adjacent elements is 9 - 2 = 7)\n    \"\"\"\n\n    max_diff = 0\n    stack = []\n\n    for num in nums:\n        while stack and num > stack[-1]:\n            max_diff = max(max_diff, num - stack.pop())\n        stack.append(num)\n\n    return max_diff\n\ndef g():\n    return [5, 2, 9, 1, 7]\n\nassert f(g()) == 7\n\n",
        "idx_generation": 265,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique BSTs (binary search trees) that can be constructed with n nodes.\n\n    Example:\n    n = 3\n\n    Output:\n    5\n\n    Explanation:\n    For n = 3, there are 5 unique BSTs that can be constructed:\n       1         3     3      2      1\n        \\       /     /      / \\      \\\n         3     2     1      1   3      2\n        /     /       \\                 \\\n       2     1         2                 3\n\n    Hint: Use dynamic programming to solve this problem.\n    \"\"\"\n\n    dp = [0] * (n+1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n+1):\n        for j in range(1, i+1):\n            dp[i] += dp[j-1] * dp[i-j]\n\n    return dp[n]\n\ndef g():\n    return 3\n\nassert f(g()) == 5\n\n",
        "idx_generation": 487,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a grid of integers, rotate the grid 90 degrees clockwise.\n\n    Return the rotated grid.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    [\n        [7, 4, 1],\n        [8, 5, 2],\n        [9, 6, 3]\n    ]\n    \"\"\"\n\n    def rotate_grid(grid):\n        m, n = len(grid), len(grid[0])\n        rotated_grid = [[0] * m for _ in range(n)]\n\n        for i in range(m):\n            for j in range(n):\n                rotated_grid[j][m - 1 - i] = grid[i][j]\n\n        return rotated_grid\n\n    return rotate_grid(grid)\n\ndef g():\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g()) == [\n    [7, 4, 1],\n    [8, 5, 2],\n    [9, 6, 3]\n]\n",
        "idx_generation": 451,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of non-negative integers, find the number of unique paths from the top-left corner to the bottom-right corner.\n    - Each cell in the grid represents a potential obstacle, where 0 means the cell is empty and 1 means the cell is blocked.\n    - You can only move either down or right at any point in time.\n    - The robot is trying to reach the bottom-right corner of the grid.\n\n    Example:\n    grid = [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]\n\n    Output:\n    2\n\n    Explanation:\n    There are two unique paths to the bottom-right corner.\n    1. Right -> Right -> Down -> Down\n    2. Down -> Down -> Right -> Right\n\n    Hint: Use dynamic programming to build a 2D array to store the number of paths at each cell.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                dp[i][j] = 1\n            elif grid[i][j] == 1:\n                dp[i][j] = 0\n            else:\n                if i > 0:\n                    dp[i][j] += dp[i-1][j]\n                if j > 0:\n                    dp[i][j] += dp[i][j-1]\n\n    return dp[m-1][n-1]\n\ndef g(grid: List[List[int]] = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]):\n    return grid\n\nassert f(g()) == 2\n",
        "idx_generation": 168,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, return the longest common prefix among them.\n\n    Args:\n    - strings: A list of strings.\n\n    Returns:\n    - The longest common prefix among the strings.\n    \"\"\"\n    if not strings:\n        return \"\"\n    \n    prefix = strings[0]\n    for string in strings:\n        while not string.startswith(prefix):\n            prefix = prefix[:-1]\n            if not prefix:\n                return \"\"\n    \n    return prefix\n\ndef g() -> List[str]:\n    return [\"flower\", \"flow\", \"flight\"]\n\nassert f(g()) == \"fl\"\n",
        "idx_generation": 499,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a list of words, determine if it is possible to construct the string s using the words in the list.\n    Each word can be used multiple times, and the words can be concatenated in any order.\n    \"\"\"\n\n    def can_construct(s: str, words: List[str], memo: dict) -> bool:\n        if s == \"\":\n            return True\n        if s in memo:\n            return memo[s]\n        for word in words:\n            if s.startswith(word):\n                suffix = s[len(word):]\n                if can_construct(suffix, words, memo):\n                    memo[s] = True\n                    return True\n        memo[s] = False\n        return False\n\n    memo = {}\n    return can_construct(s, words, memo)\n\ndef g() -> Tuple[str, List[str]]:\n    s = \"leetcode\"\n    words = [\"leet\", \"code\"]\n    return s, words\n\nassert f(*g()) == True\n\n",
        "idx_generation": 208,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a power of two.\n\n    Sample Input:\n    n = 8\n\n    Sample Output:\n    True\n    \"\"\"\n    if n <= 0:\n        return False\n\n    return n & (n - 1) == 0\n\ndef g(n=8):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 92,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of numbers, find the maximum sum of a path from the top left cell to the bottom right cell.\n    You can only move down or right.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\n\ndef g(grid: List[List[int]] = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    \"\"\"\n    Find the maximum sum of a path from the top left cell to the bottom right cell in the grid.\n    \"\"\"\n    return grid\n\n\nassert f(g()) == 12\n",
        "idx_generation": 112,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given a number of nodes n and a list of edges representing a graph, determine if the graph contains a cycle.\n\n    Return True if the graph contains a cycle, otherwise return False.\n\n    Example:\n    n = 4\n    edges = [[0, 1], [1, 2], [2, 3], [3, 0]]\n\n    Output:\n    True\n\n    Explanation:\n    The graph contains a cycle: 0 -> 1 -> 2 -> 3 -> 0\n    \"\"\"\n    def dfs(node, visited, parent):\n        visited[node] = True\n        for neighbor in edges[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, node):\n                    return True\n            elif parent != neighbor:\n                return True\n        return False\n\n    visited = [False] * n\n    for i in range(n):\n        if not visited[i]:\n            if dfs(i, visited, -1):\n                return True\n    return False\n\ndef g() -> Tuple[int, List[List[int]]]:\n    \"\"\"\n    Generate the number of nodes and a list of edges representing a graph.\n    \"\"\"\n    return 4, [[0, 1], [1, 2], [2, 3], [3, 0]]\n\nassert f(*g()) == True\n\n",
        "idx_generation": 469,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph and two vertices, start and end, check if there is a path from start to end.\n\n    Example:\n    graph = {1: [2, 3], 2: [3, 4], 3: [5], 4: [5], 5: []}\n    start = 1\n    end = 5\n    Output: True\n    \"\"\"\n\n    visited = set()\n    queue = deque([start])\n\n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        \n        visited.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                queue.append(neighbor)\n\n    return False\n\ndef g():\n    return {1: [2, 3], 2: [3, 4], 3: [5], 4: [5], 5: []}, 1, 5\n\nassert f(*g()) == True\n",
        "idx_generation": 173,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nclass Graph:\n    def __init__(self, num_vertices):\n        self.num_vertices = num_vertices\n        self.adj_list = [[] for _ in range(num_vertices)]\n    \n    def add_edge(self, u, v):\n        self.adj_list[u].append(v)\n    \n    def is_cyclic_util(self, v, visited, stack):\n        visited[v] = True\n        stack[v] = True\n        for neighbor in self.adj_list[v]:\n            if not visited[neighbor]:\n                if self.is_cyclic_util(neighbor, visited, stack):\n                    return True\n            elif stack[neighbor]:\n                return True\n        stack[v] = False\n        return False\n    \n    def is_cyclic(self):\n        visited = [False] * self.num_vertices\n        stack = [False] * self.num_vertices\n        for v in range(self.num_vertices):\n            if not visited[v]:\n                if self.is_cyclic_util(v, visited, stack):\n                    return True\n        return False\n\ndef f(graph: Graph) -> bool:\n    \"\"\"Check if a given directed graph contains a cycle.\"\"\"\n    return graph.is_cyclic()\n\ndef g():\n    graph = Graph(4)\n    graph.add_edge(0, 1)\n    graph.add_edge(1, 2)\n    graph.add_edge(2, 3)\n    graph.add_edge(3, 0)\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 63,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representing a directed graph, determine if the graph is strongly connected.\n    A directed graph is strongly connected if there is a directed path between every pair of vertices.\n    \"\"\"\n    n = len(graph)\n    \n    def dfs(v: int, visited: List[bool]):\n        visited[v] = True\n        for u in range(n):\n            if graph[v][u] == 1 and not visited[u]:\n                dfs(u, visited)\n    \n    visited = [False] * n\n    dfs(0, visited)\n    \n    if False in visited:\n        return False\n    \n    transpose = [[graph[j][i] for j in range(n)] for i in range(n)]\n    visited = [False] * n\n    dfs(0, visited)\n    \n    if False in visited:\n        return False\n    \n    return True\n\ndef g():\n    return [[0, 1, 1, 0],\n            [0, 0, 0, 1],\n            [1, 0, 0, 0],\n            [0, 0, 1, 0]]\n\nassert f(g()) == True\n",
        "idx_generation": 132,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given positive integers n and k, calculate the number of unique combinations of k elements that can be selected from\n    a set of n elements.\n\n    Sample Input:\n    n = 5\n    k = 3\n\n    Sample Output:\n    10\n    \"\"\"\n    if k == 0 or k == n:\n        return 1\n    if k > n:\n        return 0\n    return f(n-1, k-1) + f(n-1, k)\n\ndef g():\n    return [5, 3]\n\nassert f(*g()) == 10\n",
        "idx_generation": 88,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Calculate the number of permutations of a given list of numbers.\n    \"\"\"\n    def backtrack(nums, used, current_permutation, permutations):\n        if len(current_permutation) == len(nums):\n            permutations.append(current_permutation[:])\n            return\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n            used[i] = True\n            current_permutation.append(nums[i])\n            backtrack(nums, used, current_permutation, permutations)\n            used[i] = False\n            current_permutation.pop()\n    \n    permutations = []\n    used = [False] * len(nums)\n    backtrack(nums, used, [], permutations)\n    \n    return len(permutations)\n\ndef g():\n    nums = [1, 2, 3]\n    return (nums,)\n\nassert f(g()) == True\n",
        "idx_generation": 145,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, count the number of prime numbers less than or equal to n.\n\n    Args:\n    - n: An integer representing the upper limit.\n\n    Returns:\n    - The count of prime numbers less than or equal to n.\n    \"\"\"\n\n    def is_prime(num: int) -> bool:\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2, n + 1):\n        if is_prime(i):\n            count += 1\n    return count\n\ndef g(n = 20):\n    return n\n\nassert f(g()) == 8\n\n",
        "idx_generation": 498,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, check if t is an anagram of s.\n\n    An anagram is a word or phrase formed by rearranging the letters of a different word or phrase,\n    typically using all the original letters exactly once.\n\n    Example:\n    s = \"listen\"\n    t = \"silent\"\n\n    Output:\n    True\n\n    Explanation:\n    The string \"silent\" is an anagram of \"listen\" because the letters can be rearranged to form \"listen\".\n    \"\"\"\n\n    # Convert the strings to lists of characters\n    s_list = list(s)\n    t_list = list(t)\n\n    # Sort the characters in each list\n    s_list.sort()\n    t_list.sort()\n\n    # Check if the sorted lists are equal\n    return s_list == t_list\n\ndef g(s=\"listen\", t=\"silent\"):\n    \"\"\"\n    Generate two strings such that one is an anagram of the other.\n    \"\"\"\n    return s, t\n\nassert f(*g())\n\n",
        "idx_generation": 476,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and a target integer, find two numbers in the array that sum up to the target.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    Input:\n    arr = [2, 7, 11, 15]\n    target = 9\n\n    Output: [0, 1]\n\n    Explanation: The numbers at indices 0 and 1, i.e., 2 and 7, sum up to the target value of 9.\n    \"\"\"\n\n    seen = {}\n\n    for i, num in enumerate(arr):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    arr = [2, 7, 11, 15]\n    target = 9\n    return arr, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 284,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, determine if there are three numbers in the list that add up\n    to the target. Return True if such numbers exist, otherwise return False.\n\n    Example:\n    nums = [1, 2, 4, 5, 6, 8, 9]\n    target = 13\n\n    Output:\n    True\n\n    Explanation:\n    The numbers 4, 5, and 9 add up to the target of 13.\n\n    Hint: Use the two-pointer technique to find two numbers that add up to the target, and recursion to find the third number.\n    \"\"\"\n\n    def twoSum(nums: List[int], target: int) -> bool:\n        left = 0\n        right = len(nums) - 1\n\n        while left < right:\n            current_sum = nums[left] + nums[right]\n            if current_sum == target:\n                return True\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n\n        return False\n\n    def threeSum(nums: List[int], target: int) -> bool:\n        if len(nums) < 3:\n            return False\n\n        for i in range(len(nums)):\n            if twoSum(nums[i+1:], target - nums[i]):\n                return True\n\n        return False\n\n    nums.sort()\n    return threeSum(nums, target)\n\ndef g(nums=[1, 2, 4, 5, 6, 8, 9], target=13):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 100,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, result: int, permutations=['abc', 'bca', 'cab', 'acb', 'bac', 'cba']) -> bool:\n    \"\"\"Check if the given string is the result of sorting the characters of any string in the list.\"\"\"\n    return any((sorted(p) == list(s) for p in permutations)) and len(s) == result\ndef g(permutations=['abc', 'bca', 'cab', 'acb', 'bac', 'cba']):\n    return ''.join(sorted(permutations[2]))\nassert f(g(), 3)\n",
        "idx_generation": 21,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of three numbers from the list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    24\n\n    Explanation:\n    The maximum product of three numbers is 2 * 3 * 4 = 24.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    \n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g(nums: List[int] = [1, 2, 3, 4]):\n    return (nums,)\n\nassert f(*g()) == 24\n\n",
        "idx_generation": 313,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the number of pairs of integers in the list that sum up to the target.\n    \"\"\"\n    count = 0\n    nums.sort()  # Sorting the list in ascending order\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        if nums[left] + nums[right] == target:\n            count += 1\n            left += 1\n            right -= 1\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return count\n\ndef g() -> List[int]:\n    return [2, 4, 6, 8, 10, 12]\n\nassert f(g(), 14) == 3\n\n",
        "idx_generation": 407,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the longest increasing subsequence (LIS).\n    The LIS is the longest subsequence in the list where the elements are in strictly increasing order.\n    Return the length of the LIS.\n    \"\"\"\n    if not nums:\n        return 0\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g(nums: List[int] = [10, 9, 2, 5, 3, 7, 101, 18]):\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 201,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], k: int) -> List[str]:\n    \"\"\"\n    Given a list of words and an integer k, return the k most frequent words in the list.\n    If there are multiple words with the same frequency, sort them alphabetically.\n    \"\"\"\n    word_count = {}\n    for word in words:\n        if word in word_count:\n            word_count[word] += 1\n        else:\n            word_count[word] = 1\n    \n    sorted_words = sorted(word_count.keys(), key=lambda x: (-word_count[x], x))\n    \n    return sorted_words[:k]\n\ndef g():\n    words = [\"apple\", \"banana\", \"cherry\", \"apple\", \"banana\", \"apple\", \"cherry\", \"date\", \"elderberry\"]\n    k = 3\n    return words, k\n\nassert f(*g()) == [\"apple\", \"banana\", \"cherry\"]\n",
        "idx_generation": 253,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Determine if a given matrix is a magic square.\n    A magic square is an n x n square matrix filled with distinct positive integers in the range [1, n^2]\n    where the sum of each row, each column, and both diagonals are equal.\n    \"\"\"\n    n = len(matrix)\n    target_sum = n * (n ** 2 + 1) // 2\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for j in range(n):\n        col_sum = sum(matrix[i][j] for i in range(n))\n        if col_sum != target_sum:\n            return False\n\n    # Check diagonal 1\n    diag1_sum = sum(matrix[i][i] for i in range(n))\n    if diag1_sum != target_sum:\n        return False\n\n    # Check diagonal 2\n    diag2_sum = sum(matrix[i][n-i-1] for i in range(n))\n    if diag2_sum != target_sum:\n        return False\n\n    return True\n\ndef g():\n    return [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n\nassert f(g()) == True\n",
        "idx_generation": 230,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all the multiples of 3 and 5 below n.\n    \"\"\"\n    def calculate_sum(num):\n        if num <= 0:\n            return 0\n        if num % 3 == 0 or num % 5 == 0:\n            return num + calculate_sum(num - 1)\n        else:\n            return calculate_sum(num - 1)\n\n    return calculate_sum(n - 1)\n\n\ndef g(n=10):\n    return n\n\nassert f(g()) == 23\n\n",
        "idx_generation": 402,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the two numbers in the list that sum up to the target value.\n    Return the indices of the two numbers as a tuple.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    (0, 1)\n\n    Hint: Use a hash table to store the complements of the numbers as you iterate through the list.\n    \"\"\"\n\n    num_map = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return num_map[complement], i\n        num_map[num] = i\n\n    return ()\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == (0, 1)\n\n",
        "idx_generation": 289,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the elements in the original list except itself.\n\n    Parameters:\n    nums (List[int]): The input list of integers.\n\n    Returns:\n    List[int]: The new list where each element is the product of all the elements in the original list except itself.\n    \"\"\"\n    n = len(nums)\n    result = [1] * n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                result[i] *= nums[j]\n    return result\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    \"\"\"\n    Generate a list of integers.\n\n    Returns:\n    List[int]: A list of integers.\n    \"\"\"\n    return nums\n\nassert f(g()) == [120, 60, 40, 30, 24]\n",
        "idx_generation": 489,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\nclass MinStack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n    \n    def push(self, x: int) -> None:\n        self.stack.append(x)\n        if not self.min_stack or x <= self.min_stack[-1]:\n            self.min_stack.append(x)\n    \n    def pop(self) -> None:\n        if self.stack.pop() == self.min_stack[-1]:\n            self.min_stack.pop()\n    \n    def top(self) -> int:\n        return self.stack[-1]\n    \n    def getMin(self) -> int:\n        return self.min_stack[-1]\n\ndef f(stack: MinStack) -> List[int]:\n    \"\"\"\n    Given a stack of integers, perform the following operations:\n    - Add the integers 5, 3, and 7 to the stack\n    - Pop the top element from the stack\n    - Return the current minimum element in the stack\n\n    Args:\n    - stack: A stack of integers\n\n    Returns:\n    - A list containing the top element of the stack and the current minimum element\n    \"\"\"\n    stack.push(5)\n    stack.push(3)\n    stack.push(7)\n    stack.pop()\n    return [stack.top(), stack.getMin()]\n\ndef g():\n    stack = MinStack()\n    return stack\n\nassert f(g()) == [3, 3]\n",
        "idx_generation": 272,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer k, return the maximum sum of a subarray of size k.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    k = 3\n\n    Output:\n    12\n\n    Explanation:\n    The subarray with maximum sum is [3, 4, 5] with a sum of 12.\n\n    Hint: Use sliding window technique to solve this problem.\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n    left = 0\n\n    for right in range(len(nums)):\n        curr_sum += nums[right]\n\n        if right - left + 1 == k:\n            max_sum = max(max_sum, curr_sum)\n            curr_sum -= nums[left]\n            left += 1\n\n    return max_sum\n\ndef g(nums=[1, 2, 3, 4, 5], k=3):\n    return nums, k\n\nassert f(*g()) == 12\n\n",
        "idx_generation": 487,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the maximum sum of a hourglass in the grid.\n\n    An hourglass in the grid is defined as follows:\n    - There are 7 cells in total, forming the shape of an hourglass.\n    - The cells in the hourglass must be adjacent to each other, either horizontally or vertically.\n\n    Parameters:\n    grid (List[List[int]]): The 2D grid of integers.\n\n    Returns:\n    int: The maximum sum of a hourglass in the grid.\n    \"\"\"\n\n    if not grid or len(grid) < 3 or len(grid[0]) < 3:\n        return 0\n\n    max_sum = float('-inf')\n\n    for i in range(len(grid) - 2):\n        for j in range(len(grid[0]) - 2):\n            hourglass_sum = grid[i][j] + grid[i][j + 1] + grid[i][j + 2] + grid[i + 1][j + 1] + grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2]\n            max_sum = max(max_sum, hourglass_sum)\n\n    return max_sum\n\n\ndef g(grid=[\n    [1, 1, 1, 0, 0],\n    [0, 1, 0, 0, 0],\n    [1, 1, 1, 0, 0],\n    [0, 0, 2, 4, 4],\n    [0, 0, 0, 2, 0],\n    [0, 0, 1, 2, 4]\n]) -> List[List[int]]:\n    return grid\n\nassert f(g()) == 19\n\n",
        "idx_generation": 463,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique paths from the top-left corner to the bottom-right corner\n    in a grid of size n x n. You can only move down or right.\n    \"\"\"\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][0] = 1\n        dp[0][i] = 1\n    \n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[n-1][n-1]\n\ndef g():\n    return 3\n\nassert f(g()) == 6\n",
        "idx_generation": 180,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Given two strings s1 and s2 of equal length, determine if they are isomorphic.\n\n    Two strings are isomorphic if the characters in s1 can be replaced to get s2.\n\n    All occurrences of a character must be replaced with another character\n    while preserving the order of characters. No two characters may map to the same character,\n    but a character may map to itself.\n\n    Example:\n    Input: s1 = \"egg\", s2 = \"add\"\n    Output: True\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n\n    map1 = {}\n    map2 = {}\n\n    for char1, char2 in zip(s1, s2):\n        if char1 not in map1 and char2 not in map2:\n            map1[char1] = char2\n            map2[char2] = char1\n        elif map1.get(char1) != char2 or map2.get(char2) != char1:\n            return False\n\n    return True\n\ndef g() -> Tuple[str, str]:\n    \"\"\"\n    Generate a tuple containing two strings of equal length.\n    \"\"\"\n    s1 = \"paper\"\n    s2 = \"title\"\n    return (s1, s2)\n\nassert f(*g()) == True\n",
        "idx_generation": 353,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\n\ndef f(s: str, t: str) -> int:\n    \"\"\"\n    Given two strings s and t, determine the minimum number of operations required to convert s to t. An operation is defined as\n    either inserting a character, deleting a character, or replacing a character.\n\n    Example:\n    s = \"horse\"\n    t = \"ros\"\n\n    Output:\n    3\n\n    Hint: Use dynamic programming to build a table of minimum operations for each prefix of the two strings.\n    \"\"\"\n\n    m = len(s)\n    n = len(t)\n\n    # Creating a table to store minimum operations\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # Initializing the first row and column of the table\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    # Updating the table based on the minimum operations\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n\n    # Returning the minimum number of operations\n    return dp[m][n]\n\ndef g(s=\"horse\", t=\"ros\"):\n    return s, t\n\nassert f(*g()) == 3\n\n",
        "idx_generation": 250,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and an integer k, find the maximum XOR value of any two numbers in the list such that the XOR result is less than or equal to k.\n\n    Example:\n    nums = [5, 10, 15, 20, 25]\n    k = 18\n\n    Output:\n    17\n\n    Explanation:\n    The maximum XOR value of any two numbers in the list that is less than or equal to 18 is 17 (5 XOR 20 = 17).\n\n    Hint: Use bit manipulation to check the XOR value of each pair of numbers and keep track of the maximum XOR value.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            if xor <= k and xor > max_xor:\n                max_xor = xor\n    return max_xor\n\ndef g(nums=[5, 10, 15, 20, 25], k=18):\n    return nums, k\n\nassert f(g()[0], g()[1]) == 17\n",
        "idx_generation": 96,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find the sum of the digits of a number\"\"\"\n    def sum_of_digits(num):\n        if num < 10:\n            return num\n        return (num % 10) + sum_of_digits(num // 10)\n\n    return sum_of_digits(n) % 3 == 0\n\ndef g():\n    return 12345\n\nassert f(g()) == True\n",
        "idx_generation": 118,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency list and two nodes, determine if there is a path from the start node to the end node.\n\n    Example:\n    graph = [\n        [1, 2],\n        [2],\n        [3],\n        [],\n    ]\n    start = 0\n    end = 3\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 0 to node 3 in the graph.\n\n    Hint: Use a depth-first search (DFS) algorithm to traverse the graph and determine if there is a path from the start node to the end node.\n    \"\"\"\n    visited = [False] * len(graph)\n    \n    def dfs(node):\n        if node == end:\n            return True\n        \n        visited[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n        \n        return False\n    \n    return dfs(start)\n\ndef g() -> Tuple[List[List[int]], int, int]:\n    \"\"\"\n    Generate a directed graph represented as an adjacency list, and two nodes (start and end) for the puzzle.\n    \"\"\"\n    graph = [\n        [1, 2],\n        [2],\n        [3],\n        [],\n    ]\n    start = 0\n    end = 3\n    return graph, start, end\n\nassert f(*g()) == True\n\n",
        "idx_generation": 476,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Graph:\n    def __init__(self, num_vertices: int, edges: List[List[int]]):\n        self.num_vertices = num_vertices\n        self.adj_list = [[] for _ in range(num_vertices)]\n        for edge in edges:\n            u, v = edge\n            self.adj_list[u].append(v)\n    \n    def is_connected(self, source: int, destination: int) -> bool:\n        visited = [False] * self.num_vertices\n        stack = [source]\n        while stack:\n            node = stack.pop()\n            if node == destination:\n                return True\n            if not visited[node]:\n                visited[node] = True\n                stack.extend(self.adj_list[node])\n        return False\n\ndef f(num_vertices: int, edges: List[List[int]], source: int, destination: int) -> bool:\n    \"\"\"\n    Given a graph represented by its edges, determine if there is a path from source to destination.\n\n    Args:\n    - num_vertices: The number of vertices in the graph.\n    - edges: A list of edges, where each edge is represented by a pair of vertices.\n    - source: The source vertex.\n    - destination: The destination vertex.\n\n    Returns:\n    - True if there is a path from source to destination, False otherwise.\n    \"\"\"\n    graph = Graph(num_vertices, edges)\n    return graph.is_connected(source, destination)\n\ndef g() -> Tuple[int, List[List[int]], int, int]:\n    num_vertices = 5\n    edges = [[0, 1], [1, 2], [2, 3], [3, 4]]\n    source = 0\n    destination = 4\n    return num_vertices, edges, source, destination\n\nassert f(*g())\n",
        "idx_generation": 183,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(adj_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representing a graph, check if the graph contains a cycle.\n    \"\"\"\n\n    visited = [False] * len(adj_matrix)\n    stack = [False] * len(adj_matrix)\n\n    for i in range(len(adj_matrix)):\n        if not visited[i] and is_cyclic(adj_matrix, i, visited, stack):\n            return True\n\n    return False\n\ndef is_cyclic(adj_matrix: List[List[int]], vertex: int, visited: List[bool], stack: List[bool]) -> bool:\n    visited[vertex] = True\n    stack[vertex] = True\n\n    for neighbor in range(len(adj_matrix)):\n        if adj_matrix[vertex][neighbor] == 1:\n            if not visited[neighbor]:\n                if is_cyclic(adj_matrix, neighbor, visited, stack):\n                    return True\n            elif stack[neighbor]:\n                return True\n\n    stack[vertex] = False\n    return False\n\ndef g():\n    adj_matrix = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 0, 0, 0]\n    ]\n    return adj_matrix\n\nassert f(g()) == True\n",
        "idx_generation": 66,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Determine if there exists a path from the top-left corner to the bottom-right corner in the given grid,\n    where each cell is either 0 (empty) or 1 (obstacle).\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    visited = set()\n\n    def dfs(i, j):\n        if i == m - 1 and j == n - 1:\n            return True\n        if i >= m or j >= n or grid[i][j] == 1 or (i, j) in visited:\n            return False\n        visited.add((i, j))\n        return dfs(i + 1, j) or dfs(i, j + 1)\n\n    return dfs(0, 0)\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid with obstacles and empty cells.\n    \"\"\"\n    return [[0, 0, 1, 0],\n            [0, 1, 0, 0],\n            [0, 1, 0, 1],\n            [0, 0, 0, 0]]\n\nassert f(g()) == True\n",
        "idx_generation": 133,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, count all numbers with unique digits, x, where 0 \u2264 x < 10^n.\n\n    Sample Input:\n    n = 2\n\n    Sample Output:\n    91\n\n    Explanation:\n    There are a total of 91 unique numbers with 2 digits (0, 1, 2, ..., 10, 11, ..., 98, 99).\n    \"\"\"\n    if n == 0:\n        return 1\n    \n    count = 10\n    unique_digits = 9\n    available_digits = 9\n    \n    for i in range(1, min(n, 10)):\n        unique_digits *= available_digits\n        count += unique_digits\n        available_digits -= 1\n    \n    return count\n\ndef g(n=2):\n    return n\n\nassert f(g()) == 91\n",
        "idx_generation": 140,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the number of ways to climb n stairs, where each step can be taken as either 1 or 2 steps.\n    \"\"\"\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    return f(n-1) + f(n-2)\n\ndef g(n=4):\n    return n\n\nassert f(g()) == 5\n",
        "idx_generation": 147,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order and return the sorted list.\n    \"\"\"\n    nums.sort()\n    return nums\n\ndef g() -> List[int]:\n    \"\"\"\n    Return a list of integers.\n    \"\"\"\n    return [4, 2, 1, 3]\n\nassert f(g()) == [1, 2, 3, 4]\n",
        "idx_generation": 479,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Determine if the target number is present in the given sorted array using binary search.\n    \"\"\"\n    def binary_search(arr: List[int], target: int, low: int, high: int) -> bool:\n        if low <= high:\n            mid = (low + high) // 2\n            if arr[mid] == target:\n                return True\n            elif arr[mid] > target:\n                return binary_search(arr, target, low, mid - 1)\n            else:\n                return binary_search(arr, target, mid + 1, high)\n        else:\n            return False\n\n    return binary_search(arr, target, 0, len(arr) - 1)\n\ndef g(arr: List[int] = [1, 3, 5, 7, 9, 11], target: int = 7):\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 292,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find the longest increasing subsequence (LIS) within the list.\n    Return the LIS as a list of integers.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    Output:\n    [2, 3, 7, 18]\n\n    Explanation:\n    The longest increasing subsequence is [2, 3, 7, 18] with length 4.\n    \"\"\"\n    def find_lis(nums):\n        n = len(nums)\n        dp = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        max_length = max(dp)\n        lis = []\n        for i in range(n-1, -1, -1):\n            if dp[i] == max_length:\n                lis.append(nums[i])\n                max_length -= 1\n        lis.reverse()\n        return lis\n\n    return find_lis(nums)\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return (nums,)\n\nassert f(*g()) == [2, 3, 7, 18]\n",
        "idx_generation": 102,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if t is an anagram of s.\n    An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\n    Example:\n    s = \"listen\"\n    t = \"silent\"\n    Output: True\n\n    s = \"hello\"\n    t = \"world\"\n    Output: False\n    \"\"\"\n    return sorted(s) == sorted(t)\n\ndef g(s = \"listen\", t = \"silent\"):\n    return s, t\n\nassert f(*g())\n",
        "idx_generation": 127,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3])\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 60\n",
        "idx_generation": 322,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of combinations of three numbers that sum up to zero.\n\n    Example:\n    nums = [-1, 0, 1, 2, -1, -4]\n    The combinations that sum up to zero are:\n    [-1, 0, 1]\n    [-1, -1, 2]\n\n    Return the number of combinations.\n    \"\"\"\n    nums.sort()\n    count = 0\n\n    for i in range(len(nums) - 2):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n        left = i + 1\n        right = len(nums) - 1\n\n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total < 0:\n                left += 1\n            elif total > 0:\n                right -= 1\n            else:\n                count += 1\n                while left < right and nums[left] == nums[left+1]:\n                    left += 1\n                while left < right and nums[right] == nums[right-1]:\n                    right -= 1\n                left += 1\n                right -= 1\n\n    return count\n\ndef g() -> List[int]:\n    nums = [-1, 0, 1, 2, -1, -4]\n    return nums\n\nassert f(g()) == 2\n",
        "idx_generation": 414,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1, 2 and 7, and 11 and 15 all add up to 9. The function should return the indices of any\n    pair of numbers that satisfy the condition.\n    \"\"\"\n\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 201,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[int]:\n    \"\"\"\n    Given a positive integer n, generate all possible binary strings of length n.\n\n    Example:\n    n = 3\n\n    Output:\n    ['000', '001', '010', '011', '100', '101', '110', '111']\n    \"\"\"\n\n    binary_strings = []\n    for i in range(2**n):\n        binary_string = bin(i)[2:].zfill(n)\n        binary_strings.append(binary_string)\n\n    return binary_strings\n\ndef g():\n    return 3\n\nassert f(g()) == ['000', '001', '010', '011', '100', '101', '110', '111']\n",
        "idx_generation": 277,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of trailing zeros in n!.\n\n    Example:\n    n = 10\n\n    Output:\n    2\n\n    Explanation:\n    The factorial of 10 is 10! = 3628800, which has 2 trailing zeros.\n    \"\"\"\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n    return count\n\ndef g():\n    n = 10\n    return n\n\nassert f(g()) == 2\n\n",
        "idx_generation": 235,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a non-empty subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6 (the subarray [4, -1, 2, 1] has the maximum sum of 6)\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g() -> List[int]:\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 442,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Find the maximum sum of a subarray within a given array of integers.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    n = len(nums)\n    dp = [0] * n\n    dp[0] = nums[0]\n    \n    for i in range(1, n):\n        dp[i] = max(nums[i], dp[i-1] + nums[i])\n    \n    return max(dp)\n\ndef g(nums: List[int] = [-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 290,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find the maximum subarray sum.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The maximum subarray sum.\n    \"\"\"\n\n    if not nums:\n        return []\n    \n    curr_sum = max_sum = nums[0]\n    start = end = 0\n\n    for i in range(1, len(nums)):\n        if nums[i] > curr_sum + nums[i]:\n            curr_sum = nums[i]\n            start = i\n        else:\n            curr_sum += nums[i]\n        \n        if curr_sum > max_sum:\n            max_sum = curr_sum\n            end = i\n    \n    return nums[start:end+1]\n\ndef g(nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\n\nassert f(g()) == [4, -1, 2, 1]\n",
        "idx_generation": 490,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\nfrom typing import List\n\ndef f(expression: str) -> bool:\n    \"\"\"\n    Given a mathematical expression as a string, determine if the expression is balanced.\n    A balanced expression has an equal number of opening and closing parentheses.\n\n    Sample Input:\n    expression = \"((2 + 3) * 4) - (5 / 2)\"\n\n    Sample Output:\n    True\n    \"\"\"\n    stack = []\n    for char in expression:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g():\n    \"\"\"\n    Generate the input values for the function f.\n    \"\"\"\n    expression = \"((2 + 3) * 4) - (5 / 2)\"\n    return expression\n\nassert f(g()) == True\n",
        "idx_generation": 309,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a contiguous subarray.\n\n    Return the maximum sum.\n\n    Example:\n    nums = [1, -2, 3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    9\n\n    Explanation:\n    The contiguous subarray with the maximum sum is [3, 4, -1, 2, 1], which sums up to 9.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g():\n    nums = [1, -2, 3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 9\n",
        "idx_generation": 488,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum of values from the top-left corner to the bottom-right corner.\n    The allowed moves are right and down.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[float('inf')] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(rows):\n        for j in range(cols):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j])\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j])\n\n    return dp[rows-1][cols-1]\n\ndef g(grid: List[List[int]] = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    \"\"\"\n    Return the input grid.\n    \"\"\"\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 188,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if they are isomorphic.\n    Two strings are isomorphic if the characters in s can be replaced to get t.\n\n    The replacement must be one-to-one, meaning that each character in s must be replaced with a unique character in t, and vice versa.\n\n    Example:\n    Input: s = \"egg\", t = \"add\"\n    Output: True\n    \"\"\"\n\n    if len(s) != len(t):\n        return False\n\n    mapping_s = {}\n    mapping_t = {}\n\n    for i in range(len(s)):\n        if s[i] in mapping_s:\n            if mapping_s[s[i]] != t[i]:\n                return False\n        else:\n            mapping_s[s[i]] = t[i]\n\n        if t[i] in mapping_t:\n            if mapping_t[t[i]] != s[i]:\n                return False\n        else:\n            mapping_t[t[i]] = s[i]\n\n    return True\n\ndef g() -> Tuple[str, str]:\n    \"\"\"\n    Generate two isomorphic strings.\n    \"\"\"\n    return \"egg\", \"add\"\n\nassert f(*g())\n",
        "idx_generation": 358,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, return the longest palindromic substring in s.\n    \"\"\"\n    if len(s) < 2:\n        return s\n    \n    max_len = 0\n    start = 0\n    \n    for i in range(len(s)):\n        # Check for odd length palindromes\n        left = i\n        right = i\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        if right - left - 1 > max_len:\n            max_len = right - left - 1\n            start = left + 1\n        \n        # Check for even length palindromes\n        left = i\n        right = i + 1\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        if right - left - 1 > max_len:\n            max_len = right - left - 1\n            start = left + 1\n    \n    return s[start:start + max_len]\n\ndef g():\n    s = \"babad\"\n    return s\n\nassert f(g()) == \"bab\"\n",
        "idx_generation": 253,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine if a given number is a power of two.\n\n    Example:\n    n = 16\n    Output: True\n    Explanation: 16 is a power of 2 (2^4).\n    \"\"\"\n    assert n > 0\n    return n & (n - 1) == 0\n\ndef g():\n    n = 16\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 97,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number is a perfect square\"\"\"\n    if n < 0:\n        return False\n    \n    i = 1\n    while n > 0:\n        n -= i\n        i += 2\n    \n    return n == 0\n\ndef g():\n    n = 25\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 134,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency list, determine if there is a path from the start node to the end node.\n    \"\"\"\n    visited = set()\n    stack = [start]\n    \n    while stack:\n        node = stack.pop()\n        \n        if node == end:\n            return True\n        \n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    \n    return False\n\ndef g(start = 1, end = 5):\n    graph = {\n        1: [2, 3],\n        2: [4],\n        3: [4, 5],\n        4: [],\n        5: []\n    }\n    return graph, start, end\n\nassert f(*g())\n\n",
        "idx_generation": 193,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom collections import defaultdict\n\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"Find if there exists a path from start to end in a directed graph\"\"\"\n    def dfs(node):\n        if node == end:\n            return True\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n        return False\n\n    visited = defaultdict(bool)\n    return dfs(start)\n\ndef g():\n    graph = {\n        1: [2, 3],\n        2: [3, 4],\n        3: [4],\n        4: []\n    }\n    start = 1\n    end = 4\n    return graph, start, end\n\nassert f(*g())\n",
        "idx_generation": 70,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import Dict\n\nclass Graph:\n    def __init__(self, graph: Dict[int, List[int]]):\n        self.graph = graph\n\n    def is_cyclic_util(self, v: int, visited: List[bool], parent: int) -> bool:\n        visited[v] = True\n        for i in self.graph[v]:\n            if not visited[i]:\n                if self.is_cyclic_util(i, visited, v):\n                    return True\n            elif parent != i:\n                return True\n        return False\n\n    def is_cyclic(self) -> bool:\n        visited = [False] * len(self.graph)\n        for i in range(len(self.graph)):\n            if not visited[i]:\n                if self.is_cyclic_util(i, visited, -1):\n                    return True\n        return False\n\ndef f(graph: Dict[int, List[int]]) -> bool:\n    \"\"\"\n    Given a graph represented as a dictionary, determine if the graph contains a cycle.\n\n    Example:\n    graph = {0: [1, 2], 1: [2], 2: [0, 3], 3: [3]}\n\n    Output:\n    True\n\n    Explanation:\n    The graph contains a cycle: 0 -> 1 -> 2 -> 0.\n    \"\"\"\n    g = Graph(graph)\n    return g.is_cyclic()\n\ndef g() -> Dict[int, List[int]]:\n    return {0: [1, 2], 1: [2], 2: [0, 3], 3: [3]}\n\nassert f(g()) == True\n",
        "idx_generation": 134,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Given an integer n, generate all possible combinations of n pairs of parentheses.\n\n    Example:\n    Input: 3\n    Output: [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\n\n    Explanation: The solution set contains all possible combinations of 3 pairs of parentheses.\n    \"\"\"\n\n    def backtrack(s: str, left: int, right: int, result: List[str]):\n        if left == 0 and right == 0:\n            result.append(s)\n            return\n        if left > 0:\n            backtrack(s + \"(\", left - 1, right, result)\n        if right > left:\n            backtrack(s + \")\", left, right - 1, result)\n\n    result = []\n    backtrack(\"\", n, n, result)\n    return result\n\ndef g():\n    n = 3\n    return n\n\nassert f(g()) == [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\n",
        "idx_generation": 171,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Given an integer 'n', generate all possible combinations of 'n' elements, taken 'k' at a time.\n    The combinations should be returned as a list of lists.\n\n    Example:\n    n = 3\n\n    Output:\n    [[1, 2, 3], [1, 2], [1, 3], [2, 3], [1], [2], [3]]\n    \"\"\"\n    def backtrack(start, curr):\n        if len(curr) == k:\n            result.append(curr[:])\n            return\n        for i in range(start, n + 1):\n            curr.append(i)\n            backtrack(i + 1, curr)\n            curr.pop()\n\n    result = []\n    for k in range(n + 1):\n        backtrack(1, [])\n    return result\n\ndef g():\n    return (3,)\n\nassert f(*g()) == [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n",
        "idx_generation": 148,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order.\n\n    Example:\n    nums = [5, 2, 8, 1, 9]\n\n    Output:\n    [1, 2, 5, 8, 9]\n    \"\"\"\n    nums.sort()\n    return nums\n\ndef g() -> List[int]:\n    return [5, 2, 8, 1, 9]\n\nassert f(g()) == [1, 2, 5, 8, 9]\n",
        "idx_generation": 479,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers nums, return the next greater element for each element in the array.\n    The next greater element of an element x is the first greater element to its right.\n    If it does not exist, return -1 for that element.\n    \"\"\"\n    stack = []\n    result = [-1] * len(nums)\n    \n    for i in range(len(nums)-1, -1, -1):\n        while stack and stack[-1] <= nums[i]:\n            stack.pop()\n        if stack:\n            result[i] = stack[-1]\n        stack.append(nums[i])\n    \n    return result\n\ndef g():\n    return [4, 5, 2, 25, 10]\n\nassert f(g()) == [5, 25, 25, -1, -1]\n",
        "idx_generation": 299,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target using binary search.\n\n    Sample Input:\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n\n    Sample Output:\n    2\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\n\ndef g(arr=[1, 3, 5, 7, 9], target=5):\n    return arr, target\n\n\nassert f(*g()) == 2\n",
        "idx_generation": 109,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome\"\"\"\n    s = s.lower()\n    s = ''.join(c for c in s if c.isalnum())\n    return s == s[::-1]\n\ndef g():\n    s = \"A man, a plan, a canal, Panama!\"\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 134,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    60 (since 4 * 5 * 3 = 60)\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[n-1] * nums[n-2] * nums[n-3], nums[0] * nums[1] * nums[n-1])\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 60\n\n",
        "idx_generation": 325,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target number using binary search.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 3\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 445,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and an integer k, find the k most frequent elements in the list.\n    Return the elements in any order.\n\n    Example:\n    nums = [1,1,1,2,2,3], k = 2\n    Output: [1,2]\n    \"\"\"\n    freq_dict = {}\n    for num in nums:\n        freq_dict[num] = freq_dict.get(num, 0) + 1\n\n    sorted_nums = sorted(freq_dict, key=lambda x: freq_dict[x], reverse=True)\n    return sorted_nums[:k]\n\ndef g(nums: List[int] = [1,1,1,2,2,3], k: int = 2):\n    return (nums, k)\n\nassert f(*g()) == [1, 2]\n",
        "idx_generation": 211,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> int:\n    \"\"\"\n    Given a list of words, return the length of the longest common prefix among them.\n\n    Example:\n    words = [\"apple\", \"app\", \"apply\", \"aptitude\"]\n\n    Output:\n    2 (since the longest common prefix is \"ap\")\n    \"\"\"\n    if not words:\n        return 0\n\n    prefix = words[0]\n    for i in range(1, len(words)):\n        while words[i].find(prefix) != 0:\n            prefix = prefix[:-1]\n            if not prefix:\n                return 0\n    return len(prefix)\n\ndef g() -> List[str]:\n    return [\"apple\", \"app\", \"apply\", \"aptitude\"]\n\nassert f(g()) == 2\n\n",
        "idx_generation": 306,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the missing number.\n    The array contains all the numbers from 1 to n except for one number.\n\n    Example:\n    arr = [1, 2, 4, 5, 6]\n    The missing number in the array is 3.\n\n    Return the missing number.\n    \"\"\"\n    n = len(arr) + 1\n    target_sum = (n * (n + 1)) // 2\n    actual_sum = sum(arr)\n    return target_sum - actual_sum\n\n\ndef g() -> List[int]:\n    arr = [1, 2, 4, 5, 6]\n    return arr\n\n\nassert f(g()) == 3\n\n",
        "idx_generation": 244,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two numbers in the list.\n\n    Example:\n    Input:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output: 250\n\n    Explanation: The maximum product can be obtained by multiplying 10 and 25, which results in 250.\n    \"\"\"\n\n    max_product = float('-inf')\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            max_product = max(max_product, nums[i]*nums[j])\n\n    return max_product\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 250\n\n",
        "idx_generation": 452,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find two numbers in the list that add up to the target.\n\n    Parameters:\n    nums (List[int]): A list of integers.\n    target (int): The target number.\n\n    Returns:\n    List[int]: The indices of the two numbers that add up to the target.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 305,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all positive integers less than or equal to n that are divisible by 3 or 5.\n\n    Example:\n    n = 10\n    Output: 33\n    Explanation: The positive integers less than or equal to 10 that are divisible by 3 or 5 are 3, 5, 6, and 9. Their sum is 33.\n    \"\"\"\n    sum = 0\n    for i in range(1, n + 1):\n        if i % 3 == 0 or i % 5 == 0:\n            sum += i\n    return sum\n\ndef g(n: int = 10):\n    return n\n\nassert f(g()) == 33\n",
        "idx_generation": 491,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Stack:\n    def __init__(self):\n        self.stack = []\n\n    def push(self, value):\n        self.stack.append(value)\n\n    def pop(self):\n        if self.is_empty():\n            return None\n        return self.stack.pop()\n\n    def peek(self):\n        if self.is_empty():\n            return None\n        return self.stack[-1]\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string containing parentheses, brackets, and braces, determine if they are balanced and properly nested.\n\n    Example:\n    s = \"{[()]}\"\n\n    Output:\n    True\n\n    Explanation:\n    The string contains balanced and properly nested parentheses, brackets, and braces.\n    \"\"\"\n\n    stack = Stack()\n\n    for char in s:\n        if char in ['(', '[', '{']:\n            stack.push(char)\n        elif char in [')', ']', '}']:\n            if stack.is_empty():\n                return False\n            top = stack.pop()\n            if (char == ')' and top != '(') or (char == ']' and top != '[') or (char == '}' and top != '{'):\n                return False\n\n    return stack.is_empty()\n\ndef g():\n    return \"{[()]}\"\n\nassert f(g()) == True\n\n",
        "idx_generation": 317,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of any contiguous subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The contiguous subarray with the maximum sum is [4, -1, 2, 1], which has a sum of 6.\n\n    Hint: Use dynamic programming and recursion to solve this problem.\n    \"\"\"\n\n    def max_subarray(nums: List[int], start: int, end: int) -> int:\n        if start == end:\n            return nums[start]\n\n        mid = (start + end) // 2\n\n        left_max = max_subarray(nums, start, mid)\n        right_max = max_subarray(nums, mid+1, end)\n\n        left_sum = float('-inf')\n        right_sum = float('-inf')\n        sum = 0\n\n        for i in range(mid, start-1, -1):\n            sum += nums[i]\n            left_sum = max(left_sum, sum)\n\n        sum = 0\n\n        for i in range(mid+1, end+1):\n            sum += nums[i]\n            right_sum = max(right_sum, sum)\n\n        return max(left_max, right_max, left_sum + right_sum)\n\n    return max_subarray(nums, 0, len(nums)-1)\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 492,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Minimum Path Sum\n\n    Given a grid filled with non-negative numbers, find a path from the top left to the bottom right, which minimizes the sum of all numbers along its path. You can only move down or right at any point in time.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    output: 7\n\n    Explanation:\n    The grid represents a 3x3 matrix. The path with the minimum sum is 1 -> 3 -> 1 -> 1 -> 1, with a sum of 7.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 189,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> int:\n    \"\"\"\n    Given a string, return the length of the longest substring without repeating characters.\n\n    Example:\n    Input: \"abcabcbb\"\n    Output: 3 (the longest substring without repeating characters is \"abc\")\n\n    Input: \"bbbbb\"\n    Output: 1 (the longest substring without repeating characters is \"b\")\n    \"\"\"\n    if len(string) == 0:\n        return 0\n    \n    max_length = 0\n    start = 0\n    visited = {}\n    \n    for end in range(len(string)):\n        if string[end] in visited and visited[string[end]] >= start:\n            start = visited[string[end]] + 1\n        visited[string[end]] = end\n        max_length = max(max_length, end - start + 1)\n    \n    return max_length\n\ndef g(string: str = \"abcabcbb\"):\n    return string\n\nassert f(g()) == 3\n\n",
        "idx_generation": 362,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n\n    Args:\n    - s: The input string.\n\n    Returns:\n    - The length of the longest substring without repeating characters.\n    \"\"\"\n    max_length = 0\n    start = 0\n    char_map = {}\n\n    for i in range(len(s)):\n        if s[i] in char_map and start <= char_map[s[i]]:\n            start = char_map[s[i]] + 1\n        else:\n            max_length = max(max_length, i - start + 1)\n        char_map[s[i]] = i\n\n    return max_length\n\ndef g() -> str:\n    s = \"abcabcbb\"\n    return s\n\nassert f(g()) == 3\n",
        "idx_generation": 278,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR value between any two elements in the array.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    \n    for i in range(31, -1, -1):\n        prefixes = set()\n        mask |= (1 << i)\n        \n        for num in nums:\n            prefixes.add(num & mask)\n        \n        possible_max = max_xor | (1 << i)\n        \n        for prefix in prefixes:\n            if (possible_max ^ prefix) in prefixes:\n                max_xor = possible_max\n                break\n    \n    return max_xor\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n\n",
        "idx_generation": 98,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, compute the sum of all even Fibonacci numbers less than or equal to n.\n\n    Return the sum of even Fibonacci numbers.\n\n    Example:\n    n = 10\n\n    Output:\n    10\n\n    Explanation:\n    The even Fibonacci numbers less than or equal to 10 are [0, 2, 8]. The sum of these numbers is 10.\n    \"\"\"\n\n    def fibonacci(n):\n        if n <= 0:\n            return 0\n        if n == 1:\n            return 1\n        return fibonacci(n - 1) + fibonacci(n - 2)\n\n    sum_even_fibonacci = 0\n    i = 0\n    while True:\n        fibonacci_number = fibonacci(i)\n        if fibonacci_number > n:\n            break\n        if fibonacci_number % 2 == 0:\n            sum_even_fibonacci += fibonacci_number\n        i += 1\n\n    return sum_even_fibonacci\n\ndef g(n=10):\n    return n\n\nassert f(g()) == 10\n",
        "idx_generation": 139,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency list and two vertices 'start' and 'end',\n    determine if there exists a path from 'start' to 'end' in the graph.\n\n    Return True if a path exists, False otherwise.\n\n    Example:\n    graph = {\n        0: [1, 2],\n        1: [3],\n        2: [3],\n        3: [4],\n        4: []\n    }\n\n    start = 0, end = 4\n\n    Output:\n    True\n\n    Explanation:\n    There exists a path from vertex 0 to vertex 4: 0 -> 1 -> 3 -> 4.\n    \"\"\"\n    stack = [start]\n    visited = set()\n\n    while stack:\n        node = stack.pop()\n        visited.add(node)\n\n        if node == end:\n            return True\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n\n    return False\n\ndef g():\n    graph = {\n        0: [1, 2],\n        1: [3],\n        2: [3],\n        3: [4],\n        4: []\n    }\n    start = 0\n    end = 4\n    return graph, start, end\n\nassert f(*g()) == True\n\n",
        "idx_generation": 200,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(edges: List[Tuple[int, int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a list of edges representing a directed graph, determine if there is a path from start to end.\n    \"\"\"\n    graph = {}\n    for u, v in edges:\n        if u not in graph:\n            graph[u] = []\n        graph[u].append(v)\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        visited.add(node)\n        if node in graph:\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    stack.append(neighbor)\n    return False\ndef g():\n    edges = [\n        (0, 1),\n        (1, 2),\n        (2, 3),\n        (3, 4),\n        (4, 0)\n    ]\n    return edges, 0, 3\nassert f(*g())\n",
        "idx_generation": 80,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, return the topological order of the graph.\n    \"\"\"\n\n    def dfs(node, visited, stack):\n        visited[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, stack)\n\n        stack.append(node)\n\n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n    stack = []\n\n    for node in range(num_nodes):\n        if not visited[node]:\n            dfs(node, visited, stack)\n\n    stack.reverse()\n    return stack\n\ndef g():\n    graph = [[1, 2], [3], [], [4], [5], []]\n    return graph\n\nassert f(g()) == [0, 2, 1, 3, 4, 5]\n\n",
        "idx_generation": 147,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if it is possible to rearrange the elements in such a way that every element appears exactly twice, except for one element which appears only once.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - A boolean value indicating whether the rearrangement is possible.\n    \"\"\"\n    count = {}\n    for num in nums:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    odd_count = 0\n    for num, freq in count.items():\n        if freq % 2 != 0:\n            odd_count += 1\n    \n    return odd_count <= 1\n\ndef g() -> List[int]:\n    nums = [1, 2, 2, 3, 3, 4, 4, 5, 5]\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 172,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums, check if there exists a subsequence of length 3 such that the sum of the elements in the subsequence is equal to the product of the elements.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    True\n\n    Explanation:\n    The subsequence [2, 3, 4] has a sum of 9 and a product of 24, which are equal.\n    \"\"\"\n\n    def count_subsequences(nums, count, current_sum, current_product, start):\n        if count == 3:  # Base case: subsequence of length 3 is found\n            if current_sum == current_product:  # Check if the sum is equal to the product\n                return True\n            else:\n                return False\n\n        for i in range(start, len(nums)):\n            if count_subsequences(nums, count + 1, current_sum + nums[i], current_product * nums[i], i + 1):  # Recursive call to include the next integer\n                return True\n\n        return False\n\n    return count_subsequences(nums, 0, 0, 1, 0)\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 155,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value, determine if there are two numbers in the array that add up to the target.\n    The array is sorted in ascending order and may contain duplicates.\n\n    Example:\n    Input:\n    arr = [1, 2, 3, 4, 5, 6, 7]\n    k = 9\n\n    Output: True\n\n    Explanation: The numbers 2 and 7 in the array add up to 9.\n    \"\"\"\n\n    def two_sum(arr: List[int], target: int) -> bool:\n        left = 0\n        right = len(arr) - 1\n\n        while left < right:\n            current_sum = arr[left] + arr[right]\n            if current_sum == target:\n                return True\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n\n        return False\n\n    return two_sum(arr, k)\n\ndef g():\n    arr = [1, 2, 3, 4, 5, 6, 7]\n    k = 9\n    return arr, k\n\nassert f(*g()) == True\n",
        "idx_generation": 481,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort them in descending order using bubble sort algorithm.\n\n    Example:\n    f([3, 1, 5, 2, 4]) returns [5, 4, 3, 2, 1].\n\n    Note:\n    - The input list can contain duplicate numbers.\n    \"\"\"\n\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] < nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n\n    return nums\n\n\ndef g(nums: List[int] = [3, 1, 5, 2, 4]) -> List[int]:\n    \"\"\"\n    Generate a list of positive integers.\n\n    Example:\n    g() returns [3, 1, 5, 2, 4].\n\n    Note:\n    - The input list can contain duplicate numbers.\n    \"\"\"\n\n    return nums\n\n\nassert f(g()) == [5, 4, 3, 2, 1]\n",
        "idx_generation": 312,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the minimum number of elements from the list that sum up to the target.\n    \"\"\"\n    dp = [float('inf')] * (target+1)\n    dp[0] = 0\n\n    for num in nums:\n        for j in range(num, target+1):\n            dp[j] = min(dp[j], dp[j-num] + 1)\n\n    return dp[target]\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    target = 10\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 110,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]], k: int, origin: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of points in a 2D plane, find the k closest points to the given origin point.\n\n    Args:\n    - points: A list of points represented as [x, y] coordinates.\n    - k: The number of closest points to find.\n    - origin: The origin point represented as [x, y] coordinates.\n\n    Returns:\n    - A list of the k closest points to the origin point.\n    \"\"\"\n    distances = []\n    for point in points:\n        distance = (point[0] - origin[0]) ** 2 + (point[1] - origin[1]) ** 2\n        distances.append((point, distance))\n\n    distances.sort(key=lambda x: x[1])\n    closest_points = [point[0] for point in distances[:k]]\n    return closest_points\n\ndef g():\n    points = [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]\n    k = 3\n    origin = [0, 0]\n    return points, k, origin\n\nassert f(*g()) == [[1, 2], [3, 4], [5, 6]]\n",
        "idx_generation": 136,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a perfect square.\n    A perfect square is an integer that is the square of an integer.\n    \"\"\"\n    if n < 0:\n        return False\n    elif n == 0:\n        return True\n    else:\n        left, right = 1, n\n        while left <= right:\n            mid = (left + right) // 2\n            square = mid * mid\n            if square == n:\n                return True\n            elif square < n:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False\n\ndef g(n = 16):\n    return n\n\nassert f(g())\n",
        "idx_generation": 328,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct pairs (a, b) such that a + b = target.\n    The pairs should be unique and the order of the pairs does not matter.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n\n    Output:\n    2\n\n    Explanation:\n    The distinct pairs (a, b) such that a + b = 6 are (1, 5) and (2, 4).\n\n    Hint: Use a set to store the complement of each number to the target.\n    \"\"\"\n\n    target = 6\n    num_set = set()\n    count = 0\n\n    for num in nums:\n        complement = target - num\n        if complement in num_set:\n            count += 1\n        num_set.add(num)\n\n    return count\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g()) == 2\n\n",
        "idx_generation": 454,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a subset whose sum is equal to zero.\n    \"\"\"\n    n = len(nums)\n    dp = [[False] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(1, n + 1):\n        dp[i][0] = True\n        for j in range(1, n + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= nums[i - 1]:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - nums[i - 1]]\n    return dp[n][n]\n\ndef g() -> List[int]:\n    return [1, 2, 3, -6, 4, 5]\n\nassert f(g()) == True\n",
        "idx_generation": 217,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> int:\n    \"\"\"\n    Given a string s and a list of words, count the number of occurrences of each word in the string.\n\n    Example:\n    s = \"hello world hello\"\n    words = [\"hello\", \"world\"]\n    The word \"hello\" occurs 2 times and the word \"world\" occurs 1 time, so the output should be [2, 1].\n    \"\"\"\n    word_count = [0] * len(words)\n    for i, word in enumerate(words):\n        word_count[i] = s.count(word)\n    return word_count\n\ndef g(s: str = \"hello world hello\", words: List[str] = [\"hello\", \"world\"]) -> int:\n    \"\"\"Generate a string and a list of words.\"\"\"\n    return s, words\n\nassert f(*g()) == [2, 1]\n",
        "idx_generation": 316,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    20\n\n    Explanation:\n    The maximum product of any two distinct numbers is 5 * 4 = 20.\n    \"\"\"\n\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n\n    return max_product\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 20\n",
        "idx_generation": 248,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n\n    Return the maximum subarray sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The maximum subarray sum is obtained by the subarray [4, -1, 2, 1], which has a sum of 6.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n\n",
        "idx_generation": 469,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum subarray sum.\n\n    Example:\n    Input: arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6 (The maximum subarray sum is [4, -1, 2, 1])\n\n    Note: The solution should have a time complexity of O(n) using Kadane's algorithm.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in arr:\n        curr_sum += num\n        if curr_sum > max_sum:\n            max_sum = curr_sum\n        if curr_sum < 0:\n            curr_sum = 0\n\n    return max_sum\n\ndef g(arr=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return (arr,)\n\nassert f(*g()) == 6\n",
        "idx_generation": 307,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with all duplicate elements removed.\n    The order of the elements in the new list should be the same as the original list.\n\n    Example:\n    nums = [2, 3, 1, 3, 4, 2]\n\n    Output:\n    [2, 3, 1, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    \n    for num in nums:\n        if num not in seen:\n            result.append(num)\n            seen.add(num)\n    \n    return result\n\ndef g() -> List[int]:\n    return [2, 3, 1, 3, 4, 2]\n\nassert f(g()) == [2, 3, 1, 4]\n",
        "idx_generation": 493,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Optional\n\nclass Node:\n    def __init__(self, val: int):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef f(root: Optional[Node]) -> List[int]:\n    \"\"\"Perform an in-order traversal of a binary tree and return the values in a list.\"\"\"\n    result = []\n    stack = []\n    curr = root\n    while curr or stack:\n        while curr:\n            stack.append(curr)\n            curr = curr.left\n        curr = stack.pop()\n        result.append(curr.val)\n        curr = curr.right\n    return result\n\ndef g():\n    root = Node(4)\n    root.left = Node(2)\n    root.right = Node(6)\n    root.left.left = Node(1)\n    root.left.right = Node(3)\n    root.right.left = Node(5)\n    root.right.right = Node(7)\n    return root\n\nassert f(g()) == [1, 2, 3, 4, 5, 6, 7]\n",
        "idx_generation": 319,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all even numbers from 1 to n (inclusive).\n\n    Args:\n    - n: A positive integer.\n\n    Returns:\n    - The sum of all even numbers from 1 to n.\n\n    Example:\n    n = 10\n\n    Output:\n    30\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n % 2 == 0:\n        return n + f(n-2)\n    else:\n        return f(n-1)\n\ndef g(n=10):\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return n\n\nassert f(g()) == 30\n",
        "idx_generation": 496,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of unique paths from the top-left corner to the bottom-right corner of a grid of size n x n. You can only move either down or right at any point in time.\n\n    Sample Input:\n    3\n\n    Sample Output:\n    6\n    \"\"\"\n\n    def unique_paths_helper(i, j, n, memo):\n        if i == n - 1 or j == n - 1:\n            return 1\n\n        if memo[i][j] != -1:\n            return memo[i][j]\n\n        right = unique_paths_helper(i, j + 1, n, memo)\n        down = unique_paths_helper(i + 1, j, n, memo)\n\n        memo[i][j] = right + down\n        return memo[i][j]\n\n    memo = [[-1] * n for _ in range(n)]\n    return unique_paths_helper(0, 0, n, memo)\n\ndef g():\n    return 3\n\nassert f(g()) == 6\n\n",
        "idx_generation": 196,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of words in the string while keeping the words themselves unchanged.\n\n    Example:\n    s = \"Hello World\"\n\n    Output:\n    \"World Hello\"\n\n    Explanation:\n    The words in the string are \"Hello\" and \"World\". Reversing the order of the words gives \"World Hello\".\n\n    Hint: Split the string into words, reverse the order of the words, and join them back into a string.\n    \"\"\"\n    words = s.split()\n    words.reverse()\n    return \" \".join(words)\n\ndef g():\n    s = \"Hello World\"\n    return s\n\nassert f(g()) == \"World Hello\"\n",
        "idx_generation": 363,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str]) -> str:\n    \"\"\"\n    Given a list of strings, find the longest common prefix among them.\n    \"\"\"\n    if not strings:\n        return \"\"\n    prefix = strings[0]\n    for i in range(1, len(strings)):\n        while strings[i].find(prefix) != 0:\n            prefix = prefix[:-1]\n            if not prefix:\n                return \"\"\n    return prefix\n\ndef g():\n    strings = [\"flower\", \"flow\", \"flight\"]\n    return strings\n\nassert f(g()) == \"fl\"\n",
        "idx_generation": 285,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two numbers in the list.\n\n    Example:\n    f([3, 10, 5, 25, 2, 8]) returns 28, as the maximum XOR value is obtained by 5 ^ 25 = 28.\n\n    Note:\n    - The input list can contain duplicate numbers.\n    \"\"\"\n\n    max_xor = 0\n    n = len(nums)\n\n    for i in range(n):\n        for j in range(i+1, n):\n            xor = nums[i] ^ nums[j]\n            if xor > max_xor:\n                max_xor = xor\n\n    return max_xor\n\n\ndef g(nums: List[int] = [3, 10, 5, 25, 2, 8]) -> List[int]:\n    \"\"\"\n    Generate a list of positive integers.\n\n    Example:\n    g() returns [3, 10, 5, 25, 2, 8].\n\n    Note:\n    - The input list can contain duplicate numbers.\n    \"\"\"\n\n    return nums\n\n\nassert f(g()) == 28\n",
        "idx_generation": 99,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the nth Fibonacci number using matrix exponentiation.\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    matrix = [[1, 1], [1, 0]]\n    result = matrix_power(matrix, n-1)\n    \n    return result[0][0]\n\ndef matrix_power(matrix: List[List[int]], n: int) -> List[List[int]]:\n    if n == 0:\n        return [[1, 0], [0, 1]]\n    \n    if n % 2 == 0:\n        half = matrix_power(matrix, n//2)\n        return matrix_multiply(half, half)\n    else:\n        half = matrix_power(matrix, (n-1)//2)\n        return matrix_multiply(matrix_multiply(half, half), matrix)\n\ndef matrix_multiply(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]:\n    result = [[0, 0], [0, 0]]\n    \n    for i in range(2):\n        for j in range(2):\n            for k in range(2):\n                result[i][j] += matrix1[i][k] * matrix2[k][j]\n    \n    return result\n\ndef g(n=6):\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 147,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Node:\n    def __init__(self, val: int):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef f(root: Node) -> List[int]:\n    \"\"\"\n    Given the root of a binary tree, return a list of values of all the nodes in a breadth-first order.\n\n    Example:\n    Input:\n        1\n       / \\\n      2   3\n     / \\   \\\n    4   5   6\n\n    Output:\n    [1, 2, 3, 4, 5, 6]\n    \"\"\"\n    if not root:\n        return []\n    \n    queue = [root]\n    result = []\n    \n    while queue:\n        node = queue.pop(0)\n        result.append(node.val)\n        \n        if node.left:\n            queue.append(node.left)\n        if node.right:\n            queue.append(node.right)\n    \n    return result\n\ndef g():\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.right = Node(6)\n    return root\n\nassert f(g()) == [1, 2, 3, 4, 5, 6]\n",
        "idx_generation": 213,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a 2D grid of integers, return True if there is a path from the top-left cell to the bottom-right cell\n    that consists of moving only right or down. Otherwise, return False.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    def dfs(row: int, col: int) -> bool:\n        if row == rows - 1 and col == cols - 1:\n            return True\n        if row >= rows or col >= cols:\n            return False\n        if dfs(row + 1, col) or dfs(row, col + 1):\n            return True\n        return False\n    \n    return dfs(0, 0)\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == True\n",
        "idx_generation": 81,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of 'm' rows and 'n' columns, determine if it is possible to reach the bottom-right cell\n    from the top-left cell by moving only right or down.\n    Each cell in the grid contains a non-negative integer, where 0 represents an empty cell.\n\n    Example:\n    grid = [\n        [0, 1, 0],\n        [0, 0, 1],\n        [1, 0, 0]\n    ]\n\n    Output:\n    True\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[False] * n for _ in range(m)]\n    dp[0][0] = True\n\n    for i in range(1, m):\n        if grid[i][0] == 0 and dp[i - 1][0]:\n            dp[i][0] = True\n\n    for j in range(1, n):\n        if grid[0][j] == 0 and dp[0][j - 1]:\n            dp[0][j] = True\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] == 0:\n                dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n\n    return dp[m - 1][n - 1]\n\ndef g():\n    return ([\n        [0, 1, 0],\n        [0, 0, 1],\n        [1, 0, 0]\n    ],)\n\nassert f(*g()) == True\n",
        "idx_generation": 148,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the number of ways to choose k elements from a set of n elements, where the order of selection does not matter.\n\n    Args:\n    - n: The total number of elements.\n    - k: The number of elements to choose.\n\n    Returns:\n    - The number of ways to choose k elements from a set of n elements.\n    \"\"\"\n    if k == 0 or k == n:\n        return 1\n    elif k > n:\n        return 0\n    \n    return f(n-1, k-1) + f(n-1, k)\n\ndef g() -> List[int]:\n    n = 5\n    k = 3\n    return n, k\n\nassert f(*g()) == 10\n",
        "idx_generation": 172,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int, nums: List[int]) -> bool:\n    \"\"\"Check if there exists a subset of nums with sum k and size n\"\"\"\n    def subset_sum(nums, n, k):\n        if k == 0:\n            return True\n        if n == 0 and k != 0:\n            return False\n        if nums[n-1] > k:\n            return subset_sum(nums, n-1, k)\n        return subset_sum(nums, n-1, k) or subset_sum(nums, n-1, k-nums[n-1])\n    \n    return subset_sum(nums, len(nums), k) and len(nums) >= n\ndef g(n=3, k=10, nums=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]):\n    return n, k, nums\nassert f(*g())\n",
        "idx_generation": 156,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Count Pairs with Given Sum\n\n    Given a list of integers, count the number of pairs whose sum is equal to the target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    Output: 2\n\n    Explanation:\n    The pairs with sum equal to 6 are (1, 5) and (2, 4), so the count is 2.\n    \"\"\"\n    nums.sort()\n    count = 0\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            count += 1\n            left += 1\n            right -= 1\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return count\n\ndef g(nums = [1, 2, 3, 4, 5], target = 6):\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 481,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target=10) -> bool:\n    \"\"\"\n    Given a sorted array of integers, determine if there exists two numbers in the array such that their sum is equal to the target.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(target = 10):\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return arr\n\nassert f(g()) == True\n",
        "idx_generation": 331,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target in the list using binary search.\n    If the target is not found, return -1.\n\n    Sample Input:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    Sample Output:\n    2\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(nums=[1, 3, 5, 7, 9], target=5):\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 111,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums sorted in ascending order, find two numbers such that they add up to a specific target number.\n    Return the indices of the two numbers in the array, where index1 must be less than index2.\n\n    You may assume that each input would have exactly one solution and you may not use the same element twice.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    nums[0] + nums[1] = 2 + 7 = 9, so the indices are [0, 1].\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g() -> List[int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 143,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Perfect Number\n\n    A perfect number is a positive integer that is equal to the sum of its proper divisors, excluding the number itself.\n    For example, 28 is a perfect number because its proper divisors are 1, 2, 4, 7, and 14, and 1 + 2 + 4 + 7 + 14 = 28.\n\n    Given an integer n, determine if it is a perfect number.\n\n    Example:\n    n = 28\n    output: True\n    \"\"\"\n    if n <= 0:\n        return False\n\n    divisors = [1]\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n\n    return sum(divisors) == n\n\ndef g(n = 28):\n    return n\n\nassert f(g()) == True\n\n",
        "idx_generation": 334,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of distinct integers and a target value, return the index if the target is found. \n    If not, return the index where it would be if it were inserted in order.\n\n    Example:\n    nums = [1,3,5,6], target = 5\n    Output: 2\n\n    nums = [1,3,5,6], target = 2\n    Output: 1\n\n    nums = [1,3,5,6], target = 7\n    Output: 4\n\n    nums = [1,3,5,6], target = 0\n    Output: 0\n    \"\"\"\n    left, right = 0, len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left\n\ndef g() -> List:\n    nums = [1, 3, 5, 6]\n    target = 5\n    return [nums, target]\n\nassert f(*g()) == 2\n",
        "idx_generation": 252,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, count the number of distinct elements in the list.\n\n    Example:\n    nums = [1, 2, 3, 1, 2, 3, 4, 5]\n\n    Output:\n    5\n\n    Explanation:\n    There are 5 distinct elements in the list: 1, 2, 3, 4, 5.\n\n    Hint: Use a set to keep track of unique elements and return the length of the set.\n    \"\"\"\n    return len(set(nums))\n\ndef g():\n    nums = [1, 2, 3, 1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 5\n",
        "idx_generation": 363,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of perfect squares in the list.\n    \"\"\"\n    count = 0\n    for num in nums:\n        if int(num**0.5)**2 == num:\n            count += 1\n    return count\n\ndef g():\n    return [4, 9, 16, 25, 36, 49, 64]\n\nassert f(g()) == 7\n",
        "idx_generation": 297,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Find the number of ways to climb n steps.\n\n    You can climb either 1 or 2 steps at a time.\n\n    Example:\n    n = 4\n    output: 5\n\n    Explanation:\n    There are 5 different ways to climb 4 steps:\n    1. 1 -> 1 -> 1 -> 1\n    2. 1 -> 1 -> 2\n    3. 1 -> 2 -> 1\n    4. 2 -> 1 -> 1\n    5. 2 -> 2\n    \"\"\"\n    if n <= 1:\n        return n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\ndef g(n=4):\n    return n\n\nassert f(g()) == 5\n\n",
        "idx_generation": 470,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Find two numbers in the given list that add up to the target value.\n    Return the indices of the two numbers.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate the list of numbers and the target value for the puzzle.\n    \"\"\"\n    nums = [2, 7, 11, 15, 3, 6, 8]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 311,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Args:\n    - nums: A list of integers\n\n    Returns:\n    - The maximum product of any two distinct numbers in the list.\n    \"\"\"\n    n = len(nums)\n    max_product = float('-inf')\n\n    for i in range(n):\n        for j in range(i+1, n):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n\n    return max_product\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 20\n",
        "idx_generation": 496,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, reverse the order of the elements using a stack.\n    \"\"\"\n    stack = []\n    for num in nums:\n        stack.append(num)\n    \n    reversed_nums = []\n    while stack:\n        reversed_nums.append(stack.pop())\n    \n    return reversed_nums\n\ndef g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9]):\n    \"\"\"\n    Generate a list of integers such that the order of the elements is reversed after using a stack.\n    \"\"\"\n    return nums\n\nassert f(g()) == [9, 8, 7, 6, 5, 4, 3, 2, 1]\n",
        "idx_generation": 353,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target sum, return True if there exists a subset of nums that adds up to the target sum, and False otherwise.\n\n    Example:\n    nums = [2, 4, 6, 8]\n    target = 10\n\n    Output:\n    True\n\n    Explanation:\n    There exists a subset [2, 8] in nums that adds up to the target sum 10.\n    \"\"\"\n\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if nums[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n\n    return dp[n][target]\n\ndef g() -> Tuple[List[int], int]:\n    return ([2, 4, 6, 8], 10)\n\nassert f(*g()) == True\n",
        "idx_generation": 497,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix, find the number of unique paths from the top-left cell to the bottom-right cell.\n    You can only move down or right in the matrix.\n\n    Example:\n    matrix = [[1, 1, 1],\n              [1, 2, 1],\n              [1, 1, 1]]\n\n    Output:\n    6\n\n    Explanation:\n    There are 6 unique paths from the top-left cell to the bottom-right cell:\n    1 -> 1 -> 1 -> 2 -> 1 -> 1 -> 1\n    1 -> 1 -> 2 -> 1 -> 1 -> 1 -> 1\n    1 -> 2 -> 1 -> 1 -> 1 -> 1 -> 1\n    2 -> 1 -> 1 -> 1 -> 1 -> 1 -> 1\n    1 -> 1 -> 1 -> 1 -> 2 -> 1 -> 1\n    1 -> 1 -> 1 -> 1 -> 1 -> 1 -> 2\n\n    Hint: Use dynamic programming to build a grid of counts for each cell, starting from the top-left cell.\n    \"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n\n    # Create a grid to store the counts for each cell\n    counts = [[0] * n for _ in range(m)]\n\n    # Initialize the counts for the top row and left column\n    for i in range(m):\n        counts[i][0] = 1\n    for j in range(n):\n        counts[0][j] = 1\n\n    # Calculate the counts for each cell\n    for i in range(1, m):\n        for j in range(1, n):\n            counts[i][j] = counts[i-1][j] + counts[i][j-1]\n\n    # Return the count of paths to the bottom-right cell\n    return counts[m-1][n-1]\n\ndef g():\n    matrix = [[1, 1, 1],\n              [1, 2, 1],\n              [1, 1, 1]]\n    return matrix\n\nassert f(g()) == 6\n",
        "idx_generation": 203,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> str:\n    \"\"\"\n    Given a string, convert all lowercase letters to uppercase and all uppercase letters to lowercase.\n    \"\"\"\n    result = \"\"\n    for char in string:\n        if char.islower():\n            result += char.upper()\n        else:\n            result += char.lower()\n    return result\n\ndef g():\n    return \"Hello World\"\n\nassert f(g()) == \"hELLO wORLD\"\n",
        "idx_generation": 367,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a valid palindrome after removing at most one character.\n\n    Example:\n    s = \"raceacar\"\n\n    Output:\n    True (remove 'e' to get \"racecar\")\n    \"\"\"\n    def is_palindrome(s: str, left: int, right: int, deleted: int) -> bool:\n        while left < right:\n            if s[left] != s[right]:\n                if deleted == 1:\n                    return False\n                return is_palindrome(s, left+1, right, deleted+1) or is_palindrome(s, left, right-1, deleted+1)\n            left += 1\n            right -= 1\n        return True\n    \n    return is_palindrome(s, 0, len(s)-1, 0)\n\ndef g() -> str:\n    return \"raceacar\"\n\nassert f(g()) == True\n",
        "idx_generation": 291,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Check if the kth bit of n is set (1) or not (0) using bitwise operations.\"\"\"\n    return n & (1 << (k - 1)) != 0\n\ndef g(n: int, k: int) -> int:\n    \"\"\"Set the kth bit of n to 1 using bitwise operations.\"\"\"\n    return n | (1 << (k - 1))\n\nassert f(g(5, 3), 3)\n",
        "idx_generation": 101,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the factorial of the given non-negative integer.\n\n    Example:\n    n = 5\n    Output: 120\n    \"\"\"\n    assert n >= 0\n    if n == 0:\n        return 1\n    return n * f(n-1)\n\ndef g():\n    return 5\n\nassert f(g()) == 120\n",
        "idx_generation": 157,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Dict\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency list, determine if there is a path from a given start node to a given end node.\n    Return True if a path exists, otherwise return False.\n    \"\"\"\n    visited = set()\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n        visited.add(node)\n\n        if node == end:\n            return True\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n\n    return False\n\ndef g():\n    return {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D'],\n        'D': ['E'],\n        'E': []\n    }, 'A', 'E'\n\nassert f(*g()) == True\n",
        "idx_generation": 228,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, path: List[int] = []) -> bool:\n    \"\"\"\n    Given a directed graph and two vertices, determine if there exists a path from the start vertex to the\n    end vertex.\n\n    The graph is represented as an adjacency list, where graph[i] is a list of vertices that are adjacent to vertex i.\n\n    Example:\n    graph = [[1, 2], [3], [4], [], []]\n    start = 0\n    end = 4\n\n    Output:\n    True\n\n    Explanation:\n    There exists a path from vertex 0 to vertex 4: 0 -> 1 -> 3 -> 4.\n\n    Hint: Consider using depth-first search (DFS) or breadth-first search (BFS) to traverse the graph and check for a path.\n    \"\"\"\n\n    if start == end:\n        return True\n\n    visited = set()\n    stack = [start]\n\n    while stack:\n        vertex = stack.pop()\n\n        if vertex == end:\n            return True\n\n        if vertex not in visited:\n            visited.add(vertex)\n            stack.extend(graph[vertex])\n\n    return False\n\ndef g(graph=[[1, 2], [3], [4], [], []], start=0, end=4):\n    return graph, start, end\n\nassert f(*g())\n",
        "idx_generation": 81,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency list graph, determine if there is a path from start to end using breadth-first search.\n    \"\"\"\n\n    queue = deque([start])\n    visited = set()\n\n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node in visited:\n            continue\n        visited.add(node)\n        if node in graph:\n            queue.extend(graph[node])\n\n    return False\n\ndef g():\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['D'],\n        'C': ['E'],\n        'D': [],\n        'E': ['F'],\n        'F': []\n    }\n    start = 'A'\n    end = 'F'\n    return graph, start, end\n\nassert f(*g()) == True\n\n",
        "idx_generation": 166,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest palindrome that can be formed using the characters in s.\n\n    Example:\n    s = \"aabbc\"\n\n    Output:\n    5\n\n    Explanation:\n    The longest palindrome that can be formed using the characters in s is \"abcba\" or \"bacab\", both of which have length 5.\n    \"\"\"\n    char_count = {}\n\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    length = 0\n    odd_count = 0\n\n    for count in char_count.values():\n        if count % 2 == 0:\n            length += count\n        else:\n            length += count - 1\n            odd_count = 1\n\n    return length + odd_count\n\ndef g(s=\"aabbc\"):\n    return s\n\nassert f(g()) == 5\n",
        "idx_generation": 177,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of distinct combinations of numbers that add up to n.\n    \"\"\"\n    def count_combinations(n: int, index: int, coins: List[int]) -> int:\n        if n == 0:\n            return 1\n        if n < 0 or index >= len(coins):\n            return 0\n        \n        count1 = count_combinations(n - coins[index], index, coins)  # include current coin\n        count2 = count_combinations(n, index + 1, coins)  # exclude current coin\n        \n        return count1 + count2\n    \n    coins = [1, 2, 5]\n    return count_combinations(n, 0, coins)\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == 4\n",
        "idx_generation": 160,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n    If the target value is not in the list, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target: int = 6):\n    return nums, target\n\nassert f(*g()) == 5\n",
        "idx_generation": 482,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target number, determine if there are three integers in nums that sum up to the target.\n    \"\"\"\n    for i in range(len(nums)-2):\n        left = i + 1\n        right = len(nums) - 1\n        while left < right:\n            curr_sum = nums[i] + nums[left] + nums[right]\n            if curr_sum == target:\n                return True\n            elif curr_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 9\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 335,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Check if there exists a pair of numbers in the given list that add up to the target value.\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5], target=9):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 114,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Reverse the order of words in the given string.\n    \"\"\"\n    words = s.split()\n    return ' '.join(words[::-1])\n\ndef g() -> str:\n    return \"Hello World\"\n\nassert f(g()) == \"World Hello\"\n",
        "idx_generation": 156,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    60\n\n    Explanation:\n    The maximum product is achieved by multiplying 4 * 5 * 3 = 60.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return (nums,)\n\nassert f(*g()) == 60\n\n",
        "idx_generation": 337,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of valid parentheses sequences of length 2n.\n    A sequence is valid if and only if it consists of opening and closing parentheses such that every opening parenthesis has a corresponding closing parenthesis and vice versa.\n    \"\"\"\n    if n == 0:\n        return 1\n    if n == 1:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    \n    for i in range(2, n + 1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i - j - 1]\n    \n    return dp[n]\n\ndef g():\n    n = 3\n    return n\n\nassert f(g()) == 5\n",
        "idx_generation": 253,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int, words: List[str]) -> List[int]:\n    \"\"\"Find the indices of the k most frequent strings among the given words\"\"\"\n    wordCounts = {}\n    for word in words:\n        wordCounts[word] = wordCounts.get(word, 0) + 1\n    sortedWords = sorted(wordCounts.keys(), key=lambda x: (-wordCounts[x], x))\n    return [i for i, word in enumerate(sortedWords) if i < k]\n\ndef g(n=5, k=2, words=[\"apple\", \"banana\", \"apple\", \"orange\", \"banana\"]):\n    return n, k, words\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 364,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n\n    Sample Output:\n    20\n\n    Explanation:\n    The maximum product of two distinct numbers is 5 * 4 = 20.\n    \"\"\"\n    max_product = float('-inf')\n    n = len(nums)\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            max_product = max(max_product, nums[i] * nums[j])\n    \n    return max_product\n\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 20\n\n",
        "idx_generation": 317,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of numbers, find all the prime numbers in the list.\n    Return a list containing the prime numbers.\n\n    Example:\n    numbers = [2, 3, 4, 5, 6, 7, 8, 9]\n\n    Output:\n    [2, 3, 5, 7]\n\n    Hint: Iterate through the list and check if each number is prime.\n    \"\"\"\n\n    def is_prime(number):\n        if number < 2:\n            return False\n        \n        for i in range(2, int(number**0.5) + 1):\n            if number % i == 0:\n                return False\n        \n        return True\n\n    prime_numbers = []\n\n    for number in numbers:\n        if is_prime(number):\n            prime_numbers.append(number)\n    \n    return prime_numbers\n\ndef g() -> List[int]:\n    \"\"\"\n    Return a list of numbers.\n    \"\"\"\n    return [2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g()) == [2, 3, 5, 7]\n\n",
        "idx_generation": 472,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n    \"\"\"\n    def max_subarray_sum(nums, left, right):\n        if left == right:\n            return nums[left]\n        mid = (left + right) // 2\n        left_sum = max_subarray_sum(nums, left, mid)\n        right_sum = max_subarray_sum(nums, mid + 1, right)\n        cross_sum = cross_max_subarray_sum(nums, left, mid, right)\n        return max(left_sum, right_sum, cross_sum)\n    \n    def cross_max_subarray_sum(nums, left, mid, right):\n        left_sum = float('-inf')\n        curr_sum = 0\n        for i in range(mid, left - 1, -1):\n            curr_sum += nums[i]\n            left_sum = max(left_sum, curr_sum)\n        \n        right_sum = float('-inf')\n        curr_sum = 0\n        for i in range(mid + 1, right + 1):\n            curr_sum += nums[i]\n            right_sum = max(right_sum, curr_sum)\n        \n        return left_sum + right_sum\n    \n    return max_subarray_sum(nums, 0, len(nums) - 1)\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 312,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer 'n', determine if it is a prime number.\n\n    Example:\n    n = 17\n    \n    Output:\n    True\n    \"\"\"\n    if n <= 1:\n        return False\n    \n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    \n    return True\n\ndef g() -> int:\n    return 17\n\nassert f(g()) == True\n\n",
        "idx_generation": 497,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string containing only characters '(', ')', '{', '}', '[' and ']',\n    determine if the input string is valid.\n\n    An input string is valid if:\n    1. Open brackets must be closed by the same type of brackets.\n    2. Open brackets must be closed in the correct order.\n\n    Return 1 if the string is valid, 0 otherwise.\n\n    Example:\n    Input: s = \"(([]))\"\n    Output: 1\n\n    Explanation:\n    The input string contains only valid brackets, so the output is 1.\n    \"\"\"\n    stack = []\n    brackets = {\n        ')': '(',\n        '}': '{',\n        ']': '['\n    }\n\n    for char in s:\n        if char in brackets.values():\n            stack.append(char)\n        elif char in brackets:\n            if not stack or brackets[char] != stack.pop():\n                return 0\n\n    return 1 if not stack else 0\n\ndef g(s = \"(([]))\"):\n    return s\n\nassert f(g())\n",
        "idx_generation": 377,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the factorial of n.\n\n    Example:\n    n = 5\n\n    Output:\n    120\n\n    Explanation:\n    The factorial of 5 is 5 * 4 * 3 * 2 * 1 = 120.\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n    \n    return n * f(n-1)\n\ndef g():\n    return 5\n\nassert f(g()) == 120\n",
        "idx_generation": 368,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Count the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\n    \"\"\"\n\n    def dfs(row, col):\n        if row == n - 1 and col == n - 1:\n            return 1\n        if row >= n or col >= n:\n            return 0\n        return dfs(row + 1, col) + dfs(row, col + 1)\n\n    return dfs(0, 0)\n\ndef g():\n    n = 3\n    return n\n\nassert f(g()) == 6\n",
        "idx_generation": 207,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n    The longest substring without repeating characters is \"abc\", which has a length of 3.\n\n    Constraints:\n    - The input string s will consist of lowercase English letters only.\n    \"\"\"\n    start = 0\n    max_length = 0\n    char_map = {}\n    \n    for i in range(len(s)):\n        if s[i] in char_map and start <= char_map[s[i]]:\n            start = char_map[s[i]] + 1\n        else:\n            max_length = max(max_length, i - start + 1)\n        \n        char_map[s[i]] = i\n    \n    return max_length\n\ndef g():\n    s = \"abcabcbb\"\n    return s\n\nassert f(g()) == 3\n",
        "idx_generation": 369,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, check if it is a palindrome after removing at most one character from it.\n\n    Example:\n    s = \"racecar\"\n    output: True\n\n    Explanation:\n    The string \"racecar\" is a palindrome, so the function returns True.\n\n    Constraints:\n    - The input string may contain uppercase and lowercase letters.\n    \"\"\"\n    def is_palindrome(s, left, right, removed):\n        while left < right:\n            if s[left] != s[right]:\n                if removed:\n                    return False\n                else:\n                    return is_palindrome(s, left+1, right, True) or is_palindrome(s, left, right-1, True)\n            left += 1\n            right -= 1\n        return True\n    \n    return is_palindrome(s, 0, len(s)-1, False)\n\ndef g(s=\"racecar\"):\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 294,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"\n    Count the number of set bits (bits with value 1) in the binary representation of the given number.\n    \"\"\"\n    count = 0\n    while num > 0:\n        count += num & 1\n        num >>= 1\n    return count\n\ndef g(num=10):\n    return num\n\nassert f(g()) == 2\n",
        "idx_generation": 103,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, check if it is a prime number.\n\n    Return True if n is prime, False otherwise.\n\n    Example:\n    n = 7\n\n    Output:\n    True\n\n    Explanation:\n    The number 7 is a prime number.\n    \"\"\"\n\n    if n <= 1:\n        return False\n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n\n    return True\n\ndef g(n: int) -> int:\n    \"\"\"\n    Generate a prime number greater than or equal to n.\n    \"\"\"\n    while True:\n        if f(n):\n            return n\n        n += 1\n\nassert f(g(7)) == True\n\n",
        "idx_generation": 166,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Node:\n    def __init__(self, val: int):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef f(root: Node) -> List[int]:\n    \"\"\"Perform a level order traversal on a binary tree and return the values in a list.\"\"\"\n    if not root:\n        return []\n    \n    queue = [root]\n    result = []\n    \n    while queue:\n        node = queue.pop(0)\n        result.append(node.val)\n        \n        if node.left:\n            queue.append(node.left)\n        if node.right:\n            queue.append(node.right)\n    \n    return result\n\ndef g():\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n\n    return root\n\nassert f(g()) == [1, 2, 3, 4, 5, 6, 7]\n",
        "idx_generation": 234,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    Given a number of nodes 'n' and a list of edges 'edges', find the number of connected components in the graph.\n\n    Example:\n    n = 5\n    edges = [[0, 1], [1, 2], [3, 4]]\n\n    Output:\n    2 (since there are two connected components: {0, 1, 2} and {3, 4})\n\n    \"\"\"\n\n    def dfs(node: int, visited: List[bool], graph: List[List[int]]):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, graph)\n\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = [False] * n\n    components = 0\n\n    for i in range(n):\n        if not visited[i]:\n            dfs(i, visited, graph)\n            components += 1\n\n    return components\n\ndef g():\n    return 5, [[0, 1], [1, 2], [3, 4]]\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 84,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: dict) -> bool:\n    \"\"\"\n    Given a directed graph, determine if there is a cycle in the graph.\n\n    Sample Input:\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D'],\n        'D': ['E'],\n        'E': ['A']\n    }\n\n    Sample Output:\n    True\n    \"\"\"\n    visited = set()\n    stack = set()\n\n    def dfs(node):\n        visited.add(node)\n        stack.add(node)\n\n        for neighbor in graph.get(node, []):\n            if neighbor in stack:\n                return True\n            if neighbor not in visited and dfs(neighbor):\n                return True\n\n        stack.remove(node)\n        return False\n\n    for node in graph:\n        if node not in visited and dfs(node):\n            return True\n\n    return False\n\ndef g(graph={'A': ['B', 'C'], 'B': ['C', 'D'], 'C': ['D'], 'D': ['E'], 'E': ['A']}):\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 172,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of distinct pairs (a, b) such that a + b is divisible by 3.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n\n    Output:\n    4\n\n    Explanation:\n    The distinct pairs (1, 2), (2, 4), (1, 5), and (4, 5) have a sum that is divisible by 3.\n\n    Hint: Use counting and combinatorial analysis to determine the number of distinct pairs.\n    \"\"\"\n    count = 0\n    freq = [0] * 3\n    for num in arr:\n        freq[num % 3] += 1\n    count += (freq[0] * (freq[0] - 1)) // 2  # Count pairs with numbers divisible by 3\n    count += freq[1] * freq[2]  # Count pairs with numbers having remainder 1 and 2\n    return count\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    return arr\n\nassert f(g()) == 4\n",
        "idx_generation": 184,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums, return all possible permutations of its elements.\n\n    Example:\n    nums = [1, 2, 3]\n\n    Output:\n    [\n        [1, 2, 3],\n        [1, 3, 2],\n        [2, 1, 3],\n        [2, 3, 1],\n        [3, 1, 2],\n        [3, 2, 1]\n    ]\n    \"\"\"\n\n    def backtrack(nums, path, result):\n        if not nums:\n            result.append(path)\n            return\n        for i in range(len(nums)):\n            backtrack(nums[:i] + nums[i + 1:], path + [nums[i]], result)\n\n    result = []\n    backtrack(nums, [], result)\n    return result\n\ndef g() -> List[int]:\n    return [1, 2, 3]\n\nassert f(g()) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n",
        "idx_generation": 161,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list using the bubble sort algorithm.\n\n    Example:\n    nums = [5, 3, 8, 2, 1]\n\n    Output:\n    [1, 2, 3, 5, 8]\n\n    Explanation:\n    The bubble sort algorithm repeatedly swaps adjacent elements if they are in the wrong order.\n    In this case, the list is sorted in ascending order.\n\n    Hint: Implement the bubble sort algorithm by repeatedly iterating through the list and swapping adjacent elements if necessary.\n    \"\"\"\n\n    n = len(nums)\n\n    for i in range(n-1):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n\n    return nums\n\ndef g():\n    nums = [5, 3, 8, 2, 1]\n    return nums\n\nassert f(g()) == [1, 2, 3, 5, 8]\n\n",
        "idx_generation": 484,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nimport heapq\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return the k smallest elements in ascending order.\n\n    Example:\n    nums = [4, 2, 7, 1, 5]\n    k = 3\n\n    The k smallest elements are [1, 2, 4], so the output should be [1, 2, 4].\n    \"\"\"\n    heap = []\n    for num in nums:\n        heapq.heappush(heap, num)\n    \n    result = []\n    for _ in range(k):\n        result.append(heapq.heappop(heap))\n    \n    return result\n\ndef g():\n    nums = [4, 2, 7, 1, 5]\n    k = 3\n    return nums, k\n\nassert f(*g()) == [1, 2, 4]\n",
        "idx_generation": 345,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a 2D grid of integers, determine if it forms a valid Sudoku solution.\n\n    Sample Input:\n    grid = [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]\n\n    Sample Output:\n    True\n    \"\"\"\n    for i in range(9):\n        row = [False] * 9\n        col = [False] * 9\n        for j in range(9):\n            if grid[i][j] != 0:\n                if row[grid[i][j] - 1]:\n                    return False\n                row[grid[i][j] - 1] = True\n            if grid[j][i] != 0:\n                if col[grid[j][i] - 1]:\n                    return False\n                col[grid[j][i] - 1] = True\n    for i in range(3):\n        for j in range(3):\n            subgrid = [False] * 9\n            for k in range(3):\n                for l in range(3):\n                    num = grid[i * 3 + k][j * 3 + l]\n                    if num != 0:\n                        if subgrid[num - 1]:\n                            return False\n                        subgrid[num - 1] = True\n    return True\n\ndef g(grid = [\n    [5, 3, 0, 0, 7, 0, 0, 0, 0],\n    [6, 0, 0, 1, 9, 5, 0, 0, 0],\n    [0, 9, 8, 0, 0, 0, 0, 6, 0],\n    [8, 0, 0, 0, 6, 0, 0, 0, 3],\n    [4, 0, 0, 8, 0, 3, 0, 0, 1],\n    [7, 0, 0, 0, 2, 0, 0, 0, 6],\n    [0, 6, 0, 0, 0, 0, 2, 8, 0],\n    [0, 0, 0, 4, 1, 9, 0, 0, 5],\n    [0, 0, 0, 0, 8, 0, 0, 7, 9]\n]):\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 115,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return the list of words sorted based on the length of each word in ascending order.\n    If two words have the same length, sort them lexicographically.\n\n    Example:\n    words = [\"apple\", \"banana\", \"cat\", \"dog\", \"elephant\"]\n\n    Output:\n    [\"cat\", \"dog\", \"apple\", \"banana\", \"elephant\"]\n\n    Hint: Use the sort() method with a custom key function to sort the words based on length and then lexicographically.\n    \"\"\"\n\n    return sorted(words, key=lambda x: (len(x), x))\n\ndef g():\n    return [\"apple\", \"banana\", \"cat\", \"dog\", \"elephant\"]\n\nassert f(g()) == [\"cat\", \"dog\", \"apple\", \"banana\", \"elephant\"]\n",
        "idx_generation": 159,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum product of any three numbers from the list.\n\n    Return the maximum product.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    24\n\n    Explanation:\n    The maximum product can be obtained by multiplying 2, 3, and 4 (2 * 3 * 4 = 24).\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n\n    return max(nums[0] * nums[1] * nums[n - 1], nums[n - 3] * nums[n - 2] * nums[n - 1])\n\ndef g(nums=[1, 2, 3, 4]):\n    \"\"\"\n    Generate a list of integers 'nums'.\n    \"\"\"\n    return nums\n\nassert f(g()) == 24\n",
        "idx_generation": 397,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target number, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the list.\n\n    Sample Input:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Sample Output:\n    [0, 1]\n    \"\"\"\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    return []\n\ndef g() -> List[int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return (nums, target)\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 264,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the number of distinct prime factors of n.\n\n    Example:\n    n = 24\n\n    Output:\n    2 (since 24 has two distinct prime factors: 2 and 3)\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    factors = set()\n    for i in range(2, n+1):\n        if n % i == 0 and is_prime(i):\n            factors.add(i)\n    \n    return len(factors)\n\ndef g(n=24):\n    return n\n\nassert f(g()) == 2\n\n",
        "idx_generation": 325,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of trailing zeros in n!.\n\n    Example:\n    n = 10\n\n    Output:\n    2\n\n    Explanation:\n    10! = 3628800, which has 2 trailing zeros.\n    \"\"\"\n\n    count = 0\n    i = 5\n\n    while n // i >= 1:\n        count += n // i\n        i *= 5\n\n    return count\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    return 10\n\nassert f(g()) == 2\n\n",
        "idx_generation": 480,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15], target = 9\n\n    Output:\n    [0, 1] (nums[0] + nums[1] = 2 + 7 = 9)\n    \"\"\"\n    complement = {}\n    for i, num in enumerate(nums):\n        if num in complement:\n            return [complement[num], i]\n        else:\n            complement[target - num] = i\n    return []\n\ndef g(nums: List[int] = [2, 7, 11, 15], target: int = 9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 349,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the product of all the elements in the list.\n\n    Args:\n    - nums: The input list of integers.\n\n    Returns:\n    - The product of all the elements in the list.\n    \"\"\"\n    product = 1\n\n    for num in nums:\n        product *= num\n\n    return product\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g()) == 120\n",
        "idx_generation": 497,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find the next greater element for each element in the list.\n    The next greater element for an element x is the first greater element to its right, or -1 if there is no such element.\n\n    Sample Input:\n    nums = [4, 5, 2, 25]\n\n    Sample Output:\n    [5, 25, 25, -1]\n    Explanation: The next greater element for 4 is 5, for 5 is 25, for 2 is 25, and there is no greater element for 25.\n\n    \"\"\"\n    stack = []\n    result = [-1] * len(nums)\n    for i in range(len(nums)-1, -1, -1):\n        while stack and nums[i] >= stack[-1]:\n            stack.pop()\n        if stack:\n            result[i] = stack[-1]\n        stack.append(nums[i])\n    return result\n\ndef g() -> List[int]:\n    nums = [4, 5, 2, 25]\n    return nums\n\nassert f(g()) == [5, 25, 25, -1]\n\n",
        "idx_generation": 378,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Find the maximum sum of a subarray in a given array that is less than or equal to the target value.\n    \"\"\"\n    def dp(nums, target):\n        if target <= 0:\n            return 0\n        if not nums:\n            return float('-inf')\n        if nums[0] > target:\n            return dp(nums[1:], target)\n        return max(nums[0] + dp(nums[1:], target - nums[0]), dp(nums[1:], target))\n    \n    return dp(nums, target)\n\ndef g(nums: List[int], target: int) -> Tuple[List[int], int]:\n    \"\"\"\n    Return the array and target value to find the maximum sum of a subarray.\n    \"\"\"\n    return nums, target\n\nassert f(*g([1, 2, 3, 4, 5], 9)) == 9\n",
        "idx_generation": 370,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Count the number of unique paths from the top-left corner to the bottom-right corner of a grid of size n x m.\n    You can only move down or right.\n\n    Example:\n    n = 3, m = 3\n    output: 6\n\n    Explanation:\n    The grid represents a 3x3 matrix. There are 6 unique paths from the top-left corner to the bottom-right corner:\n    1. Down, Down, Right\n    2. Down, Right, Down\n    3. Right, Down, Down\n    4. Right, Right, Down\n    5. Right, Down, Right\n    6. Down, Right, Right\n    \"\"\"\n    dp = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n        dp[i][0] = 1\n\n    for j in range(m):\n        dp[0][j] = 1\n\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[n-1][m-1]\n\ndef g(n: int = 3, m: int = 3) -> List[int]:\n    \"\"\"\n    Generate the dimensions of a grid for the function f.\n    \"\"\"\n    return [n, m]\n\nassert f(*g()) == 6\n\n",
        "idx_generation": 221,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Reverse the order of words in a given string.\n    \"\"\"\n    words = s.split()\n    return ' '.join(words[::-1])\n\ndef g(s: str) -> str:\n    \"\"\"\n    Return the string to reverse the order of words.\n    \"\"\"\n    return s\n\nassert f(g(\"Hello World\")) == \"World Hello\"\n",
        "idx_generation": 370,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, wordDict: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a dictionary of words wordDict, determine if s can be segmented into a space-separated\n    sequence of one or more dictionary words.\n\n    Example:\n    s = \"leetcode\"\n    wordDict = [\"leet\", \"code\"]\n\n    Output:\n    True\n\n    Explanation:\n    \"leetcode\" can be segmented into \"leet\" and \"code\".\n    \"\"\"\n\n    def word_break(s: str, wordDict: List[str], memo: Dict[str, bool]) -> bool:\n        if s in memo:\n            return memo[s]\n\n        if s in wordDict:\n            return True\n\n        for i in range(1, len(s)):\n            prefix = s[:i]\n            if prefix in wordDict and word_break(s[i:], wordDict, memo):\n                memo[s] = True\n                return True\n\n        memo[s] = False\n        return False\n\n    memo = {}\n    return word_break(s, wordDict, memo)\n\ndef g() -> Tuple[str, List[str]]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    return \"leetcode\", [\"leet\", \"code\"]\n\nassert f(*g()) == True\n",
        "idx_generation": 294,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(num1: int, num2: int) -> int:\n    \"\"\"\n    Given two integers num1 and num2, return the result of performing the bitwise AND operation between num1 and num2.\n\n    Example:\n    num1 = 5\n    num2 = 7\n\n    Output:\n    5\n\n    Explanation:\n    The binary representation of 5 is 101 and the binary representation of 7 is 111. Performing the bitwise AND\n    operation between 101 and 111 results in 101, which is equal to 5 in decimal.\n    \"\"\"\n\n    return num1 & num2\n\n\ndef g(num1=5, num2=7):\n    return num1, num2\n\n\nassert f(*g()) == 5\n",
        "idx_generation": 107,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Determine if there exists a subset of the given list of numbers whose sum is divisible by 9.\n    \"\"\"\n    total = sum(nums)\n    if total % 9 != 0:\n        return False\n    target = total // 9\n    dp = [False] * (target + 1)\n    dp[0] = True\n\n    for num in nums:\n        for i in range(target, num - 1, -1):\n            dp[i] = dp[i] or dp[i - num]\n\n    return dp[target]\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g()) == True\n",
        "idx_generation": 168,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given a graph, check if it is a connected graph.\n\n    Sample Input:\n    graph = [[0, 1, 1, 0],\n             [1, 0, 0, 1],\n             [1, 0, 0, 1],\n             [0, 1, 1, 0]]\n\n    Sample Output:\n    True\n    \"\"\"\n    visited = [False] * len(graph)\n    stack = [0]\n    visited[0] = True\n\n    while stack:\n        node = stack.pop()\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                stack.append(neighbor)\n                visited[neighbor] = True\n\n    return all(visited)\n\ndef g():\n    graph = [[0, 1, 1, 0],\n             [1, 0, 0, 1],\n             [1, 0, 0, 1],\n             [0, 1, 1, 0]]\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 242,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode, target: int) -> bool:\n    \"\"\"Check if a target value exists in a binary tree using depth-first search.\"\"\"\n    if root is None:\n        return False\n    \n    if root.val == target:\n        return True\n    \n    return f(root.left, target) or f(root.right, target)\n\ndef g(root: TreeNode, target: int) -> TreeNode:\n    return root, target\n\n# Example usage\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3)\nroot.left.left = TreeNode(4)\nroot.left.right = TreeNode(5)\n\nassert f(*g(root, 5))\n",
        "idx_generation": 86,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, target: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, use depth-first search to determine if there is a path from a start node to a target node.\n    \"\"\"\n    def dfs(node):\n        visited[node] = True\n        if node == target:\n            return True\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n        return False\n    \n    visited = [False] * len(graph)\n    return dfs(start)\n\ndef g() -> Tuple[List[List[int]], int, int]:\n    graph = [[0, 1, 1, 0],\n             [0, 0, 1, 0],\n             [0, 0, 0, 1],\n             [0, 0, 0, 0]]\n    return (graph, 0, 3)\n\nassert f(*g()) == True\n",
        "idx_generation": 174,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str], target: str) -> int:\n    \"\"\"\n    Given a list of strings and a target string, count the number of strings in the list that are anagrams of the target string.\n\n    An anagram is a word or phrase formed by rearranging the letters of a different word or phrase. For example, the word \"listen\" is an anagram of \"silent\".\n\n    Example:\n    strings = [\"listen\", \"silent\", \"hello\", \"world\"]\n    target = \"silent\"\n\n    Output:\n    2\n\n    Explanation:\n    The anagrams of \"silent\" in the list are \"listen\" and \"silent\".\n\n    Hint: Use counting and combinatorics to solve this problem.\n    \"\"\"\n\n    def char_count(word: str) -> dict:\n        count = {}\n        for char in word:\n            count[char] = count.get(char, 0) + 1\n        return count\n\n    target_count = char_count(target)\n    result = 0\n\n    for string in strings:\n        if char_count(string) == target_count:\n            result += 1\n\n    return result\n\ndef g(strings=[\"listen\", \"silent\", \"hello\", \"world\"], target=\"silent\"):\n    return strings, target\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 199,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int, arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of combinations of size k that can be formed from the list.\n\n    Args:\n    - n: The number of elements in the list.\n    - k: The size of the combinations.\n    - arr: A list of integers.\n\n    Returns:\n    - The number of combinations of size k.\n    \"\"\"\n    def count_combinations(n, k):\n        if k == 0 or k == n:\n            return 1\n        else:\n            return count_combinations(n - 1, k - 1) + count_combinations(n - 1, k)\n\n    return count_combinations(n, k)\n\ndef g():\n    n = 5\n    k = 2\n    arr = [1, 2, 3, 4, 5]\n    return n, k, arr\n\nassert f(*g()) == 10\n\n",
        "idx_generation": 169,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the median of the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    3 (since the median of the list is 3)\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    if n % 2 == 0:\n        return (nums[n//2] + nums[n//2 - 1]) / 2\n    else:\n        return nums[n//2]\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 3\n",
        "idx_generation": 484,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two elements in the list.\n    Return the maximum XOR value.\n    \"\"\"\n    max_xor = 0\n\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            xor = arr[i] ^ arr[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor\n\ndef g(arr = [4, 6, 2, 8, 10]):\n    \"\"\"\n    Return the input array.\n    \"\"\"\n    return arr\n\nassert f(g()) == 14\n\n",
        "idx_generation": 346,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target element.\n    If the target element is not found, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output:\n    2\n\n    Explanation:\n    The target element 5 is found at index 2 in the list.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(nums=[1, 3, 5, 7, 9], target=5):\n    return nums, target\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 119,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> str:\n    \"\"\"\n    Given a list of words, return the longest common prefix among them.\n    If there is no common prefix, return an empty string.\n    \"\"\"\n    if not words:\n        return \"\"\n    min_len = min(len(word) for word in words)\n    low, high = 0, min_len\n    while low < high:\n        mid = (low + high + 1) // 2\n        if is_common_prefix(words, mid):\n            low = mid\n        else:\n            high = mid - 1\n    return words[0][:low]\n\ndef is_common_prefix(words, length):\n    prefix = words[0][:length]\n    for word in words:\n        if not word.startswith(prefix):\n            return False\n    return True\n\ndef g():\n    return [\"flower\", \"flow\", \"flight\"]\n\nassert f(g()) == \"fl\"\n",
        "idx_generation": 168,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Args:\n    - nums: A list of integers\n\n    Returns:\n    - The maximum product of any three numbers in the list\n\n    Example:\n    nums = [1, 2, 3, 4]\n    The maximum product of any three numbers is 2 * 3 * 4 = 24, so the output should be 24.\n    \"\"\"\n\n    nums.sort()\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\n\ndef g():\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == 24\n\n",
        "idx_generation": 397,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, find the index of the target in the list using binary search. If the target is not found, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    output: 2\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(nums=[1, 3, 5, 7, 9], target=5):\n    return nums, target\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 268,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the sum of all positive integers less than or equal to n that are divisible by either 3 or 5.\n\n    Example:\n    n = 10\n    The positive integers less than or equal to 10 that are divisible by either 3 or 5 are 3, 5, 6, 9, 10.\n    The sum of these numbers is 33.\n\n    Constraints:\n    - The input integer n will always be positive.\n    \"\"\"\n    return sum(i for i in range(1, n+1) if i % 3 == 0 or i % 5 == 0)\n\ndef g(n=10):\n    return n\n\nassert f(g()) == 33\n",
        "idx_generation": 326,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of trailing zeros in n!.\n\n    Example:\n    n = 5\n\n    Output:\n    1\n\n    Explanation:\n    5! = 5 * 4 * 3 * 2 * 1 = 120, which has 1 trailing zero.\n\n    Hint: Count the number of factors of 5 in n! to determine the number of trailing zeros.\n    \"\"\"\n\n    count = 0\n    i = 5\n    while n // i >= 1:\n        count += n // i\n        i *= 5\n    return count\n\ndef g(n: int):\n    return n\n\nassert f(g(20)) == 4\n",
        "idx_generation": 483,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    You can return the answer in any order.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    nums[0] + nums[1] equals to 9, so the indices are 0 and 1.\n    \"\"\"\n\n    hashmap = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in hashmap:\n            return [hashmap[complement], i]\n        hashmap[num] = i\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 371,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if the list is sorted in non-decreasing order.\n\n    Sample Input:\n    arr = [1, 2, 3, 4, 5]\n\n    Sample Output:\n    True\n\n    Explanation: The list is sorted in non-decreasing order.\n\n    Hint: Iterate through the list and check if each element is greater than or equal to the previous element.\n    \"\"\"\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            return False\n    return True\n\ndef g(arr: List[int] = [1, 2, 3, 4, 5]) -> List[int]:\n    \"\"\"Generate a list of integers.\"\"\"\n    return arr\n\nassert f(g())\n",
        "idx_generation": 353,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s containing only parentheses ( and ), determine if the parentheses are balanced.\n\n    Return True if the parentheses are balanced, False otherwise.\n\n    Example:\n    s = \"()()((()))\"\n\n    Output:\n    True\n\n    Explanation:\n    The parentheses in the string are balanced.\n\n    Hint: Use a stack to keep track of opening parentheses and pop them when a closing parenthesis is encountered. If the stack is empty at the end, the parentheses are balanced.\n    \"\"\"\n\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n\n    return len(stack) == 0\n\ndef g():\n    s = \"()()((()))\"\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 382,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    Output:\n    4\n\n    Explanation:\n    The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[int]:\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n\n",
        "idx_generation": 371,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool:\n    \"\"\"\n    Check if there is a valid path from the start point to the end point in the grid.\n    A valid path consists of only 1s and can only move horizontally or vertically.\n    \"\"\"\n    def is_valid(grid, row, col):\n        if 0 <= row < len(grid) and 0 <= col < len(grid[0]) and grid[row][col] == 1:\n            return True\n        return False\n    \n    def dfs(grid, row, col, visited):\n        if (row, col) == end:\n            return True\n        \n        visited.add((row, col))\n        \n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        for dr, dc in directions:\n            new_row, new_col = row + dr, col + dc\n            if is_valid(grid, new_row, new_col) and (new_row, new_col) not in visited:\n                if dfs(grid, new_row, new_col, visited):\n                    return True\n        \n        return False\n    \n    visited = set()\n    return dfs(grid, start[0], start[1], visited)\n\ndef g() -> Tuple[List[List[int]], Tuple[int, int], Tuple[int, int]]:\n    \"\"\"\n    Generate a grid, start point, and end point for the puzzle.\n    \"\"\"\n    grid = [[1, 1, 1, 1, 1],\n            [0, 0, 1, 0, 1],\n            [1, 1, 1, 1, 1],\n            [1, 0, 1, 0, 0],\n            [1, 1, 1, 1, 1]]\n    start = (0, 0)\n    end = (4, 4)\n    return grid, start, end\n\nassert f(g()[0], g()[1], g()[2]) == True\n",
        "idx_generation": 228,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of the words in the string.\n\n    Example:\n    Input: \"Hello World\"\n    Output: \"World Hello\"\n    \"\"\"\n    words = s.split()\n    return ' '.join(reversed(words))\n\ndef g() -> str:\n    return \"Hello World\"\n\nassert f(g()) == \"World Hello\"\n\n",
        "idx_generation": 373,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a list of words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.\n\n    Args:\n    - s: The input string.\n    - words: The list of dictionary words.\n\n    Returns:\n    - True if s can be segmented into a sequence of dictionary words, False otherwise.\n    \"\"\"\n    n = len(s)\n    dp = [False] * (n + 1)\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in words:\n                dp[i] = True\n                break\n\n    return dp[n]\n\ndef g() -> Tuple[str, List[str]]:\n    s = \"leetcode\"\n    words = [\"leet\", \"code\"]\n    return s, words\n\nassert f(*g())\n",
        "idx_generation": 310,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of bits that are set to 1 in the binary representation of a given integer n.\"\"\"\n    count = 0\n\n    while n:\n        count += n & 1\n        n >>= 1\n\n    return count\n\ndef g(n: int = 42) -> int:\n    \"\"\"Generate an integer value.\"\"\"\n    return n\n\nassert f(g()) == 3\n",
        "idx_generation": 108,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    Input:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\n    Output: 7\n\n    Explanation: The minimum sum path is 1 + 3 + 1 + 1 + 1 = 7.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[m - 1][n - 1]\n\ndef g():\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 171,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> List[int]:\n    \"\"\"\n    Given a binary tree, return the level order traversal of its nodes' values.\n    (i.e., from left to right, level by level).\n\n    Example:\n    Input:\n           3\n          / \\\n         9  20\n           /  \\\n          15   7\n\n    Output:\n    [3, 9, 20, 15, 7]\n    \"\"\"\n\n    if not root:\n        return []\n\n    queue = [root]\n    result = []\n\n    while queue:\n        level_size = len(queue)\n        level_nodes = []\n\n        for _ in range(level_size):\n            node = queue.pop(0)\n            level_nodes.append(node.val)\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        result.extend(level_nodes)\n\n    return result\n\ndef g():\n    \"\"\"\n    Generate a binary tree with the following structure:\n           3\n          / \\\n         9  20\n           /  \\\n          15   7\n    \"\"\"\n    root = TreeNode(3)\n    root.left = TreeNode(9)\n    root.right = TreeNode(20)\n    root.right.left = TreeNode(15)\n    root.right.right = TreeNode(7)\n    return root\n\nassert f(g()) == [3, 9, 20, 15, 7]\n",
        "idx_generation": 260,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, determine if the graph is bipartite.\n    A graph is bipartite if its vertices can be divided into two independent sets, such that there is no\n    edge between vertices of the same set.\n\n    Example:\n    graph = [\n        [0, 1, 0, 1],\n        [1, 0, 1, 0],\n        [0, 1, 0, 1],\n        [1, 0, 1, 0]\n    ]\n\n    Output:\n    True (The graph can be divided into two sets: {0, 2} and {1, 3})\n    \"\"\"\n    n = len(graph)\n    color = [-1] * n\n    \n    def dfs(node, c):\n        color[node] = c\n        \n        for neighbor in range(n):\n            if graph[node][neighbor] == 1:\n                if color[neighbor] == c:\n                    return False\n                if color[neighbor] == -1 and not dfs(neighbor, 1 - c):\n                    return False\n        \n        return True\n    \n    for node in range(n):\n        if color[node] == -1 and not dfs(node, 0):\n            return False\n    \n    return True\n\ndef g():\n    return [\n        [0, 1, 0, 1],\n        [1, 0, 1, 0],\n        [0, 1, 0, 1],\n        [1, 0, 1, 0]\n    ]\n\nassert f(g()) == True\n",
        "idx_generation": 92,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the shortest distance from a source cell to a destination cell.\n    You can move in all four directions (up, down, left, and right) from a given cell if the adjacent cell is 1 and not visited.\n\n    Example:\n    grid = [\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 0, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 0, 0],\n        [1, 1, 1, 1, 1]\n    ]\n    source = (0, 0)\n    destination = (4, 4)\n\n    Output:\n    8\n\n    Explanation:\n    The shortest distance from the source cell (0, 0) to the destination cell (4, 4) is 8.\n\n    Hint: Use string manipulation techniques to check if the string is a palindrome.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    if grid[0][0] == 0 or grid[rows - 1][cols - 1] == 0:\n        return -1\n\n    visited = [[False] * cols for _ in range(rows)]\n    visited[0][0] = True\n\n    queue = [(0, 0, 0)]\n\n    while queue:\n        row, col, dist = queue.pop(0)\n\n        if (row, col) == (rows - 1, cols - 1):\n            return dist\n\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            new_row = row + dr\n            new_col = col + dc\n\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1 and not visited[new_row][new_col]:\n                visited[new_row][new_col] = True\n                queue.append((new_row, new_col, dist + 1))\n\n    return -1\n\ndef g():\n    grid = [\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 0, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 0, 0],\n        [1, 1, 1, 1, 1]\n    ]\n    return [grid]\n\nassert f(*g()) == 8\n",
        "idx_generation": 177,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Generate all possible combinations of n pairs of parentheses.\n    \"\"\"\n    def backtrack(s, left, right):\n        if len(s) == 2 * n:\n            result.append(s)\n            return\n        if left < n:\n            backtrack(s + '(', left + 1, right)\n        if right < left:\n            backtrack(s + ')', left, right + 1)\n    \n    result = []\n    backtrack('', 0, 0)\n    return result\n\ndef g(n: int = 3):\n    return n\n\nassert f(g()) == ['((()))', '(()())', '(())()', '()(())', '()()()']\n",
        "idx_generation": 217,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the number of ways to choose k items from a set of n items.\n\n    Example:\n    Input:\n    n = 5, k = 3\n\n    Output:\n    10\n    Explanation:\n    Choosing 3 items from a set of 5 items can be done in 10 ways: C(5, 3) = 10.\n    \"\"\"\n    def factorial(x: int) -> int:\n        if x == 0 or x == 1:\n            return 1\n        return x * factorial(x - 1)\n\n    return factorial(n) // (factorial(k) * factorial(n - k))\n\ndef g() -> Tuple[int, int]:\n    return 5, 3\n\nassert f(*g()) == 10\n",
        "idx_generation": 170,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Find if the length of the longest substring with distinct characters is at least k.\"\"\"\n    max_len = 0\n    for i in range(len(s)):\n        distinct_chars = set()\n        for j in range(i, len(s)):\n            if s[j] in distinct_chars:\n                break\n            distinct_chars.add(s[j])\n        max_len = max(max_len, len(distinct_chars))\n    return max_len >= k\n\ndef g(s: str, k: int):\n    \"\"\"Generate a string s with distinct characters and a value k.\"\"\"\n    return s, k\n\nassert f(*g(s=\"programming\", k=5))\n",
        "idx_generation": 71,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target value, find two numbers in the list that add up to the target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    Output:\n    [2, 5]\n\n    Explanation:\n    The numbers 2 and 5 add up to 7.\n\n    Hint: Use a two-pointer approach to search for the two numbers. Start with two pointers at both ends of the list and move them towards the middle, adjusting their positions based on the sum of the numbers at the pointers.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return [nums[left], nums[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value for the puzzle.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target\n\nassert f(*g()) == [2, 5]\n\n",
        "idx_generation": 484,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the list.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation:\n    The sum of nums[0] and nums[1] is 2 + 7 = 9, which is the target value.\n    Therefore, the indices of the two numbers are [0, 1].\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g(nums: List[int] = [2, 7, 11, 15], target: int = 9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 350,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(nums: List[int], target: int) -> Tuple[int, int]:\n    \"\"\"\n    Given a sorted array of integers, find two numbers such that their sum is closest to a target number.\n    Return the indices of the two numbers as a tuple.\n\n    Example:\n    Input: nums = [-1, 2, 3, 4, 5], target = 1\n    Output: (0, 1)\n    Explanation:\n    The sum of -1 and 2 is -1, which is the closest to the target number 1.\n    Therefore, the indices of these two numbers are (0, 1).\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    closest_sum = float('inf')\n    closest_indices = (0, 0)\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if abs(current_sum - target) < abs(closest_sum - target):\n            closest_sum = current_sum\n            closest_indices = (left, right)\n        if current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return closest_indices\n\ndef g() -> Tuple[List[int], int]:\n    return ([-1, 2, 3, 4, 5], 1)\n\nassert f(*g()) == (0, 1)\n\n",
        "idx_generation": 122,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> List[str]:\n    \"\"\"\n    Given a string s and a list of words, find all the words from the list that are anagrams of s.\n\n    Example:\n    s = \"listen\"\n    words = [\"enlist\", \"silent\", \"inlets\", \"google\", \"listen\"]\n\n    Output:\n    [\"enlist\", \"silent\", \"inlets\", \"listen\"]\n\n    Explanation:\n    The anagrams of \"listen\" from the list are [\"enlist\", \"silent\", \"inlets\", \"listen\"].\n\n    Hint: Convert the input string and the words in the list to a sorted form and compare them.\n    \"\"\"\n\n    sorted_s = ''.join(sorted(s))\n    anagrams = []\n\n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        if sorted_word == sorted_s:\n            anagrams.append(word)\n\n    return anagrams\n\ndef g():\n    s = \"listen\"\n    words = [\"enlist\", \"silent\", \"inlets\", \"google\", \"listen\"]\n    return (s, words)\n\nassert f(*g()) == [\"enlist\", \"silent\", \"inlets\", \"listen\"]\n\n",
        "idx_generation": 173,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum possible product of any three numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    24 (maximum product is achieved by multiplying 2, 3, and 4)\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g():\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == 24\n",
        "idx_generation": 409,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target number, return the index of the target number in the list.\n    If the target number is not found, return -1.\n\n    This function uses a binary search algorithm to find the index.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 4\n\n    Output:\n    3\n\n    Explanation:\n    The target number 4 is found at index 3 in the list.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5, 6], target: int = 4):\n    \"\"\"\n    Generate a sorted list of integers and a target number for the function f.\n    \"\"\"\n    return nums, target\n\nassert f(*g()) == 3\n",
        "idx_generation": 269,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, determine whether it is a prime number.\n\n    A prime number is a natural number greater than 1 that is not a product of two smaller natural numbers.\n\n    Return True if n is prime, False otherwise.\n\n    Example:\n    n = 7\n\n    Output:\n    True\n\n    Explanation:\n    7 is a prime number.\n    \"\"\"\n\n    if n <= 1:\n        return False\n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n\n    return True\n\ndef g(n=7):\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    return n\n\nassert f(g()) == True\n\n",
        "idx_generation": 331,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return a new list where each element is the product of all the elements of nums except the corresponding element.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    [24, 12, 8, 6]\n\n    Explanation:\n    The product of all elements in nums except 1 is 2*3*4 = 24.\n    The product of all elements in nums except 2 is 1*3*4 = 12.\n    The product of all elements in nums except 3 is 1*2*4 = 8.\n    The product of all elements in nums except 4 is 1*2*3 = 6.\n    \"\"\"\n\n    n = len(nums)\n    prefix = [1] * n\n    suffix = [1] * n\n    result = [0] * n\n\n    for i in range(1, n):\n        prefix[i] = prefix[i - 1] * nums[i - 1]\n        suffix[n - i - 1] = suffix[n - i] * nums[n - i]\n\n    for i in range(n):\n        result[i] = prefix[i] * suffix[i]\n\n    return result\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4]\n\nassert f(g()) == [24, 12, 8, 6]\n",
        "idx_generation": 497,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, return the sum of all the elements in the matrix.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    45 (sum of all elements in the matrix)\n    \"\"\"\n    total_sum = 0\n    for row in matrix:\n        for num in row:\n            total_sum += num\n    return total_sum\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == 45\n\n",
        "idx_generation": 388,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with only the even numbers.\n\n    Example:\n    arr = [1, 2, 3, 4, 5, 6, 7, 8]\n    Output: [2, 4, 6, 8]\n    \"\"\"\n\n    result = []\n    for num in arr:\n        if num % 2 == 0:\n            result.append(num)\n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8]\n\nassert f(g()) == [2, 4, 6, 8]\n\n",
        "idx_generation": 354,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the sum of all elements in the grid, using a stack.\n\n    Return the sum of all elements in the grid.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    Output:\n    45\n\n    Explanation:\n    The sum of all elements in the grid is 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45.\n    \"\"\"\n\n    stack = []\n    for row in grid:\n        for num in row:\n            stack.append(num)\n\n    total_sum = 0\n    while stack:\n        total_sum += stack.pop()\n\n    return total_sum\n\ndef g(grid: List[List[int]] = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return grid\n\nassert f(g()) == 45\n\n",
        "idx_generation": 386,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum number of steps required to reach the bottom-right cell from the top-left cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum number of steps required is 7, which is the length of the shortest path: 1 -> 3 -> 1 -> 1 -> 1.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Initialize the dp table\n    dp = [[0] * cols for _ in range(rows)]\n\n    # Fill in the dp table\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g():\n    \"\"\"\n    Generate a grid of integers for testing.\n    \"\"\"\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n\n",
        "idx_generation": 374,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers representing elevations, find the minimum number of steps required to reach the bottom-right cell from the top-left cell.\n    You can only move down, to the right, or diagonally right-down.\n    Each step can only be taken to a neighboring cell with a smaller or equal elevation.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    2 (1 -> 4 -> 9)\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n\n    for i in range(1, m):\n        if grid[i][0] >= grid[i-1][0]:\n            dp[i][0] = dp[i-1][0] + 1\n\n    for j in range(1, n):\n        if grid[0][j] >= grid[0][j-1]:\n            dp[0][j] = dp[0][j-1] + 1\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] >= grid[i-1][j]:\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + 1)\n            if grid[i][j] >= grid[i][j-1]:\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + 1)\n            if grid[i][j] >= grid[i-1][j-1]:\n                dp[i][j] = min(dp[i][j], dp[i-1][j-1] + 1)\n\n    return dp[m-1][n-1]\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g()) == 2\n",
        "idx_generation": 237,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n\n    Example:\n    Input: \"abcabcbb\"\n    Output: 3\n    Explanation: The longest substring without repeating characters is \"abc\", which has a length of 3.\n    \"\"\"\n    max_length = 0\n    start = 0\n    char_dict = {}\n\n    for i in range(len(s)):\n        if s[i] in char_dict and start <= char_dict[s[i]]:\n            start = char_dict[s[i]] + 1\n        else:\n            max_length = max(max_length, i - start + 1)\n\n        char_dict[s[i]] = i\n\n    return max_length\n\ndef g() -> str:\n    return \"abcabcbb\"\n\nassert f(g()) == 3\n\n",
        "idx_generation": 373,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> str:\n    \"\"\"\n    Given a list of words, return the longest word that can be formed by concatenating other words in the list.\n\n    Example:\n    words = [\"cat\", \"banana\", \"dog\", \"fruit\", \"apple\", \"catdog\"]\n\n    Output:\n    \"catdog\"\n\n    Explanation:\n    The longest word that can be formed by concatenating other words in the list is \"catdog\".\n    \"\"\"\n    word_set = set(words)\n    longest_word = \"\"\n\n    for word in words:\n        word_set.remove(word)\n        if is_concatenated_word(word, word_set):\n            if len(word) > len(longest_word):\n                longest_word = word\n        word_set.add(word)\n\n    return longest_word\n\ndef is_concatenated_word(word: str, word_set: set) -> bool:\n    if word in word_set:\n        return True\n\n    for i in range(1, len(word)):\n        if word[:i] in word_set and is_concatenated_word(word[i:], word_set):\n            return True\n\n    return False\n\ndef g(words=[\"cat\", \"banana\", \"dog\", \"fruit\", \"apple\", \"catdog\"]):\n    return words\n\nassert f(g()) == \"catdog\"\n",
        "idx_generation": 319,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer 'n', return the total number of set bits in the binary representation of 'n'.\n\n    Sample Input:\n    n = 10\n\n    Sample Output:\n    2\n    \"\"\"\n    count = 0\n\n    while n > 0:\n        if n & 1:\n            count += 1\n        n >>= 1\n\n    return count\n\ndef g() -> int:\n    n = 10\n    return n\n\nassert f(g()) == 2\n\n",
        "idx_generation": 109,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique paths from the top-left corner to the bottom-right corner\n    of an n x n grid, where you can only move down or right.\n    \"\"\"\n    def helper(n: int, row: int, col: int) -> int:\n        if row == n - 1 and col == n - 1:\n            return 1\n\n        if row < n - 1:\n            paths = helper(n, row + 1, col)\n        else:\n            paths = 0\n\n        if col < n - 1:\n            paths += helper(n, row, col + 1)\n\n        return paths\n\n    return helper(n, 0, 0)\n\ndef g(n: int) -> int:\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    return n\n\nassert f(g(3)) == 6\n",
        "idx_generation": 176,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix and two nodes start and end, determine if there\n    is a path from start to end in the graph.\n\n    Return True if there is a path from start to end, False otherwise.\n\n    Example:\n    graph = [[0, 1, 1, 0],\n             [0, 0, 0, 1],\n             [0, 0, 0, 1],\n             [0, 0, 0, 0]]\n    start = 0\n    end = 3\n\n    Output:\n    True\n\n    Explanation:\n    There is a directed path from node 0 to node 3 in the graph.\n    \"\"\"\n    visited = [False] * len(graph)\n    stack = [start]\n    \n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        \n        if not visited[node]:\n            visited[node] = True\n            for neighbor in range(len(graph[node])):\n                if graph[node][neighbor]:\n                    stack.append(neighbor)\n    \n    return False\n\ndef g():\n    graph = [[0, 1, 1, 0],\n             [0, 0, 0, 1],\n             [0, 0, 0, 1],\n             [0, 0, 0, 0]]\n    start = 0\n    end = 3\n    return graph, start, end\n\nassert f(*g())\n",
        "idx_generation": 261,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the number of islands in the grid.\n    An island is a group of connected 1s (horizontal or vertical).\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    def dfs(row, col):\n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] != 1:\n            return\n        grid[row][col] = -1\n        dfs(row + 1, col)\n        dfs(row - 1, col)\n        dfs(row, col + 1)\n        dfs(row, col - 1)\n    \n    count = 0\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                dfs(i, j)\n                count += 1\n    \n    return count\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    return [grid]\n\nassert f(*g()) == 3\n\n",
        "idx_generation": 93,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(edges: List[Tuple[int, int]]) -> bool:\n    \"\"\"\n    Given a list of edges representing a graph, determine if the graph is a tree.\n\n    Return True if the graph is a tree, False otherwise.\n\n    Example:\n    edges = [(0, 1), (0, 2), (0, 3), (1, 4)]\n\n    Output:\n    True\n\n    Explanation:\n    The graph is a tree as it is connected and contains no cycles.\n    \"\"\"\n    n = len(edges) + 1\n    parent = list(range(n))\n\n    def find(x):\n        while x != parent[x]:\n            parent[x] = parent[parent[x]]\n            x = parent[x]\n        return x\n\n    def union(x, y):\n        parent[find(y)] = find(x)\n\n    for u, v in edges:\n        if find(u) == find(v):\n            return False\n        union(u, v)\n\n    return len(set(parent)) == 1\n\ndef g(edges = [(0, 1), (0, 2), (0, 3), (1, 4)]):\n    return edges\n\nassert f(g()) == True\n",
        "idx_generation": 178,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target integer, find the number of different pairs of integers in the list that sum up to the target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n\n    Output:\n    2\n\n    Explanation:\n    The pairs that sum up to the target are (1, 5) and (2, 4).\n\n    Hint: Use counting and combinatorics to solve this problem.\n    \"\"\"\n\n    count = 0\n    nums_dict = {}\n\n    for num in nums:\n        complement = target - num\n        if complement in nums_dict:\n            count += 1\n        nums_dict[num] = nums_dict.get(num, 0) + 1\n\n    return count\n\ndef g(nums=[1, 2, 3, 4, 5], target=6):\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 223,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Find the number of combinations that add up to the target sum using the numbers in the list.\n    \"\"\"\n    def helper(nums: List[int], target: int, index: int) -> int:\n        if target == 0:\n            return 1\n        if target < 0 or index >= len(nums):\n            return 0\n        \n        count = 0\n        count += helper(nums, target - nums[index], index)\n        count += helper(nums, target, index + 1)\n        return count\n    \n    return helper(nums, target, 0)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target sum.\n    \"\"\"\n    nums = [1, 2, 3]\n    target = 4\n    return nums, target\n\nassert f(*g()) == 4\n",
        "idx_generation": 172,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, apply run-length encoding to compress the string.\n    Replace consecutive occurrences of the same character with the character followed by the count.\n\n    Example:\n    s = \"aaabbcccc\"\n\n    Output:\n    \"a3b2c4\"\n    \"\"\"\n    encoded = []\n    count = 1\n    \n    for i in range(1, len(s)):\n        if s[i] == s[i-1]:\n            count += 1\n        else:\n            encoded.append(s[i-1] + str(count))\n            count = 1\n    \n    encoded.append(s[-1] + str(count))\n    \n    return \"\".join(encoded)\n\ndef g():\n    return \"aaabbcccc\"\n\nassert f(g()) == \"a3b2c4\"\n",
        "idx_generation": 92,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target integer, determine if the target integer is present in the list.\n\n    Example:\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output:\n    True (since the target integer 5 is present in the list)\n    \"\"\"\n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n    return arr, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 485,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Stack:\n    def __init__(self):\n        self.stack = []\n    \n    def push(self, x):\n        self.stack.append(x)\n    \n    def pop(self):\n        if not self.is_empty():\n            return self.stack.pop()\n        return None\n    \n    def is_empty(self):\n        return len(self.stack) == 0\n    \n    def top(self):\n        if not self.is_empty():\n            return self.stack[-1]\n        return None\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of heights representing a bar graph, find the largest rectangular area that can be formed\n    by a rectangle contained entirely within the bar graph.\n\n    Args:\n    - heights: A list of integers representing the heights of the bars in the graph.\n    \n    Returns:\n    - The area of the largest rectangle that can be formed.\n    \"\"\"\n    n = len(heights)\n    stack = Stack()\n    max_area = 0\n    i = 0\n    \n    while i < n:\n        if stack.is_empty() or heights[i] >= heights[stack.top()]:\n            stack.push(i)\n            i += 1\n        else:\n            top = stack.pop()\n            area = heights[top] * (i if stack.is_empty() else i - stack.top() - 1)\n            max_area = max(max_area, area)\n    \n    while not stack.is_empty():\n        top = stack.pop()\n        area = heights[top] * (i if stack.is_empty() else i - stack.top() - 1)\n        max_area = max(max_area, area)\n    \n    return max_area\n\ndef g():\n    heights = [2, 1, 5, 6, 2, 3]\n    return heights\n\nassert f(g()) == 10\n",
        "idx_generation": 387,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of positive integers, find the maximum sum of a subarray with the constraint that no two numbers in the subarray are adjacent.\n    Return the maximum sum.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    if n == 1:\n        return nums[0]\n    if n == 2:\n        return max(nums[0], nums[1])\n    \n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    \n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n    \n    return dp[n-1]\n\ndef g():\n    nums = [1, 2, 3, 1]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 126,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], target: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a target string, find all words in the list that can be formed by rearranging\n    the characters of the target string.\n\n    Sample Input:\n    words = [\"cat\", \"dog\", \"tac\", \"god\", \"act\"]\n    target = \"act\"\n\n    Sample Output:\n    [\"cat\", \"tac\", \"act\"]\n    \"\"\"\n    def is_anagram(word: str, target: str) -> bool:\n        return sorted(word) == sorted(target)\n\n    result = []\n    for word in words:\n        if is_anagram(word, target):\n            result.append(word)\n    \n    return result\n\n\ndef g(words = [\"cat\", \"dog\", \"tac\", \"god\", \"act\"], target = \"act\"):\n    return words, target\n\n\nassert f(*g()) == [\"cat\", \"tac\", \"act\"]\n",
        "idx_generation": 182,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n    \n    Return the maximum product.\n    \n    Example:\n    nums = [1, 2, 3, 4, 5]\n    \n    Output:\n    60\n    \n    Explanation:\n    The maximum product is obtained by multiplying 4, 5, and 3.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 60\n",
        "idx_generation": 411,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target sum, determine if there exists a subset of the list that adds up to the target sum.\n\n    Return True if such a subset exists, False otherwise.\n\n    Example:\n    nums = [2, 4, 6, 8]\n    target = 14\n\n    Output:\n    True\n\n    Explanation:\n    The subset [2, 4, 8] adds up to the target sum of 14.\n    \"\"\"\n    def subset_sum(nums, target, n):\n        if target == 0:\n            return True\n        if n == 0:\n            return False\n        if nums[n-1] > target:\n            return subset_sum(nums, target, n-1)\n        return subset_sum(nums, target-nums[n-1], n-1) or subset_sum(nums, target, n-1)\n\n    return subset_sum(nums, target, len(nums))\n\ndef g():\n    return [2, 4, 6, 8], 14\n\nassert f(*g()) == True\n\n",
        "idx_generation": 277,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of trailing zeros in n!.\n\n    Example:\n    Input: n = 5\n    Output: 1\n\n    Explanation: 5! = 120, which has 1 trailing zero.\n\n    Hint: The number of trailing zeros in n! is equal to the number of factors of 5 in n!.\n    \"\"\"\n    count = 0\n    power = 1\n    while n >= math.pow(5, power):\n        count += n // math.pow(5, power)\n        power += 1\n    return count\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 1\n\n",
        "idx_generation": 333,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if a given number is a prime number.\n\n    Sample Input:\n    n = 17\n\n    Sample Output:\n    True\n    \"\"\"\n    if n <= 1:\n        return False\n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n\n    return True\n\ndef g(n=17):\n    return n\n\nassert f(g())\n",
        "idx_generation": 394,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n\n    Example:\n    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g(arr=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return arr\n\nassert f(g()) == 6\n",
        "idx_generation": 355,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a valid parentheses string.\n\n    A valid parentheses string is any non-empty string where each open parenthesis '(' has a corresponding closing parenthesis ')'.\n\n    Example:\n    Input: \"((()))\"\n    Output: True\n\n    Input: \"()[]{}\"\n    Output: True\n\n    Input: \"([)]\"\n    Output: False\n    \"\"\"\n    stack = []\n    for char in s:\n        if char == \"(\" or char == \"[\" or char == \"{\":\n            stack.append(char)\n        else:\n            if not stack:\n                return False\n            if char == \")\" and stack[-1] != \"(\":\n                return False\n            if char == \"]\" and stack[-1] != \"[\":\n                return False\n            if char == \"}\" and stack[-1] != \"{\":\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g() -> str:\n    return \"((()))\"\n\nassert f(g()) == True\n",
        "idx_generation": 405,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, calculate the sum of all elements.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    45\n\n    Hint: Use recursion to iterate through all elements of the matrix and add them to the sum.\n    \"\"\"\n    def recursive_sum(matrix: List[List[int]], i: int, j: int) -> int:\n        if i >= len(matrix) or j >= len(matrix[0]):\n            return 0\n        return matrix[i][j] + recursive_sum(matrix, i + 1 if j + 1 >= len(matrix[0]) else i, (j + 1) % len(matrix[0]))\n\n    return recursive_sum(matrix, 0, 0)\n\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return (matrix,)\n\nassert f(*g()) == 45\n",
        "idx_generation": 376,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the minimum sum path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7 (since the minimum sum path is 1 + 3 + 1 + 1 + 1 = 7)\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g():\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n",
        "idx_generation": 244,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, return the longest palindromic substring.\n\n    Example:\n    s = \"babad\"\n\n    Output:\n    \"bab\" (or \"aba\")\n    \"\"\"\n    if not s:\n        return \"\"\n    \n    longest_palindrome = \"\"\n    \n    def expand_from_center(left: int, right: int) -> str:\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left+1:right]\n    \n    for i in range(len(s)):\n        palindrome_odd = expand_from_center(i, i)\n        palindrome_even = expand_from_center(i, i+1)\n        \n        longest_palindrome = max(longest_palindrome, palindrome_odd, palindrome_even, key=len)\n    \n    return longest_palindrome\n\ndef g():\n    s = \"babad\"\n    return s\n\nassert f(g()) == \"bab\"\n",
        "idx_generation": 374,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n    The longest substring without repeating characters is \"abc\", which has a length of 3.\n\n    Constraints:\n    - The input string s will only contain lowercase English letters.\n    \"\"\"\n    max_length = 0\n    start = 0\n    char_map = {}\n    \n    for i, char in enumerate(s):\n        if char in char_map and start <= char_map[char]:\n            start = char_map[char] + 1\n        else:\n            max_length = max(max_length, i - start + 1)\n        \n        char_map[char] = i\n    \n    return max_length\n\ndef g(s=\"abcabcbb\"):\n    return s\n\nassert f(g()) == 3\n",
        "idx_generation": 326,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, check if it is a power of 2.\n\n    - n is an integer.\n    - Return True if n is a power of 2, False otherwise.\n    \"\"\"\n    if n <= 0:\n        return False\n    return (n & (n - 1)) == 0\n\ndef g():\n    return 16\n\nassert f(g()) == True\n",
        "idx_generation": 117,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Find the number of prime numbers less than or equal to n.\n    \"\"\"\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2, n + 1):\n        if is_prime(i):\n            count += 1\n    return count\n\ndef g():\n    n = 20\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 186,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> int:\n    \"\"\"\n    Given a binary tree, find the maximum depth of the tree.\n    The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n    Example:\n    Input:\n          3\n         / \\\n        9   20\n           /  \\\n          15   7\n\n    Output:\n    3\n    Explanation:\n    The maximum depth of the binary tree is 3.\n    \"\"\"\n    if not root:\n        return 0\n\n    stack = [(root, 1)]\n    max_depth = 0\n    while stack:\n        node, depth = stack.pop()\n        max_depth = max(max_depth, depth)\n        if node.left:\n            stack.append((node.left, depth + 1))\n        if node.right:\n            stack.append((node.right, depth + 1))\n\n    return max_depth\n\ndef g():\n    node15 = TreeNode(15)\n    node7 = TreeNode(7)\n    node20 = TreeNode(20, node15, node7)\n    node9 = TreeNode(9)\n    root = TreeNode(3, node9, node20)\n    return root\n\nassert f(g()) == 3\n",
        "idx_generation": 273,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Node:\n    def __init__(self, val: int):\n        self.val = val\n        self.children = []\n\ndef f(nodes: List[Node]) -> bool:\n    \"\"\"\n    Given a list of Node objects, check if there exists a path from any node to any other node.\n\n    Return True if such path exists, False otherwise.\n\n    Example:\n    nodes = [Node(1), Node(2), Node(3), Node(4), Node(5)]\n    nodes[0].children = [nodes[1], nodes[2]]\n    nodes[1].children = [nodes[2]]\n    nodes[2].children = [nodes[3], nodes[4]]\n    nodes[3].children = [nodes[4]]\n\n    Output:\n    True\n    \"\"\"\n    visited = set()\n\n    def dfs(node):\n        visited.add(node)\n        for child in node.children:\n            if child not in visited:\n                dfs(child)\n\n    dfs(nodes[0])\n    return len(visited) == len(nodes)\n\ndef g():\n    nodes = [Node(1), Node(2), Node(3), Node(4), Node(5)]\n    nodes[0].children = [nodes[1], nodes[2]]\n    nodes[1].children = [nodes[2]]\n    nodes[2].children = [nodes[3], nodes[4]]\n    nodes[3].children = [nodes[4]]\n    return nodes\n\nassert f(g()) == True\n",
        "idx_generation": 100,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there is a path from the start node to the end node in a given graph.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g() -> Tuple[List[List[int]], int, int]:\n    \"\"\"Generate a graph and the start and end nodes.\"\"\"\n    graph = [[1, 2],\n             [3],\n             [4, 5],\n             [],\n             [6],\n             [7],\n             [8],\n             [9, 10],\n             [11],\n             [12],\n             []]\n    start = 0\n    end = 12\n    return graph, start, end\n\nassert f(*g()) == True\n\n",
        "idx_generation": 181,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "import random\nfrom typing import*\nimport itertools\nfrom typing import List\n\ndef f(n: int, k: int, nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums and an integer k,\n    find the maximum sum of any k-sized subarray in nums.\n\n    Return the maximum sum.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    k = 3\n\n    Output:\n    12\n\n    Explanation:\n    The maximum sum subarray of size 3 is [3, 4, 5], which gives a total sum of 12.\n    \"\"\"\n\n    max_sum = float('-inf')\n    for subarray in itertools.combinations(nums, k):\n        max_sum = max(max_sum, sum(subarray))\n    return max_sum\n\ndef g(n: int, k: int, nums: List[int]) -> List[int]:\n    \"\"\"\n    Generate a list of n integers with random values.\n    \"\"\"\n    return n, k, nums\n\nassert f(*g(5, 3, [1, 2, 3, 4, 5])) == 12\n\n",
        "idx_generation": 226,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Count the number of valid parentheses expressions of length n.\n    \"\"\"\n    dp = [0] * (n+1)\n    dp[0] = 1\n    \n    for i in range(2, n+1, 2):\n        for j in range(2, i+1, 2):\n            dp[i] += dp[j-2] * dp[i-j]\n    \n    return dp[n]\n\ndef g():\n    return 6\n\nassert f(g()) == 5\n",
        "idx_generation": 184,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of non-negative integers less than or equal to n that have no repeated digits.\n\n    Return the count of non-negative integers with no repeated digits.\n\n    Example:\n    n = 100\n\n    Output:\n    91\n\n    Explanation:\n    The non-negative integers less than or equal to 100 with no repeated digits are: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 100].\n\n    There are 91 non-negative integers with no repeated digits.\n    \"\"\"\n    def count_non_repeated_digits(n):\n        count = 0\n        for num in range(n+1):\n            digits = set()\n            repeated = False\n            while num > 0:\n                digit = num % 10\n                if digit in digits:\n                    repeated = True\n                    break\n                digits.add(digit)\n                num //= 10\n            if not repeated:\n                count += 1\n        return count\n    \n    return count_non_repeated_digits(n)\n\ndef g(n=100):\n    return n\n\nassert f(g()) == 91\n",
        "idx_generation": 127,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order using the bubble sort algorithm.\n\n    Example:\n    arr = [5, 3, 2, 4, 1]\n\n    Output:\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\n\ndef g() -> List[int]:\n    return [5, 3, 2, 4, 1]\n\nassert f(g()) == [1, 2, 3, 4, 5]\n\n",
        "idx_generation": 485,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order using the bubble sort algorithm.\n    \n    Example:\n    nums = [5, 3, 8, 2, 1]\n    \n    Output:\n    [1, 2, 3, 5, 8]\n    \n    Hint: Use nested loops to compare adjacent elements and swap them if they are in the wrong order.\n    \"\"\"\n    n = len(nums)\n    for i in range(n - 1):\n        for j in range(n - i - 1):\n            if nums[j] > nums[j + 1]:\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n    return nums\n\ndef g():\n    return [[5, 3, 8, 2, 1]]\n\nassert f(*g()) == [1, 2, 3, 5, 8]\n",
        "idx_generation": 428,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Return the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    Output:\n    4\n\n    Explanation:\n    The longest increasing subsequence is [2, 3, 7, 101] with a length of 4.\n    \"\"\"\n    def longest_increasing_subsequence(nums):\n        n = len(nums)\n        dp = [1] * n\n\n        for i in range(1, n):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        \n        return max(dp)\n\n    return longest_increasing_subsequence(nums)\n\ndef g(nums=[10, 9, 2, 5, 3, 7, 101, 18]):\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 127,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list with the words sorted in lexicographic order and each word reversed.\n    \"\"\"\n    return sorted([word[::-1] for word in words])\n\ndef g(words: List[str] = [\"hello\", \"world\", \"python\"]):\n    \"\"\"\n    Return the input list of words.\n    \"\"\"\n    return words\n\nassert f(g()) == [\"dlrow\", \"nohtyp\", \"olleh\"]\n",
        "idx_generation": 188,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target number if it exists in the list.\n    If the target number does not exist in the list, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(nums=[2, 4, 6, 8, 10, 12], target=8):\n    return nums, target\n\nassert f(*g()) == 3\n",
        "idx_generation": 488,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of unique triplets that add up to zero.\n\n    Sample Input:\n    nums = [-1, 0, 1, 2, -1, -4]\n\n    Sample Output:\n    2\n\n    Explanation:\n    The unique triplets that add up to zero are [-1, 0, 1] and [-1, -1, 2].\n    \"\"\"\n\n    nums.sort()\n    result = 0\n\n    for i in range(len(nums) - 2):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left = i + 1\n        right = len(nums) - 1\n\n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total < 0:\n                left += 1\n            elif total > 0:\n                right -= 1\n            else:\n                result += 1\n\n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return result\n\ndef g(nums: List[int] = [-1, 0, 1, 2, -1, -4]) -> List[int]:\n    return nums\n\nassert f(g()) == 2\n",
        "idx_generation": 278,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a pair of numbers whose product is a perfect square.\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(i+1, n):\n            if (nums[i] * nums[j]) ** 0.5 % 1 == 0:\n                return True\n    return False\n\ndef g():\n    nums = [2, 3, 4, 6, 8]\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 341,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> float:\n    \"\"\"\n    Given a list of numbers, calculate the average of the numbers.\n    \"\"\"\n    n = len(nums)\n    total = 0\n    \n    for num in nums:\n        total += num\n    \n    average = total / n\n    return average\n\ndef g():\n    return ([1, 2, 3, 4, 5],)\n\nassert f(*g()) == 3.0\n\n",
        "idx_generation": 400,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a prime number.\n\n    Example:\n    n = 7\n\n    Output:\n    True\n\n    Explanation:\n    7 is a prime number.\n    \"\"\"\n    if n <= 1:\n        return False\n\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n\n    return True\n\ndef g(n=7):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 355,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid consisting of 0s and 1s, find the maximum area of a rectangle composed only of 1s.\n\n    Args:\n    - grid: A list of lists representing the grid.\n\n    Returns:\n    - An integer, the maximum area of a rectangle composed only of 1s.\n    \"\"\"\n    def maxArea(heights):\n        stack = [-1]\n        max_area = 0\n\n        for i in range(len(heights)):\n            while stack[-1] != -1 and heights[stack[-1]] >= heights[i]:\n                h = heights[stack.pop()]\n                w = i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n\n        while stack[-1] != -1:\n            h = heights[stack.pop()]\n            w = len(heights) - stack[-1] - 1\n            max_area = max(max_area, h * w)\n\n        return max_area\n\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    heights = [0] * n\n    max_area = 0\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                heights[j] = 0\n            else:\n                heights[j] += 1\n\n        max_area = max(max_area, maxArea(heights))\n\n    return max_area\n\ndef g():\n    grid = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n    return grid\n\nassert f(g()) == 6\n",
        "idx_generation": 412,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid consisting of 0s and 1s, find the number of islands in the grid.\n    An island is a group of connected 1s formed by horizontally or vertically adjacent cells.\n\n    Example:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n\n    Output:\n    3\n\n    Explanation:\n    There are 3 islands in the grid.\n    \"\"\"\n\n    def dfs(row: int, col: int) -> None:\n        \"\"\"\n        Perform depth-first search (DFS) to mark the cells of an island as visited.\n        \"\"\"\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] != 1:\n            return\n\n        grid[row][col] = -1\n\n        dfs(row - 1, col)  # up\n        dfs(row + 1, col)  # down\n        dfs(row, col - 1)  # left\n        dfs(row, col + 1)  # right\n\n    count = 0\n\n    for row in range(len(grid)):\n        for col in range(len(grid[0])):\n            if grid[row][col] == 1:\n                dfs(row, col)\n                count += 1\n\n    return count\n\ndef g(grid: List[List[int]]):\n    return grid\n\nassert f(g([\n    [1, 1, 0, 0, 0],\n    [1, 1, 0, 0, 0],\n    [0, 0, 1, 0, 0],\n    [0, 0, 0, 1, 1]\n])) == 3\n",
        "idx_generation": 377,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n    The maximum sum path is: 1 -> 4 -> 7 -> 8 -> 9, with a sum of 29.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    # Initialize the first row\n    for j in range(1, n):\n        grid[0][j] += grid[0][j-1]\n    \n    # Initialize the first column\n    for i in range(1, m):\n        grid[i][0] += grid[i-1][0]\n    \n    # Calculate the maximum sum path for each cell\n    for i in range(1, m):\n        for j in range(1, n):\n            grid[i][j] += max(grid[i-1][j], grid[i][j-1])\n    \n    return grid[m-1][n-1]\n\ndef g():\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\nassert f(g()) == 29\n",
        "idx_generation": 255,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if they are isomorphic.\n    Two strings are isomorphic if the characters in s can be replaced to get t.\n\n    Example:\n    s = \"egg\"\n    t = \"add\"\n\n    Output:\n    True\n\n    Explanation:\n    The character 'e' in s is replaced with 'a' in t, and the character 'g' in s is replaced with 'd' in t.\n    Therefore, the strings are isomorphic.\n    \"\"\"\n    if len(s) != len(t):\n        return False\n\n    mapping = {}\n    used_chars = set()\n\n    for i in range(len(s)):\n        if s[i] not in mapping:\n            if t[i] in used_chars:\n                return False\n            mapping[s[i]] = t[i]\n            used_chars.add(t[i])\n        else:\n            if mapping[s[i]] != t[i]:\n                return False\n\n    return True\n\ndef g():\n    s = \"egg\"\n    t = \"add\"\n    return s, t\n\nassert f(*g()) == True\n",
        "idx_generation": 377,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, return True if s is a palindrome, False otherwise.\n\n    Args:\n    - s: A string to check for palindrome.\n\n    Returns:\n    - True if s is a palindrome, False otherwise.\n    \"\"\"\n    s = s.lower()\n    s = \"\".join(char for char in s if char.isalnum())\n    \n    return s == s[::-1]\n\ndef g() -> str:\n    s = \"A man, a plan, a canal: Panama\"\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 396,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n    Return the maximum XOR value.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value is obtained by XORing 5 and 25 (5 XOR 25 = 28).\n    \"\"\"\n\n    def find_maximum_xor(nums):\n        max_xor = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                xor_value = nums[i] ^ nums[j]\n                max_xor = max(max_xor, xor_value)\n        return max_xor\n\n    return find_maximum_xor(nums)\n\ndef g(nums=[3, 10, 5, 25, 2, 8]):\n    return nums\n\nassert f(g()) == 28\n",
        "idx_generation": 118,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers n and m, find the number of ways to climb to the top of a staircase of n steps.\n\n    Args:\n    - n: The number of steps in the staircase.\n    - m: The maximum number of steps that can be taken at once.\n\n    Returns:\n    - The number of ways to climb to the top of the staircase.\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n\n    ways = [0] * (n + 1)\n    ways[0] = 1\n    ways[1] = 1\n\n    for i in range(2, n + 1):\n        for j in range(1, min(m, i) + 1):\n            ways[i] += ways[i - j]\n\n    return ways[n]\n\ndef g() -> Tuple[int, int]:\n    n = 5\n    m = 2\n    return n, m\n\nassert f(*g()) == 8\n",
        "idx_generation": 190,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> List[int]:\n    \"\"\"\n    Given a graph represented as an adjacency matrix and two vertices, find the shortest path between the two vertices.\n    Return the path as a list of vertices.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0, 0],\n        [1, 0, 0, 1, 0],\n        [1, 0, 0, 1, 1],\n        [0, 1, 1, 0, 1],\n        [0, 0, 1, 1, 0]\n    ]\n    start = 0\n    end = 4\n\n    Output:\n    [0, 2, 4]\n\n    Return the shortest path: 0 -> 2 -> 4\n    \"\"\"\n    queue = [(start, [start])]\n    visited = set()\n\n    while queue:\n        node, path = queue.pop(0)\n        if node == end:\n            return path\n        if node not in visited:\n            visited.add(node)\n            for i in range(len(graph[node])):\n                if graph[node][i] == 1:\n                    queue.append((i, path + [i]))\n\n    return []\n\ndef g():\n    return [\n        [0, 1, 1, 0, 0],\n        [1, 0, 0, 1, 0],\n        [1, 0, 0, 1, 1],\n        [0, 1, 1, 0, 1],\n        [0, 0, 1, 1, 0]\n    ], 0, 4\n\nassert f(*g()) == [0, 2, 4]\n\n",
        "idx_generation": 285,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Node:\n    def __init__(self, val: int):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef f(root: Node) -> bool:\n    \"\"\"\n    Given a binary tree, determine if it is a valid binary search tree (BST).\n    \"\"\"\n    def is_valid_bst(node: Node, low=float('-inf'), high=float('inf')) -> bool:\n        if not node:\n            return True\n        if node.val <= low or node.val >= high:\n            return False\n        return is_valid_bst(node.left, low, node.val) and is_valid_bst(node.right, node.val, high)\n\n    return is_valid_bst(root)\n\ndef g(root: Node) -> Node:\n    \"\"\"\n    Given a binary tree, return the root of the tree.\n    \"\"\"\n    return root\n\n# Example usage\nroot = Node(5)\nroot.left = Node(3)\nroot.right = Node(7)\nroot.left.left = Node(2)\nroot.left.right = Node(4)\nroot.right.left = Node(6)\nroot.right.right = Node(8)\n\nassert f(g(root))\n",
        "idx_generation": 104,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix (2D list of integers),\n    return True if the graph contains a cycle, otherwise return False.\n    \"\"\"\n    def dfs(node: int, visited: List[bool], stack: List[bool]) -> bool:\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1:\n                if not visited[neighbor]:\n                    if dfs(neighbor, visited, stack):\n                        return True\n                elif stack[neighbor]:\n                    return True\n\n        stack[node] = False\n        return False\n\n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n    stack = [False] * num_nodes\n\n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(node, visited, stack):\n                return True\n\n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    return [[0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1],\n            [1, 0, 0, 0]]\n\nassert f(g()) == True\n",
        "idx_generation": 185,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of ways to select k items from a set of n items.\n\n    Example:\n    n = 5, k = 3\n    The number of ways to select 3 items from a set of 5 items is 10, so the output should be 10.\n    \"\"\"\n    if n < k:\n        return 0\n    else:\n        numerator = 1\n        for i in range(n, n - k, -1):\n            numerator *= i\n        denominator = 1\n        for i in range(1, k + 1):\n            denominator *= i\n        return numerator // denominator\n\ndef g(n=5, k=3):\n    return n, k\n\nassert f(*g()) == 10\n",
        "idx_generation": 238,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subsequence such that no two elements in the subsequence are adjacent.\n    \"\"\"\n    if len(nums) == 0:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n\n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, len(nums)):\n        dp[i] = max(nums[i] + dp[i - 2], dp[i - 1])\n\n    return dp[-1]\n\ndef g(nums: List[int]):\n    return nums\n\nassert f(g([1, 2, 3, 4, 5])) == 9\n",
        "idx_generation": 189,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str], pattern: str) -> List[str]:\n    \"\"\"\n    Given a list of strings and a pattern string, find all strings in the list that match the pattern.\n    A pattern consists of lowercase letters and '?' wildcard characters that can match any single character.\n    Return a list of matching strings.\n    \"\"\"\n    def match(pattern: str, string: str) -> bool:\n        if len(pattern) != len(string):\n            return False\n\n        for p, s in zip(pattern, string):\n            if p != '?' and p != s:\n                return False\n\n        return True\n\n    return [string for string in strings if match(pattern, string)]\n\ndef g():\n    return ['apple', 'banana', 'orange', 'grape'], 'a?ple'\n\nassert f(*g()) == ['apple']\n",
        "idx_generation": 228,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a sorted 2D matrix of integers and a target value, determine if the target is present in the matrix.\n\n    The matrix is sorted row-wise and column-wise.\n\n    Example:\n    Input: \n    matrix = [\n        [1, 4, 7],\n        [2, 5, 8],\n        [3, 6, 9]\n    ]\n    target = 5\n\n    Output: True\n\n    Explanation: The target value 5 is present in the matrix.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    row = 0\n    col = cols - 1\n\n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n\n    return False\n\ndef g() -> Tuple[List[List[int]], int]:\n    matrix = [\n        [1, 4, 7],\n        [2, 5, 8],\n        [3, 6, 9]\n    ]\n    target = 5\n    return (matrix, target)\n\nassert f(*g()) == True\n",
        "idx_generation": 485,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order using the bubble sort algorithm.\n\n    Example:\n    Input:\n    nums = [5, 2, 8, 10, 1]\n\n    Output:\n    [1, 2, 5, 8, 10]\n    \"\"\"\n\n    def bubble_sort(nums: List[int]) -> List[int]:\n        n = len(nums)\n\n        for i in range(n):\n            swapped = False\n\n            for j in range(0, n-i-1):\n                if nums[j] > nums[j+1]:\n                    nums[j], nums[j+1] = nums[j+1], nums[j]\n                    swapped = True\n\n            if not swapped:\n                break\n\n        return nums\n\n    return bubble_sort(nums)\n\ndef g():\n    nums = [5, 2, 8, 10, 1]\n    return nums\n\nassert f(g()) == [1, 2, 5, 8, 10]\n\n",
        "idx_generation": 454,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums and a target value, find all unique combinations in nums where the sum of the\n    combination equals the target value. Each number in nums may only be used once in the combination.\n    \"\"\"\n    def backtrack(comb: List[int], remain: int, start: int) -> None:\n        if remain == 0:\n            result.append(list(comb))\n            return\n        elif remain < 0:\n            return\n\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            comb.append(nums[i])\n            backtrack(comb, remain - nums[i], i + 1)\n            comb.pop()\n\n    nums.sort()\n    result = []\n    backtrack([], target, 0)\n    return result\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 7\n    return nums, target\n\nassert f(*g()) == [[1, 2, 4], [1, 6], [2, 5], [3, 4]]\n",
        "idx_generation": 130,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, return True if the list is sorted in ascending order,\n    and False otherwise.\n    \"\"\"\n    n = len(nums)\n    for i in range(1, n):\n        if nums[i] < nums[i-1]:\n            return False\n    return True\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 206,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers, check if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.\n\n    Example:\n    arr = [1, 5, 11, 5]\n    Output: True\n\n    Explanation:\n    The array can be partitioned into [1, 5, 5] and [11] where the sum of elements in both subsets is 11.\n    \"\"\"\n    total_sum = sum(arr)\n    if total_sum % 2 != 0:\n        return False\n\n    target_sum = total_sum // 2\n    n = len(arr)\n\n    def subset_sum(curr_sum, index):\n        if curr_sum == target_sum:\n            return True\n        if curr_sum > target_sum or index >= n:\n            return False\n\n        return subset_sum(curr_sum + arr[index], index + 1) or subset_sum(curr_sum, index + 1)\n\n    return subset_sum(0, 0)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate an array of integers for the function f.\n    \"\"\"\n    arr = [1, 5, 11, 5]\n    return arr\n\nassert f(g()) == True\n",
        "idx_generation": 289,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum product of any two numbers in the list.\"\"\"\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n    \n    return max_product\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5]) -> List[int]:\n    \"\"\"Generate a list of integers.\"\"\"\n    return nums\n\nassert f(g()) == 20\n\n",
        "idx_generation": 362,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Two Sum\n\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n\n    You can return the answer in any order.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    Because nums[0] + nums[1] == 9, we return [0, 1].\n    \"\"\"\n\n    num_to_idx = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_to_idx:\n            return [num_to_idx[complement], i]\n        num_to_idx[num] = i\n\n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 418,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums' and a target integer 'target', \n    find two numbers in 'nums' that add up to 'target' and return their indices.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 355,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(expression: str) -> bool:\n    \"\"\"\n    Given a string containing only parentheses, determine if the parentheses are balanced.\n    An expression is considered balanced if it consists of opening and closing parentheses that match correctly.\n    \"\"\"\n    stack = []\n    for char in expression:\n        if char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g(expression=\"((()))\"):\n    \"\"\"\n    Return the given expression.\n    \"\"\"\n    return expression\n\nassert f(g()) == True\n",
        "idx_generation": 428,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, calculate the number of unique paths from the top-left corner to the bottom-right corner of a n x n grid.\n    You can only move either down or right at any point in time.\n\n    Sample Input:\n    n = 3\n\n    Sample Output:\n    6\n    Explanation: In a 3x3 grid, there are 6 unique paths from the top-left corner to the bottom-right corner.\n\n    \"\"\"\n    def unique_paths_helper(i: int, j: int, memo: Dict[Tuple[int, int], int]) -> int:\n        if i == 0 or j == 0:\n            return 1\n        if (i, j) in memo:\n            return memo[(i, j)]\n        memo[(i, j)] = unique_paths_helper(i-1, j, memo) + unique_paths_helper(i, j-1, memo)\n        return memo[(i, j)]\n    \n    memo = {}\n    return unique_paths_helper(n-1, n-1, memo)\n\ndef g() -> int:\n    n = 3\n    return n\n\nassert f(g()) == 6\n\n",
        "idx_generation": 378,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 0 represents an obstacle and 1 represents an empty space,\n    find the number of unique paths from the top-left corner to the bottom-right corner of the grid,\n    moving only right or down.\n\n    Args:\n    - grid: The grid represented as a 2D list of integers.\n\n    Returns:\n    - The number of unique paths from the top-left to the bottom-right corner.\n\n    Example:\n    f([[1, 1, 1],\n       [1, 0, 1],\n       [1, 1, 1]])\n\n    Output:\n    2\n\n    Explanation:\n    There are 2 unique paths from the top-left corner to the bottom-right corner:\n    1. Down, Right, Right, Down\n    2. Right, Down, Down, Right\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    # Initialize the first column with 1s\n    for i in range(rows):\n        if grid[i][0] == 1:\n            dp[i][0] = 1\n        else:\n            break\n\n    # Initialize the first row with 1s\n    for j in range(cols):\n        if grid[0][j] == 1:\n            dp[0][j] = 1\n        else:\n            break\n\n    # Calculate the number of unique paths for each cell\n    for i in range(1, rows):\n        for j in range(1, cols):\n            if grid[i][j] == 1:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[-1][-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of 0s and 1s.\n\n    Returns:\n    - The grid represented as a 2D list of integers.\n\n    Example:\n    g() returns [[1, 1, 1],\n                 [1, 0, 1],\n                 [1, 1, 1]]\n    \"\"\"\n\n    return [[1, 1, 1],\n            [1, 0, 1],\n            [1, 1, 1]]\n\nassert f(g()) == 2\n\n",
        "idx_generation": 257,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> str:\n    \"\"\"\n    Given a string, find and return the longest substring that contains only unique characters.\n    \"\"\"\n    max_length = 0\n    start = 0\n    max_start = 0\n    char_map = {}\n\n    for i in range(len(string)):\n        if string[i] in char_map and start <= char_map[string[i]]:\n            start = char_map[string[i]] + 1\n        else:\n            if i - start + 1 > max_length:\n                max_length = i - start + 1\n                max_start = start\n        char_map[string[i]] = i\n\n    return string[max_start:max_start+max_length]\n\ndef g(string: str = \"abcabcbb\"):\n    return string\n\nassert f(g()) == \"abc\"\n\n",
        "idx_generation": 378,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string, return the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n\n    Output:\n    3\n\n    Explanation:\n    The longest substring without repeating characters is \"abc\", which has a length of 3.\n    \"\"\"\n\n    n = len(s)\n    seen = {}\n    max_length = 0\n    start = 0\n\n    for end in range(n):\n        if s[end] in seen:\n            start = max(start, seen[s[end]] + 1)\n        seen[s[end]] = end\n        max_length = max(max_length, end - start + 1)\n\n    return max_length\n\ndef g():\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"abcabcbb\"\n\nassert f(g()) == 3\n",
        "idx_generation": 403,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"\n    Given an integer, count the number of bits set to 1 in its binary representation.\n    \"\"\"\n    count = 0\n    while num:\n        count += num & 1\n        num >>= 1\n    return count\n\ndef g():\n    return 27\n\nassert f(g()) == 4\n",
        "idx_generation": 118,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Find the minimum cost to reach the bottom-right corner of the grid from the top-left corner.\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(m):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j])\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j])\n    return dp[m-1][n-1]\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\nassert f(g()) == 7\n",
        "idx_generation": 195,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix and two nodes, determine if there is a path from the start node to the end node.\n    \n    Example:\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n    Output: True\n    Explanation: There is a path from node 0 to node 3: 0 -> 1 -> 2 -> 3.\n    \"\"\"\n    visited = [False] * len(graph)\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if not visited[node]:\n            visited[node] = True\n            neighbors = graph[node]\n            for i in range(len(neighbors)):\n                if neighbors[i] == 1:\n                    stack.append(i)\n    return False\n\ndef g(graph=[[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [0, 0, 0, 0]], start=0, end=3):\n    return [graph, start, end]\n\nassert f(*g())\n",
        "idx_generation": 300,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency matrix and two nodes start and end, return True if there is a path from\n    start to end in the graph. Otherwise, return False.\n    \"\"\"\n    visited = set()\n    return dfs(graph, start, end, visited)\n\ndef dfs(graph: List[List[int]], node: int, end: int, visited: set) -> bool:\n    if node == end:\n        return True\n    visited.add(node)\n    for neighbor in range(len(graph[node])):\n        if graph[node][neighbor] == 1 and neighbor not in visited:\n            if dfs(graph, neighbor, end, visited):\n                return True\n    return False\n\ndef g():\n    graph = [[0, 1, 0, 0, 0],\n             [1, 0, 1, 1, 0],\n             [0, 1, 0, 0, 1],\n             [0, 1, 0, 0, 1],\n             [0, 0, 1, 1, 0]]\n    start = 0\n    end = 4\n    return graph, start, end\n\nassert f(*g()) == True\n\n",
        "idx_generation": 109,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, determine if there is a cycle in the graph.\n\n    Example:\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 0, 0, 0]\n    ]\n\n    Output:\n    True\n\n    Explanation:\n    The graph has a cycle: 0 -> 1 -> 2 -> 3 -> 0\n    \"\"\"\n    stack = []\n    visited = set()\n    n = len(graph)\n\n    def dfs(node):\n        stack.append(node)\n        visited.add(node)\n\n        for neighbor in range(n):\n            if graph[node][neighbor] == 1:\n                if neighbor in stack:\n                    return True\n                elif neighbor not in visited:\n                    if dfs(neighbor):\n                        return True\n\n        stack.pop()\n        return False\n\n    for node in range(n):\n        if node not in visited:\n            if dfs(node):\n                return True\n\n    return False\n\ndef g() -> List[List[int]]:\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 0, 0, 0]\n    ]\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 186,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique permutations of the list.\n    \"\"\"\n    def backtrack(nums, path, result, visited):\n        if len(path) == len(nums):\n            result.append(path[:])\n            return\n        for i in range(len(nums)):\n            if visited[i]:\n                continue\n            if i > 0 and nums[i] == nums[i-1] and not visited[i-1]:\n                continue\n            visited[i] = True\n            path.append(nums[i])\n            backtrack(nums, path, result, visited)\n            visited[i] = False\n            path.pop()\n\n    nums.sort()\n    result = []\n    visited = [False] * len(nums)\n    backtrack(nums, [], result, visited)\n    return len(result)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    nums = [1, 1, 2]\n    return nums\n\nassert f(g()) == 3\n\n",
        "idx_generation": 251,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Count the number of unique combinations that can be formed from a given array of positive integers.\"\"\"\n    def backtrack(start: int, path: List[int]) -> None:\n        nonlocal count\n        \n        if len(path) > 0:\n            count += 1\n        \n        for i in range(start, len(arr)):\n            path.append(arr[i])\n            backtrack(i + 1, path)\n            path.pop()\n    \n    count = 0\n    backtrack(0, [])\n    return count\n\ndef g():\n    return [1, 2, 3, 4]\n\nassert f(g()) == 15\n\n",
        "idx_generation": 190,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "import itertools\nfrom typing import*\nfrom itertools import permutations\n\ndef f(s: str) -> List[str]:\n    \"\"\"Generate all possible permutations of the characters in the given string.\"\"\"\n    perms = [''.join(p) for p in permutations(s)]\n    return perms\n\ndef g():\n    return \"abc\"\n\nassert f(g()) == ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n",
        "idx_generation": 237,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Find the index of the target element in a sorted array using binary search.\n    If the target element is not found, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g(nums = [1, 2, 3, 4, 5], target = 3):\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 486,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Check if a target number is present in a sorted list of integers using binary search.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5], target: int = 3) -> List[int]:\n    return nums\n\nassert f(g(), 3) == True\n",
        "idx_generation": 478,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there exists a subset of the list\n    such that the sum of the subset is equal to the target value. Return True if such subset exists,\n    otherwise return False.\n\n    Example:\n    nums = [2, 4, 6, 8]\n    target = 10\n\n    Output:\n    True\n\n    Explanation:\n    The subset [2, 8] has a sum of 10, which is equal to the target value.\n\n    Hint: Use a dynamic programming approach to solve this problem.\n    \"\"\"\n\n    def subset_sum(nums: List[int], target: int) -> bool:\n        n = len(nums)\n        dp = [[False] * (target + 1) for _ in range(n + 1)]\n\n        for i in range(n + 1):\n            dp[i][0] = True\n\n        for i in range(1, n + 1):\n            for j in range(1, target + 1):\n                if nums[i - 1] <= j:\n                    dp[i][j] = dp[i - 1][j - nums[i - 1]] or dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n\n        return dp[n][target]\n\n    return subset_sum(nums, target)\n\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 132,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, rotate it 90 degrees clockwise.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n\n    Output:\n    [[7, 4, 1],\n     [8, 5, 2],\n     [9, 6, 3]]\n\n    Hint: Transpose the matrix and reverse each row.\n    \"\"\"\n\n    def transpose(matrix: List[List[int]]) -> None:\n        n = len(matrix)\n        for i in range(n):\n            for j in range(i + 1, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n    def reverse_rows(matrix: List[List[int]]) -> None:\n        n = len(matrix)\n        for i in range(n):\n            matrix[i] = matrix[i][::-1]\n\n    transpose(matrix)\n    reverse_rows(matrix)\n\n    return matrix\n\ndef g():\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\nassert f(g()) == [[7, 4, 1],\n                  [8, 5, 2],\n                  [9, 6, 3]]\n",
        "idx_generation": 228,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique binary search trees that can be formed using the numbers 1 to n as nodes.\n    \"\"\"\n    if n <= 1:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    \n    for i in range(2, n + 1):\n        for j in range(1, i + 1):\n            dp[i] += dp[j - 1] * dp[i - j]\n    \n    return dp[n]\n\ndef g(n = 3):\n    return n\n\nassert f(g()) == 5\n\n",
        "idx_generation": 292,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two numbers in the list.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The maximum product of any two numbers in the list.\n    \"\"\"\n    max_product = float('-inf')\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n\n    return max_product\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 20\n\n",
        "idx_generation": 371,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the sum of all the elements in the matrix.\n\n    Args:\n    - matrix: A matrix of integers.\n\n    Returns:\n    - The sum of all the elements in the matrix.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    45\n\n    Explanation:\n    The sum of all the elements in the matrix is 45.\n\n    Note:\n    - The matrix may have different dimensions.\n    \"\"\"\n\n    sum = 0\n\n    for row in matrix:\n        for element in row:\n            sum += element\n\n    return sum\n\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers.\n    \"\"\"\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g()) == 45\n\n",
        "idx_generation": 429,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all numbers from 1 to n that are multiples of either 3 or 5.\n\n    Sample Input:\n    n = 10\n\n    Sample Output:\n    33\n\n    Explanation:\n    The numbers from 1 to 10 that are multiples of either 3 or 5 are: 3, 5, 6, and 9.\n    The sum of these numbers is 3 + 5 + 6 + 9 = 23.\n    \"\"\"\n\n    def calculate_sum(n: int) -> int:\n        total_sum = 0\n        for i in range(1, n+1):\n            if i % 3 == 0 or i % 5 == 0:\n                total_sum += i\n        return total_sum\n\n    return calculate_sum(n)\n\ndef g(n: int = 10) -> int:\n    return n\n\nassert f(g()) == 33\n\n",
        "idx_generation": 356,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s containing only '(' and ')', determine if it is a valid parentheses string.\n    \n    A valid parentheses string is one in which all parentheses are properly closed and nested.\n    \"\"\"\n    stack = deque()\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g() -> str:\n    \"\"\"\n    Generate a string that contains a valid parentheses string.\n    \"\"\"\n    return \"((()))\"\n\nassert f(g()) == True\n\n",
        "idx_generation": 430,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid filled with non-negative numbers, find the path from the top-left corner to the bottom-right corner\n    that minimizes the sum of all numbers along its path. You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 7\n    Explanation: The minimum sum path from top-left to bottom-right is 1 -> 3 -> 1 -> 1 -> 1, which sums up to 7.\n\n    Hint: Use dynamic programming to solve this problem.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g(grid: List[List[int]] = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(g()) == 7\n\n",
        "idx_generation": 381,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of unique paths from the top-left corner to the bottom-right corner\n    of a grid of size n x n, moving only right or down.\n\n    Args:\n    - n: The size of the grid.\n\n    Returns:\n    - The number of unique paths from the top-left to the bottom-right corner.\n\n    Example:\n    f(3)\n\n    Output:\n    6\n\n    Explanation:\n    There are 6 unique paths from the top-left corner to the bottom-right corner:\n    1. Down, Down, Right, Right\n    2. Down, Right, Down, Right\n    3. Down, Right, Right, Down\n    4. Right, Down, Down, Right\n    5. Right, Down, Right, Down\n    6. Right, Right, Down, Down\n    \"\"\"\n\n    dp = [[0] * n for _ in range(n)]\n\n    # Initialize the first column with 1s\n    for i in range(n):\n        dp[i][0] = 1\n\n    # Initialize the first row with 1s\n    for j in range(n):\n        dp[0][j] = 1\n\n    # Calculate the number of unique paths for each cell\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[-1][-1]\n\ndef g() -> int:\n    \"\"\"\n    Generate an integer.\n\n    Returns:\n    - The generated integer.\n\n    Example:\n    g() returns 3\n    \"\"\"\n\n    return 3\n\nassert f(g()) == 6\n\n",
        "idx_generation": 257,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome when only alphanumeric characters are considered.\n\n    Example:\n    s = \"A man, a plan, a canal: Panama\"\n\n    Output:\n    True\n\n    Explanation:\n    The string \"A man, a plan, a canal: Panama\" is a palindrome when only alphanumeric characters are considered.\n\n    Hint: Use two pointers to compare characters from the beginning and end of the string.\n    \"\"\"\n\n    left = 0\n    right = len(s) - 1\n\n    while left < right:\n        while left < right and not s[left].isalnum():\n            left += 1\n        while left < right and not s[right].isalnum():\n            right -= 1\n\n        if s[left].lower() != s[right].lower():\n            return False\n\n        left += 1\n        right -= 1\n\n    return True\n\ndef g() -> str:\n    return \"A man, a plan, a canal: Panama\"\n\nassert f(g()) == True\n",
        "idx_generation": 379,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s containing only lowercase letters, return true if it is a palindrome.\n\n    A palindrome is a word that is the same forwards and backwards.\n\n    Example:\n    Input: \"racecar\"\n    Output: True\n\n    Input: \"hello\"\n    Output: False\n    \"\"\"\n    def is_palindrome(left: int, right: int) -> bool:\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n\n    left = 0\n    right = len(s) - 1\n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(left+1, right) or is_palindrome(left, right-1)\n        left += 1\n        right -= 1\n    return True\n\ndef g() -> str:\n    return \"racecar\"\n\nassert f(g()) == True\n",
        "idx_generation": 405,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom collections import defaultdict\n\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency list, check if there is a path from start to end using bit manipulation.\n    \"\"\"\n    visited = [False] * len(graph)\n    visited[start] = True\n    stack = [(start, 0)]\n    while stack:\n        node, bitmask = stack.pop()\n        if node == end:\n            return True\n        for neighbor in graph[node]:\n            if not visited[neighbor] and bitmask & (1 << neighbor) == 0:\n                visited[neighbor] = True\n                stack.append((neighbor, bitmask | (1 << neighbor)))\n    return False\n\ndef g():\n    graph = {0: [1, 2], 1: [3], 2: [4], 3: [], 4: []}\n    start = 0\n    end = 4\n    return graph, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 120,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums, determine if there exists a subset of nums\n    where the sum of the subset is equal to the sum of the remaining elements.\n    \"\"\"\n\n    def subset_sum(nums, target, index, current_sum):\n        if current_sum == target:\n            return True\n        if current_sum > target or index >= len(nums):\n            return False\n\n        # Include the current element in the subset\n        if subset_sum(nums, target, index + 1, current_sum + nums[index]):\n            return True\n\n        # Exclude the current element from the subset\n        if subset_sum(nums, target, index + 1, current_sum):\n            return True\n\n        return False\n\n    total_sum = sum(nums)\n\n    # If the total sum is odd, it is not possible to split the list into two subsets with equal sum\n    if total_sum % 2 != 0:\n        return False\n\n    target = total_sum // 2\n    return subset_sum(nums, target, 0, 0)\n\ndef g():\n    nums = [1, 5, 11, 5]\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 197,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters representing a maze, find the minimum number of steps required to reach the exit.\n\n    Args:\n    - grid: A 2D list of characters representing the maze. The grid contains 'S' (start), 'E' (exit), '.' (open path), and '#' (blocked path).\n\n    Returns:\n    - The minimum number of steps required to reach the exit.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    visited = set()\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                queue.append((i, j, 0))\n                visited.add((i, j))\n\n    while queue:\n        x, y, steps = queue.pop(0)\n\n        if grid[x][y] == 'E':\n            return steps\n\n        for dx, dy in directions:\n            nx = x + dx\n            ny = y + dy\n\n            if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and grid[nx][ny] != '#':\n                queue.append((nx, ny, steps + 1))\n                visited.add((nx, ny))\n\n    return -1\n\ndef g():\n    grid = [\n        ['S', '.', '.', '#', '.', '.', '.'],\n        ['#', '#', '.', '#', '.', '#', '.'],\n        ['.', '.', '.', '.', '.', '.', '.'],\n        ['.', '#', '#', '#', '#', '#', '.'],\n        ['.', '.', '.', '.', '.', '.', 'E']\n    ]\n    return grid\n\nassert f(g()) == 10\n\n",
        "idx_generation": 327,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\n\ndef f(graph: Dict[int, List[int]], start: int, target: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency list 'graph', a starting node 'start', and a target node 'target',\n    determine if there exists a path from 'start' to 'target' in the graph.\n\n    Sample Input:\n    graph = {\n        0: [1, 2],\n        1: [3],\n        2: [4],\n        3: [],\n        4: []\n    }\n    start = 0\n    target = 4\n\n    Sample Output:\n    True\n    \"\"\"\n    visited = set()\n\n    def dfs(node: int) -> bool:\n        if node == target:\n            return True\n\n        visited.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n\n        return False\n\n    return dfs(start)\n\ndef g() -> Tuple[Dict[int, List[int]], int, int]:\n    graph = {\n        0: [1, 2],\n        1: [3],\n        2: [4],\n        3: [],\n        4: []\n    }\n    start = 0\n    target = 4\n    return graph, start, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 109,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, find the shortest path from node 0 to node N-1.\n    Return the shortest path as a list of nodes.\n\n    Example:\n    graph = [[1, 2], [0, 2, 3], [0, 1, 3], [1, 2]]\n\n    Output:\n    [0, 1, 3] (since the shortest path from node 0 to node N-1 is 0 -> 1 -> 3)\n    \"\"\"\n    from collections import deque\n    \n    queue = deque([(0, [0])])\n    visited = set()\n    \n    while queue:\n        node, path = queue.popleft()\n        visited.add(node)\n        \n        if node == len(graph) - 1:\n            return path\n        \n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                queue.append((neighbor, path + [neighbor]))\n    \n    return []\n\ndef g():\n    return [[1, 2], [0, 2, 3], [0, 1, 3], [1, 2]]\n\nassert f(g()) == [0, 1, 3]\n\n",
        "idx_generation": 187,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Given two integers n and k, return all possible combinations of k numbers out of the range [1, n].\n\n    Sample Input:\n    n = 4\n    k = 2\n\n    Sample Output:\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n    \"\"\"\n    def backtrack(start: int, curr_comb: List[int], result: List[List[int]]) -> None:\n        if len(curr_comb) == k:\n            result.append(curr_comb[:])\n            return\n        \n        for i in range(start, n + 1):\n            curr_comb.append(i)\n            backtrack(i + 1, curr_comb, result)\n            curr_comb.pop()\n\n    result = []\n    backtrack(1, [], result)\n    return result\n\n\ndef g(n = 4, k = 2):\n    return n, k\n\n\nassert f(*g()) == [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n",
        "idx_generation": 276,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target value, return all unique combinations of numbers from the list that sum to the target.\n    Each number in the list may only be used once.\n    The solution set must not contain duplicate combinations.\n\n    Sample Input:\n    arr = [10, 1, 2, 7, 6, 1, 5]\n    target = 8\n\n    Sample Output:\n    [\n        [1, 1, 6],\n        [1, 2, 5],\n        [1, 7],\n        [2, 6]\n    ]\n\n    Explanation:\n    The unique combinations of numbers that sum to 8 are [1, 1, 6], [1, 2, 5], [1, 7], and [2, 6].\n    \"\"\"\n    arr.sort()\n    result = []\n    def backtrack(path, start, target):\n        if target == 0:\n            result.append(path[:])\n            return\n        for i in range(start, len(arr)):\n            if i > start and arr[i] == arr[i-1]:\n                continue\n            if target - arr[i] < 0:\n                break\n            path.append(arr[i])\n            backtrack(path, i + 1, target - arr[i])\n            path.pop()\n    \n    backtrack([], 0, target)\n    return result\n\ndef g(arr = [10, 1, 2, 7, 6, 1, 5], target = 8):\n    return arr, target\n\nassert f(*g()) == [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n\n",
        "idx_generation": 199,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "import math\nfrom typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the count of numbers from 1 to n (inclusive) that have a repeated digit.\n\n    Example:\n    n = 20\n\n    Output:\n    1\n\n    Explanation:\n    The number 11 has a repeated digit.\n\n    Hint: Use mathematical principles to count the numbers with repeated digits.\n    \"\"\"\n\n    count = 0\n\n    for num in range(1, n + 1):\n        digits = set()\n\n        while num > 0:\n            digit = num % 10\n\n            if digit in digits:\n                count += 1\n                break\n\n            digits.add(digit)\n            num //= 10\n\n    return count\n\ndef g(n=20):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 243,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\n    Args:\n    - nums: A list of integers.\n    - target: An integer.\n\n    Returns:\n    - A list of two integers representing the indices of the two numbers.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation: The sum of nums[0] = 2 and nums[1] = 7 is 9, so the indices are [0, 1].\n    \"\"\"\n\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 487,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum cost to reach the bottom-right cell from the top-left cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7 (since the minimum cost to reach the bottom-right cell is 7: 1 + 3 + 1 + 1 + 1)\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g():\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n\n",
        "idx_generation": 135,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Find two numbers in the given array that sum up to the target value.\n    \n    Sample Input:\n    arr = [2, 7, 11, 15]\n    target = 9\n    \n    Sample Output:\n    [2, 7]\n    \n    Explanation:\n    The numbers 2 and 7 sum up to the target value of 9.\n    \"\"\"\n    num_dict = {}\n    \n    for num in arr:\n        complement = target - num\n        if complement in num_dict:\n            return [complement, num]\n        num_dict[num] = True\n    \n    return []\n\ndef g() -> List[int]:\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [2, 7]\n",
        "idx_generation": 258,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers nums, determine if it can be partitioned into two subsets such that the sum of\n    elements in both subsets is equal.\n\n    Example:\n    Input:\n    nums = [1, 5, 11, 5]\n\n    Output:\n    True\n\n    Explanation:\n    The array can be partitioned into [1, 5, 5] and [11] with equal sum.\n    \"\"\"\n    def subset_sum(nums: List[int], target: int) -> bool:\n        n = len(nums)\n        dp = [[False] * (target + 1) for _ in range(n + 1)]\n        \n        for i in range(n + 1):\n            dp[i][0] = True\n        \n        for i in range(1, n + 1):\n            for j in range(1, target + 1):\n                if nums[i - 1] <= j:\n                    dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        \n        return dp[n][target]\n    \n    total_sum = sum(nums)\n    \n    if total_sum % 2 != 0:\n        return False\n    \n    target = total_sum // 2\n    \n    return subset_sum(nums, target)\n\ndef g():\n    \"\"\"\n    Generate an array of integers with the following structure:\n    nums = [1, 5, 11, 5]\n    \"\"\"\n    return [1, 5, 11, 5]\n\nassert f(g()) == True\n",
        "idx_generation": 295,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of trailing zeros in n!.\n\n    Example:\n    n = 10\n    Output: 2\n    Explanation: 10! = 3628800, which has 2 trailing zeros.\n\n    \"\"\"\n    count = 0\n    i = 5\n    while (n / i >= 1):\n        count += int(n / i)\n        i *= 5\n    return count\n\ndef g(n: int = 10):\n    return n\n\nassert f(g()) == 2\n\n",
        "idx_generation": 401,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of these two numbers as a list.\n\n    Example:\n    Input: [2, 7, 11, 15], target = 9\n\n    Output: [0, 1]\n\n    Explanation:\n    The sum of the numbers at indices 0 and 1 is 2 + 7 = 9, which is equal to the target value.\n    \"\"\"\n\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []\n\ndef g(nums = [2, 7, 11, 15], target = 9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 446,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a prime number.\n\n    Args:\n    - n: The integer to be checked.\n\n    Returns:\n    - True if n is a prime number, False otherwise.\n\n    Example:\n    f(7)\n\n    Output:\n    True\n\n    Explanation:\n    7 is a prime number.\n    \"\"\"\n\n    if n <= 1:\n        return False\n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n\n    return True\n\ndef g() -> int:\n    \"\"\"\n    Generate an integer.\n\n    Returns:\n    - The generated integer.\n\n    Example:\n    g() returns 7\n    \"\"\"\n\n    return 7\n\nassert f(g()) == True\n",
        "idx_generation": 357,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\nfrom typing import List\n\ndef f(expression: str) -> bool:\n    \"\"\"\n    Given a string containing a mathematical expression, determine if the parentheses are balanced.\n\n    Example:\n    Input: \"(3 + 5) * (2 - 4)\"\n\n    Output: True\n\n    Explanation:\n    The parentheses in the expression are balanced, so the output is True.\n    \"\"\"\n\n    stack = []\n    for char in expression:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) == 0 or stack[-1] != '(':\n                return False\n            stack.pop()\n\n    return len(stack) == 0\n\ndef g(expression = \"(3 + 5) * (2 - 4)\"):\n    return expression\n\nassert f(g()) == True\n",
        "idx_generation": 446,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(graph: Dict[int, List[int]], start: int, target: int) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency list and two nodes start and target,\n    determine if there is a path from start to target in the graph.\n\n    Return True if there is a path, False otherwise.\n\n    Example:\n    graph = {\n        0: [1, 2],\n        1: [3, 4],\n        2: [5],\n        3: [],\n        4: [],\n        5: []\n    }\n    start = 0\n    target = 4\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 0 to node 4 in the graph.\n\n    Hint: Use depth-first search (DFS) or breadth-first search (BFS) to traverse the graph and check for a path.\n    \"\"\"\n\n    visited = set()\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n        if node == target:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n\n    return False\n\ndef g():\n    graph = {\n        0: [1, 2],\n        1: [3, 4],\n        2: [5],\n        3: [],\n        4: [],\n        5: []\n    }\n    start = 0\n    target = 4\n    return graph, start, target\n\nassert f(*g()) == True\n",
        "idx_generation": 382,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, count the number of islands.\n    An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.\n    \n    Example:\n    grid = [\n        ['1', '1', '0', '0', '0'],\n        ['1', '1', '0', '0', '0'],\n        ['0', '0', '1', '0', '0'],\n        ['0', '0', '0', '1', '1']\n    ]\n    \n    Output:\n    3 (since there are 3 islands in the grid)\n    \"\"\"\n    def dfs(grid, i, j):\n        if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] != '1':\n            return\n        grid[i][j] = '0'\n        dfs(grid, i+1, j)\n        dfs(grid, i-1, j)\n        dfs(grid, i, j+1)\n        dfs(grid, i, j-1)\n    \n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == '1':\n                count += 1\n                dfs(grid, i, j)\n    \n    return count\n\ndef g():\n    grid = [\n        ['1', '1', '0', '0', '0'],\n        ['1', '1', '0', '0', '0'],\n        ['0', '0', '1', '0', '0'],\n        ['0', '0', '0', '1', '1']\n    ]\n    return grid\n\nassert f(g()) == 3\n\n",
        "idx_generation": 282,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of words in it.\n    \"\"\"\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)\n\ndef g():\n    s = \"Hello World!\"\n    return s\n\nassert f(g()) == \"World! Hello\"\n",
        "idx_generation": 382,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n\n    Return the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n\n    Output:\n    3\n\n    Explanation:\n    The longest substring without repeating characters is \"abc\", which has a length of 3.\n    \"\"\"\n\n    char_set = set()\n    max_length = 0\n    left = 0\n\n    for right in range(len(s)):\n        while s[right] in char_set:\n            char_set.remove(s[left])\n            left += 1\n\n        char_set.add(s[right])\n        max_length = max(max_length, right - left + 1)\n\n    return max_length\n\ndef g() -> str:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    return \"abcabcbb\"\n\nassert f(g()) == 3\n",
        "idx_generation": 413,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if the k-th bit from the right is set (equal to 1).\n\n    Example:\n    n = 10, k = 2\n    The binary representation of 10 is 1010.\n    The 2nd bit from the right is set, so the output should be True.\n    \"\"\"\n    return (n >> (k-1)) & 1 == 1\n\ndef g(n=10, k=2):\n    return n, k\n\nassert f(*g()) == True\n",
        "idx_generation": 121,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two positive integers n and m, compute the value of n^m.\n\n    Args:\n    - n: A positive integer.\n    - m: A positive integer.\n\n    Returns:\n    - The value of n^m.\n    \"\"\"\n    if m == 0:\n        return 1\n    if m % 2 == 0:\n        half = f(n, m // 2)\n        return half * half\n    else:\n        half = f(n, (m - 1) // 2)\n        return half * half * n\n\ndef g(n=2, m=10):\n    \"\"\"\n    Generate two positive integers n and m.\n\n    Returns:\n    - n: A positive integer.\n    - m: A positive integer.\n    \"\"\"\n    return n, m\n\nassert f(*g()) == 1024\n",
        "idx_generation": 200,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix 'graph', and two vertices 'start' and 'end', determine if there is a path from 'start' to 'end' in the graph.\n\n    Example:\n    graph = [[0, 1, 0, 0],\n             [0, 0, 1, 0],\n             [0, 0, 0, 1],\n             [0, 0, 0, 0]]\n    start = 0\n    end = 3\n\n    Output:\n    True (there is a path from vertex 0 to vertex 3: 0 -> 1 -> 2 -> 3)\n    \"\"\"\n    stack = [start]\n    visited = set()\n\n    while stack:\n        node = stack.pop()\n        visited.add(node)\n\n        if node == end:\n            return True\n\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] == 1 and neighbor not in visited:\n                stack.append(neighbor)\n\n    return False\n\ndef g():\n    graph = [[0, 1, 0, 0],\n             [0, 0, 1, 0],\n             [0, 0, 0, 1],\n             [0, 0, 0, 0]]\n    start = 0\n    end = 3\n    return (graph, start, end)\n\nassert f(*g()) == True\n",
        "idx_generation": 328,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> int:\n    \"\"\"\n    Given a binary tree, find the maximum depth of the tree.\n    \"\"\"\n    if not root:\n        return 0\n    return 1 + max(f(root.left), f(root.right))\n\ndef g() -> TreeNode:\n    \"\"\"\n    Build a binary tree with maximum depth of 3.\n    \"\"\"\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    return root\n\nassert f(g()) == 3\n",
        "idx_generation": 110,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there is a path from start to end in the graph\"\"\"\n    visited = set()\n\n    def dfs(node):\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n        return False\n\n    return dfs(start)\n\ndef g():\n    graph = [[1, 2], [2, 3], [4], [4], []]\n    start = 0\n    end = 4\n    return graph, start, end\n\nassert f(*g())\n",
        "idx_generation": 198,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, arr: List[int]) -> bool:\n    \"\"\"\n    Check if there are exactly n pairs of numbers in the given list that sum up to zero.\n\n    Example:\n    n = 2\n    arr = [1, -1, 2, -2, 3]\n    Output: True\n\n    Hint: Use combinatorics to count the number of pairs that sum up to zero.\n    \"\"\"\n\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] + arr[j] == 0:\n                count += 1\n\n    return count == n\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, -1, 2, -2, 3]\n\nassert f(2, g()) == True\n\n",
        "idx_generation": 296,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int, nums: List[int]) -> int:\n    \"\"\"\n    Given an integer n, find the number of ways to select k elements from the list nums.\n    \"\"\"\n    def helper(n: int, k: int) -> int:\n        if k == 0 or k == n:\n            return 1\n        return helper(n-1, k-1) + helper(n-1, k)\n    \n    return helper(n, k)\n\ndef g() -> Tuple[int, int, List[int]]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    n = 5\n    k = 3\n    nums = [1, 2, 3, 4, 5]\n    return n, k, nums\n\nassert f(*g()) == 10\n\n",
        "idx_generation": 199,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], target: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a target string, find all words in the list that are anagrams of the target string.\n\n    Example:\n    words = [\"cat\", \"dog\", \"tac\", \"god\", \"act\"]\n    target = \"act\"\n\n    Output:\n    [\"cat\", \"tac\", \"act\"]\n    \"\"\"\n    target_count = [0] * 26\n    for char in target:\n        target_count[ord(char) - ord('a')] += 1\n\n    anagrams = []\n    for word in words:\n        if len(word) == len(target):\n            word_count = [0] * 26\n            for char in word:\n                word_count[ord(char) - ord('a')] += 1\n            if word_count == target_count:\n                anagrams.append(word)\n    \n    return anagrams\n\ndef g():\n    return [\"cat\", \"dog\", \"tac\", \"god\", \"act\"], \"act\"\n\nassert f(*g()) == [\"cat\", \"tac\", \"act\"]\n",
        "idx_generation": 254,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, find the index of the target value in the list using binary search.\n    If the target value is not found, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g():\n    nums = [1, 3, 5, 7, 9]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 3\n\n",
        "idx_generation": 488,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], x: int) -> bool:\n    \"\"\"\n    Check if there exists a pair of elements in the given sorted array that adds up to the target value x.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    \n    while left < right:\n        if arr[left] + arr[right] == x:\n            return True\n        elif arr[left] + arr[right] < x:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    arr = [1, 2, 4, 6, 8, 10]\n    x = 14\n    return arr, x\n\nassert f(*g()) == True\n\n",
        "idx_generation": 144,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> int:\n    \"\"\"\n    Given a list of words, return the length of the longest common prefix among all words.\n\n    Example:\n    words = [\"flower\", \"flow\", \"flight\"]\n\n    Output:\n    2\n\n    Explanation:\n    The longest common prefix among all words is \"fl\".\n    \"\"\"\n    if len(words) == 0:\n        return 0\n    \n    prefix = words[0]\n    for word in words[1:]:\n        while word[:len(prefix)] != prefix:\n            prefix = prefix[:-1]\n            if len(prefix) == 0:\n                return 0\n    \n    return len(prefix)\n\ndef g():\n    return [\"flower\", \"flow\", \"flight\"]\n\nassert f(g()) == 2\n\n",
        "idx_generation": 259,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array of integers 'nums' and a target integer 'target', find all unique combinations in 'nums' where the sum of the elements is equal to 'target'. Each number in 'nums' may only be used once in each combination. The combinations should be returned as a list of lists.\n    \"\"\"\n    def backtrack(nums: List[int], target: int, start: int, path: List[int], res: List[List[int]]):\n        if target < 0:\n            return\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            backtrack(nums, target-nums[i], i+1, path+[nums[i]], res)\n    \n    nums.sort()\n    res = []\n    backtrack(nums, target, 0, [], res)\n    return res\n\ndef g() -> Tuple[List[int], int]:\n    return ([10,1,2,7,6,1,5], 8)\n\nassert f(*g()) == [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n",
        "idx_generation": 300,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, calculate the sum of all elements in the matrix.\n\n    Sample Input:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Sample Output:\n    45\n    \"\"\"\n    total_sum = 0\n    for row in matrix:\n        for num in row:\n            total_sum += num\n\n    return total_sum\n\ndef g() -> List[List[int]]:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == 45\n",
        "idx_generation": 404,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that sum up to the target value.\n    Return a list containing the indices of these two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    The numbers at indices 0 and 1 (2 and 7) sum up to the target value 9.\n    Return the list [0, 1].\n    \"\"\"\n    num_dict = {}\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[nums[i]] = i\n    return []\n\ndef g():\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 449,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray that contains only positive numbers.\n    Return 0 if there is no such subarray.\n\n    Example:\n    nums = [1, -2, 3, 4, -5, 2]\n\n    Output:\n    7\n\n    Explanation:\n    The subarray with the maximum sum that contains only positive numbers is [3, 4].\n\n    Hint: Use a sliding window approach to iterate through the list of numbers and keep track of the maximum sum.\n    \"\"\"\n    max_sum = 0\n    curr_sum = 0\n\n    for num in nums:\n        if num > 0:\n            curr_sum += num\n        else:\n            curr_sum = 0\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g(nums: List[int] = [1, -2, 3, 4, -5, 2]):\n    return nums\n\nassert f(g()) == 7\n\n",
        "idx_generation": 361,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(expression: str) -> bool:\n    \"\"\"\n    Given a string containing parentheses, determine if the parentheses are balanced. A string is considered balanced if it consists of opening and closing parentheses that are properly nested.\n\n    Sample Input:\n    expression = \"((())())\"\n\n    Sample Output:\n    True\n    \"\"\"\n    stack = []\n    for char in expression:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n\n    return len(stack) == 0\n\ndef g(expression=\"((())())\"):\n    return expression\n\nassert f(g()) == True\n",
        "idx_generation": 448,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum path sum from the top-left cell to the bottom-right cell. You can only move down or right.\n\n    Args:\n    - grid: A 2D grid of integers.\n\n    Returns:\n    - The minimum path sum from the top-left cell to the bottom-right cell.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g(grid=[[1,3,1],[1,5,1],[4,2,1]]):\n    return grid\n\nassert f(g()) == 7\n\n",
        "idx_generation": 383,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 0 represents an empty cell and 1 represents an obstacle, find the number of unique paths from the top-left cell to the bottom-right cell.\n    You can only move down or right, and you cannot move through obstacles.\n\n    Example:\n    grid = [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]\n\n    Output:\n    2\n\n    Hint: Use dynamic programming to store the number of unique paths for each cell.\n    \"\"\"\n\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                dp[i][j] = 0\n            elif i == 0 and j == 0:\n                dp[i][j] = 1\n            elif i == 0:\n                dp[i][j] = dp[i][j - 1]\n            elif j == 0:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[m - 1][n - 1]\n\ndef g():\n    grid = [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]\n    return grid\n\nassert f(g()) == 2\n\n",
        "idx_generation": 289,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse each word in the string while maintaining the order of the words.\n\n    Return the reversed string.\n\n    Example:\n    s = \"Hello World\"\n\n    Output:\n    \"olleH dlroW\"\n\n    Explanation:\n    Each word in the string is reversed while maintaining the order of the words.\n\n    Hint: Split the string into words, reverse each word, and then join the reversed words back into a string.\n    \"\"\"\n\n    words = s.split()\n    reversed_words = [word[::-1] for word in words]\n    reversed_string = ' '.join(reversed_words)\n\n    return reversed_string\n\ndef g():\n    s = \"Hello World\"\n    return s\n\nassert f(g()) == \"olleH dlroW\"\n",
        "idx_generation": 382,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string, find the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n\n    Output:\n    3\n\n    Explanation:\n    The longest substring without repeating characters is \"abc\", which has a length of 3.\n    \"\"\"\n\n    max_length = 0\n    start = 0\n    char_map = {}\n\n    for i in range(len(s)):\n        if s[i] in char_map and start <= char_map[s[i]]:\n            start = char_map[s[i]] + 1\n        else:\n            max_length = max(max_length, i - start + 1)\n        char_map[s[i]] = i\n\n    return max_length\n\ndef g(s: str = \"abcabcbb\"):\n    \"\"\"\n    Generate a string for the function f.\n    \"\"\"\n    return s\n\nassert f(g()) == 3\n",
        "idx_generation": 427,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine if a given number is a power of 2 and also a perfect square.\n    \"\"\"\n    return (n & (n - 1) == 0) and (int(n ** 0.5) ** 2 == n)\n\ndef g():\n    n = 64\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 125,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth number in the Fibonacci sequence.\n    The Fibonacci sequence is defined as follows:\n    F(0) = 0\n    F(1) = 1\n    F(n) = F(n-1) + F(n-2), for n > 1\n    \"\"\"\n    if n == 0:\n        return 0\n    \n    if n == 1:\n        return 1\n    \n    dp = [0] * (n+1)\n    dp[0] = 0\n    dp[1] = 1\n    \n    for i in range(2, n+1):\n        dp[i] = dp[i-1] + dp[i-2]\n    \n    return dp[n]\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 5\n",
        "idx_generation": 206,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Determine if there is a path from the start node to the end node in a directed graph.\n    \"\"\"\n    visited = [False] * len(graph)\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if not visited[node]:\n            visited[node] = True\n            stack.extend(graph[node])\n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a directed graph with 5 nodes and random edges.\n    \"\"\"\n    return [[1, 2], [2, 3], [3, 4], [4, 0], [0, 1], [1, 3]]\n\nassert f(g(), 0, 4)\n\n",
        "idx_generation": 362,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the number of islands in the grid. An island is defined as a group of connected 1s.\n\n    Args:\n    - grid: A 2D grid represented as a list of lists.\n\n    Returns:\n    - The number of islands in the grid.\n    \"\"\"\n    def dfs(grid, row, col):\n        if row < 0 or col < 0 or row >= len(grid) or col >= len(grid[0]) or grid[row][col] != 1:\n            return\n\n        grid[row][col] = -1\n\n        dfs(grid, row - 1, col)\n        dfs(grid, row + 1, col)\n        dfs(grid, row, col - 1)\n        dfs(grid, row, col + 1)\n\n    count = 0\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                dfs(grid, i, j)\n                count += 1\n\n    return count\n\ndef g():\n    grid = [[1, 1, 0, 0, 0],\n            [1, 1, 0, 0, 0],\n            [0, 0, 1, 0, 0],\n            [0, 0, 0, 1, 1]]\n    return grid\n\nassert f(g()) == 3\n",
        "idx_generation": 117,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Determine if there exists a path from the start node to the end node in a directed graph.\n    \"\"\"\n\n    def dfs(node, visited):\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited):\n                    return True\n        return False\n\n    visited = set()\n    return dfs(start, visited)\n\ndef g():\n    graph = [[1, 2], [2], []]\n    start = 0\n    end = 2\n    return graph, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 207,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[int]:\n    \"\"\"\n    Given two integers n and k, generate all possible combinations of k numbers out of the range [1, n].\n    Return the combinations as a list of lists.\n\n    Example:\n    n = 4\n    k = 2\n\n    Output:\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n\n    Explanation:\n    There are six possible combinations of two numbers from the range [1, 4].\n    \"\"\"\n\n    def backtrack(start, curr_comb):\n        if len(curr_comb) == k:\n            result.append(curr_comb[:])\n        else:\n            for i in range(start, n + 1):\n                curr_comb.append(i)\n                backtrack(i + 1, curr_comb)\n                curr_comb.pop()\n\n    result = []\n    backtrack(1, [])\n    return result\n\ndef g(n=4, k=2):\n    return n, k\n\nassert f(*g()) == [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n\n",
        "idx_generation": 311,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two positive integers n and k, calculate the number of different combinations of choosing k elements from a set of n elements.\n\n    Sample Input:\n    n = 5\n    k = 3\n\n    Sample Output:\n    10\n    Explanation: There are 10 different combinations of choosing 3 elements from a set of 5 elements: (1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5), (1, 4, 5), (2, 3, 4), (2, 3, 5), (2, 4, 5), (3, 4, 5).\n    \"\"\"\n    if k == 0 or k == n:\n        return 1\n    else:\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][0] = 1\n        for i in range(1, n + 1):\n            for j in range(1, min(i, k) + 1):\n                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]\n        return dp[n][k]\n\ndef g(n=5, k=3):\n    return n, k\n\nassert f(*g()) == 10\n\n",
        "idx_generation": 203,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "import itertools\nfrom typing import*\nfrom typing import *\nfrom itertools import permutations\n\ndef f(s: str, n: int) -> List[str]:\n    \"\"\"\n    Find all possible permutations of a string with length n.\n\n    Given a string s and an integer n, return a list of all possible permutations of s with length n.\n\n    Example:\n    s = \"abc\"\n    n = 2\n    output: [\"ab\", \"ac\", \"ba\", \"bc\", \"ca\", \"cb\"]\n    \"\"\"\n\n    perms = [''.join(permutation) for permutation in permutations(s, n)]\n    return perms\n\ndef g(s=\"abc\", n=2):\n    return s, n\n\nassert f(*g()) == [\"ab\", \"ac\", \"ba\", \"bc\", \"ca\", \"cb\"]\n\n",
        "idx_generation": 271,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers as a list.\n\n    Note: You may assume that each input would have exactly one solution, and you may not use the same element twice.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    nums[0] + nums[1] = 2 + 7 = 9, so the indices are [0, 1].\n\n    Hint: Use a dictionary to store the complement of each number as you iterate through the list. Check if the complement exists in the dictionary, and if so, return the indices.\n    \"\"\"\n    complement_map = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        if complement in complement_map:\n            return [complement_map[complement], i]\n        \n        complement_map[num] = i\n    \n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 488,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, find two numbers in the list that\n    add up to the target. Return the indices of the two numbers.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g():\n    return [2, 3, 4, 7, 11]\n\nassert f(g(), 9) == [0, 3]\n\n",
        "idx_generation": 150,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], word1: str, word2: str) -> int:\n    \"\"\"\n    Given a list of words and two words word1 and word2, return the shortest distance between word1 and word2 in the list.\n\n    Sample Input:\n    words = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"]\n    word1 = \"coding\"\n    word2 = \"practice\"\n\n    Sample Output:\n    3\n\n    Explanation:\n    The shortest distance between \"coding\" and \"practice\" is 3 (coding -> makes -> practice).\n    \"\"\"\n    min_distance = len(words)\n    index1, index2 = -1, -1\n    for i in range(len(words)):\n        if words[i] == word1:\n            index1 = i\n            if index2 != -1:\n                min_distance = min(min_distance, abs(index1 - index2))\n        elif words[i] == word2:\n            index2 = i\n            if index1 != -1:\n                min_distance = min(min_distance, abs(index1 - index2))\n    return min_distance\n\ndef g(words = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"], word1 = \"coding\", word2 = \"practice\"):\n    return words, word1, word2\n\nassert f(*g()) == 3\n",
        "idx_generation": 261,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of trailing zeros in n factorial.\n\n    Example:\n    n = 5\n\n    Output:\n    1\n\n    Explanation:\n    5 factorial is 120, which has 1 trailing zero.\n\n    Hint: The number of trailing zeros in n factorial is equal to the number of times n is divisible by 5.\n    \"\"\"\n\n    count = 0\n\n    while n >= 5:\n        n //= 5\n        count += n\n\n    return count\n\ndef g() -> int:\n    n = 10\n    return n\n\nassert f(g()) == 2\n",
        "idx_generation": 301,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of trailing zeros in n! (n factorial).\n\n    Example:\n    n = 5\n\n    Output:\n    1\n\n    Explanation:\n    5! = 5 * 4 * 3 * 2 * 1 = 120\n    The number of trailing zeros in 120 is 1.\n    \"\"\"\n\n    count = 0\n    i = 5\n\n    while n // i >= 1:\n        count += n // i\n        i *= 5\n\n    return count\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return 10\n\nassert f(g()) == 2\n\n",
        "idx_generation": 430,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if they are isomorphic.\n\n    Two strings are isomorphic if the characters in s can be replaced to get t.\n\n    Example:\n    s = \"egg\", t = \"add\"\n\n    Output:\n    True\n\n    Explanation:\n    The characters 'e' and 'a' can be replaced with 'a' and 'd' respectively to get t.\n\n    \"\"\"\n    if len(s) != len(t):\n        return False\n\n    char_map = {}\n    used_chars = set()\n\n    for i in range(len(s)):\n        if s[i] in char_map:\n            if char_map[s[i]] != t[i]:\n                return False\n        else:\n            if t[i] in used_chars:\n                return False\n            char_map[s[i]] = t[i]\n            used_chars.add(t[i])\n\n    return True\n\ndef g() -> Tuple[str, str]:\n    \"\"\"\n    Generate two isomorphic strings.\n    \"\"\"\n    return (\"egg\", \"add\")\n\nassert f(*g())\n\n",
        "idx_generation": 362,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where all the duplicates are removed and the remaining elements are in the same order as the original list.\n\n    Example:\n    nums = [1, 2, 3, 2, 4, 3, 5, 6, 4]\n\n    Output:\n    [1, 2, 3, 4, 5, 6]\n    \"\"\"\n\n    stack = []\n    seen = set()\n\n    for num in nums:\n        if num not in seen:\n            stack.append(num)\n            seen.add(num)\n\n    return stack\n\ndef g() -> List[int]:\n    return [1, 2, 3, 2, 4, 3, 5, 6, 4]\n\nassert f(g()) == [1, 2, 3, 4, 5, 6]\n",
        "idx_generation": 449,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray within the list.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The maximum sum of a subarray within the list.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n\n    Explanation:\n    The subarray with the maximum sum is [4, -1, 2, 1], which sums up to 6.\n\n    Hint: Use dynamic programming to solve this problem.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    current_sum = nums[0]\n    max_sum = nums[0]\n\n    for i in range(1, len(nums)):\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 383,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid represented as a list of lists of integers, find the minimum path sum from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    The minimum path sum is 7.\n\n    Return the minimum path sum.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid represented as a list of lists of integers.\n    \"\"\"\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\n\nassert f(g()) == 7\n",
        "idx_generation": 295,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of all the words in the string while maintaining the order of the characters within each word.\n\n    Example:\n    s = \"Hello World!\"\n\n    Output:\n    \"World! Hello\"\n    \"\"\"\n    words = s.split()\n    return ' '.join(words[::-1])\n\ndef g() -> str:\n    s = \"Hello World!\"\n    return s\n\nassert f(g()) == \"World! Hello\"\n",
        "idx_generation": 386,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, return a new list where each string is reversed.\n\n    Example:\n    strings = [\"hello\", \"world\", \"python\"]\n\n    Output:\n    [\"olleh\", \"dlrow\", \"nohtyp\"]\n\n    Hint: Use recursion to reverse each string in the list.\n    \"\"\"\n\n    def reverse_string(string):\n        if len(string) <= 1:\n            return string\n        return reverse_string(string[1:]) + string[0]\n\n    return [reverse_string(string) for string in strings]\n\ndef g() -> List[str]:\n    strings = [\"hello\", \"world\", \"python\"]\n    return [strings]\n\nassert f(*g()) == [\"olleh\", \"dlrow\", \"nohtyp\"]\n\n",
        "idx_generation": 439,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nimport math\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of bits required to represent n in binary form.\n\n    Example:\n    n = 10\n\n    Output:\n    4 (since 10 in binary form is 1010, which requires 4 bits)\n    \"\"\"\n    return math.floor(math.log2(n)) + 1\n\ndef g():\n    return 10\n\nassert f(g()) == 4\n\n",
        "idx_generation": 135,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Find the nth Fibonacci number using matrix exponentiation.\n    \"\"\"\n    def multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        C = [[0, 0], [0, 0]]\n        for i in range(2):\n            for j in range(2):\n                for k in range(2):\n                    C[i][j] += A[i][k] * B[k][j]\n        return C\n\n    def power(A: List[List[int]], n: int) -> List[List[int]]:\n        if n == 0:\n            return [[1, 0], [0, 1]]\n        elif n == 1:\n            return A\n        elif n % 2 == 0:\n            X = power(A, n // 2)\n            return multiply(X, X)\n        else:\n            X = power(A, (n - 1) // 2)\n            return multiply(multiply(X, X), A)\n\n    A = [[1, 1], [1, 0]]\n    result = power(A, n)\n    return result[0][1]\n\ndef g(n=10):\n    return n\n\nassert f(g()) == 55\n",
        "idx_generation": 207,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(matrix: List[List[int]], target: int) -> Tuple[int, int]:\n    \"\"\"\n    Given a matrix of integers and a target value, find the position (row and column indices) of the target value in the matrix.\n\n    Example:\n    Input: matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], target = 5\n    Output: (1, 1)\n    Explanation: The target value 5 is located at position (1, 1) in the matrix.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    # Perform a modified BFS using a queue\n    queue = [(0, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    visited[0][0] = True\n\n    while queue:\n        curr_row, curr_col = queue.pop(0)\n\n        if matrix[curr_row][curr_col] == target:\n            return curr_row, curr_col\n\n        # Explore adjacent cells\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_row = curr_row + dr\n            next_col = curr_col + dc\n\n            if 0 <= next_row < rows and 0 <= next_col < cols and not visited[next_row][next_col]:\n                queue.append((next_row, next_col))\n                visited[next_row][next_col] = True\n\n    return -1, -1\n\ndef g() -> Tuple[List[List[int]], int]:\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    target = 5\n    return matrix, target\n\nassert f(*g()) == (1, 1)\n",
        "idx_generation": 377,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if it is possible to reach the bottom-right cell from the top-left cell in a grid.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    memo = [[False] * cols for _ in range(rows)]\n    \n    def dfs(row, col):\n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] == 0:\n            return False\n        if row == rows - 1 and col == cols - 1:\n            return True\n        if memo[row][col]:\n            return False\n        \n        memo[row][col] = True\n        return dfs(row + 1, col) or dfs(row, col + 1)\n    \n    return dfs(0, 0)\n\ndef g(grid=[[1, 1, 1], [0, 0, 1], [0, 1, 1]]):\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 119,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> int:\n    \"\"\"\n    Given a directed acyclic graph represented as an adjacency list and two nodes start and end,\n    find the minimum number of edges to be traversed from start to end.\n    Return -1 if there is no path from start to end.\n\n    Example:\n    f([[1, 2], [3], [3], []], 0, 3) returns 2, as the minimum number of edges to be traversed from node 0 to node 3 is 2.\n\n    Note:\n    - The graph is represented as an adjacency list where graph[i] is a list of nodes that can be reached from node i.\n    - The graph is guaranteed to be a directed acyclic graph (DAG).\n    - The start and end nodes are guaranteed to be valid nodes in the graph.\n    \"\"\"\n\n    from collections import deque\n\n    # Initialize the queue with the start node\n    queue = deque([(start, 0)])\n\n    # Initialize the visited set to keep track of visited nodes\n    visited = set([start])\n\n    while queue:\n        node, distance = queue.popleft()\n\n        # Check if the current node is the end node\n        if node == end:\n            return distance\n\n        # Explore all neighbors of the current node\n        for neighbor in graph[node]:\n            # Check if the neighbor has not been visited\n            if neighbor not in visited:\n                # Add the neighbor to the queue with an increased distance\n                queue.append((neighbor, distance + 1))\n                # Mark the neighbor as visited\n                visited.add(neighbor)\n\n    # If no path is found from start to end, return -1\n    return -1\n\n\ndef g() -> Tuple[List[List[int]], int, int]:\n    \"\"\"\n    Generate a directed acyclic graph represented as an adjacency list,\n    and select two nodes start and end.\n\n    Example:\n    g() returns ([[1, 2], [3], [3], []], 0, 3)\n\n    Note:\n    - The generated graph should be a directed acyclic graph (DAG).\n    - The start and end nodes should be valid nodes in the graph.\n    \"\"\"\n\n    graph = [[1, 2], [3], [3], []]\n    start = 0\n    end = 3\n\n    return graph, start, end\n\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 209,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers n and m, find the number of ways to reach the point (n, m) from the point (0, 0) by only moving right or up.\n    You can only move right or up.\n\n    Args:\n    - n: The number of rows.\n    - m: The number of columns.\n\n    Returns:\n    - The number of ways to reach the point (n, m) from the point (0, 0).\n    \"\"\"\n\n    def factorial(num: int) -> int:\n        \"\"\"\n        Compute the factorial of a number.\n\n        Args:\n        - num: An integer.\n\n        Returns:\n        - The factorial of the number.\n        \"\"\"\n        result = 1\n\n        for i in range(1, num+1):\n            result *= i\n\n        return result\n\n    def combinations(n: int, r: int) -> int:\n        \"\"\"\n        Compute the number of combinations of n choose r.\n\n        Args:\n        - n: An integer.\n        - r: An integer.\n\n        Returns:\n        - The number of combinations of n choose r.\n        \"\"\"\n        return factorial(n) // (factorial(r) * factorial(n-r))\n\n    return combinations(n+m-2, n-1)\n\ndef g() -> List[int]:\n    n = 3\n    m = 4\n    return n, m\n\nassert f(*g()) == 10\n",
        "idx_generation": 315,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, return all possible permutations of the numbers.\n    \"\"\"\n    def backtrack(first):\n        if first == n:\n            output.append(nums[:])\n        for i in range(first, n):\n            nums[first], nums[i] = nums[i], nums[first]\n            backtrack(first + 1)\n            nums[first], nums[i] = nums[i], nums[first]\n\n    n = len(nums)\n    output = []\n    backtrack(0)\n    return output\n\ndef g():\n    nums = [1, 2, 3]\n    return nums\n\nassert f(g()) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]\n",
        "idx_generation": 204,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of characters in each word within the string.\n\n    Return the modified string.\n\n    Example:\n    s = \"hello world\"\n\n    Output:\n    \"olleh dlrow\"\n\n    Explanation:\n    The word \"hello\" is reversed to \"olleh\" and the word \"world\" is reversed to \"dlrow\".\n    \"\"\"\n\n    def reverse_word(word):\n        return word[::-1]\n\n    words = s.split()\n    reversed_words = [reverse_word(word) for word in words]\n    reversed_string = ' '.join(reversed_words)\n\n    return reversed_string\n\ndef g(s=\"hello world\"):\n    return s\n\nassert f(g()) == \"olleh dlrow\"\n\n",
        "idx_generation": 272,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target integer, determine if there are two numbers in the list that add up to the target.\n\n    Return True if there exists two numbers that add up to the target, False otherwise.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    Output:\n    True\n\n    Explanation:\n    There exists 2 and 5 in the list that add up to 7.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        total = nums[left] + nums[right]\n        if total == target:\n            return True\n        elif total < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 488,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n    \"\"\"\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g(nums=[10, 9, 2, 5, 3, 7, 101, 18]):\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 152,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return the words in sorted order based on their length.\n    If two words have the same length, sort them in lexicographical order.\n\n    Sample Input:\n    words = [\"apple\", \"banana\", \"cat\", \"dog\", \"elephant\"]\n\n    Sample Output:\n    [\"cat\", \"dog\", \"apple\", \"banana\", \"elephant\"]\n    \"\"\"\n    words.sort(key=lambda x: (len(x), x))\n    return words\n\ndef g() -> List[str]:\n    words = [\"apple\", \"banana\", \"cat\", \"dog\", \"elephant\"]\n    return (words,)\n\nassert f(*g()) == [\"cat\", \"dog\", \"apple\", \"banana\", \"elephant\"]\n",
        "idx_generation": 264,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, return all possible permutations of the numbers.\n\n    Example:\n    nums = [1, 2, 3]\n\n    Output:\n    [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n    Explanation:\n    The possible permutations of the numbers 1, 2, and 3 are [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n    \"\"\"\n    def backtrack(nums, path, res):\n        if not nums:\n            res.append(path)\n        for i in range(len(nums)):\n            backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n    \n    res = []\n    backtrack(nums, [], res)\n    return res\n\ndef g():\n    return [[1, 2, 3]]\n\nassert f(*g()) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n",
        "idx_generation": 340,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the sum of all the multiples of 3 or 5 below n.\n\n    Example:\n    n = 10\n\n    Output:\n    23\n\n    Explanation:\n    The multiples of 3 or 5 below 10 are 3, 5, 6, and 9. Their sum is 23.\n    \"\"\"\n\n    total_sum = 0\n    for num in range(n):\n        if num % 3 == 0 or num % 5 == 0:\n            total_sum += num\n\n    return total_sum\n\n\ndef g() -> int:\n    return 10\n\n\nassert f(g()) == 23\n\n",
        "idx_generation": 433,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists two numbers in the list whose sum is equal to the target.\"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(nums: List[int] = [5, 2, 7, 3, 1], target: int = 9) -> List[int]:\n    \"\"\"Generate a list of integers and a target number.\"\"\"\n    return nums, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 362,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth number in the Fibonacci sequence.\n\n    Args:\n    - n: A positive integer.\n\n    Returns:\n    - The nth number in the Fibonacci sequence.\n\n    Example:\n    n = 6\n    Output: 8\n\n    Explanation:\n    The Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, ...\n    The 6th number in the sequence is 8.\n\n    Hint: Use recursion to solve this problem.\n    \"\"\"\n\n    if n <= 1:\n        return n\n\n    return f(n - 1) + f(n - 2)\n\ndef g() -> int:\n    n = 6\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 383,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers where each cell represents the cost to travel through that cell,\n    find the minimum cost to travel from the top-left cell to the bottom-right cell.\n    You can only move down, right, or diagonally.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    \n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g(grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(g()) == 5\n",
        "idx_generation": 299,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if a string is a valid palindrome after removing at most one character.\n\n    Args:\n    - s: A string.\n\n    Returns:\n    - True if the string is a valid palindrome after removing at most one character, False otherwise.\n    \"\"\"\n    i = 0\n    j = len(s) - 1\n    while i < j:\n        if s[i] != s[j]:\n            return is_palindrome(s, i + 1, j) or is_palindrome(s, i, j - 1)\n        i += 1\n        j -= 1\n    return True\n\ndef is_palindrome(s: str, i: int, j: int) -> bool:\n    while i < j:\n        if s[i] != s[j]:\n            return False\n        i += 1\n        j -= 1\n    return True\n\ndef g():\n    s = \"abca\"\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 387,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a valid palindrome after deleting at most one character.\n\n    Args:\n    - s: The input string.\n\n    Returns:\n    - True if the string is a valid palindrome after deleting at most one character, False otherwise.\n    \"\"\"\n    def is_palindrome(s: str, left: int, right: int, deleted: int) -> bool:\n        while left < right:\n            if s[left] != s[right]:\n                if deleted == 1:\n                    return False\n                return is_palindrome(s, left + 1, right, deleted + 1) or is_palindrome(s, left, right - 1, deleted + 1)\n            left += 1\n            right -= 1\n        return True\n\n    return is_palindrome(s, 0, len(s) - 1, 0)\n\ndef g() -> str:\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"abca\"\n\nassert f(g()) == True\n\n",
        "idx_generation": 447,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(string: str) -> str:\n    \"\"\"\n    Reverse the bits of a given 32-bit unsigned integer.\n\n    Sample Input:\n    string = \"00000010100101000001111010011100\"\n\n    Sample Output:\n    \"00111001011110000010100101000000\"\n    \"\"\"\n    reversed_bits = string[::-1]\n    return reversed_bits\n\ndef g(string=\"00000010100101000001111010011100\"):\n    return string\n\nassert f(g()) == \"00111001011110000010100101000000\"\n",
        "idx_generation": 140,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the sum of the first n Fibonacci numbers.\n\n    Example:\n    n = 5\n    Output: 12 (1 + 1 + 2 + 3 + 5 = 12)\n    \"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        fib = [0, 1]\n        for i in range(2, n+1):\n            fib.append(fib[i-1] + fib[i-2])\n        return sum(fib)\n\ndef g(n: int = 5):\n    return n\n\nassert f(g()) == 12\n",
        "idx_generation": 220,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> List[int]:\n    \"\"\"\n    Given the root of a binary tree, return the inorder traversal of its nodes' values.\n\n    Example:\n    Input: [1,null,2,3]\n    Output: [1,3,2]\n    \"\"\"\n    result = []\n    stack = []\n    curr = root\n\n    while curr or stack:\n        while curr:\n            stack.append(curr)\n            curr = curr.left\n        \n        curr = stack.pop()\n        result.append(curr.val)\n        curr = curr.right\n    \n    return result\n\ndef g():\n    # Creating a binary tree\n    root = TreeNode(1)\n    root.right = TreeNode(2)\n    root.right.left = TreeNode(3)\n    return root\n\nassert f(g()) == [1, 3, 2]\n",
        "idx_generation": 413,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    Find the maximum path sum in a directed acyclic graph (DAG).\n\n    Given a number of nodes and a list of directed edges in the form of [source, destination, weight],\n    find the maximum sum of weights along any path in the graph.\n\n    Example:\n    n = 5\n    edges = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5]]\n    output: 14\n\n    Explanation:\n    The graph has 5 nodes and the edges are [0->1, 1->2, 2->3, 3->4].\n    The maximum path sum is 14, which is achieved by the path 0->1->2->3->4 with weights [2, 3, 4, 5].\n\n    Assumptions:\n    - The input graph is a directed acyclic graph (DAG).\n    \"\"\"\n    graph = {}\n    for edge in edges:\n        source, destination, weight = edge\n        if source not in graph:\n            graph[source] = []\n        graph[source].append((destination, weight))\n    \n    def dfs(node):\n        if node not in graph:\n            return 0\n        \n        max_sum = float('-inf')\n        for neighbor, weight in graph[node]:\n            max_sum = max(max_sum, weight + dfs(neighbor))\n        \n        return max_sum\n    \n    max_path_sum = float('-inf')\n    for node in range(n):\n        max_path_sum = max(max_path_sum, dfs(node))\n    \n    return max_path_sum\n\ndef g(n=5, edges=[[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5]]):\n    return n, edges\n\nassert f(*g()) == 14\n\n",
        "idx_generation": 120,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix and two vertices start and end,\n    determine if there is a path from start to end in the graph.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from vertex 0 to vertex 3: 0 -> 1 -> 3\n\n    Hint: Use a combination of sorting, searching, recursion, and dynamic programming to traverse the graph and find a path from start to end.\n    \"\"\"\n    if start == end:\n        return True\n    \n    visited = [False] * len(graph)\n    visited[start] = True\n    \n    stack = [start]\n    while stack:\n        curr = stack.pop()\n        for neighbor, connected in enumerate(graph[curr]):\n            if connected and not visited[neighbor]:\n                if neighbor == end:\n                    return True\n                stack.append(neighbor)\n                visited[neighbor] = True\n    \n    return False\n\ndef g() -> Tuple[List[List[int]], int, int]:\n    \"\"\"\n    Generate a directed graph represented as an adjacency matrix, and two vertices start and end.\n    \"\"\"\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n    return graph, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 213,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, find the number of ways to choose k elements from a set of n elements.\n\n    Sample Input:\n    n = 5\n    k = 3\n\n    Sample Output:\n    10\n\n    Explanation:\n    There are 10 ways to choose 3 elements from a set of 5 elements: (1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5), (1, 4, 5), (2, 3, 4), (2, 3, 5), (2, 4, 5), (3, 4, 5).\n    \"\"\"\n    def factorial(n: int) -> int:\n        if n == 0 or n == 1:\n            return 1\n        return n * factorial(n-1)\n\n    return factorial(n) // (factorial(k) * factorial(n-k))\n\ndef g(n = 5, k = 3):\n    return n, k\n\nassert f(*g()) == 10\n",
        "idx_generation": 320,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the number of combinations of k elements from a set of n elements.\n    Return the number of combinations.\n    \"\"\"\n    def factorial(n: int) -> int:\n        if n == 0 or n == 1:\n            return 1\n        else:\n            return n * factorial(n-1)\n\n    return factorial(n) // (factorial(k) * factorial(n - k))\n\ndef g():\n    n = 5\n    k = 2\n    return n, k\n\nassert f(*g()) == 10\n",
        "idx_generation": 205,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(string: str) -> int:\n    \"\"\"\n    Count the number of unique substrings in a given string.\n    \"\"\"\n    n = len(string)\n    substrings = set()\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substrings.add(string[i:j])\n\n    return len(substrings)\n\ndef g(string=\"abc\"):\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return string\n\nassert f(g()) == 6\n",
        "idx_generation": 274,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in non-decreasing order.\n\n    Example:\n    nums = [5, 2, 8, 1, 9]\n\n    Output:\n    [1, 2, 5, 8, 9]\n\n    Hint: Use any sorting algorithm such as bubble sort, insertion sort, or merge sort.\n    \"\"\"\n\n    # Bubble sort implementation\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n\n    return nums\n\ndef g(nums: List[int] = [5, 2, 8, 1, 9]):\n    \"\"\"\n    Generate a list of integers to be sorted.\n    \"\"\"\n    return nums\n\nassert f(g()) == [1, 2, 5, 8, 9]\n",
        "idx_generation": 490,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output:\n    2\n    \"\"\"\n\n    def binary_search(nums, target, low, high):\n        if low > high:\n            return -1\n\n        mid = (low + high) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] > target:\n            return binary_search(nums, target, low, mid - 1)\n        else:\n            return binary_search(nums, target, mid + 1, high)\n\n    return binary_search(nums, target, 0, len(nums) - 1)\n\ndef g():\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    return [1, 3, 5, 7, 9], 5\n\nassert f(*g()) == 2\n",
        "idx_generation": 155,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> List[str]:\n    \"\"\"\n    Given a string s and a list of words, find all the words from the list that are anagrams of s.\n    Return a list of the matching words.\n\n    Example:\n    s = \"listen\"\n    words = [\"enlist\", \"silent\", \"inlets\", \"banana\", \"listen\"]\n\n    Output:\n    [\"enlist\", \"silent\", \"inlets\", \"listen\"]\n\n    Explanation:\n    The words \"enlist\", \"silent\", and \"inlets\" are anagrams of \"listen\".\n    The word \"banana\" is not an anagram of \"listen\".\n    \"\"\"\n\n    def is_anagram(s1: str, s2: str) -> bool:\n        return sorted(s1) == sorted(s2)\n\n    return [word for word in words if is_anagram(s, word)]\n\n\ndef g() -> List[str]:\n    s = \"listen\"\n    words = [\"enlist\", \"silent\", \"inlets\", \"banana\", \"listen\"]\n    return s, words\n\nassert f(*g()) == [\"enlist\", \"silent\", \"inlets\", \"listen\"]\n",
        "idx_generation": 270,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[str]:\n    \"\"\"\n    Given an integer n, generate all possible valid parentheses combinations of length 2n.\n    \"\"\"\n    def generateParenthesesHelper(open_count: int, close_count: int, current: str, result: List[str]) -> None:\n        # Base case: all parentheses generated\n        if open_count == 0 and close_count == 0:\n            result.append(current)\n            return\n        \n        # Recursive case: generate parentheses with remaining counts\n        if open_count > 0:\n            generateParenthesesHelper(open_count - 1, close_count, current + '(', result)\n        if close_count > open_count:\n            generateParenthesesHelper(open_count, close_count - 1, current + ')', result)\n    \n    result = []\n    generateParenthesesHelper(n, n, '', result)\n    return result\n\ndef g():\n    \"\"\"\n    Generate an integer for testing.\n    \"\"\"\n    return 3\n\nassert f(g()) == ['((()))', '(()())', '(())()', '()(())', '()()()']\n",
        "idx_generation": 346,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[int]:\n    \"\"\"\n    Given a positive integer 'n', generate a list of all prime numbers less than or equal to 'n'.\n\n    Example:\n    n = 20\n\n    Output:\n    [2, 3, 5, 7, 11, 13, 17, 19]\n    \"\"\"\n    primes = []\n    for num in range(2, n+1):\n        if all(num % i != 0 for i in range(2, int(num**0.5) + 1)):\n            primes.append(num)\n    return primes\n\ndef g():\n    n = 20\n    return n\n\nassert f(g()) == [2, 3, 5, 7, 11, 13, 17, 19]\n\n",
        "idx_generation": 444,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum difference between any two elements in the list.\n    \"\"\"\n    if len(nums) < 2:\n        return 0\n    \n    min_num = float('inf')\n    max_diff = 0\n    \n    for num in nums:\n        min_num = min(min_num, num)\n        max_diff = max(max_diff, num - min_num)\n    \n    return max_diff\n\ndef g() -> List[int]:\n    return [7, 1, 5, 3, 6, 4]\n\nassert f(g()) == 5\n",
        "idx_generation": 364,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum number of steps required to reach the bottom-right corner of the grid from the top-left corner.\n    You can only move down or right.\n\n    Example:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum number of steps required is 7 (1 -> 3 -> 1 -> 1 -> 1 -> 2 -> 1).\n\n    Hint: Use dynamic programming to calculate the minimum number of steps efficiently.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Calculate the cumulative sum of each row\n    for i in range(1, rows):\n        grid[i][0] += grid[i - 1][0]\n\n    # Calculate the cumulative sum of each column\n    for j in range(1, cols):\n        grid[0][j] += grid[0][j - 1]\n\n    # Calculate the minimum number of steps\n    for i in range(1, rows):\n        for j in range(1, cols):\n            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n\n    return grid[rows - 1][cols - 1]\n\ndef g() -> List[List[int]]:\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 7\n",
        "idx_generation": 386,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of valid paths from the top-left cell to the bottom-right cell of an n x n grid.\n    You can only move down or right.\n    \n    Example:\n    n = 3\n    \n    Output:\n    6\n    \n    Explanation:\n    There are 6 valid paths from the top-left cell to the bottom-right cell:\n    - Right -> Right -> Down\n    - Right -> Down -> Right\n    - Right -> Down -> Down\n    - Down -> Right -> Right\n    - Down -> Right -> Down\n    - Down -> Down -> Right\n    \"\"\"\n    dp = [[0] * (n+1) for _ in range(n+1)]\n    \n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i == 1 or j == 1:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[n][n]\n\ndef g(n: int = 3):\n    \"\"\"\n    Return the size of the grid.\n    \"\"\"\n    return n\n\nassert f(g()) == 6\n\n",
        "idx_generation": 302,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Reverse the words in a given string.\n    Return the reversed string.\n\n    Example:\n    Input: \"Hello World\"\n    Output: \"World Hello\"\n    \"\"\"\n\n    words = s.split()\n    reversed_words = ' '.join(words[::-1])\n    return reversed_words\n\ndef g() -> str:\n    return \"Hello World\"\n\nassert f(g()) == \"World Hello\"\n\n",
        "idx_generation": 391,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str, pattern: str) -> bool:\n    \"\"\"\n    Given a string and a pattern, determine if the pattern matches the string.\n    The pattern consists of letters (a-z) and wildcards (*).\n    A wildcard can match any sequence of characters.\n\n    Args:\n    - string: The input string.\n    - pattern: The pattern to match.\n\n    Returns:\n    - True if the pattern matches the string, False otherwise.\n    \"\"\"\n    # Length of the string and pattern\n    n = len(string)\n    m = len(pattern)\n    \n    # Initialize the DP table\n    dp = [[False] * (m + 1) for _ in range(n + 1)]\n    \n    # Base case: empty string and empty pattern match\n    dp[0][0] = True\n    \n    # Initialize the first row: empty string and non-empty pattern\n    for j in range(1, m + 1):\n        if pattern[j - 1] == '*':\n            dp[0][j] = dp[0][j - 1]\n    \n    # Fill in the DP table\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if pattern[j - 1] == '*':\n                dp[i][j] = dp[i][j - 1] or dp[i - 1][j]\n            elif pattern[j - 1] == '?' or pattern[j - 1] == string[i - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n    \n    return dp[n][m]\n\ndef g():\n    string = \"abacaba\"\n    pattern = \"a*a?a*a\"\n    return string, pattern\n\nassert f(*g()) == True\n",
        "idx_generation": 455,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n\n    Sample Input:\n    [3, 10, 5, 25, 2, 8]\n\n    Sample Output:\n    28\n    \"\"\"\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n\n        for num in nums:\n            prefix_set.add(num & mask)\n\n        temp_max_xor = max_xor | (1 << i)\n\n        for prefix in prefix_set:\n            if temp_max_xor ^ prefix in prefix_set:\n                max_xor = temp_max_xor\n                break\n\n    return max_xor\n\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\n\nassert f(g()) == 28\n",
        "idx_generation": 140,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, compute the factorial of n.\n\n    Sample Input:\n    n = 5\n\n    Sample Output:\n    120\n    \"\"\"\n    if n == 0:\n        return 1\n    else:\n        return n * f(n-1)\n\ndef g() -> int:\n    return 5\n\nassert f(g()) == 120\n\n",
        "idx_generation": 232,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency list and two nodes start and end,\n    determine if there is a path from start to end in the graph.\n\n    Example:\n    graph = [[1, 2], [2], [3], [3], []], start = 0, end = 3\n    The graph is represented as follows:\n    0 -> 1 -> 2 -> 3\n    There is a path from node 0 to node 3, so the output is True.\n\n    Determine if there is a path from start to end in the graph.\n    \"\"\"\n    visited = [False] * len(graph)\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n\n        if not visited[node]:\n            visited[node] = True\n            stack.extend(graph[node])\n\n    return False\n\ndef g() -> Tuple[List[List[int]], int, int]:\n    graph = [[1, 2], [2], [3], [3], []]\n    start = 0\n    end = 3\n    return graph, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 421,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of unique paths from the top-left corner to the bottom-right corner of a n x n grid.\n    You can only move either down or right at any point in time.\n\n    Example:\n    n = 3\n    Output: 6\n\n    In a 3 x 3 grid, there are 6 unique paths from the top-left corner to the bottom-right corner:\n    ['R', 'R', 'D']\n    ['R', 'D', 'D']\n    ['D', 'R', 'D']\n    ['D', 'D', 'R']\n    ['D', 'R', 'R']\n    ['R', 'D', 'R']\n    \"\"\"\n    if n == 0:\n        return 0\n    \n    def unique_paths_helper(i, j, n, memo):\n        if i == n-1 and j == n-1:\n            return 1\n        if i >= n or j >= n:\n            return 0\n        if memo[i][j] != -1:\n            return memo[i][j]\n        \n        right_paths = unique_paths_helper(i, j+1, n, memo)\n        down_paths = unique_paths_helper(i+1, j, n, memo)\n        \n        memo[i][j] = right_paths + down_paths\n        return memo[i][j]\n    \n    memo = [[-1] * n for _ in range(n)]\n    return unique_paths_helper(0, 0, n, memo)\n\ndef g(n = 3):\n    return n\n\nassert f(g()) == 6\n",
        "idx_generation": 127,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Graph:\n    def __init__(self, num_vertices: int):\n        self.num_vertices = num_vertices\n        self.adj_list = [[] for _ in range(num_vertices)]\n\n    def add_edge(self, u: int, v: int) -> None:\n        self.adj_list[u].append(v)\n        self.adj_list[v].append(u)\n\ndef f(graph: Graph) -> bool:\n    \"\"\"\n    Given an undirected graph, determine if it contains a cycle.\n\n    Args:\n    - graph: The undirected graph.\n\n    Returns:\n    - True if the graph contains a cycle, False otherwise.\n    \"\"\"\n    visited = [False] * graph.num_vertices\n    for vertex in range(graph.num_vertices):\n        if not visited[vertex]:\n            if dfs(graph, vertex, visited, -1):\n                return True\n    return False\n\ndef dfs(graph: Graph, vertex: int, visited: List[bool], parent: int) -> bool:\n    visited[vertex] = True\n    for neighbor in graph.adj_list[vertex]:\n        if not visited[neighbor]:\n            if dfs(graph, neighbor, visited, vertex):\n                return True\n        elif parent != neighbor:\n            return True\n    return False\n\ndef g():\n    graph = Graph(4)\n    graph.add_edge(0, 1)\n    graph.add_edge(1, 2)\n    graph.add_edge(2, 3)\n    return graph\n\nassert f(g()) == False\n\n",
        "idx_generation": 214,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the number of combinations of elements in the list that add up to the target value.\n\n    Example:\n    Input:\n    nums = [1, 2, 3]\n    target = 4\n\n    Output:\n    4\n\n    Explanation:\n    There are 4 combinations of elements in the list [1, 2, 3] that add up to the target value 4:\n    [1, 1, 1, 1]\n    [1, 1, 2]\n    [1, 3]\n    [2, 2]\n    \"\"\"\n\n    def countCombinations(nums: List[int], target: int, index: int, memo: List[int]) -> int:\n        if target == 0:\n            return 1\n\n        if index >= len(nums) or target < 0:\n            return 0\n\n        if memo[index][target] != -1:\n            return memo[index][target]\n\n        count = countCombinations(nums, target - nums[index], index, memo) + countCombinations(nums, target, index + 1, memo)\n        memo[index][target] = count\n\n        return count\n\n    memo = [[-1] * (target + 1) for _ in range(len(nums))]\n    return countCombinations(nums, target, 0, memo)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return ([1, 2, 3], 4)\n\nassert f(*g()) == 4\n\n",
        "idx_generation": 334,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums, generate all possible unique permutations of nums.\n\n    Example:\n    nums = [1, 2, 3]\n  \n    Output:\n    [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n    Hint: Use backtracking to generate all possible permutations of the numbers.\n    \"\"\"\n    def backtrack(nums, path, used, res):\n        if len(path) == len(nums):\n            res.append(path[:])\n            return\n\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n            if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]:\n                continue\n\n            path.append(nums[i])\n            used[i] = True\n            backtrack(nums, path, used, res)\n            path.pop()\n            used[i] = False\n\n    nums.sort()\n    res = []\n    used = [False] * len(nums)\n    backtrack(nums, [], used, res)\n\n    return res\n\ndef g(nums=[1, 2, 3]):\n    return [nums]\n\nassert f(*g()) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n",
        "idx_generation": 212,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[List[str]]:\n    \"\"\"\n    Given a list of words, group them by anagrams and return the result as a list of lists.\n\n    Example:\n    Input:\n    words = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n\n    Output:\n    [\n        [\"eat\", \"tea\", \"ate\"],\n        [\"tan\", \"nat\"],\n        [\"bat\"]\n    ]\n    \"\"\"\n    def countCharacters(word: str) -> List[int]:\n        count = [0] * 26\n        for char in word:\n            count[ord(char) - ord('a')] += 1\n        return count\n    \n    anagrams = {}\n    for word in words:\n        count = tuple(countCharacters(word))\n        if count in anagrams:\n            anagrams[count].append(word)\n        else:\n            anagrams[count] = [word]\n    \n    return list(anagrams.values())\n\ndef g() -> List[str]:\n    return [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n\nassert f(g()) == [\n    [\"eat\", \"tea\", \"ate\"],\n    [\"tan\", \"nat\"],\n    [\"bat\"]\n]\n",
        "idx_generation": 275,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums sorted in ascending order,\n    find two numbers such that they add up to a specific target number.\n\n    Args:\n    - nums: A list of integers.\n    - target: The target sum.\n\n    Returns:\n    - The indices of the two numbers such that they add up to the target.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g(nums = [2, 7, 11, 15], target = 9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 490,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence within the list.\n\n    Sample input:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    Sample output:\n    4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g():\n    return ([10, 9, 2, 5, 3, 7, 101, 18],)\n\nassert f(g()) == True\n",
        "idx_generation": 163,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, words=['apple', 'banana', 'cherry', 'date'], target='banana') -> bool:\n    \"\"\"\n    Given a list of words and a target word, determine if the target word is present in the list.\n    \"\"\"\n    sorted_words = sorted(words)\n    left = 0\n    right = len(sorted_words) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if sorted_words[mid] == target:\n            return True\n        elif sorted_words[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef g(words=['apple', 'banana', 'cherry', 'date'], target='banana'):\n    return words, target\n\nassert f(g()) == True\n",
        "idx_generation": 283,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given an array of integers 'arr' and a target integer 'target', determine if there exists a subset of 'arr' that sums up to 'target'.\n\n    Return True if such subset exists, False otherwise.\n\n    Example:\n    arr = [1, 5, 3, 9, 2]\n    target = 8\n\n    Output:\n    True\n\n    Explanation:\n    The subset [1, 3, 2] sums up to the target 8.\n    \"\"\"\n\n    def subset_sum(arr, target, n):\n        if target == 0:\n            return True\n        if n == 0:\n            return False\n        if arr[n-1] > target:\n            return subset_sum(arr, target, n-1)\n        return subset_sum(arr, target, n-1) or subset_sum(arr, target-arr[n-1], n-1)\n\n    return subset_sum(arr, target, len(arr))\n\ndef g(arr=[1, 5, 3, 9, 2], target=8):\n    \"\"\"\n    Generate an array 'arr' and target integer 'target'.\n    \"\"\"\n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 351,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of trailing zeros in n!.\n\n    Args:\n    - n: A positive integer.\n\n    Returns:\n    - The number of trailing zeros in n!.\n\n    Example:\n    f(5) => 1\n    f(10) => 2\n    f(20) => 4\n    \"\"\"\n\n    count = 0\n    i = 5\n    while n // i >= 1:\n        count += n // i\n        i *= 5\n\n    return count\n\ndef g() -> int:\n    n = 25\n    return n\n\nassert f(g()) == 6\n\n",
        "idx_generation": 453,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of integers, determine if it is a valid Sudoku solution.\n\n    Example:\n    grid = [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]\n\n    Output:\n    True\n\n    Explanation:\n    The above grid represents a valid Sudoku solution.\n    \"\"\"\n\n    def is_valid_row(grid: List[List[int]], row: int) -> bool:\n        seen = set()\n        for num in grid[row]:\n            if num != 0:\n                if num in seen:\n                    return False\n                seen.add(num)\n        return True\n\n    def is_valid_column(grid: List[List[int]], col: int) -> bool:\n        seen = set()\n        for row in range(9):\n            num = grid[row][col]\n            if num != 0:\n                if num in seen:\n                    return False\n                seen.add(num)\n        return True\n\n    def is_valid_box(grid: List[List[int]], start_row: int, start_col: int) -> bool:\n        seen = set()\n        for row in range(start_row, start_row + 3):\n            for col in range(start_col, start_col + 3):\n                num = grid[row][col]\n                if num != 0:\n                    if num in seen:\n                        return False\n                    seen.add(num)\n        return True\n\n    for row in range(9):\n        if not is_valid_row(grid, row):\n            return False\n\n    for col in range(9):\n        if not is_valid_column(grid, col):\n            return False\n\n    for start_row in range(0, 9, 3):\n        for start_col in range(0, 9, 3):\n            if not is_valid_box(grid, start_row, start_col):\n                return False\n\n    return True\n\n\ndef g() -> List[List[int]]:\n    return [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]\n\n\nassert f(g()) == True\n\n",
        "idx_generation": 364,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size m x n, find the number of unique paths from the top-left corner to the bottom-right corner.\n    You can only move down or right at any point in time.\n\n    Example:\n    grid = [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1]\n    ]\n    The number of unique paths from the top-left corner to the bottom-right corner is 6.\n\n    Constraints:\n    - The grid will have at most 100 rows and 100 columns.\n    - Each cell in the grid will be either 0 or 1.\n    - The top-left and bottom-right cells will always be 1.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1\n    \n    for i in range(m):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n    \n    return dp[m-1][n-1]\n\ndef g():\n    \"\"\"\n    Generate a grid for testing.\n    \"\"\"\n    return [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1]\n    ]\n\nassert f(g()) == 6\n",
        "idx_generation": 389,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, find the area of the largest island. An island is a group of connected 1s\n    horizontally or vertically. You may assume that the grid is rectangular and that there is at least one island.\n\n    Args:\n    - grid: A 2D list of 0s and 1s\n\n    Returns:\n    - The area of the largest island\n    \"\"\"\n    def dfs(grid: List[List[int]], i: int, j: int) -> int:\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0:\n            return 0\n        \n        grid[i][j] = 0\n        count = 1\n        count += dfs(grid, i-1, j)\n        count += dfs(grid, i+1, j)\n        count += dfs(grid, i, j-1)\n        count += dfs(grid, i, j+1)\n\n        return count\n\n    max_area = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                area = dfs(grid, i, j)\n                max_area = max(max_area, area)\n\n    return max_area\n\ndef g() -> List[List[int]]:\n    grid = [[1, 1, 0, 0, 0],\n            [1, 1, 0, 0, 0],\n            [0, 0, 0, 1, 1],\n            [0, 0, 0, 1, 1]]\n    return grid\n\nassert f(g()) == 4\n",
        "idx_generation": 304,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, reverse each word in the list.\n\n    Return the list of reversed words.\n\n    Example:\n    arr = [\"hello\", \"world\", \"python\"]\n\n    Output:\n    [\"olleh\", \"dlrow\", \"nohtyp\"]\n    \"\"\"\n    def reverse_words(arr):\n        reversed_arr = []\n        \n        for word in arr:\n            reversed_arr.append(word[::-1])\n        \n        return reversed_arr\n\n    return reverse_words(arr)\n\ndef g(arr=[\"hello\", \"world\", \"python\"]):\n    return arr\n\nassert f(g()) == [\"olleh\", \"dlrow\", \"nohtyp\"]\n\n",
        "idx_generation": 394,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string, count the number of ways to decode it.\n\n    Example:\n    s = \"226\"\n\n    Output:\n    3 (there are 3 ways to decode the string: \"BBF\", \"BZ\", \"VF\")\n    \"\"\"\n    def decode(s):\n        n = len(s)\n        if n == 0 or (n == 1 and s[0] == '0'):\n            return 0\n        if n == 1 or (n == 2 and s[1] == '0'):\n            return 1\n\n        dp = [0] * (n + 1)\n        dp[n] = 1\n        if s[n - 1] != '0':\n            dp[n - 1] = 1\n\n        for i in range(n - 2, -1, -1):\n            if s[i] == '0':\n                continue\n            dp[i] = dp[i + 1]\n            if s[i] == '1' or (s[i] == '2' and s[i + 1] <= '6'):\n                dp[i] += dp[i + 2]\n\n        return dp[0]\n\n    return decode(s)\n\ndef g():\n    return \"226\"\n\nassert f(g()) == 3\n",
        "idx_generation": 457,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"\n    Given a positive integer, count the number of set bits in its binary representation.\n    Return the count of set bits.\n    \"\"\"\n    count = 0\n    while num > 0:\n        if num % 2 == 1:\n            count += 1\n        num = num // 2\n    return count\n\ndef g(num=10):\n    \"\"\"\n    Generate a positive integer. Return the generated integer.\n    \"\"\"\n    return num\n\nassert f(g()) == 2\n",
        "idx_generation": 148,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if it is possible to obtain the target value\n    by combining the integers in the list using addition and subtraction operations.\n    Each integer in the list can be used multiple times.\n\n    Example:\n    nums = [1, 2, 3]\n    target = 7\n\n    Output:\n    True\n\n    Explanation:\n    1 + 2 + 2 + 2 = 7\n    \"\"\"\n\n    def can_sum(target: int, memo: Dict[int, bool]) -> bool:\n        if target in memo:\n            return memo[target]\n        if target == 0:\n            return True\n        if target < 0:\n            return False\n\n        for num in nums:\n            if can_sum(target - num, memo):\n                memo[target] = True\n                return True\n\n        memo[target] = False\n        return False\n\n    memo = {}\n    return can_sum(target, memo)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    return ([1, 2, 2, 2], 7)\n\nassert f(*g()) == True\n",
        "idx_generation": 240,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> List[int]:\n    \"\"\"\n    Given a directed graph represented as an adjacency list 'graph', a start node 'start',\n    and an end node 'end', find the shortest path from 'start' to 'end' using breadth-first search (BFS).\n    Return the path as a list of nodes.\n\n    Example:\n    graph = {\n        1: [2, 3],\n        2: [4],\n        3: [4, 5],\n        4: [5],\n        5: []\n    }\n    start = 1\n    end = 5\n\n    Output:\n    [1, 3, 5]\n\n    Explanation:\n    The shortest path from node 1 to node 5 is [1, 3, 5].\n    \"\"\"\n\n    def bfs(graph: Dict[int, List[int]], start: int, end: int) -> List[int]:\n        queue = deque([(start, [start])])\n        visited = set()\n\n        while queue:\n            node, path = queue.popleft()\n            visited.add(node)\n\n            if node == end:\n                return path\n\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    queue.append((neighbor, path + [neighbor]))\n\n        return []\n\n    return bfs(graph, start, end)\n\ndef g() -> Tuple[Dict[int, List[int]], int, int]:\n    return ({1: [2, 3], 2: [4], 3: [4, 5], 4: [5], 5: []}, 1, 5)\n\nassert f(*g()) == [1, 3, 5]\n",
        "idx_generation": 469,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix,\n    determine if there is a path from the start node to the end node.\n    \"\"\"\n    visited = [False] * len(graph)\n    \n    def dfs(node):\n        if node == end:\n            return True\n        \n        visited[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n        \n        return False\n    \n    return dfs(start)\n\ndef g() -> Tuple[List[List[int]], int, int]:\n    graph = [[1, 2], [2], [3], []]\n    start = 0\n    end = 3\n    return graph, start, end\n\nassert f(*g()) == True\n\n",
        "idx_generation": 130,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom collections import defaultdict\n\ndef f(graph: Dict[int, List[int]]) -> int:\n    \"\"\"Find the number of connected components in a graph\"\"\"\n    def dfs(node):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor)\n\n    visited = set()\n    components = 0\n    for node in graph:\n        if node not in visited:\n            dfs(node)\n            components += 1\n    return components\n\ndef g():\n    return {1: [2, 3], 2: [1, 3], 3: [1, 2], 4: [5], 5: [4]}\n\nassert f(g()) == 2\n",
        "idx_generation": 218,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers n and m, compute the value of n choose m (nCm), also known as the binomial coefficient.\n\n    Example:\n    n = 5\n    m = 2\n\n    Output:\n    10\n\n    Explanation:\n    The binomial coefficient 5C2 is equal to 5! / (2! * (5-2)!) = 10.\n    \"\"\"\n    def factorial(n: int) -> int:\n        if n == 0 or n == 1:\n            return 1\n        return n * factorial(n-1)\n\n    return factorial(n) // (factorial(m) * factorial(n-m))\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate two integers for the function f.\n    \"\"\"\n    return [5, 2]\n\nassert f(*g()) == 10\n\n",
        "idx_generation": 343,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, find the number of ways to choose k items from a set of n items.\n    \"\"\"\n    if k == 0 or k == n:\n        return 1\n    else:\n        return f(n-1, k-1) + f(n-1, k)\n\ndef g(n: int = 5, k: int = 2):\n    \"\"\"\n    Find the number of ways to choose k items from a set of n items.\n    \"\"\"\n    return n, k\n\nassert f(*g()) == 10\n",
        "idx_generation": 214,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the number of distinct substrings that can be formed using the characters of s.\n    \"\"\"\n    distinct_substrings = set()\n    n = len(s)\n    for i in range(n):\n        for j in range(i, n):\n            distinct_substrings.add(s[i:j+1])\n    \n    return len(distinct_substrings)\n\ndef g():\n    return \"abc\"\n\nassert f(g()) == 6\n\n",
        "idx_generation": 276,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there are two numbers in the list that add up to the target.\n    Return True if such numbers exist, otherwise return False.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 10\n\n    Output:\n    True (since 1 + 9 = 10)\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g() -> Tuple[List[int], int]:\n    return ([1, 3, 5, 7, 9], 10)\n\nassert f(*g())\n",
        "idx_generation": 493,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target element using binary search.\n\n    Example:\n    arr = [1, 2, 3, 4, 6]\n    target = 4\n    Output: 3\n    \"\"\"\n    low = 0\n    high = len(arr) - 1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return -1\n\ndef g():\n    return [1, 2, 3, 4, 6], 4\n\nassert f(*g()) == 3\n",
        "idx_generation": 164,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str]) -> str:\n    \"\"\"\n    Given a list of strings, concatenate them into a single string in alphabetical order.\n\n    Example:\n    strings = [\"c\", \"a\", \"b\"]\n\n    Output:\n    \"abc\"\n\n    Hint: Use the sorted() function to sort the strings in alphabetical order before concatenating them.\n    \"\"\"\n    return ''.join(sorted(strings))\n\ndef g() -> List[str]:\n    strings = [\"c\", \"a\", \"b\"]\n    return strings\n\nassert f(g()) == \"abc\"\n\n",
        "idx_generation": 333,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of inversions in the list.\n    An inversion occurs when two elements in the list are out of order.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The number of inversions in the list.\n    \"\"\"\n    def merge_sort(nums, start, end):\n        if start < end:\n            mid = (start + end) // 2\n            count = merge_sort(nums, start, mid)\n            count += merge_sort(nums, mid+1, end)\n            count += merge(nums, start, mid, end)\n            return count\n        else:\n            return 0\n\n    def merge(nums, start, mid, end):\n        count = 0\n        left = nums[start:mid+1]\n        right = nums[mid+1:end+1]\n        i = j = 0\n        k = start\n\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                nums[k] = left[i]\n                i += 1\n            else:\n                nums[k] = right[j]\n                j += 1\n                count += (mid - start + 1) - i\n            k += 1\n\n        while i < len(left):\n            nums[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            nums[k] = right[j]\n            j += 1\n            k += 1\n\n        return count\n\n    return merge_sort(nums, 0, len(nums)-1)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [4, 2, 1, 3, 5]\n\nassert f(g()) == 4\n\n",
        "idx_generation": 373,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the sum of all positive integers less than n that are divisible by 3 or 5.\n    \n    Example:\n    n = 10\n    \n    Output:\n    23\n    \n    Explanation:\n    The positive integers less than 10 that are divisible by 3 or 5 are 3, 5, 6, and 9.\n    Their sum is 3 + 5 + 6 + 9 = 23.\n    \"\"\"\n    sum = 0\n    for i in range(1, n):\n        if i % 3 == 0 or i % 5 == 0:\n            sum += i\n    \n    return sum\n\ndef g():\n    n = 10\n    return n\n\nassert f(g()) == 23\n",
        "idx_generation": 461,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the sum of all the elements in the grid.\n    \"\"\"\n    total_sum = 0\n    for row in grid:\n        for num in row:\n            total_sum += num\n    return total_sum\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 45\n",
        "idx_generation": 367,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the nth Fibonacci number.\n\n    Return the nth Fibonacci number.\n\n    Example:\n    n = 6\n\n    Output:\n    8\n\n    Explanation:\n    The 6th Fibonacci number is 8.\n\n    Hint: Use either recursion or dynamic programming to calculate the Fibonacci sequence.\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    a, b = 0, 1\n    \n    for _ in range(2, n+1):\n        a, b = b, a + b\n        \n    return b\n\ndef g(n: int = 6) -> int:\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 389,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid filled with non-negative integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    Input:\n    [\n      [1,3,1],\n      [1,5,1],\n      [4,2,1]\n    ]\n    Output: 12\n    Explanation: Because the path 1\u21923\u21925\u21921\u21922\u21921 maximizes the sum.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    \n    # Create a dp table to store the maximum path sum for each cell\n    dp = [[0] * n for _ in range(m)]\n    \n    # Initialize the first row and first column of the dp table\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    # Fill in the rest of the dp table using dynamic programming\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    # Return the maximum path sum for the bottom-right corner\n    return dp[m-1][n-1]\n\ndef g(grid = [[1,3,1],[1,5,1],[4,2,1]]):\n    return grid\n\nassert f(g()) == 12\n",
        "idx_generation": 306,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the length of the longest substring without repeating characters.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    int: The length of the longest substring without repeating characters.\n    \"\"\"\n    n = len(s)\n    max_len = 0\n    start = 0\n    char_to_idx = {}\n\n    for i in range(n):\n        if s[i] in char_to_idx and start <= char_to_idx[s[i]]:\n            start = char_to_idx[s[i]] + 1\n        else:\n            max_len = max(max_len, i - start + 1)\n        char_to_idx[s[i]] = i\n\n    return max_len\n\ndef g(s=\"abcabcbb\"):\n    \"\"\"\n    Generate a string for finding the length of the longest substring without repeating characters.\n    \"\"\"\n    return (s,)\n\nassert f(*g()) == 3\n",
        "idx_generation": 396,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome after removing at most one character.\n\n    Example:\n    Input: \"racecar\"\n    Output: True\n\n    Explanation:\n    The string \"racecar\" is already a palindrome.\n\n    Input: \"abccdba\"\n    Output: True\n\n    Explanation:\n    The string \"abccdba\" is a palindrome after removing the character 'd'.\n\n    Input: \"abcdba\"\n    Output: False\n\n    Explanation:\n    The string \"abcdba\" is not a palindrome after removing at most one character.\n\n    \"\"\"\n\n    def is_palindrome(s: str, left: int, right: int, removed: bool) -> bool:\n        while left < right:\n            if s[left] != s[right]:\n                if removed:\n                    return False\n                else:\n                    return is_palindrome(s, left + 1, right, True) or is_palindrome(s, left, right - 1, True)\n            left += 1\n            right -= 1\n        return True\n\n    return is_palindrome(s, 0, len(s) - 1, False)\n\ndef g() -> str:\n    return \"abccdba\"\n\nassert f(g()) == True\n",
        "idx_generation": 468,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(num1: int, num2: int) -> int:\n    \"\"\"Calculate the sum of two integers without using the + or - operators\"\"\"\n    while num2 != 0:\n        carry = num1 & num2\n        num1 = num1 ^ num2\n        num2 = carry << 1\n    return num1\ndef g(num1=5, num2=7):\n    return num1, num2\nassert f(*g()) == 12\n",
        "idx_generation": 156,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the minimum cost path from the top-left corner to the bottom-right corner,\n    where the cost of a path is defined as the sum of the values of the cells along the path.\n\n    Example:\n    f([[1, 3, 1],\n       [1, 5, 1],\n       [4, 2, 1]]) -> 7\n\n    Return the minimum cost.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[m-1][n-1]\n\ndef g():\n    return [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\nassert f(g()) == 7\n\n",
        "idx_generation": 249,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom heapq import heappop, heappush\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the minimum path sum from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Return the minimum path sum.\n\n    Example:\n    matrix = [[1, 3, 1],\n              [1, 5, 1],\n              [4, 2, 1]]\n    The minimum path sum is: 1 -> 3 -> 1 -> 1 -> 1, with a sum of 7.\n    \"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n\n    # Initialize the distance matrix with maximum values\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = matrix[0][0]\n\n    # Create a priority queue to store the nodes to be visited\n    pq = [(matrix[0][0], 0, 0)]\n\n    while pq:\n        dist, row, col = heappop(pq)\n\n        # Check if the current distance is already updated\n        if dist > distance[row][col]:\n            continue\n\n        # Explore the neighbors (down and right)\n        for dr, dc in [(1, 0), (0, 1)]:\n            new_row = row + dr\n            new_col = col + dc\n\n            # Check if the new position is within the matrix boundaries\n            if 0 <= new_row < m and 0 <= new_col < n:\n                new_dist = dist + matrix[new_row][new_col]\n\n                # Update the distance if a shorter path is found\n                if new_dist < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_dist\n                    heappush(pq, (new_dist, new_row, new_col))\n\n    return distance[m - 1][n - 1]\n\ndef g():\n    return [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\nassert f(g()) == 7\n\n",
        "idx_generation": 483,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom collections import deque\nfrom typing import List\n\ndef f(adj_matrix: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix and two vertices start and end, determine if there\n    is a path from start to end.\n\n    Sample Input:\n    adj_matrix = [[0, 1, 1, 0],\n                  [1, 0, 0, 1],\n                  [1, 0, 0, 1],\n                  [0, 1, 1, 0]]\n    start = 0\n    end = 3\n\n    Sample Output:\n    True\n\n    Explanation:\n    There is a path from vertex 0 to vertex 3: 0 -> 1 -> 3\n    \"\"\"\n\n    visited = [False] * len(adj_matrix)\n    queue = deque([start])\n    visited[start] = True\n\n    while queue:\n        vertex = queue.popleft()\n        if vertex == end:\n            return True\n        for neighbor in range(len(adj_matrix)):\n            if adj_matrix[vertex][neighbor] and not visited[neighbor]:\n                queue.append(neighbor)\n                visited[neighbor] = True\n\n    return False\n\ndef g(adj_matrix: List[List[int]] = [[0, 1, 1, 0],\n                                     [1, 0, 0, 1],\n                                     [1, 0, 0, 1],\n                                     [0, 1, 1, 0]],\n      start: int = 0,\n      end: int = 3) -> List[List[int]]:\n    return adj_matrix\n\nassert f(g(), start=0, end=3)\n",
        "idx_generation": 142,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(adj_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representing a directed graph, return True if there exists a cycle in the graph. Otherwise, return False.\n    \"\"\"\n    visited = [False] * len(adj_matrix)\n    stack = [False] * len(adj_matrix)\n    \n    for i in range(len(adj_matrix)):\n        if not visited[i]:\n            if dfs(i, adj_matrix, visited, stack):\n                return True\n    \n    return False\n\ndef dfs(node: int, adj_matrix: List[List[int]], visited: List[bool], stack: List[bool]) -> bool:\n    visited[node] = True\n    stack[node] = True\n    \n    for neighbor in range(len(adj_matrix)):\n        if adj_matrix[node][neighbor]:\n            if not visited[neighbor]:\n                if dfs(neighbor, adj_matrix, visited, stack):\n                    return True\n            elif stack[neighbor]:\n                return True\n    \n    stack[node] = False\n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate an adjacency matrix representing a directed graph.\n    \"\"\"\n    return [[0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1],\n            [1, 0, 0, 0]]\n\nassert f(g()) == True\n",
        "idx_generation": 229,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string of binary numbers, count the number of occurrences of the substring '11'.\n    \"\"\"\n    count = 0\n    i = 0\n    \n    while i < len(s) - 1:\n        if s[i:i+2] == '11':\n            count += 1\n            i += 2\n        else:\n            i += 1\n    \n    return count\n\ndef g(s='101101110111'):\n    \"\"\"\n    Generate a string of binary numbers such that there are multiple occurrences of the substring '11'.\n    \"\"\"\n    return s\n\nassert f(g()) > 0\n",
        "idx_generation": 353,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of ways to arrange n distinct objects in a row.\"\"\"\n    if n == 0:\n        return 1\n    else:\n        return n * f(n - 1)\n\ndef g():\n    n = 4\n    return (n,)\n\nassert f(*g()) == 24\n",
        "idx_generation": 214,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Check if a string is a palindrome and contains a substring of length k\"\"\"\n    is_palindrome = s == s[::-1]\n    has_substring = any(len(s[i:i+k]) == k for i in range(len(s)-k+1))\n    return is_palindrome and has_substring\n\ndef g(s: str):\n    return s\n\nassert f(g(\"racecar\"), 3)\n",
        "idx_generation": 287,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, return the index of the target value in the list.\n    If the target value is not found in the list, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output:\n    2\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    return ([1, 3, 5, 7, 9], 5)\n\nassert f(*g()) == 2\n",
        "idx_generation": 493,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the first occurrence of a target number.\n    If the target number does not exist in the list, return -1.\n\n    Example:\n    nums = [1, 2, 3, 3, 5, 6, 7, 8, 8, 9]\n    target = 3\n\n    Output:\n    2\n\n    Explanation:\n    The target number 3 is first found at index 2 in the given list.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            if mid == 0 or nums[mid - 1] < target:\n                return mid\n            else:\n                right = mid - 1\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    nums = [1, 2, 3, 3, 5, 6, 7, 8, 8, 9]\n    target = 3\n    return (nums, target)\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 164,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, rotate the matrix 90 degrees clockwise.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    \n    Output:\n    [[7, 4, 1],\n     [8, 5, 2],\n     [9, 6, 3]]\n\n    Hint: Use the zip() function to transpose the matrix, and then reverse each row.\n    \"\"\"\n    return [list(row)[::-1] for row in zip(*matrix)]\n\ndef g() -> List[List[int]]:\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n\n",
        "idx_generation": 344,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The length of the longest increasing subsequence.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n\n",
        "idx_generation": 373,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of trailing zeros in n!.\n\n    Example:\n    n = 5\n\n    Output:\n    1\n\n    Explanation:\n    5! = 120, which has 1 trailing zero.\n    \"\"\"\n    count = 0\n    while n >= 5:\n        n = n // 5\n        count += n\n    return count\n\ndef g() -> int:\n    return 5\n\nassert f(g()) == 1\n",
        "idx_generation": 463,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of distinct prime numbers.\n\n    Example:\n    Input: nums = [2, 3, 5, 7, 8, 9, 11, 13]\n    Output: 6\n\n    Explanation:\n    The distinct prime numbers are 2, 3, 5, 7, 11, and 13.\n    \"\"\"\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    distinct_primes = set()\n    for num in nums:\n        if is_prime(num):\n            distinct_primes.add(num)\n    \n    return len(distinct_primes)\n\ndef g():\n    return [2, 3, 5, 7, 8, 9, 11, 13]\n\nassert f(g()) == 6\n",
        "idx_generation": 367,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of any path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    The maximum sum path is 1 -> 4 -> 7 -> 8 -> 9, which gives a sum of 29.\n\n    Return the maximum sum of any path.\n    \"\"\"\n    if not matrix:\n        return 0\n    \n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    \n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = matrix[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + matrix[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + matrix[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    \n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == 29\n\n",
        "idx_generation": 393,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid represented by a 2D list of integers, find the minimum path sum from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum path sum from the top-left cell (1) to the bottom-right cell (1) is 7.\n    The path is: 1 -> 3 -> 1 -> 1 -> 1.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n\n",
        "idx_generation": 314,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n\n    Output:\n    3\n\n    Explanation:\n    The longest substring without repeating characters is \"abc\", which has a length of 3.\n    \"\"\"\n\n    def longest_substring(s, start, end):\n        if start == end:\n            return 1\n\n        if start > end:\n            return 0\n\n        if len(set(s[start:end+1])) == end - start + 1:\n            return end - start + 1\n\n        return max(longest_substring(s, start+1, end), longest_substring(s, start, end-1))\n\n    return longest_substring(s, 0, len(s)-1)\n\ndef g(s = \"abcabcbb\"):\n    return s\n\nassert f(g()) == 3\n",
        "idx_generation": 475,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if the given integer n is a power of 2.\n    \"\"\"\n    return n != 0 and (n & (n - 1)) == 0\n\ndef g() -> int:\n    return 16\n\nassert f(g()) == True\n",
        "idx_generation": 156,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique paths from the top-left corner to the bottom-right corner of a grid.\n    You can only move down or right at each step.\n\n    Example:\n    Input: nums = [1, 2, 3, 4]\n    Grid:\n    1 2\n    3 4\n    Output: 2 (There are 2 unique paths: 1 -> 2 -> 4 and 1 -> 3 -> 4)\n    \"\"\"\n    m = int(len(nums) ** 0.5)\n    dp = [[0] * m for _ in range(m)]\n    dp[0][0] = 1\n    for i in range(m):\n        for j in range(m):\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n    return dp[m-1][m-1]\n\ndef g(nums=[1, 2, 3, 4]):\n    return nums\n\nassert f(g()) == 2\n",
        "idx_generation": 255,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom heapq import heappop, heappush\n\ndef f(graph: Dict[int, List[Tuple[int, int]]], start: int, end: int) -> List[int]:\n    \"\"\"\n    Given a weighted directed graph represented as an adjacency list, find the shortest path from a given start node\n    to a given end node.\n\n    Return the shortest path as a list of nodes.\n\n    Example:\n    graph = {1: [(2, 1), (3, 3)],\n             2: [(4, 2)],\n             3: [(4, 1)],\n             4: []}\n    start = 1, end = 4\n    The graph is represented as follows:\n    1 -(1)-> 2 -(2)-> 4\n      -(3)-> 3 -(1)-> 4\n    The shortest path from node 1 to node 4 is 1 -> 2 -> 4, so the function should return [1, 2, 4].\n    \"\"\"\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    heap = [(0, start)]\n    prev = {}\n\n    while heap:\n        dist, node = heappop(heap)\n\n        if dist > distances[node]:\n            continue\n\n        if node == end:\n            path = []\n            while node is not None:\n                path.append(node)\n                node = prev.get(node)\n            return path[::-1]\n\n        for neighbor, weight in graph[node]:\n            new_dist = dist + weight\n\n            if new_dist < distances[neighbor]:\n                distances[neighbor] = new_dist\n                prev[neighbor] = node\n                heappush(heap, (new_dist, neighbor))\n\n    return []\n\ndef g():\n    return {1: [(2, 1), (3, 3)],\n            2: [(4, 2)],\n            3: [(4, 1)],\n            4: []}, 1, 4\n\nassert f(*g()) == [1, 2, 4]\n\n",
        "idx_generation": 483,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode, target: int) -> int:\n    \"\"\"\n    Given a binary tree and a target number, find the number of paths in the tree that sum up to the target.\n    Return the count.\n    \"\"\"\n    def path_sum_helper(node, target, current_sum, prefix_sums):\n        if not node:\n            return 0\n        \n        current_sum += node.val\n        count = prefix_sums.get(current_sum - target, 0)\n        prefix_sums[current_sum] = prefix_sums.get(current_sum, 0) + 1\n        \n        count += path_sum_helper(node.left, target, current_sum, prefix_sums)\n        count += path_sum_helper(node.right, target, current_sum, prefix_sums)\n        \n        prefix_sums[current_sum] -= 1\n        \n        return count\n\n    return path_sum_helper(root, target, 0, {0: 1})\n\ndef g():\n    root = TreeNode(10)\n    root.left = TreeNode(5)\n    root.right = TreeNode(-3)\n    root.left.left = TreeNode(3)\n    root.left.right = TreeNode(2)\n    root.right.right = TreeNode(11)\n    root.left.left.left = TreeNode(3)\n    root.left.left.right = TreeNode(-2)\n    root.left.right.right = TreeNode(1)\n    target = 8\n    return root, target\n\nassert f(*g()) == 3\n",
        "idx_generation": 149,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency list, determine if there is a path from a start node to an end node.\n\n    Args:\n    - graph: The directed graph represented as an adjacency list.\n    - start: The start node.\n    - end: The end node.\n\n    Returns:\n    - True if there is a path from the start node to the end node, False otherwise.\n    \"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g():\n    graph = {\n        0: [1, 2],\n        1: [2],\n        2: [3],\n        3: []\n    }\n    start = 0\n    end = 3\n    return graph, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 235,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer 'n', determine the number of combinations of valid parentheses pairs that can be formed with 'n' pairs of parentheses.\n\n    Example:\n    n = 3\n\n    Output:\n    5\n    \"\"\"\n    def backtrack(open_count, close_count):\n        if open_count == close_count == n:\n            return 1\n        if open_count > n or close_count > open_count:\n            return 0\n\n        return backtrack(open_count + 1, close_count) + backtrack(open_count, close_count + 1)\n\n    return backtrack(0, 0)\n\ndef g():\n    n = 3\n    return n\n\nassert f(g()) == 5\n",
        "idx_generation": 355,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"Count the number of ways to choose k objects from a set of n objects.\"\"\"\n    if k == 0 or k == n:\n        return 1\n    else:\n        return f(n - 1, k - 1) + f(n - 1, k)\n\ndef g():\n    n = 5\n    k = 3\n    return (n, k)\n\nassert f(*g()) == 10\n",
        "idx_generation": 214,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string 's' consisting of lowercase English letters, find the number of distinct substrings that can be formed from 's'.\n\n    Example:\n    Input: \"abc\"\n    Output: 6\n    Explanation: The distinct substrings that can be formed are \"a\", \"b\", \"c\", \"ab\", \"bc\", \"abc\".\n    \"\"\"\n    n = len(s)\n    distinct_substrings = set()\n\n    for i in range(n):\n        for j in range(i, n):\n            distinct_substrings.add(s[i:j+1])\n\n    return len(distinct_substrings)\n\ndef g(s: str = \"abc\"):\n    return s\n\nassert f(g()) == 6\n",
        "idx_generation": 296,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums sorted in ascending order, find two numbers such that they add up to a specific target number.\n\n    Return the indices of the two numbers (1-indexed) as an integer array answer of size 2, where 1 <= answer[0] < answer[1] <= nums.length.\n\n    You may assume that each input would have exactly one solution and you may not use the same element twice.\n\n    Example:\n    nums = [2,7,11,15]\n    target = 9\n\n    Output:\n    [1, 2]\n\n    Explanation:\n    The sum of 2 and 7 is 9. Therefore, the indices are 1 and 2.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left + 1, right + 1]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g(nums: List[int] = [2,7,11,15], target: int = 9):\n    return (nums, target,)\n\nassert f(*g()) == [1, 2]\n\n",
        "idx_generation": 494,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers 'nums' and a target value 'target',\n    find the index of the target in the list using binary search.\n    If the target is not found, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output:\n    2\n\n    Explanation:\n    The target value 5 is located at index 2 in the list.\n    \"\"\"\n\n    def binary_search(nums: List[int], target: int, left: int, right: int) -> int:\n        if left > right:\n            return -1\n\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            return binary_search(nums, target, mid + 1, right)\n        else:\n            return binary_search(nums, target, left, mid - 1)\n\n    return binary_search(nums, target, 0, len(nums) - 1)\n\ndef g() -> Tuple[List[int], int]:\n    return ([1, 3, 5, 7, 9], 5)\n\nassert f(*g()) == 2\n",
        "idx_generation": 168,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> List[int]:\n    \"\"\"\n    Given a string s, return a list of indices representing the starting positions of each occurrence of the substring \"ab\" in s.\n\n    Args:\n    - s: The input string.\n\n    Returns:\n    - A list of starting positions of each occurrence of \"ab\" in s.\n\n    Example:\n    f(\"abababa\")\n\n    Output:\n    [0, 2, 4]\n\n    Explanation:\n    The substring \"ab\" occurs at positions 0, 2, and 4 in the string \"abababa\".\n    \"\"\"\n\n    indices = []\n    i = 0\n\n    while i < len(s):\n        if s[i:i+2] == \"ab\":\n            indices.append(i)\n            i += 2\n        else:\n            i += 1\n\n    return indices\n\ndef g() -> str:\n    \"\"\"\n    Generate a string.\n\n    Returns:\n    - The generated string.\n\n    Example:\n    g() returns \"abababa\"\n    \"\"\"\n\n    return \"abababa\"\n\nassert f(g()) == [0, 2, 4]\n",
        "idx_generation": 357,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, return all subsets of the list.\n\n    Example:\n    nums = [1, 2, 3]\n\n    Output:\n    [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n    \"\"\"\n\n    def backtrack(start: int, subset: List[int], subsets: List[List[int]]) -> None:\n        subsets.append(subset[:])\n\n        for i in range(start, len(nums)):\n            subset.append(nums[i])\n            backtrack(i+1, subset, subsets)\n            subset.pop()\n\n    subsets = []\n    backtrack(0, [], subsets)\n\n    return subsets\n\ndef g() -> List[int]:\n    return [1, 2, 3]\n\nassert f(g()) == [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]\n",
        "idx_generation": 390,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of trailing zeroes in n!.\n\n    Example:\n    Input:\n    n = 10\n\n    Output: 2\n\n    Explanation: 10! = 3628800, which has 2 trailing zeroes.\n    \"\"\"\n\n    def count_trailing_zeroes(n: int) -> int:\n        count = 0\n        while n >= 5:\n            n = n // 5\n            count += n\n        return count\n\n    return count_trailing_zeroes(n)\n\ndef g():\n    n = 10\n    return n,\n\nassert f(*g()) == 2\n",
        "idx_generation": 481,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any contiguous subarray in the list.\n\n    Return the maximum sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The contiguous subarray with the maximum sum is [4, -1, 2, 1], which has a sum of 6.\n    \"\"\"\n    n = len(nums)\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for i in range(n):\n        curr_sum += nums[i]\n        \n        if curr_sum > max_sum:\n            max_sum = curr_sum\n        \n        if curr_sum < 0:\n            curr_sum = 0\n    \n    return max_sum\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 368,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n\n    Return the length of the longest increasing subsequence.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    n = len(nums)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n\n",
        "idx_generation": 393,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    12 (since the maximum sum path is 1 + 3 + 5 + 1 + 2 + 1 = 12)\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g():\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 12\n",
        "idx_generation": 315,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of non-negative integers, find the maximum XOR value between two numbers in the list.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set([num & mask for num in nums])\n        temp_max_xor = max_xor | (1 << i)\n\n        for prefix in prefix_set:\n            if temp_max_xor ^ prefix in prefix_set:\n                max_xor = temp_max_xor\n                break\n\n    return max_xor\n\ndef g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n",
        "idx_generation": 161,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique binary strings of length n that do not contain consecutive ones.\n\n    Sample Input:\n    n = 3\n\n    Sample Output:\n    5\n\n    Explanation:\n    The unique binary strings of length 3 that do not contain consecutive ones are:\n    000, 001, 010, 100, 101.\n    \"\"\"\n    def countStrings(n: int, lastBit: int) -> int:\n        if n == 0:\n            return 1\n        if dp[n][lastBit] != -1:\n            return dp[n][lastBit]\n        if lastBit == 0:\n            dp[n][lastBit] = countStrings(n-1, 0) + countStrings(n-1, 1)\n        else:\n            dp[n][lastBit] = countStrings(n-1, 0)\n        return dp[n][lastBit]\n\n    dp = [[-1] * 2 for _ in range(n+1)]\n    return countStrings(n, 0)\n\ndef g(n = 3):\n    return n\n\nassert f(g()) == 5\n",
        "idx_generation": 261,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> bool:\n    \"\"\"\n    Given a binary tree, determine if it is a valid binary search tree (BST).\n\n    A valid BST is defined as follows:\n        - The left subtree of a node contains only nodes with keys less than the node's key.\n        - The right subtree of a node contains only nodes with keys greater than the node's key.\n        - Both the left and right subtrees must also be binary search trees.\n\n    Example:\n    Input:\n        2\n       / \\\n      1   3\n    Output: True\n\n    Explanation: The binary tree [2,1,3] is a valid BST.\n\n    Hint: Perform an inorder traversal and check if the values are in ascending order. Use a stack to store the nodes during traversal.\n    \"\"\"\n\n    stack = []\n    prev = None\n\n    while root or stack:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and prev.val >= root.val:\n            return False\n        prev = root\n        root = root.right\n\n    return True\n\ndef g():\n    root = TreeNode(2)\n    root.left = TreeNode(1)\n    root.right = TreeNode(3)\n    return root\n\nassert f(g()) == True\n\n",
        "idx_generation": 484,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Graph:\n    def __init__(self, num_vertices: int):\n        self.num_vertices = num_vertices\n        self.adjacency_list = [[] for _ in range(num_vertices)]\n\n    def add_edge(self, u: int, v: int):\n        self.adjacency_list[u].append(v)\n\n    def is_reachable(self, start: int, end: int) -> bool:\n        \"\"\"\n        Given a graph and two vertices 'start' and 'end',\n        check if there is a path from 'start' to 'end' in the graph.\n\n        Example:\n        num_vertices = 4\n        edges = [(0, 1), (1, 2), (2, 3)]\n        start = 0\n        end = 3\n\n        Output:\n        True\n\n        Explanation:\n        There is a path from vertex 0 to vertex 3: 0 -> 1 -> 2 -> 3.\n\n        Hint: Use graph traversal techniques to find a path.\n        \"\"\"\n\n        visited = [False] * self.num_vertices\n\n        def dfs(vertex: int):\n            visited[vertex] = True\n            if vertex == end:\n                return True\n            for neighbor in self.adjacency_list[vertex]:\n                if not visited[neighbor]:\n                    if dfs(neighbor):\n                        return True\n            return False\n\n        return dfs(start)\n\ndef f(num_vertices: int, edges: List[Tuple[int, int]], start: int, end: int) -> bool:\n    graph = Graph(num_vertices)\n    for edge in edges:\n        graph.add_edge(edge[0], edge[1])\n    return graph.is_reachable(start, end)\n\ndef g() -> Tuple[int, List[Tuple[int, int]], int, int]:\n    num_vertices = 4\n    edges = [(0, 1), (1, 2), (2, 3)]\n    start = 0\n    end = 3\n    return num_vertices, edges, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 151,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency list, determine if there exists a path from\n    the start node to the end node.\n    \"\"\"\n    visited = set()\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n\n    return False\n\ndef g(graph: List[List[int]], start: int, end: int):\n    \"\"\"\n    Generate an adjacency list graph where there exists a path from the start node to the end node.\n    \"\"\"\n    graph[start].append(end)\n    return graph\n\ngraph = [\n    [1, 2],\n    [0, 3],\n    [0],\n    [1]\n]\nstart = 0\nend = 3\n\nassert f(g(graph, start, end), start, end)\n",
        "idx_generation": 240,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport itertools\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product that can be obtained from a subset of the integers.\n    Return the maximum product.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    24\n\n    Explanation:\n    The maximum product can be obtained by multiplying 3 and 4, which gives a product of 12.\n    \"\"\"\n\n    def find_max_product(nums):\n        n = len(nums)\n        max_product = float('-inf')\n        for r in range(1, n+1):\n            subsets = itertools.combinations(nums, r)\n            for subset in subsets:\n                product = 1\n                for num in subset:\n                    product *= num\n                max_product = max(max_product, product)\n        return max_product\n\n    return find_max_product(nums)\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == 24\n",
        "idx_generation": 361,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Count the number of valid parentheses expressions of length 2n.\n    A valid parentheses expression is one in which the parentheses are properly balanced.\n\n    Example:\n    n = 3\n    output: 5\n\n    Explanation:\n    The valid parentheses expressions of length 6 are:\n    1. ((()))\n    2. (()())\n    3. (())()\n    4. ()(())\n    5. ()()()\n    \"\"\"\n    dp = [0] * (n+1)\n    dp[0] = 1\n\n    for i in range(1, n+1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i-j-1]\n\n    return dp[n]\n\ndef g(n: int = 3) -> List[int]:\n    \"\"\"\n    Generate the length of a valid parentheses expression for the function f.\n    \"\"\"\n    return [n]\n\nassert f(*g()) == 5\n\n",
        "idx_generation": 221,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Given two strings, check if they are anagrams of each other.\n    Return True if they are anagrams, otherwise return False.\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n\n    count = [0] * 26\n\n    for ch in s1:\n        count[ord(ch) - ord('a')] += 1\n\n    for ch in s2:\n        count[ord(ch) - ord('a')] -= 1\n\n    for c in count:\n        if c != 0:\n            return False\n\n    return True\n\ndef g(s1 = \"listen\", s2 = \"silent\"):\n    return s1, s2\n\nassert f(*g()) == True\n",
        "idx_generation": 316,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, sort each row in ascending order.\n\n    Args:\n    - matrix: A matrix of integers.\n\n    Returns:\n    - A matrix with each row sorted in ascending order.\n\n    Example:\n    matrix = [\n        [3, 2, 1],\n        [6, 5, 4],\n        [9, 8, 7]\n    ]\n\n    Output:\n    [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    \"\"\"\n    for row in matrix:\n        row.sort()\n    \n    return matrix\n\ndef g(matrix=[[3, 2, 1], [6, 5, 4], [9, 8, 7]]):\n    \"\"\"\n    Generate a matrix of integers.\n    \"\"\"\n    return matrix\n\nassert f(g()) == [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n",
        "idx_generation": 496,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the area of the largest rectangle that can be formed by 1s.\n\n    Sample input:\n    grid = [[1, 0, 1, 0, 0],\n            [1, 0, 1, 1, 1],\n            [1, 1, 1, 1, 1],\n            [1, 0, 0, 1, 0]]\n\n    Sample output:\n    6\n\n    Explanation:\n    The largest rectangle that can be formed by 1s in the grid has an area of 6.\n\n    Hint: Use the largest rectangle in histogram problem to solve this.\n    \"\"\"\n\n    def largest_rectangle_area(heights: List[int]) -> int:\n        stack = [-1]\n        max_area = 0\n\n        for i in range(len(heights)):\n            while stack[-1] != -1 and heights[stack[-1]] >= heights[i]:\n                height = heights[stack.pop()]\n                width = i - stack[-1] - 1\n                max_area = max(max_area, height * width)\n            stack.append(i)\n\n        while stack[-1] != -1:\n            height = heights[stack.pop()]\n            width = len(heights) - stack[-1] - 1\n            max_area = max(max_area, height * width)\n\n        return max_area\n\n    if not grid:\n        return 0\n\n    m = len(grid)\n    n = len(grid[0])\n    heights = [0] * n\n    max_area = 0\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                heights[j] = 0\n            else:\n                heights[j] += 1\n\n        max_area = max(max_area, largest_rectangle_area(heights))\n\n    return max_area\n\ndef g():\n    return [[1, 0, 1, 0, 0],\n            [1, 0, 1, 1, 1],\n            [1, 1, 1, 1, 1],\n            [1, 0, 0, 1, 0]]\n\nassert f(g()) == 6\n\n",
        "idx_generation": 173,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], k: int) -> List[str]:\n    \"\"\"\n    Given a list of words and an integer k, return the k most frequent words in the list.\n    If two words have the same frequency, then the word with the lower alphabetical order comes first.\n    \"\"\"\n    word_count = {}\n    for word in words:\n        if word in word_count:\n            word_count[word] += 1\n        else:\n            word_count[word] = 1\n    \n    sorted_words = sorted(word_count.keys(), key=lambda x: (-word_count[x], x))\n    \n    return sorted_words[:k]\n\ndef g():\n    return ([\"apple\", \"banana\", \"cherry\", \"apple\", \"banana\", \"apple\"], 2)\n\nassert f(*g()) == [\"apple\", \"banana\"]\n",
        "idx_generation": 367,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find the next permutation in ascending order.\n\n    Example:\n    nums = [1, 2, 3]\n    Next permutation: [1, 3, 2]\n\n    Return the next permutation in ascending order.\n    \"\"\"\n    def reverse(nums: List[int], start: int, end: int) -> None:\n        while start < end:\n            nums[start], nums[end] = nums[end], nums[start]\n            start += 1\n            end -= 1\n    \n    n = len(nums)\n    i = n - 2\n    while i >= 0 and nums[i] >= nums[i + 1]:\n        i -= 1\n    \n    if i >= 0:\n        j = n - 1\n        while nums[j] <= nums[i]:\n            j -= 1\n        nums[i], nums[j] = nums[j], nums[i]\n    \n    reverse(nums, i + 1, n - 1)\n    return nums\n\ndef g() -> List[int]:\n    nums = [1, 2, 3]\n    return nums\n\nassert f(g()) == [1, 3, 2]\n\n",
        "idx_generation": 406,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(prices: List[int]) -> int:\n    \"\"\"\n    Given a list of stock prices, find the maximum profit that can be obtained by buying and selling the stock.\n    You can only perform one transaction (i.e., buy one and sell one share of the stock).\n\n    Example:\n    prices = [7, 1, 5, 3, 6, 4]\n    The maximum profit that can be obtained is 5 (buy at 1 and sell at 6).\n\n    Constraints:\n    - The input list prices will have at least one element.\n    - Each element in the list prices will be a non-negative integer.\n    \"\"\"\n    max_profit = 0\n    min_price = float('inf')\n    \n    for price in prices:\n        min_price = min(min_price, price)\n        max_profit = max(max_profit, price - min_price)\n    \n    return max_profit\n\ndef g():\n    prices = [7, 1, 5, 3, 6, 4]\n    return prices\n\nassert f(g()) == 5\n",
        "idx_generation": 369,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Determine the number of ways to climb to the top of a staircase with 'n' steps, where at each step you can either climb 1 or 2 steps.\n    The number of ways should be returned modulo 10^9 + 7.\n\n    Example:\n    Input: n = 3, k = 100\n    Output: 3\n\n    Explanation: There are 3 ways to climb to the top: [1, 1, 1], [1, 2], [2, 1].\n\n    Hint: Use dynamic programming to store the number of ways to reach each step.\n    \"\"\"\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = (dp[i - 1] + dp[i - 2]) % (10**9 + 7)\n    return dp[n]\n\ndef g(n=3, k=100):\n    return n, k\n\nassert f(*g()) == 3\n",
        "idx_generation": 394,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two positive integers n and m, calculate the number of unique paths from the top-left corner to the bottom-right corner of an n x m grid.\n\n    Example:\n    n = 3\n    m = 3\n\n    Output:\n    6\n\n    Explanation:\n    There are 6 unique paths from the top-left corner to the bottom-right corner of a 3 x 3 grid.\n\n    Hint: Use dynamic programming to store the number of paths for each grid cell.\n    \"\"\"\n\n    dp = [[1] * m] * n\n\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[n-1][m-1]\n\ndef g(n=3, m=3):\n    return n, m\n\nassert f(*g()) == 6\n\n",
        "idx_generation": 320,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum bitwise XOR value between any two numbers in the list.\n    Return the maximum XOR value.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value is 28, which is the result of the XOR operation between 5 and 25 (5 XOR 25 = 28).\n    \"\"\"\n\n    def find_max_xor(nums):\n        max_xor = 0\n        mask = 0\n        for i in range(31, -1, -1):\n            mask |= (1 << i)\n            prefixes = set()\n            for num in nums:\n                prefixes.add(num & mask)\n            max_possible_xor = max_xor | (1 << i)\n            for prefix in prefixes:\n                if (prefix ^ max_possible_xor) in prefixes:\n                    max_xor = max_possible_xor\n                    break\n        return max_xor\n\n    return find_max_xor(nums)\n\ndef g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return (nums,)\n\nassert f(*g()) == 28\n",
        "idx_generation": 162,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the nth Fibonacci number.\n\n    Sample Input:\n    n = 6\n\n    Sample Output:\n    8\n    \"\"\"\n    if n <= 1:\n        return n\n    fib = [0, 1]\n    for i in range(2, n+1):\n        fib.append(fib[i-1] + fib[i-2])\n    return fib[n]\n\ndef g() -> int:\n    n = 6\n    return (n,)\n\nassert f(*g()) == 8\n",
        "idx_generation": 264,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> List[int]:\n    \"\"\"\n    Given a binary tree, return the inorder traversal of its nodes' values.\n\n    Example:\n    Input:\n        1\n         \\\n          2\n         /\n        3\n    Output: [1,3,2]\n\n    Hint: Use a stack to simulate the recursive inorder traversal. Start from the root and traverse to the leftmost node, pushing all the nodes along the way. Once there are no more left nodes, pop a node from the stack, add its value to the result list, and move to its right child. Repeat until the stack is empty and all nodes have been traversed.\n    \"\"\"\n\n    result = []\n    stack = []\n\n    while root or stack:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        result.append(root.val)\n        root = root.right\n\n    return result\n\ndef g():\n    root = TreeNode(1)\n    root.right = TreeNode(2)\n    root.right.left = TreeNode(3)\n    return root\n\nassert f(g()) == [1, 3, 2]\n\n",
        "idx_generation": 484,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\n\nclass Node:\n    def __init__(self, val: int) -> None:\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef f(root: Optional[Node]) -> int:\n    \"\"\"\n    Given a binary tree, calculate the sum of all the numbers formed from root to leaf paths.\n\n    Example:\n    Input:\n            1\n           / \\\n          2   3\n\n    Output: 25\n    Explanation: The sum of all numbers formed from root to leaf paths is 12 + 13 = 25.\n    \"\"\"\n    if root is None:\n        return 0\n    \n    def dfs(node: Node, current_sum: int) -> int:\n        if node is None:\n            return 0\n        \n        current_sum = current_sum * 10 + node.val\n        \n        if node.left is None and node.right is None:\n            return current_sum\n        \n        return dfs(node.left, current_sum) + dfs(node.right, current_sum)\n    \n    return dfs(root, 0)\n\ndef g() -> Optional[Node]:\n    \"\"\"\n    Generate a binary tree.\n    \"\"\"\n    node1 = Node(1)\n    node2 = Node(2)\n    node3 = Node(3)\n\n    node1.left = node2\n    node1.right = node3\n\n    return node1\n\nassert f(g()) == 25\n",
        "idx_generation": 151,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Check if there is a path from start to end in the given graph using Depth First Search.\n    \"\"\"\n    def dfs(curr, visited):\n        visited.add(curr)\n        if curr == end:\n            return True\n        for neighbor in graph[curr]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited):\n                    return True\n        return False\n    \n    visited = set()\n    return dfs(start, visited)\n\ndef g() -> Tuple[List[List[int]], int, int]:\n    graph = [[1, 2], [3], [4], [2, 5], []]\n    start = 0\n    end = 5\n    return graph, start, end\n\nassert f(*g()) == True\n\n",
        "idx_generation": 242,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer 'n', find the number of ways to arrange 'n' distinct objects in a row, subject to certain restrictions.\n    The restrictions are:\n    - The first object must be placed at one of the ends.\n    - The second object must be placed next to the first object.\n\n    Return the number of possible arrangements.\n\n    Example:\n    n = 3\n\n    Output:\n    2\n\n    Explanation:\n    The possible arrangements are: [1, 2, 3] and [3, 2, 1].\n\n    Hint: Use combinatorics to calculate the number of arrangements.\n    \"\"\"\n    if n <= 2:\n        return n\n\n    return 2\n\ndef g(n=3):\n    return n\n\nassert f(g()) == 2\n\n",
        "idx_generation": 378,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, find the number of ways to select k elements from a set of n elements \n    such that no two selected elements have consecutive indices. Return the count of such selections.\n    \"\"\"\n    if k > n:\n        return 0\n    \n    if k == 0 or k == n:\n        return 1\n    \n    dp = [[0] * (k+1) for _ in range(n+1)]\n    \n    for i in range(n+1):\n        dp[i][0] = 1\n    \n    for i in range(1, n+1):\n        for j in range(1, min(i, k)+1):\n            dp[i][j] = dp[i-1][j] + dp[i-2][j-1]\n    \n    return dp[n][k]\n\ndef g():\n    return 5, 2\n\nassert f(*g()) == 6\n",
        "idx_generation": 226,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, count the number of distinct substrings that can be formed from s.\n    \"\"\"\n\n    n = len(s)\n    substrings = set()\n    for i in range(n):\n        for j in range(i+1, n+1):\n            substrings.add(s[i:j])\n    \n    return len(substrings)\n\ndef g():\n    s = \"abc\"\n    return s\n    \nassert f(g()) == 6\n",
        "idx_generation": 322,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target value, find two numbers in the list that add up to the target value.\n    \n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    \n    Output:\n    [2, 7]\n    \"\"\"\n    \n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        cur_sum = nums[left] + nums[right]\n        if cur_sum == target:\n            return [nums[left], nums[right]]\n        elif cur_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [2, 7]\n",
        "idx_generation": 498,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the number of occurrences of a specific target number.\n    \"\"\"\n    def binary_search(arr: List[int], target: int) -> int:\n        left = 0\n        right = len(arr) - 1\n        count = 0\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == target:\n                count += 1\n                i = 1\n                while mid - i >= 0 and arr[mid - i] == target:\n                    count += 1\n                    i += 1\n                i = 1\n                while mid + i < len(arr) and arr[mid + i] == target:\n                    count += 1\n                    i += 1\n                break\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return count\n    \n    target = 5\n    return binary_search(arr, target)\n\ndef g():\n    return [1, 2, 3, 4, 5, 5, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == 3\n",
        "idx_generation": 174,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target element using linear search.\n    If the target element is not found, return -1.\n    \"\"\"\n    for i in range(len(nums)):\n        if nums[i] == target:\n            return i\n    return -1\n\ndef g():\n    nums = [4, 5, 2, 1, 7]\n    target = 2\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 382,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Check if there exists a subarray in the given list whose sum is equal to the target value.\n    \"\"\"\n    n = len(arr)\n    prefix = [arr[0]]\n    for i in range(1, n):\n        prefix.append(prefix[-1] + arr[i])\n\n    for i in range(n):\n        for j in range(i, n):\n            if i == 0:\n                if prefix[j] == target:\n                    return True\n            else:\n                if (prefix[j] - prefix[i-1]) == target:\n                    return True\n    return False\n\ndef g(arr: List[int] = [2, 4, 6, 8, 10], target: int = 14) -> List[int]:\n    return arr, target\n\nassert f(g()[0], g()[1]) == True\n",
        "idx_generation": 407,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct\n    numbers in the list. Return the maximum product.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    20\n\n    Explanation:\n    The maximum product is 4 * 5 = 20.\n    \"\"\"\n\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n    return max_product\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 20\n",
        "idx_generation": 370,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum sum of a contiguous subarray.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g(nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 395,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the size of the largest square of 1s in the grid.\n\n    Example:\n    grid = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n\n    The largest square of 1s in the grid has a size of 2x2.\n\n    Return the size of the largest square of 1s in the grid.\n    \"\"\"\n    if not grid:\n        return 0\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n    max_square_size = 0\n    \n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            if grid[i - 1][j - 1] == 1:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                max_square_size = max(max_square_size, dp[i][j])\n    \n    return max_square_size * max_square_size\n\ndef g():\n    return [[[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]]\n\nassert f(*g()) == 4\n",
        "idx_generation": 321,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(num1: int, num2: int) -> int:\n    \"\"\"\n    Given two integers, return their sum using bit manipulation.\n    \"\"\"\n    while num2 != 0:\n        carry = num1 & num2\n        num1 = num1 ^ num2\n        num2 = carry << 1\n    return num1\n\ndef g():\n    num1 = 10\n    num2 = 5\n    return num1, num2\n\nassert f(*g()) == 15\n\n",
        "idx_generation": 163,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of size n x m, where each cell contains a non-negative integer, find the maximum sum along a path from the top-left cell to the bottom-right cell. You can only move down or right in the matrix.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n\n    Output:\n    29\n\n    Explanation:\n    The maximum sum along a path from the top-left cell to the bottom-right cell is 1 + 4 + 7 + 8 + 9 = 29.\n\n    Hint: Use dynamic programming to build a grid of sums for each cell, starting from the top-left cell.\n    \"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n\n    # Create a grid to store the sums for each cell\n    sums = [[0] * n for _ in range(m)]\n\n    # Initialize the sums for the top row and left column\n    for i in range(m):\n        sums[i][0] = sums[i-1][0] + matrix[i][0]\n    for j in range(n):\n        sums[0][j] = sums[0][j-1] + matrix[0][j]\n\n    # Calculate the sums for each cell\n    for i in range(1, m):\n        for j in range(1, n):\n            sums[i][j] = max(sums[i-1][j], sums[i][j-1]) + matrix[i][j]\n\n    # Return the maximum sum along a path to the bottom-right cell\n    return sums[m-1][n-1]\n\ndef g():\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    return matrix\n\nassert f(g()) == 29\n\n",
        "idx_generation": 268,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the minimum initial health the knight needs in order to reach the princess.\n    The knight can only move right and down, and the health should never drop to 0 or below.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[m-1][n-1] = max(1, 1 - grid[m-1][n-1])\n    \n    for i in range(m-2, -1, -1):\n        dp[i][n-1] = max(dp[i+1][n-1] - grid[i][n-1], 1)\n    for j in range(n-2, -1, -1):\n        dp[m-1][j] = max(dp[m-1][j+1] - grid[m-1][j], 1)\n    \n    for i in range(m-2, -1, -1):\n        for j in range(n-2, -1, -1):\n            dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - grid[i][j], 1)\n    \n    return dp[0][0]\n\ndef g(grid=[[1, -3, 3], [0, -2, 0], [-3, -3, -3]]):\n    return grid\n\nassert f(g()) == 3\n",
        "idx_generation": 152,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> List[str]:\n    \"\"\"\n    Given a graph represented as a dictionary of nodes and their corresponding neighbors, find the shortest path from the start node to the end node.\n    If there are multiple shortest paths, return any valid path.\n\n    Example:\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['A', 'D', 'E'],\n        'C': ['A', 'F'],\n        'D': ['B'],\n        'E': ['B', 'F'],\n        'F': ['C', 'E']\n    }\n    start = 'A'\n    end = 'F'\n\n    Output:\n    ['A', 'C', 'F']\n\n    Explanation:\n    The shortest path from 'A' to 'F' is ['A', 'C', 'F'].\n\n    Hint: Use a breadth-first search algorithm to find the shortest path.\n    \"\"\"\n\n    queue = [(start, [start])]\n    visited = set()\n\n    while queue:\n        node, path = queue.pop(0)\n        if node == end:\n            return path\n        if node not in visited:\n            visited.add(node)\n            for neighbor in graph[node]:\n                queue.append((neighbor, path + [neighbor]))\n\n    return []\n\ndef g(graph: Dict[str, List[str]] = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D', 'E'],\n    'C': ['A', 'F'],\n    'D': ['B'],\n    'E': ['B', 'F'],\n    'F': ['C', 'E']\n}, start: str = 'A', end: str = 'F') -> Tuple[Dict[str, List[str]], str, str]:\n    \"\"\"\n    Generate a graph represented as a dictionary, a start node, and an end node for the function f.\n    \"\"\"\n    return graph, start, end\n\nassert f(*g()) == ['A', 'C', 'F']\n",
        "idx_generation": 244,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Given an integer n and a positive integer k, generate all possible permutations of k numbers out of the range [1, n].\n\n    Example:\n    n = 4\n    k = 2\n\n    Output:\n    [[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 4], [3, 1], [3, 2], [3, 4], [4, 1], [4, 2], [4, 3]]\n\n    Hint: Use recursion and a backtracking approach to generate all permutations.\n    \"\"\"\n\n    def backtrack(curr_perm):\n        if len(curr_perm) == k:\n            result.append(curr_perm[:])\n            return\n        \n        for num in range(1, n + 1):\n            if num not in curr_perm:\n                curr_perm.append(num)\n                backtrack(curr_perm)\n                curr_perm.pop()\n\n    result = []\n    backtrack([])\n    return result\n\ndef g():\n    return (4, 2)\n\nassert f(*g()) == [[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 4], [3, 1], [3, 2], [3, 4], [4, 1], [4, 2], [4, 3]]\n",
        "idx_generation": 380,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique paths from the top-left corner to the bottom-right corner of a n x n grid. You can only move down or right.\n    \"\"\"\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        dp[0][i] = 1\n        dp[i][0] = 1\n    \n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[n-1][n-1]\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    return 3\n\nassert f(g()) == 6\n\n",
        "idx_generation": 229,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> int:\n    \"\"\"\n    Given a string s, count the number of distinct substrings of length k.\n    \"\"\"\n\n    def count_distinct_substrings(s, k):\n        distinct_substrings = set()\n        n = len(s)\n        for i in range(n - k + 1):\n            substring = s[i:i+k]\n            distinct_substrings.add(substring)\n        return len(distinct_substrings)\n\n    return count_distinct_substrings(s, k)\n\ndef g():\n    return (\"ababa\", 3)\n\nassert f(*g()) == 2\n",
        "idx_generation": 339,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\n\n    Example:\n    Input: arr = [2, 4, 7, 11, 15], target = 9\n    Output: True\n\n    Explanation: The sum of 2 and 7 is equal to the target value 9.\n\n    Hint: Use a two-pointer approach to search for the pair of numbers.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    return ([2, 4, 7, 11, 15], 9)\n\nassert f(*g()) == True\n",
        "idx_generation": 499,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers 'nums' and a target integer 'target', \n    return True if 'target' is present in the list, False otherwise.\n    \"\"\"\n    def binary_search(nums, target, left, right):\n        if left > right:\n            return False\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            return binary_search(nums, target, mid + 1, right)\n        else:\n            return binary_search(nums, target, left, mid - 1)\n    \n    return binary_search(nums, target, 0, len(nums) - 1)\n\ndef g(nums=[1, 2, 3, 4, 5, 6], target=4):\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 174,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\nfrom typing import List, Tuple\n\ndef f(words: List[str], target: str) -> Tuple[str, List[str]]:\n    \"\"\"\n    Given a list of words and a target word, find the word in the list that is closest to the target word based on\n    mathematical distance. The mathematical distance between two words is calculated as the sum of the absolute\n    differences between the ASCII values of their corresponding characters.\n\n    Args:\n    - words: A list of strings, the words to search through.\n    - target: A string, the target word to find the closest word to.\n\n    Returns:\n    - A tuple containing the closest word and a list of all words that have the same distance to the target word.\n    \"\"\"\n    closest_word = \"\"\n    closest_distance = float('inf')\n    same_distance_words = []\n\n    for word in words:\n        distance = sum(abs(ord(c1) - ord(c2)) for c1, c2 in zip(word, target))\n        \n        if distance < closest_distance:\n            closest_word = word\n            closest_distance = distance\n            same_distance_words = [word]\n        elif distance == closest_distance:\n            same_distance_words.append(word)\n\n    return closest_word, same_distance_words\n\ndef g() -> Tuple[List[str], str]:\n    words = [\"apple\", \"banana\", \"cherry\", \"durian\"]\n    target = \"berry\"\n    return words, target\n\nassert f(*g()) == (\"cherry\", [\"cherry\"])\n",
        "idx_generation": 398,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of binary strings of length n that do not have any consecutive 1s.\n\n    Args:\n    - n: The length of the binary strings.\n\n    Returns:\n    - The number of binary strings without consecutive 1s.\n    \"\"\"\n    if n == 1:\n        return 2\n    if n == 2:\n        return 3\n    \n    a, b = 1, 2\n    for _ in range(3, n+1):\n        a, b = b, a + b\n    \n    return b\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 424,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subarray.\n\n    Example:\n    nums = [1, 3, 2, 4, 7, 6, 8]\n\n    Output:\n    3\n\n    Explanation:\n    The longest increasing subarray is [2, 4, 7] of length 3.\n    \"\"\"\n\n    max_length = 0\n    curr_length = 1\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i-1]:\n            curr_length += 1\n        else:\n            max_length = max(max_length, curr_length)\n            curr_length = 1\n    max_length = max(max_length, curr_length)\n    return max_length\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    return [1, 3, 2, 4, 7, 6, 8]\n\nassert f(g()) == 3\n",
        "idx_generation": 372,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n    \"\"\"\n    if n <= 1:\n        return n\n    fib = [0, 1]\n    for i in range(2, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2])\n    return fib[n]\n\ndef g(n = 6):\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 395,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique paths from the top-left corner to the bottom-right corner of a grid with dimensions n x n.\n    You can only move down or right at any point in time.\n    \"\"\"\n    def unique_paths_helper(x: int, y: int, n: int) -> int:\n        if x == n-1 or y == n-1:\n            return 1\n        return unique_paths_helper(x+1, y, n) + unique_paths_helper(x, y+1, n)\n    \n    return unique_paths_helper(0, 0, n)\n\ndef g() -> int:\n    n = 3\n    return n\n\nassert f(g()) == 6\n\n",
        "idx_generation": 324,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, count the number of bits set to 1 in its binary representation.\n    \n    Example:\n    n = 13\n    \n    Output:\n    3 (as the binary representation of 13 is 1101, which has 3 bits set to 1)\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g():\n    return 13\n\nassert f(g()) == 3\n",
        "idx_generation": 178,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the minimum number of elements to remove from the list so that the sum of the remaining elements is equal to the target value.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n    Output: 2\n    Explanation: Removing 1 and 3 gives [2, 4, 5], which sums up to 9.\n    \"\"\"\n    n = len(nums)\n    dp = [[0] * (target + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = 0\n    for j in range(1, target + 1):\n        dp[0][j] = float('inf')\n    \n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if nums[i-1] > j:\n                dp[i][j] = dp[i-1][j]\n            else:\n                dp[i][j] = min(dp[i-1][j], dp[i-1][j-nums[i-1]] + 1)\n    \n    return dp[n][target]\n\ndef g() -> Tuple[List[int], int]:\n    return [1, 2, 3, 4, 5], 9\n\nassert f(*g()) == 2\n",
        "idx_generation": 275,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given a number 'n' and a list of directed edges, determine if there is a path from node 0 to node n-1.\n\n    Sample Input:\n    n = 4\n    edges = [[0, 1], [1, 2], [2, 3]]\n\n    Sample Output:\n    True\n    \"\"\"\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n    visited = [False] * n\n\n    def dfs(node):\n        if node == n - 1:\n            return True\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor] and dfs(neighbor):\n                return True\n        return False\n\n    return dfs(0)\n\ndef g(n=4, edges=[[0, 1], [1, 2], [2, 3]]):\n    return n, edges\n\nassert f(*g()) == True\n\n",
        "idx_generation": 154,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 0 represents an empty cell and 1 represents a wall,\n    find the length of the shortest path from the top-left corner to the bottom-right corner,\n    moving only through empty cells.\n\n    You can only move horizontally or vertically, not diagonally.\n    If there is no possible path, return -1.\n\n    Example:\n    grid = [\n        [0, 1, 0, 0, 0],\n        [0, 1, 0, 1, 0],\n        [0, 0, 0, 1, 0],\n        [0, 1, 0, 0, 0],\n        [0, 0, 0, 1, 0]\n    ]\n\n    Output:\n    8\n\n    Explanation:\n    The shortest path is (0, 0) -> (1, 0) -> (2, 0) -> (3, 0) -> (3, 1) -> (3, 2) -> (4, 2) -> (4, 3) -> (4, 4),\n    which has a length of 8.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    queue = [(0, 0, 0)]\n    visited = set((0, 0))\n\n    while queue:\n        row, col, dist = queue.pop(0)\n\n        if row == rows - 1 and col == cols - 1:\n            return dist\n\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            new_row = row + dr\n            new_col = col + dc\n\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 0 and (new_row, new_col) not in visited:\n                queue.append((new_row, new_col, dist + 1))\n                visited.add((new_row, new_col))\n\n    return -1\n\ndef g(grid=[\n    [0, 1, 0, 0, 0],\n    [0, 1, 0, 1, 0],\n    [0, 0, 0, 1, 0],\n    [0, 1, 0, 0, 0],\n    [0, 0, 0, 1, 0]\n]):\n    return grid\n\nassert f(g()) == 8\n\n",
        "idx_generation": 249,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, check if s is an anagram of t.\n\n    Example:\n    s = \"listen\"\n    t = \"silent\"\n\n    Output:\n    True\n\n    Explanation:\n    The characters in s can be rearranged to form t.\n\n    Hint: Use counting and combinatorics to check if two strings are anagrams.\n    \"\"\"\n\n    if len(s) != len(t):\n        return False\n\n    count_s = [0] * 26\n    count_t = [0] * 26\n\n    for char in s:\n        count_s[ord(char) - ord('a')] += 1\n\n    for char in t:\n        count_t[ord(char) - ord('a')] += 1\n\n    return count_s == count_t\n\ndef g() -> Tuple[str, str]:\n    s = \"listen\"\n    t = \"silent\"\n    return s, t\n\nassert f(*g()) == True\n\n",
        "idx_generation": 381,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of distinct permutations of the digits 1 to n.\n\n    Example:\n    n = 3\n\n    Output:\n    6\n\n    Explanation:\n    The distinct permutations of the digits 1 to 3 are: [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].\n    \"\"\"\n\n    def backtrack(nums: List[int], perm: List[int], used: List[bool], result: List[List[int]]) -> None:\n        if len(perm) == len(nums):\n            result.append(perm[:])\n            return\n\n        for i in range(len(nums)):\n            if not used[i]:\n                used[i] = True\n                perm.append(nums[i])\n                backtrack(nums, perm, used, result)\n                perm.pop()\n                used[i] = False\n\n    nums = list(range(1, n + 1))\n    result = []\n    used = [False] * n\n    backtrack(nums, [], used, result)\n\n    return len(result)\n\ndef g():\n    return (3,)\n\nassert f(*g()) == 6\n\n",
        "idx_generation": 230,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> int:\n    \"\"\"\n    Given a string, count the number of distinct substrings that can be formed from the string.\n    \"\"\"\n    distinct_substrings = set()\n    \n    for i in range(len(string)):\n        for j in range(i+1, len(string)+1):\n            distinct_substrings.add(string[i:j])\n    \n    return len(distinct_substrings)\n\ndef g():\n    string = \"abc\"\n    return string\n\nassert f(g()) == 6\n",
        "idx_generation": 357,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the second largest element in the array.\n    \n    Example:\n    arr = [5, 2, 8, 1, 3]\n    \n    Output:\n    5\n    \"\"\"\n    arr.sort()\n    return arr[-2]\n\ndef g() -> List[int]:\n    return [5, 2, 8, 1, 3]\n\nassert f(g()) == 5\n\n",
        "idx_generation": 343,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list and a target value, return the index of the target value in the list.\n    Use binary search algorithm to find the index.\n\n    Sample Input:\n    arr = [2, 4, 6, 8, 10]\n    target = 6\n\n    Sample Output:\n    2\n\n    Explanation:\n    The target value 6 is present at index 2 in the list.\n    \"\"\"\n    def binary_search(nums: List[int], target: int) -> int:\n        low, high = 0, len(nums) - 1\n        while low <= high:\n            mid = (low + high) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return -1\n\n    return binary_search(arr, target)\n\ndef g(arr = [2, 4, 6, 8, 10], target = 6):\n    return arr, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 177,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(words: List[str], k: int) -> List[str]:\n    \"\"\"\n    Given a list of words and an integer k, return the k most frequent words in the list.\n\n    Args:\n    - words: A list of strings.\n    - k: An integer representing the number of most frequent words to return.\n\n    Returns:\n    - A list of the k most frequent words.\n\n    Example:\n    words = [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"]\n    k = 2\n\n    Output:\n    [\"the\", \"is\"]\n\n    Explanation:\n    The word \"the\" appears 4 times, while the words \"is\" and \"sunny\" appear 3 times each. Therefore, the 2 most frequent words are \"the\" and \"is\".\n    \"\"\"\n\n    # Create a dictionary to store the word frequencies\n    word_freq = {}\n\n    # Count the frequencies of each word\n    for word in words:\n        if word in word_freq:\n            word_freq[word] += 1\n        else:\n            word_freq[word] = 1\n\n    # Sort the words based on their frequencies\n    sorted_words = sorted(word_freq.keys(), key=lambda x: (-word_freq[x], x))\n\n    # Return the k most frequent words\n    return sorted_words[:k]\n\ndef g(words: List[str] = [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], k: int = 2) -> List[str]:\n    return words, k\n\nassert f(*g()) == [\"the\", \"is\"]\n\n",
        "idx_generation": 409,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array of integers and a target value, find all unique combinations of numbers in the array that sum up to the target.\n    Each number in the array may only be used once in the combination.\n\n    Example:\n    Input:\n    nums = [10, 1, 2, 7, 6, 1, 5]\n    target = 8\n\n    Output:\n    [\n        [1, 1, 6],\n        [1, 2, 5],\n        [1, 7],\n        [2, 6]\n    ]\n\n    Explanation:\n    The combinations [1, 1, 6], [1, 2, 5], [1, 7], and [2, 6] are the unique combinations of numbers in the array that sum up to the target value of 8.\n    \"\"\"\n\n    def backtrack(combination, start, target):\n        if target == 0:\n            result.append(combination)\n            return\n        elif target < 0:\n            return\n\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            backtrack(combination + [nums[i]], i + 1, target - nums[i])\n\n    result = []\n    nums.sort()\n    backtrack([], 0, target)\n    return result\n\ndef g() -> (List[int], int):\n    \"\"\"\n    Generate an array of integers and a target value.\n    \"\"\"\n    return ([10, 1, 2, 7, 6, 1, 5], 8)\n\nassert f(*g()) == [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n",
        "idx_generation": 428,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the product of the maximum and minimum elements in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    5\n\n    Explanation:\n    The maximum element is 5 and the minimum element is 1, so the product is 5.\n    \"\"\"\n\n    max_num = float('-inf')\n    min_num = float('inf')\n\n    for num in nums:\n        max_num = max(max_num, num)\n        min_num = min(min_num, num)\n\n    return max_num * min_num\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 5\n",
        "idx_generation": 372,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum sum of a subarray.\n\n    Example:\n    Input: [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n    Explanation: The subarray [4, -1, 2, 1] has the maximum sum of 6.\n\n    \"\"\"\n    if len(arr) == 0:\n        return 0\n\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in arr:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 397,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the number of unique paths from the top-left corner to the bottom-right corner.\n    You can only move down or right. Additionally, you cannot pass through cells containing 1s.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = 1 if grid[0][0] == 0 else 0\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] if grid[i][0] == 0 else 0\n    \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] if grid[0][j] == 0 else 0\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            if grid[i][j] == 0:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    return grid\n\nassert f(g()) == 2\n\n",
        "idx_generation": 325,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find if the given number is a power of two.\"\"\"\n    return n > 0 and (n & (n - 1)) == 0\n\ndef g():\n    \"\"\"Generate a power of two number.\"\"\"\n    return 2**5\n\nassert f(g()) == True\n",
        "idx_generation": 179,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the number of ways to climb to the top of a staircase.\n\n    You can climb 1 or 2 steps at a time. \n\n    Example:\n    n = 4\n    output: 5\n    Explanation: There are 5 ways to climb to the top: \n    1. 1 step + 1 step + 1 step + 1 step\n    2. 1 step + 1 step + 2 steps\n    3. 1 step + 2 steps + 1 step\n    4. 2 steps + 1 step + 1 step\n    5. 2 steps + 2 steps\n    \"\"\"\n\n    if n <= 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\ndef g(n=4):\n    return n\n\nassert f(g()) == 5\n\n",
        "idx_generation": 276,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representing a directed graph, determine if the graph contains a cycle.\n\n    Example:\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 0, 0, 0]\n    ]\n\n    Output:\n    True\n\n    Explanation:\n    The graph contains a cycle: 0 -> 1 -> 2 -> 3 -> 0\n    \"\"\"\n\n    def dfs(node, visited, stack):\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1:\n                if not visited[neighbor]:\n                    if dfs(neighbor, visited, stack):\n                        return True\n                elif stack[neighbor]:\n                    return True\n\n        stack[node] = False\n        return False\n\n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n    stack = [False] * num_nodes\n\n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(node, visited, stack):\n                return True\n\n    return False\n\ndef g():\n    \"\"\"\n    Generate an adjacency matrix representing a directed graph.\n    \"\"\"\n    return [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 0, 0, 0]\n    ]\n\nassert f(g()) == True\n",
        "idx_generation": 155,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Determine if there exists a cycle in the given undirected graph.\n    \"\"\"\n    def dfs(node, parent):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node):\n                    return True\n            elif parent != neighbor:\n                return True\n        return False\n\n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(node, -1):\n                return True\n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    graph = [[1, 2], [0, 2], [0, 1, 3], [2]]\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 251,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the number of ways to choose k elements from a set of n elements.\n\n    Return the number of combinations.\n\n    Example:\n    n = 5\n    k = 3\n\n    Output:\n    10\n\n    Explanation:\n    There are 10 ways to choose 3 elements from a set of 5 elements.\n    \"\"\"\n\n    def combinations(n, k):\n        if k == 0 or n == k:\n            return 1\n        else:\n            return combinations(n-1, k-1) + combinations(n-1, k)\n\n    return combinations(n, k)\n\ndef g(n: int, k: int):\n    \"\"\"\n    Generate two integers n and k.\n    \"\"\"\n    return n, k\n\nassert f(*g(5, 3)) == 10\n",
        "idx_generation": 392,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Given two integers n and k, determine if there exists a combination of k numbers that add up to n.\n\n    Sample input:\n    n = 12\n    k = 3\n\n    Sample output:\n    True\n\n    The combination [3, 4, 5] adds up to 12.\n    \"\"\"\n    def find_combination(target, k):\n        if target == 0 and k == 0:\n            return True\n        if target < 0 or k == 0:\n            return False\n        for i in range(1, target + 1):\n            if find_combination(target - i, k - 1):\n                return True\n        return False\n\n    return find_combination(n, k)\n\ndef g():\n    return 12, 3\n\nassert f(*g()) == True\n",
        "idx_generation": 231,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> int:\n    \"\"\"Count the number of non-overlapping occurrences of string t in string s.\"\"\"\n    count = 0\n    i = 0\n    while i < len(s):\n        if s[i:i+len(t)] == t:\n            count += 1\n            i += len(t)\n        else:\n            i += 1\n    return count\n\ndef g():\n    return \"abababab\", \"ab\"\n\nassert f(*g()) == 4\n",
        "idx_generation": 375,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target integer, return True if there exists a pair of integers in the list whose sum is equal to the target, and False otherwise.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    return [1, 2, 3, 4, 5], 9\n\nassert f(*g()) == True\n\n",
        "idx_generation": 344,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence (LIS) in the list.\n    An increasing subsequence is a subsequence where the elements are in increasing order, but not necessarily\n    contiguous. Return the length of the longest increasing subsequence.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    dp = [1] * len(nums)\n    \n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 180,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], target: str) -> bool:\n    \"\"\"\n    Given a list of words and a target word, determine if the target word can be formed\n    by concatenating two words from the list.\n\n    Example:\n    words = [\"apple\", \"banana\", \"orange\", \"peach\"]\n    target = \"applebanana\"\n\n    Output:\n    True\n\n    Explanation:\n    The target word \"applebanana\" can be formed by concatenating \"apple\" and \"banana\"\n    from the list.\n    \"\"\"\n    words.sort()  # sorting the list of words lexicographically\n\n    for i in range(len(words)):\n        for j in range(i + 1, len(words)):\n            if words[i] + words[j] == target:\n                return True\n\n    return False\n\ndef g():\n    return (\n        [\"apple\", \"banana\", \"orange\", \"peach\"],\n        \"applebanana\"\n    )\n\nassert f(*g()) == True\n\n",
        "idx_generation": 415,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of ways to arrange n rooks on an n x n chessboard such that no two rooks\n    are in the same row or column.\n\n    Args:\n    - n: An integer representing the size of the chessboard.\n\n    Returns:\n    - The number of ways to arrange n rooks on an n x n chessboard.\n\n    Example:\n    n = 4\n\n    Output:\n    24\n\n    Explanation:\n    There are 24 ways to arrange 4 rooks on a 4 x 4 chessboard such that no two rooks are in the same row or column.\n\n    Note:\n    - The value of n will be between 1 and 8 (inclusive).\n    \"\"\"\n\n    def factorial(n):\n        if n == 0 or n == 1:\n            return 1\n        else:\n            return n * factorial(n - 1)\n\n    return factorial(n)\n\n\ndef g() -> int:\n    \"\"\"\n    Generate an integer n representing the size of the chessboard.\n    \"\"\"\n    return 4\n\nassert f(g()) == 24\n\n",
        "idx_generation": 429,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the sum of all the even numbers in the list.\n    \"\"\"\n    return sum(num for num in nums if num % 2 == 0)\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5, 6, 7, 8]\n\nassert f(g()) == 20\n\n",
        "idx_generation": 373,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the length of the longest increasing path.\n\n    Example:\n    grid = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n\n    Output:\n    4\n\n    Explanation:\n    The longest increasing path is [1, 2, 6, 9].\n    \"\"\"\n    if not grid:\n        return 0\n\n    rows = len(grid)\n    cols = len(grid[0])\n    memo = [[0] * cols for _ in range(rows)]\n\n    def dfs(row: int, col: int) -> int:\n        if memo[row][col]:\n            return memo[row][col]\n\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        max_length = 1\n\n        for dx, dy in directions:\n            new_row, new_col = row + dx, col + dy\n\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] > grid[row][col]:\n                max_length = max(max_length, 1 + dfs(new_row, new_col))\n\n        memo[row][col] = max_length\n        return max_length\n\n    max_path = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            max_path = max(max_path, dfs(i, j))\n\n    return max_path\n\ndef g() -> List[List[int]]:\n    return [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n\nassert f(g()) == 4\n",
        "idx_generation": 397,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid consisting of 0s (representing water) and 1s (representing land), count the number of islands.\n\n    An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.\n    Assume all four edges of the grid are all surrounded by water.\n\n    Example:\n    Input:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    Output: 3\n    \"\"\"\n\n    def dfs(row: int, col: int):\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] == 0:\n            return\n\n        grid[row][col] = 0\n\n        dfs(row + 1, col)\n        dfs(row - 1, col)\n        dfs(row, col + 1)\n        dfs(row, col - 1)\n\n    islandCount = 0\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                islandCount += 1\n                dfs(i, j)\n\n    return islandCount\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a 2D grid with islands.\n    \"\"\"\n    # Creating the grid:\n    # 1 1 0 0 0\n    # 1 1 0 0 0\n    # 0 0 1 0 0\n    # 0 0 0 1 1\n    return [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n\nassert f(g()) == 3\n",
        "idx_generation": 332,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum bitwise XOR value between any two numbers in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2]\n    \n    Output:\n    28\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            if xor > max_xor:\n                max_xor = xor\n\n    return max_xor\n\ndef g() -> List[int]:\n    return [3, 10, 5, 25, 2]\n\nassert f(g()) == 28\n",
        "idx_generation": 180,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two positive integers n and m, calculate the value of n to the power of m using the exponentiation by squaring algorithm.\n\n    Args:\n    - n: The base.\n    - m: The exponent.\n\n    Returns:\n    - The result of n raised to the power of m.\n\n    Example:\n    n = 2\n    m = 10\n\n    Output:\n    1024\n\n    Explanation:\n    2 to the power of 10 is equal to 1024.\n    \"\"\"\n\n    def exp_by_squaring(base, exponent):\n        if exponent == 0:\n            return 1\n        if exponent == 1:\n            return base\n\n        if exponent % 2 == 0:\n            half_exponent = exponent // 2\n            half_result = exp_by_squaring(base, half_exponent)\n            return half_result * half_result\n        else:\n            half_exponent = exponent // 2\n            half_result = exp_by_squaring(base, half_exponent)\n            return half_result * half_result * base\n    \n    return exp_by_squaring(n, m)\n\ndef g(n=2, m=10):\n    return n, m\n\nassert f(*g()) == 1024\n\n",
        "idx_generation": 280,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> List[int]:\n    \"\"\"\n    Perform an inorder traversal of the given binary tree and return a list of the node values.\n\n    Example:\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    Output: [2, 1, 3]\n    \"\"\"\n    def inorder(node, res):\n        if node:\n            inorder(node.left, res)\n            res.append(node.val)\n            inorder(node.right, res)\n    \n    result = []\n    inorder(root, result)\n    return result\n\ndef g():\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    return root\n\nassert f(g()) == [2, 1, 3]\n",
        "idx_generation": 157,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list and an integer n,\n    find the number of connected components in the graph.\n\n    Example:\n    n = 5, edges = [[0, 1], [1, 2], [3, 4]]\n\n    The graph has 2 connected components: [0, 1, 2] and [3, 4], so the output should be 2.\n    \"\"\"\n\n    def dfs(node):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n\n    graph = [[] for _ in range(n)]\n    for edge in edges:\n        u, v = edge\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = [False] * n\n    count = 0\n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n            count += 1\n\n    return count\n\ndef g():\n    \"\"\"\n    Generate an integer n and a list of edges to represent an undirected graph.\n    \"\"\"\n    n = 5\n    edges = [[0, 1], [1, 2], [3, 4]]\n    return n, edges\n\nassert f(*g()) == 2\n",
        "idx_generation": 252,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(s: str, k: int) -> List[str]:\n    \"\"\"\n    Given a string s and an integer k, generate all possible combinations of length k from the characters of s.\n\n    Example:\n    Input: s = \"abc\", k = 2\n    Output: [\"ab\", \"ac\", \"bc\"]\n\n    Explanation: The solution set contains all possible combinations of length 2 from the characters 'a', 'b', 'c'.\n    \"\"\"\n\n    def backtrack(combination: str, start: int):\n        if len(combination) == k:\n            result.append(combination)\n            return\n        for i in range(start, len(s)):\n            backtrack(combination + s[i], i + 1)\n\n    result = []\n    backtrack(\"\", 0)\n    return result\n\ndef g():\n    s = \"abc\"\n    k = 2\n    return s, k\n\nassert f(*g()) == [\"ab\", \"ac\", \"bc\"]\n",
        "idx_generation": 394,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Given a positive integer n, generate all unique permutations of the numbers from 1 to n.\n\n    Example:\n    n = 3\n    The unique permutations of the numbers from 1 to 3 are [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]], \n    so the output should be [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]].\n    \"\"\"\n    def backtrack(nums, path, res):\n        if not nums:\n            res.append(path)\n        else:\n            for i in range(len(nums)):\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n\n    nums = [i for i in range(1, n + 1)]\n    res = []\n    backtrack(nums, [], res)\n    return res\n\ndef g(n=3):\n    return n\n\nassert f(g()) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n",
        "idx_generation": 238,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, return the count of the occurrence of 1 as a digit in all the numbers from 0 to n (inclusive).\n    \"\"\"\n    count = 0\n    for num in range(n+1):\n        count += str(num).count('1')\n    return count\n\ndef g(n: int) -> int:\n    \"\"\"\n    Generate a non-negative integer. Return the generated integer.\n    \"\"\"\n    return n\n\nassert f(g(15)) == 8\n",
        "idx_generation": 385,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, return the list sorted in lexicographical order.\n\n    Example:\n    words = [\"banana\", \"apple\", \"cherry\", \"date\"]\n    \n    Output:\n    [\"apple\", \"banana\", \"cherry\", \"date\"]\n\n    Hint: Use the sorted() function with the appropriate key parameter.\n    \"\"\"\n    return sorted(words)\n\ndef g() -> List[str]:\n    return [\"banana\", \"apple\", \"cherry\", \"date\"]\n\nassert f(g()) == [\"apple\", \"banana\", \"cherry\", \"date\"]\n\n",
        "idx_generation": 344,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target number using binary search.\n    If target is not found, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5, 6], target: int = 4):\n    \"\"\"\n    Generate a sorted list of integers and a target number for the function f.\n    \"\"\"\n    nums.sort()\n    return nums, target\n\nassert f(*g()) == 3\n\n",
        "idx_generation": 182,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list containing the unique numbers in the original list in descending order.\n\n    Example:\n    nums = [1, 2, 2, 3, 4, 4, 5, 5, 5]\n    output = [5, 4, 3, 2, 1]\n    \"\"\"\n    unique_nums = list(set(nums))\n    unique_nums.sort(reverse=True)\n    return unique_nums\n\ndef g():\n    return [1, 2, 2, 3, 4, 4, 5, 5, 5]\n\nassert f(g()) == [5, 4, 3, 2, 1]\n",
        "idx_generation": 419,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a valid parentheses expression.\n\n    Args:\n    - s: A string containing only the characters '(' and ')'.\n\n    Returns:\n    - A boolean value indicating whether the string is a valid parentheses expression.\n\n    Example:\n    s = \"()()()\"\n\n    Output:\n    True\n    \"\"\"\n    def is_valid(s: str, left: int, right: int) -> bool:\n        if left > right:\n            return True\n        if s[left] != '(' or s[right] != ')':\n            return False\n        i = left + 1\n        while i < right:\n            if s[i] == '(':\n                count = 1\n                j = i + 1\n                while j < right and count > 0:\n                    if s[j] == '(':\n                        count += 1\n                    elif s[j] == ')':\n                        count -= 1\n                    j += 1\n                if count != 0:\n                    return False\n                if not is_valid(s, i, j-1):\n                    return False\n                i = j\n            else:\n                i += 1\n        return True\n\n    return is_valid(s, 0, len(s)-1)\n\ndef g() -> str:\n    return \"(()()())\"\n\nassert f(g()) == True\n",
        "idx_generation": 436,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Check if the target value is present in the matrix.\"\"\"\n    for row in matrix:\n        if target in row:\n            return True\n    return False\n\ndef g():\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    target = 5\n    return matrix, target\n\nassert f(*g())\n",
        "idx_generation": 373,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(prices: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of stock prices and the maximum number of transactions allowed, find the maximum profit that can be\n    obtained by buying and selling stocks. Each transaction consists of buying at the start of the day and selling at\n    the end of the day.\n\n    Args:\n    - prices: A list of integers, representing the stock prices.\n    - k: An integer, the maximum number of transactions allowed.\n\n    Returns:\n    - An integer, the maximum profit that can be obtained.\n    \"\"\"\n    n = len(prices)\n    \n    if k >= n // 2:\n        return sum(max(prices[i+1] - prices[i], 0) for i in range(n-1))\n    \n    dp = [[0] * n for _ in range(k+1)]\n    \n    for i in range(1, k+1):\n        max_diff = -prices[0]\n        \n        for j in range(1, n):\n            dp[i][j] = max(dp[i][j-1], prices[j] + max_diff)\n            max_diff = max(max_diff, dp[i-1][j] - prices[j])\n    \n    return dp[k][-1]\n\ndef g() -> Tuple[List[int], int]:\n    prices = [3, 2, 6, 5, 0, 3]\n    k = 2\n    return prices, k\n\nassert f(*g()) == 7\n",
        "idx_generation": 398,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, find the largest square containing only 1s and return its area.\n\n    Example:\n    Input:\n    grid = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n    Output: 4\n    \"\"\"\n\n    if len(grid) == 0 or len(grid[0]) == 0:\n        return 0\n\n    rows = len(grid)\n    cols = len(grid[0])\n    maxSquareSide = 0\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                if i == 0 or j == 0:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n\n                maxSquareSide = max(maxSquareSide, dp[i][j])\n\n    return maxSquareSide * maxSquareSide\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a 2D grid with the largest square of 1s.\n    \"\"\"\n    # Creating the grid:\n    # 1 0 1 0 0\n    # 1 0 1 1 1\n    # 1 1 1 1 1\n    # 1 0 0 1 0\n    return [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n\nassert f(g()) == 4\n\n",
        "idx_generation": 332,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, check if it is a power of two.\n\n    Sample Input:\n    16\n\n    Sample Output:\n    True\n    \"\"\"\n    if n == 0:\n        return False\n    while n % 2 == 0:\n        n //= 2\n    return n == 1\n\ndef g():\n    return 64\n\nassert f(g()) == True\n",
        "idx_generation": 182,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of distinct valid combinations of steps to reach the nth stair.\n    You can climb either 1 or 2 steps at a time.\n\n    Example:\n    n = 3\n\n    Output:\n    3 (Possible combinations: 1-1-1, 1-2, 2-1)\n    \"\"\"\n    if n <= 2:\n        return n\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    \n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    \n    return dp[n]\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 281,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> int:\n    \"\"\"\n    Given a binary tree, find the maximum sum of any path from the root to a leaf node.\n    \"\"\"\n    def max_path_sum(root: TreeNode) -> int:\n        if not root:\n            return 0\n\n        left_sum = max_path_sum(root.left)\n        right_sum = max_path_sum(root.right)\n\n        return max(left_sum, right_sum) + root.val\n\n    if not root:\n        return 0\n\n    return max_path_sum(root)\n\ndef g():\n    # Create a binary tree\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n\n    return root\n\nassert f(g()) == 8\n",
        "idx_generation": 157,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency list and two vertices start and end, \n    determine if there is a path from start to end in the graph.\n    \"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        visited.add(node)\n        if node == end:\n            return True\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    return False\n\ndef g():\n    graph = [[1, 2], [3], [4], [2], []]\n    start = 0\n    end = 4\n    return graph, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 258,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the count of numbers from 0 to n (inclusive) that have an even number of set bits in their binary representation.\n\n    Example:\n    n = 5\n\n    Output:\n    3\n\n    Explanation:\n    The numbers from 0 to 5 with an even number of set bits are 0 (0 in binary), 3 (11 in binary), and 5 (101 in binary).\n    \"\"\"\n\n    count = 0\n\n    for num in range(n + 1):\n        if bin(num).count('1') % 2 == 0:\n            count += 1\n\n    return count\n\ndef g() -> int:\n    return 5\n\nassert f(g()) == 3\n\n",
        "idx_generation": 396,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\n\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Given an integer n, return a list of lists representing a Pascal's Triangle up to the nth row.\n\n    Example:\n    n = 5\n\n    Output:\n    [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n\n    Hint: Each row of Pascal's Triangle can be generated by summing the adjacent elements of the previous row.\n    \"\"\"\n\n    triangle = []\n    \n    for i in range(n):\n        row = [1] * (i + 1)\n        \n        for j in range(1, i):\n            row[j] = triangle[i-1][j-1] + triangle[i-1][j]\n        \n        triangle.append(row)\n        \n    return triangle\n\ndef g():\n    return 5\n\nassert f(g()) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n\n",
        "idx_generation": 241,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(string: str, k: int) -> List[str]:\n    \"\"\"\n    Given a string and an integer k, return all possible substrings of length k that can be formed from the string.\n\n    Return the list of substrings.\n\n    Example:\n    string = \"abcde\"\n    k = 3\n\n    Output:\n    [\"abc\", \"bcd\", \"cde\"]\n    \"\"\"\n\n    substrings = []\n\n    for i in range(len(string) - k + 1):\n        substrings.append(string[i:i+k])\n\n    return substrings\n\ndef g(string: str = \"abcde\", k: int = 3) -> List[str]:\n    return string, k\n\nassert f(*g()) == [\"abc\", \"bcd\", \"cde\"]\n",
        "idx_generation": 415,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(arr: List[int], target: int) -> Tuple[int, int]:\n    \"\"\"\n    Given an array of integers and a target number, find two numbers in the array that add up to the target.\n    Return the indices of the two numbers as a tuple.\n    \"\"\"\n    num_dict = {}\n    \n    for i, num in enumerate(arr):\n        complement = target - num\n        if complement in num_dict:\n            return (num_dict[complement], i)\n        num_dict[num] = i\n    \n    return ()\n\ndef g(arr=[2, 7, 11, 15], target=9):\n    return (arr, target)\n\nassert f(*g()) == (0, 1)\n\n",
        "idx_generation": 345,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of numbers and a target value, find all unique combinations of numbers in the list that sum up to the target.\n    Each number in the list can only be used once.\n\n    Sample Input:\n    numbers = [10, 1, 2, 7, 6, 1, 5]\n    target = 8\n\n    Sample Output:\n    [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n    \"\"\"\n    def backtrack(numbers: List[int], target: int, start: int, curr_comb: List[int], result: List[List[int]]) -> None:\n        if target == 0:\n            result.append(curr_comb[:])\n            return\n        elif target < 0:\n            return\n        \n        for i in range(start, len(numbers)):\n            if i > start and numbers[i] == numbers[i - 1]:\n                continue\n            curr_comb.append(numbers[i])\n            backtrack(numbers, target - numbers[i], i + 1, curr_comb, result)\n            curr_comb.pop()\n\n    numbers.sort()\n    result = []\n    backtrack(numbers, target, 0, [], result)\n    return result\n\n\ndef g(numbers = [10, 1, 2, 7, 6, 1, 5], target = 8):\n    return numbers, target\n\n\nassert f(*g()) == [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n",
        "idx_generation": 182,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, find if there exists a pair of numbers whose sum is equal to the target.\n\n    Sample Input:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n\n    Sample Output:\n    True\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        sum = arr[left] + arr[right]\n        if sum == target:\n            return True\n        elif sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 432,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, count the number of inversions in the list.\n\n    An inversion occurs when there are two elements nums[i] and nums[j] such that i < j but nums[i] > nums[j].\n\n    Return the number of inversions in the list.\n\n    Example:\n    nums = [2, 4, 1, 3, 5]\n\n    Output:\n    3\n\n    Explanation:\n    There are 3 inversions in the list:\n    - (2, 1)\n    - (4, 1)\n    - (4, 3)\n    \"\"\"\n\n    def merge_sort(nums):\n        if len(nums) <= 1:\n            return nums, 0\n        \n        mid = len(nums) // 2\n        left, count_left = merge_sort(nums[:mid])\n        right, count_right = merge_sort(nums[mid:])\n        merged, count_merge = merge(left, right)\n        \n        return merged, count_left + count_right + count_merge\n    \n    def merge(left, right):\n        merged = []\n        count = 0\n        i, j = 0, 0\n        \n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                count += len(left) - i\n                j += 1\n        \n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        \n        return merged, count\n    \n    _, count = merge_sort(nums)\n    return count\n\ndef g():\n    \"\"\"\n    Generate a list of integers with some inversions.\n    \"\"\"\n    return [2, 4, 1, 3, 5]\n\nassert f(g()) == 3\n",
        "idx_generation": 441,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the first missing positive integer.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The first missing positive integer.\n    \"\"\"\n    n = len(nums)\n\n    for i in range(n):\n        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n\n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n\n    return n + 1\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [3, 4, -1, 1]\n\nassert f(g()) == 2\n\n",
        "idx_generation": 373,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a power of 2.\n\n    Sample Input:\n    n = 16\n\n    Sample Output:\n    True\n    \"\"\"\n    if n <= 0:\n        return False\n    if n == 1:\n        return True\n    if n % 2 == 1:\n        return False\n    return f(n // 2)\n\ndef g():\n    return [16]\n\nassert f(*g())\n",
        "idx_generation": 398,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the number of unique paths from the top-left corner to the bottom-right corner, \n    while only moving down or right.\n\n    Example:\n    Input:\n    grid = [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]\n\n    Output:\n    2\n\n    Explanation:\n    The grid represents a 3x3 matrix. The number 0 represents an empty cell, while the number 1 represents an obstacle.\n    There are 2 unique paths from the top-left corner to the bottom-right corner: [0, 0, 0, 0, 0] and [0, 0, 0, 0, 0].\n    \"\"\"\n\n    def countPaths(grid: List[List[int]], row: int, col: int, memo: List[List[int]]) -> int:\n        if row == len(grid) - 1 and col == len(grid[0]) - 1:\n            return 1\n\n        if row >= len(grid) or col >= len(grid[0]) or grid[row][col] == 1:\n            return 0\n\n        if memo[row][col] != -1:\n            return memo[row][col]\n\n        right = countPaths(grid, row, col + 1, memo)\n        down = countPaths(grid, row + 1, col, memo)\n\n        memo[row][col] = right + down\n\n        return memo[row][col]\n\n    memo = [[-1] * len(grid[0]) for _ in range(len(grid))]\n    return countPaths(grid, 0, 0, memo)\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of 0s and 1s.\n    \"\"\"\n    return [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]\n\nassert f(g()) == 2\n",
        "idx_generation": 338,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum XOR value between any two numbers.\n    The XOR value is calculated by taking the bitwise XOR of two numbers.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[i])):\n            for k in range(len(grid)):\n                for l in range(len(grid[k])):\n                    xor = grid[i][j] ^ grid[k][l]\n                    max_xor = max(max_xor, xor)\n    return max_xor\n\ndef g(grid: List[List[int]]):\n    return grid\n\nassert f(g([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) == 15\n",
        "idx_generation": 189,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    fib = [0, 1]\n    for i in range(2, n+1):\n        fib.append(fib[i-1] + fib[i-2])\n    \n    return fib[n]\n\ndef g():\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 297,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representing a graph, determine if the graph contains a cycle.\n    \"\"\"\n    def has_cycle(node: int, visited: List[bool], rec_stack: List[bool], graph: List[List[int]]) -> bool:\n        visited[node] = True\n        rec_stack[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if has_cycle(neighbor, visited, rec_stack, graph):\n                    return True\n            elif rec_stack[neighbor]:\n                return True\n        \n        rec_stack[node] = False\n        return False\n    \n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n    rec_stack = [False] * num_nodes\n    \n    for node in range(num_nodes):\n        if not visited[node]:\n            if has_cycle(node, visited, rec_stack, graph):\n                return True\n    \n    return False\n\ndef g():\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 0, 0, 0]\n    ]\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 160,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Check if a given directed graph contains a cycle.\n    \"\"\"\n    def dfs(node, visited, stack):\n        visited[node] = True\n        stack[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, stack):\n                    return True\n            elif stack[neighbor]:\n                return True\n        \n        stack[node] = False\n        return False\n    \n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n    stack = [False] * num_nodes\n    \n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(node, visited, stack):\n                return True\n    \n    return False\n\ndef g():\n    \"\"\"\n    Generate a directed graph with a cycle.\n    \"\"\"\n    graph = [[1], [2], [3], [4], [0]]\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 265,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Calculate the number of combinations of a given list of numbers.\n    \"\"\"\n    def backtrack(nums, start, current_combination, combinations):\n        combinations.append(current_combination[:])\n        for i in range(start, len(nums)):\n            current_combination.append(nums[i])\n            backtrack(nums, i + 1, current_combination, combinations)\n            current_combination.pop()\n\n    combinations = []\n    backtrack(nums, 0, [], combinations)\n    return len(combinations)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of numbers.\n    \"\"\"\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == 16\n",
        "idx_generation": 420,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the number of different ways to choose k elements from the range 1 to n.\n\n    Example:\n    n = 5, k = 3\n    Output: 10\n    Explanation: There are 10 different ways to choose 3 elements from the range 1 to 5: \n                 (1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5), (1, 4, 5), (2, 3, 4), (2, 3, 5), (2, 4, 5), (3, 4, 5).\n    \"\"\"\n    if k == 0 or k == n:\n        return 1\n    return f(n - 1, k - 1) + f(n - 1, k)\n\ndef g(n = 5, k = 3):\n    return n, k\n\nassert f(*g()) == 10\n",
        "idx_generation": 248,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> str:\n    \"\"\"\n    Convert a non-negative integer into its English words representation.\n\n    Args:\n    - n: A non-negative integer.\n\n    Returns:\n    - The English words representation of the given integer.\n\n    Example:\n    n = 12345\n\n    Output:\n    \"twelve thousand three hundred forty five\"\n    \"\"\"\n    def convert_less_than_20(num: int) -> str:\n        less_than_20 = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n        return less_than_20[num]\n\n    def convert_tens(num: int) -> str:\n        tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n        return tens[num]\n\n    def convert_hundreds(num: int) -> str:\n        return convert_less_than_20(num) + \" hundred\"\n\n    def convert_thousands(num: int) -> str:\n        return convert_less_than_20(num) + \" thousand\"\n\n    if n == 0:\n        return \"zero\"\n\n    result = \"\"\n    if n >= 1000:\n        result += convert_thousands(n // 1000) + \" \"\n        n %= 1000\n    if n >= 100:\n        result += convert_hundreds(n // 100) + \" \"\n        n %= 100\n    if n >= 20:\n        result += convert_tens(n // 10) + \" \"\n        n %= 10\n    if n > 0:\n        result += convert_less_than_20(n) + \" \"\n\n    return result.strip()\n\ndef g() -> int:\n    return 12345\n\nassert f(g()) == \"twelve thousand three hundred forty five\"\n\n",
        "idx_generation": 464,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers, find the index of the target element using binary search.\n    If the target is not found, return -1.\n    \"\"\"\n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    arr = [1, 3, 5, 7, 9, 11, 13]\n    target = 7\n    return arr, target\n\nassert f(*g()) == 3\n",
        "idx_generation": 346,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there exists two elements in the list\n    whose sum is equal to the target. Return True if such elements exist, otherwise return False.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    Output:\n    True\n\n    Explanation:\n    There exist two elements in the list [1, 2, 3, 4, 5] (3 and 4) whose sum is equal to the target value 7.\n\n    Hint: Use a two-pointer approach to search for the two elements.\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\n\ndef g() -> (List[int], int):\n    \"\"\"\n    Generate a list of integers and a target value for the function f.\n    \"\"\"\n    return [1, 2, 3, 4, 5], 7\n\n\nassert f(*g()) == True\n",
        "idx_generation": 188,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Given two strings s1 and s2, check if s1 is an anagram of s2.\n\n    An anagram is a word or phrase formed by rearranging the letters of a different word or phrase.\n\n    Return True if s1 is an anagram of s2, False otherwise.\n\n    Example:\n    s1 = \"listen\"\n    s2 = \"silent\"\n\n    Output:\n    True\n\n    Explanation:\n    The string \"listen\" can be rearranged to form the string \"silent\", which makes s1 an anagram of s2.\n    \"\"\"\n\n    if len(s1) != len(s2):\n        return False\n    \n    count = [0] * 26\n    for char in s1:\n        count[ord(char) - ord('a')] += 1\n    \n    for char in s2:\n        count[ord(char) - ord('a')] -= 1\n        if count[ord(char) - ord('a')] < 0:\n            return False\n    \n    return True\n\ndef g():\n    \"\"\"\n    Generate two strings that are anagrams of each other.\n    \"\"\"\n    return \"listen\", \"silent\"\n\nassert f(*g()) == True\n",
        "idx_generation": 441,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the sum of all even Fibonacci numbers less than or equal to n.\n    \"\"\"\n    fib = [1, 2]\n    sum = 0\n    i = 2\n    while fib[i-1] <= n:\n        fib.append(fib[i-1] + fib[i-2])\n        if fib[i-1] % 2 == 0:\n            sum += fib[i-1]\n        i += 1\n    return sum\n\ndef g() -> int:\n    return 100\n\nassert f(g()) == 44\n",
        "idx_generation": 450,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a contiguous subarray.\n\n    Sample Input:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Sample Output:\n    6\n    Explanation: The contiguous subarray [4, -1, 2, 1] has the maximum sum of 6.\n\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(current_sum + num, num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n\n",
        "idx_generation": 378,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum sum that can be obtained by choosing a non-empty subarray of the list.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n\n    current_sum = max_sum = nums[0]\n\n    for i in range(1, len(nums)):\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 399,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid represented as a list of lists of integers, find the minimum number of steps required to reach the bottom-right cell from the top-left cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum number of steps required to reach the bottom-right cell from the top-left cell is 7: 1 -> 3 -> 1 -> 1 -> 1 -> 2 -> 1.\n\n    Hint: Use sorting and searching, and solve the problem as a grid problem by finding the shortest path from the top-left cell to the bottom-right cell.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid represented as a list of lists of integers.\n    \"\"\"\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 344,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers.\n    The XOR value is calculated by taking the bitwise XOR of two numbers.\n    \"\"\"\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor\n\ndef g(nums: List[int]):\n    return nums\n\nassert f(g([1, 2, 3, 4, 5])) == 7\n",
        "idx_generation": 189,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, calculate the determinant of the matrix.\n\n    Args:\n    - matrix: A square matrix represented as a list of lists.\n\n    Returns:\n    - The determinant of the matrix.\n    \"\"\"\n    def determinant(matrix):\n        n = len(matrix)\n        if n == 1:\n            return matrix[0][0]\n\n        det = 0\n        for col in range(n):\n            sub_matrix = [row[:col] + row[col+1:] for row in matrix[1:]]\n            det += (-1) ** col * matrix[0][col] * determinant(sub_matrix)\n        return det\n\n    return determinant(matrix)\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a square matrix.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 0\n\n",
        "idx_generation": 301,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(n: int, edges: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"\n    Given an undirected graph with n nodes and a list of edges, find the minimum number of edges\n    that need to be added to the graph to make it strongly connected.\n\n    Example:\n    n = 5, edges = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]\n\n    Output:\n    []\n\n    Explanation:\n    The graph is already strongly connected, so no extra edges need to be added.\n\n    Hint: Use depth-first search (DFS) to check if the graph is strongly connected.\n    \"\"\"\n\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n        graph[u-1].append(v-1)\n        graph[v-1].append(u-1)\n\n    visited = [False] * n\n\n    def dfs(node):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n\n    dfs(0)\n\n    if all(visited):\n        return []\n\n    missing_edges = []\n    for i in range(n):\n        if not visited[i]:\n            for j in range(n):\n                if i != j and not (i, j) in edges and not (j, i) in edges:\n                    missing_edges.append((i, j))\n                    break\n\n    return missing_edges\n\ndef g(n=5, edges=[(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]):\n    return n, edges\n\nassert f(*g()) == []\n",
        "idx_generation": 167,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(adj_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix of a directed graph, determine if the graph contains a cycle.\n\n    Example:\n    adj_matrix = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 0, 0, 0]\n    ]\n\n    Output:\n    True\n\n    Explanation:\n    The graph contains a cycle: 0 -> 1 -> 2 -> 3 -> 0.\n    \"\"\"\n    def dfs(v, visited, stack):\n        visited[v] = True\n        stack[v] = True\n\n        for neighbor in range(len(adj_matrix)):\n            if adj_matrix[v][neighbor] == 1:\n                if not visited[neighbor]:\n                    if dfs(neighbor, visited, stack):\n                        return True\n                elif stack[neighbor]:\n                    return True\n\n        stack[v] = False\n        return False\n\n    visited = [False] * len(adj_matrix)\n    stack = [False] * len(adj_matrix)\n\n    for v in range(len(adj_matrix)):\n        if not visited[v]:\n            if dfs(v, visited, stack):\n                return True\n    \n    return False\n\ndef g():\n    return [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 0, 0, 0]\n    ]\n\nassert f(g()) == True\n",
        "idx_generation": 279,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two positive integers n and m, calculate the number of ways to arrange n objects in m slots,\n    such that each slot can contain at most one object.\n\n    Example:\n    n = 4\n    m = 2\n\n    Output:\n    12\n\n    Explanation:\n    There are 12 ways to arrange 4 objects in 2 slots:\n    - (1, 2)\n    - (1, 3)\n    - (1, 4)\n    - (2, 1)\n    - (2, 3)\n    - (2, 4)\n    - (3, 1)\n    - (3, 2)\n    - (3, 4)\n    - (4, 1)\n    - (4, 2)\n    - (4, 3)\n    \"\"\"\n\n    def factorial(n):\n        if n == 0 or n == 1:\n            return 1\n        return n * factorial(n-1)\n\n    return factorial(n) // factorial(n-m)\n\ndef g() -> Tuple[int, int]:\n    \"\"\"\n    Generate the input for the function f.\n    \"\"\"\n    return (4, 2)\n\nassert f(*g()) == 12\n",
        "idx_generation": 421,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, count the number of combinations\n    of numbers in the list that add up to the target.\n    \"\"\"\n    memo = {}\n\n    def dp(i: int, target: int) -> int:\n        if target == 0:\n            return 1\n        if i == len(nums) or target < 0:\n            return 0\n        if (i, target) in memo:\n            return memo[(i, target)]\n\n        count = dp(i + 1, target) + dp(i + 1, target - nums[i])\n        memo[(i, target)] = count\n        return count\n\n    return dp(0, target)\n\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target number.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    return nums, target\n\n\nassert f(*g()) == 3\n\n",
        "idx_generation": 256,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> int:\n    \"\"\"\n    Given a string and a list of words, count the number of occurrences of each word in the string.\n    \"\"\"\n    counts = {word: 0 for word in words}\n    \n    for word in words:\n        start = 0\n        while start < len(s):\n            index = s.find(word, start)\n            if index == -1:\n                break\n            counts[word] += 1\n            start = index + len(word)\n    \n    return counts\n\ndef g() -> (str, List[str]):\n    \"\"\"\n    Generate a string and a list of words. The words are guaranteed to appear in the string.\n    \"\"\"\n    s = \"apple banana apple cherry banana\"\n    words = [\"apple\", \"banana\", \"cherry\"]\n    return s, words\n\nassert f(*g()) == {\"apple\": 2, \"banana\": 2, \"cherry\": 1}\n",
        "idx_generation": 470,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, use binary search to determine if the target number is present in the list.\n\n    Example:\n    f([1, 2, 3, 4, 5], 3) returns True.\n\n    Note:\n    - The input list will always be sorted in ascending order.\n    - The input list can contain duplicate numbers.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5], target: int = 3) -> bool:\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n\n    Example:\n    g() returns ([1, 2, 3, 4, 5], 3).\n\n    Note:\n    - The input list will always be sorted in ascending order.\n    - The input list can contain duplicate numbers.\n    \"\"\"\n\n    return nums, target\n\n\nassert f(*g()) == True\n",
        "idx_generation": 347,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers, find the index of the first occurrence of the target number using binary search.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == target:\n            if mid == 0 or arr[mid - 1] != target:\n                return mid\n            else:\n                right = mid - 1\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g(arr=[1, 2, 2, 3, 4, 4, 4, 5], target=4):\n    return arr, target\n\nassert f(*g()) == 4\n\n",
        "idx_generation": 193,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> str:\n    \"\"\"\n    Given a string s and an integer k, reverse the order of the words in the string while keeping the words themselves intact.\n    Words are defined as contiguous sequences of non-space characters.\n    \n    Example:\n    s = \"hello world how are you\"\n    k = 3\n    \n    Output:\n    \"how world hello are you\"\n    \"\"\"\n    words = s.split()\n    reversed_words = words[:k][::-1] + words[k:]\n    return ' '.join(reversed_words)\n\ndef g() -> Tuple[str, int]:\n    s = \"hello world how are you\"\n    k = 3\n    return s, k\n\nassert f(*g()) == \"how world hello are you\"\n",
        "idx_generation": 442,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of positive integers nums, return the count of distinct increasing subsequences.\n\n    Example:\n    f([1, 2, 3, 4]) returns 15, as there are 15 distinct increasing subsequences: [1], [2], [3], [4], [1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4], [1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4], [1, 2, 3, 4].\n\n    Note:\n    - The input list nums may contain duplicates.\n    - The subsequences should be strictly increasing, i.e., each element in the subsequence should be greater than the previous element.\n    \"\"\"\n\n    def count_subsequences(nums: List[int], index: int, prev: int, memo: dict) -> int:\n        if index >= len(nums):\n            return 0\n        if (index, prev) in memo:\n            return memo[(index, prev)]\n        \n        count = 0\n        if nums[index] > prev:\n            count += 1 + count_subsequences(nums, index + 1, nums[index], memo)\n        count += count_subsequences(nums, index + 1, prev, memo)\n        \n        memo[(index, prev)] = count\n        return memo[(index, prev)]\n\n    memo = {}\n    return count_subsequences(nums, 0, float('-inf'), memo)\n\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers.\n\n    Example:\n    g() returns [1, 2, 3, 4].\n    \"\"\"\n\n    return [1, 2, 3, 4]\n\n\nassert f(g()) == 15\n\n",
        "idx_generation": 456,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Maximum Subarray Sum\n\n    Given an array of integers, find the maximum sum of any contiguous subarray.\n\n    Example:\n    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    output: 6\n    Explanation: The contiguous subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n    def max_subarray_sum(arr: List[int]) -> int:\n        max_sum = float('-inf')\n        curr_sum = 0\n        for num in arr:\n            curr_sum = max(curr_sum + num, num)\n            max_sum = max(max_sum, curr_sum)\n        return max_sum\n\n    return max_subarray_sum(arr)\n\ndef g() -> List[int]:\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 380,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the nth Fibonacci number using recursion and memoization.\n    \"\"\"\n    memo = {}\n    \n    def fibonacci(n: int) -> int:\n        if n in memo:\n            return memo[n]\n        \n        if n <= 1:\n            return n\n        \n        memo[n] = fibonacci(n-1) + fibonacci(n-2)\n        return memo[n]\n    \n    return fibonacci(n)\n\ndef g() -> int:\n    return 7\n\nassert f(g()) == 13\n\n",
        "idx_generation": 126,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of integers, determine if there exists a path from the top-left corner to the bottom-right corner,\n    where the sum of the numbers along the path is divisible by 3.\n    \"\"\"\n    def dfs(i, j, curr_sum):\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\n            return curr_sum % 3 == 0\n        if i < len(grid) - 1 and dfs(i + 1, j, curr_sum + grid[i + 1][j]):\n            return True\n        if j < len(grid[0]) - 1 and dfs(i, j + 1, curr_sum + grid[i][j + 1]):\n            return True\n        return False\n\n    return dfs(0, 0, grid[0][0]) if grid else False\n\ndef g(grid: List[List[int]] = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return grid\n\nassert f(g())\n",
        "idx_generation": 358,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, return True if n is a power of 2, and False otherwise.\n\n    Example:\n    n = 16\n\n    Output:\n    True (since 16 is a power of 2)\n    \"\"\"\n    return n > 0 and (n & (n - 1)) == 0\n\ndef g():\n    n = 16\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 193,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of ways to climb to the top of a staircase. You can climb either 1 or 2 steps\n    at a time. The order of steps is important.\n\n    Example:\n    Input: n = 4\n    Output: 5\n\n    Explanation:\n    There are 5 ways to climb to the top:\n    1. 1 step + 1 step + 1 step + 1 step\n    2. 1 step + 1 step + 2 steps\n    3. 1 step + 2 steps + 1 step\n    4. 2 steps + 1 step + 1 step\n    5. 2 steps + 2 steps\n    \"\"\"\n\n    if n == 0 or n == 1:\n        return 1\n\n    dp = [0] * (n+1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n+1):\n        dp[i] = dp[i-1] + dp[i-2]\n\n    return dp[n]\n\ndef g():\n    return 4\n\nassert f(g()) == 5\n",
        "idx_generation": 303,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the maximum sum of numbers obtained by traversing a grid from top-left to bottom-right, allowed to move only down or right.\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    return dp[m - 1][n - 1]\n\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 12\n\n",
        "idx_generation": 167,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given a directed graph represented by its edges, determine if the graph contains a cycle.\n\n    Example:\n    Input:\n    n = 4\n    edges = [[0, 1], [1, 2], [2, 3], [3, 0]]\n\n    Output: True\n\n    Explanation: The graph contains a cycle: 0 -> 1 -> 2 -> 3 -> 0.\n    \"\"\"\n\n    def has_cycle(n: int, edges: List[List[int]]) -> bool:\n        graph = [[] for _ in range(n)]\n        visited = [False] * n\n        rec_stack = [False] * n\n\n        for u, v in edges:\n            graph[u].append(v)\n\n        def dfs(node: int) -> bool:\n            visited[node] = True\n            rec_stack[node] = True\n\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    if dfs(neighbor):\n                        return True\n                elif rec_stack[neighbor]:\n                    return True\n\n            rec_stack[node] = False\n            return False\n\n        for i in range(n):\n            if not visited[i]:\n                if dfs(i):\n                    return True\n\n        return False\n\n    return has_cycle(n, edges)\n\ndef g() -> Tuple[int, List[List[int]]]:\n    n = 4\n    edges = [[0, 1], [1, 2], [2, 3], [3, 0]]\n    return n, edges\n\nassert f(*g()) == True\n",
        "idx_generation": 284,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, determine the number of k-combinations for a set of size n.\n\n    Return the total number of k-combinations.\n\n    Example:\n    n = 5\n    k = 3\n\n    Output:\n    10\n\n    Explanation:\n    There are 10 different combinations of size 3 that can be formed from a set of size 5.\n    \"\"\"\n    def factorial(n):\n        result = 1\n        for i in range(1, n+1):\n            result *= i\n        return result\n    \n    return factorial(n) // (factorial(k) * factorial(n-k))\n\ndef g() -> Tuple[int, int]:\n    \"\"\"\n    Generate two integers n and k.\n\n    Returns:\n    - The generated integers.\n\n    Example:\n    g() returns (5, 3)\n    \"\"\"\n\n    return (5, 3)\n\nassert f(*g()) == 10\n",
        "idx_generation": 431,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of ways to represent it as a sum of 1s and 2s.\n\n    Example:\n    Input: n = 4\n    Output: 5\n    Explanation:\n    There are 5 ways to represent 4 as a sum of 1s and 2s: (1, 1, 1, 1), (1, 1, 2), (1, 2, 1), (2, 1, 1), (2, 2).\n    \"\"\"\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\ndef g(n: int) -> int:\n    return n\n\nassert f(g(4)) == 5\n",
        "idx_generation": 262,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import Dict, List\n\ndef f(words: List[str]) -> Dict[str, int]:\n    \"\"\"\n    Given a list of words, count the number of occurrences of each word in the list and return a dictionary with the word as the key and its count as the value.\n\n    Example:\n    Input:\n    words = [\"apple\", \"banana\", \"apple\", \"cherry\", \"banana\"]\n\n    Output:\n    {\"apple\": 2, \"banana\": 2, \"cherry\": 1}\n\n    Explanation:\n    The list of words contains the words \"apple\", \"banana\", and \"cherry\".\n    The word \"apple\" appears twice, the word \"banana\" appears twice, and the word \"cherry\" appears once.\n    The output is a dictionary with the word as the key and its count as the value.\n    \"\"\"\n\n    word_count = {}\n\n    for word in words:\n        word_count[word] = word_count.get(word, 0) + 1\n\n    return word_count\n\ndef g(words: List[str] = [\"apple\", \"banana\", \"apple\", \"cherry\", \"banana\"]):\n    return (words,)\n\nassert f(*g()) == {\"apple\": 2, \"banana\": 2, \"cherry\": 1}\n\n",
        "idx_generation": 489,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the index of the target number in the list using linear search.\n\n    Example:\n    f([5, 2, 7, 3, 1], 7) returns 2.\n\n    Note:\n    - The input list can contain duplicate numbers.\n    \"\"\"\n\n    for i in range(len(nums)):\n        if nums[i] == target:\n            return i\n\n    return -1\n\n\ndef g(nums: List[int] = [5, 2, 7, 3, 1], target: int = 7) -> int:\n    \"\"\"\n    Generate a list of integers and a target number.\n\n    Example:\n    g() returns ([5, 2, 7, 3, 1], 7).\n\n    Note:\n    - The input list can contain duplicate numbers.\n    \"\"\"\n\n    return nums, target\n\n\nassert f(*g()) == 2\n",
        "idx_generation": 347,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, find the number of occurrences of the target value in the list.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    first_occurrence = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            first_occurrence = mid\n            right = mid - 1\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    if first_occurrence == -1:\n        return 0\n\n    left = first_occurrence\n    right = len(nums) - 1\n\n    last_occurrence = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            last_occurrence = mid\n            left = mid + 1\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return last_occurrence - first_occurrence + 1\n\ndef g():\n    nums = [1, 2, 2, 2, 3, 4, 5]\n    target = 2\n    return (nums, target)\n\nassert f(*g()) == 3\n\n",
        "idx_generation": 193,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Check if s1 and s2 are anagrams.\"\"\"\n    s1 = s1.replace(\" \", \"\").lower()\n    s2 = s2.replace(\" \", \"\").lower()\n\n    if sorted(s1) == sorted(s2):\n        return True\n    return False\n\ndef g(s1=\"Listen\", s2=\"Silent\"):\n    return s1, s2\n\nassert f(*g())\n",
        "idx_generation": 450,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target integer, determine if there exists a pair of integers in the list whose sum is equal to the target.\n\n    Args:\n    - nums: The list of integers.\n    - target: The target integer.\n\n    Returns:\n    - True if there exists a pair of integers in the list whose sum is equal to the target, False otherwise.\n    \"\"\"\n    nums_set = set(nums)\n    for num in nums:\n        complement = target - num\n        if complement in nums_set:\n            return True\n    return False\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 457,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the number of ways to add or subtract the elements in the list\n    to obtain the target number.\n\n    Example:\n    nums = [1, 1, 1, 1, 1]\n    target = 3\n\n    Output:\n    5\n\n    Explanation:\n    There are 5 ways to obtain the target number:\n    - 1 + 1 + 1\n    - 1 + 1 - 1 + 1\n    - 1 - 1 + 1 + 1\n    - 1 - 1 - 1 + 1 + 1\n    - 1 - 1 - 1 - 1 + 1 + 1\n    \"\"\"\n\n    def count_ways(index: int, current_sum: int) -> int:\n        if index == len(nums):\n            if current_sum == target:\n                return 1\n            else:\n                return 0\n        return count_ways(index+1, current_sum + nums[index]) + count_ways(index+1, current_sum - nums[index])\n\n    return count_ways(0, 0)\n\ndef g() -> List[int]:\n    nums = [1, 1, 1, 1, 1]\n    target = 3\n    return (nums, target)\n\nassert f(*g()) == 5\n\n",
        "idx_generation": 381,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum using the Kadane's algorithm.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum\n\ndef g() -> List[int]:\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n\n",
        "idx_generation": 126,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the shortest path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The shortest path is 1 -> 3 -> 1 -> 1 -> 1, with a total sum of 7.\n\n    Hint: Use dynamic programming to store the shortest paths to each cell.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[m - 1][n - 1]\n\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return (grid,)\n\nassert f(*g()) == 7\n",
        "idx_generation": 367,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer 'n', return the number of set bits (1s) in its binary representation.\n    \n    Example:\n    n = 5\n    \n    Output:\n    2\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g():\n    return 5\n\nassert f(g()) == 2\n",
        "idx_generation": 194,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer 'n', return the number of unique paths to reach the bottom-right corner of a 'n x n' grid.\n    You can only move either down or right at any point in time.\n\n    Example:\n    n = 3\n\n    Output:\n    6 (since there are 6 unique paths to reach the bottom-right corner)\n    \"\"\"\n    def dfs(i, j):\n        if i == n - 1 and j == n - 1:\n            return 1\n        if i >= n or j >= n:\n            return 0\n\n        return dfs(i + 1, j) + dfs(i, j + 1)\n\n    return dfs(0, 0)\n\ndef g() -> int:\n    return 3\n\nassert f(g()) == 6\n\n",
        "idx_generation": 306,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented by its edges, determine if the graph is bipartite.\n\n    Example:\n    Input:\n    n = 4\n    edges = [[0, 1], [1, 2], [2, 3], [3, 0]]\n\n    Output: True\n\n    Explanation: The graph can be partitioned into two sets of vertices {0, 2} and {1, 3},\n    where there are no edges within the sets and all edges connect vertices from different sets.\n    \"\"\"\n\n    def is_bipartite(n: int, edges: List[List[int]]) -> bool:\n        graph = [[] for _ in range(n)]\n        colors = [0] * n\n\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        def dfs(node: int, color: int) -> bool:\n            colors[node] = color\n            for neighbor in graph[node]:\n                if colors[neighbor] == color:\n                    return False\n                if colors[neighbor] == 0 and not dfs(neighbor, -color):\n                    return False\n            return True\n\n        for i in range(n):\n            if colors[i] == 0 and not dfs(i, 1):\n                return False\n\n        return True\n\n    return is_bipartite(n, edges)\n\ndef g():\n    n = 4\n    edges = [[0, 1], [1, 2], [2, 3], [3, 0]]\n    return n, edges\n\nassert f(*g()) == True\n",
        "idx_generation": 171,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, check if the graph contains a cycle.\n\n    Example:\n    graph = [[1, 2], [2, 3, 4], [3, 4], [], [5], []]\n\n    Output:\n    True\n    \"\"\"\n    def dfs(node, visited, parent):\n        visited[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, node):\n                    return True\n            elif neighbor != parent:\n                return True\n\n        return False\n\n    n = len(graph)\n    visited = [False] * n\n\n    for node in range(n):\n        if not visited[node]:\n            if dfs(node, visited, -1):\n                return True\n\n    return False\n\ndef g():\n    graph = [[1, 2], [2, 3, 4], [3, 4], [], [5], []]\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 286,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the number of ways to choose k items from n items without repetition.\n\n    Example:\n    n = 5\n    k = 3\n\n    Output:\n    10 (there are 10 ways to choose 3 items from a set of 5)\n    \"\"\"\n    fact_n = 1\n    fact_k = 1\n    fact_n_k = 1\n    for i in range(1, n+1):\n        fact_n *= i\n    for i in range(1, k+1):\n        fact_k *= i\n    for i in range(1, n-k+1):\n        fact_n_k *= i\n    return fact_n // (fact_k * fact_n_k)\n\ndef g() -> Tuple[int, int]:\n    return 5, 3\n\nassert f(*g()) == 10\n",
        "idx_generation": 442,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Find the number of ways to choose 'n' items from a set of 10 items, where the order does not matter.\n    \"\"\"\n    if n < 0 or n > 10:\n        return None\n    \n    if n == 0 or n == 10:\n        return 1\n    \n    numerator = 1\n    denominator = 1\n    \n    for i in range(n):\n        numerator *= (10 - i)\n        denominator *= (n - i)\n    \n    return numerator // denominator\n\ndef g():\n    return 7\n\nassert f(g()) == 120\n",
        "idx_generation": 262,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, determine if there are two numbers in the list that sum up to the target.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    Sample Output:\n    True\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5], 7\n\nassert f(*g()) == True\n",
        "idx_generation": 349,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(arr: List[int], target: int) -> Tuple[int, int]:\n    \"\"\"\n    Given a sorted list of integers and a target value, find two numbers in the list that add up to the target.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n\n    Output:\n    (2, 5)\n\n    Explanation:\n    The numbers 2 and 5 add up to the target value of 7.\n\n    Hint: Use a two-pointer approach to search for the pair of numbers.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return (arr[left], arr[right])\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n\n    return ()\n\ndef g() -> Tuple[List[int], int]:\n    return ([1, 2, 3, 4, 5], 7)\n\nassert f(*g()) == (2, 5)\n",
        "idx_generation": 194,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Given two strings, check if they are anagrams of each other.\n\n    Example:\n    s1 = \"listen\"\n    s2 = \"silent\"\n\n    Output:\n    True\n\n    Explanation:\n    The strings \"listen\" and \"silent\" are anagrams of each other.\n\n    Hint: An anagram is a word or phrase formed by rearranging the letters of another word or phrase.\n    \"\"\"\n\n    # Convert the strings to lowercase and remove whitespace\n    s1 = s1.lower().replace(\" \", \"\")\n    s2 = s2.lower().replace(\" \", \"\")\n\n    # Check if the sorted characters of the first string are equal to the sorted characters of the second string\n    return sorted(s1) == sorted(s2)\n\ndef g(s1: str = \"listen\", s2: str = \"silent\"):\n    \"\"\"\n    Generate two strings to check if they are anagrams of each other.\n    \"\"\"\n    return s1, s2\n\nassert f(*g()) == True\n",
        "idx_generation": 490,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of unique binary search trees that can be formed with n nodes.\n\n    Example:\n    Input: 3\n    Output: 5\n\n    Explanation:\n    For n = 3, there are 5 unique binary search trees that can be formed:\n        1         3     3      2      1\n         \\       /     /      / \\      \\\n          3     2     1      1   3      2\n         /     /       \\                 \\\n        2     1         2                 3\n    \"\"\"\n\n    if n <= 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i - j - 1]\n\n    return dp[n]\n\ndef g() -> int:\n    return 3\n\nassert f(g()) == 5\n",
        "idx_generation": 466,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list containing only the even numbers.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    Output: [2, 4, 6, 8, 10]\n    \"\"\"\n\n    return [x for x in nums if x % 2 == 0]\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]):\n    return nums\n\nassert f(g()) == [2, 4, 6, 8, 10]\n\n",
        "idx_generation": 381,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    return dp[-1][-1]\n\ndef g(grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(g()) == 12\n",
        "idx_generation": 128,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, find the length of the shortest path from the top-left corner to the bottom-right corner.\n    You can only move down or right in the grid.\n\n    Args:\n    - grid: A 2D list of 0s and 1s\n\n    Returns:\n    - The length of the shortest path\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n    return grid\n\nassert f(g()) == 7\n\n",
        "idx_generation": 371,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR value between any two numbers in the array.\n    Return the maximum XOR value.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    max_xor = 0\n    mask = 0\n    \n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n        \n        for num in nums:\n            prefix_set.add(num & mask)\n        \n        possible_xor = max_xor | (1 << i)\n        \n        for prefix in prefix_set:\n            if (prefix ^ possible_xor) in prefix_set:\n                max_xor = possible_xor\n                break\n    \n    return max_xor\n\ndef g():\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n",
        "idx_generation": 209,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of valid parentheses expressions of length 2n.\n    A valid parentheses expression must have an opening parenthesis '(' followed by a closing parenthesis ')'.\n    \"\"\"\n    if n == 0:\n        return 1\n\n    count = 0\n    for i in range(n):\n        count += f(i) * f(n - i - 1)\n\n    return count\n\ndef g(n: int = 3):\n    return n\n\nassert f(g()) == 5\n\n",
        "idx_generation": 314,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, k: int) -> int:\n    \"\"\"\n    Given a graph represented as an adjacency matrix, find the number of paths from start to end with a maximum of k edges.\n\n    Sample Input:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n    k = 2\n\n    Sample Output:\n    2\n\n    Explanation:\n    There are two paths from start to end with a maximum of 2 edges: 0 -> 1 -> 3 and 0 -> 2 -> 3.\n    \"\"\"\n    count = 0\n    visited = [False] * len(graph)\n    visited[start] = True\n\n    def dfs(node, edges):\n        nonlocal count\n\n        if node == end and edges <= k:\n            count += 1\n\n        if edges > k:\n            return\n\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                visited[neighbor] = True\n                dfs(neighbor, edges + 1)\n                visited[neighbor] = False\n\n    dfs(start, 0)\n\n    return count\n\ndef g(graph = [[0, 1, 1, 0], [0, 0, 1, 1], [0, 0, 0, 1], [0, 0, 0, 0]], start = 0, end = 3, k = 2):\n    return graph, start, end, k\n\nassert f(*g()) == 2\n",
        "idx_generation": 175,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the length of the shortest path from the top-left corner to the bottom-right corner.\n    You can only move down or right in the grid.\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    \n    # Initialize the distance grid\n    distance = [[float('inf')] * m for _ in range(n)]\n    distance[0][0] = grid[0][0]\n    \n    # Initialize the queue with the starting position\n    queue = deque([(0, 0)])\n    \n    # BFS to find the shortest path\n    while queue:\n        x, y = queue.popleft()\n        \n        # Check right neighbor\n        if x + 1 < n:\n            new_distance = distance[x][y] + grid[x+1][y]\n            if new_distance < distance[x+1][y]:\n                distance[x+1][y] = new_distance\n                queue.append((x+1, y))\n        \n        # Check down neighbor\n        if y + 1 < m:\n            new_distance = distance[x][y] + grid[x][y+1]\n            if new_distance < distance[x][y+1]:\n                distance[x][y+1] = new_distance\n                queue.append((x, y+1))\n    \n    return distance[n-1][m-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 300,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[str]:\n    \"\"\"\n    Given an integer n, generate all valid parentheses combinations with n pairs of parentheses.\n\n    Example:\n    Input: n = 3\n\n    Output:\n    [\n        \"((()))\",\n        \"(()())\",\n        \"(())()\",\n        \"()(())\",\n        \"()()()\"\n    ]\n    \"\"\"\n    def generate_parentheses_helper(open_count, close_count, current, result):\n        if open_count == 0 and close_count == 0:\n            result.append(current)\n            return\n\n        if open_count > 0:\n            generate_parentheses_helper(open_count - 1, close_count, current + \"(\", result)\n\n        if close_count > open_count:\n            generate_parentheses_helper(open_count, close_count - 1, current + \")\", result)\n\n    result = []\n    generate_parentheses_helper(n, n, \"\", result)\n    return result\n\ndef g(n=3):\n    return n\n\nassert f(g()) == [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\n",
        "idx_generation": 448,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target integer, determine if there exists a combination of numbers in nums that\n    add up to the target. Each number in nums can only be used once.\n    \"\"\"\n    return dfs(nums, target, 0, \"\")\n\ndef dfs(nums: List[int], target: int, index: int, path: str) -> bool:\n    if target == 0:\n        return True\n    if index == len(nums):\n        return False\n    if nums[index] <= target:\n        if dfs(nums, target - nums[index], index + 1, path + str(nums[index]) + \" \"):\n            return True\n    return dfs(nums, target, index + 1, path)\n\ndef g():\n    nums = [2, 4, 6, 8, 10]\n    target = 14\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 263,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of inversions in the list.\n    An inversion occurs when two elements at indices i and j in the list satisfy the condition nums[i] > nums[j] and i < j.\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] > nums[j]:\n                count += 1\n    return count\n\ndef g(nums=[5, 3, 2, 4, 1]):\n    return nums\n\nassert f(g()) == 8\n\n",
        "idx_generation": 349,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target element using binary search.\n    \"\"\"\n    def binary_search(nums, target, low, high):\n        if low > high:\n            return -1\n        \n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] > target:\n            return binary_search(nums, target, low, mid - 1)\n        else:\n            return binary_search(nums, target, mid + 1, high)\n    \n    return binary_search(nums, target, 0, len(nums) - 1)\n\ndef g():\n    \"\"\"\n    Generate the input values for the function f.\n    \"\"\"\n    return ([1, 3, 5, 7, 9], 5)\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 195,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of trailing zeros in n!.\n\n    Example:\n    n = 10\n\n    Output:\n    2\n\n    Explanation:\n    10! = 3628800, which has 2 trailing zeros.\n\n    Hint: Count the number of factors of 5 in the prime factorization of n!\n    \"\"\"\n\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n\n    return count\n\n\ndef g() -> int:\n    return 25\n\n\nassert f(g()) == 6\n",
        "idx_generation": 473,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a prime number.\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g() -> int:\n    return 17\n\nassert f(g())\n",
        "idx_generation": 382,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n    \"\"\"\n    if n <= 2:\n        return n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\ndef g(n = 4):\n    return n\n\nassert f(g()) == 5\n",
        "idx_generation": 128,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the length of the longest increasing path.\n\n    Example:\n    Input: [[9,9,4],[6,6,8],[2,1,1]]\n    Output: 4\n    Explanation: The longest increasing path is [1, 2, 6, 9].\n\n    Note:\n    - The path can start at any position, but it must follow the increasing order of adjacent cells.\n    - You can move up, down, left, or right from a cell to another adjacent one with a smaller or equal value.\n    \"\"\"\n    if not grid:\n        return 0\n\n    rows, cols = len(grid), len(grid[0])\n    longest_path = 0\n    memo = [[0] * cols for _ in range(rows)]\n\n    def dfs(row, col):\n        if memo[row][col]:\n            return memo[row][col]\n\n        path = 1\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        for dx, dy in directions:\n            new_row, new_col = row + dx, col + dy\n\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] > grid[row][col]:\n                path = max(path, dfs(new_row, new_col) + 1)\n\n        memo[row][col] = path\n        return path\n\n    for i in range(rows):\n        for j in range(cols):\n            longest_path = max(longest_path, dfs(i, j))\n\n    return longest_path\n\ndef g():\n    return [[9, 9, 4], [6, 6, 8], [2, 1, 1]]\n\nassert f(g()) == 4\n",
        "idx_generation": 399,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"\n    Given a positive integer num, find the number of bits required to represent it in binary.\n\n    Sample Input:\n    num = 10\n\n    Sample Output:\n    4\n\n    Explanation:\n    The binary representation of 10 is 1010, which requires 4 bits.\n    \"\"\"\n\n    def count_bits(num: int) -> int:\n        if num == 0:\n            return 0\n        return 1 + count_bits(num // 2)\n\n    return count_bits(num)\n\ndef g(num: int = 10) -> int:\n    return num\n\nassert f(g()) == 4\n",
        "idx_generation": 220,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the factorial of n.\n    Return the factorial value.\n\n    Sample input:\n    n = 5\n\n    Sample output:\n    120\n    \"\"\"\n    if n == 0:\n        return 1\n    else:\n        return n * f(n-1)\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 120\n",
        "idx_generation": 315,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(vertices: List[List[int]], edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given a list of vertices and a list of edges, determine if the given graph is a tree.\n    A tree is a connected graph with no cycles.\n    \"\"\"\n    parent = [i for i in range(len(vertices))]\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    def union(x, y):\n        rootX, rootY = find(x), find(y)\n        if rootX == rootY:\n            return False\n        parent[rootY] = rootX\n        return True\n    for edge in edges:\n        if not union(edge[0], edge[1]):\n            return False\n    return len(set(parent)) == 1\n\ndef g(vertices = [[0, 0], [0, 1], [1, 0], [1, 1]], edges = [[0, 1], [0, 2], [0, 3]]):\n    return vertices, edges\n\nassert f(*g())\n",
        "idx_generation": 179,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Graph:\n    def __init__(self, num_vertices: int):\n        self.num_vertices = num_vertices\n        self.adj_list = [[] for _ in range(num_vertices)]\n    \n    def add_edge(self, u: int, v: int):\n        self.adj_list[u].append(v)\n    \n    def is_path(self, start: int, end: int) -> bool:\n        visited = [False] * self.num_vertices\n        stack = [start]\n        \n        while stack:\n            vertex = stack.pop()\n            \n            if vertex == end:\n                return True\n            \n            if not visited[vertex]:\n                visited[vertex] = True\n                \n                for neighbor in self.adj_list[vertex]:\n                    stack.append(neighbor)\n        \n        return False\n\ndef f(edges: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a list of directed edges, check if there is a path from a start node to an end node in the graph.\n    \"\"\"\n    num_vertices = max(max(edge) for edge in edges) + 1\n    graph = Graph(num_vertices)\n    \n    for edge in edges:\n        u, v = edge\n        graph.add_edge(u, v)\n    \n    return graph.is_path(start, end)\n\ndef g():\n    edges = [[0, 1], [1, 2], [2, 3]]\n    start = 0\n    end = 3\n    return edges, start, end\n\nassert f(*g()) == True\n\n",
        "idx_generation": 302,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers 'n' and 'k', compute the number of ways to choose k objects from a set of n objects.\n    The order of the objects does not matter.\n\n    Example:\n    n = 5, k = 3\n\n    Output:\n    10 (there are 10 ways to choose 3 objects from a set of 5 objects)\n\n    Note:\n    - The result should be computed modulo 10^9 + 7.\n    \"\"\"\n\n    def factorial(n: int) -> int:\n        result = 1\n        for i in range(1, n + 1):\n            result = (result * i) % (10 ** 9 + 7)\n        return result\n\n    return (factorial(n) // (factorial(k) * factorial(n - k))) % (10 ** 9 + 7)\n\n\ndef g():\n    return (5, 3)\n\n\nassert f(*g()) == 10\n\n",
        "idx_generation": 458,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, find the number of possible combinations of k elements from a set of n elements.\n    \"\"\"\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return f(n-1, k-1) + f(n-1, k)\n\ndef g(n=5, k=2):\n    return n, k\n\nassert f(*g()) == 10\n",
        "idx_generation": 269,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list containing only the even numbers from the original list.\n    \"\"\"\n    return [num for num in nums if num % 2 == 0]\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == [2, 4, 6, 8, 10]\n",
        "idx_generation": 351,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers `arr` and a target value `target`, find the index of the target value in the list using binary search.\n    If the target value is not found in the list, return -1.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 3\n\n    Output:\n    2\n\n    Explanation:\n    The target value 3 is found at index 2 in the list.\n\n    Hint: Use the binary search algorithm to find the target value.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n\n        elif arr[mid] < target:\n            left = mid + 1\n\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers.\n    \"\"\"\n    return [1, 3, 5, 7, 9]\n\nassert f(g(), 3) == 1\n",
        "idx_generation": 203,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums and a target value, find all unique combinations in nums where the sum of the values equals the target.\n    Each number in nums may only be used once in the combination.\n    The solution set must not contain duplicate combinations.\n\n    Example:\n    nums = [10, 1, 2, 7, 6, 1, 5]\n    target = 8\n\n    Output:\n    [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n\n    Hint: Use backtracking to generate all combinations and check if their sum equals the target.\n    \"\"\"\n\n    def backtrack(curr_comb, start, curr_sum):\n        if curr_sum == target:\n            result.append(curr_comb[:])\n            return\n\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n\n            if curr_sum + nums[i] > target:\n                break\n\n            curr_comb.append(nums[i])\n            backtrack(curr_comb, i+1, curr_sum + nums[i])\n            curr_comb.pop()\n\n    nums.sort()\n    result = []\n    backtrack([], 0, 0)\n    return result\n\ndef g():\n    return ([10, 1, 2, 7, 6, 1, 5], 8)\n\nassert f(*g()) == [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n\n",
        "idx_generation": 480,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers 'nums' and a target sum, find two numbers in the array that add up to the target and return their indices.\n\n    Args:\n    - nums: A list of integers.\n    - target: The target sum.\n\n    Returns:\n    - A list containing the indices of the two numbers that add up to the target sum.\n    \"\"\"\n    num_to_index = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_to_index:\n            return [num_to_index[complement], i]\n        num_to_index[num] = i\n\n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 383,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum along a path from the top-left cell to the bottom-right cell.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    \n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    return grid\n\nassert f(g()) == 12\n\n",
        "idx_generation": 130,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool:\n    \"\"\"\n    Given a grid of 0s and 1s, determine if there is a path from the start cell to the end cell.\n    You can only move horizontally or vertically and cannot cross cells with a value of 0.\n\n    Sample Input:\n    grid = [[1, 0, 0, 0],\n            [1, 1, 0, 1],\n            [1, 1, 0, 0],\n            [0, 1, 1, 1]]\n    start = (0, 0)\n    end = (3, 3)\n\n    Sample Output:\n    True\n    \"\"\"\n    def dfs(row: int, col: int) -> bool:\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] == 0:\n            return False\n        if row == end[0] and col == end[1]:\n            return True\n\n        grid[row][col] = 0\n        if dfs(row + 1, col) or dfs(row - 1, col) or dfs(row, col + 1) or dfs(row, col - 1):\n            return True\n\n        return False\n\n    return dfs(start[0], start[1])\n\ndef g():\n    grid = [[1, 0, 0, 0],\n            [1, 1, 0, 1],\n            [1, 1, 0, 0],\n            [0, 1, 1, 1]]\n    start = (0, 0)\n    end = (3, 3)\n    return grid, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 402,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of set bits (1s) in its binary representation.\n\n    Sample Input:\n    n = 10\n\n    Sample Output:\n    2\n    \"\"\"\n    count = 0\n\n    while n:\n        count += n & 1\n        n >>= 1\n\n    return count\n\ndef g(n=10):\n    return n\n\nassert f(g()) == 2\n",
        "idx_generation": 222,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    1 + 4 + 7 + 8 + 9 = 29\n    \"\"\"\n\n    def dfs(row: int, col: int) -> int:\n        if row >= len(matrix) or col >= len(matrix[0]):\n            return 0\n\n        right = dfs(row, col + 1)\n        down = dfs(row + 1, col)\n\n        return matrix[row][col] + max(right, down)\n\n    return dfs(0, 0)\n\n\ndef g():\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n\nassert f(g()) == 29\n\n",
        "idx_generation": 317,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given an n x m grid filled with non-negative integers, find the number of unique paths from the top-left corner to the bottom-right corner.\n    You can only move down or right at any point in time.\n    Return the number of unique paths.\n\n    Example:\n    n = 3\n    m = 3\n    grid = [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]\n\n    Output:\n    2\n\n    Explanation:\n    There are two unique paths from the top-left corner to the bottom-right corner: (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) and (0,0) -> (1,0) -> (2,0) -> (2,1) -> (2,2).\n    \"\"\"\n\n    if n == 0 or m == 0:\n        return 0\n\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = 1\n\n    for i in range(n):\n        for j in range(m):\n            if i > 0 and grid[i][j] != 1:\n                dp[i][j] += dp[i-1][j]\n            if j > 0 and grid[i][j] != 1:\n                dp[i][j] += dp[i][j-1]\n\n    return dp[n-1][m-1]\n\ndef g():\n    n = 3\n    m = 3\n    grid = [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]\n    return n, m, grid\n\nassert f(*g()) == 2\n",
        "idx_generation": 183,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency matrix and two nodes (start and end), determine if there is a path from start to end in the graph.\n\n    Example:\n    Input:\n    graph = [[0, 1, 0, 0],\n             [0, 0, 1, 0],\n             [1, 0, 0, 1],\n             [0, 0, 0, 0]]\n    start = 0\n    end = 3\n\n    Output: True\n    Explanation: There is a path from node 0 to node 3: 0 -> 1 -> 2 -> 3.\n    \"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        current = stack.pop()\n        visited.add(current)\n        if current == end:\n            return True\n        for neighbor in range(len(graph[current])):\n            if graph[current][neighbor] == 1 and neighbor not in visited:\n                stack.append(neighbor)\n    return False\n\ndef g() -> Tuple[List[List[int]], int, int]:\n    graph = [[0, 1, 0, 0],\n             [0, 0, 1, 0],\n             [1, 0, 0, 1],\n             [0, 0, 0, 0]]\n    start = 0\n    end = 3\n    return graph, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 307,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of ways to arrange n identical balls into k distinct boxes,\n    where each box can contain any number of balls (including zero).\n\n    Example:\n    n = 4\n\n    Output:\n    15\n\n    Explanation:\n    The number of ways to arrange 4 identical balls into distinct boxes is 15:\n    - 4 balls in 1 box\n    - 3 balls in 1 box, 1 ball in another box\n    - 2 balls in 1 box, 2 balls in another box\n    - 2 balls in 2 boxes, 1 ball in another box\n    - 1 ball in 1 box, 3 balls in another box\n    - 1 ball in 2 boxes, 2 balls in another box\n    - 1 ball in 3 boxes, 1 ball in another box\n    - 0 balls in 1 box, 4 balls in another box\n    - 0 balls in 2 boxes, 3 balls in another box\n    - 0 balls in 3 boxes, 2 balls in another box\n    - 0 balls in 4 boxes, 1 ball in another box\n    - 0 balls in 5 boxes\n    - 0 balls in 6 boxes\n    - 0 balls in 7 boxes\n    - 0 balls in 8 boxes\n\n    Hint: Use combinatorial analysis to calculate the number of ways to arrange the balls.\n    \"\"\"\n\n    # Calculate the number of ways to arrange n identical balls into k distinct boxes\n    return pow(2, n) - 1\n\ndef g(n=4):\n    return n\n\nassert f(g()) == 15\n\n",
        "idx_generation": 465,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of distinct subsets with an odd sum.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The number of distinct subsets with an odd sum.\n    \"\"\"\n    def count_subsets(nums, i, cur_sum, memo):\n        if i == len(nums):\n            if cur_sum % 2 == 1:\n                return 1\n            else:\n                return 0\n\n        if (i, cur_sum) in memo:\n            return memo[(i, cur_sum)]\n\n        include = count_subsets(nums, i+1, cur_sum + nums[i], memo)\n        exclude = count_subsets(nums, i+1, cur_sum, memo)\n\n        memo[(i, cur_sum)] = include + exclude\n\n        return memo[(i, cur_sum)]\n\n    memo = {}\n    return count_subsets(nums, 0, 0, memo)\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 16\n",
        "idx_generation": 271,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a pair of numbers in the list whose sum is equal to 10.\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == 10:\n            return True\n        elif current_sum < 10:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9]):\n    \"\"\"\n    Generate a list of integers such that there exists a pair of numbers whose sum is equal to 10.\n    \"\"\"\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 353,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers 'arr' and a target value 'target', use Binary Search to determine if the target is present in the array.\n\n    Binary Search is a search algorithm that works by repeatedly dividing the search interval in half. It compares the middle element of the interval with the target value and adjusts the interval accordingly. This process is repeated until the target is found or the interval becomes empty.\n\n    Example:\n    arr = [12, 25, 36, 47, 58, 69, 80]\n    target = 47\n\n    Output:\n    True\n    \"\"\"\n    def binary_search(arr: List[int], low: int, high: int, target: int) -> bool:\n        if low <= high:\n            mid = (low + high) // 2\n            if arr[mid] == target:\n                return True\n            elif arr[mid] > target:\n                return binary_search(arr, low, mid - 1, target)\n            else:\n                return binary_search(arr, mid + 1, high, target)\n        else:\n            return False\n\n    return binary_search(arr, 0, len(arr) - 1, target)\n\ndef g():\n    return [12, 25, 36, 47, 58, 69, 80], 47\n\nassert f(*g()) == True\n",
        "idx_generation": 204,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of prime numbers less than or equal to n.\n\n    Example:\n    n = 10\n\n    Output:\n    4\n\n    Explanation:\n    There are 4 prime numbers less than or equal to 10: 2, 3, 5, and 7.\n\n    Hint: Use the Sieve of Eratosthenes algorithm to find all prime numbers up to n.\n    \"\"\"\n\n    if n <= 1:\n        return 0\n\n    primes = [True] * (n + 1)\n    primes[0] = primes[1] = False\n\n    for i in range(2, int(n ** 0.5) + 1):\n        if primes[i]:\n            for j in range(i*i, n + 1, i):\n                primes[j] = False\n\n    return sum(primes)\n\ndef g() -> int:\n    n = 20\n    return n\n\nassert f(g()) == 8\n\n",
        "idx_generation": 492,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two integers in the list.\n    \"\"\"\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n    return max_product\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return (nums,)\n\nassert f(*g()) == 20\n\n",
        "idx_generation": 383,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the nth Fibonacci number.\n    The Fibonacci sequence is defined as follows:\n    - F(0) = 0\n    - F(1) = 1\n    - F(n) = F(n-1) + F(n-2) for n > 1\n\n    Return the nth Fibonacci number.\n\n    Example:\n    n = 5\n\n    Output:\n    5\n\n    Explanation:\n    The 5th Fibonacci number is 5.\n    \"\"\"\n    def fibonacci(n: int, memo: Dict[int, int]) -> int:\n        if n in memo:\n            return memo[n]\n\n        if n <= 1:\n            return n\n\n        memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)\n        return memo[n]\n\n    return fibonacci(n, {})\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 5\n\n",
        "idx_generation": 133,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two positive integers n and m, count the number of unique paths from the top-left corner to the\n    bottom-right corner of an n x m grid. You can only move down or right.\n\n    Example:\n    n = 3\n    m = 3\n\n    Output:\n    6 (there are 6 unique paths from the top-left to the bottom-right corner of a 3x3 grid)\n    \"\"\"\n    dp = [[0] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if i == 0 or j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    return dp[n-1][m-1]\n\ndef g():\n    n = 3\n    m = 3\n    return n, m\n\nassert f(*g()) == 6\n",
        "idx_generation": 409,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(num1: int, num2: int) -> int:\n    \"\"\"\n    Given two integers, perform the bitwise XOR operation on them and return the result.\n\n    Sample Input:\n    num1 = 5\n    num2 = 3\n\n    Sample Output:\n    6\n    Explanation: 5 XOR 3 = 6 in binary (101 XOR 011 = 110)\n    \"\"\"\n    return num1 ^ num2\n\ndef g():\n    num1 = 5\n    num2 = 3\n    return num1, num2\n\nassert f(*g()) == 6\n",
        "idx_generation": 223,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum of a path from the top left cell to the bottom right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7 (path: 1 -> 3 -> 1 -> 1 -> 1)\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n",
        "idx_generation": 318,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> int:\n    \"\"\"\n    Given a binary tree, return the maximum depth of the tree.\n    \"\"\"\n    if root is None:\n        return 0\n\n    left_depth = f(root.left)\n    right_depth = f(root.right)\n\n    return max(left_depth, right_depth) + 1\n\ndef g():\n    # Create a binary tree\n    root = TreeNode(3)\n    root.left = TreeNode(9)\n    root.right = TreeNode(20)\n    root.right.left = TreeNode(15)\n    root.right.right = TreeNode(7)\n\n    return root\n\nassert f(g()) == 3\n",
        "idx_generation": 187,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph as a dictionary where the keys represent the nodes and the values represent the neighbors,\n    determine if there is a path from the start node to the end node.\n\n    Sample Input:\n    graph = {1: [2, 3], 2: [4], 3: [4, 5], 4: [6], 5: [6], 6: []}\n    start = 1\n    end = 6\n\n    Sample Output:\n    True\n    \"\"\"\n    visited = set()\n    return dfs(graph, start, end, visited)\n\ndef dfs(graph, node, end, visited):\n    if node == end:\n        return True\n    visited.add(node)\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, end, visited):\n                return True\n    return False\n\ndef g():\n    \"\"\"\n    Generate the input values for the function f.\n    \"\"\"\n    graph = {1: [2, 3], 2: [4], 3: [4, 5], 4: [6], 5: [6], 6: []}\n    start = 1\n    end = 6\n    return (graph, start, end)\n\nassert f(*g()) == True\n",
        "idx_generation": 309,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string1: str, string2: str) -> bool:\n    \"\"\"Check if two strings are anagrams of each other.\"\"\"\n\n    def count_chars(string: str) -> dict:\n        char_count = {}\n        for char in string:\n            char_count[char] = char_count.get(char, 0) + 1\n        return char_count\n\n    char_count1 = count_chars(string1)\n    char_count2 = count_chars(string2)\n\n    return char_count1 == char_count2\n\ndef g(string1=\"listen\", string2=\"silent\"):\n    return string1, string2\n\nassert f(*g()) == True\n",
        "idx_generation": 483,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, calculate the number of distinct subsequences that can be formed from s.\n\n    Example:\n    Input:\n    s = \"aba\"\n\n    Output:\n    7\n    Explanation:\n    The distinct subsequences that can be formed from \"aba\" are:\n    \"\", \"a\", \"b\", \"ab\", \"ba\", \"aa\", \"aba\"\n    \"\"\"\n    def countSubsequences(s: str, i: int, subseq: str, memo: List[List[int]]) -> int:\n        if i == len(s):\n            return 1\n        \n        if memo[i][len(subseq)] != -1:\n            return memo[i][len(subseq)]\n        \n        count = countSubsequences(s, i + 1, subseq, memo)\n        \n        if s[i] not in subseq:\n            count += countSubsequences(s, i + 1, subseq + s[i], memo)\n        \n        memo[i][len(subseq)] = count\n        \n        return count\n    \n    memo = [[-1] * (len(s) + 1) for _ in range(len(s))]\n    return countSubsequences(s, 0, \"\", memo)\n\ndef g() -> str:\n    return \"aba\"\n\nassert f(g()) == 7\n",
        "idx_generation": 275,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n\n    Output:\n    True\n\n    Explanation:\n    2 + 5 = 7\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        sum = arr[left] + arr[right]\n\n        if sum == target:\n            return True\n        elif sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(arr=[1, 2, 3, 4, 5], target=7):\n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 355,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers 'arr', find the length of the longest increasing subsequence in the array.\n\n    A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. An increasing subsequence is a subsequence in which the elements are in strictly increasing order.\n\n    Example:\n    arr = [10, 22, 9, 33, 21, 50, 41, 60]\n\n    Output:\n    5 (the longest increasing subsequence is [10, 22, 33, 50, 60])\n    \"\"\"\n    def binary_search(arr: List[int], low: int, high: int, target: int) -> int:\n        while low <= high:\n            mid = (low + high) // 2\n            if arr[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return low\n\n    n = len(arr)\n    tail = [0] * n\n    length = 1\n    tail[0] = arr[0]\n\n    for i in range(1, n):\n        if arr[i] > tail[length - 1]:\n            tail[length] = arr[i]\n            length += 1\n        else:\n            index = binary_search(tail, 0, length - 1, arr[i])\n            tail[index] = arr[i]\n\n    return length\n\ndef g():\n    return [10, 22, 9, 33, 21, 50, 41, 60]\n\nassert f(g()) == 5\n",
        "idx_generation": 204,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n\n    Args:\n    - nums: A list of integers.\n    - target: The target value.\n\n    Returns:\n    - The product of the two numbers that add up to the target.\n    \"\"\"\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return num * complement\n        seen[num] = i\n    return -1\n\ndef g():\n    nums = [2, 3, 4, 5, 6]\n    target = 9\n    return nums, target\n\nassert f(*g()) == 20\n",
        "idx_generation": 384,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of ways to climb to the top of a staircase.\n    You can climb either 1 or 2 steps at a time.\n\n    Return the number of distinct ways to climb to the top.\n\n    Example:\n    n = 4\n\n    Output:\n    5\n\n    Explanation:\n    There are 5 distinct ways to climb to the top:\n    - 1 step + 1 step + 1 step + 1 step\n    - 1 step + 1 step + 2 steps\n    - 1 step + 2 steps + 1 step\n    - 2 steps + 1 step + 1 step\n    - 2 steps + 2 steps\n    \"\"\"\n    def climb_stairs(n: int, memo: Dict[int, int]) -> int:\n        if n in memo:\n            return memo[n]\n\n        if n <= 2:\n            return n\n\n        memo[n] = climb_stairs(n-1, memo) + climb_stairs(n-2, memo)\n        return memo[n]\n\n    return climb_stairs(n, {})\n\ndef g(n=4):\n    return n\n\nassert f(g()) == 5\n\n",
        "idx_generation": 133,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum path sum from the top-left cell to the bottom-right cell.\n    You can only move down or right at any step.\n\n    Example:\n    Input:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output: 7\n\n    Explanation: The minimum path sum is 1 + 3 + 1 + 1 + 1 = 7.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 412,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, count the number of set bits (bits that are equal to 1) in its binary representation.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g(n: int = 10):\n    return n\n\nassert f(g()) == 2\n\n",
        "idx_generation": 225,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the nth Fibonacci number.\n    \"\"\"\n\n    if n <= 1:\n        return n\n    \n    fib = [0] * (n+1)\n    fib[1] = 1\n\n    for i in range(2, n+1):\n        fib[i] = fib[i-1] + fib[i-2]\n\n    return fib[n]\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 5\n",
        "idx_generation": 322,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Count the number of Hamiltonian paths in a grid of size n x n.\n    \"\"\"\n\n    def dfs(row: int, col: int, visited: List[List[bool]], n: int) -> int:\n        if visited[row][col]:\n            return 0\n\n        if row == n-1 and col == n-1:\n            return 1\n\n        visited[row][col] = True\n        paths = 0\n\n        if row+1 < n:\n            paths += dfs(row+1, col, visited, n)\n\n        if col+1 < n:\n            paths += dfs(row, col+1, visited, n)\n\n        visited[row][col] = False\n        return paths\n\n    visited = [[False] * n for _ in range(n)]\n    return dfs(0, 0, visited, n)\n\ndef g(n: int):\n    return n\n\nassert f(g(3)) == 6\n",
        "idx_generation": 188,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed acyclic graph (DAG) represented as an adjacency list, determine if there is a path from the start node to the end node.\n\n    Example:\n    graph = [[1, 2], [3], [3], []]\n    start = 0\n    end = 3\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 0 to node 3: 0 -> 1 -> 3.\n\n    Hint: Use depth-first search (DFS) to traverse the graph and find a path from the start node to the end node.\n    \"\"\"\n\n    def dfs(node):\n        if node == end:\n            return True\n\n        visited[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n\n        return False\n\n    n = len(graph)\n    visited = [False] * n\n\n    return dfs(start)\n\ndef g():\n    return [[1, 2], [3], [3], []], 0, 3\n\nassert f(*g()) == True\n\n",
        "idx_generation": 312,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of possible permutations of k numbers from the range 1 to n.\n\n    Example:\n    n = 5, k = 3\n    Output: 60\n    Explanation: There are 60 possible permutations of 3 numbers from the range 1 to 5: \n    [1,2,3], [1,2,4], [1,2,5], [1,3,2], [1,3,4], [1,3,5], [1,4,2], [1,4,3], [1,4,5], [1,5,2], [1,5,3], [1,5,4],\n    [2,1,3], [2,1,4], [2,1,5], [2,3,1], [2,3,4], [2,3,5], [2,4,1], [2,4,3], [2,4,5], [2,5,1], [2,5,3], [2,5,4],\n    [3,1,2], [3,1,4], [3,1,5], [3,2,1], [3,2,4], [3,2,5], [3,4,1], [3,4,2], [3,4,5], [3,5,1], [3,5,2], [3,5,4],\n    [4,1,2], [4,1,3], [4,1,5], [4,2,1], [4,2,3], [4,2,5], [4,3,1], [4,3,2], [4,3,5], [4,5,1], [4,5,2], [4,5,3],\n    [5,1,2], [5,1,3], [5,1,4], [5,2,1], [5,2,3], [5,2,4], [5,3,1], [5,3,2], [5,3,4], [5,4,1], [5,4,2], [5,4,3].\n\n    Hint: Use a recursive approach to generate all permutations of k numbers from the range 1 to n.\n    \"\"\"\n\n    def generate_permutations(permutation: List[int], used: List[bool]):\n        if len(permutation) == k:\n            permutations.append(permutation[:])\n            return\n        \n        for i in range(1, n + 1):\n            if not used[i]:\n                used[i] = True\n                permutation.append(i)\n                generate_permutations(permutation, used)\n                used[i] = False\n                permutation.pop()\n\n    permutations = []\n    used = [False] * (n + 1)\n    generate_permutations([], used)\n    return len(permutations)\n\ndef g():\n    return 5, 3\n\nassert f(*g()) == 60\n\n",
        "idx_generation": 493,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of binary strings of length n that contain no consecutive 1s.\n\n    Example:\n    n = 4\n\n    Output:\n    8\n    \"\"\"\n\n    if n == 0:\n        return 0\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 2\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\ndef g():\n    return 4\n\nassert f(g()) == 8\n",
        "idx_generation": 277,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers,\n    find the maximum product of any two distinct numbers in the list.\n    Return the maximum product.\n    \"\"\"\n    max_product = float('-inf')\n\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            max_product = max(max_product, arr[i] * arr[j])\n\n    return max_product\n\ndef g():\n    return [2, 4, 6, 8, 10]\n\nassert f(g()) == 80\n",
        "idx_generation": 355,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, sort the numbers in ascending order and return the sorted list.\n\n    Example:\n    nums = [5, 2, 7, 1, 9]\n\n    Output:\n    [1, 2, 5, 7, 9]\n\n    Hint: Use any sorting algorithm to sort the list in ascending order.\n    \"\"\"\n\n    # Implementation of insertion sort\n    for i in range(1, len(nums)):\n        key = nums[i]\n        j = i - 1\n        while j >= 0 and nums[j] > key:\n            nums[j + 1] = nums[j]\n            j -= 1\n        nums[j + 1] = key\n\n    return nums\n\ndef g(nums=[5, 2, 7, 1, 9]):\n    return nums\n\nassert f(g()) == [1, 2, 5, 7, 9]\n",
        "idx_generation": 206,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that sum up to the target value.\n    Return the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1] (nums[0] + nums[1] = 2 + 7 = 9)\n    \"\"\"\n    num_dict = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []\n\ndef g():\n    \"\"\"\n    Generate a list of random integers.\n    \"\"\"\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 384,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Count the number of ways to climb n stairs, where each time you can either climb 1 or 2 steps.\n\n    Example:\n    n = 3\n\n    Output:\n    3\n\n    Explanation:\n    There are 3 ways to climb the stairs: [1, 1, 1], [1, 2], [2, 1].\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\ndef g() -> int:\n    return 3\n\nassert f(g()) == 3\n",
        "idx_generation": 134,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum path sum from the top-left cell to the bottom-right cell.\n    You can only move right or down.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    memo = [[-1] * n for _ in range(m)]\n\n    def helper(i: int, j: int) -> int:\n        if i == m - 1 and j == n - 1:\n            return grid[i][j]\n        if memo[i][j] != -1:\n            return memo[i][j]\n        if i == m - 1:\n            memo[i][j] = grid[i][j] + helper(i, j + 1)\n        elif j == n - 1:\n            memo[i][j] = grid[i][j] + helper(i + 1, j)\n        else:\n            memo[i][j] = grid[i][j] + min(helper(i, j + 1), helper(i + 1, j))\n        return memo[i][j]\n\n    return helper(0, 0)\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n",
        "idx_generation": 413,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of set bits in a given integer n\"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g(n: int):\n    return n\n\nassert f(g(7)) == 3\n",
        "idx_generation": 227,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth number in the Fibonacci sequence.\n    The Fibonacci sequence is defined as follows:\n    F(0) = 0\n    F(1) = 1\n    F(n) = F(n-1) + F(n-2) for n > 1\n    \"\"\"\n    def fibonacci(n: int, memo: List[int]) -> int:\n        if n == 0 or n == 1:\n            return n\n        if memo[n] != -1:\n            return memo[n]\n        memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)\n        return memo[n]\n    \n    memo = [-1] * (n+1)\n    return fibonacci(n, memo)\n\ndef g() -> int:\n    n = 5\n    return n\n\nassert f(g()) == 5\n\n",
        "idx_generation": 324,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix 'graph', determine if it contains a cycle.\n\n    Example:\n    graph = [\n        [0, 1, 0, 0],\n        [1, 0, 1, 1],\n        [0, 1, 0, 1],\n        [0, 1, 1, 0]\n    ]\n\n    Output:\n    True (since the graph contains a cycle)\n    \"\"\"\n\n    def dfs(vertex, visited, parent):\n        visited[vertex] = True\n\n        for neighbor in range(len(graph[vertex])):\n            if graph[vertex][neighbor] == 1:\n                if not visited[neighbor]:\n                    if dfs(neighbor, visited, vertex):\n                        return True\n                elif parent != neighbor:\n                    return True\n\n        return False\n\n    visited = [False] * len(graph)\n\n    for vertex in range(len(graph)):\n        if not visited[vertex]:\n            if dfs(vertex, visited, -1):\n                return True\n\n    return False\n\ndef g(graph: List[List[int]] = [[0, 1, 0, 0], [1, 0, 1, 1], [0, 1, 0, 1], [0, 1, 1, 0]]) -> List[List[int]]:\n    \"\"\"Generate an adjacency matrix representing an undirected graph.\"\"\"\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 196,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Determine if there is a path from start to end in a directed graph.\n\n    The graph is represented as an adjacency matrix, where graph[i][j] = 1 indicates\n    a directed edge from node i to node j.\n\n    Returns True if there is a path from start to end, False otherwise.\n    \"\"\"\n    visited = [False] * len(graph)\n    return dfs(graph, start, end, visited)\n\ndef dfs(graph: List[List[int]], node: int, end: int, visited: List[bool]) -> bool:\n    # Base case: If the current node is the end node, return True\n    if node == end:\n        return True\n    \n    # Mark the current node as visited\n    visited[node] = True\n    \n    # Recursive case: Check if there is a path from the current node to the end node\n    for neighbor in range(len(graph)):\n        if graph[node][neighbor] == 1 and not visited[neighbor]:\n            if dfs(graph, neighbor, end, visited):\n                return True\n    \n    # If no path is found, return False\n    return False\n\ndef g():\n    graph = [\n        [0, 1, 0, 0, 1],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    start = 0\n    end = 4\n\n    return graph, start, end\n\nassert f(*g()) == True\n\n",
        "idx_generation": 362,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of distinct and valid parentheses strings of length 2n.\n\n    Example:\n    Input:\n    n = 3\n\n    Output:\n    5\n\n    Explanation:\n    The distinct and valid parentheses strings of length 2n=6 are:\n    [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\n    \"\"\"\n\n    def backtrack(left, right, path, result):\n        if left == 0 and right == 0:\n            result.append(path)\n            return\n\n        if left > 0:\n            backtrack(left - 1, right, path + \"(\", result)\n        if right > left:\n            backtrack(left, right - 1, path + \")\", result)\n\n    result = []\n    backtrack(n, n, \"\", result)\n    return len(result)\n\ndef g():\n    \"\"\"\n    Generate an integer with the following structure:\n    3\n    \"\"\"\n    return 3\n\nassert f(g()) == 5\n",
        "idx_generation": 284,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a matrix of integers 'matrix' and a target integer 'target', \n    determine if the target exists in the matrix.\n\n    The matrix is sorted row-wise and column-wise in non-decreasing order.\n\n    Example:\n    matrix = [\n        [1, 4, 7],\n        [2, 5, 8],\n        [3, 6, 9]\n    ]\n    target = 5\n\n    Output:\n    True\n    \"\"\"\n    rows = len(matrix)\n    if rows == 0:\n        return False\n    cols = len(matrix[0])\n\n    row = 0\n    col = cols - 1\n\n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n\n    return False\n\ndef g():\n    matrix = [\n        [1, 4, 7],\n        [2, 5, 8],\n        [3, 6, 9]\n    ]\n    target = 5\n    return matrix, target\n\nassert f(*g()) == True\n",
        "idx_generation": 355,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target integer, find the length of the shortest subarray with a sum greater than or equal to the target.\n    Return -1 if no such subarray exists.\n\n    Example:\n    nums = [2, 3, 1, 2, 4, 3]\n    target = 7\n\n    Output:\n    2\n\n    Explanation:\n    The shortest subarray with a sum greater than or equal to 7 is [4, 3].\n\n    Hint: Use sorting, searching, and dynamic programming to solve this problem.\n    \"\"\"\n\n    if sum(nums) < target:\n        return -1\n\n    min_length = float('inf')\n    left = 0\n    curr_sum = 0\n\n    for right in range(len(nums)):\n        curr_sum += nums[right]\n\n        while curr_sum >= target:\n            min_length = min(min_length, right - left + 1)\n            curr_sum -= nums[left]\n            left += 1\n\n    return min_length\n\ndef g():\n    nums = [2, 3, 1, 2, 4, 3]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 208,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the sum of all multiples of 3 or 5 below n.\n\n    Example:\n    n = 10\n\n    Output:\n    23\n\n    Explanation:\n    The multiples of 3 or 5 below 10 are: 3, 5, 6, 9. Their sum is 23.\n    \"\"\"\n    total = 0\n    \n    for i in range(n):\n        if i % 3 == 0 or i % 5 == 0:\n            total += i\n    \n    return total\n\ndef g() -> int:\n    n = 10\n    return n\n\nassert f(g()) == 23\n\n",
        "idx_generation": 385,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Check if there exists a subarray in the given list, where the sum of the elements is equal to the target value.\n    \"\"\"\n    def helper(arr: List[int], target: int, index: int, current_sum: int) -> bool:\n        if current_sum == target:\n            return True\n        if index >= len(arr):\n            return False\n\n        # Include the current element in the sum\n        if helper(arr, target, index + 1, current_sum + arr[index]):\n            return True\n\n        # Exclude the current element from the sum\n        if helper(arr, target, index + 1, current_sum):\n            return True\n\n        return False\n\n    return helper(arr, sum(arr) // 2, 0, 0)\n\ndef g(arr: List[int]) -> List[int]:\n    return sorted(arr, reverse=True)\n\nassert f(g([1, 2, 3, 4, 5, 6, 7, 8, 9]))\n",
        "idx_generation": 137,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of zeros and ones, find the number of unique paths from the top-left corner to the bottom-right corner,\n    where zeros represent obstacles that cannot be traversed.\n\n    Example:\n    grid = [[0, 0, 0],\n            [0, 1, 0],\n            [0, 0, 0]]\n\n    Output:\n    2\n\n    Explanation:\n    There are two unique paths from the top-left corner to the bottom-right corner: \n    1. Right -> Right -> Down -> Down\n    2. Down -> Down -> Right -> Right\n\n    Hint: Use dynamic programming to calculate the number of unique paths from each cell to the destination.\n    \"\"\"\n\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                if i > 0:\n                    dp[i][j] += dp[i - 1][j]\n                if j > 0:\n                    dp[i][j] += dp[i][j - 1]\n\n    return dp[-1][-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of zeros and ones with a solution for finding the number of unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    return [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n\nassert f(g()) == 2\n\n",
        "idx_generation": 417,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D matrix of integers, find the maximum value in the matrix using bit manipulation.\n\n    Sample Input:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Sample Output:\n    9\n    \"\"\"\n    max_value = float('-inf')\n\n    for row in matrix:\n        for num in row:\n            max_value = max(max_value, num)\n\n    return max_value\n\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix\n\nassert f(g()) == 9\n",
        "idx_generation": 229,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 5],\n        [2, 1, 4],\n        [1, 2, 3]\n    ]\n    Output: 9\n    Explanation: The minimum sum of a path is 1 + 2 + 1 + 2 + 3 = 9.\n\n    Hint: Use dynamic programming to keep track of the minimum sum of paths.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 3, 5],\n        [2, 1, 4],\n        [1, 2, 3]\n    ]\n    return grid\n\nassert f(g()) == 9\n",
        "idx_generation": 327,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Dict\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency list and two nodes, determine if there is a path from start to end.\n\n    Args:\n    - graph: A dictionary representing the directed graph, where the keys are the nodes and the values are the lists of nodes that can be reached from the key node.\n    - start: The starting node.\n    - end: The ending node.\n\n    Returns:\n    - True if there is a path from start to end, False otherwise.\n    \"\"\"\n    visited = set()\n    \n    def dfs(node):\n        visited.add(node)\n        if node == end:\n            return True\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n        return False\n    \n    return dfs(start)\n\ndef g():\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D'],\n        'D': ['E'],\n        'E': []\n    }\n    start = 'A'\n    end = 'E'\n    return graph, start, end\n\nassert f(*g())\n",
        "idx_generation": 209,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size n x m, count the number of paths from the top-left corner to the bottom-right corner.\n    You can only move down or right. The grid contains obstacles represented by 1, which cannot be traversed.\n    \"\"\"\n    if grid[0][0] == 1 or grid[n-1][m-1] == 1:\n        return 0\n    \n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = 1\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                continue\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n    \n    return dp[n-1][m-1]\n\ndef g() -> Tuple[int, int, List[List[int]]]:\n    \"\"\"\n    Generate a grid and its dimensions.\n    \"\"\"\n    n = 3\n    m = 3\n    grid = [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]\n    return n, m, grid\n\nassert f(*g()) == 2\n",
        "idx_generation": 366,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(n: int, k: int) -> List[Tuple[int, int, int]]:\n    \"\"\"\n    Given two integers n and k, return a list of tuples representing all possible combinations of numbers\n    from 1 to n, where each tuple contains k numbers.\n\n    Example:\n    n = 4\n    k = 2\n\n    Output:\n    [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n    \"\"\"\n    result = []\n\n    def backtrack(start, curr):\n        if len(curr) == k:\n            result.append(tuple(curr))\n            return\n        for i in range(start, n + 1):\n            curr.append(i)\n            backtrack(i + 1, curr)\n            curr.pop()\n\n    backtrack(1, [])\n    return result\n\ndef g(n=4, k=2):\n    return n, k\n\nassert f(*g()) == [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n\n",
        "idx_generation": 286,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n\n    Example:\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 6\n\n    Output:\n    5\n\n    Explanation:\n    The target value 6 is at index 5 in the list.\n\n    Note: The input list will always be sorted in ascending order and will not contain duplicates.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 6\n    return arr, target\n\nassert f(*g()) == 5\n\n",
        "idx_generation": 356,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return the elements in spiral order.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n    Explanation:\n    The elements are visited in the following order: 1, 2, 3, 6, 9, 8, 7, 4, 5\n\n    Hint: Use a combination of sorting, searching, recursion, and dynamic programming to traverse the matrix in spiral order.\n    \"\"\"\n    if not matrix:\n        return []\n    \n    rows, cols = len(matrix), len(matrix[0])\n    top, bottom, left, right = 0, rows - 1, 0, cols - 1\n    result = []\n    \n    while top <= bottom and left <= right:\n        # Traverse the top row from left to right\n        for j in range(left, right + 1):\n            result.append(matrix[top][j])\n        top += 1\n        \n        # Traverse the right column from top to bottom\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n        \n        if top <= bottom:\n            # Traverse the bottom row from right to left\n            for j in range(right, left - 1, -1):\n                result.append(matrix[bottom][j])\n            bottom -= 1\n        \n        if left <= right:\n            # Traverse the left column from bottom to top\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n    \n    return result\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers.\n    \"\"\"\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 213,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of the maximum subarray.\n\n    Args:\n    nums (List[int]): A list of integers.\n\n    Returns:\n    int: The sum of the maximum subarray.\n\n    Example:\n    Input:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n\n    n = len(nums)\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for i in range(n):\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for finding the maximum subarray sum.\n    \"\"\"\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 385,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    Only down and right movements are allowed.\n    Return the maximum sum.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    \n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g():\n    grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    return grid\n\nassert f(g()) == 12\n",
        "idx_generation": 138,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two positive integers n and m, find the number of unique paths from the top-left corner to the bottom-right corner of an n x m grid.\n    You can only move down or right at any point in time.\n    \"\"\"\n    def unique_paths(n: int, m: int, i: int, j: int) -> int:\n        if i == n - 1 and j == m - 1:\n            return 1\n        elif i >= n or j >= m:\n            return 0\n        else:\n            return unique_paths(n, m, i + 1, j) + unique_paths(n, m, i, j + 1)\n\n    return unique_paths(n, m, 0, 0)\n\ndef g():\n    n = 3\n    m = 4\n    return n, m\n\nassert f(*g()) == 10\n",
        "idx_generation": 421,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of bits required to represent n in binary.\n\n    Example:\n    n = 10\n\n    Output:\n    4\n\n    Explanation:\n    The binary representation of 10 is 1010, which requires 4 bits.\n    \"\"\"\n\n    if n == 0:\n        return 1\n\n    count = 0\n    while n > 0:\n        count += 1\n        n = n >> 1\n\n    return count\n\ndef g():\n    return (10,)\n\nassert f(*g()) == 4\n\n",
        "idx_generation": 230,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move right or down.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    1 + 4 + 7 + 8 + 9 = 29\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = matrix[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g(matrix: List[List[int]]):\n    return matrix\n\nassert f(g([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) == 29\n\n",
        "idx_generation": 328,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef f(root: Node) -> int:\n    \"\"\"\n    Given the root of a binary tree, determine if it is a valid binary search tree.\n\n    Args:\n    - root: The root node of the binary tree.\n\n    Returns:\n    - True if the binary tree is a valid binary search tree, False otherwise.\n    \"\"\"\n    return is_valid_bst(root, float('-inf'), float('inf'))\n\ndef is_valid_bst(root: Node, min_val: int, max_val: int) -> bool:\n    if root is None:\n        return True\n    if root.value <= min_val or root.value >= max_val:\n        return False\n    return is_valid_bst(root.left, min_val, root.value) and is_valid_bst(root.right, root.value, max_val)\n\ndef g():\n    root = Node(5)\n    root.left = Node(3)\n    root.right = Node(7)\n    root.left.left = Node(2)\n    root.left.right = Node(4)\n    root.right.left = Node(6)\n    root.right.right = Node(8)\n    return root\n\nassert f(g()) == True\n",
        "idx_generation": 214,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]], target: int, rows=3, cols=3) -> bool:\n    \"\"\"\n    Given a matrix of integers and a target number, determine if the target number can be obtained by traversing the matrix.\n    The target number can be obtained by starting at any cell in the matrix and moving to adjacent cells (up, down, left, or right),\n    summing the values along the path. Return True if the target number can be obtained, False otherwise.\n    \"\"\"\n    def dfs(i, j, target):\n        if target == 0:\n            return True\n        if i < 0 or i >= rows or j < 0 or j >= cols or matrix[i][j] == -1:\n            return False\n        temp = matrix[i][j]\n        matrix[i][j] = -1\n        found = dfs(i+1, j, target - temp) or dfs(i-1, j, target - temp) or dfs(i, j+1, target - temp) or dfs(i, j-1, target - temp)\n        matrix[i][j] = temp\n        return found\n\n    for i in range(rows):\n        for j in range(cols):\n            if dfs(i, j, target):\n                return True\n    return False\n\ndef g(matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], target = 15):\n    return matrix, target\n\nassert f(*g())\n",
        "idx_generation": 366,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Given two integers n and k, return all possible combinations of k numbers out of the range [1, n].\n    \"\"\"\n    def backtrack(start, curr_combination):\n        if len(curr_combination) == k:\n            combinations.append(curr_combination[:])\n            return\n        for i in range(start, n + 1):\n            curr_combination.append(i)\n            backtrack(i + 1, curr_combination)\n            curr_combination.pop()\n    \n    combinations = []\n    backtrack(1, [])\n    \n    return combinations\n\ndef g(n=4, k=2):\n    \"\"\"\n    Generate two integers n and k such that there exists possible combinations of k numbers out of the range [1, n].\n    \"\"\"\n    return n, k\n\nassert f(*g()) == [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n",
        "idx_generation": 286,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers, find the index of the first occurrence of a target element.\n    If the target is not found, return -1.\n    \"\"\"\n    low = 0\n    high = len(nums) - 1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        \n        if nums[mid] == target:\n            if mid == 0 or nums[mid - 1] != target:\n                return mid\n            else:\n                high = mid - 1\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return -1\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 5, 6, 6, 6, 7]\n    target = 6\n    return (nums, target)\n\nassert f(*g()) == 6\n",
        "idx_generation": 357,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if target exists in arr\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef g():\n    return [3, 1, 5, 2, 4], 2\n\nassert f(*g()) == True\n",
        "idx_generation": 218,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return the list in reverse order.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    [5, 4, 3, 2, 1]\n    \"\"\"\n    return nums[::-1]\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == [5, 4, 3, 2, 1]\n",
        "idx_generation": 386,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n\n    Return the number of distinct ways.\n\n    Example:\n    n = 3\n\n    Output:\n    3\n\n    Explanation:\n    The possible ways to climb to the top of a staircase with 3 steps are:\n    - 1 step + 1 step + 1 step\n    - 1 step + 2 steps\n    - 2 steps + 1 step\n    The total number of distinct ways is 3.\n    \"\"\"\n\n    def count_steps(n):\n        if n <= 1:\n            return 1\n        dp = [0] * (n + 1)\n        dp[1] = 1\n        dp[2] = 2\n        for i in range(3, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        return dp[n]\n\n    return count_steps(n)\n\ndef g(n: int):\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return n\n\nassert f(g(3)) == 3\n",
        "idx_generation": 138,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum path is 1 -> 3 -> 1 -> 1 -> 1, which has a sum of 7.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[-1][-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n\n",
        "idx_generation": 423,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, strings=['apple', 'banana', 'cherry', 'date', 'fig', 'grape', 'honeydew', 'kiwi', 'lemon', 'mango']) -> bool:\n    \"\"\"Check if the given string is a substring of any string in the list.\"\"\"\n    return any((s in string for string in strings))\n    \ndef g(strings=['apple', 'banana', 'cherry', 'date', 'fig', 'grape', 'honeydew', 'kiwi', 'lemon', 'mango']):\n    return strings[0][:len(strings[0])//2]\n    \nassert f(g()) == True\n",
        "idx_generation": 1,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of bits set to 1 in its binary representation.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g(n: int = 42):\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return n\n\nassert f(g()) == 3\n",
        "idx_generation": 233,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of the first n Fibonacci numbers.\n\n    Example:\n    Input: n = 5\n    Output: 12\n\n    Explanation: The first 5 Fibonacci numbers are 0, 1, 1, 2, 3. Their sum is 0 + 1 + 1 + 2 + 3 = 7.\n\n    Hint: Use the mathematical formula for the sum of the first n Fibonacci numbers.\n    \"\"\"\n\n    def fibonacci_sum(n):\n        if n <= 0:\n            return 0\n        fib = [0, 1]\n        for i in range(2, n + 1):\n            fib.append(fib[i - 1] + fib[i - 2])\n        return sum(fib)\n\n    return fibonacci_sum(n)\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 12\n",
        "idx_generation": 347,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representing a directed graph, determine if there is a cycle in the graph.\n\n    Example:\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 0, 0, 0]\n    ]\n\n    Output:\n    True\n\n    Hint: Use depth-first search (DFS) to traverse the graph and detect cycles.\n    \"\"\"\n\n    visited = [False] * len(graph)\n\n    def dfs(node, parent):\n        visited[node] = True\n\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1:\n                if visited[neighbor] == True and neighbor != parent:\n                    return True\n                elif visited[neighbor] == False:\n                    if dfs(neighbor, node):\n                        return True\n\n        return False\n\n    for node in range(len(graph)):\n        if visited[node] == False:\n            if dfs(node, -1):\n                return True\n\n    return False\n\ndef g():\n    return [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 0, 0, 0]\n    ]\n\nassert f(g()) == True\n",
        "idx_generation": 215,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there is a path between start and end in a given graph.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g():\n    graph = {1: [2, 3], 2: [4], 3: [5], 4: [5], 5: []}\n    start = 1\n    end = 5\n    return graph\n\nassert f(g(), 1, 5) == True\n",
        "idx_generation": 373,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Given an integer n, generate all unique permutations of the numbers 1 to n.\n\n    Example:\n    Input: n = 3\n    Output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n    Hint: Use backtracking to generate all permutations.\n    \"\"\"\n\n    def backtrack(nums, path, used, result):\n        if len(path) == len(nums):\n            result.append(path[:])\n            return\n        for i in range(len(nums)):\n            if not used[i]:\n                used[i] = True\n                path.append(nums[i])\n                backtrack(nums, path, used, result)\n                used[i] = False\n                path.pop()\n\n    nums = list(range(1, n + 1))\n    result = []\n    backtrack(nums, [], [False] * n, result)\n    return result\n\ndef g(n: int = 3) -> int:\n    \"\"\"\n    Generate the value of n for the function f.\n    \"\"\"\n    return n\n\nassert f(g()) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n",
        "idx_generation": 289,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in ascending order.\n    \n    Example:\n    nums = [2, 5, 7, 11, 15]\n    target = 9\n    \n    Output:\n    [0, 2] (2 + 7 = 9)\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g():\n    nums = [2, 5, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 2]\n\n",
        "idx_generation": 358,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, find the index of the target value in the list using binary search.\n\n    Sample Input:\n    nums = [1, 3, 5, 7, 9]\n    target = 7\n\n    Sample Output:\n    3\n    \"\"\"\n\n    def binary_search(nums: List[int], target: int) -> int:\n        left = 0\n        right = len(nums) - 1\n\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return -1\n\n    return binary_search(nums, target)\n\ndef g(nums: List[int] = [1, 3, 5, 7, 9], target: int = 7) -> int:\n    return nums, target\n\nassert f(*g()) == 3\n",
        "idx_generation": 220,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two numbers in the list that sum up to the target.\n\n    Args:\n    - arr: A sorted list of integers.\n    - target: The target value.\n\n    Returns:\n    - True if there are two numbers in the list that sum up to the target, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    target = 9\n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 387,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there exists a subset of the list\n    such that the sum of the subset is equal to the target value. Return True if such subset exists,\n    otherwise return False.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n\n    Output:\n    True\n\n    Explanation:\n    The subset [2, 3, 4] has a sum of 9, which is equal to the target value.\n    \"\"\"\n\n    def subset_sum(nums: List[int], target: int) -> bool:\n        n = len(nums)\n        dp = [[False] * (target + 1) for _ in range(n + 1)]\n\n        for i in range(n + 1):\n            dp[i][0] = True\n\n        for i in range(1, n + 1):\n            for j in range(1, target + 1):\n                if nums[i - 1] <= j:\n                    dp[i][j] = dp[i - 1][j - nums[i - 1]] or dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n\n        return dp[n][target]\n\n    return subset_sum(nums, target)\n\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n    return nums, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 139,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum path from the top-left cell to the bottom-right cell.\n    Each step can only move down or right.\n\n    Example:\n    Input:\n    grid = [\n      [1, 3, 1],\n      [1, 5, 1],\n      [4, 2, 1]\n    ]\n    Output: 7\n    Explanation: The minimum sum path is 1 -> 3 -> 1 -> 1 -> 1.\n\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[float('inf')] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(rows):\n        for j in range(cols):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j])\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j])\n\n    return dp[rows-1][cols-1]\n\ndef g():\n    \"\"\"\n    Generate a grid of integers.\n    Return the grid.\n\n    Example:\n    grid = [\n      [1, 3, 1],\n      [1, 5, 1],\n      [4, 2, 1]\n    ]\n    \"\"\"\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n\n",
        "idx_generation": 425,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(string: str, substring='abc') -> bool:\n    \"\"\"Check if a substring exists in a string\"\"\"\n    return substring in string\n\ndef g(string = 'abcdefg', substring = 'abc'):\n    return string\n\nassert f(g()) == True\n",
        "idx_generation": 3,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Find the number of set bits (1s) in the binary representation of the given number.\n    \"\"\"\n    count = 0\n    while n > 0:\n        if n & 1:\n            count += 1\n        n >>= 1\n    return count\n\ndef g():\n    return 42\n\nassert f(g()) == 3\n\n",
        "idx_generation": 234,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique paths from the top-left corner to the bottom-right corner of a n x n grid.\n    You can only move either down or right at any point in time.\n\n    Example:\n    Input: 3\n    Output: 6\n\n    Explanation:\n    There are 6 possible paths to reach the bottom-right corner of a 3 x 3 grid.\n\n    Hint: Use dynamic programming to store the number of paths for each subgrid.\n    \"\"\"\n\n    def unique_paths_helper(i, j, n, memo):\n        if i == n - 1 and j == n - 1:\n            return 1\n        if i >= n or j >= n:\n            return 0\n        if memo[i][j] != -1:\n            return memo[i][j]\n        memo[i][j] = unique_paths_helper(i+1, j, n, memo) + unique_paths_helper(i, j+1, n, memo)\n        return memo[i][j]\n\n    memo = [[-1] * n for _ in range(n)]\n    return unique_paths_helper(0, 0, n, memo)\n\ndef g():\n    return 3\n\nassert f(g()) == 6\n",
        "idx_generation": 355,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\ndef f(graph: List[List[int]], start: int, end: int, path_length: int) -> bool:\n    \"\"\"\n    Check if there exists a path in a given graph from start to end with a specified length.\n    The graph is represented as an adjacency matrix.\n    \"\"\"\n    def dfs(node, length):\n        if node == end and length == path_length:\n            return True\n        if length > path_length:\n            return False\n        for i in range(len(graph[node])):\n            if graph[node][i] == 1 and not visited[i]:\n                visited[i] = True\n                if dfs(i, length + 1):\n                    return True\n                visited[i] = False\n        return False\n\n    visited = [False] * len(graph)\n    visited[start] = True\n    return dfs(start, 0)\n\ndef g(graph=[[0, 1, 1, 0, 0],\n             [1, 0, 0, 1, 0],\n             [1, 0, 0, 1, 0],\n             [0, 1, 1, 0, 1],\n             [0, 0, 0, 1, 0]], start=0, end=4, path_length=3):\n    return graph, start, end, path_length\n\nassert f(*g())\n",
        "idx_generation": 217,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(adjacency: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix of a directed graph, determine if there is a cycle in the graph.\n    Return True if there is a cycle, False otherwise.\n\n    Example:\n    Input: adjacency = [[0, 1, 0], [0, 0, 1], [1, 0, 0]]\n    Output: True\n\n    Explanation:\n    The given adjacency matrix represents the following directed graph:\n    0 -> 1 -> 2 -> 0\n    There is a cycle in the graph, so the output is True.\n    \"\"\"\n    stack = []\n    visited = set()\n\n    def dfs(node):\n        if node in visited:\n            return True\n\n        visited.add(node)\n        stack.append(node)\n\n        for neighbor in range(len(adjacency)):\n            if adjacency[node][neighbor] == 1 and dfs(neighbor):\n                return True\n\n        stack.remove(node)\n        return False\n\n    for node in range(len(adjacency)):\n        if node not in visited and dfs(node):\n            return True\n\n    return False\n\ndef g(adjacency = [[0, 1, 0], [0, 0, 1], [1, 0, 0]]):\n    return adjacency\n\nassert f(g())\n",
        "idx_generation": 377,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of different ways to climb a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n    Return the number of ways.\n    \"\"\"\n    if n <= 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 291,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the second smallest element in the list.\n\n    Sample input:\n    nums = [5, 2, 7, 9, 1, 3]\n\n    Sample output:\n    2\n    Explanation: The second smallest element in the list is 2.\n    \"\"\"\n    nums.sort()\n    return nums[1]\n\ndef g():\n    return [5, 2, 7, 9, 1, 3]\n\nassert f(g()) == 2\n",
        "idx_generation": 359,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The subarray with the maximum sum is [4, -1, 2, 1], with a sum of 6.\n\n    Hint: Use Kadane's algorithm to find the maximum sum subarray.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum += num\n        if current_sum > max_sum:\n            max_sum = current_sum\n        if current_sum < 0:\n            current_sum = 0\n\n    return max_sum\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 225,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    The maximum subarray sum is 6, which is obtained from the subarray [4, -1, 2, 1].\n\n    Constraints:\n    - The input list will always contain at least one integer.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef g():\n    \"\"\"\n    Generate a list of integers for testing.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 389,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the maximum sum of a subarray\n    within the list that is less than or equal to the target value.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    Output:\n    7\n\n    Explanation:\n    The maximum sum of a subarray that is less than or equal to 7 is 7, which can be achieved by\n    selecting the entire array [1, 2, 3, 4, 5].\n    \"\"\"\n\n    def max_subarray_sum(nums: List[int], target: int) -> int:\n        n = len(nums)\n        dp = [0] * (target + 1)\n\n        for i in range(n):\n            for j in range(target, nums[i] - 1, -1):\n                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])\n\n        return dp[target]\n\n    return max_subarray_sum(nums, target)\n\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 7\n\n",
        "idx_generation": 139,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the perimeter of the island (group of connected cells with value 1).\n\n    Args:\n    - grid: A 2D grid of integers.\n\n    Returns:\n    - The perimeter of the island.\n\n    Example:\n    Input:\n    grid = [\n        [0, 1, 0, 0],\n        [1, 1, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 0, 0]\n    ]\n\n    Output:\n    16\n\n    Explanation:\n    The island consists of cells with value 1. The perimeter is calculated by counting the number of edges surrounding the island, which is 16 in this case.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    perimeter = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                perimeter += 4\n\n                if i > 0 and grid[i-1][j] == 1:\n                    perimeter -= 2\n\n                if j > 0 and grid[i][j-1] == 1:\n                    perimeter -= 2\n\n    return perimeter\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [\n        [0, 1, 0, 0],\n        [1, 1, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 0, 0]\n    ]\n\nassert f(g()) == 16\n",
        "idx_generation": 436,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(string: str, target: str) -> bool:\n    \"\"\"Check if the target string is a substring of the given string.\"\"\"\n    if target in string:\n        return True\n    else:\n        return False\n\ndef g(string=\"Hello, World!\", target=\"World\"):\n    return string, target\n\nassert f(*g()) == True\n",
        "idx_generation": 5,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Single Number\n\n    Given a non-empty list of integers nums, every element appears twice except for one. Find that single one.\n\n    Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n\n    Example:\n    nums = [4, 1, 2, 1, 2]\n\n    Output:\n    4\n\n    Explanation:\n    The single number in the list is 4.\n    \"\"\"\n\n    result = 0\n\n    for num in nums:\n        result ^= num\n\n    return result\n\ndef g(nums=[4, 1, 2, 1, 2]):\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 240,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it can be expressed as the sum of two squares.\n    \"\"\"\n    for i in range(int(n ** 0.5) + 1):\n        if ((n - i ** 2) ** 0.5).is_integer():\n            return True\n    return False\n\ndef g(n=25):\n    \"\"\"\n    This solution checks if a positive integer n can be expressed as the sum of two squares.\n    \"\"\"\n    for i in range(int(n ** 0.5) + 1):\n        if ((n - i ** 2) ** 0.5).is_integer():\n            return True\n    return False\n\nassert f(g()) == True\n",
        "idx_generation": 3,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number k, find the number of subarrays with a sum divisible by k.\n\n    Example:\n    nums = [4, 5, 0, -2, -3, 1]\n    k = 5\n    Output: 7\n    Explanation: The subarrays with a sum divisible by 5 are: [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0, -2, -3], [5, 0, -2, -3, 1], [-2, -3].\n\n    Hint: Use dynamic programming to keep track of the cumulative sum and the count of remainders when divided by k.\n    \"\"\"\n    count = 0\n    prefix_sum = 0\n    remainders = [0] * k\n    remainders[0] = 1\n\n    for num in nums:\n        prefix_sum += num\n        remainder = prefix_sum % k\n        count += remainders[remainder]\n        remainders[remainder] += 1\n\n    return count\n\ndef g():\n    nums = [4, 5, 0, -2, -3, 1]\n    k = 5\n    return nums, k\n\nassert f(*g()) == 7\n",
        "idx_generation": 356,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, return True if the graph is bipartite, \n    and False otherwise.\n\n    Sample Input:\n    graph = [[0, 1, 0, 1],\n             [1, 0, 1, 0],\n             [0, 1, 0, 1],\n             [1, 0, 1, 0]]\n\n    Sample Output:\n    True\n    \"\"\"\n    def is_bipartite(graph: List[List[int]], node: int, color: List[int]) -> bool:\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1:\n                if color[neighbor] == color[node]:\n                    return False\n                if color[neighbor] == 0:\n                    color[neighbor] = -color[node]\n                    if not is_bipartite(graph, neighbor, color):\n                        return False\n        return True\n\n    n = len(graph)\n    color = [0] * n\n\n    for node in range(n):\n        if color[node] == 0:\n            color[node] = 1\n            if not is_bipartite(graph, node, color):\n                return False\n\n    return True\n\ndef g() -> List[List[int]]:\n    graph = [[0, 1, 0, 1],\n             [1, 0, 1, 0],\n             [0, 1, 0, 1],\n             [1, 0, 1, 0]]\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 224,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(adj_list: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given an adjacency list representing a directed graph, determine if there is a path from a start node to an end node.\n\n    Example:\n    adj_list = [[1, 2], [2], [3], [0, 4], [2]]\n\n    start = 0\n    end = 3\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 0 to node 3: 0 -> 2 -> 3.\n    \"\"\"\n    visited = set()\n    return dfs(adj_list, start, end, visited)\n\ndef dfs(adj_list: List[List[int]], curr: int, end: int, visited: set) -> bool:\n    if curr == end:\n        return True\n    \n    visited.add(curr)\n    \n    for neighbor in adj_list[curr]:\n        if neighbor not in visited:\n            if dfs(adj_list, neighbor, end, visited):\n                return True\n    \n    return False\n\ndef g() -> Tuple[List[List[int]], int, int]:\n    adj_list = [[1, 2], [2], [3], [0, 4], [2]]\n    start = 0\n    end = 3\n    \n    return adj_list, start, end\n\nassert f(*g()) == True\n\n",
        "idx_generation": 385,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the number of unique paths from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    Input:\n    grid = [[0, 0, 0],\n            [0, 0, 0],\n            [0, 0, 0]]\n\n    Output:\n    6\n\n    Explanation:\n    There are 6 unique paths from the top-left to the bottom-right cell:\n    D -> D -> R -> R\n    D -> R -> D -> R\n    D -> R -> R -> D\n    R -> D -> D -> R\n    R -> D -> R -> D\n    R -> R -> D -> D\n    \"\"\"\n\n    def countPaths(grid: List[List[int]], row: int, col: int, memo: List[List[int]]) -> int:\n        if row == len(grid) - 1 and col == len(grid[0]) - 1:\n            return 1\n\n        if memo[row][col] != -1:\n            return memo[row][col]\n\n        paths = 0\n\n        if row + 1 < len(grid):\n            paths += countPaths(grid, row + 1, col, memo)\n\n        if col + 1 < len(grid[0]):\n            paths += countPaths(grid, row, col + 1, memo)\n\n        memo[row][col] = paths\n\n        return paths\n\n    memo = [[-1] * len(grid[0]) for _ in range(len(grid))]\n    return countPaths(grid, 0, 0, memo)\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of non-negative integers.\n    \"\"\"\n    return [[0, 0, 0],\n            [0, 0, 0],\n            [0, 0, 0]]\n\nassert f(g()) == 6\n",
        "idx_generation": 292,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find two numbers that add up to a target value.\n    Return the indices of the two numbers in the original list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1 (2 and 7) add up to the target value of 9.\n\n    Hint: Use a two-pointer approach to iterate through the list and find the two numbers that add up to the target value.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g(nums: List[int] = [2, 7, 11, 15], target: int = 9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 361,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there are two numbers that add up to a given target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    Output:\n    True\n\n    Explanation:\n    The numbers 2 and 5 add up to the target 7.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g() -> (List[int], int):\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 227,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a perfect square.\n\n    Return True if n is a perfect square, False otherwise.\n\n    Example:\n    n = 16\n\n    Output:\n    True\n\n    Explanation:\n    16 is a perfect square since 4^2 = 16.\n\n    Hint: Use the square root function and check if the result is an integer.\n    \"\"\"\n    import math\n    \n    root = math.sqrt(n)\n    return root.is_integer()\n\ndef g(n: int = 16) -> int:\n    \"\"\"\n    Generate an integer that is a perfect square.\n    \"\"\"\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 389,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the number of ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time. Additionally, you can take a maximum of k consecutive steps at a time.\n\n    Example:\n    n = 5\n    k = 2\n\n    Output:\n    8 (since there are 8 ways to climb the staircase: [1, 1, 1, 1, 1], [1, 1, 1, 2], [1, 1, 2, 1], [1, 2, 1, 1], [2, 1, 1, 1], [1, 2, 2], [2, 1, 2], [2, 2, 1])\n    \"\"\"\n\n    def dp(i: int, dp_table: List[int]) -> int:\n        if i == 0:\n            return 1\n        if dp_table[i] != -1:\n            return dp_table[i]\n        total = 0\n        for j in range(1, min(k+1, i+1)):\n            total += dp(i-j, dp_table)\n        dp_table[i] = total\n        return total\n\n    dp_table = [-1] * (n+1)\n    return dp(n, dp_table)\n\ndef g():\n    return 5, 2\n\nassert f(*g()) == 8\n\n",
        "idx_generation": 140,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 0 represents an empty cell and 1 represents a wall,\n    determine the minimum number of steps required to reach the bottom-right cell from the top-left cell.\n    You can only move down, right, or diagonally right-down from a cell.\n\n    Example:\n    Input:\n    grid = [\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 1, 0, 0],\n        [0, 0, 0, 0]\n    ]\n\n    Output:\n    4\n    Explanation:\n    The minimum number of steps required to reach the bottom-right cell from the top-left cell is 4.\n    The path is: (0, 0) -> (0, 1) -> (1, 2) -> (2, 3) -> (3, 3).\n    \"\"\"\n\n    m, n = len(grid), len(grid[0])\n\n    dp = [[float('inf')] * (n + 1) for _ in range(m + 1)]\n    dp[m][n-1] = dp[m-1][n] = 0\n\n    for i in range(m-1, -1, -1):\n        for j in range(n-1, -1, -1):\n            if grid[i][j] == 0:\n                dp[i][j] = min(dp[i+1][j], dp[i][j+1], dp[i+1][j+1]) + 1\n\n    return dp[0][0]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 1, 0, 0],\n        [0, 0, 0, 0]\n    ]\n    return (grid,)\n\nassert f(*g()) == 4\n\n",
        "idx_generation": 437,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Determine if a given string is a palindrome.\n    \"\"\"\n    return s == s[::-1]\n\ndef g():\n    \"\"\"\n    Generate a palindrome string of length 10.\n    \"\"\"\n    return \"abcdedcba\"\n\nassert f(g()) == True\n",
        "idx_generation": 11,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Check if the k-th bit of n is set to 1.\"\"\"\n    return (n >> (k - 1)) & 1 == 1\ndef g():\n    n = 14\n    k = 3\n    return n, k\nassert f(*g())\n",
        "idx_generation": 247,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(num: int) -> bool:\n    \"\"\"\n    Given a positive integer, determine if it is a power of two.\n    Return True if the number is a power of two, otherwise return False.\n    \"\"\"\n    return num & (num - 1) == 0\n\ndef g(num = 16):\n    return num\n\nassert f(g()) == True\n",
        "idx_generation": 6,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n    \"\"\"\n    def fibonacci(n, memo={}):\n        if n in memo:\n            return memo[n]\n        if n <= 2:\n            return 1\n        memo[n] = fibonacci(n - 1) + fibonacci(n - 2)\n        return memo[n]\n\n    return fibonacci(n)\n\ndef g(n: int = 6):\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 358,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"\n    Given a directed graph represented as a dictionary where the keys are nodes and the values are lists of neighboring nodes, determine if there is a path from the start node to the end node.\n    \"\"\"\n    def dfs(graph, node, visited):\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(graph, neighbor, visited):\n                    return True\n        return False\n    \n    visited = set()\n    return dfs(graph, start, visited)\n\ndef g(graph: Dict[str, List[str]] = {\"A\": [\"B\", \"C\"], \"B\": [\"C\"], \"C\": [\"D\"], \"D\": []}, start=\"A\", end=\"D\"):\n    return graph, start, end\n\nassert f(*g()) == True\n\n",
        "idx_generation": 225,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef f(root: Node, target: int) -> bool:\n    \"\"\"\n    Given the root of a binary tree and a target value,\n    determine if there exists a root-to-leaf path in the tree\n    such that the sum of the values along the path equals the target value.\n\n    Returns True if such a path exists, False otherwise.\n    \"\"\"\n    if root is None:\n        return False\n\n    stack = [(root, root.value)]\n    while stack:\n        node, curr_sum = stack.pop()\n        if node.left is None and node.right is None:\n            if curr_sum == target:\n                return True\n        if node.left:\n            stack.append((node.left, curr_sum + node.left.value))\n        if node.right:\n            stack.append((node.right, curr_sum + node.right.value))\n\n    return False\n\ndef g() -> Node:\n    \"\"\"\n    Generate a binary tree.\n    \"\"\"\n    root = Node(5)\n    root.left = Node(4)\n    root.right = Node(8)\n    root.left.left = Node(11)\n    root.left.left.left = Node(7)\n    root.left.left.right = Node(2)\n    root.right.left = Node(13)\n    root.right.right = Node(4)\n    root.right.right.right = Node(1)\n    return root\n\ntarget = 22\nassert f(g(), target) == True\n\n",
        "idx_generation": 401,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[str]:\n    \"\"\"\n    Given a positive integer n, return all distinct valid combinations of pairs of parentheses with n pairs.\n\n    Example:\n    Input: 3\n    Output: [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\n\n    Explanation: The combinations of parentheses with 3 pairs are:\n    1. \"((()))\"\n    2. \"(()())\"\n    3. \"(())()\"\n    4. \"()(())\"\n    5. \"()()()\"\n    \"\"\"\n    def generate_parentheses(n: int) -> List[str]:\n        result = []\n\n        def backtrack(s, left, right):\n            if len(s) == 2 * n:\n                result.append(s)\n                return\n            if left < n:\n                backtrack(s + '(', left + 1, right)\n            if right < left:\n                backtrack(s + ')', left, right + 1)\n\n        backtrack('', 0, 0)\n        return result\n\n    return generate_parentheses(n)\n\ndef g(n=3):\n    return n\n\nassert f(g()) == [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\n\n",
        "idx_generation": 293,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if the list is sorted in non-decreasing order.\n    \"\"\"\n    return arr == sorted(arr)\n\ndef g() -> List[int]:\n    arr = [1, 2, 3, 4, 5]\n    return arr\n\nassert f(g()) == True\n",
        "idx_generation": 361,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The maximum subarray sum is 6, which is achieved by the subarray [4, -1, 2, 1].\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 227,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums):\n    \"\"\"\n    Given a list of integers, return the maximum element in the list.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The maximum element in the list.\n    \"\"\"\n    return max(nums)\n\ndef g():\n    nums = [5, 2, 9, 1, 7]\n    return nums\n\nassert f(g()) == 9\n",
        "idx_generation": 390,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(l: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Given a list of integers 'l', a target value 'target', and an integer 'k',\n    determine if there exists a sublist of 'l' with length 'k' whose sum is equal to 'target'.\n\n    Sample Input:\n    l = [1, 2, 3, 4, 5]\n    target = 9\n    k = 3\n\n    Sample Output:\n    True\n    \"\"\"\n    def dfs(sublist: List[int], index: int, curr_sum: int) -> bool:\n        if len(sublist) == k:\n            return curr_sum == target\n\n        if index >= len(l):\n            return False\n\n        # Include the current element in the sublist\n        if dfs(sublist + [l[index]], index + 1, curr_sum + l[index]):\n            return True\n\n        # Exclude the current element from the sublist\n        if dfs(sublist, index + 1, curr_sum):\n            return True\n\n        return False\n\n    return dfs([], 0, 0)\n\ndef g() -> Tuple[List[int], int, int]:\n    l = [1, 2, 3, 4, 5]\n    target = 9\n    k = 3\n    return l, target, k\n\nassert f(*g()) == True\n",
        "idx_generation": 141,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the length of the longest increasing path.\n\n    An increasing path is defined as a path in which the value of each cell is greater than the value of its adjacent cells.\n\n    Return the length of the longest increasing path.\n\n    Example:\n    grid = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n\n    Output:\n    4\n\n    Explanation:\n    The longest increasing path is [1, 2, 6, 9].\n    \"\"\"\n\n    def dfs(i: int, j: int, grid: List[List[int]], memo: List[List[int]]) -> int:\n        if memo[i][j] != 0:\n            return memo[i][j]\n\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        max_path = 1\n\n        for dx, dy in directions:\n            x, y = i + dx, j + dy\n            if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] <= grid[i][j]:\n                continue\n            max_path = max(max_path, 1 + dfs(x, y, grid, memo))\n\n        memo[i][j] = max_path\n        return max_path\n\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    memo = [[0] * n for _ in range(m)]\n    max_path = 0\n\n    for i in range(m):\n        for j in range(n):\n            max_path = max(max_path, dfs(i, j, grid, memo))\n\n    return max_path\n\ndef g():\n    return [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n\nassert f(g()) == 4\n\n",
        "idx_generation": 448,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(x: str, s=\"hello world\") -> bool:\n    \"\"\"Check if a given string is a palindrome and contains a specific substring.\"\"\"\n    return x == s[::-1] and \"world\" in s\ndef g(s=\"hello world\"):\n    return s[::-1]\nassert f(g()) == True\n",
        "idx_generation": 14,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an integer array nums, every element appears three times except for one, which appears exactly once. Find that single\n    one.\n\n    Note:\n    - Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n    \"\"\"\n    ones = 0\n    twos = 0\n    for num in nums:\n        ones = (ones ^ num) & ~twos\n        twos = (twos ^ num) & ~ones\n    return ones\n\ndef g():\n    return [2, 2, 3, 2]\n\nassert f(g()) == 3\n\n",
        "idx_generation": 249,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, calculate the nth Fibonacci number.\n    Return True if the nth Fibonacci number is even, otherwise return False.\n    \"\"\"\n    fib = [0, 1]\n    for i in range(2, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2])\n    return fib[n] % 2 == 0\n\ndef g(n = 6):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 6,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"\n    Given an integer num, return the number of steps to reduce it to zero.\n    If the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it.\n    Repeat the process until the number is zero.\n\n    Example:\n    num = 14\n    Output: 6\n\n    Explanation:\n    Step 1: 14 is even, divide by 2 to get 7.\n    Step 2: 7 is odd, subtract 1 to get 6.\n    Step 3: 6 is even, divide by 2 to get 3.\n    Step 4: 3 is odd, subtract 1 to get 2.\n    Step 5: 2 is even, divide by 2 to get 1.\n    Step 6: 1 is odd, subtract 1 to get 0.\n\n    \"\"\"\n\n    steps = 0\n\n    while num != 0:\n        if num % 2 == 0:\n            num //= 2\n        else:\n            num -= 1\n        steps += 1\n\n    return steps\n\ndef g() -> int:\n    num = 14\n    return num\n\nassert f(g()) == 6\n",
        "idx_generation": 363,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums, check if there is a cycle in the graph formed by the elements of the list.\n\n    Return True if there is a cycle, False otherwise.\n\n    Example:\n    nums = [2, 3, 1, 4, 0]\n\n    Output:\n    True\n\n    Explanation:\n    The graph formed by the elements of the list is:\n    2 -> 1 -> 3 -> 4 -> 0 -> 2\n    There is a cycle in the graph.\n    \"\"\"\n\n    def has_cycle(nums):\n        visited = [False] * len(nums)\n        stack = []\n\n        for i in range(len(nums)):\n            if visited[i]:\n                continue\n\n            stack.append(i)\n\n            while stack:\n                current = stack.pop()\n                visited[current] = True\n\n                next_vertex = nums[current]\n                if next_vertex == i:\n                    return True\n\n                stack.append(next_vertex)\n\n        return False\n\n    return has_cycle(nums)\n\ndef g():\n    \"\"\"\n    Generate a list of integers with a cycle in the graph formed by the elements.\n    \"\"\"\n    return [2, 3, 1, 4, 0]\n\nassert f(g()) == True\n",
        "idx_generation": 228,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representation of a directed graph, determine if the graph contains a cycle.\n\n    Example:\n    Input:\n    graph = [[0, 1, 0],\n             [0, 0, 1],\n             [1, 0, 0]]\n\n    Output:\n    True\n    \"\"\"\n\n    def hasCycle(graph: List[List[int]], visited: List[bool], current: int) -> bool:\n        if visited[current]:\n            return True\n\n        visited[current] = True\n        for neighbor in range(len(graph)):\n            if graph[current][neighbor] == 1 and hasCycle(graph, visited, neighbor):\n                return True\n\n        visited[current] = False\n        return False\n\n    visited = [False] * len(graph)\n    for node in range(len(graph)):\n        if hasCycle(graph, visited, node):\n            return True\n\n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate an adjacency matrix representation of a directed graph.\n    \"\"\"\n    graph = [[0, 1, 0],\n             [0, 0, 1],\n             [1, 0, 0]]\n    return graph\n\nassert f(g()) == True\n\n",
        "idx_generation": 403,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, return all possible permutations of the numbers.\n\n    Example:\n    nums = [1, 2, 3]\n\n    Output:\n    [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n    Hint: Use backtracking to generate all possible permutations.\n    \"\"\"\n    def backtrack(nums: List[int], perm: List[int], result: List[List[int]]) -> None:\n        if len(perm) == len(nums):\n            result.append(perm[:])\n            return\n        \n        for num in nums:\n            if num in perm:\n                continue\n            perm.append(num)\n            backtrack(nums, perm, result)\n            perm.pop()\n\n    result = []\n    backtrack(nums, [], result)\n    return result\n\n\ndef g(nums=[1, 2, 3]):\n    return (nums,)\n\n\nassert f(*g()) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n",
        "idx_generation": 308,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array nums, return the two numbers such that they add up to the target.\n\n    You may assume that each input would have exactly one solution and you may not use the same element twice.\n\n    Example:\n    nums = [2, 7, 11, 15], target = 9\n\n    Output:\n    [2, 7]\n\n    Explanation:\n    The sum of 2 and 7 is 9.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [nums[left], nums[right]]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted array and a target sum.\n    \"\"\"\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [2, 7]\n\n",
        "idx_generation": 362,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers and a target value, find the index of the target value in the array. If the target value is not found, return -1.\n\n    Example:\n    nums = [2, 4, 6, 8, 10], target = 6\n\n    Output:\n    2\n\n    Explanation:\n    The target value 6 is found at index 2 in the array.\n\n    Hint: Use binary search to find the index of the target value in the sorted array.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    return ([2, 4, 6, 8, 10], 6)\n\nassert f(*g()) == 2\n",
        "idx_generation": 230,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid):\n    \"\"\"\n    Given a 2D grid of characters, determine if it is a valid sudoku board.\n\n    Args:\n    - grid: A 2D list representing the sudoku board.\n\n    Returns:\n    - True if the board is valid, False otherwise.\n    \"\"\"\n    def is_valid_row(row):\n        count = [0] * 9\n        for num in row:\n            if num != \".\":\n                count[int(num) - 1] += 1\n                if count[int(num) - 1] > 1:\n                    return False\n        return True\n\n    def is_valid_col(col):\n        count = [0] * 9\n        for i in range(9):\n            num = grid[i][col]\n            if num != \".\":\n                count[int(num) - 1] += 1\n                if count[int(num) - 1] > 1:\n                    return False\n        return True\n\n    def is_valid_box(row, col):\n        count = [0] * 9\n        for i in range(row, row + 3):\n            for j in range(col, col + 3):\n                num = grid[i][j]\n                if num != \".\":\n                    count[int(num) - 1] += 1\n                    if count[int(num) - 1] > 1:\n                        return False\n        return True\n\n    for i in range(9):\n        if not is_valid_row(grid[i]):\n            return False\n        if not is_valid_col(i):\n            return False\n\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            if not is_valid_box(i, j):\n                return False\n\n    return True\n\ndef g():\n    grid = [\n        [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n        [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n        [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n        [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n        [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n        [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n        [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n        [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n        [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"],\n    ]\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 390,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find the nth Fibonacci number using dynamic programming\"\"\"\n    def fibonacci(n, memo):\n        if n in memo:\n            return memo[n]\n        if n <= 2:\n            return 1\n        memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo)\n        return memo[n]\n    \n    memo = {}\n    return fibonacci(n, memo)\n\ndef g():\n    n = 6\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 145,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the path from the top-left corner to the bottom-right corner that minimizes the sum of all numbers along its path. You can only move down or right.\n\n    Args:\n    - grid: A grid of non-negative integers.\n\n    Returns:\n    - The minimum sum of all numbers along the path from the top-left corner to the bottom-right corner.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum sum path is 1 -> 3 -> 1 -> 1 -> 1, which has a sum of 7.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 466,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome. Ignore non-alphanumeric characters and case sensitivity.\n    \"\"\"\n    s = ''.join(c.lower() for c in s if c.isalnum())\n    return s == s[::-1]\ndef g(s = ''):\n    return s\nassert f(g()) == True\n",
        "idx_generation": 15,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"\n    Given an integer num, count the number of set bits in its binary representation.\n\n    Example:\n    f(5) -> 2\n\n    Return the count of set bits.\n    \"\"\"\n    count = 0\n    while num:\n        count += num & 1\n        num >>= 1\n    return count\n\ndef g():\n    return 5\n\nassert f(g()) == 2\n\n",
        "idx_generation": 249,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "import random\nfrom typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a number is a prime number.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g(n: int) -> int:\n    \"\"\"Find the nth prime number.\"\"\"\n    count = 0\n    num = 2\n    while count < n:\n        if f(num):\n            count += 1\n        num += 1\n    return num - 1\n\nn = random.randint(1, 100)\nassert f(g(n))\n",
        "idx_generation": 17,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n\n    Sample Input:\n    n = 6\n\n    Sample Output:\n    8\n\n    Explanation:\n    The 6th Fibonacci number is 8.\n    The Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, ...\n    \"\"\"\n\n    if n <= 1:\n        return n\n\n    fib = [0, 1]\n    for i in range(2, n+1):\n        fib.append(fib[i-1] + fib[i-2])\n\n    return fib[n]\n\ndef g(n=6):\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 374,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representation of a directed graph, determine if the graph contains a cycle.\n\n    Sample Input:\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [1, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n\n    Sample Output:\n    True\n    \"\"\"\n    def dfs(node, visited, rec_stack):\n        visited[node] = True\n        rec_stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, rec_stack):\n                    return True\n            elif rec_stack[neighbor]:\n                return True\n\n        rec_stack[node] = False\n        return False\n\n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n    rec_stack = [False] * num_nodes\n\n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(node, visited, rec_stack):\n                return True\n\n    return False\n\ndef g(graph=[[0, 1, 0, 0], [0, 0, 1, 0], [1, 0, 0, 1], [0, 0, 0, 0]]):\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 232,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(graph: Dict[int, List[int]]) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency list, determine if it contains a cycle using DFS.\n\n    Args:\n    - graph: A dictionary representing the graph, where the keys are the nodes and the values are the adjacent nodes.\n\n    Returns:\n    - A boolean value indicating whether the graph contains a cycle.\n    \"\"\"\n    def dfs(node, visited, stack):\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, stack):\n                    return True\n            elif stack[neighbor]:\n                return True\n\n        stack[node] = False\n        return False\n\n    visited = {node: False for node in graph}\n    stack = {node: False for node in graph}\n\n    for node in graph:\n        if not visited[node]:\n            if dfs(node, visited, stack):\n                return True\n\n    return False\n\ndef g():\n    graph = {\n        1: [2, 3],\n        2: [3, 4],\n        3: [4],\n        4: [1]\n    }\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 412,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome after removing a single character.\n    \"\"\"\n    def is_palindrome(s, left, right):\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n    \n    left = 0\n    right = len(s) - 1\n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s, left + 1, right) or is_palindrome(s, left, right - 1)\n        left += 1\n        right -= 1\n    return True\n\ndef g(s=\"level\"):\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 312,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted (in ascending order) integer array nums of n elements and a target value,\n    write a function to search target in nums. If target exists, then return its index, otherwise return -1.\n\n    Example:\n    nums = [-1,0,3,5,9,12], target = 9\n    Output: 4\n\n    Explanation:\n    9 is found at index 4 in the array.\n\n    nums = [-1,0,3,5,9,12], target = 2\n    Output: -1\n\n    Explanation:\n    2 is not found in the array.\n\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> (List[int], int):\n    nums = [-1, 0, 3, 5, 9, 12]\n    target = 9\n    return nums, target\n\nassert f(*g()) == 4\n",
        "idx_generation": 363,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of distinct integers and a target value, return the index if the target is found.\n    If not, return the index where it would be if it were inserted in order.\n\n    Example:\n    nums = [1, 3, 5, 6]\n    target = 5\n    Output: 2\n\n    nums = [1, 3, 5, 6]\n    target = 2\n    Output: 1\n\n    Hint: Use binary search to find the target or the position where it should be inserted.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left\n\ndef g(nums: List[int], target: int):\n    return nums, target\n\nassert f(*g([1, 3, 5, 6], 5)) == 2\n",
        "idx_generation": 232,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr):\n    \"\"\"\n    Given an array of integers, find the longest subarray with equal number of 0s and 1s.\n\n    Args:\n    - arr: A list of integers.\n\n    Returns:\n    - The length of the longest subarray with equal number of 0s and 1s.\n    \"\"\"\n    count = 0\n    max_len = 0\n    count_dict = {0: -1}  # Initialize count_dict with count 0 at index -1\n    for i in range(len(arr)):\n        count += 1 if arr[i] == 1 else -1\n        if count in count_dict:\n            max_len = max(max_len, i - count_dict[count])\n        else:\n            count_dict[count] = i\n    return max_len\n\ndef g():\n    arr = [0, 1, 1, 0, 1, 0, 0]\n    return arr\n\nassert f(g()) == 6\n",
        "idx_generation": 390,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target sum, find if there exists a subset of the list that adds up to the target sum.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    Output:\n    True\n\n    Explanation:\n    The subset [3, 4] adds up to the target sum of 7.\n    \"\"\"\n\n    def subset_sum(arr, target, index, curr_sum):\n        if curr_sum == target:\n            return True\n\n        if index >= len(arr):\n            return False\n\n        # Include the current element in the subset\n        if subset_sum(arr, target, index + 1, curr_sum + arr[index]):\n            return True\n\n        # Exclude the current element from the subset\n        if subset_sum(arr, target, index + 1, curr_sum):\n            return True\n\n        return False\n\n    return subset_sum(nums, target, 0, 0)\n\ndef g():\n    return [1, 2, 3, 4, 5], 7\n\nassert f(*g()) == True\n\n",
        "idx_generation": 146,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the length of the shortest path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The shortest path is: \n    1 -> 3 -> 1 -> 1 -> 2 -> 1 -> 1\n\n    Hint: Use dynamic programming to calculate the shortest path length.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(m):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j])\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j])\n\n    return dp[m-1][n-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return [grid]\n\nassert f(*g()) == 7\n",
        "idx_generation": 490,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a given string is a palindrome.\"\"\"\n    return s == s[::-1]\n\ndef g() -> str:\n    return \"level\"\n\nassert f(g()) == True\n",
        "idx_generation": 18,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of set bits (bits with a value of 1) in the binary representation of n.\n\n    Example:\n    n = 9\n\n    The binary representation of 9 is 1001, so the output should be 2.\n    \"\"\"\n\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n\n    return count\n\ndef g(n=9):\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    return n\n\nassert f(g()) == 2\n",
        "idx_generation": 252,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the list contains a number that is a perfect square.\"\"\"\n    for num in arr:\n        if num > 0 and int(num**0.5)**2 == num:\n            return True\n    return False\n\ndef g(arr: List[int] = [1, 4, 7, 9, 16, 18, 25]):\n    return arr\n\nassert f(g()) == True\n",
        "idx_generation": 20,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> float:\n    \"\"\"\n    Harmonic Series\n\n    The harmonic series is the sum of the reciprocals of the positive integers.\n    The n-th harmonic number can be represented by the formula: Hn = 1/1 + 1/2 + 1/3 + ... + 1/n.\n\n    Given an integer n, calculate the n-th harmonic number.\n\n    Example:\n    n = 5\n    output: 2.283333333333333\n    \"\"\"\n    def harmonic(n: int) -> float:\n        if n == 1:\n            return 1\n        return 1/n + harmonic(n-1)\n\n    return harmonic(n)\n\ndef g(n = 5):\n    return n\n\nassert f(g()) == 2.283333333333333\n",
        "idx_generation": 380,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef f(root: Node) -> int:\n    \"\"\"Calculate the sum of all the values in a binary tree.\"\"\"\n    if not root:\n        return 0\n    return root.value + f(root.left) + f(root.right)\n\ndef g():\n    root = Node(4)\n    root.left = Node(2)\n    root.right = Node(6)\n    root.left.left = Node(1)\n    root.left.right = Node(3)\n    root.right.left = Node(5)\n    root.right.right = Node(7)\n    return root\n\nassert f(g()) == 28\n\n",
        "idx_generation": 238,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix and two nodes, start and end,\n    determine if there is a path from start to end in the graph.\n\n    Example:\n    graph = [\n        [0, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    start = 0\n    end = 4\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 0 to node 4 in the graph.\n\n    Hint: Use depth-first search or breadth-first search to traverse the graph and find a path from start to end.\n    \"\"\"\n\n    def dfs(node: int, visited: List[bool]) -> bool:\n        if node == end:\n            return True\n\n        visited[node] = True\n\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                if dfs(neighbor, visited):\n                    return True\n\n        return False\n\n    visited = [False] * len(graph)\n    return dfs(start, visited)\n\n\ndef g():\n    \"\"\"\n    Generate a directed graph represented as an adjacency matrix and two nodes, start and end.\n    \"\"\"\n    graph = [\n        [0, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    start = 0\n    end = 4\n    return graph, start, end\n\n\nassert f(*g())\n",
        "idx_generation": 458,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> str:\n    \"\"\"\n    Given a string, return the longest palindromic substring.\n\n    Example:\n    f(\"babad\") -> \"bab\" or \"aba\"\n\n    Explanation:\n    The longest palindromic substring in \"babad\" is \"bab\" or \"aba\".\n\n    Hint: Use dynamic programming to solve this problem.\n    \"\"\"\n    if len(string) <= 1:\n        return string\n\n    longest = \"\"\n    for i in range(len(string)):\n        # Check for odd-length palindromes\n        left, right = i, i\n        while left >= 0 and right < len(string) and string[left] == string[right]:\n            left -= 1\n            right += 1\n        if right - left - 1 > len(longest):\n            longest = string[left+1:right]\n\n        # Check for even-length palindromes\n        left, right = i, i + 1\n        while left >= 0 and right < len(string) and string[left] == string[right]:\n            left -= 1\n            right += 1\n        if right - left - 1 > len(longest):\n            longest = string[left+1:right]\n\n    return longest\n\ndef g():\n    string = \"babad\"\n    return string\n\nassert f(g()) == \"bab\"\n",
        "idx_generation": 318,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if the target value is present in the list using binary search algorithm.\n    \"\"\"\n    low = 0\n    high = len(nums) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False\n\ndef g() -> List[int]:\n    return [1, 3, 5, 7, 9, 11, 13, 15]\n\nassert f(g(), 9) == True\n",
        "idx_generation": 364,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of distinct integers and a target value, find the index of the target using binary search.\n    If the target is not found, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(nums: List[int] = [1, 3, 5, 7, 9], target: int = 5):\n    \"\"\"\n    Generate a sorted array of distinct integers and a target value.\n    \"\"\"\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 233,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if it is a magic square.\n\n    A magic square is a square matrix of size n x n, where each row, column, and diagonal have the same sum.\n\n    Example:\n    matrix = [\n        [2, 7, 6],\n        [9, 5, 1],\n        [4, 3, 8]\n    ]\n\n    Output:\n    True\n\n    Explanation:\n    The matrix forms a magic square, where each row, column, and diagonal sums up to 15.\n    \"\"\"\n\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = sum(matrix[i][col] for i in range(n))\n        if col_sum != target_sum:\n            return False\n\n    # Check diagonals\n    diagonal_sum = sum(matrix[i][i] for i in range(n))\n    anti_diagonal_sum = sum(matrix[i][n-i-1] for i in range(n))\n    if diagonal_sum != target_sum or anti_diagonal_sum != target_sum:\n        return False\n\n    return True\n\ndef g(matrix=[[2, 7, 6], [9, 5, 1], [4, 3, 8]]):\n    return matrix\n\nassert f(g()) == True\n\n",
        "idx_generation": 391,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of valid parentheses expressions of length 2*n.\n\n    A valid parentheses expression consists of \"(\" and \")\" characters and is balanced if:\n    1. It is empty\n    2. It can be written as AB, where A and B are valid parentheses expressions\n    3. It can be written as (A), where A is a valid parentheses expression\n\n    Example:\n    n = 3\n\n    Output:\n    5\n\n    Explanation:\n    The valid parentheses expressions of length 6 are:\n    \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"\n\n    Hint: Use dynamic programming to count the number of valid parentheses expressions.\n    \"\"\"\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i - j - 1]\n\n    return dp[n]\n\ndef g(n=3):\n    return n\n\nassert f(g()) == 5\n\n",
        "idx_generation": 147,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid, find the minimum number of steps required to move from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    The minimum number of steps required is 7. So the output should be 7.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[rows - 1][cols - 1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 498,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the string is a palindrome.\"\"\"\n    return s == s[::-1]\n\ndef g():\n    return \"level\"\n\nassert f(g()) == True\n",
        "idx_generation": 20,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a power of two.\n\n    Example:\n    n = 16\n\n    Output:\n    True\n\n    Explanation:\n    16 is a power of two.\n\n    Hint: Use bitwise operations to check if a number is a power of two. A power of two has only one bit set to 1.\n    \"\"\"\n    if n <= 0:\n        return False\n\n    return n & (n - 1) == 0\n\ndef g(n=64):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 260,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if it is a magic square.\n    A magic square is a square matrix where the sum of each row, column, and diagonal is the same.\n\n    Example:\n    [[4, 9, 2],\n     [3, 5, 7],\n     [8, 1, 6]]\n    is a magic square because the sum of each row, column, and diagonal is 15.\n\n    Returns True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = 0\n        for row in matrix:\n            col_sum += row[col]\n        if col_sum != target_sum:\n            return False\n\n    # Check diagonals\n    diagonal_sum = 0\n    anti_diagonal_sum = 0\n    for i in range(n):\n        diagonal_sum += matrix[i][i]\n        anti_diagonal_sum += matrix[i][n - i - 1]\n    if diagonal_sum != target_sum or anti_diagonal_sum != target_sum:\n        return False\n\n    return True\n\ndef g():\n    \"\"\"\n    Generate a 3x3 magic square.\n    \"\"\"\n    return [[8, 1, 6],\n            [3, 5, 7],\n            [4, 9, 2]]\n\nassert f(g()) == True\n",
        "idx_generation": 21,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the number of ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n    \n    Example:\n    n = 3\n    \n    Output:\n    3\n    \n    Explanation:\n    There are 3 ways to climb to the top of a staircase with 3 steps: [1, 1, 1], [1, 2], [2, 1].\n    \"\"\"\n    if n <= 2:\n        return n\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    \n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    \n    return dp[n]\n\ndef g():\n    n = 3\n    return n\n\nassert f(g()) == 3\n",
        "idx_generation": 380,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency list, determine if it contains a cycle.\n    \"\"\"\n    def dfs(node, visited, parent):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited, node):\n                    return True\n            elif parent != neighbor:\n                return True\n        return False\n\n    visited = set()\n    for node in range(len(graph)):\n        if node not in visited:\n            if dfs(node, visited, -1):\n                return True\n\n    return False\n\ndef g(graph: List[List[int]]):\n    \"\"\"\n    Generate an adjacency list graph with a cycle.\n    \"\"\"\n    graph.append([len(graph)-1])\n    return graph\n\ngraph = [\n    [1, 2],\n    [0],\n    [0]\n]\n\nassert f(g(graph))\n",
        "idx_generation": 240,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there is a path between two nodes in a directed graph using Depth-First Search.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g():\n    graph = [[1, 2], [2, 3], [3], []]\n    start = 0\n    end = 3\n    return graph, start, end\n\nassert f(*g())\n",
        "idx_generation": 460,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums and a target integer n, find the number of different combinations\n    of numbers in nums that add up to n.\n\n    Example:\n    Input: n = 4, nums = [1, 2, 3]\n    Output: 4\n\n    Explanation: The different combinations of numbers in nums that add up to 4 are:\n    1. [1, 1, 1, 1]\n    2. [1, 1, 2]\n    3. [1, 3]\n    4. [2, 2]\n    \"\"\"\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for num in nums:\n        for i in range(num, n + 1):\n            dp[i] += dp[i - num]\n\n    return dp[n]\n\ndef g() -> (int, List[int]):\n    return 4, [1, 2, 3]\n\nassert f(*g()) == 4\n",
        "idx_generation": 318,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [-10, -10, 1, 3, 2]\n\n    Output:\n    300\n\n    Explanation:\n    The maximum product of any three numbers (-10, -10, 3) in the list is 300.\n\n    Hint: Sort the list and consider the cases where the largest and smallest numbers are negative.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3])\n\ndef g(nums=[-10, -10, 1, 3, 2]):\n    return nums\n\nassert f(g()) == 300\n\n",
        "idx_generation": 365,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence (LIS).\n    An increasing subsequence is a sequence of numbers in an array such that the elements\n    are sorted in increasing order (not necessarily contiguous) and the subsequences are\n    strictly increasing.\n\n    Example:\n    Input: nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n\n    Explanation:\n    The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n    \"\"\"\n    if not nums:\n        return 0\n\n    lis = [1] * len(nums)\n\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    return max(lis)\n\ndef g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 239,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of itself and all previous elements in the list.\n    \"\"\"\n    prefix_sum = [0] * len(nums)\n    prefix_sum[0] = nums[0]\n    for i in range(1, len(nums)):\n        prefix_sum[i] = prefix_sum[i-1] + nums[i]\n    return prefix_sum\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [1, 3, 6, 10, 15]\n\n",
        "idx_generation": 391,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the nth triangular number using recursion and memoization.\n    \"\"\"\n    memo = {}\n    \n    def triangular(n: int) -> int:\n        if n in memo:\n            return memo[n]\n        \n        if n == 1:\n            return 1\n        \n        memo[n] = n + triangular(n-1)\n        return memo[n]\n    \n    return triangular(n)\n\ndef g() -> int:\n    return 5\n\nassert f(g()) == 15\n\n",
        "idx_generation": 147,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a given number is a palindrome\"\"\"\n    def is_palindrome(number: int) -> bool:\n        num_str = str(number)\n        return num_str == num_str[::-1]\n    \n    return is_palindrome(n)\n\ndef g():\n    return 12321\n\nassert f(g()) == True\n",
        "idx_generation": 23,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int]) -> int:\n    \"\"\"\n    Given a list of numbers, find the maximum XOR value between any two numbers.\n\n    Sample Input:\n    numbers = [1, 2, 3, 4, 5]\n\n    Sample Output:\n    7\n    \"\"\"\n    max_xor = 0\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            xor = numbers[i] ^ numbers[j]\n            if xor > max_xor:\n                max_xor = xor\n    return max_xor\n\ndef g():\n    numbers = [1, 2, 3, 4, 5]\n    return numbers\n\nassert f(g()) == 7\n\n",
        "idx_generation": 261,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Check if there exists a positive integer x such that x^k = n.\"\"\"\n    if n == 1:\n        return True\n    if k == 1:\n        return False\n    for x in range(2, int(n**(1/k))+1):\n        if x**k == n:\n            return True\n    return False\n\ndef g(n = 16, k = 2):\n    return n, k\n\nassert f(*g())\n",
        "idx_generation": 44,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the factorial of n.\n\n    Args:\n    - n: A positive integer.\n\n    Returns:\n    - The factorial of n.\n\n    Example:\n    n = 5\n    Output: 120\n\n    Explanation:\n    The factorial of 5 is 5 * 4 * 3 * 2 * 1 = 120.\n\n    Hint: Use recursion to solve this problem.\n    \"\"\"\n\n    if n == 0:\n        return 1\n\n    return n * f(n - 1)\n\ndef g() -> int:\n    n = 5\n    return n\n\nassert f(g()) == 120\n",
        "idx_generation": 383,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given the number of nodes 'n' and a list of directed edges, determine if there is a cycle in the graph.\n\n    Example:\n    n = 4\n    edges = [[0, 1], [1, 2], [2, 3], [3, 1]]\n\n    Output:\n    True\n    \"\"\"\n\n    graph = [[] for _ in range(n)]\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n\n    def has_cycle(node: int, visited: List[bool], stack: List[bool]) -> bool:\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if has_cycle(neighbor, visited, stack):\n                    return True\n            elif stack[neighbor]:\n                return True\n\n        stack[node] = False\n        return False\n\n    visited = [False] * n\n    stack = [False] * n\n\n    for i in range(n):\n        if not visited[i]:\n            if has_cycle(i, visited, stack):\n                return True\n    \n    return False\n\ndef g():\n    return 4, [[0, 1], [1, 2], [2, 3], [3, 1]]\n\nassert f(*g()) == True\n",
        "idx_generation": 241,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    def add_edge(self, u, v):\n        self.graph[u][v] = 1\n        self.graph[v][u] = 1\n\n    def is_cyclic_util(self, v, visited, parent):\n        visited[v] = True\n\n        for i in range(self.V):\n            if self.graph[v][i] == 1:\n                if visited[i] == False:\n                    if self.is_cyclic_util(i, visited, v):\n                        return True\n                elif parent != i:\n                    return True\n\n        return False\n\n    def is_cyclic(self):\n        visited = [False] * self.V\n\n        for i in range(self.V):\n            if visited[i] == False:\n                if self.is_cyclic_util(i, visited, -1) == True:\n                    return True\n\n        return False\n\ndef f(edges: List[Tuple[int, int]]) -> bool:\n    \"\"\"\n    Given a list of edges in a graph, determine if the graph contains any cycles.\n    \"\"\"\n    g = Graph(len(edges))\n    for u, v in edges:\n        g.add_edge(u, v)\n\n    return g.is_cyclic()\n\ndef g():\n    edges = [(0, 1), (1, 2), (2, 0)]\n    return edges\n\nassert f(g())\n",
        "idx_generation": 470,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, find the number of ways to arrange k identical objects in n distinct boxes, \n    such that each box contains at most one object. Return the total number of arrangements.\n    \"\"\"\n    def arrange_objects(n: int, k: int) -> int:\n        if k > n:\n            return 0\n        \n        dp = [[0] * (k+1) for _ in range(n+1)]\n        \n        for i in range(n+1):\n            dp[i][0] = 1\n        \n        for i in range(1, n+1):\n            for j in range(1, k+1):\n                dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n        \n        return dp[n][k]\n\n    return arrange_objects(n, k)\n\ndef g():\n    n = 5\n    k = 3\n    return n, k\n\nassert f(*g()) == 10\n\n",
        "idx_generation": 326,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the sum of all the even numbers in the list.\n    \"\"\"\n    even_sum = 0\n    for num in nums:\n        if num % 2 == 0:\n            even_sum += num\n    return even_sum\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g()) == 20\n",
        "idx_generation": 367,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an unsorted integer array, find the smallest missing positive integer.\n\n    Example:\n    nums = [1,2,0]\n    Output: 3\n\n    nums = [3,4,-1,1]\n    Output: 2\n\n    nums = [7,8,9,11,12]\n    Output: 1\n\n    Note: Your algorithm should run in O(n) time and use constant extra space.\n    \"\"\"\n    n = len(nums)\n\n    for i in range(n):\n        while 0 < nums[i] <= n and nums[i] != nums[nums[i] - 1]:\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n\n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n\n    return n + 1\n\ndef g() -> List:\n    nums = [1, 2, 0]\n    return [nums]\n\nassert f(*g()) == 3\n",
        "idx_generation": 252,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Node:\n    def __init__(self, val: int):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef f(root: Node) -> int:\n    \"\"\"\n    Given the root of a binary tree, find the maximum depth.\n\n    The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n    Example:\n    Input: root = [3,9,20,null,null,15,7]\n    Output: 3\n\n    Explanation: The maximum depth is 3, since the longest path from root node to any leaf node is 3.\n    \"\"\"\n    if not root:\n        return 0\n    return 1 + max(f(root.left), f(root.right))\n\ndef g(root: Node) -> Node:\n    node1 = Node(9)\n    node2 = Node(20)\n    node3 = Node(15)\n    node4 = Node(7)\n    root.left = node1\n    root.right = node2\n    node2.left = node3\n    node2.right = node4\n    return root\n\nroot = Node(3)\nassert f(g(root)) == 3\n\n",
        "idx_generation": 391,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of a subarray.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    max_product = nums[0]\n    max_ending_here = nums[0]\n    min_ending_here = nums[0]\n    \n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            max_ending_here, min_ending_here = min_ending_here, max_ending_here\n        \n        max_ending_here = max(nums[i], max_ending_here * nums[i])\n        min_ending_here = min(nums[i], min_ending_here * nums[i])\n        \n        max_product = max(max_product, max_ending_here)\n    \n    return max_product\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, -5, 4, -2, 3, -1, 0, -2, 3, -4]\n\nassert f(g()) == 240\n",
        "idx_generation": 148,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the binary representation of n is a palindrome.\"\"\"\n    binary = bin(n)[2:]\n    return binary == binary[::-1]\ndef g():\n    return 9\nassert f(g()) == True\n",
        "idx_generation": 29,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of set bits in its binary representation.\n\n    Example:\n    Input: n = 10\n    Output: 2\n    Explanation:\n    The binary representation of 10 is '1010', which contains 2 set bits.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g(n: int) -> int:\n    return n\n\nassert f(g(10)) == 2\n",
        "idx_generation": 262,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number is a prime number.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g(n = 17):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 44,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a subgrid where the subgrid is a rectangular region within the grid.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    Output:\n    45\n\n    Explanation:\n    The maximum sum is obtained from the subgrid [[5, 6], [8, 9]], which has a sum of 45.\n\n    Hint: Use dynamic programming to calculate the sum of subgrids efficiently.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Calculate the cumulative sum of each row\n    for i in range(rows):\n        for j in range(1, cols):\n            grid[i][j] += grid[i][j - 1]\n\n    max_sum = float('-inf')\n\n    # Calculate the sum of each subgrid\n    for left in range(cols):\n        for right in range(left, cols):\n            current_sum = 0\n            for row in range(rows):\n                if left > 0:\n                    current_sum += grid[row][right] - grid[row][left - 1]\n                else:\n                    current_sum += grid[row][right]\n                max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[List[int]]:\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 45\n",
        "idx_generation": 386,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented by its edges, determine if the graph is a tree.\n\n    Example:\n    Input:\n    n = 5\n    edges = [[0, 1], [0, 2], [2, 3], [2, 4]]\n\n    Output: True\n\n    Explanation: The graph is a tree since it is connected, acyclic, and every vertex except the root has exactly one parent.\n    \"\"\"\n\n    def is_tree(n: int, edges: List[List[int]]) -> bool:\n        graph = [[] for _ in range(n)]\n        visited = [False] * n\n\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        def dfs(node: int, parent: int) -> bool:\n            visited[node] = True\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    if not dfs(neighbor, node):\n                        return False\n                elif neighbor != parent:\n                    return False\n            return True\n\n        if not dfs(0, -1):\n            return False\n\n        return all(visited)\n\n    return is_tree(n, edges)\n\ndef g():\n    n = 5\n    edges = [[0, 1], [0, 2], [2, 3], [2, 4]]\n    return n, edges\n\nassert f(*g()) == True\n\n",
        "idx_generation": 241,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, target: int) -> bool:\n    \"\"\"\n    Given an adjacency matrix 'graph', a starting node 'start', and a target node 'target',\n    determine if there is a path from 'start' to 'target' in the graph.\n\n    Args:\n    - graph: An adjacency matrix representing the graph.\n    - start: The starting node.\n    - target: The target node.\n\n    Returns:\n    - True if there is a path from 'start' to 'target', False otherwise.\n\n    Example:\n    graph = [[0, 1, 0, 0, 0],\n             [0, 0, 1, 0, 0],\n             [0, 0, 0, 1, 0],\n             [0, 0, 0, 0, 1],\n             [0, 0, 0, 0, 0]]\n\n    start = 0\n    target = 4\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 0 to node 4: 0 -> 1 -> 2 -> 3 -> 4.\n    \"\"\"\n\n    visited = [False] * len(graph)\n\n    def dfs(node):\n        if node == target:\n            return True\n\n        visited[node] = True\n\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n\n        return False\n\n    return dfs(start)\n\ndef g() -> Tuple[List[List[int]], int, int]:\n    \"\"\"\n    Generate an adjacency matrix representing a graph, a starting node, and a target node.\n    \"\"\"\n    graph = [[0, 1, 0, 0, 0],\n             [0, 0, 1, 0, 0],\n             [0, 0, 0, 1, 0],\n             [0, 0, 0, 0, 1],\n             [0, 0, 0, 0, 0]]\n\n    start = 0\n    target = 4\n\n    return graph, start, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 471,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the value of n choose k.\n\n    Sample Input:\n    n = 5\n    k = 2\n\n    Sample Output:\n    10\n    \"\"\"\n    if k == 0 or k == n:\n        return 1\n    \n    if k > n:\n        return 0\n    \n    dp = [[0] * (k+1) for _ in range(n+1)]\n    \n    for i in range(n+1):\n        dp[i][0] = 1\n    \n    for i in range(1, n+1):\n        for j in range(1, min(i+1, k+1)):\n            dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n    \n    return dp[n][k]\n\n\ndef g(n=5, k=2):\n    return n, k\n\n\nassert f(*g()) == 10\n",
        "idx_generation": 336,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three elements in the list.\n\n    Return the maximum product.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    60\n\n    Explanation:\n    The maximum product of any three elements in the list is 4 * 5 * 3 = 60.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 60\n",
        "idx_generation": 368,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers 'nums' and a target value 'target',\n    find the number of occurrences of the target in the list using binary search.\n    If the target is not found, return 0.\n\n    Example:\n    nums = [1, 2, 2, 2, 3, 4, 5]\n    target = 2\n\n    Output:\n    3\n\n    Explanation:\n    The target value 2 appears 3 times in the list.\n    \"\"\"\n\n    def binary_search(nums: List[int], target: int, left: int, right: int) -> int:\n        if left > right:\n            return 0\n\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return 1 + binary_search(nums, target, left, mid - 1) + binary_search(nums, target, mid + 1, right)\n        elif nums[mid] < target:\n            return binary_search(nums, target, mid + 1, right)\n        else:\n            return binary_search(nums, target, left, mid - 1)\n\n    return binary_search(nums, target, 0, len(nums) - 1)\n\ndef g() -> Tuple[List[int], int]:\n    return ([1, 2, 2, 2, 3, 4, 5], 2)\n\nassert f(*g()) == 3\n\n",
        "idx_generation": 273,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    Input:\n    arr = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1 (2 and 7) add up to the target value 9.\n    \"\"\"\n\n    num_map = {}\n\n    for i, num in enumerate(arr):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n\n    return []\n\ndef g(arr = [2, 7, 11, 15], target = 9):\n    return arr, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 393,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Find the number of ways to reach the target sum by adding up the numbers in the list,\n    using dynamic programming.\n    \"\"\"\n    dp = [0] * (target + 1)\n    dp[0] = 1\n    \n    for i in range(1, target + 1):\n        for num in nums:\n            if i >= num:\n                dp[i] += dp[i - num]\n    \n    return dp[target]\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target sum.\n    \"\"\"\n    nums = [1, 2, 3]\n    target = 4\n    return nums, target\n\nassert f(*g()) == 7\n",
        "idx_generation": 148,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n\n    Output:\n    3\n\n    Explanation:\n    The longest substring without repeating characters is \"abc\" with a length of 3.\n\n    Hint: Use a sliding window approach to keep track of the longest substring without repeating characters.\n    \"\"\"\n    if not s:\n        return 0\n\n    max_length = 0\n    start = 0\n    seen = {}\n\n    for end in range(len(s)):\n        if s[end] in seen and start <= seen[s[end]]:\n            start = seen[s[end]] + 1\n        else:\n            max_length = max(max_length, end - start + 1)\n\n        seen[s[end]] = end\n\n    return max_length\n\ndef g(s=\"abcabcbb\"):\n    return s\n\nassert f(g()) == 3\n",
        "idx_generation": 30,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the count of set bits in its binary representation.\n\n    Example:\n    n = 7\n\n    Output:\n    3\n\n    Explanation:\n    The binary representation of 7 is 111, which contains 3 set bits.\n\n    Hint: Use bitwise operations to count the number of set bits.\n    \"\"\"\n\n    count = 0\n\n    while n > 0:\n        count += n & 1\n        n >>= 1\n\n    return count\n\ndef g() -> int:\n    n = 15\n    return n\n\nassert f(g()) == 4\n",
        "idx_generation": 263,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> bool:\n    \"\"\"Check if n and m are coprime numbers\"\"\"\n    def gcd(a, b):\n        while b != 0:\n            a, b = b, a % b\n        return a\n    return gcd(n, m) == 1\ndef g():\n    return 15, 28\nassert f(*g())\n",
        "idx_generation": 52,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, wordDict: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a dictionary of words wordDict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.\n\n    Example:\n    s = \"leetcode\"\n    wordDict = [\"leet\", \"code\"]\n\n    Output:\n    True\n\n    Explanation:\n    The string \"leetcode\" can be segmented into \"leet\" and \"code\".\n\n    Hint: Use dynamic programming to keep track of whether a substring of s can be segmented into dictionary words. Iterate through the string and check if a substring starting from each index can be formed using the words in the dictionary.\n    \"\"\"\n\n    n = len(s)\n    dp = [False] * (n + 1)\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in wordDict:\n                dp[i] = True\n                break\n\n    return dp[n]\n\ndef g() -> Tuple[str, List[str]]:\n    s = \"leetcode\"\n    wordDict = [\"leet\", \"code\"]\n    return s, wordDict\n\nassert f(*g()) == True\n",
        "idx_generation": 387,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given a number of nodes and a list of edges between the nodes, determine if the graph contains a cycle.\n\n    Example:\n    Input: n = 4, edges = [[0, 1], [1, 2], [2, 3], [3, 0]]\n    Output: True\n    Explanation:\n    The graph contains a cycle: 0 -> 1 -> 2 -> 3 -> 0\n    \"\"\"\n    parent = [-1] * n\n\n    def find(x):\n        if parent[x] == -1:\n            return x\n        return find(parent[x])\n\n    def union(x, y):\n        xroot = find(x)\n        yroot = find(y)\n        if xroot == yroot:\n            return True\n        parent[xroot] = yroot\n        return False\n\n    for edge in edges:\n        if union(edge[0], edge[1]):\n            return True\n    return False\n\ndef g() -> Tuple[int, List[List[int]]]:\n    return 4, [[0, 1], [1, 2], [2, 3], [3, 0]]\n\nassert f(*g()) == True\n",
        "idx_generation": 245,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: dict, start='A', end='E') -> List[str]:\n    \"\"\"\n    Find the shortest path from the start node to the end node in a given graph using breadth-first search.\n\n    Args:\n    - graph: A dictionary representing the graph.\n    - start: The start node.\n    - end: The end node.\n\n    Returns:\n    - A list of nodes representing the shortest path from the start to the end node, or an empty list if no path exists.\n\n    Example:\n    Input:\n    graph = {'A': ['B', 'C'],\n             'B': ['D', 'E'],\n             'C': ['F'],\n             'D': [],\n             'E': [],\n             'F': []}\n    start = 'A'\n    end = 'E'\n\n    Output:\n    ['A', 'B', 'E']\n\n    Explanation:\n    The shortest path from 'A' to 'E' is ['A', 'B', 'E'].\n    \"\"\"\n\n    queue = [(start, [start])]\n    visited = set()\n\n    while queue:\n        node, path = queue.pop(0)\n\n        if node == end:\n            return path\n\n        if node not in visited:\n            visited.add(node)\n\n            for neighbor in graph[node]:\n                queue.append((neighbor, path + [neighbor]))\n\n    return []\n\ndef g() -> dict:\n    \"\"\"\n    Generate a graph.\n    \"\"\"\n    graph = {'A': ['B', 'C'],\n             'B': ['D', 'E'],\n             'C': ['F'],\n             'D': [],\n             'E': [],\n             'F': []}\n    return graph\n\nassert f(g(), 'A', 'E') == ['A', 'B', 'E']\n",
        "idx_generation": 472,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers 'nums' and a target integer 'target', \n    find the number of unique combinations that add up to the target.\n    Each number in 'nums' can be used multiple times.\n\n    Example:\n    nums = [1, 2, 3]\n    target = 4\n\n    Output:\n    7\n    \"\"\"\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i >= num:\n                dp[i] += dp[i - num]\n\n    return dp[target]\n\ndef g():\n    nums = [1, 2, 3]\n    target = 4\n    return nums, target\n\nassert f(*g()) == 7\n",
        "idx_generation": 338,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], x: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers arr and a target integer x,\n    determine if there are two numbers in the list that add up to x.\n    \n    Example:\n    arr = [1, 2, 3, 4, 5]\n    x = 7\n    \n    Output:\n    True (since 3 + 4 = 7)\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        if arr[left] + arr[right] == x:\n            return True\n        elif arr[left] + arr[right] < x:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target integer.\n    \"\"\"\n    arr = [1, 2, 3, 4, 5]\n    x = 7\n    return arr, x\n\nassert f(*g()) == True\n",
        "idx_generation": 368,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            max_xor = max(max_xor, nums[i] ^ nums[j])\n    \n    return max_xor\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5]):\n    \"\"\"\n    Generate a list of integers for the function f.\n    \"\"\"\n    return nums\n\nassert f(g()) == 7\n",
        "idx_generation": 279,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of distinct pairs (a, b) such that a + b = target, where target is a given integer.\n\n    Return the number of distinct pairs.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 6\n\n    Output:\n    2\n\n    Explanation:\n    The distinct pairs that sum up to 6 are (1, 5) and (2, 4).\n    \"\"\"\n    def count_pairs(arr, target):\n        count = 0\n        seen = set()\n        \n        for num in arr:\n            complement = target - num\n            if complement in seen:\n                count += 1\n            seen.add(num)\n        \n        return count\n\n    target = 6\n    return count_pairs(arr, target)\n\ndef g(arr=[1, 2, 3, 4, 5]):\n    return arr\n\nassert f(g()) == 2\n\n",
        "idx_generation": 394,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the length of the longest increasing subsequence in the array.\n    \"\"\"\n    n = len(arr)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g() -> List[int]:\n    arr = [1, 3, 2, 4, 6, 5]\n    return arr\n\nassert f(g()) == 4\n\n",
        "idx_generation": 150,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if a number is a palindrome.\n    \"\"\"\n    num = str(n)\n    return num == num[::-1]\n\ndef g(n: int) -> int:\n    \"\"\"\n    Find the smallest palindrome number greater than n.\n    \"\"\"\n    n += 1\n    while not f(n):\n        n += 1\n    return n\n\nn = 100\nassert f(g(n))\n",
        "idx_generation": 39,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, count the number of set bits in its binary representation.\n\n    Return the count of set bits.\n\n    Example:\n    n = 11\n\n    Output:\n    3\n\n    Explanation:\n    The binary representation of 11 is 1011, which contains 3 set bits.\n    \"\"\"\n    count = 0\n\n    while n:\n        count += n & 1\n        n >>= 1\n\n    return count\n\ndef g(n=11):\n    return n\n\nassert f(g()) == 3\n\n",
        "idx_generation": 272,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "import math\nfrom typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if n is a perfect square and the square root is a prime number.\"\"\"\n    import math\n    \n    if n < 0:\n        return False\n    \n    sqrt = math.isqrt(n)\n    if sqrt * sqrt != n:\n        return False\n    \n    if sqrt < 2:\n        return False\n    \n    for i in range(2, math.isqrt(sqrt) + 1):\n        if sqrt % i == 0:\n            return False\n    \n    return True\n\ndef g():\n    return 49\n\nassert f(g()) == True\n",
        "idx_generation": 57,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> str:\n    \"\"\"\n    Given an integer n, calculate the factorial of n and return it as a string.\n\n    Example:\n    n = 5\n\n    Output:\n    \"120\"\n\n    Explanation:\n    The factorial of 5 is 120.\n    \"\"\"\n\n    def factorial(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n-1)\n\n    return str(factorial(n))\n\ndef g(n: int):\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    return n\n\nassert f(g(5)) == \"120\"\n",
        "idx_generation": 392,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    Given an undirected connected tree with n nodes numbered from 0 to n-1, and an array edges where edges[i] = [ai, bi]\n    indicates that there is an edge between nodes ai and bi in the tree. You can choose any node of the tree as the root.\n    When you select a node x as the root, the result tree has height h. Among all possible rooted trees, those with minimum\n    height (i.e. min(h))  are called minimum height trees (MHTs). Return a list of the root labels of all the MHTs.\n\n    Note:\n    - The given tree will have between 1 and 2000 nodes.\n    - Each node's value will be between 0 and n-1.\n    - The given edges are undirected, and each edge is between two different nodes of the tree.\n    \"\"\"\n    if n == 1:\n        return [0]\n\n    graph = [[] for _ in range(n)]\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    leaves = [i for i in range(n) if len(graph[i]) == 1]\n\n    while n > 2:\n        n -= len(leaves)\n        new_leaves = []\n        for leaf in leaves:\n            neighbor = graph[leaf].pop()\n            graph[neighbor].remove(leaf)\n            if len(graph[neighbor]) == 1:\n                new_leaves.append(neighbor)\n        leaves = new_leaves\n\n    return leaves\n\ndef g():\n    n = 6\n    edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]\n    return n, edges\n\nassert f(*g()) == [3, 4]\n\n",
        "idx_generation": 249,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\n\nclass Queue:\n    def __init__(self):\n        self.queue = []\n\n    def enqueue(self, item: int) -> None:\n        self.queue.append(item)\n\n    def dequeue(self) -> int:\n        return self.queue.pop(0)\n\n    def is_empty(self) -> bool:\n        return len(self.queue) == 0\n\n\ndef f(graph: Dict[int, List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph and a source node, determine if it is possible to reach all other nodes from the source node.\n\n    Args:\n    - graph: The undirected graph represented as an adjacency list.\n\n    Returns:\n    - True if all other nodes can be reached from the source node, False otherwise.\n\n    Example:\n    graph = {\n        0: [1, 2],\n        1: [0],\n        2: [0, 3],\n        3: [2]\n    }\n\n    Output:\n    True\n\n    Explanation:\n    All other nodes can be reached from the source node 0.\n    \"\"\"\n\n    source = 0\n    visited = set()\n\n    queue = Queue()\n    queue.enqueue(source)\n    visited.add(source)\n\n    while not queue.is_empty():\n        node = queue.dequeue()\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                queue.enqueue(neighbor)\n                visited.add(neighbor)\n\n    return len(visited) == len(graph)\n\n\ndef g() -> Dict[int, List[int]]:\n    graph = {\n        0: [1, 2],\n        1: [0],\n        2: [0, 3],\n        3: [2]\n    }\n    return graph\n\n\nassert f(g()) == True\n\n",
        "idx_generation": 473,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the majority element (element that appears more than n/2 times, where n is the length of the list).\n\n    Example:\n    Input: [2, 2, 1, 1, 1, 2, 2]\n    Output: 2\n    Explanation: The majority element in the list is 2, as it appears more than n/2 times (where n is 7).\n    \"\"\"\n\n    count = 0\n    majority = None\n\n    for num in nums:\n        if count == 0:\n            majority = num\n        if num == majority:\n            count += 1\n        else:\n            count -= 1\n\n    return majority\n\ndef g():\n    return ([2, 2, 1, 1, 1, 2, 2],)\n\nassert f(*g()) == 2\n",
        "idx_generation": 342,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of distinct integers and a target value, return the index if the target is found.\n    If not, return the index where it would be if it were inserted in order.\n\n    Args:\n    - nums: A list of integers in ascending order.\n    - target: The target value.\n\n    Returns:\n    - The index of the target value in the list, or the index where it would be if inserted.\n\n    Example:\n    f([1, 3, 5, 6], 5) returns 2\n    f([1, 3, 5, 6], 2) returns 1\n    f([1, 3, 5, 6], 7) returns 4\n    f([1, 3, 5, 6], 0) returns 0\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left\n\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted array of distinct integers and a target value.\n\n    Returns:\n    - The generated array and target value.\n\n    Example:\n    g() returns ([1, 3, 5, 6], 5)\n    \"\"\"\n\n    return [1, 3, 5, 6], 5\n\nassert f(*g()) == 2\n",
        "idx_generation": 368,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value, determine if there are two numbers in the array that\n    add up to the target.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    This solution uses a two-pointer approach to find a pair of numbers that add up to the target value.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return [arr[left], arr[right]]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\narr = [1, 2, 3, 4, 5]\ntarget = 7\nassert f(g(arr, target), target)\n\n",
        "idx_generation": 284,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[int]:\n    \"\"\"\n    Given an integer n, return a list of the first n Fibonacci numbers.\n\n    Args:\n    - n: An integer, the number of Fibonacci numbers to return.\n\n    Returns:\n    - A list of the first n Fibonacci numbers.\n    \"\"\"\n    fib = [0, 1]\n    \n    for i in range(2, n):\n        fib.append(fib[i-1] + fib[i-2])\n    \n    return fib\n\ndef g() -> int:\n    n = 5\n    return n\n\nassert f(g()) == [0, 1, 1, 2, 3]\n",
        "idx_generation": 396,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int) -> List[int]:\n    \"\"\"\n    Given an adjacency matrix representation of a directed graph and a starting vertex,\n    perform a depth-first search (DFS) starting from the given vertex and return the traversal path.\n    \"\"\"\n    n = len(graph)\n    visited = [False] * n\n    traversal_path = []\n\n    def dfs(vertex):\n        visited[vertex] = True\n        traversal_path.append(vertex)\n\n        for neighbor in range(n):\n            if graph[vertex][neighbor] == 1 and not visited[neighbor]:\n                dfs(neighbor)\n\n    dfs(start)\n\n    return traversal_path\n\ndef g(graph: List[List[int]] = [[0, 1, 1, 0], [0, 0, 1, 0], [0, 0, 0, 1], [0, 0, 0, 0]], start: int = 0):\n    return (graph, start)\n\nassert f(*g()) == [0, 1, 2, 3]\n\n",
        "idx_generation": 153,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if the string is a palindrome after removing all non-alphanumeric characters and ignoring the case.\n    \"\"\"\n    def is_palindrome(s):\n        s = ''.join(ch.lower() for ch in s if ch.isalnum())\n        return s == s[::-1]\n\n    return is_palindrome(s)\n\ndef g(s=\"A man, a plan, a canal: Panama\"):\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 39,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value is obtained by XORing 5 and 25, which results in 28 (101 XOR 110 = 011).\n    \"\"\"\n\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n\n        prefixes = set()\n        for num in nums:\n            prefixes.add(num & mask)\n\n        possible_xor = max_xor | (1 << i)\n        for prefix in prefixes:\n            if possible_xor ^ prefix in prefixes:\n                max_xor = possible_xor\n                break\n    \n    return max_xor\n\ndef g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n\n",
        "idx_generation": 274,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "import math\nfrom typing import*\nfrom math import factorial\n\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number n is a factorial number.\"\"\"\n    i = 1\n    while factorial(i) < n:\n        i += 1\n    return factorial(i) == n\n\ndef g():\n    return 120\n\nassert f(g()) == True\n",
        "idx_generation": 61,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of ways to represent n as the sum of 1, 2, and 3.\n\n    Args:\n    - n: A positive integer.\n\n    Returns:\n    - The number of ways to represent n as the sum of 1, 2, and 3.\n    \"\"\"\n    if n == 0:\n        return 1\n    elif n < 0:\n        return 0\n\n    return f(n - 1) + f(n - 2) + f(n - 3)\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer for the function f.\n    \"\"\"\n    return 4\n\nassert f(g()) == 7\n\n",
        "idx_generation": 412,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"\n    Given a directed graph as a dictionary where the keys are nodes and the values are lists of adjacent nodes,\n    determine if there is a path from the start node to the end node.\n\n    Example:\n    f({'A': ['B', 'C'], 'B': ['C', 'D'], 'C': ['D'], 'D': []}, 'A', 'D') -> True\n\n    Return True if there is a path, else return False.\n    \"\"\"\n    def dfs(node):\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n        return False\n    \n    visited = set()\n    return dfs(start)\n\ndef g():\n    return {'A': ['B', 'C'], 'B': ['C', 'D'], 'C': ['D'], 'D': []}, 'A', 'D'\n\nassert f(*g()) == True\n\n",
        "idx_generation": 249,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> int:\n    \"\"\"\n    Given a graph represented as an adjacency list and two nodes, find the minimum number of edges required to reach the end node from the start node.\n    If it is not possible to reach the end node from the start node, return -1.\n\n    Example:\n    Input:\n    graph = {0: [1, 2], 1: [2], 2: [0, 3], 3: [3]}\n    start = 2\n    end = 3\n\n    Output:\n    1\n\n    Explanation:\n    The minimum number of edges required to reach node 3 from node 2 is 1.\n    \"\"\"\n\n    def bfs(graph: Dict[int, List[int]], start: int, end: int) -> int:\n        queue = [(start, 0)]\n        visited = set()\n\n        while queue:\n            current, edges = queue.pop(0)\n\n            if current == end:\n                return edges\n\n            if current in visited:\n                continue\n\n            visited.add(current)\n\n            for neighbor in graph[current]:\n                queue.append((neighbor, edges + 1))\n\n        return -1\n\n    return bfs(graph, start, end)\n\ndef g() -> Tuple[Dict[int, List[int]], int, int]:\n    \"\"\"\n    Generate a graph represented as an adjacency list, start node, and end node.\n    \"\"\"\n    return ({0: [1, 2], 1: [2], 2: [0, 3], 3: [3]}, 2, 3)\n\nassert f(*g()) == 1\n",
        "idx_generation": 474,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> List[str]:\n    \"\"\"\n    Generate all possible valid combinations of n pairs of parentheses.\n\n    Example:\n    n = 3\n\n    Output:\n    [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\n    \"\"\"\n\n    def generate_parentheses(n):\n        result = []\n        generate(\"\", n, n, result)\n        return result\n\n    def generate(current, left, right, result):\n        if left == 0 and right == 0:\n            result.append(current)\n            return\n\n        if left > 0:\n            generate(current + \"(\", left - 1, right, result)\n        if right > left:\n            generate(current + \")\", left, right - 1, result)\n\n    return generate_parentheses(n)\n\ndef g(n=3):\n    return n\n\nassert f(g()) == [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\n",
        "idx_generation": 344,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers 'nums' and an integer 'k', find the kth smallest element in the list.\n    \n    Example:\n    nums = [3, 7, 1, 4, 2, 8, 5]\n    k = 3\n    \n    Output:\n    3\n    \n    Explanation:\n    After sorting the list in ascending order, the third smallest element is 3.\n    \"\"\"\n    nums.sort()\n    return nums[k-1]\n\ndef g(nums: List[int] = [3, 7, 1, 4, 2, 8, 5], k: int = 3):\n    return nums, k\n\nassert f(*g()) == 3\n\n",
        "idx_generation": 369,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n    You must write an algorithm with O(log n) runtime complexity.\n\n    Example:\n    nums = [1,3,5,6], target = 5\n    Output: 2\n\n    nums = [1,3,5,6], target = 2\n    Output: 1\n\n    nums = [1,3,5,6], target = 7\n    Output: 4\n\n    nums = [1,3,5,6], target = 0\n    Output: 0\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted array of distinct integers and a target value.\n    \"\"\"\n    nums = [1, 3, 5, 6]\n    target = 5\n    return nums, target\n\n\nassert f(*g()) == 2\n",
        "idx_generation": 306,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers, check if the array contains a Pythagorean triplet.\n\n    A Pythagorean triplet is a set of three integers (a, b, c) such that a^2 + b^2 = c^2.\n\n    Example:\n    Input: [3, 1, 4, 6, 5]\n    Output: True\n    Explanation: The array contains a Pythagorean triplet (3, 4, 5), where 3^2 + 4^2 = 5^2.\n\n    \"\"\"\n    # Create a set to store the squares of all elements in the array\n    squares = set([x**2 for x in arr])\n\n    # Iterate through all pairs of elements in the array\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            # Check if the sum of squares of the two elements is in the set\n            if arr[i]**2 + arr[j]**2 in squares:\n                return True\n\n    return False\n\ndef g():\n    return [3, 1, 4, 6, 5]\n\nassert f(g()) == True\n",
        "idx_generation": 397,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the nth Fibonacci number using dynamic programming\"\"\"\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    fib = [0] * (n+1)\n    fib[1] = 1\n    for i in range(2, n+1):\n        fib[i] = fib[i-1] + fib[i-2]\n    return fib[n]\ndef g(n=10):\n    return n\nassert f(g()) == 55\n",
        "idx_generation": 156,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, t: str) -> bool:\n    \"\"\"Check if s and t are isomorphic strings.\"\"\"\n    if len(s) != len(t):\n        return False\n    \n    mapping = {}\n    mapped = set()\n    \n    for i in range(len(s)):\n        char_s = s[i]\n        char_t = t[i]\n        \n        if char_s in mapping:\n            if mapping[char_s] != char_t:\n                return False\n        else:\n            if char_t in mapped:\n                return False\n            mapping[char_s] = char_t\n            mapped.add(char_t)\n    \n    return True\n\ndef g() -> (str, str):\n    s = \"egg\"\n    t = \"add\"\n    return s, t\n\nassert f(*g())\n",
        "idx_generation": 40,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two elements in the list.\n\n    Example:\n    arr = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n    \"\"\"\n\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = set()\n        for num in arr:\n            prefixes.add(num & mask)\n\n        candidate = max_xor | (1 << i)\n        for prefix in prefixes:\n            if (prefix ^ candidate) in prefixes:\n                max_xor = candidate\n                break\n\n    return max_xor\n\ndef g():\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n",
        "idx_generation": 277,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the sum of the first n positive integers is divisible by n.\n\n    Sample Input:\n    n = 5\n\n    Sample Output:\n    True\n    \"\"\"\n    return (n * (n + 1) // 2) % n == 0\n\ndef g(n=5):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 62,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n    \"\"\"\n    if n <= 1:\n        return n\n    return f(n-1) + f(n-2)\n\ndef g(n: int = 6):\n    \"\"\"\n    Generate a positive integer for the function f.\n    \"\"\"\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 435,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Graph:\n    def __init__(self, vertices: int):\n        self.vertices = vertices\n        self.adj_list = [[] for _ in range(vertices)]\n\n    def add_edge(self, u: int, v: int) -> None:\n        self.adj_list[u].append(v)\n        self.adj_list[v].append(u)\n\n    def is_cyclic(self) -> bool:\n        visited = [False] * self.vertices\n\n        for vertex in range(self.vertices):\n            if not visited[vertex]:\n                if self.is_cyclic_util(vertex, visited, -1):\n                    return True\n\n        return False\n\n    def is_cyclic_util(self, vertex: int, visited: List[bool], parent: int) -> bool:\n        visited[vertex] = True\n\n        for neighbor in self.adj_list[vertex]:\n            if not visited[neighbor]:\n                if self.is_cyclic_util(neighbor, visited, vertex):\n                    return True\n            elif parent != neighbor:\n                return True\n\n        return False\n\ndef f(edges: List[List[int]], vertices: int) -> bool:\n    \"\"\"\n    Given a list of edges in a graph and the number of vertices, determine if the graph contains a cycle.\n\n    Example:\n    edges = [[0, 1], [1, 2], [2, 0]]\n    vertices = 3\n\n    Output:\n    True\n\n    Explanation:\n    The given graph contains a cycle.\n\n    Hint: Use depth-first search (DFS) to detect cycles in the graph.\n    \"\"\"\n\n    graph = Graph(vertices)\n\n    for edge in edges:\n        graph.add_edge(edge[0], edge[1])\n\n    return graph.is_cyclic()\n\ndef g() -> List[List[int]]:\n    edges = [[0, 1], [1, 2], [2, 3], [3, 0]]\n    vertices = 4\n    return edges, vertices\n\nassert f(*g()) == True\n",
        "idx_generation": 263,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph, determine if it contains a cycle.\n\n    Parameters:\n    graph (List[List[int]]): An adjacency list representation of the graph. Each element is a list of neighbors for a given vertex.\n\n    Returns:\n    bool: True if the graph contains a cycle, False otherwise.\n    \"\"\"\n\n    def is_cycle(node, visited, parent):\n        visited[node] = True\n\n        for neighbor in graph[node]:\n            if visited[neighbor] == False:\n                if is_cycle(neighbor, visited, node):\n                    return True\n            elif parent != neighbor:\n                return True\n\n        return False\n\n    num_vertices = len(graph)\n    visited = [False] * num_vertices\n\n    for node in range(num_vertices):\n        if visited[node] == False:\n            if is_cycle(node, visited, -1):\n                return True\n\n    return False\n\ndef g() -> List[List[int]]:\n    graph = [[1, 2], [0, 2], [0, 1, 3], [2]]\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 482,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array of distinct integers nums and a target integer target, \n    return a list of all unique combinations of nums where the chosen numbers sum to target.\n    You may return the combinations in any order.\n    The same number may be chosen from nums an unlimited number of times.\n    Two combinations are unique if the frequency of at least one of the chosen numbers is different.\n    It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\n\n    Example:\n    Input: nums = [2,3,6,7], target = 7\n    Output: [[2,2,3],[7]]\n\n    Input: nums = [2,3,5], target = 8\n    Output: [[2,2,2,2],[2,3,3],[3,5]]\n    \"\"\"\n\n    def combination_sum(nums, target, path, result):\n        if target == 0:\n            result.append(path)\n            return\n        \n        if target < 0:\n            return\n        \n        for i in range(len(nums)):\n            num = nums[i]\n            combination_sum(nums[i:], target - num, path + [num], result)\n\n    result = []\n    combination_sum(nums, target, [], result)\n    return result\n\n\ndef g(nums: List[int] = [2, 3, 6, 7], target: int = 7):\n    return nums, target\n\nassert f(*g()) == [[2, 2, 3], [7]]\n\n",
        "idx_generation": 350,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there exists two numbers in the list such that their sum is equal to a given target.\n    Return True if such pair exists, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        \n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    nums = [-2, 1, 3, 5, 7, 9]\n    target = 10\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 370,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, find two numbers in nums that add up to the target.\n    Return the indices of the two numbers in the original list.\n    \"\"\"\n\n    def binary_search(nums, target):\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        complement_index = binary_search(nums, complement)\n        if complement_index != -1 and complement_index != i:\n            return [i, complement_index]\n\n    return []\n\ndef g() -> List[int]:\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 310,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer 'n', find the sum of all the multiples of 3 or 5 below 'n'.\n\n    Example:\n    n = 10\n\n    Output:\n    23 (since the multiples are 3, 5, 6, and 9)\n    \"\"\"\n    sum = 0\n    \n    for i in range(n):\n        if i % 3 == 0 or i % 5 == 0:\n            sum += i\n    \n    return sum\n\ndef g():\n    return 10\n\nassert f(g()) == 23\n",
        "idx_generation": 29,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all even Fibonacci numbers less than or equal to n.\n\n    Example:\n    n = 10\n\n    Output:\n    10\n\n    Explanation:\n    The even Fibonacci numbers less than or equal to 10 are [0, 2, 8] and their sum is 10.\n\n    Hint: Use dynamic programming to calculate the Fibonacci sequence and keep track of the even numbers.\n    \"\"\"\n\n    fib = [0, 1]\n    even_sum = 0\n\n    while fib[-1] <= n:\n        if fib[-1] % 2 == 0:\n            even_sum += fib[-1]\n        fib.append(fib[-1] + fib[-2])\n\n    return even_sum\n\ndef g():\n    return 10\n\nassert f(g()) == 10\n",
        "idx_generation": 159,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string 's', reverse the order of the words in the string.\n\n    Example:\n    s = \"Hello World\"\n\n    Output:\n    \"World Hello\"\n    \"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)\n\ndef g():\n    return \"Hello World\"\n\nassert f(g()) == \"World Hello\"\n",
        "idx_generation": 41,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a pair of numbers whose XOR is equal to the target value.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n\n    Sample Output:\n    True\n    \"\"\"\n    complement_set = set()\n    for num in nums:\n        complement = target ^ num\n        if complement in complement_set:\n            return True\n        complement_set.add(num)\n\n    return False\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g(), 6) == True\n",
        "idx_generation": 281,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a prime number.\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g(n = 29):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 63,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum path sum from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    \n    Output:\n    7\n    \n    Explanation:\n    The minimum path sum is 7, following the path 1 -> 3 -> 1 -> 1 -> 1.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n",
        "idx_generation": 441,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> List[int]:\n    \"\"\"\n    Given the root of a binary tree, return the inorder traversal of its nodes' values.\n\n    Example:\n    Input:\n        1\n         \\\n          2\n         /\n        3\n\n    Output:\n    [1, 3, 2]\n    \"\"\"\n    def inorder(node, result):\n        if not node:\n            return\n        inorder(node.left, result)\n        result.append(node.val)\n        inorder(node.right, result)\n\n    result = []\n    inorder(root, result)\n    return result\n\ndef g() -> TreeNode:\n    root = TreeNode(1)\n    root.right = TreeNode(2)\n    root.right.left = TreeNode(3)\n    return root\n\nassert f(g()) == [1, 3, 2]\n",
        "idx_generation": 267,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Determine if a directed graph contains a cycle.\n    \"\"\"\n    visited = [0] * len(graph)\n    path = [0] * len(graph)\n\n    for node in range(len(graph)):\n        if not visited[node] and dfs(graph, node, visited, path):\n            return True\n    \n    return False\n\ndef dfs(graph: List[List[int]], node: int, visited: List[int], path: List[int]) -> bool:\n    visited[node] = 1\n    path[node] = 1\n\n    for neighbor in range(len(graph)):\n        if graph[node][neighbor] == 1:\n            if not visited[neighbor] and dfs(graph, neighbor, visited, path):\n                return True\n            elif path[neighbor]:\n                return True\n    \n    path[node] = 0\n\n    return False\n\ndef g():\n    graph = [\n        [0, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 1],\n        [1, 0, 0, 0, 0]\n    ]\n\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 486,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Generate all possible combinations of n pairs of parentheses.\n    Return a list of strings representing all valid combinations.\n    \"\"\"\n    def backtrack(s, left, right):\n        if len(s) == 2 * n:\n            combinations.append(s)\n            return\n\n        if left < n:\n            backtrack(s + \"(\", left + 1, right)\n        if right < left:\n            backtrack(s + \")\", left, right + 1)\n\n    combinations = []\n    backtrack(\"\", 0, 0)\n    return combinations\n\ndef g() -> int:\n    return 3\n\nassert f(g()) == [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\n\n",
        "idx_generation": 354,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    20\n\n    Explanation:\n    The maximum product of any two numbers in the list is 4 * 5 = 20.\n    \"\"\"\n\n    max_product = float(\"-inf\")\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n\n    return max_product\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 20\n",
        "idx_generation": 371,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of non-negative integers nums and a target integer, find the minimum number of jumps to reach the\n    target position. Each element in the list represents the maximum jump length at that position.\n\n    Example:\n    nums = [2, 3, 1, 1, 4]\n    target = 4\n\n    Output:\n    2\n\n    Explanation:\n    The minimum number of jumps to reach the target position is 2.\n    The first jump takes us from index 0 to index 1.\n    The second jump takes us from index 1 to index 4.\n    \"\"\"\n\n    def jump(start, jumps):\n        if start == target:\n            return jumps\n\n        if start >= len(nums):\n            return float('inf')\n\n        min_jumps = float('inf')\n        for i in range(1, nums[start] + 1):\n            min_jumps = min(min_jumps, jump(start + i, jumps + 1))\n\n        return min_jumps\n\n    return jump(0, 0)\n\ndef g(nums=[2, 3, 1, 1, 4], target=4):\n    return nums, target\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 311,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Check if the given grid represents a valid Sudoku solution.\n    \"\"\"\n    def is_valid_row(grid: List[List[int]], row: int) -> bool:\n        seen = set()\n        for num in grid[row]:\n            if num != 0 and num in seen:\n                return False\n            seen.add(num)\n        return True\n\n    def is_valid_col(grid: List[List[int]], col: int) -> bool:\n        seen = set()\n        for row in range(9):\n            num = grid[row][col]\n            if num != 0 and num in seen:\n                return False\n            seen.add(num)\n        return True\n\n    def is_valid_box(grid: List[List[int]], start_row: int, start_col: int) -> bool:\n        seen = set()\n        for row in range(start_row, start_row + 3):\n            for col in range(start_col, start_col + 3):\n                num = grid[row][col]\n                if num != 0 and num in seen:\n                    return False\n                seen.add(num)\n        return True\n\n    for row in range(9):\n        if not is_valid_row(grid, row):\n            return False\n    for col in range(9):\n        if not is_valid_col(grid, col):\n            return False\n    for start_row in range(0, 9, 3):\n        for start_col in range(0, 9, 3):\n            if not is_valid_box(grid, start_row, start_col):\n                return False\n    return True\n\ndef g():\n    return [[5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9]]\n\nassert f(g()) == True\n",
        "idx_generation": 31,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target integer, determine if there exists a subset of nums that sums up to the target.\n    Return True if such a subset exists, False otherwise.\n    \"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if nums[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n\n    return dp[n][target]\n\ndef g(nums=[1, 2, 3, 4, 5], target=9):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 159,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Determine if a given string is a palindrome.\n    \"\"\"\n    return s == s[::-1]\n\ndef g() -> str:\n    \"\"\"\n    Generate a palindrome string.\n    \"\"\"\n    return \"racecar\"\n\nassert f(g()) == True\n",
        "idx_generation": 48,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two elements in the list.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n    return max_xor\n\ndef g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n",
        "idx_generation": 285,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a perfect square.\n\n    Sample input:\n    n = 16\n\n    Sample output:\n    True\n    \"\"\"\n    if n < 0:\n        return False\n    if n == 0 or n == 1:\n        return True\n    low, high = 0, n\n    while low <= high:\n        mid = (low + high) // 2\n        if mid * mid == n:\n            return True\n        elif mid * mid < n:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False\ndef g(n = 16):\n    return f(n)\nassert f(g()) == True\n",
        "idx_generation": 68,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of the first n Fibonacci numbers.\n\n    Args:\n    - n: The number of Fibonacci numbers to calculate.\n\n    Returns:\n    - The sum of the first n Fibonacci numbers.\n    \"\"\"\n    def fibonacci(n):\n        if n <= 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            return fibonacci(n - 1) + fibonacci(n - 2)\n    \n    sum_fib = 0\n    for i in range(1, n + 1):\n        sum_fib += fibonacci(i)\n    \n    return sum_fib\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == 12\n",
        "idx_generation": 457,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, check if it is a bipartite graph.\n    A bipartite graph is a graph whose vertices can be divided into two disjoint sets such that\n    every edge in the graph connects a vertex from one set to a vertex from the other set.\n\n    Example:\n    graph = [\n        [0, 1, 0, 1],\n        [1, 0, 1, 0],\n        [0, 1, 0, 1],\n        [1, 0, 1, 0]\n    ]\n\n    Output:\n    True\n\n    Explanation:\n    The graph can be divided into two sets: {0, 2} and {1, 3}.\n    Every edge in the graph connects a vertex from one set to a vertex from the other set.\n\n    Hint: Use depth-first search (DFS) to traverse the graph and color the vertices alternatively.\n    If a vertex has already been colored and its adjacent vertices have the same color, the graph is not bipartite.\n    \"\"\"\n    def dfs(node, color):\n        nonlocal visited, colors, graph\n\n        visited[node] = True\n        colors[node] = color\n\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1:\n                if not visited[neighbor]:\n                    if not dfs(neighbor, 1 - color):\n                        return False\n                elif colors[node] == colors[neighbor]:\n                    return False\n\n        return True\n\n    n = len(graph)\n    visited = [False] * n\n    colors = [-1] * n\n\n    for node in range(n):\n        if not visited[node]:\n            if not dfs(node, 0):\n                return False\n\n    return True\n\ndef g(graph=[[0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0]]):\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 270,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(adj_list: Dict[int, List[int]]) -> List[int]:\n    \"\"\"\n    Given an adjacency list representation of a directed graph, return a list of nodes in the topological order.\n\n    Example:\n    adj_list = {\n        0: [1, 2],\n        1: [3],\n        2: [3],\n        3: []\n    }\n\n    Output:\n    [0, 2, 1, 3]\n\n    Explanation:\n    The topological order of the graph is [0, 2, 1, 3].\n    \"\"\"\n\n    def dfs(node, visited, stack):\n        visited[node] = True\n\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, stack)\n\n        stack.append(node)\n\n    n = len(adj_list)\n    visited = [False] * n\n    stack = []\n\n    for node in range(n):\n        if not visited[node]:\n            dfs(node, visited, stack)\n\n    return stack[::-1]\n\ndef g() -> Dict[int, List[int]]:\n    return {\n        0: [1, 2],\n        1: [3],\n        2: [3],\n        3: []\n    }\n\nassert f(g()) == [0, 2, 1, 3]\n",
        "idx_generation": 497,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the number of combinations that sum up to the target.\n    Each number in the list can be used multiple times.\n\n    Example:\n    nums = [1, 2, 3]\n    target = 4\n    Output: 7\n    Explanation: The possible combinations are: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [1, 3], [2, 1, 1], [2, 2], [3, 1].\n\n    Hint: Use dynamic programming to build the number of combinations for each target sum.\n    \"\"\"\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i - num >= 0:\n                dp[i] += dp[i - num]\n\n    return dp[target]\n\ndef g():\n    nums = [1, 2, 3]\n    target = 4\n    return nums, target\n\nassert f(*g()) == 7\n",
        "idx_generation": 356,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers 'nums' and a target value 'target',\n    determine if there are three numbers in 'nums' that sum up to the target value.\n    Return True if such numbers exist, otherwise return False.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7]\n    target = 9\n\n    Output:\n    True\n\n    Explanation:\n    The numbers 2, 3, and 4 in the list sum up to the target value 9.\n    \"\"\"\n\n    def two_sum(nums: List[int], target: int, start: int) -> bool:\n        left = start\n        right = len(nums) - 1\n        while left < right:\n            curr_sum = nums[left] + nums[right]\n            if curr_sum == target:\n                return True\n            elif curr_sum < target:\n                left += 1\n            else:\n                right -= 1\n        return False\n\n    nums.sort()\n    for i in range(len(nums) - 2):\n        if two_sum(nums, target - nums[i], i+1):\n            return True\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    return ([1, 2, 3, 4, 5, 6, 7], 9)\n\nassert f(*g()) == True\n",
        "idx_generation": 372,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [2, 7]\n\n    Explanation:\n    The numbers 2 and 7 add up to 9.\n\n    Hint: Use a two-pointer approach to search for the two numbers that add up to the target.\n    \"\"\"\n\n    n = len(nums)\n    nums = sorted(nums)\n    left = 0\n    right = n - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [nums[left], nums[right]]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g():\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [2, 7]\n\n",
        "idx_generation": 312,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int, nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of n integers and a number k, count the number of subarrays that sum to k.\n    \"\"\"\n    count = 0\n    prefix_sum = 0\n    prefix_sums = {0: 1}\n    \n    for num in nums:\n        prefix_sum += num\n        if prefix_sum - k in prefix_sums:\n            count += prefix_sums[prefix_sum - k]\n        prefix_sums[prefix_sum] = prefix_sums.get(prefix_sum, 0) + 1\n    \n    return count\n\ndef g(n: int, k: int, nums: List[int]):\n    return n, k, nums\n\nassert f(*g(5, 9, [4, 5, 3, 2, 1]))\n",
        "idx_generation": 32,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given an n x m matrix, where each cell contains a non-negative integer, find the maximum sum you can obtain by starting at cell (0,0) and moving only right or down to reach cell (n-1, m-1).\n    \"\"\"\n    n = len(matrix)\n    m = len(matrix[0])\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = matrix[0][0]\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n    for j in range(1, m):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    return dp[-1][-1]\n\ndef g(matrix = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return matrix\n\nassert f(g()) == 12\n\n",
        "idx_generation": 166,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, a: int, b: int) -> str:\n    \"\"\"\n    Given a string s, replace all occurrences of character a with character b.\n\n    Sample Input:\n    s = \"banana\"\n    a = 'a'\n    b = 'x'\n\n    Sample Output:\n    \"bxnxnx\"\n    \"\"\"\n    return s.replace(a, b)\n\ndef g(s=\"banana\", a='a', b='x'):\n    return s, a, b\n\nassert f(*g()) == \"bxnxnx\"\n",
        "idx_generation": 51,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n    output: 28\n\n    Explanation:\n    The maximum XOR value is obtained by XORing 5 and 25, which gives 28 (binary representation: 11100).\n\n    Constraints:\n    - The input list will always contain at least two numbers.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n    return max_xor\n\ndef g(nums=[3, 10, 5, 25, 2, 8]):\n    return nums\n\nassert f(g()) == 28\n",
        "idx_generation": 294,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nimport math\n\ndef f(a: int, b: int, c: int) -> bool:\n    \"\"\"\n    Given three numbers 'a', 'b', and 'c', determine if they form a Pythagorean triple.\n\n    Example:\n    a = 3\n    b = 4\n    c = 5\n\n    Output:\n    True\n\n    Explanation:\n    The numbers 3, 4, and 5 form a Pythagorean triple since 3^2 + 4^2 = 5^2.\n    \"\"\"\n\n    def is_perfect_square(n: int) -> bool:\n        root = int(math.sqrt(n))\n        return root * root == n\n\n    return is_perfect_square(a * a + b * b) or is_perfect_square(b * b + c * c) or is_perfect_square(a * a + c * c)\n\n\ndef g() -> Tuple[int, int, int]:\n    return 3, 4, 5\n\n\nassert f(*g())\n",
        "idx_generation": 75,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the nth Fibonacci number.\n\n    Example:\n    n = 6\n\n    Output:\n    8\n\n    Explanation:\n    The Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, ...\n    The 6th Fibonacci number is 8.\n\n    Hint: Use recursion to calculate the Fibonacci sequence.\n    \"\"\"\n\n    def fibonacci(n):\n        if n <= 1:\n            return n\n        else:\n            return fibonacci(n-1) + fibonacci(n-2)\n\n    return fibonacci(n)\n\ndef g():\n    n = 6\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 465,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, determine if the graph contains a cycle.\n\n    Return True if the graph contains a cycle, False otherwise.\n\n    Example:\n    graph = [[1, 2], [0, 2], [0, 1, 3], [2]]\n\n    Output:\n    True\n\n    Explanation:\n    The graph contains a cycle: 0 -> 1 -> 2 -> 0\n    \"\"\"\n    def has_cycle(node, visited, parent):\n        visited[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if has_cycle(neighbor, visited, node):\n                    return True\n            elif parent != neighbor:\n                return True\n        \n        return False\n\n    n = len(graph)\n    visited = [False] * n\n\n    for node in range(n):\n        if not visited[node]:\n            if has_cycle(node, visited, -1):\n                return True\n\n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate an undirected graph represented as an adjacency list.\n    \"\"\"\n    return [[1, 2], [0, 2], [0, 1, 3], [2]]\n\nassert f(g()) == True\n",
        "idx_generation": 272,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Node:\n    def __init__(self, val: int) -> None:\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef f(root: Node) -> List[int]:\n    \"\"\"\n    Given the root of a binary tree, return the inorder traversal of its nodes' values.\n\n    Args:\n    - root: The root node of the binary tree.\n\n    Returns:\n    - The inorder traversal of the binary tree as a list of integers.\n    \"\"\"\n    def inorder(node: Node, res: List[int]) -> None:\n        if node:\n            inorder(node.left, res)\n            res.append(node.val)\n            inorder(node.right, res)\n    \n    result = []\n    inorder(root, result)\n    return result\n\ndef g() -> Node:\n    root = Node(1)\n    root.right = Node(2)\n    root.right.left = Node(3)\n    return root\n\nassert f(g()) == [1, 3, 2]\n",
        "idx_generation": 499,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target integer, find the number of combinations of elements in nums that add up to the target.\n\n    Example:\n    Input: nums = [1, 2, 3], target = 4\n    Output: 4\n\n    Explanation: The possible combinations are [1, 1, 1, 1], [1, 1, 2], [1, 3], [2, 2].\n    \"\"\"\n    def backtrack(curr_sum, index):\n        if curr_sum == target:\n            return 1\n        if curr_sum > target or index >= len(nums):\n            return 0\n\n        count = 0\n        count += backtrack(curr_sum + nums[index], index)\n        count += backtrack(curr_sum, index + 1)\n\n        return count\n\n    return backtrack(0, 0)\n\ndef g(nums=[1, 2, 3], target=4):\n    return nums, target\n\nassert f(*g()) == 4\n\n",
        "idx_generation": 361,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, determine if there exists a pair of integers in the list\n    such that their sum is equal to the target.\n\n    Args:\n    - nums: A sorted list of integers.\n    - target: The target integer.\n\n    Returns:\n    - True if there exists a pair of integers in the list such that their sum is equal to the target, False otherwise.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    Output:\n    True\n\n    Explanation:\n    There exists a pair of integers in the list whose sum is equal to the target:\n    2 + 5 = 7.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5], target=7):\n    return nums, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 374,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Find the minimum number of steps required to reach the target value from the start of the array.\n    Each step involves adding or subtracting a number from the current value.\n    \"\"\"\n    n = len(arr)\n    dp = [float('inf')] * (target + 1)\n    dp[0] = 0\n\n    for i in range(1, target + 1):\n        for j in range(n):\n            if i - arr[j] >= 0:\n                dp[i] = min(dp[i], dp[i-arr[j]] + 1)\n    \n    return dp[target]\n\ndef g(arr: List[int], target: int) -> Tuple[List[int], int]:\n    \"\"\"\n    Return the array and target value to find the minimum number of steps required to reach the target.\n    \"\"\"\n    return arr, target\n\nassert f(*g([1, 2, 5], 11)) == 3\n",
        "idx_generation": 321,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum value in the grid.\n    \"\"\"\n    max_val = float('-inf')\n    for row in grid:\n        max_val = max(max_val, max(row))\n    return max_val\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g()) == 9\n",
        "idx_generation": 35,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the nth Fibonacci number.\n\n    Example:\n    n = 6\n\n    Output:\n    8\n\n    Explanation:\n    The 6th Fibonacci number is 8 (0, 1, 1, 2, 3, 5, 8).\n    \"\"\"\n\n    if n <= 1:\n        return n\n\n    fib = [0] * (n + 1)\n    fib[1] = 1\n\n    for i in range(2, n + 1):\n        fib[i] = fib[i-1] + fib[i-2]\n\n    return fib[n]\n\ndef g(n: int) -> int:\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    return n\n\nassert f(g(6)) == 8\n\n",
        "idx_generation": 166,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, substring: str) -> bool:\n    \"\"\"\n    Given a string s and a substring, determine if the substring exists in the string.\n    \"\"\"\n    return substring in s\n\ndef g():\n    return \"Hello, world!\", \"world\"\n\nassert f(*g()) == True\n",
        "idx_generation": 52,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    \n    for i in range(31, -1, -1):\n        mask = mask | (1 << i)\n        prefix_set = set([num & mask for num in nums])\n        candidate = max_xor | (1 << i)\n        \n        for prefix in prefix_set:\n            if candidate ^ prefix in prefix_set:\n                max_xor = candidate\n                break\n    \n    return max_xor\n\ndef g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n\n",
        "idx_generation": 298,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine if a given number n is a prime number.\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g(n=17):\n    \"\"\"\n    Return a number n to check if it is a prime number.\n    \"\"\"\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 78,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the sum of the first n natural numbers.\n\n    Args:\n    - n: The number of natural numbers to sum.\n\n    Returns:\n    - The sum of the first n natural numbers.\n\n    Example:\n    f(5) => 15\n    \"\"\"\n    if n == 0:\n        return 0\n    else:\n        return n + f(n-1)\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == 15\n",
        "idx_generation": 466,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix 'graph',\n    determine if the graph is cyclic.\n\n    Args:\n    - graph: A 2D list representing the adjacency matrix of the graph.\n\n    Returns:\n    - A boolean value indicating whether the graph is cyclic.\n    \"\"\"\n\n    def is_cyclic(graph: List[List[int]], node: int, visited: List[bool], parent: int) -> bool:\n        visited[node] = True\n\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1:\n                if not visited[neighbor]:\n                    if is_cyclic(graph, neighbor, visited, node):\n                        return True\n                elif parent != neighbor:\n                    return True\n\n        return False\n\n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n\n    for node in range(num_nodes):\n        if not visited[node]:\n            if is_cyclic(graph, node, visited, -1):\n                return True\n\n    return False\n\ndef g() -> List[List[int]]:\n    return [[0, 1, 0, 0],\n            [1, 0, 1, 1],\n            [0, 1, 0, 1],\n            [0, 1, 1, 0]]\n\nassert f(g()) == True\n",
        "idx_generation": 273,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of valid parentheses expressions of length n.\n    \"\"\"\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i - 1 - j]\n\n    return dp[n]\n\ndef g():\n    n = 3\n    return n\n\nassert f(g()) == 5\n\n",
        "idx_generation": 364,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n\n    Example:\n    n = 5\n\n    Output:\n    5 (since the 5th Fibonacci number is 5)\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    prev1 = 0\n    prev2 = 1\n    \n    for _ in range(2, n + 1):\n        curr = prev1 + prev2\n        prev1, prev2 = prev2, curr\n    \n    return prev2\n\ndef g() -> int:\n    n = 5\n    return n\n\nassert f(g()) == 5\n\n",
        "idx_generation": 375,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target number, find the number of occurrences of the target number in the list.\n\n    Example:\n    nums = [1, 1, 2, 2, 2, 3]\n    target = 2\n    The target number 2 appears 3 times in the list.\n\n    Return the count of occurrences of the target number.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            count = 1\n            i = mid - 1\n            while i >= 0 and nums[i] == target:\n                count += 1\n                i -= 1\n                \n            j = mid + 1\n            while j < len(nums) and nums[j] == target:\n                count += 1\n                j += 1\n            \n            return count\n        \n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return 0\n\ndef g():\n    return [[1, 1, 2, 2, 2, 3], 2]\n\nassert f(*g()) == 3\n",
        "idx_generation": 321,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Check if there exists a subarray in the given list that sums up to 0.\n    \"\"\"\n    prefix_sum = 0\n    seen = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum in seen:\n            return True\n        seen.add(prefix_sum)\n    return False\n\ndef g(nums = [4, -3, 2, 1, 8, -6, -4, -1]):\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 36,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 2],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    29\n\n    Explanation:\n    The maximum sum of a path from the top-left cell (1) to the bottom-right cell (9) is:\n    1 -> 4 -> 7 -> 8 -> 9 = 29\n\n    Hint: Use dynamic programming to store the maximum sum at each cell.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Create a dp table to store the maximum sum at each cell\n    dp = [[0] * cols for _ in range(rows)]\n\n    # Initialize the first row and column of the dp table\n    dp[0][0] = grid[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    # Calculate the maximum sum at each cell\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g(grid=[[1, 3, 2], [4, 5, 6], [7, 8, 9]]):\n    return grid\n\nassert f(g()) == 29\n",
        "idx_generation": 167,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, k=2) -> bool:\n    \"\"\"Check if the given string can be split into k equal parts\"\"\"\n    def is_valid_split(s, k):\n        if len(s) % k != 0:\n            return False\n        part_length = len(s) // k\n        for i in range(0, len(s), part_length):\n            if s[i:i+part_length] != s[:part_length]:\n                return False\n        return True\n    return is_valid_split(s, k)\n\ndef g(k=2):\n    return \"abcabc\"\n\nassert f(g()) == True\n",
        "idx_generation": 54,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum sum of a subarray where the sum is obtained by performing a bitwise OR operation on the elements.\n\n    Example:\n    arr = [3, 2, 6, 8]\n\n    Output:\n    15\n\n    Explanation:\n    The subarray with the maximum sum is [2, 6, 8], and performing a bitwise OR operation on the elements gives 15.\n    \"\"\"\n    n = len(arr)\n    max_sum = 0\n    current_sum = 0\n\n    for i in range(n):\n        current_sum |= arr[i]\n        max_sum = max(max_sum, current_sum)\n        if current_sum == 0:\n            current_sum = 0\n\n    return max_sum\n\ndef g(arr: List[int] = [3, 2, 6, 8]):\n    return (arr,)\n\nassert f(*g()) == 15\n\n",
        "idx_generation": 298,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, compute the sum of all the positive integers less than or equal to n.\n\n    Example:\n    n = 5\n\n    Output:\n    15\n\n    Explanation:\n    The sum of all the positive integers less than or equal to 5 is 1 + 2 + 3 + 4 + 5 = 15.\n\n    Hint: Use the formula for the sum of an arithmetic series.\n    \"\"\"\n    return n * (n + 1) // 2\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 15\n\n",
        "idx_generation": 89,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Determine if there exists an integer x such that x^k = n.\"\"\"\n    def isPerfectPower(n: int, k: int) -> bool:\n        if n <= 1:\n            return True\n        for i in range(2, int(n ** (1/k)) + 1):\n            x = i\n            while x ** k <= n:\n                if x ** k == n:\n                    return True\n                x += 1\n        return False\n\n    return isPerfectPower(n, k)\n\ndef g(n=16, k=2):\n    return n, k\n\nassert f(*g()) == True\n",
        "idx_generation": 483,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Node:\n    def __init__(self, val: int, left: 'Node' = None, right: 'Node' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: Node) -> int:\n    \"\"\"\n    Given the root of a binary tree, return the maximum depth of the tree.\n    The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n    Sample Input:\n    root = Node(3, Node(9), Node(20, Node(15), Node(7)))\n\n    Sample Output:\n    3\n    \"\"\"\n    if not root:\n        return 0\n    return max(f(root.left), f(root.right)) + 1\n\n\ndef g(root = Node(3, Node(9), Node(20, Node(15), Node(7)))):\n    return root\n\n\nassert f(g()) == 3\n",
        "idx_generation": 276,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of ways to choose k items from a set of n items.\n    Return the count.\n\n    Example:\n    n = 5\n    k = 3\n\n    Output:\n    10\n    \"\"\"\n\n    def choose(n, k):\n        if k == 0 or k == n:\n            return 1\n        return choose(n-1, k-1) + choose(n-1, k)\n\n    return choose(n, k)\n\ndef g():\n    n = 5\n    k = 3\n    return n, k\n\nassert f(*g()) == 10\n\n",
        "idx_generation": 371,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Sort an array of integers in descending order\"\"\"\n    return sorted(arr, reverse=True)\n\ndef g():\n    return [5, 2, 8, 1, 7]\n\nassert f(g()) == [8, 7, 5, 2, 1]\n",
        "idx_generation": 375,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers and a target value, find the index of the target in the array.\n    If the target is not found, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output:\n    2\n\n    Explanation:\n    The target value 5 is found at index 2 in the array.\n    \"\"\"\n\n    def binary_search(nums: List[int], target: int, left: int, right: int) -> int:\n        if left > right:\n            return -1\n\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            return binary_search(nums, target, mid + 1, right)\n        else:\n            return binary_search(nums, target, left, mid - 1)\n\n    return binary_search(nums, target, 0, len(nums) - 1)\n\ndef g(nums=[1, 3, 5, 7, 9], target=5):\n    return nums, target\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 329,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]], k: int) -> bool:\n    \"\"\"Check if the matrix contains a submatrix whose elements sum up to k\"\"\"\n    m, n = len(matrix), len(matrix[0])\n    prefix_sum = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            prefix_sum[i][j] = prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1] + matrix[i - 1][j - 1]\n    \n    for i in range(m):\n        for j in range(n):\n            for x in range(i + 1, m + 1):\n                for y in range(j + 1, n + 1):\n                    curr_sum = prefix_sum[x][y] - prefix_sum[i][y] - prefix_sum[x][j] + prefix_sum[i][j]\n                    if curr_sum == k:\n                        return True\n    return False\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    k = 15\n    return matrix, k\n\nassert f(*g())\n",
        "idx_generation": 38,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size n x n, find the number of unique paths from the top-left\n    cell to the bottom-right cell. You can only move down or right at each step.\n    \"\"\"\n    if n == 0:\n        return 0\n    \n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][0] = 1\n    \n    for j in range(n):\n        dp[0][j] = 1\n    \n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[n-1][n-1]\n\ndef g():\n    n = 3\n    grid = [[0, 0, 0],\n            [0, 0, 0],\n            [0, 0, 0]]\n    return (n, grid)\n\nassert f(*g()) == 6\n",
        "idx_generation": 167,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if a string is a palindrome.\n    \"\"\"\n    n = len(s)\n    if n <= 1:\n        return True\n    if s[0] != s[n-1]:\n        return False\n    return f(s[1:n-1])\n\ndef g(s = \"racecar\"):\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 60,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the next power of 2 that is greater than or equal to n.\n\n    Example:\n    n = 7\n\n    Output:\n    8\n\n    Explanation:\n    The next power of 2 that is greater than or equal to 7 is 8.\n\n    Hint: Use bitwise operations to find the next power of 2.\n    \"\"\"\n\n    power = 1\n\n    while power < n:\n        power <<= 1\n\n    return power\n\n\ndef g() -> int:\n    n = 10\n    return n\n\nassert f(g()) == 16\n",
        "idx_generation": 301,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "import math\nfrom typing import*\ndef f(n: int, m: int) -> bool:\n    \"\"\"\n    Given two integers n and m, determine if n is a power of m.\n    \n    Example:\n    n = 8\n    m = 2\n\n    Output:\n    True\n\n    Explanation:\n    8 is a power of 2 since 2^3 = 8.\n\n    Hint: Use logarithms to check if the exponent of m that equals to n is an integer.\n    \"\"\"\n    import math\n    \n    if n <= 0 or m <= 0:\n        return False\n    \n    result = math.log(n, m)\n    return result.is_integer()\n\ndef g(n=8, m=2):\n    return n, m\n\nassert f(*g()) == True\n",
        "idx_generation": 91,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of all the previous elements in the input list.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5]\n    Output: [1, 3, 6, 10, 15]\n\n    Explanation: The output list is obtained by summing the previous elements in the input list. \n    The first element remains the same, while each subsequent element is the sum of all the previous elements.\n    \"\"\"\n    result = []\n    for i in range(len(nums)):\n        if i == 0:\n            result.append(nums[i])\n        else:\n            result.append(nums[i] + result[i-1])\n    return result\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [1, 3, 6, 10, 15]\n",
        "idx_generation": 485,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given a list of edges representing connections between nodes in a directed graph, determine if the graph contains a cycle.\n\n    Example:\n    Input:\n    edges = [[0, 1], [1, 2], [2, 3], [3, 1]]\n\n    Output:\n    True\n    \"\"\"\n\n    def has_cycle(node: int, visited: List[bool], recursion_stack: List[bool]) -> bool:\n        visited[node] = True\n        recursion_stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if has_cycle(neighbor, visited, recursion_stack):\n                    return True\n            elif recursion_stack[neighbor]:\n                return True\n\n        recursion_stack[node] = False\n        return False\n\n    num_nodes = max(max(edge) for edge in edges) + 1\n    graph = {i: [] for i in range(num_nodes)}\n    for u, v in edges:\n        graph[u].append(v)\n\n    visited = [False] * num_nodes\n    recursion_stack = [False] * num_nodes\n\n    for node in range(num_nodes):\n        if not visited[node]:\n            if has_cycle(node, visited, recursion_stack):\n                return True\n\n    return False\n\ndef g():\n    edges = [[0, 1], [1, 2], [2, 3], [3, 1]]\n    return edges\n\nassert f(g()) == True\n",
        "idx_generation": 283,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two positive integers n and k, calculate the number of k-combinations from a set of n elements.\n\n    Example:\n    n = 5\n    k = 3\n\n    Output:\n    10\n\n    Explanation:\n    There are 10 different combinations of 3 elements from a set of 5 elements.\n\n    Hint: Use the formula C(n, k) = n! / (k! * (n-k)!)\n    \"\"\"\n\n    def factorial(n: int) -> int:\n        if n == 0 or n == 1:\n            return 1\n        else:\n            return n * factorial(n - 1)\n\n    return factorial(n) // (factorial(k) * factorial(n - k))\n\ndef g() -> Tuple[int, int]:\n    \"\"\"\n    Generate values for n and k for the puzzle.\n    \"\"\"\n    n = 5\n    k = 3\n    return n, k\n\nassert f(g()[0], g()[1]) == 10\n",
        "idx_generation": 372,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: list) -> bool:\n    \"\"\"\n    Given a list of integers, check if the list is sorted in non-decreasing order.\n\n    Example:\n    arr = [1, 2, 3, 5, 8]\n\n    Output:\n    True\n\n    Explanation:\n    The list is sorted in non-decreasing order.\n\n    Hint: Compare adjacent elements and check if they are in the correct order.\n    \"\"\"\n\n    for i in range(len(arr) - 1):\n        if arr[i] > arr[i + 1]:\n            return False\n\n    return True\n\ndef g(arr = [1, 2, 3, 5, 8]):\n    return arr\n\nassert f(g()) == True\n\n",
        "idx_generation": 375,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers and a target value, find two numbers in the array that add up to the target.\n    Return the indices of the two numbers as a list, with the smaller index coming first.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n    \"\"\"\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g(nums: List[int] = [2, 7, 11, 15], target: int = 9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 333,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if a number is a prime number.\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g(n: int) -> int:\n    \"\"\"\n    Find the n-th prime number.\n    \"\"\"\n    primes = []\n    num = 2\n    while len(primes) < n:\n        if f(num):\n            primes.append(num)\n        num += 1\n    return primes[-1]\n\nn = 10\nassert f(g(n))\n",
        "idx_generation": 39,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome. Return True if the string is a palindrome,\n    False otherwise.\n    \"\"\"\n    def is_palindrome(s, left, right):\n        if left >= right:\n            return True\n        if s[left] == s[right]:\n            return is_palindrome(s, left+1, right-1)\n        else:\n            return False\n    \n    return is_palindrome(s, 0, len(s)-1)\n\ndef g(s = \"racecar\"):\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 171,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Reverse the order of words in a string\"\"\"\n    words = s.split()\n    return ' '.join(words[::-1])\n\ndef g(s=\"Hello World\"):\n    return s\n\nassert f(g()) == \"World Hello\"\n",
        "idx_generation": 64,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort them in non-decreasing order using bit manipulation.\n\n    Example:\n    f([3, 1, 5, 2, 4]) returns [1, 2, 3, 4, 5].\n\n    Note:\n    - The input list can contain duplicate numbers.\n    \"\"\"\n\n    # Convert the list elements to binary strings\n    binary_nums = [bin(num)[2:] for num in nums]\n\n    # Sort the binary strings based on their length and then their values\n    sorted_binary_nums = sorted(binary_nums, key=lambda x: (len(x), x))\n\n    # Convert the binary strings back to integers\n    sorted_nums = [int(binary, 2) for binary in sorted_binary_nums]\n\n    return sorted_nums\n\n\ndef g(nums: List[int] = [3, 1, 5, 2, 4]) -> List[int]:\n    \"\"\"\n    Generate a list of positive integers.\n\n    Example:\n    g() returns [3, 1, 5, 2, 4].\n\n    Note:\n    - The input list can contain duplicate numbers.\n    \"\"\"\n\n    return nums\n\n\nassert f(g()) == [1, 2, 3, 4, 5]\n",
        "idx_generation": 308,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the sum of the first n natural numbers.\n    \"\"\"\n    return n * (n + 1) // 2\n\ndef g() -> int:\n    n = 10\n    return n\n\nassert f(g()) == 55\n\n",
        "idx_generation": 93,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of ways to climb to the top of a staircase, where you can either climb 1 or 2 steps at a time.\n    Return the number of distinct ways.\n\n    Example:\n    n = 3\n\n    Output:\n    3 (as there are 3 ways to climb to the top: 1+1+1, 1+2, 2+1)\n\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    def climb_stairs_helper(n, memo):\n        if n <= 2:\n            return n\n        if n in memo:\n            return memo[n]\n        \n        distinct_ways = climb_stairs_helper(n - 1, memo) + climb_stairs_helper(n - 2, memo)\n        \n        memo[n] = distinct_ways\n        return distinct_ways\n\n    return climb_stairs_helper(n, {})\n\ndef g(n = 4):\n    return n\n\nassert f(g()) == 5\n\n",
        "idx_generation": 485,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the number of unique paths from the top left corner to the bottom right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1]\n    ]\n    Output: 6\n\n    Explanation:\n    There are 6 unique paths from the top left corner to the bottom right corner:\n    1. Right -> Right -> Down -> Down\n    2. Right -> Down -> Right -> Down\n    3. Right -> Down -> Down -> Right\n    4. Down -> Right -> Right -> Down\n    5. Down -> Right -> Down -> Right\n    6. Down -> Down -> Right -> Right\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = 1\n\n    for i in range(1, m):\n        dp[i][0] = 1\n\n    for j in range(1, n):\n        dp[0][j] = 1\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers for the function f.\n    \"\"\"\n    grid = [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 6\n\n",
        "idx_generation": 289,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the number of ways to choose k items from a set of n items.\n\n    Example:\n    n = 5\n    k = 3\n\n    Output:\n    10\n\n    Explanation:\n    There are 10 ways to choose 3 items from a set of 5 items: (1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5), (1, 4, 5), (2, 3, 4), (2, 3, 5), (2, 4, 5), (3, 4, 5)\n    \"\"\"\n\n    def factorial(n: int) -> int:\n        if n == 0 or n == 1:\n            return 1\n        else:\n            return n * factorial(n-1)\n\n    return factorial(n) // (factorial(k) * factorial(n-k))\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    return [5, 3]\n\nassert f(*g()) == 10\n",
        "idx_generation": 375,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the numbers in ascending order using bubble sort algorithm.\n\n    Example:\n    nums = [5, 2, 9, 1, 3]\n\n    Output:\n    [1, 2, 3, 5, 9]\n\n    Hint: Use nested loops to compare adjacent elements and swap them if necessary.\n    \"\"\"\n    n = len(nums)\n    for i in range(n - 1):\n        for j in range(n - 1 - i):\n            if nums[j] > nums[j + 1]:\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n    return nums\n\ndef g(nums=[5, 2, 9, 1, 3]):\n    return (nums,)\n\nassert f(*g()) == [1, 2, 3, 5, 9]\n",
        "idx_generation": 376,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers, find three numbers in the array that add up to a given target number.\n    \"\"\"\n    for i in range(len(arr)-2):\n        left = i + 1\n        right = len(arr) - 1\n        while left < right:\n            if arr[i] + arr[left] + arr[right] == target:\n                return True\n            elif arr[i] + arr[left] + arr[right] < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g(target: int = 15):\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g(), target=15) == True\n\n",
        "idx_generation": 335,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there exists a pair of numbers in the list whose sum is equal to the target.\n    \"\"\"\n    stack = []\n    for num in nums:\n        stack.append(num)\n        while sum(stack) > target:\n            stack.pop(0)\n        if sum(stack) == target:\n            return True\n    return False\n\ndef g():\n    nums = [2, 4, 6, 8, 10]\n    target = 14\n    return nums, target\n\nassert f(*g())\n\n",
        "idx_generation": 42,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n\n    Example:\n    n = 4\n    Output: 5\n    Explanation: There are 5 ways to climb to the top: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2].\n    \"\"\"\n\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    \n    dp = [0] * (n+1)\n    dp[1] = 1\n    dp[2] = 2\n    \n    for i in range(3, n+1):\n        dp[i] = dp[i-1] + dp[i-2]\n    \n    return dp[n]\n\ndef g():\n    return 4\n\nassert f(g()) == 5\n",
        "idx_generation": 173,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of words in the string.\n    Return the reversed string.\n    \"\"\"\n    words = s.strip().split()\n    return ' '.join(words[::-1])\n\ndef g(s = \"Hello World\"):\n    return s\n\nassert f(g()) == \"World Hello\"\n",
        "idx_generation": 69,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the single number that appears only once while all the other numbers appear twice.\n\n    Example:\n    nums = [2, 2, 1, 3, 3]\n\n    Output:\n    1\n\n    Explanation:\n    The number 1 appears only once in the array, while 2 and 3 appear twice.\n    \"\"\"\n    result = 0\n    \n    for num in nums:\n        result ^= num\n    \n    return result\n\ndef g() -> List[int]:\n    nums = [2, 2, 1, 3, 3]\n    return nums\n\nassert f(g()) == 1\n\n",
        "idx_generation": 308,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine if a number is a perfect square.\n    \"\"\"\n    if n < 0:\n        return False\n    root = int(n ** 0.5)\n    return root * root == n\n\ndef g():\n    \"\"\"\n    Generate a perfect square number.\n    \"\"\"\n    return 16\n\nassert f(g()) == True\n",
        "idx_generation": 98,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers n and m, calculate the value of n! * m!.\n\n    Example:\n    n = 3, m = 4\n\n    Output:\n    144 (as 3! = 3*2*1 = 6 and 4! = 4*3*2*1 = 24, so the result is 6 * 24 = 144)\n    \"\"\"\n    def factorial(num):\n        if num == 0 or num == 1:\n            return 1\n        else:\n            return num * factorial(num - 1)\n    \n    return factorial(n) * factorial(m)\n\ndef g(n: int = 3, m: int = 4) -> Tuple[int, int]:\n    return n, m\n\nassert f(*g()) == 144\n\n",
        "idx_generation": 494,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, count the number of connected regions.\n    A connected region consists of adjacent cells with the same character.\n    \"\"\"\n    def dfs(i: int, j: int) -> None:\n        if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != target:\n            return\n        grid[i][j] = '#'\n        dfs(i + 1, j)\n        dfs(i - 1, j)\n        dfs(i, j + 1)\n        dfs(i, j - 1)\n    \n    m, n = len(grid), len(grid[0])\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != '#':\n                target = grid[i][j]\n                dfs(i, j)\n                count += 1\n    \n    return count\n\ndef g() -> List[List[str]]:\n    grid = [\n        ['A', 'A', 'B', 'B'],\n        ['A', 'A', 'B', 'B'],\n        ['C', 'C', 'D', 'D'],\n        ['C', 'C', 'D', 'D']\n    ]\n    return grid\n\nassert f(g()) == 4\n",
        "idx_generation": 289,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Given two integers n and k, generate all possible combinations of k numbers from 1 to n.\n\n    Example:\n    n = 4, k = 2\n\n    Output:\n    [\n        [1, 2],\n        [1, 3],\n        [1, 4],\n        [2, 3],\n        [2, 4],\n        [3, 4]\n    ]\n    \"\"\"\n    combinations = []\n    backtrack([], 1, n, k, combinations)\n    return combinations\n\ndef backtrack(current_combination, start, n, k, combinations):\n    if len(current_combination) == k:\n        combinations.append(current_combination[:])\n        return\n\n    for i in range(start, n+1):\n        current_combination.append(i)\n        backtrack(current_combination, i+1, n, k, combinations)\n        current_combination.pop()\n\ndef g():\n    n = 4\n    k = 2\n    return n, k\n\nassert f(*g()) == [\n    [1, 2],\n    [1, 3],\n    [1, 4],\n    [2, 3],\n    [2, 4],\n    [3, 4]\n]\n\n",
        "idx_generation": 388,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers 'arr' and a target integer 'target', find two numbers in the list that sum up to the target.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    arr = [2, 4, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 2]\n\n    Explanation:\n    The numbers at indices 0 and 2 ([2, 7]) sum up to 9.\n\n    Hint: Use two pointers to find the two numbers that sum up to the target.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g(arr=[2, 4, 7, 11, 15], target=9):\n    return arr, target\n\nassert f(*g()) == [0, 2]\n\n",
        "idx_generation": 378,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Find the length of the longest increasing subsequence in a given list of numbers.\n    \"\"\"\n    def dp(i):\n        if i == 0:\n            return 1\n        max_length = 1\n        for j in range(i):\n            if nums[i] > nums[j]:\n                max_length = max(max_length, dp(j) + 1)\n        return max_length\n    \n    longest_length = 0\n    for i in range(len(nums)):\n        longest_length = max(longest_length, dp(i))\n    return longest_length\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return (nums,)\n\nassert f(*g()) == 4\n",
        "idx_generation": 337,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number is a prime number\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n",
        "idx_generation": 43,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray with the constraint that no two numbers in the\n    subarray are adjacent to each other.\n    \"\"\"\n    if len(nums) == 0:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    for i in range(2, len(nums)):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n    return dp[-1]\n\ndef g():\n    return [1, 2, 3, 1]\n\nassert f(g()) == 4\n",
        "idx_generation": 174,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, check if it is a palindrome.\n    Return True if s is a palindrome, otherwise return False.\n    \"\"\"\n    s = s.lower()\n    s = ''.join(c for c in s if c.isalnum())\n    return s == s[::-1]\n\ndef g(s = \"A man, a plan, a canal, Panama!\"):\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 69,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"\n    Given an integer num, return the number of set bits (1s) in its binary representation.\n\n    Sample input:\n    num = 10\n\n    Sample output:\n    2\n    \"\"\"\n    count = 0\n    while num:\n        count += num & 1\n        num >>= 1\n    return count\n\ndef g(num=10):\n    return num\n\nassert f(g()) == 2\n",
        "idx_generation": 315,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a perfect square.\n    \"\"\"\n    return n ** 0.5 == int(n ** 0.5)\n\ndef g() -> int:\n    \"\"\"\n    Generate a perfect square number greater than 100.\n    \"\"\"\n    num = 101\n    while not f(num):\n        num += 1\n    return num\n\nassert f(g()) == True\n",
        "idx_generation": 111,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there exists a subsequence (not necessarily contiguous) whose sum is equal to the target.\n    \"\"\"\n    def subset_sum(nums, target):\n        n = len(nums)\n        dp = [[False] * (target+1) for _ in range(n+1)]\n        for i in range(n+1):\n            dp[i][0] = True\n        for i in range(1, n+1):\n            for j in range(1, target+1):\n                if nums[i-1] <= j:\n                    dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i-1]]\n                else:\n                    dp[i][j] = dp[i-1][j]\n        return dp[n][target]\n    \n    return subset_sum(nums, target)\n\ndef g():\n    nums = [3, 5, 7, 9, 11]\n    target = 16\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 495,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two positive integers n and m, calculate the number of unique paths from the top-left corner to the bottom-right corner of an n x m grid.\n    You can only move down and right.\n\n    Example:\n    n = 3, m = 3\n    There are 6 unique paths from the top-left corner to the bottom-right corner.\n\n    Return the number of unique paths.\n    \"\"\"\n    dp = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            if i == 0 or j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[n-1][m-1]\n\n\ndef g() -> Tuple[int, int]:\n    \"\"\"\n    Generate two positive integers n and m.\n    \"\"\"\n    n = 3\n    m = 3\n    return n, m\n\n\nassert f(*g()) == 6\n",
        "idx_generation": 295,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the number of combinations of elements in the list that add up to the target.\n    \"\"\"\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for num in nums:\n        for i in range(num, target + 1):\n            dp[i] += dp[i - num]\n\n    return dp[target]\n\ndef g():\n    return [1, 2, 3], 4\n\nassert f(*g()) == 4\n\n",
        "idx_generation": 391,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value, determine if there exists a pair of elements in the array whose sum is equal to the target value.\n    \n    Example:\n    arr = [1, 2, 3, 4, 5, 6]\n    target = 8\n    \n    Output:\n    True\n    \n    Explanation:\n    There exists a pair of elements in the array [2, 6] whose sum is equal to the target value 8.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5, 6]\n    target = 8\n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 380,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n\n    Example:\n    Input:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 6\n\n    Output:\n    5\n    \"\"\"\n\n    def binary_search(nums: List[int], target: int, left: int, right: int) -> int:\n        if left > right:\n            return -1\n\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            return binary_search(nums, target, mid + 1, right)\n        else:\n            return binary_search(nums, target, left, mid - 1)\n\n    return binary_search(nums, target, 0, len(nums) - 1)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9], 6\n\nassert f(*g()) == 5\n\n",
        "idx_generation": 343,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of non-negative integers, where each represents the maximum jump length at that position, determine\n    the minimum number of jumps required to reach the last index.\n\n    Example:\n    Input: nums = [2, 3, 1, 1, 4]\n    Output: 2\n\n    Explanation:\n    We start at the first position and can jump a maximum of 2 steps. We can choose to jump 1 step or 2 steps to reach\n    the second position. From the second position, we can jump 1 step to reach the last index. Therefore, the minimum\n    number of jumps required is 2.\n    \"\"\"\n    if len(nums) <= 1:\n        return 0\n    \n    jumps = 0\n    curr_end = 0\n    curr_farthest = 0\n    \n    for i in range(len(nums) - 1):\n        curr_farthest = max(curr_farthest, i + nums[i])\n        \n        if i == curr_end:\n            jumps += 1\n            curr_end = curr_farthest\n    \n    return jumps\n\ndef g():\n    return [2, 3, 1, 1, 4]\n\nassert f(g()) == 2\n",
        "idx_generation": 46,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the nth Fibonacci number using recursion.\n    \"\"\"\n    if n <= 1:\n        return n\n    return f(n-1) + f(n-2)\n\ndef g() -> int:\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 175,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome.\"\"\"\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    def remove_chars(s, chars):\n        for char in chars:\n            s = s.replace(char, \"\")\n        return s\n\n    # Remove special characters and spaces from the string\n    s = remove_chars(s, [\",\", \".\", \" \", \"-\", \"_\"])\n\n    # Convert the string to lowercase\n    s = s.lower()\n\n    # Check if the modified string is a palindrome\n    return is_palindrome(s)\n\ndef g(s=\"A man, a plan, a canal. Panama.\"):\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 70,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer, count the number of set bits (1s) in its binary representation.\n    Return the count.\n    \"\"\"\n    count = 0\n    while n > 0:\n        if n & 1 == 1:\n            count += 1\n        n >>= 1\n    return count\n\ndef g(n = 10):\n    return n\n\nassert f(g()) == 2\n",
        "idx_generation": 316,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of unique combinations of bits that can be formed using n bits.\n\n    Example:\n    n = 3\n\n    Output:\n    8\n\n    Explanation:\n    With 3 bits, the possible combinations are:\n    000\n    001\n    010\n    011\n    100\n    101\n    110\n    111\n    So, the total number of combinations is 8.\n    \"\"\"\n\n    def count_combinations(n):\n        return 2 ** n\n\n    return count_combinations(n)\n\ndef g(n = 3):\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 113,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray with the constraint that no two numbers in the subarray are adjacent.\n    \n    Return the maximum sum.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n\n    Output:\n    9\n\n    Explanation:\n    The maximum sum of a subarray with the constraint is achieved by selecting [1, 3, 5] or [2, 4].\n    \"\"\"\n    if len(arr) == 0:\n        return 0\n    \n    if len(arr) == 1:\n        return arr[0]\n    \n    dp = [0] * len(arr)\n    dp[0] = arr[0]\n    dp[1] = max(arr[0], arr[1])\n\n    for i in range(2, len(arr)):\n        dp[i] = max(dp[i-1], dp[i-2] + arr[i])\n    \n    return dp[-1]\n\ndef g(arr=[1, 2, 3, 4, 5]):\n    return arr\n\nassert f(g()) == 9\n",
        "idx_generation": 499,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if there is a cycle in the given directed graph represented as an adjacency matrix\"\"\"\n    n = len(matrix)\n    visited = [0] * n\n\n    def dfs(node: int) -> bool:\n        visited[node] = 1\n        for neighbor in range(n):\n            if matrix[node][neighbor] == 1:\n                if visited[neighbor] == 1:\n                    return True\n                if visited[neighbor] == 0 and dfs(neighbor):\n                    return True\n        visited[node] = 2\n        return False\n\n    for node in range(n):\n        if visited[node] == 0 and dfs(node):\n            return True\n    return False\n\ndef g():\n    return [[0, 1, 0, 0, 0],\n            [0, 0, 1, 0, 0],\n            [0, 0, 0, 1, 0],\n            [0, 0, 0, 0, 1],\n            [1, 0, 0, 0, 0]]\n\nassert f(g()) == True\n",
        "idx_generation": 297,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of unique binary search trees that can be formed using the integers from 1 to n.\n\n    Return the total number of unique BSTs.\n\n    Example:\n    n = 3\n\n    Output:\n    5\n\n    Explanation:\n    The integers from 1 to 3 can form the following unique BSTs:\n    -   1       3     3      2      1\n        \\       /     /      / \\      \\\n         3     2     1      1   3      2\n        /     /       \\                 \\\n       2     1         2                 3\n    \"\"\"\n    def count_bsts(n):\n        if n <= 1:\n            return 1\n        else:\n            count = 0\n            for i in range(1, n+1):\n                count += count_bsts(i-1) * count_bsts(n-i)\n            return count\n    \n    return count_bsts(n)\n\ndef g():\n    return 3\n\nassert f(g()) == 5\n\n",
        "idx_generation": 399,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target number, determine if the target number is present in the array using binary search.\n    Return True if the target number is found, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\ndef g(arr = [1, 2, 3, 4, 5], target = 3):\n    \"\"\"\n    Return the input array and target number.\n    \"\"\"\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 380,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, sort the list in ascending order and return the sorted list.\n\n    Example:\n    Input: nums = [5, 2, 7, 1, 3]\n    Output: [1, 2, 3, 5, 7]\n\n    Hint: Use a sorting algorithm such as bubble sort, insertion sort, or merge sort.\n    \"\"\"\n\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr\n        mid = len(arr) // 2\n        left = merge_sort(arr[:mid])\n        right = merge_sort(arr[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        merged = []\n        i = j = 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n        while i < len(left):\n            merged.append(left[i])\n            i += 1\n        while j < len(right):\n            merged.append(right[j])\n            j += 1\n        return merged\n\n    return merge_sort(nums)\n\ndef g(nums=[5, 2, 7, 1, 3]):\n    return nums\n\nassert f(g()) == [1, 2, 3, 5, 7]\n",
        "idx_generation": 347,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine if a given number is a perfect square.\n    \"\"\"\n    return n**0.5 % 1 == 0\n\ndef g() -> int:\n    \"\"\"\n    Generate the smallest perfect square greater than 100.\n    \"\"\"\n    n = 11\n    while not f(n):\n        n += 1\n    return n**2\n\nassert f(g()) == True\n",
        "idx_generation": 48,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum sum of a subarray with the constraint that no two numbers in the subarray are adjacent.\n\n    Example:\n    nums = [4, 1, 1, 4, 2, 1]\n\n    Output:\n    9\n\n    Explanation:\n    The maximum sum of a subarray with the constraint is 9 (formed by the subarray [4, 1, 4]).\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    n = len(nums)\n\n    if n == 1:\n        return nums[0]\n\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, n):\n        dp[i] = max(nums[i] + dp[i-2], dp[i-1])\n\n    return dp[n-1]\n\ndef g():\n    \"\"\"\n    Generate an array of integers.\n    \"\"\"\n    return [4, 1, 1, 4, 2, 1]\n\nassert f(g()) == 9\n",
        "idx_generation": 176,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine whether it is a palindrome after removing exactly one character.\n    \"\"\"\n    n = len(s)\n    i = 0\n    j = n - 1\n    while i < j:\n        if s[i] != s[j]:\n            return s[i+1:j+1] == s[i+1:j+1][::-1] or s[i:j] == s[i:j][::-1]\n        i += 1\n        j -= 1\n    return True\n\ndef g(s='racecar'):\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 73,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two numbers in the list.\n\n    Parameters:\n    nums (List[int]): A list of integers.\n\n    Returns:\n    int: The maximum XOR value of any two numbers in the list.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n    return max_xor\n\ndef g(nums=[3, 10, 5, 25, 2, 8]):\n    return nums\n\nassert f(g()) == 28\n",
        "idx_generation": 321,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if a number is prime.\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g(n: int) -> int:\n    \"\"\"\n    Find the largest prime number less than or equal to n.\n    \"\"\"\n    while not f(n):\n        n -= 1\n    return n\n\nn = 100\nassert f(g(n))\n",
        "idx_generation": 114,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Graph:\n    def __init__(self, num_vertices: int):\n        self.num_vertices = num_vertices\n        self.adj_list = [[] for _ in range(num_vertices)]\n    \n    def add_edge(self, u: int, v: int):\n        self.adj_list[u].append(v)\n    \n    def is_cyclic_util(self, v: int, visited: List[bool], stack: List[bool]) -> bool:\n        visited[v] = True\n        stack[v] = True\n        \n        for neighbor in self.adj_list[v]:\n            if not visited[neighbor]:\n                if self.is_cyclic_util(neighbor, visited, stack):\n                    return True\n            elif stack[neighbor]:\n                return True\n        \n        stack[v] = False\n        return False\n    \n    def is_cyclic(self) -> bool:\n        visited = [False] * self.num_vertices\n        stack = [False] * self.num_vertices\n        \n        for v in range(self.num_vertices):\n            if not visited[v]:\n                if self.is_cyclic_util(v, visited, stack):\n                    return True\n        \n        return False\n\ndef f(edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given a list of directed edges, check if the graph contains a cycle.\n    \"\"\"\n    num_vertices = max(max(edge) for edge in edges) + 1\n    graph = Graph(num_vertices)\n    \n    for edge in edges:\n        u, v = edge\n        graph.add_edge(u, v)\n    \n    return graph.is_cyclic()\n\ndef g():\n    edges = [[0, 1], [1, 2], [2, 0]]\n    return edges\n\nassert f(g()) == True\n",
        "idx_generation": 298,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of distinct integers, return all possible permutations of the numbers.\n\n    Example:\n    nums = [1, 2, 3]\n    Output: [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]\n    \"\"\"\n\n    def backtrack(nums, temp, res):\n        if not nums:\n            res.append(temp[:])\n        for i in range(len(nums)):\n            temp.append(nums[i])\n            backtrack(nums[:i] + nums[i+1:], temp, res)\n            temp.pop()\n\n    res = []\n    backtrack(nums, [], res)\n\n    return res\n\ndef g(nums=[1, 2, 3]):\n    return [nums]\n\nassert f(*g()) == [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]\n\n",
        "idx_generation": 408,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of numbers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in a list.\n    \"\"\"\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return (nums, target)\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 383,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted (in non-decreasing order) array of distinct integers nums and a target value,\n    return the index where the target is found. If the target is not found, return the index where it would be if it were inserted in order.\n\n    You must write an algorithm with O(log n) runtime complexity.\n\n    Example:\n    Input: nums = [1,3,5,6], target = 5\n    Output: 2\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a tuple containing a sorted list of distinct integers and a target value.\n    \"\"\"\n    nums = [1, 3, 5, 6]\n    target = 5\n    return (nums, target)\n\nassert f(*g()) == 2\n",
        "idx_generation": 353,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int], x=10, y=5) -> bool:\n    \"\"\"Find two numbers in a given array that sum up to a target value.\"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] + arr[j] == x:\n                return True\n    return False\n\ndef g(arr=[2, 4, 6, 8, 10], x=10, y=5):\n    return arr\n\nassert f(g()) == True\n",
        "idx_generation": 49,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of non-negative integers, find a path from the top-left cell to the bottom-right cell\n    that minimizes the sum of all numbers along its path.\n    You can only move down or right at any point in time.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[m-1][n-1]\n\ndef g(grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 179,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string 's' consisting of lowercase and uppercase letters, return a new string where\n    the lowercase letters are followed by their corresponding uppercase letters.\n\n    Example:\n    s = 'aBcDeF'\n    output: 'aceBDF'\n\n    Explanation:\n    The lowercase letters in 's' are: 'a', 'c', 'e'\n    The uppercase letters in 's' are: 'B', 'D', 'F'\n    The resulting string is formed by concatenating the lowercase letters followed by the uppercase letters.\n    \"\"\"\n\n    lower = ''\n    upper = ''\n\n    for char in s:\n        if char.islower():\n            lower += char\n        else:\n            upper += char\n\n    return lower + upper\n\ndef g(s = 'aBcDeF'):\n    return s\n\nassert f(g()) == 'aceBDF'\n",
        "idx_generation": 79,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a power of 2.\n\n    Parameters:\n    n (int): The input integer.\n\n    Returns:\n    bool: True if n is a power of 2, False otherwise.\n    \"\"\"\n    if n == 0:\n        return False\n\n    return n & (n - 1) == 0\n\ndef g() -> int:\n    \"\"\"\n    Generate an integer that is a power of 2.\n\n    Returns:\n    int: An integer that is a power of 2.\n    \"\"\"\n    return 16\n\nassert f(g()) == True\n",
        "idx_generation": 321,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, m: int, k: int) -> bool:\n    \"\"\"\n    Determine if it is possible to arrange n objects in a line such that there are exactly m objects between any two \n    adjacent objects. Additionally, the first and last objects must be k positions apart.\n    \"\"\"\n    if n <= 0 or m < 0 or k < 0:\n        return False\n    \n    # Check if the given conditions are satisfied\n    if (n - 1) % (m + 1) == 0 and (n - 1) // (m + 1) >= k:\n        return True\n    else:\n        return False\n\ndef g(n=10, m=2, k=3):\n    return n, m, k\n\nassert f(*g())\n",
        "idx_generation": 124,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    Given a number of nodes and a list of directed edges between the nodes, determine if there is a cycle in the graph.\n\n    Example:\n    n = 4\n    edges = [[0, 1], [1, 2], [2, 3], [3, 1]]\n    output: True\n    Explanation: There is a cycle in the graph: 1 -> 2 -> 3 -> 1\n    \"\"\"\n\n    graph = [[] for _ in range(n)]\n    visited = [False] * n\n    recursion_stack = [False] * n\n\n    for edge in edges:\n        u, v = edge\n        graph[u].append(v)\n\n    def is_cycle(node):\n        visited[node] = True\n        recursion_stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if is_cycle(neighbor):\n                    return True\n            elif recursion_stack[neighbor]:\n                return True\n\n        recursion_stack[node] = False\n        return False\n\n    for node in range(n):\n        if not visited[node]:\n            if is_cycle(node):\n                return True\n\n    return False\n\ndef g(n=4, edges=[[0, 1], [1, 2], [2, 3], [3, 1]]):\n    return n, edges\n\nassert f(*g()) == True\n",
        "idx_generation": 302,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of different ways to choose k elements from the set {1, 2, ..., n}.\n\n    Example:\n    n = 5, k = 3\n\n    Output:\n    10\n\n    Explanation:\n    There are 10 different ways to choose 3 elements from the set {1, 2, 3, 4, 5}:\n    - (1, 2, 3)\n    - (1, 2, 4)\n    - (1, 2, 5)\n    - (1, 3, 4)\n    - (1, 3, 5)\n    - (1, 4, 5)\n    - (2, 3, 4)\n    - (2, 3, 5)\n    - (2, 4, 5)\n    - (3, 4, 5)\n\n    Hint: Use recursion and dynamic programming to solve this problem.\n    \"\"\"\n\n    def choose(n: int, k: int) -> int:\n        if k == 0 or k == n:\n            return 1\n        return choose(n-1, k-1) + choose(n-1, k)\n\n    return choose(n, k)\n\ndef g(n=5, k=3):\n    return (n, k)\n\nassert f(*g()) == 10\n",
        "idx_generation": 412,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the second smallest number.\n\n    Example:\n    nums = [5, 3, 1, 7, 2]\n\n    Output:\n    2\n\n    Explanation:\n    The second smallest number in the list is 2.\n\n    Hint: You can solve this problem by sorting the list and returning the second element.\n    \"\"\"\n\n    nums.sort()\n    return nums[1]\n\ndef g(nums=[5, 3, 1, 7, 2]):\n    return nums\n\nassert f(g()) == 2\n\n",
        "idx_generation": 386,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a given number is a perfect square.\"\"\"\n    if n < 0:\n        return False\n    if n == 0 or n == 1:\n        return True\n\n    left, right = 1, n\n    while left <= right:\n        mid = left + (right - left) // 2\n        if mid * mid == n:\n            return True\n        elif mid * mid < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef g(n: int) -> int:\n    \"\"\"Generate a perfect square number.\"\"\"\n    return n * n\n\nassert f(g(9))\n",
        "idx_generation": 360,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if the given matrix is a magic square.\n\n    A magic square is a square matrix where the sum of each row, each column, and both diagonals are equal.\n\n    Sample Input:\n    matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n\n    Sample Output:\n    True\n    \"\"\"\n    n = len(matrix)\n\n    target_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for j in range(n):\n        col_sum = 0\n        for i in range(n):\n            col_sum += matrix[i][j]\n        if col_sum != target_sum:\n            return False\n\n    # Check diagonal 1\n    diagonal_sum_1 = 0\n    for i in range(n):\n        diagonal_sum_1 += matrix[i][i]\n    if diagonal_sum_1 != target_sum:\n        return False\n\n    # Check diagonal 2\n    diagonal_sum_2 = 0\n    for i in range(n):\n        diagonal_sum_2 += matrix[i][n - 1 - i]\n    if diagonal_sum_2 != target_sum:\n        return False\n\n    return True\n\ndef g(matrix=[[2, 7, 6], [9, 5, 1], [4, 3, 8]]):\n    return matrix\n\nassert f(g()) == True\n",
        "idx_generation": 49,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of positive integers and a target sum, return the minimum number of elements from the list that are required to sum up to the target.\n\n    Example:\n    nums = [2, 4, 6, 8]\n    target = 14\n    \n    Output:\n    2\n    Explanation: The minimum number of elements required to sum up to 14 is 2 (6 + 8).\n\n    \"\"\"\n\n    memo = {}\n\n    def recurse(curr_sum, idx):\n        if curr_sum == target:\n            return 0\n        if curr_sum > target or idx >= len(nums):\n            return float('inf')\n        if (curr_sum, idx) in memo:\n            return memo[(curr_sum, idx)]\n\n        take = 1 + recurse(curr_sum + nums[idx], idx)\n        skip = recurse(curr_sum, idx + 1)\n\n        memo[(curr_sum, idx)] = min(take, skip)\n        return memo[(curr_sum, idx)]\n\n    result = recurse(0, 0)\n    return result if result != float('inf') else -1\n\ndef g() -> Tuple[List[int], int]:\n    return ([2, 4, 6, 8], 14)\n\nassert f(*g()) == 2\n",
        "idx_generation": 180,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], target: str) -> int:\n    \"\"\"\n    Count Occurrences of Target String\n\n    Given a list of words, count the number of times the target string appears in the list.\n\n    Example:\n    words = [\"apple\", \"banana\", \"apple\", \"cherry\", \"apple\"]\n    target = \"apple\"\n    output: 3\n\n    Explanation:\n    The target string \"apple\" appears 3 times in the list of words.\n    \"\"\"\n    count = 0\n    for word in words:\n        if target in word:\n            count += 1\n    return count\n\ndef g(words = [\"apple\", \"banana\", \"apple\", \"cherry\", \"apple\"], target = \"apple\"):\n    return words, target\n\nassert f(*g()) == 3\n",
        "idx_generation": 85,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR value between two numbers in the array.\n    \"\"\"\n    maxXOR = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixSet = set()\n        for num in nums:\n            prefixSet.add(num & mask)\n        \n        maxXORCandidate = maxXOR | (1 << i)\n        for prefix in prefixSet:\n            if prefix ^ maxXORCandidate in prefixSet:\n                maxXOR = maxXORCandidate\n                break\n    \n    return maxXOR\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n",
        "idx_generation": 322,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(a: int, b: int, c: int) -> bool:\n    \"\"\"\n    Check if the given values satisfy the equation a^2 + b^2 = c^2.\n    \"\"\"\n    return a**2 + b**2 == c**2\n\ndef g(a=3, b=4):\n    c = 5\n    return a, b, c\n\nassert f(*g()) == True\n",
        "idx_generation": 140,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, determine if there is a path from a\n    given start node to a given end node.\n\n    Example:\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 0 to node 3 in the given directed graph.\n\n    Hint: Use depth-first search (DFS) to traverse the graph and check for a path.\n    \"\"\"\n\n    def dfs(graph, visited, current, end):\n        if current == end:\n            return True\n        visited[current] = True\n        for i in range(len(graph)):\n            if graph[current][i] == 1 and not visited[i]:\n                if dfs(graph, visited, i, end):\n                    return True\n        return False\n\n    visited = [False] * len(graph)\n    return dfs(graph, visited, start, end)\n\ndef g(graph=[[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [0, 0, 0, 0]], start=0, end=3):\n    return graph, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 306,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of subarrays with an odd sum.\n\n    Return the count of subarrays with an odd sum.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    9\n\n    Explanation:\n    The subarrays with an odd sum are: [1], [1, 2, 3], [1, 2, 3, 4, 5], [2, 3], [2, 3, 4, 5], [3, 4, 5], [3, 4], [4, 5], [5].\n    \"\"\"\n\n    count = 0\n    prefix_sum = 0\n    odd_count = [1, 0]\n    result = 0\n\n    for num in nums:\n        prefix_sum += num\n        odd_count[prefix_sum % 2] += 1\n        result += odd_count[prefix_sum % 2 ^ 1]\n        count += odd_count[prefix_sum % 2]\n\n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 9\n",
        "idx_generation": 413,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int]) -> int:\n    \"\"\"\n    Given a list of numbers, find the maximum product of any three numbers in the list.\n\n    Example:\n    numbers = [1, 2, 3, 4, 5]\n\n    Output:\n    60 (since the maximum product is 4 * 5 * 3 = 60)\n    \"\"\"\n\n    numbers.sort()\n    return max(numbers[-1] * numbers[-2] * numbers[-3], numbers[0] * numbers[1] * numbers[-1])\n\ndef g(numbers: List[int] = [1, 2, 3, 4, 5]) -> List[int]:\n    \"\"\"\n    Generate a list of numbers.\n    \"\"\"\n    return numbers\n\nassert f(g()) == 60\n",
        "idx_generation": 388,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of distinct integers nums and a target value, return the index if the target is found.\n    If not, return the index where it would be if it were inserted in order.\n\n    Example:\n    nums = [1,3,5,6], target = 5\n    Output: 2\n\n    Explanation:\n    5 is found at index 2 in the array.\n\n    nums = [1,3,5,6], target = 2\n    Output: 1\n\n    Explanation:\n    2 is not found in the array, so it would be inserted at index 1.\n\n    \"\"\"\n\n    left = 0\n    right = len(nums)\n\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid\n\n    return left\n\ndef g() -> (List[int], int):\n    nums = [1, 3, 5, 6]\n    target = 5\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 363,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if n is a prime number and its digits are in increasing order.\"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    n_str = str(n)\n    if not is_prime(n):\n        return False\n    \n    for i in range(len(n_str) - 1):\n        if n_str[i] >= n_str[i+1]:\n            return False\n    \n    return True\n\ndef g():\n    return 2357\n\nassert f(g()) == True\n",
        "idx_generation": 57,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a subset whose sum is equal to the target.\n    This function uses dynamic programming to calculate the sum of all possible subsets.\n    \"\"\"\n    dp = [False] * (target + 1)\n    dp[0] = True\n    \n    for num in nums:\n        for i in range(target, num - 1, -1):\n            dp[i] = dp[i] or dp[i - num]\n    \n    return dp[target]\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5, 6], target: int = 10):\n    \"\"\"\n    Generate a list of integers and a target number for the function f.\n    \"\"\"\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 181,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string is a palindrome.\"\"\"\n    def is_palindrome(string):\n        if string == string[::-1]:\n            return True\n        return False\n    \n    return is_palindrome(s)\n\ndef g():\n    return \"racecar\"\n\nassert f(g()) == True\n",
        "idx_generation": 85,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers, return the array with the two single numbers that appear only once.\n    \"\"\"\n    xor = 0\n    for num in nums:\n        xor ^= num\n    \n    diffBit = xor & (-xor)\n    \n    num1 = 0\n    num2 = 0\n    \n    for num in nums:\n        if num & diffBit:\n            num1 ^= num\n        else:\n            num2 ^= num\n    \n    return [num1, num2]\n\ndef g() -> List[int]:\n    nums = [1, 2, 1, 3, 2, 5]\n    return nums\n\nassert f(g()) == [3, 5]\n",
        "idx_generation": 322,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of elements that are divisible by both 3 and 5.\n    \"\"\"\n    count = 0\n    for num in nums:\n        if num % 3 == 0 and num % 5 == 0:\n            count += 1\n    return count\n\ndef g() -> List[int]:\n    return [3, 7, 15, 10, 9, 30, 25]\n\nassert f(g()) == 2\n\n",
        "idx_generation": 151,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph, determine if it is a tree.\n\n    An undirected graph is a tree if it is connected and contains no cycles.\n\n    Parameters:\n    graph (List[List[int]]): The adjacency list representation of the graph.\n\n    Returns:\n    bool: True if the graph is a tree, False otherwise.\n    \"\"\"\n\n    def dfs(node, parent):\n        visited.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor == parent:\n                continue\n            if neighbor in visited:\n                return False\n            if not dfs(neighbor, node):\n                return False\n\n        return True\n\n    n = len(graph)\n    visited = set()\n\n    if not dfs(0, -1):\n        return False\n\n    if len(visited) != n:\n        return False\n\n    return True\n\ndef g(graph=[\n    [1, 2],\n    [0, 3, 4],\n    [0, 5],\n    [1],\n    [1],\n    [2]\n]) -> List[List[int]]:\n    return graph\n\nassert f(g()) == True\n\n",
        "idx_generation": 314,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Given two integers n and k, generate all possible combinations of k numbers out of the range [1, n].\n\n    Args:\n    - n: An integer representing the range of numbers.\n    - k: An integer representing the length of combinations.\n\n    Returns:\n    - A list of all possible combinations of k numbers.\n\n    Example:\n    n = 4\n    k = 2\n\n    Output:\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n\n    Explanation:\n    The possible combinations of 2 numbers from the range [1, 4] are [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]].\n    \"\"\"\n\n    def backtrack(start, combination):\n        if len(combination) == k:\n            result.append(combination[:])\n            return\n        for i in range(start, n + 1):\n            combination.append(i)\n            backtrack(i + 1, combination)\n            combination.pop()\n\n    result = []\n    backtrack(1, [])\n    return result\n\ndef g():\n    return 4, 2\n\nassert f(*g()) == [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n",
        "idx_generation": 417,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of numbers and an integer k, find the kth largest element in the list.\n\n    Example:\n    numbers = [3, 2, 1, 5, 6, 4]\n    k = 2\n\n    Output:\n    5 (since the 2nd largest element is 5)\n    \"\"\"\n\n    numbers.sort(reverse=True)\n    return numbers[k-1]\n\ndef g(numbers: List[int] = [3, 2, 1, 5, 6, 4], k: int = 2) -> List[int]:\n    \"\"\"\n    Generate a list of numbers and an integer k.\n    \"\"\"\n    return numbers, k\n\nassert f(*g()) == 5\n",
        "idx_generation": 388,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, find the index of the target in the list using binary search.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output:\n    2\n\n    Explanation:\n    The target 5 is located at index 2 in the sorted list.\n\n    Hint: Use binary search to find the index of the target.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 366,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Calculate the sum of the squares of the even numbers in the given list.\"\"\"\n    return sum([num ** 2 for num in nums if num % 2 == 0])\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == 220\n",
        "idx_generation": 59,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n    \"\"\"\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n\n    memo = [0] * (n + 1)\n    memo[1] = 1\n    memo[2] = 2\n\n    for i in range(3, n + 1):\n        memo[i] = memo[i - 1] + memo[i - 2]\n\n    return memo[n]\n\ndef g(n: int = 4):\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return n\n\nassert f(g()) == 5\n\n",
        "idx_generation": 189,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], pattern: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a pattern, find all the words from the list that match the pattern.\n\n    The pattern consists of lowercase English letters and a single dot '.'.\n    The dot matches any single letter.\n\n    Return the list of matching words.\n\n    Example:\n    words = [\"abc\", \"def\", \"ghi\", \"jkl\"]\n    pattern = \"a..\"\n\n    Output:\n    [\"abc\"]\n\n    Explanation:\n    The pattern \"a..\" matches the word \"abc\".\n    \"\"\"\n    matching_words = []\n\n    for word in words:\n        if len(word) != len(pattern):\n            continue\n\n        is_match = True\n\n        for i in range(len(word)):\n            if pattern[i] != '.' and pattern[i] != word[i]:\n                is_match = False\n                break\n\n        if is_match:\n            matching_words.append(word)\n\n    return matching_words\n\ndef g(words=[\"abc\", \"def\", \"ghi\", \"jkl\"], pattern=\"a..\"):\n    return words, pattern\n\nassert f(*g()) == [\"abc\"]\n",
        "idx_generation": 88,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Count the number of set bits (bits with a value of 1) in an integer 'n'.\n\n    Example:\n    n = 12\n\n    Output:\n    2 (the binary representation of 12 is 1100, which has 2 set bits)\n    \"\"\"\n    count = 0\n\n    while n > 0:\n        count += n & 1\n        n >>= 1\n\n    return count\n\ndef g():\n    n = 12\n    return n\n\nassert f(g()) == 2\n",
        "idx_generation": 328,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Calculate the sum of all prime numbers in a given list of integers.\n    \"\"\"\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    prime_sum = 0\n    for num in nums:\n        if is_prime(num):\n            prime_sum += num\n    return prime_sum\n\ndef g() -> List[int]:\n    return [2, 5, 8, 11, 15, 20, 23]\n\nassert f(g()) == 41\n\n",
        "idx_generation": 151,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(adj_list: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given an adjacency list representing a directed graph, check if there is a valid path from the start node to the end node.\n    \"\"\"\n    def dfs(node, visited):\n        if node == end:\n            return True\n        \n        visited.add(node)\n        \n        for neighbor in adj_list[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited):\n                    return True\n        \n        return False\n    \n    visited = set()\n    return dfs(start, visited)\n\ndef g() -> Tuple[List[List[int]], int, int]:\n    \"\"\"\n    Generate an adjacency list, start node, and end node for the puzzle.\n    \"\"\"\n    adj_list = [[1, 2], [3], [4], [2], []]\n    start = 0\n    end = 4\n    return adj_list, start, end\n\nassert f(g()[0], g()[1], g()[2]) == True\n\n",
        "idx_generation": 322,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Given two integers n and k, generate all possible combinations of k numbers out of the range [1, n].\n    Return a list of lists, where each inner list represents a combination.\n\n    Example:\n    Input: n = 4, k = 2\n    Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n\n    Hint: Use backtracking to generate all combinations.\n    \"\"\"\n\n    def backtrack(start, curr_comb):\n        if len(curr_comb) == k:\n            result.append(curr_comb[:])\n            return\n        for i in range(start, n + 1):\n            curr_comb.append(i)\n            backtrack(i + 1, curr_comb)\n            curr_comb.pop()\n\n    result = []\n    backtrack(1, [])\n    return result\n\ndef g(n: int = 4, k: int = 2) -> List[int]:\n    \"\"\"\n    Generate two integers n and k for the function f.\n    \"\"\"\n    return n, k\n\nassert f(*g()) == [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n",
        "idx_generation": 419,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(numbers: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of numbers, sort the list in ascending order.\n\n    Example:\n    Input:\n    numbers = [4, 2, 6, 1, 3]\n\n    Output:\n    [1, 2, 3, 4, 6]\n    \"\"\"\n    numbers.sort()\n    return numbers\n\ndef g():\n    numbers = [4, 2, 6, 1, 3]\n    return numbers\n\nassert f(g()) == [1, 2, 3, 4, 6]\n",
        "idx_generation": 388,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers, determine if there are two numbers in the array that add up to the target value.\n\n    Example:\n    arr = [2, 4, 6, 8, 10]\n    target = 14\n\n    Output:\n    True\n\n    Explanation:\n    There are two numbers in the array, 4 and 10, that add up to the target value of 14.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted array and a target value for the puzzle.\n    \"\"\"\n    arr = [1, 3, 5, 7, 9, 11]\n    target = 14\n    return arr, target\n\nassert f(g()[0], g()[1]) == True\n",
        "idx_generation": 372,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> List[List[int]]:\n    \"\"\"Generate a matrix of size n x m with elements in increasing order from 1 to n*m.\"\"\"\n    matrix = [[0] * m for _ in range(n)]\n    num = 1\n    for i in range(n):\n        for j in range(m):\n            matrix[i][j] = num\n            num += 1\n    return matrix\n\ndef g(n=3, m=4):\n    return n, m\n\nassert f(*g()) == [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]\n",
        "idx_generation": 60,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    arr = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    Output:\n    4\n\n    Explanation:\n    The longest increasing subsequence is [2, 3, 7, 101], with a length of 4.\n\n    Hint: You can solve this problem using dynamic programming, where you keep track of the longest increasing subsequence ending at each index.\n    \"\"\"\n    if not arr:\n        return 0\n    \n    dp = [1] * len(arr)\n    \n    for i in range(1, len(arr)):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g(arr=[10, 9, 2, 5, 3, 7, 101, 18]):\n    return arr\n\nassert f(g()) == 4\n",
        "idx_generation": 190,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, p: str) -> bool:\n    \"\"\"\n    Given a string s and a pattern p, check if s matches the pattern p.\n    \n    The pattern p consists of lowercase English letters and dots (.).\n    The dot (.) matches any single character.\n    \n    Return True if s matches the pattern p, False otherwise.\n    \n    Example:\n    s = \"apple\"\n    p = \"a..le\"\n    \n    Output:\n    True\n    \n    Explanation:\n    The pattern \"a..le\" matches the string \"apple\" since the dots can represent any single characters.\n    \"\"\"\n    if len(s) != len(p):\n        return False\n\n    for i in range(len(s)):\n        if p[i] != '.' and p[i] != s[i]:\n            return False\n\n    return True\n\ndef g(s=\"apple\", p=\"a..le\"):\n    return s, p\n\nassert f(*g()) == True\n\n",
        "idx_generation": 91,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two elements in the list.\n\n    Example:\n    Input:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value can be obtained by XORing 5 and 25, which results in 28.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor_val = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor_val)\n\n    return max_xor\n\ndef g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n",
        "idx_generation": 332,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer, return True if it is a prime number, and False otherwise.\n    \"\"\"\n    if n < 2:\n        return False\n    \n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    \n    return True\n\ndef g():\n    n = 17\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 156,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> int:\n    \"\"\"\n    Given the root of a binary tree, return the sum of all left leaves.\n    A left leaf is a leaf node that has a left child.\n    \n    Example:\n    Input: root = [3,9,20,null,null,15,7]\n    Output: 24\n    Explanation: There are two left leaves in the binary tree, with values 9 and 15 respectively. The sum of these leaves is 24.\n    \"\"\"\n    if not root:\n        return 0\n    \n    def dfs(node: TreeNode, is_left: bool) -> int:\n        if not node:\n            return 0\n        if not node.left and not node.right and is_left:\n            return node.val\n        return dfs(node.left, True) + dfs(node.right, False)\n    \n    return dfs(root, False)\n\ndef g():\n    \"\"\"\n    Returns a sample binary tree.\n\n    The tree looks like this:\n\n            3\n           / \\\n          9  20\n            /  \\\n           15   7\n    \"\"\"\n    root = TreeNode(3)\n    root.left = TreeNode(9)\n    root.right = TreeNode(20)\n    root.right.left = TreeNode(15)\n    root.right.right = TreeNode(7)\n    return root\n\nassert f(g()) == 24\n",
        "idx_generation": 324,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target sum,\n    return all possible combinations of numbers that add up to the target sum.\n    Each number in the list can be used multiple times.\n\n    Example:\n    nums = [2, 3, 6, 7]\n    target = 7\n\n    Output:\n    [\n        [2, 2, 3],\n        [7]\n    ]\n\n    Explanation:\n    The combinations that add up to 7 are [2, 2, 3] and [7].\n    \"\"\"\n\n    def combination_sum(nums: List[int], target: int, curr: List[int], index: int, res: List[List[int]]):\n        if target == 0:\n            res.append(curr[:])\n            return\n        \n        if target < 0 or index == len(nums):\n            return\n        \n        curr.append(nums[index])\n        combination_sum(nums, target - nums[index], curr, index, res)\n        curr.pop()\n        combination_sum(nums, target, curr, index + 1, res)\n    \n    res = []\n    combination_sum(nums, target, [], 0, res)\n    return res\n\ndef g() -> List[int]:\n    nums = [2, 3, 6, 7]\n    target = 7\n    return nums, target\n\nassert f(*g()) == [[2, 2, 3], [7]]\n\n",
        "idx_generation": 422,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in non-decreasing order using the bubble sort algorithm.\n    \"\"\"\n    n = len(nums)\n    \n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    \n    return nums\n\ndef g():\n    \"\"\"\n    Generate a list of integers for testing.\n    \"\"\"\n    return [9, 4, 7, 2, 1, 5]\n\nassert f(g()) == [1, 2, 4, 5, 7, 9]\n",
        "idx_generation": 389,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array arr of distinct integers and a target value, find the index of the target in the array.\n    If the target is not found, return -1.\n\n    Example:\n    arr = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]\n    target = 16\n\n    Output:\n    4 (since the target 16 is found at index 4 in the array)\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        \n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    arr = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]\n    target = 16\n    return arr, target\n\nassert f(*g()) == 4\n\n",
        "idx_generation": 375,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine if a given number is a power of two.\n    \"\"\"\n    if n == 0:\n        return False\n    while n != 1:\n        if n % 2 != 0:\n            return False\n        n = n // 2\n    return True\n\ndef g(n = 16):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 60,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer 'n', return the number of ways to climb a staircase with 'n' steps. \n    You can climb either 1 or 2 steps at a time.\n    \n    Example:\n    n = 4\n    \n    Output:\n    5 (1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2)\n    \"\"\"\n    if n <= 1:\n        return 1\n    dp = [0] * (n+1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n+1):\n        dp[i] = dp[i-1] + dp[i-2]\n    return dp[n]\n\ndef g():\n    return 4\n\nassert f(g()) == 5\n",
        "idx_generation": 194,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string 's', reverse the order of words in the string.\n\n    Example:\n    s = \"Hello World! This is a test.\"\n    \n    Output:\n    \"test. a is This World! Hello\"\n    \"\"\"\n\n    words = s.split()\n    reversed_words = words[::-1]\n    reversed_sentence = \" \".join(reversed_words)\n\n    return reversed_sentence\n\ndef g() -> str:\n    return \"Hello World! This is a test.\"\n\nassert f(g()) == \"test. a is This World! Hello\"\n",
        "idx_generation": 94,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a pair of numbers that\n    when combined using bitwise XOR operation, results in the target number.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n\n    Output:\n    True\n\n    Explanation:\n    The pair (2, 4) when combined using XOR operation results in 6.\n\n    Hint: Use a set to store the complement of each number and check if the complement exists in the set.\n    \"\"\"\n\n    complements = set()\n\n    for num in nums:\n        complement = target ^ num\n\n        if complement in complements:\n            return True\n\n        complements.add(num)\n\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5], target=6):\n    return nums, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 336,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if it is a magic square. A magic square is a square matrix in which the sum of every row, every column, and both diagonals is equal.\n\n    Sample Input:\n    matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n\n    Sample Output:\n    True\n    \"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for j in range(n):\n        column_sum = sum(matrix[i][j] for i in range(n))\n        if column_sum != target_sum:\n            return False\n\n    # Check diagonals\n    diagonal_sum1 = sum(matrix[i][i] for i in range(n))\n    diagonal_sum2 = sum(matrix[i][n-i-1] for i in range(n))\n    if diagonal_sum1 != target_sum or diagonal_sum2 != target_sum:\n        return False\n\n    return True\n\ndef g():\n    return [[[2, 7, 6], [9, 5, 1], [4, 3, 8]]]\n\nassert f(*g())\n\n",
        "idx_generation": 162,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency matrix, check if there is a path from start to end.\n    Return True if there is a path, False otherwise.\n    \"\"\"\n    visited = [False] * len(graph)\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if not visited[node]:\n            visited[node] = True\n            neighbors = [i for i, val in enumerate(graph[node]) if val == 1]\n            stack.extend(neighbors)\n\n    return False\n\ndef g(start=0, end=3):\n    graph = [[0, 1, 1, 0],\n             [1, 0, 0, 1],\n             [1, 0, 0, 0],\n             [0, 1, 0, 0]]\n    return graph, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 325,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique BSTs (binary search trees) that can be formed with n nodes.\n\n    Example:\n    n = 3\n\n    Output:\n    5\n\n    Explanation:\n    There are 5 unique BSTs that can be formed with 3 nodes:\n    1.     1         3     3      2      1\n         \\       /     /      / \\      \\\n          3     2     1      1   3      2\n         /     /       \\                 \\\n        2     1         2                 3\n    \"\"\"\n\n    def num_trees(n: int, memo: List[int]) -> int:\n        if n == 0 or n == 1:\n            return 1\n        \n        if memo[n] != 0:\n            return memo[n]\n        \n        count = 0\n        for i in range(1, n+1):\n            count += num_trees(i-1, memo) * num_trees(n-i, memo)\n        \n        memo[n] = count\n        return memo[n]\n    \n    memo = [0] * (n + 1)\n    return num_trees(n, memo)\n\ndef g() -> int:\n    n = 3\n    return n\n\nassert f(g()) == 5\n\n",
        "idx_generation": 422,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers, find the index of the target number using binary search.\n    If the target number is not found, return -1.\n\n    Example:\n    Input:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 6\n\n    Output: 5\n\n    Explanation: The target number 6 is found at index 5 in the list.\n    \"\"\"\n\n    def binary_search(nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return -1\n\n    return binary_search(nums, target)\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 6\n    return nums, target\n\nassert f(*g()) == 5\n\n",
        "idx_generation": 391,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Determine if there exists a subarray in the list of integers nums that sums up to the target.\n    Return True if such subarray exists, otherwise return False.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5], target = 9\n    Output: True\n\n    Explanation: The subarray [2, 3, 4] sums up to the target 9.\n\n    Hint: Use a sliding window approach to keep track of the current sum of the subarray.\n    \"\"\"\n    left = 0\n    current_sum = 0\n    for right in range(len(nums)):\n        current_sum += nums[right]\n        while current_sum > target:\n            current_sum -= nums[left]\n            left += 1\n        if current_sum == target:\n            return True\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5], target=9):\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 394,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, a=6, b=168) -> bool:\n    \"\"\"Determine if n is a multiple of both a and b\"\"\"\n    return n % a == 0 and n % b == 0\ndef g(a=6, b=168):\n    return a * b\nassert f(g()) == True\n",
        "idx_generation": 60,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the nth Fibonacci number.\"\"\"\n    if n <= 1:\n        return n\n    return f(n-1) + f(n-2)\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 5\n",
        "idx_generation": 197,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if a given string is a palindrome or not.\n    \"\"\"\n    return s == s[::-1]\n\ndef g():\n    s = \"racecar\"\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 97,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Count the number of set bits (1s) in the binary representation of a given integer.\n    \"\"\"\n    count = 0\n    while n != 0:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g():\n    n = 42\n    return (n,)\n\nassert f(*g()) == 3\n",
        "idx_generation": 337,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers.\n\n    Sample input:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Sample output:\n    [0, 1]\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g():\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 163,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers representing elevations, find the minimum number of steps required to go from the top-left corner to the bottom-right corner, only moving down or right.\n\n    Args:\n    - grid: A 2D list of integers representing the grid.\n\n    Returns:\n    - The minimum number of steps required to reach the bottom-right corner.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n\n",
        "idx_generation": 327,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique combinations that sum up to a target number.\n    \"\"\"\n    def backtrack(start, target):\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        count = 0\n        for i in range(start, len(nums)):\n            count += backtrack(i, target - nums[i])\n        return count\n    \n    target = sum(nums)\n    return backtrack(0, target)\n\ndef g():\n    nums = [2, 4, 6]\n    return (nums,)\n\nassert f(*g()) == 7\n",
        "idx_generation": 426,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two numbers in the list.\n    \"\"\"\n    nums.sort()\n    return max(nums[-1] * nums[-2], nums[0] * nums[1])\n\ndef g():\n    return [5, 2, 3, 8, 9, 1]\n\nassert f(g()) == 72\n\n",
        "idx_generation": 391,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, sort the list in non-decreasing order.\n\n    Args:\n    nums (List[int]): The list of integers to be sorted.\n\n    Returns:\n    List[int]: The sorted list of integers.\n    \"\"\"\n\n    def merge_sort(nums):\n        if len(nums) <= 1:\n            return nums\n\n        mid = len(nums) // 2\n        left = merge_sort(nums[:mid])\n        right = merge_sort(nums[mid:])\n\n        merged = merge(left, right)\n        return merged\n\n    def merge(left, right):\n        merged = []\n        i, j = 0, 0\n\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n\n        while i < len(left):\n            merged.append(left[i])\n            i += 1\n\n        while j < len(right):\n            merged.append(right[j])\n            j += 1\n\n        return merged\n\n    return merge_sort(nums)\n\ndef g(nums=[5, 2, 8, 1, 9, 3, 7]):\n    \"\"\"\n    Generate a list of integers for sorting.\n    \"\"\"\n    return (nums,)\n\nassert f(*g()) == [1, 2, 3, 5, 7, 8, 9]\n",
        "idx_generation": 396,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum element in the matrix.\n\n    Sample input:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Sample output:\n    9\n\n    Explanation: The maximum element in the matrix is 9.\n    \"\"\"\n\n    max_element = float('-inf')\n\n    for row in matrix:\n        for num in row:\n            max_element = max(max_element, num)\n\n    return max_element\n\ndef g(matrix: List[List[int]] = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return (matrix,)\n\nassert f(*g()) == 9\n\n",
        "idx_generation": 62,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the factorial of n.\"\"\"\n    if n == 0:\n        return 1\n    return n * f(n-1)\n\ndef g(n=4):\n    return n\n\nassert f(g()) == 24\n",
        "idx_generation": 197,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Given two strings s1 and s2, check if s2 is a rotated version of s1.\n\n    Return True if s2 is a rotated version of s1, otherwise return False.\n\n    Example:\n    s1 = \"abcd\"\n    s2 = \"cdab\"\n\n    Output:\n    True\n\n    Explanation:\n    s2 is a rotated version of s1, with the rotation \"cdab\" being equivalent to a rotation of \"abcd\".\n    \"\"\"\n\n    if len(s1) != len(s2):\n        return False\n\n    s1 += s1\n\n    if s2 in s1:\n        return True\n    else:\n        return False\n\ndef g(s1='abcd', s2='cdab'):\n    \"\"\"\n    Generate two strings where s2 is a rotated version of s1.\n    \"\"\"\n    return s1, s2\n\nassert f(*g()) == True\n",
        "idx_generation": 99,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, count the number of set bits (1s) in its binary representation.\n\n    Example:\n    n = 10\n\n    Output:\n    2\n\n    Explanation:\n    The binary representation of 10 is 1010, which contains 2 set bits.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g():\n    return 10\n\nassert f(g()) == 2\n\n",
        "idx_generation": 339,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if it is a magic square.\n    A magic square is a square matrix where the sum of every row, column, and diagonal is the same.\n    \"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check columns\n    for j in range(n):\n        column_sum = sum(matrix[i][j] for i in range(n))\n        if column_sum != target_sum:\n            return False\n    \n    # Check diagonals\n    diagonal_sum_1 = sum(matrix[i][i] for i in range(n))\n    diagonal_sum_2 = sum(matrix[i][n-i-1] for i in range(n))\n    if diagonal_sum_1 != target_sum or diagonal_sum_2 != target_sum:\n        return False\n    \n    return True\n\ndef g(matrix: List[List[int]]):\n    return matrix\n\nassert f(g([[2, 7, 6], [9, 5, 1], [4, 3, 8]]))\n",
        "idx_generation": 165,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Node:\n    def __init__(self, val: int, children: List['Node'] = None):\n        self.val = val\n        self.children = children if children else []\n\ndef f(root: 'Node') -> int:\n    \"\"\"\n    Given the root of a tree, return the maximum depth of the tree.\n    The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n    Example:\n    root = Node(1, [Node(2, [Node(3), Node(4)]), Node(5)])\n\n                1\n               / \\\n              2   5\n             / \\\n            3   4\n\n    Output:\n    3 (the maximum depth is 3, as the longest path is 1 -> 2 -> 4)\n    \"\"\"\n    if not root:\n        return 0\n    \n    max_depth = 0\n    for child in root.children:\n        max_depth = max(max_depth, f(child))\n    \n    return max_depth + 1\n\ndef g() -> 'Node':\n    root = Node(1, [Node(2, [Node(3), Node(4)]), Node(5)])\n    return root\n\nassert f(g()) == 3\n",
        "idx_generation": 329,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, determine the number of ways to climb to the top of a staircase by taking either 1 or 2 steps at a time.\n\n    Example:\n    n = 4\n\n    Output:\n    5\n\n    Explanation:\n    There are 5 ways to climb to the top of the staircase:\n    1. 1 step + 1 step + 1 step + 1 step\n    2. 1 step + 1 step + 2 steps\n    3. 1 step + 2 steps + 1 step\n    4. 2 steps + 1 step + 1 step\n    5. 2 steps + 2 steps\n    \"\"\"\n\n    if n <= 2:\n        return n\n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\ndef g(n: int = 4):\n    \"\"\"\n    Generate a positive integer for the function f.\n    \"\"\"\n    return n\n\nassert f(g()) == 5\n",
        "idx_generation": 427,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers, check if the array is sorted in non-decreasing order.\n\n    Return True if the array is sorted, False otherwise.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n\n    Output:\n    True\n\n    Explanation:\n    The array is sorted in non-decreasing order.\n    \"\"\"\n\n    def is_sorted(arr):\n        n = len(arr)\n        for i in range(1, n):\n            if arr[i] < arr[i-1]:\n                return False\n        return True\n\n    return is_sorted(arr)\n\ndef g(arr: List[int]):\n    \"\"\"\n    Generate an array of integers with random values.\n    \"\"\"\n    return arr\n\nassert f(g([1, 2, 3, 4, 5])) == True\n",
        "idx_generation": 392,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum path sum from the top-left corner to the bottom-right corner.\n    Each step you may move down or right.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[m - 1][n - 1]\n\ndef g(grid=[[1,3,1],[1,5,1],[4,2,1]]):\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 400,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the sum of all positive integers less than n that are divisible by 3 or 5\"\"\"\n    return sum(i for i in range(1, n) if i % 3 == 0 or i % 5 == 0)\n\ndef g(n=20):\n    return n\n\nassert f(g()) == 78\n",
        "idx_generation": 64,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there is a subset of nums that sums to target\"\"\"\n    def dfs(index, current_sum):\n        if current_sum == target:\n            return True\n        if index >= len(nums) or current_sum > target:\n            return False\n        if dfs(index + 1, current_sum + nums[index]):\n            return True\n        return dfs(index + 1, current_sum)\n\n    return dfs(0, 0)\n\ndef g():\n    nums = [1, 5, 8, 12, 3]\n    target = 9\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 198,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"Check if target is a substring of s using string manipulation.\"\"\"\n    return target in s\n\ndef g(s: str, target: str) -> str:\n    \"\"\"Concatenate s and target using string manipulation.\"\"\"\n    return s + target\n\nassert f(g(\"hello\", \"lo\"), \"lo\")\n",
        "idx_generation": 101,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a pair of numbers whose sum is equal to a power of 2.\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(i+1, n):\n            if (nums[i] + nums[j]) & (nums[i] + nums[j] - 1) == 0:\n                return True\n    return False\n\ndef g():\n    nums = [1, 3, 4, 5, 7]\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 341,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if the list is sorted in ascending order.\n    Return True if the list is sorted, False otherwise.\n    \"\"\"\n    for i in range(1, len(nums)):\n        if nums[i] < nums[i-1]:\n            return False\n    return True\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == True\n",
        "idx_generation": 168,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(adj_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix of a directed graph, determine if the graph contains a cycle or not.\n    Return True if the graph contains a cycle, and False otherwise.\n    \n    Sample Input:\n    adj_matrix = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 0, 0, 0]\n    ]\n    \n    Sample Output:\n    True\n    \n    Explanation:\n    The given adjacency matrix represents the following directed graph:\n    0 -> 1 -> 2 -> 3 -> 0\n    The graph contains a cycle, so the output is True.\n    \"\"\"\n    def dfs(node, visited, stack):\n        visited[node] = True\n        stack[node] = True\n        \n        for neighbor in range(len(adj_matrix)):\n            if adj_matrix[node][neighbor] == 1:\n                if not visited[neighbor]:\n                    if dfs(neighbor, visited, stack):\n                        return True\n                elif stack[neighbor]:\n                    return True\n        \n        stack[node] = False\n        return False\n    \n    num_nodes = len(adj_matrix)\n    visited = [False] * num_nodes\n    stack = [False] * num_nodes\n    \n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(node, visited, stack):\n                return True\n    \n    return False\n\ndef g():\n    adj_matrix = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 0, 0, 0]\n    ]\n    return adj_matrix\n\nassert f(g()) == True\n",
        "idx_generation": 330,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target integer, find the number of ways to add up to the target using the numbers in the list.\n    Each number in the list can be used multiple times.\n    \"\"\"\n    dp = [0] * (target + 1)\n    dp[0] = 1\n    for i in range(1, target + 1):\n        for num in nums:\n            if i >= num:\n                dp[i] += dp[i - num]\n    return dp[target]\n\ndef g(nums=[1, 2, 3], target=4):\n    \"\"\"\n    Return the given list of integers and the target integer.\n    \"\"\"\n    return nums, target\n\nassert f(*g()) == 7\n",
        "idx_generation": 428,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a pair of numbers in the list such that their sum is equal to the target.\n    Return True if such a pair exists, False otherwise.\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g() -> Tuple[List[int], int]:\n    return ([2, 4, 6, 8, 10], 12)\n\nassert f(*g())\n",
        "idx_generation": 392,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g(nums=[-2,1,-3,4,-1,2,1,-5,4]):\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 400,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nimport numpy as np\n\ndef f(arr: np.ndarray) -> float:\n    \"\"\"\n    Given a 2D numpy array arr, compute the sum of all elements.\n    \"\"\"\n    return np.sum(arr)\n\ndef g(arr=np.array([[1, 2], [3, 4]])):\n    \"\"\"\n    This solution computes the sum of all elements in a 2D numpy array arr.\n    \"\"\"\n    return np.sum(arr)\n\nassert f(g()) == 10.0\n",
        "idx_generation": 65,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the number of unique paths from the top-left corner to the bottom-right corner.\n    You can only move down or right at any point in time.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    \n    # Base case\n    dp[0][0] = 1\n    \n    # Dynamic programming approach\n    for i in range(m):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n    \n    return dp[m-1][n-1]\n\ndef g(grid: List[List[int]]):\n    return grid\n\nassert f(g([[1, 1, 1], [1, 1, 1], [1, 1, 1]])) == 6\n\n",
        "idx_generation": 200,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a valid palindrome after deleting at most one character.\n    Return True if it is a valid palindrome, False otherwise.\n    \"\"\"\n    def is_palindrome(s, left, right):\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n\n    left, right = 0, len(s) - 1\n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s, left + 1, right) or is_palindrome(s, left, right - 1)\n        left += 1\n        right -= 1\n\n    return True\n\ndef g(s = \"abcdcbax\"):\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 102,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num1: int, num2: int) -> int:\n    \"\"\"\n    Given two integers num1 and num2, find the bitwise XOR of the two numbers.\n\n    Example:\n    Input: num1 = 5, num2 = 3\n    Output: 6\n\n    Explanation: The bitwise XOR of 5 and 3 is 6 (101 XOR 011 = 110).\n    \"\"\"\n    return num1 ^ num2\n\ndef g(num1=5, num2=3):\n    return num1, num2\n\nassert f(*g()) == 6\n",
        "idx_generation": 342,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the sum of all the elements in the matrix.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n\n    Output:\n    45\n\n    Explanation:\n    The sum of all the elements in the matrix is 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45.\n    \"\"\"\n\n    total_sum = 0\n\n    for row in matrix:\n        for num in row:\n            total_sum += num\n\n    return total_sum\n\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]) -> List[List[int]]:\n    return matrix\n\nassert f(g()) == 45\n\n",
        "idx_generation": 176,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> int:\n    \"\"\"\n    Given a binary tree, find the maximum path sum.\n\n    A path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections.\n    The path must contain at least one node and does not need to go through the root.\n\n    Example:\n    Input: root = [1,2,3]\n         1\n        / \\\n       2   3\n    Output: 6\n    \"\"\"\n\n    def maxPathSumHelper(node: TreeNode) -> int:\n        nonlocal maxSum\n\n        if not node:\n            return 0\n\n        leftSum = max(maxPathSumHelper(node.left), 0)\n        rightSum = max(maxPathSumHelper(node.right), 0)\n\n        currentSum = node.val + leftSum + rightSum\n\n        maxSum = max(maxSum, currentSum)\n\n        return node.val + max(leftSum, rightSum)\n\n    maxSum = float('-inf')\n    maxPathSumHelper(root)\n\n    return maxSum\n\ndef g() -> TreeNode:\n    \"\"\"\n    Generate a binary tree with maximum path sum.\n    \"\"\"\n    # Creating the tree:\n    #      1\n    #     / \\\n    #    2   3\n    return TreeNode(1, TreeNode(2), TreeNode(3))\n\nassert f(g()) == 6\n",
        "idx_generation": 332,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and a target value, find all unique combinations of numbers in the array that sum up to the target.\n\n    Example:\n    Input:\n    nums = [2, 3, 6, 7]\n    target = 7\n\n    Output:\n    [\n        [2, 2, 3],\n        [7]\n    ]\n\n    Explanation:\n    The combinations [2, 2, 3] and [7] are the unique combinations of numbers in the array that sum up to the target value of 7.\n    \"\"\"\n\n    def backtrack(combination, start, target):\n        if target == 0:\n            result.append(combination)\n            return\n        elif target < 0:\n            return\n\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            backtrack(combination + [nums[i]], i, target - nums[i])\n\n    result = []\n    nums.sort()\n    backtrack([], 0, target)\n    return result\n\ndef g() -> (List[int], int):\n    \"\"\"\n    Generate an array of integers and a target value.\n    \"\"\"\n    return ([2, 3, 6, 7], 7)\n\nassert f(*g()) == [[2, 2, 3], [7]]\n",
        "idx_generation": 428,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Example:\n    Input:\n    [1, 5, 2, 3]\n\n    Output:\n    15\n\n    Explanation:\n    The maximum product can be obtained by multiplying 5 and 3 (5 * 3 = 15).\n    \"\"\"\n\n    max_product = float('-inf')\n\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            product = arr[i] * arr[j]\n            max_product = max(max_product, product)\n\n    return max_product\n\ndef g(arr = [1, 5, 2, 3]):\n    return arr\n\nassert f(g()) == 15\n",
        "idx_generation": 393,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value, determine if there are two integers in the array that sum up to the target.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n\n    Output: True\n\n    Explanation: There are two integers in the array, 3 and 4, that sum up to 7.\n    \"\"\"\n\n    def two_sum(arr: List[int], target: int) -> bool:\n        left = 0\n        right = len(arr) - 1\n\n        while left < right:\n            curr_sum = arr[left] + arr[right]\n            if curr_sum == target:\n                return True\n            elif curr_sum < target:\n                left += 1\n            else:\n                right -= 1\n\n        return False\n\n    return two_sum(arr, target)\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    return arr, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 400,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, p=3, q=5) -> bool:\n    \"\"\"Check if a number is a power of 3 and divisible by 5\"\"\"\n    return n > 0 and n % p == 0 and n % q == 0\ndef g(p=3, q=5):\n    return p * q\nassert f(g()) == True\n",
        "idx_generation": 68,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the length of the shortest path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The shortest path is 1 -> 3 -> 1 -> 1 -> 1, and the total length is 7.\n\n    Hint: Use dynamic programming to calculate the minimum path sum.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[m - 1][n - 1]\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n\n",
        "idx_generation": 201,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Given two strings s1 and s2, determine if s2 is a rotation of s1.\n\n    Sample Input:\n    s1 = \"hello\"\n    s2 = \"lohel\"\n\n    Sample Output:\n    True\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n\n    s1 += s1\n\n    return s2 in s1\n\ndef g(s1 = \"hello\", s2 = \"lohel\"):\n    return s1, s2\n\nassert f(*g()) == True\n",
        "idx_generation": 105,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR of any two elements.\n    \"\"\"\n    max_xor = 0\n    \n    # Iterate through each bit position from left to right\n    for i in range(31, -1, -1):\n        max_xor <<= 1\n        prefixes = set()\n        \n        # Calculate the prefix of each number at the current bit position\n        for num in nums:\n            prefixes.add(num >> i)\n        \n        # Try to find a pair of numbers with different prefixes\n        for prefix in prefixes:\n            if (max_xor | 1) ^ prefix in prefixes:\n                max_xor |= 1\n                break\n    \n    return max_xor\n\ndef g():\n    \"\"\"\n    Generate a list of integers for testing.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n",
        "idx_generation": 346,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return a new list where each element is the product of all the other elements in the original list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    [120, 60, 40, 30, 24]\n\n    Explanation:\n    The first element in the output list is the product of all the elements in the original list except itself (2 * 3 * 4 * 5 = 120). The second element is the product of all the elements except itself (1 * 3 * 4 * 5 = 60), and so on.\n\n    Hint: Use two lists to keep track of the product of all elements to the left and right of the current element.\n    \"\"\"\n    n = len(nums)\n    left_products = [1] * n\n    right_products = [1] * n\n\n    for i in range(1, n):\n        left_products[i] = left_products[i - 1] * nums[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        right_products[i] = right_products[i + 1] * nums[i + 1]\n\n    return [left_products[i] * right_products[i] for i in range(n)]\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g()) == [120, 60, 40, 30, 24]\n",
        "idx_generation": 182,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency list, determine if there is a path from a given start node to a given end node.\n\n    Example:\n    Input:\n    graph = {1: [2, 3], 2: [4], 3: [5], 4: [5], 5: []}\n    start = 1\n    end = 5\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 1 to node 5 in the given graph.\n    \"\"\"\n\n    def dfs(graph: Dict[int, List[int]], node: int, end: int, visited: Set[int]) -> bool:\n        if node == end:\n            return True\n\n        visited.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(graph, neighbor, end, visited):\n                    return True\n\n        return False\n\n    return dfs(graph, start, end, set())\n\ndef g():\n    graph = {1: [2, 3], 2: [4], 3: [5], 4: [5], 5: []}\n    start = 1\n    end = 5\n    return graph, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 332,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a list of words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.\n    Return True if the string can be segmented, False otherwise.\n    \"\"\"\n    n = len(s)\n    dp = [False] * (n + 1)\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in words:\n                dp[i] = True\n                break\n\n    return dp[n]\n\ndef g(s: str = \"leetcode\", words: List[str] = [\"leet\", \"code\"]):\n    \"\"\"\n    Return the input string and list of words.\n    \"\"\"\n    return s, words\n\nassert f(*g()) == True\n",
        "idx_generation": 441,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of distinct triplets (a, b, c) such that a + b + c = target, where target is a given integer.\n\n    Return the number of distinct triplets.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 6\n\n    Output:\n    1\n\n    Explanation:\n    The distinct triplets that sum up to 6 are (1, 2, 3).\n    \"\"\"\n    def count_triplets(arr, target):\n        count = 0\n        \n        for i in range(len(arr) - 2):\n            left = i + 1\n            right = len(arr) - 1\n            \n            while left < right:\n                current_sum = arr[i] + arr[left] + arr[right]\n                \n                if current_sum == target:\n                    count += 1\n                    left += 1\n                    right -= 1\n                elif current_sum < target:\n                    left += 1\n                else:\n                    right -= 1\n        \n        return count\n\n    target = 6\n    return count_triplets(arr, target)\n\ndef g(arr=[1, 2, 3, 4, 5]):\n    return arr\n\nassert f(g()) == 1\n\n",
        "idx_generation": 394,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray using Kadane's algorithm.\n\n    Example:\n    Input:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for the function f.\n    \"\"\"\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n\n",
        "idx_generation": 403,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> bool:\n    \"\"\"Find if n is a prime number and m is a multiple of n.\"\"\"\n    prime_factors = []\n    for i in range(2, int(n**0.5) + 1):\n        while n % i == 0:\n            prime_factors.append(i)\n            n //= i\n    if n > 1:\n        prime_factors.append(n)\n    return len(prime_factors) == 1 and m % prime_factors[0] == 0\n\ndef g(n: int, m: int):\n    \"\"\"Generate a number n and a multiple m of n.\"\"\"\n    return n, n * m\n\nassert f(*g(n=7, m=3))\n",
        "idx_generation": 71,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a subarray with the constraint that\n    no two numbers in the subarray are adjacent.\n    \"\"\"\n    if not nums:\n        return 0\n\n    n = len(nums)\n    dp = [0] * n\n    dp[0] = nums[0]\n\n    for i in range(1, n):\n        dp[i] = max(nums[i], dp[i-1], nums[i] + dp[i-2])\n\n    return dp[-1]\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for the function f.\n    \"\"\"\n    return [2, 7, 9, 3, 1]\n\nassert f(g()) == 12\n",
        "idx_generation": 202,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome. A palindrome is a word, phrase, number, or other sequence\n    of characters that reads the same forward and backward.\n\n    Sample Input:\n    \"racecar\"\n\n    Sample Output:\n    True\n    \"\"\"\n    return s == s[::-1]\n\n\ndef g():\n    \"\"\"\n    Generate a palindrome string that consists of the first 10 letters of the alphabet repeated twice.\n    \"\"\"\n    alphabet = \"abcdefghij\"\n    return alphabet + alphabet[::-1]\n\n\nassert f(g()) == True\n",
        "idx_generation": 106,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value of any two elements in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value can be obtained by XORing 5 and 25, which gives 28.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor_val = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor_val)\n\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n\n",
        "idx_generation": 347,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all positive integers less than or equal to n.\n\n    Example:\n    n = 5\n\n    Output:\n    15\n\n    Explanation:\n    The sum of all positive integers less than or equal to 5 is 1 + 2 + 3 + 4 + 5 = 15.\n\n    Hint: Use the formula for the sum of an arithmetic series.\n    \"\"\"\n\n    return (n * (n + 1)) // 2\n\ndef g() -> int:\n    return 5\n\nassert f(g()) == 15\n\n",
        "idx_generation": 201,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency list, determine if there is a path between two nodes.\n\n    Example:\n    Input:\n    graph = [\n        [1, 2],\n        [2, 3],\n        [3, 4],\n        [4],\n        []\n    ]\n    start = 0\n    end = 4\n\n    Output:\n    True\n\n    Explanation:\n    In this example, there is a path from node 0 to node 4: 0 -> 1 -> 2 -> 3 -> 4.\n    \"\"\"\n\n    def dfs(node, visited):\n        if node == end:\n            return True\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited):\n                    return True\n        return False\n\n    n = len(graph)\n    visited = [False] * n\n\n    return dfs(start, visited)\n\ndef g():\n    graph = [\n        [1, 2],\n        [2, 3],\n        [3, 4],\n        [4],\n        []\n    ]\n    start = 0\n    end = 4\n    return (graph, start, end)\n\nassert f(*g()) == True\n\n",
        "idx_generation": 335,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Given a positive integer 'n', generate a Pascal's triangle with 'n' rows.\n\n    Example:\n    n = 5\n\n    Output:\n    [\n        [1],\n        [1, 1],\n        [1, 2, 1],\n        [1, 3, 3, 1],\n        [1, 4, 6, 4, 1]\n    ]\n    \"\"\"\n    triangle = []\n    for i in range(n):\n        row = [1] * (i+1)\n        for j in range(1, i):\n            row[j] = triangle[i-1][j-1] + triangle[i-1][j]\n        triangle.append(row)\n    return triangle\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == [\n    [1],\n    [1, 1],\n    [1, 2, 1],\n    [1, 3, 3, 1],\n    [1, 4, 6, 4, 1]\n]",
        "idx_generation": 444,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation: The numbers at indices 0 and 1 (2 and 7) add up to the target 9.\n\n    Hint: Sort the list first and use two pointers, one at the beginning and one at the end, to find the pair that adds up to the target.\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return [left, right]\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 394,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target value using binary search.\n    If the target value is not found in the list, return -1.\n\n    Sample Input:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    Sample Output:\n    2\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> List[int]:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 404,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(num: int) -> bool:\n    \"\"\"\n    Given a positive integer num, determine if it is a perfect square.\n    \"\"\"\n    if num < 0:\n        return False\n\n    left, right = 0, num\n    while left <= right:\n        mid = (left + right) // 2\n        square = mid * mid\n\n        if square == num:\n            return True\n        elif square < num:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer for the function f.\n    \"\"\"\n    return 9\n\nassert f(g()) == True\n",
        "idx_generation": 72,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of different ways to climb to the top of a staircase with n steps.\n    You can take either 1 or 2 steps at a time.\n\n    Sample Input:\n    n = 3\n\n    Sample Output:\n    3\n    Explanation: There are three ways to climb to the top: 1 step + 1 step + 1 step, 1 step + 2 steps, 2 steps + 1 step.\n    \"\"\"\n    if n <= 2:\n        return n\n    else:\n        dp = [0] * (n + 1)\n        dp[1] = 1\n        dp[2] = 2\n        for i in range(3, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        return dp[n]\n\ndef g(n=3):\n    return n\n\nassert f(g()) == 3\n\n",
        "idx_generation": 203,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, check if it is a palindrome.\n    \"\"\"\n    s = s.lower()\n    s = ''.join(ch for ch in s if ch.isalnum())\n    return s == s[::-1]\n\ndef g() -> str:\n    \"\"\"\n    Generate a palindrome string.\n    \"\"\"\n    return \"A man, a plan, a canal: Panama\"\n\nassert f(g()) == True\n",
        "idx_generation": 110,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"\n    Given an integer number num, return the number of set bits in its binary representation.\n\n    Example:\n    num = 10\n\n    Output:\n    2\n\n    Explanation:\n    The binary representation of 10 is 1010, which has 2 set bits.\n\n    Hint: Use the bitwise AND operation to check for set bits.\n    \"\"\"\n\n    count = 0\n    while num > 0:\n        if num & 1:\n            count += 1\n        num >>= 1\n    return count\n\ndef g(num=10):\n    return num\n\nassert f(g()) == 2\n\n",
        "idx_generation": 348,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"\n    Given an integer, find the sum of all numbers from 1 to n using the formula (n * (n + 1)) // 2.\n    \"\"\"\n    return (num * (num + 1)) // 2\n\ndef g(num: int = 10):\n    \"\"\"\n    Generate an integer.\n    \"\"\"\n    return num\n\nassert f(g()) == 55\n",
        "idx_generation": 210,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> bool:\n    \"\"\"\n    Given the root of a binary tree, determine if it is a valid binary search tree (BST).\n\n    A valid BST is defined as follows:\n        - The left subtree of a node contains only nodes with keys less than the node's key.\n        - The right subtree of a node contains only nodes with keys greater than the node's key.\n        - Both the left and right subtrees must also be binary search trees.\n\n    Return True if the given binary tree is a valid BST, otherwise return False.\n\n    Example:\n    Input:\n        2\n       / \\\n      1   3\n    Output:\n        True\n\n    Hint: Perform a depth-first search (DFS) and check the validity of each node's value.\n    \"\"\"\n\n    def validate_bst(node: TreeNode, min_val=float('-inf'), max_val=float('inf')) -> bool:\n        if not node:\n            return True\n        if node.val <= min_val or node.val >= max_val:\n            return False\n        return validate_bst(node.left, min_val, node.val) and validate_bst(node.right, node.val, max_val)\n\n    return validate_bst(root)\n\n\ndef g() -> TreeNode:\n    root = TreeNode(2)\n    root.left = TreeNode(1)\n    root.right = TreeNode(3)\n    return root\n\nassert f(g()) == True\n",
        "idx_generation": 337,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the number of ways to arrange n items in a row such that no two specific items are next to each other.\n    \"\"\"\n    if n <= 1:\n        return 1\n    if n == 2:\n        return 2\n    return f(n-1) + f(n-2)\n\ndef g():\n    n = 4\n    return n\n\nassert f(g()) == 5\n",
        "idx_generation": 445,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[int]:\n    \"\"\"\n    Given an integer n, return a list of all prime numbers up to n.\n\n    Args:\n    - n: An integer, the upper limit to generate prime numbers.\n\n    Returns:\n    - A list of all prime numbers up to n.\n    \"\"\"\n    primes = []\n    \n    for num in range(2, n+1):\n        is_prime = True\n        \n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                is_prime = False\n                break\n        \n        if is_prime:\n            primes.append(num)\n    \n    return primes\n\ndef g() -> int:\n    n = 20\n    return n\n\nassert f(g()) == [2, 3, 5, 7, 11, 13, 17, 19]\n",
        "idx_generation": 396,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find two numbers in the list that add up to a target value.\n    Return the indices of the two numbers in the original list.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 407,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a subarray with a sum of zero.\n    \"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum == 0 or prefix_sum in prefix_sums:\n            return True\n        prefix_sums.add(prefix_sum)\n    return False\n\ndef g():\n    \"\"\"\n    Return a list of integers.\n    \"\"\"\n    return [1, -2, 3, 4, -5]\n\nassert f(g()) == True\n",
        "idx_generation": 72,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the factorial of n using recursion.\n\n    Sample Input:\n    n = 5\n\n    Sample Output:\n    120\n    Explanation: The factorial of 5 is 5 * 4 * 3 * 2 * 1 = 120.\n    \"\"\"\n    if n == 0:\n        return 1\n    else:\n        return n * f(n - 1)\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 120\n\n",
        "idx_generation": 203,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, check if it is a palindrome after removing all non-alphanumeric characters and ignoring case.\n    \"\"\"\n    s = ''.join(c.lower() for c in s if c.isalnum())\n    return s == s[::-1]\n\ndef g(s = \"A man, a plan, a canal: Panama\"):\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 112,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of set bits (1s) in its binary representation.\n\n    Example:\n    n = 10\n\n    Output:\n    2\n\n    Explanation:\n    The binary representation of 10 is 1010, which contains 2 set bits.\n\n    Hint: Use the bitwise AND operation to count the set bits.\n    \"\"\"\n    count = 0\n    while n > 0:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g():\n    n = 10\n    return n\n\nassert f(g()) == 2\n",
        "idx_generation": 363,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of trailing zeroes in n!.\n\n    Example:\n    n = 5\n    Output: 1\n    Explanation: 5! = 120, which has 1 trailing zero.\n\n    Hint: Count the number of factors of 5 in the prime factorization of n!.\n    \"\"\"\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n    return count\n\ndef g(n=10):\n    return n\n\nassert f(g()) == 2\n\n",
        "idx_generation": 212,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given a number of nodes and a list of edges, determine if there is a cycle in the graph.\n    \"\"\"\n    def has_cycle(node, visited, parent, adj_list):\n        visited[node] = True\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                if has_cycle(neighbor, visited, node, adj_list):\n                    return True\n            elif parent != neighbor:\n                return True\n        return False\n\n    adj_list = [[] for _ in range(n)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    visited = [False] * n\n    for i in range(n):\n        if not visited[i]:\n            if has_cycle(i, visited, -1, adj_list):\n                return True\n    return False\n\ndef g() -> (int, List[List[int]]):\n    \"\"\"\n    Generate a graph with 4 nodes and 4 edges, with a cycle.\n    \"\"\"\n    return 4, [[0, 1], [1, 2], [2, 3], [3, 0]]\n\nassert f(*g()) == True\n",
        "idx_generation": 338,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of ways to express n as the sum of distinct positive integers.\n\n    Example:\n    f(5) returns 2, as there are two ways to express 5 as the sum of distinct positive integers: 1 + 4 and 2 + 3.\n    \"\"\"\n\n    # Initialize the count of ways to 0\n    count = 0\n\n    # Start with the largest possible number and subtract it from n\n    largest_num = n - 1\n\n    while largest_num > 0:\n        # If the difference is larger than the current number, add 1 to the count\n        if n - largest_num > largest_num:\n            count += 1\n        # Otherwise, recursively find the number of ways for the difference\n        else:\n            count += f(n - largest_num)\n\n        largest_num -= 1\n\n    return count\n\ndef g(n: int = 5) -> int:\n    \"\"\"\n    Generate a positive integer.\n\n    Example:\n    g() returns 5.\n    \"\"\"\n\n    return n\n\nassert f(g()) == 2\n",
        "idx_generation": 446,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a matrix of integers and a target number, determine if the target number exists in the matrix.\n    The matrix is sorted in non-decreasing order from left to right and from top to bottom.\n\n    Sample Input:\n    matrix = [\n        [1, 4, 7, 11, 15],\n        [2, 5, 8, 12, 19],\n        [3, 6, 9, 16, 22],\n        [10, 13, 14, 17, 24],\n        [18, 21, 23, 26, 30]\n    ]\n    target = 5\n\n    Sample Output:\n    True (5 is present in the matrix)\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return False\n\n    rows, cols = len(matrix), len(matrix[0])\n    row, col = 0, cols - 1\n\n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n\n    return False\n\ndef g():\n    matrix = [\n        [1, 4, 7, 11, 15],\n        [2, 5, 8, 12, 19],\n        [3, 6, 9, 16, 22],\n        [10, 13, 14, 17, 24],\n        [18, 21, 23, 26, 30]\n    ]\n    target = 5\n    return matrix, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 396,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the length of the longest increasing path.\n\n    Example:\n    Input:\n    matrix = [\n      [9,9,4],\n      [6,6,8],\n      [2,1,1]\n    ]\n    Output: 4\n    Explanation: The longest increasing path is [1, 2, 6, 9].\n    \"\"\"\n\n    if not matrix:\n        return 0\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(row, col):\n        if dp[row][col] != 0:\n            return dp[row][col]\n\n        for d in directions:\n            newRow = row + d[0]\n            newCol = col + d[1]\n\n            if 0 <= newRow < rows and 0 <= newCol < cols and matrix[newRow][newCol] > matrix[row][col]:\n                dp[row][col] = max(dp[row][col], dfs(newRow, newCol))\n\n        dp[row][col] += 1\n        return dp[row][col]\n\n    longestPath = 0\n    dp = [[0] * cols for _ in range(rows)]\n\n    for i in range(rows):\n        for j in range(cols):\n            longestPath = max(longestPath, dfs(i, j))\n\n    return longestPath\n\ndef g():\n    \"\"\"\n    Generate a matrix with the following structure:\n    [\n      [9,9,4],\n      [6,6,8],\n      [2,1,1]\n    ]\n    \"\"\"\n    return [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n\nassert f(g()) == 4\n\n",
        "idx_generation": 410,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Reverse a string s.\"\"\"\n    return s[::-1]\n\ndef g(s=\"hello\"):\n    return s\n\nassert f(g()) == \"olleh\"\n",
        "idx_generation": 73,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Initialize the first row\n    for j in range(1, cols):\n        grid[0][j] += grid[0][j-1]\n\n    # Initialize the first column\n    for i in range(1, rows):\n        grid[i][0] += grid[i-1][0]\n\n    # Compute the maximum sum for each cell\n    for i in range(1, rows):\n        for j in range(1, cols):\n            grid[i][j] += max(grid[i-1][j], grid[i][j-1])\n\n    return grid[-1][-1]\n\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 12\n",
        "idx_generation": 207,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n    \"\"\"\n    max_len = 0\n    start = 0\n    char_map = {}\n\n    for i in range(len(s)):\n        if s[i] in char_map and start <= char_map[s[i]]:\n            start = char_map[s[i]] + 1\n        else:\n            max_len = max(max_len, i - start + 1)\n\n        char_map[s[i]] = i\n\n    return max_len\n\n\ndef g(s: str = \"abcabcbb\"):\n    \"\"\"\n    Find the length of the longest substring without repeating characters in the string s.\n    \"\"\"\n    return s\n\n\nassert f(g()) == 3\n",
        "idx_generation": 112,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Generate a square grid of size n x n where each cell contains the bitwise XOR of its row and column indices.\n\n    Args:\n    - n: The size of the grid.\n\n    Returns:\n    - A 2D list representing the grid.\n    \"\"\"\n    grid = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            grid[i][j] = i ^ j\n    return grid\n\ndef g():\n    n = 4\n    return n\n\nassert f(g()) == [[0, 1, 2, 3], [1, 0, 3, 2], [2, 3, 0, 1], [3, 2, 1, 0]]\n",
        "idx_generation": 387,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of the first n natural numbers.\n    Return the sum.\n    \"\"\"\n    return (n * (n + 1)) // 2\n\ndef g():\n    n = 10\n    return n\n\nassert f(g()) == 55\n\n",
        "idx_generation": 221,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid graph represented as an adjacency matrix 'graph', find the number of connected components.\n\n    Example:\n    Input: graph = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\n    Output: 2\n\n    Explanation:\n    The grid can be visualized as:\n    1 1 0\n    1 1 0\n    0 0 1\n\n    There are two connected components: (0, 1, 3, 4) and (2).\n    \"\"\"\n\n    def dfs(node: int) -> None:\n        visited[node] = True\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                dfs(neighbor)\n\n    n = len(graph)\n    visited = [False] * n\n    count = 0\n\n    for node in range(n):\n        if not visited[node]:\n            dfs(node)\n            count += 1\n\n    return count\n\ndef g():\n    return [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\n\nassert f(g()) == 2\n\n",
        "idx_generation": 340,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Count Valid Parenthesis Sequences\n\n    Given a positive integer n, return the number of valid parenthesis sequences of length 2n.\n\n    A valid parenthesis sequence is defined as:\n    - An empty string is a valid parenthesis sequence.\n    - If s is a valid parenthesis sequence, then (s) is also a valid parenthesis sequence.\n    - If s and t are valid parenthesis sequences, then st is also a valid parenthesis sequence.\n\n    Example:\n    n = 3\n    output: 5\n\n    Explanation: The valid parenthesis sequences of length 6 are:\n    ((())), (()()), (())(), ()(()), ()()()\n    \"\"\"\n    dp = [0] * (n+1)\n    dp[0] = 1\n\n    for i in range(1, n+1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i-j-1]\n\n    return dp[n]\n\n\ndef g(n = 3):\n    return n\n\n\nassert f(g()) == 5\n",
        "idx_generation": 451,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers, sort the array in ascending order using the bubble sort algorithm.\n    Return the sorted array.\n    \"\"\"\n\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    \n    return nums\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for the puzzle.\n    \"\"\"\n    nums = [5, 2, 8, 12, 1, 7]\n    return nums\n\nassert f(g()) == [1, 2, 5, 7, 8, 12]\n",
        "idx_generation": 398,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence (LIS).\n\n    Example:\n    Input: [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n\n    Note:\n    - The LIS does not need to be contiguous.\n    - The input list can contain duplicate elements.\n    \"\"\"\n\n    def binary_search(arr: List[int], target: int) -> int:\n        left, right = 0, len(arr) - 1\n\n        while left <= right:\n            mid = left + (right - left) // 2\n            if arr[mid] == target:\n                return mid\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return left\n\n    tails = []\n\n    for num in nums:\n        idx = binary_search(tails, num)\n        if idx == len(tails):\n            tails.append(num)\n        else:\n            tails[idx] = num\n\n    return len(tails)\n\ndef g(nums = [10, 9, 2, 5, 3, 7, 101, 18]):\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 411,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Determine if the number 'n' is a perfect square and the sum of its digits is greater than 'k'.\n    \"\"\"\n    def is_perfect_square(num):\n        sq_root = int(num**0.5)\n        return sq_root * sq_root == num\n\n    def digit_sum(num):\n        return sum(int(digit) for digit in str(num))\n\n    return is_perfect_square(n) and digit_sum(n) > k\n\ndef g(n: int = 25, k: int = 5):\n    return n, k\n\nassert f(*g())\n",
        "idx_generation": 75,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of positive integers, find the minimum cost to reach the bottom-right corner from the top-left corner.\n    You can only move down or right.\n\n    Sample input:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\n    Sample output:\n    7\n\n    Explanation:\n    The minimum cost path is 1 -> 3 -> 1 -> 1 -> 1, which gives the cost 7.\n\n    Hint: Use dynamic programming to build a table of minimum costs for each cell. Start from the top-left corner and iterate through the grid, updating each cell with the minimum cost from either the cell above or the cell to the left.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[m - 1][n - 1]\n\ndef g():\n    return [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\nassert f(g()) == 7\n",
        "idx_generation": 208,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome after deleting at most one character.\n\n    Return True if it is a palindrome, False otherwise.\n\n    Example:\n    s = \"racecar\"\n\n    Output:\n    True\n\n    Explanation:\n    The string \"racecar\" is a palindrome, so the function should return True.\n    \"\"\"\n\n    def is_palindrome(s):\n        left = 0\n        right = len(s) - 1\n\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n\n        return True\n\n    def is_almost_palindrome(s):\n        left = 0\n        right = len(s) - 1\n\n        while left < right:\n            if s[left] != s[right]:\n                # Try deleting the left character\n                new_s = s[:left] + s[left+1:]\n                if is_palindrome(new_s):\n                    return True\n\n                # Try deleting the right character\n                new_s = s[:right] + s[right+1:]\n                if is_palindrome(new_s):\n                    return True\n\n                return False\n\n            left += 1\n            right -= 1\n\n        return True\n\n    return is_almost_palindrome(s)\n\ndef g(s = \"racecar\"):\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 113,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if n is a perfect square and a power of 2.\n    Return True if n is a perfect square and a power of 2, False otherwise.\n    \"\"\"\n\n    def is_perfect_square(num: int) -> bool:\n        if num < 0:\n            return False\n        sqrt = int(num ** 0.5)\n        return sqrt * sqrt == num\n\n    def is_power_of_two(num: int) -> bool:\n        if num < 0:\n            return False\n        return num & (num - 1) == 0\n\n    return is_perfect_square(n) and is_power_of_two(n)\n\ndef g() -> int:\n    return 16\n\nassert f(g()) == True\n\n",
        "idx_generation": 391,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "import math\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Calculate the sum of all the even numbers in a given list of integers.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n\n    Output:\n    12\n\n    Explanation:\n    The even numbers in the list are 2, 4, and 6. Their sum is 12.\n\n    Hint: Use mathematical concepts to solve this problem.\n    \"\"\"\n\n    return sum(num for num in nums if num % 2 == 0)\n\ndef g(nums=[1, 2, 3, 4, 5, 6]):\n    return nums\n\nassert f(g()) == 12\n",
        "idx_generation": 223,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, check if the graph is bipartite.\n\n    A graph is bipartite if it can be colored using two colors such that no two adjacent vertices have the same color.\n\n    Return True if the graph is bipartite, and False otherwise.\n\n    Example:\n    f([[1, 3], [0, 2], [1, 3], [0, 2]]) returns True, as the graph can be colored as follows:\n    - Vertices 0 and 2 are colored with color 0.\n    - Vertices 1 and 3 are colored with color 1.\n\n    Note:\n    - The graph will have at most 100 vertices.\n    - Each vertex's edges are not sorted in any specific order.\n    - The graph may not be connected.\n    \"\"\"\n\n    colors = [-1] * len(graph)\n\n    for node in range(len(graph)):\n        if colors[node] == -1:\n            if not dfs(graph, node, colors, 0):\n                return False\n\n    return True\n\n\ndef dfs(graph: List[List[int]], node: int, colors: List[int], color: int) -> bool:\n    \"\"\"\n    Perform a depth-first search to color the graph and check if it is bipartite.\n    \"\"\"\n\n    colors[node] = color\n\n    for neighbor in graph[node]:\n        if colors[neighbor] == color:\n            return False\n        if colors[neighbor] == -1 and not dfs(graph, neighbor, colors, 1 - color):\n            return False\n\n    return True\n\n\ndef g():\n    \"\"\"\n    Generate an undirected graph represented as an adjacency list.\n    \"\"\"\n\n    return [[1, 3], [0, 2], [1, 3], [0, 2]]\n\n\nassert f(g()) == True\n\n",
        "idx_generation": 341,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique permutations of the list.\n    \"\"\"\n    def dfs(nums: List[int], path: List[int], used: List[bool], res: List[List[int]]):\n        if len(path) == len(nums):\n            res.append(path.copy())\n            return\n\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            dfs(nums, path, used, res)\n            used[i] = False\n            path.pop()\n\n    nums.sort()\n    res = []\n    dfs(nums, [], [False] * len(nums), res)\n    return len(res)\n\ndef g(nums: List[int] = [1, 1, 2]):\n    \"\"\"\n    Generate a list of integers for the function f.\n    \"\"\"\n    return nums\n\nassert f(g()) == 3\n",
        "idx_generation": 454,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the position of the target value in the list using binary search.\n\n    Return the index of the target value if it exists in the list, otherwise return -1.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 6\n\n    Output:\n    5\n\n    Explanation:\n    The target value 6 is located at index 5 in the list.\n    \"\"\"\n    def binary_search(nums, target, low, high):\n        if low <= high:\n            mid = (low + high) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                return binary_search(nums, target, mid+1, high)\n            else:\n                return binary_search(nums, target, low, mid-1)\n        else:\n            return -1\n    \n    return binary_search(nums, target, 0, len(nums)-1)\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9], 6\n\nassert f(*g()) == 5\n\n",
        "idx_generation": 399,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return the words that are anagrams of each other.\n\n    Example:\n    words = [\"cat\", \"dog\", \"tac\", \"god\", \"act\"]\n\n    Output:\n    [\"cat\", \"tac\", \"act\", \"dog\", \"god\"]\n\n    Hint: Use a dictionary to group the anagrams together.\n    \"\"\"\n\n    anagrams = {}\n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        if sorted_word in anagrams:\n            anagrams[sorted_word].append(word)\n        else:\n            anagrams[sorted_word] = [word]\n\n    result = []\n    for key in anagrams:\n        result.extend(anagrams[key])\n\n    return result\n\ndef g(words=[\"cat\", \"dog\", \"tac\", \"god\", \"act\"]):\n    return (words,)\n\nassert f(*g()) == [\"cat\", \"tac\", \"act\", \"dog\", \"god\"]\n",
        "idx_generation": 413,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of integers, determine if it is a valid Sudoku board.\n\n    Example:\n    grid = [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]\n\n    Output:\n    True\n\n    Explanation:\n    The above grid represents a valid Sudoku board.\n    \"\"\"\n\n    def is_valid_row(row: List[int]) -> bool:\n        seen = set()\n        for num in row:\n            if num != 0 and num in seen:\n                return False\n            seen.add(num)\n        return True\n\n    def is_valid_column(grid: List[List[int]], col_index: int) -> bool:\n        seen = set()\n        for row in grid:\n            num = row[col_index]\n            if num != 0 and num in seen:\n                return False\n            seen.add(num)\n        return True\n\n    def is_valid_box(grid: List[List[int]], start_row: int, start_col: int) -> bool:\n        seen = set()\n        for row in range(start_row, start_row + 3):\n            for col in range(start_col, start_col + 3):\n                num = grid[row][col]\n                if num != 0 and num in seen:\n                    return False\n                seen.add(num)\n        return True\n\n    for row in grid:\n        if not is_valid_row(row):\n            return False\n\n    for col_index in range(len(grid[0])):\n        if not is_valid_column(grid, col_index):\n            return False\n\n    for start_row in range(0, 9, 3):\n        for start_col in range(0, 9, 3):\n            if not is_valid_box(grid, start_row, start_col):\n                return False\n\n    return True\n\n\ndef g() -> List[List[int]]:\n    return [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]\n\n\nassert f(g()) == True\n",
        "idx_generation": 75,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    Output:\n    4 (the longest increasing subsequence is [2, 3, 7, 101])\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g(nums: List[int] = [10, 9, 2, 5, 3, 7, 101, 18]):\n    return (nums,)\n\nassert f(g()) == True\n",
        "idx_generation": 209,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(words: List[str], target='apple') -> bool:\n    \"\"\"\n    Given a list of words, return True if the target word is present in the list and False otherwise.\n    \"\"\"\n    return target in words\ndef g(target='apple'):\n    words = ['banana', 'orange', 'apple', 'grape']\n    return words\nassert f(g()) == True\n",
        "idx_generation": 115,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"\n    Given an integer, return the number of bits set to 1 in its binary representation.\n    \"\"\"\n    count = 0\n    while num > 0:\n        if num & 1:\n            count += 1\n        num >>= 1\n    return count\n\ndef g() -> int:\n    return 23\n\nassert f(g()) == 4\n",
        "idx_generation": 392,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[int]:\n    \"\"\"\n    Given an integer n, return a list of the first k fibonacci numbers.\n\n    Example:\n    n = 10\n    k = 5\n\n    Output:\n    [0, 1, 1, 2, 3]\n\n    Explanation:\n    The first 5 fibonacci numbers are [0, 1, 1, 2, 3].\n    \"\"\"\n    fib = []\n    a, b = 0, 1\n    while len(fib) < k:\n        fib.append(a)\n        a, b = b, a + b\n    return fib\n\ndef g():\n    return 10, 5\n\nassert f(*g()) == [0, 1, 1, 2, 3]\n\n",
        "idx_generation": 226,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of integers, determine if it is possible to reach the bottom-right cell from the top-left cell\n    by only moving downwards, rightwards, or diagonally.\n    The cells containing 0 represent obstacles that cannot be crossed.\n\n    Sample input:\n    grid = [\n        [1, 0, 0],\n        [1, 1, 1],\n        [0, 0, 1]\n    ]\n\n    Sample output:\n    True\n\n    Explanation: It is possible to reach the bottom-right cell (grid[2][2]) by moving downwards, rightwards, and diagonally.\n    \"\"\"\n    rows = len(grid)\n    if rows == 0:\n        return False\n    cols = len(grid[0])\n    if cols == 0:\n        return False\n\n    dp = [[False] * cols for _ in range(rows)]\n    dp[0][0] = True\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                if i > 0:\n                    dp[i][j] |= dp[i-1][j]\n                if j > 0:\n                    dp[i][j] |= dp[i][j-1]\n                if i > 0 and j > 0:\n                    dp[i][j] |= dp[i-1][j-1]\n\n    return dp[rows-1][cols-1]\n\ndef g(grid=[[1, 0, 0], [1, 1, 1], [0, 0, 1]]):\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 345,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of ways to arrange n pairs of parentheses such that they are balanced.\n\n    Example:\n    n = 3\n\n    Output:\n    5\n\n    Explanation:\n    The five ways to arrange 3 pairs of parentheses are: ((())), (()()), (())(), ()(()), ()()().\n    \"\"\"\n\n    def backtrack(s, left, right):\n        if left == 0 and right == 0:\n            result.append(s)\n            return\n        if left > 0:\n            backtrack(s + '(', left - 1, right + 1)\n        if right > 0:\n            backtrack(s + ')', left, right - 1)\n\n    result = []\n    backtrack('', n, 0)\n    return len(result)\n\ndef g() -> int:\n    \"\"\"\n    Generate the input for the function f.\n    \"\"\"\n    return 3\n\nassert f(g()) == 5\n",
        "idx_generation": 464,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target integer, return the index of the target integer in the list.\n    If the target integer is not found in the list, return -1.\n    \"\"\"\n    def binary_search(nums: List[int], target: int) -> int:\n        low = 0\n        high = len(nums) - 1\n\n        while low <= high:\n            mid = (low + high) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n\n        return -1\n\n    return binary_search(nums, target)\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 3, 5, 7, 9, 11]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 3\n",
        "idx_generation": 399,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value k, find the maximum sum of a contiguous subarray \n    in the list that is less than or equal to k.\n\n    Example:\n    nums = [2, 3, 1, 2, 4, 3]\n    k = 7\n\n    Output:\n    7\n\n    Explanation:\n    The subarray [2, 3, 1, 2] has the maximum sum of 8, but it is greater than k. The subarray \n    [1, 2, 4] has the maximum sum of 7, which is less than or equal to k.\n    \"\"\"\n\n    prefix_sums = [0] * (len(nums) + 1)\n    max_sum = float('-inf')\n\n    for i in range(1, len(prefix_sums)):\n        prefix_sums[i] = prefix_sums[i - 1] + nums[i - 1]\n\n    for i in range(len(prefix_sums)):\n        for j in range(i + 1, len(prefix_sums)):\n            curr_sum = prefix_sums[j] - prefix_sums[i]\n            if curr_sum <= k:\n                max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g(nums=[2, 3, 1, 2, 4, 3], k=7) -> List[int]:\n    return nums, k\n\nassert f(*g()) == 7\n\n",
        "idx_generation": 415,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers 'arr', determine if it is a valid mountain array.\n\n    Example:\n    arr = [0, 3, 2, 1]\n\n    Output:\n    True\n\n    Explanation:\n    The above array represents a valid mountain array since it increases until index 2 and then decreases.\n    \"\"\"\n\n    n = len(arr)\n    if n < 3:\n        return False\n\n    i = 0\n    # Ascending phase\n    while i < n - 1 and arr[i] < arr[i + 1]:\n        i += 1\n\n    if i == 0 or i == n - 1:\n        return False\n\n    # Descending phase\n    while i < n - 1 and arr[i] > arr[i + 1]:\n        i += 1\n\n    return i == n - 1\n\n\ndef g() -> List[int]:\n    return [0, 3, 2, 1]\n\n\nassert f(g()) == True\n",
        "idx_generation": 75,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of 0s and 1s, find the number of islands.\n    An island is defined as a group of connected 1s (horizontally or vertically).\n    Return the total number of islands in the matrix.\n    \"\"\"\n    if not matrix:\n        return 0\n    \n    rows, cols = len(matrix), len(matrix[0])\n    count = 0\n    \n    def dfs(i, j):\n        if i < 0 or i >= rows or j < 0 or j >= cols or matrix[i][j] != 1:\n            return\n        matrix[i][j] = -1\n        \n        dfs(i-1, j)\n        dfs(i+1, j)\n        dfs(i, j-1)\n        dfs(i, j+1)\n    \n    for i in range(rows):\n        for j in range(cols):\n            if matrix[i][j] == 1:\n                count += 1\n                dfs(i, j)\n    \n    return count\n\ndef g():\n    return [[1, 1, 0, 0, 0],\n            [1, 1, 0, 0, 0],\n            [0, 0, 1, 0, 0],\n            [0, 0, 0, 1, 1]]\n\nassert f(g()) == 3\n",
        "idx_generation": 209,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"\n    Given a string and a number, return True if the number of occurrences of the letter 'a' in the string is\n    greater than or equal to the number, and False otherwise.\n    \"\"\"\n    count = s.count('a')\n    return count >= n\ndef g(n=3):\n    s = 'banana'\n    return s, n\nassert f(*g())\n",
        "idx_generation": 115,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of set bits in its binary representation.\n\n    Example:\n    n = 7\n\n    Output:\n    3\n\n    Explanation:\n    The binary representation of 7 is 111, which contains 3 set bits.\n\n    Hint: Use bitwise operations to count the number of set bits.\n    \"\"\"\n\n    count = 0\n\n    while n:\n        count += n & 1\n        n >>= 1\n\n    return count\n\ndef g(n = 7):\n    return n\n\nassert f(g()) == 3\n",
        "idx_generation": 402,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the sum of the first n terms of the arithmetic sequence\"\"\"\n    return (n/2)*(2 + (n-1))\n\ndef g(n: int):\n    return n\n\nassert f(g(10)) == 55\n",
        "idx_generation": 227,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> int:\n    \"\"\"\n    Given a binary tree, find the maximum path sum.\n    The path may start and end at any node in the tree.\n    \"\"\"\n    def maxPathSumHelper(node: TreeNode) -> int:\n        if not node:\n            return 0\n        \n        # Calculate the maximum path sum for the left and right subtrees\n        left_sum = maxPathSumHelper(node.left)\n        right_sum = maxPathSumHelper(node.right)\n        \n        # Calculate the maximum sum that includes the current node\n        max_sum = max(node.val, node.val + left_sum, node.val + right_sum)\n        \n        # Update the maximum path sum if a larger sum is found\n        f.max_sum = max(f.max_sum, max_sum, node.val + left_sum + right_sum)\n        \n        # Return the maximum sum that includes the current node\n        return max_sum\n    \n    # Initialize the maximum path sum to negative infinity\n    f.max_sum = float('-inf')\n    \n    # Call the helper function to calculate the maximum path sum\n    maxPathSumHelper(root)\n    \n    # Return the maximum path sum\n    return f.max_sum\n\ndef g():\n    \"\"\"\n    Create a binary tree for testing.\n    \"\"\"\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    \n    return root\n\nassert f(g()) == 18\n",
        "idx_generation": 346,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique combinations that add up to the target sum.\n\n    Return the number of unique combinations.\n\n    Example:\n    arr = [2, 3, 6, 7]\n    target = 7\n\n    Output:\n    2\n\n    Explanation:\n    The unique combinations that sum up to 7 are [2, 2, 3] and [7].\n    \"\"\"\n    def backtrack(arr, target, start, path, result):\n        if target == 0:\n            result.append(path)\n            return\n        if target < 0:\n            return\n        \n        for i in range(start, len(arr)):\n            backtrack(arr, target - arr[i], i, path + [arr[i]], result)\n    \n    target = 7\n    result = []\n    backtrack(arr, target, 0, [], result)\n    return len(result)\n\ndef g(arr=[2, 3, 6, 7]):\n    return arr\n\nassert f(g()) == 2\n",
        "idx_generation": 472,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Check if the given list is a permutation of the numbers from 1 to n.\n    \"\"\"\n    n = len(arr)\n    visited = [False] * (n+1)\n\n    for num in arr:\n        if num < 1 or num > n or visited[num]:\n            return False\n        visited[num] = True\n\n    return all(visited[1:])\n\ndef g():\n    \"\"\"\n    Generate a permutation of the numbers from 1 to n.\n    \"\"\"\n    return [2, 3, 1, 4]\n\nassert f(g()) == True\n",
        "idx_generation": 110,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, return the number of pairs in the list\n    that sum up to the target number.\n\n    Example:\n    nums = [2, 3, 4, 5, 6]\n    target = 9\n\n    Output:\n    2\n\n    Explanation:\n    There are two pairs in the list that sum up to the target number 9: (2, 7) and (4, 5).\n    \"\"\"\n    nums.sort()  # sorting the list of integers\n\n    count = 0\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n\n        if curr_sum == target:\n            count += 1\n            left += 1\n            right -= 1\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return count\n\ndef g():\n    return (\n        [2, 3, 4, 5, 6],\n        9\n    )\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 415,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of trailing zeros in n!.\n\n    Example:\n    n = 10\n\n    Output:\n    2\n\n    Explanation:\n    10! = 3628800, which has 2 trailing zeros.\n\n    Hint: Count the number of factors of 5 in the prime factorization of n.\n    \"\"\"\n\n    count = 0\n    p = 5\n\n    while n >= p:\n        count += n // p\n        p *= 5\n\n    return count\n\ndef g(n=20):\n    return n\n\nassert f(g()) == 4\n\n",
        "idx_generation": 77,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum of numbers obtained by traversing a grid from top-left to bottom-right, allowed to move only down or right. Additionally, each cell in the grid can only be visited once.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    12\n\n    Hint: Use dynamic programming to store the maximum sum at each cell.\n    \"\"\"\n\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    return dp[m - 1][n - 1]\n\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 12\n",
        "idx_generation": 212,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of words in the string while preserving the order of characters within each word.\n    \"\"\"\n    words = s.split()\n    reversed_words = [word[::-1] for word in words]\n    reversed_sentence = \" \".join(reversed_words)\n\n    return reversed_sentence\n\ndef g(s: str = \"Hello World\"):\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return s\n\nassert f(g()) == \"olleH dlroW\"\n",
        "idx_generation": 116,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int]) -> int:\n    \"\"\"\n    Given a list of numbers, find the maximum XOR value between any two numbers using bit manipulation.\n\n    Sample Input:\n    numbers = [1, 2, 3, 4, 5]\n\n    Sample Output:\n    7\n    \"\"\"\n\n    max_xor = 0\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            xor = numbers[i] ^ numbers[j]\n            if xor > max_xor:\n                max_xor = xor\n    return max_xor\n\ndef g():\n    numbers = [1, 2, 3, 4, 5]\n    return numbers\n\nassert f(g()) == 7\n",
        "idx_generation": 416,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Fibonacci Sequence\n\n    Given a number n, generate the Fibonacci sequence up to the nth term and return it as a list.\n\n    Example:\n    nums = 5\n    output: [0, 1, 1, 2, 3]\n\n    Explanation:\n    The Fibonacci sequence up to the 5th term is [0, 1, 1, 2, 3].\n    \"\"\"\n\n    fib = [0, 1]\n    for i in range(2, nums):\n        fib.append(fib[i-1] + fib[i-2])\n    \n    return fib\n\ndef g(nums=5):\n    return nums\n\nassert f(g()) == [0, 1, 1, 2, 3]\n",
        "idx_generation": 231,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> List[int]:\n    \"\"\"\n    Given the root of a binary tree, return the inorder traversal of its nodes' values.\n\n    Example:\n    Input: [1,null,2,3]\n       1\n        \\\n         2\n        /\n       3\n\n    Output: [1, 3, 2]\n    \"\"\"\n\n    def inorder(node: TreeNode, result: List[int]) -> None:\n        if node:\n            inorder(node.left, result)\n            result.append(node.val)\n            inorder(node.right, result)\n\n    result = []\n    inorder(root, result)\n    return result\n\ndef g() -> TreeNode:\n    \"\"\"\n    Generate a binary tree for the function f.\n    \"\"\"\n    node_1 = TreeNode(1)\n    node_2 = TreeNode(2)\n    node_3 = TreeNode(3)\n    node_1.right = node_2\n    node_2.left = node_3\n    return node_1\n\nassert f(g()) == [1, 3, 2]\n",
        "idx_generation": 346,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers n and m, calculate the number of ways to choose m items from a set of n distinct items.\n\n    Example:\n    n = 5\n    m = 3\n\n    Output:\n    10\n\n    Explanation:\n    There are 10 ways to choose 3 items from a set of 5 distinct items.\n\n    Hint: Use combinatorial analysis to solve the problem.\n    \"\"\"\n\n    def factorial(num: int) -> int:\n        if num <= 1:\n            return 1\n        return num * factorial(num - 1)\n\n    return factorial(n) // (factorial(m) * factorial(n - m))\n\ndef g(n: int = 5, m: int = 3) -> int:\n    \"\"\"\n    Return the input values n and m.\n    \"\"\"\n    return n, m\n\nassert f(*g()) == 10\n\n",
        "idx_generation": 478,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there exists three numbers in the list whose sum is equal to the target.\n    This function uses two pointers to scan from both ends of the list towards the middle to find the sum.\n    \"\"\"\n    for i in range(len(nums) - 2):\n        left = i + 1\n        right = len(nums) - 1\n        \n        while left < right:\n            curr_sum = nums[i] + nums[left] + nums[right]\n            \n            if curr_sum == target:\n                return True\n            elif curr_sum < target:\n                left += 1\n            else:\n                right -= 1\n    \n    return False\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5, 6], target: int = 10):\n    \"\"\"\n    Generate a list of integers and a target number for the function f.\n    \"\"\"\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 111,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of distinct integers and a target value, return the index if the target is found.\n    If not, return the index where it would be if it were inserted in order.\n\n    Example:\n    Input: nums = [1,3,5,6], target = 5\n    Output: 2\n\n    Input: nums = [1,3,5,6], target = 2\n    Output: 1\n\n    Hint: Use binary search to find the index of the target or the position where it should be inserted.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left\n\ndef g(nums = [1, 3, 5, 6], target = 5):\n    return nums, target\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 416,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number is a prime number.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    return 7\n\nassert f(g()) == True\n",
        "idx_generation": 88,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the sum of the first n natural numbers.\"\"\"\n    if n == 0:\n        return 0\n    else:\n        return n + f(n - 1)\n\ndef g():\n    n = 6\n    return (n,)\n\nassert f(*g()) == 21\n",
        "idx_generation": 214,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of words in the string.\n\n    Args:\n    - s: The input string.\n\n    Returns:\n    - The string with the order of words reversed.\n    \"\"\"\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)\n\ndef g():\n    s = \"Hello World!\"\n    return s\n\nassert f(g()) == \"World! Hello\"\n",
        "idx_generation": 117,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of 1 bits in its binary representation.\n    \"\"\"\n    count = 0\n\n    while n > 0:\n        if n & 1 == 1:\n            count += 1\n        n >>= 1\n\n    return count\n\ndef g(n=10):\n    return n\n\nassert f(g()) == 2\n",
        "idx_generation": 418,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Find the sum of all positive integers up to the given number.\n    \"\"\"\n    return (n * (n + 1)) // 2\n\ndef g():\n    return 100\n\nassert f(g()) == 5050\n\n",
        "idx_generation": 234,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix and two nodes start and end,\n    check if there is a path from start to end in the graph.\n\n    Return True if a path exists, False otherwise.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 0 to node 3 in the graph.\n\n    Hint: Use depth-first search (DFS) or breadth-first search (BFS) algorithm to traverse the graph.\n    \"\"\"\n\n    def dfs(graph: List[List[int]], start: int, end: int, visited: List[bool]) -> bool:\n        if start == end:\n            return True\n        visited[start] = True\n        for neighbor in range(len(graph)):\n            if graph[start][neighbor] == 1 and not visited[neighbor]:\n                if dfs(graph, neighbor, end, visited):\n                    return True\n        return False\n\n    visited = [False] * len(graph)\n    return dfs(graph, start, end, visited)\n\ndef g() -> tuple:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n    return graph, start, end\n\nassert f(*g()) == True\n\n",
        "idx_generation": 348,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target value, return the minimum number of unique combinations in nums where the sum of the values equals the target.\n    Each number in nums may be used any number of times in the combination.\n    If no combination is possible, return -1.\n\n    Example:\n    nums = [1, 2, 5]\n    target = 11\n\n    Output:\n    3\n\n    Hint: Use dynamic programming to find the minimum number of unique combinations.\n    \"\"\"\n\n    dp = [float('inf')] * (target + 1)\n    dp[0] = 0\n\n    for num in nums:\n        for i in range(num, target + 1):\n            dp[i] = min(dp[i], dp[i - num] + 1)\n\n    return dp[target] if dp[target] != float('inf') else -1\n\ndef g():\n    return ([1, 2, 5], 11)\n\nassert f(*g()) == 3\n\n",
        "idx_generation": 480,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if it is a permutation of the numbers from 1 to N, where N is the length of the list.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    for i in range(n):\n        if nums[i] != i + 1:\n            return False\n    return True\n\ndef g(nums = [4, 1, 3, 2]):\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 112,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target element using binary search.\n\n    Example:\n    arr = [2, 5, 7, 9, 12, 15]\n    target = 7\n\n    Output:\n    2\n\n    Explanation:\n    The target element 7 is present at index 2 in the sorted list.\n\n    Hint: Use the binary search algorithm to efficiently search for the target element in the sorted list.\n    \"\"\"\n\n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1\n\ndef g():\n    return [2, 5, 7, 9, 12, 15], 7\n\nassert f(*g()) == 2\n\n\n",
        "idx_generation": 420,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target integer, find the number of pairs in nums that add up to the target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n\n    Output:\n    2\n\n    Explanation:\n    The pairs that add up to the target are (1, 5) and (2, 4), so the number of pairs is 2.\n\n    Hint: Use a hash set to store the complement of each number in nums.\n    \"\"\"\n    count = 0\n    complement_set = set()\n    for num in nums:\n        complement = target - num\n        if complement in complement_set:\n            count += 1\n        complement_set.add(num)\n    return count\n\ndef g(nums=[1, 2, 3, 4, 5], target=6):\n    return nums, target\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 89,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of ways to climb n stairs\"\"\"\n    if n <= 1:\n        return 1\n    elif n == 2:\n        return 2\n    else:\n        dp = [0] * (n + 1)\n        dp[1] = 1\n        dp[2] = 2\n        for i in range(3, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        return dp[n]\n\ndef g():\n    return 5\n\nassert f(g()) == 8\n",
        "idx_generation": 218,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import Tuple\n\ndef f(s: str) -> Tuple[int, int]:\n    \"\"\"\n    Given a string, return a tuple containing the number of uppercase letters and the number of lowercase letters in the string.\n\n    Example:\n    Input: s = \"Hello World\"\n    Output: (2, 8)\n    Explanation:\n    There are 2 uppercase letters ('H' and 'W') and 8 lowercase letters ('e', 'l', 'l', 'o', 'o', 'r', 'l', 'd') in the string.\n    \"\"\"\n    uppercase_count = 0\n    lowercase_count = 0\n    for char in s:\n        if char.isupper():\n            uppercase_count += 1\n        elif char.islower():\n            lowercase_count += 1\n    return (uppercase_count, lowercase_count)\n\ndef g() -> str:\n    return \"Hello World\"\n\nassert f(g()) == (2, 8)\n\n",
        "idx_generation": 122,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Hint: Use the property of XOR to optimize the solution.\n    \"\"\"\n\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= 1 << i\n        xor_set = set()\n        for num in nums:\n            xor_set.add(num & mask)\n\n        temp = max_xor | (1 << i)\n        for prefix in xor_set:\n            if temp ^ prefix in xor_set:\n                max_xor = temp\n                break\n\n    return max_xor\n\ndef g(nums=[3, 10, 5, 25, 2, 8]):\n    return (nums,)\n\nassert f(*g()) == 28\n\n",
        "idx_generation": 425,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"Calculate the sum of all the positive integers less than or equal to the given number.\"\"\"\n    if num <= 0:\n        return 0\n    return (num * (num + 1)) // 2\n\ndef g():\n    return 10\n\nassert f(g()) == 55\n",
        "idx_generation": 237,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, find the length of the longest path that can be formed by connecting adjacent characters.\n    The path can only be formed by moving up, down, left, or right from one character to another.\n    \n    Example:\n    grid = [\n        [\"A\", \"B\", \"C\"],\n        [\"D\", \"E\", \"F\"],\n        [\"G\", \"H\", \"I\"]\n    ]\n    \n    Output:\n    9 (the longest path can be formed by connecting 'A' -> 'B' -> 'C' -> 'F' -> 'I' -> 'H' -> 'G' -> 'D' -> 'E')\n    \"\"\"\n    if not grid:\n        return 0\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    \n    def dfs(row: int, col: int, path_len: int) -> int:\n        path_len += 1\n        \n        # Mark the current cell as visited\n        temp = grid[row][col]\n        grid[row][col] = \"#\"\n        \n        # Explore the neighboring cells\n        max_path_len = path_len\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        for dx, dy in directions:\n            new_row, new_col = row + dx, col + dy\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] != \"#\":\n                max_path_len = max(max_path_len, dfs(new_row, new_col, path_len))\n        \n        # Restore the cell value\n        grid[row][col] = temp\n        \n        return max_path_len\n    \n    longest_path = 0\n    for row in range(rows):\n        for col in range(cols):\n            if grid[row][col] != \"#\":\n                longest_path = max(longest_path, dfs(row, col, 0))\n    \n    return longest_path\n\ndef g():\n    grid = [\n        [\"A\", \"B\", \"C\"],\n        [\"D\", \"E\", \"F\"],\n        [\"G\", \"H\", \"I\"]\n    ]\n    return grid\n\nassert f(g()) == 9\n\n",
        "idx_generation": 358,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers 'nums' and a target integer 'target', find the number of valid combinations that can be formed by adding up the numbers in the list to reach the target.\n\n    Each number in the list can be used multiple times.\n\n    Sample Input:\n    nums = [1, 2, 3]\n    target = 4\n\n    Sample Output:\n    7\n\n    Explanation:\n    The valid combinations are: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2], [3, 1], [1, 3].\n    \"\"\"\n\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i - num >= 0:\n                dp[i] += dp[i - num]\n\n    return dp[target]\n\ndef g(nums: List[int] = [1, 2, 3], target: int = 4):\n    return nums, target\n\nassert f(*g()) == 7\n\n",
        "idx_generation": 482,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there are three integers in the list that\n    sum up to the target value. Return True if such triplets exist, otherwise return False.\n\n    Example:\n    arr = [1, 4, 2, 8, 3, 5]\n    target = 10\n\n    Output:\n    True\n\n    Explanation:\n    The triplets [1, 2, 7] and [4, 3, 3] sum up to the target value 10.\n\n    Hint: Use a combination of sorting and searching to find the triplets.\n    \"\"\"\n    arr.sort()\n    for i in range(len(arr)-2):\n        left = i + 1\n        right = len(arr) - 1\n        while left < right:\n            curr_sum = arr[i] + arr[left] + arr[right]\n            if curr_sum == target:\n                return True\n            elif curr_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g(arr=[1, 4, 2, 8, 3, 5], target=10):\n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 114,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target number using binary search.\n    If the target number is not found, return -1.\n    \"\"\"\n    def binary_search(nums: List[int], target: int, left: int, right: int) -> int:\n        if left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                return binary_search(nums, target, mid + 1, right)\n            else:\n                return binary_search(nums, target, left, mid - 1)\n        else:\n            return -1\n\n    return binary_search(nums, target, 0, len(nums) - 1)\n\ndef g():\n    nums = [1, 3, 5, 7, 9, 11, 13, 15, 17]\n    target = 9\n    return nums, target\n\nassert f(*g()) == 4\n",
        "idx_generation": 421,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, return the sum of all the elements in the matrix.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    45\n\n    Explanation:\n    The sum of all the elements in the matrix is 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45.\n\n    Hint: Use nested loops to iterate through all the elements in the matrix and accumulate the sum.\n    \"\"\"\n    total = 0\n    for row in matrix:\n        for num in row:\n            total += num\n    return total\n\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix\n\nassert f(g()) == 45\n\n",
        "idx_generation": 89,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target integer, find the contiguous subarray within the list that has the largest sum and return the sum.\n\n    Args:\n    - nums: A list of integers.\n    - target: The target integer.\n\n    Returns:\n    - The sum of the contiguous subarray with the largest sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    target = 6\n\n    Output:\n    6\n\n    Explanation:\n    The contiguous subarray with the largest sum is [4, -1, 2, 1], which has a sum of 6.\n    \"\"\"\n\n    # Initialize variables\n    max_sum = float('-inf')\n    current_sum = 0\n\n    # Iterate through the list of integers\n    for num in nums:\n        # Update the current sum\n        current_sum = max(num, current_sum + num)\n\n        # Update the max sum\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g(nums: List[int] = [-2, 1, -3, 4, -1, 2, 1, -5, 4], target: int = 6) -> List[int]:\n    return nums, target\n\nassert f(*g()) == 6\n",
        "idx_generation": 218,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Given two strings s1 and s2, check if s1 is a subsequence of s2.\n    Return True if s1 is a subsequence of s2, False otherwise.\n    \"\"\"\n    i = 0\n    j = 0\n    while i < len(s1) and j < len(s2):\n        if s1[i] == s2[j]:\n            i += 1\n        j += 1\n    return i == len(s1)\n\ndef g(s1=\"abc\", s2=\"ahbgdc\"):\n    return s1, s2\n\nassert f(*g()) == True\n",
        "idx_generation": 124,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, count the number of set bits in its binary representation.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g():\n    n = 10\n    return n\n\nassert f(g()) == 2\n",
        "idx_generation": 426,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if n is a prime number.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n",
        "idx_generation": 237,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(adj_list: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency list representation of a directed graph, determine if there is a cycle in the graph.\n\n    Example:\n    adj_list = [[1], [2], [3], [0]]\n\n    Output:\n    True\n\n    Explanation:\n    The graph has a cycle: 0 -> 1 -> 2 -> 3 -> 0\n\n    Hint: Use depth-first search (DFS) to detect cycles in a graph.\n    \"\"\"\n\n    def dfs(node: int, visited: List[bool], recursion_stack: List[bool]) -> bool:\n        visited[node] = True\n        recursion_stack[node] = True\n\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, recursion_stack):\n                    return True\n            elif recursion_stack[neighbor]:\n                return True\n\n        recursion_stack[node] = False\n        return False\n\n    num_nodes = len(adj_list)\n    visited = [False] * num_nodes\n    recursion_stack = [False] * num_nodes\n\n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(node, visited, recursion_stack):\n                return True\n\n    return False\n\ndef g(adj_list=[[1], [2], [3], [0]]):\n    return adj_list\n\nassert f(g()) == True\n",
        "idx_generation": 369,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers nums and a target integer target, return the number of combinations that add up to target.\n\n    Example:\n    nums = [1, 2, 3], target = 4\n\n    Output:\n    7 (as there are 7 combinations that add up to 4: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2], [3, 1], [1, 3])\n\n    \"\"\"\n    def combination_sum_helper(target, nums, memo):\n        if target == 0:\n            return 1\n        if target < 0:\n            return 0\n        if target in memo:\n            return memo[target]\n        \n        num_combinations = 0\n        for num in nums:\n            num_combinations += combination_sum_helper(target - num, nums, memo)\n        \n        memo[target] = num_combinations\n        return num_combinations\n    \n    return combination_sum_helper(target, nums, {})\n\ndef g(nums: List[int] = [1, 2, 3], target: int = 4):\n    return nums, target\n\nassert f(*g()) == 7\n\n",
        "idx_generation": 485,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers, determine if there are two numbers that sum up to the target value.\n    Return True if such a pair exists, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(arr: List[int] = [1, 2, 3, 4, 5], target: int = 7) -> List[int]:\n    \"\"\"\n    Return the sorted input array and the target value.\n    \"\"\"\n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 114,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, coins: List[int]) -> int:\n    \"\"\"\n    Given a positive integer n and a list of coin denominations, find the minimum number of coins needed to make n.\n\n    Args:\n    - n: The target amount.\n    - coins: The list of coin denominations.\n\n    Returns:\n    - The minimum number of coins needed to make n.\n    \"\"\"\n    dp = [float('inf')] * (n+1)\n    dp[0] = 0\n\n    for i in range(1, n+1):\n        for coin in coins:\n            if i - coin >= 0:\n                dp[i] = min(dp[i], dp[i-coin] + 1)\n\n    return dp[n]\n\ndef g():\n    n = 11\n    coins = [1, 2, 5]\n    return n, coins\n\nassert f(*g()) == 3\n",
        "idx_generation": 424,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray.\n\n    Sample Input:\n    [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Sample Output:\n    6 (corresponding to the subarray [4, -1, 2, 1])\n    \"\"\"\n    if not nums:\n        return 0\n\n    max_sum = current_sum = nums[0]\n\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n\nassert f(g()) == 6\n\n",
        "idx_generation": 90,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of ways to climb to the top of a staircase with n steps. You can climb either\n    1 or 2 steps at a time.\n    \"\"\"\n    if n <= 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\ndef g(n = 4):\n    return n\n\nassert f(g()) == 5\n",
        "idx_generation": 219,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"Check if t is a substring of s.\"\"\"\n    return t in s\ndef g():\n    str1 = \"Hello, World!\"\n    str2 = \"World\"\n    return str1, str2\nassert f(*g())\n",
        "idx_generation": 125,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value can be obtained by XORing 5 and 25: 5 XOR 25 = 28.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = set()\n        for num in nums:\n            prefixes.add(num & mask)\n        \n        target_xor = max_xor | (1 << i)\n        for prefix in prefixes:\n            if (prefix ^ target_xor) in prefixes:\n                max_xor = target_xor\n                break\n    \n    return max_xor\n\ndef g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n\n",
        "idx_generation": 430,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> int:\n    \"\"\"Calculate the binomial coefficient C(n, m).\"\"\"\n    if m > n - m:\n        m = n - m\n    result = 1\n    for i in range(m):\n        result *= (n - i)\n        result //= (i + 1)\n    return result\n\ndef g(n=10, m=3):\n    return n, m\n\nassert f(*g()) == 120\n",
        "idx_generation": 237,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the shortest path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    The shortest path is 1 -> 3 -> 1 -> 1 -> 1, which has a sum of 7.\n\n    Constraints:\n    - The grid will have at least one row and one column.\n    - Each element in the grid will be a non-negative integer.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 369,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the number of ways to arrange n pairs of parentheses.\n\n    Args:\n    - n: An integer representing the number of pairs of parentheses.\n\n    Returns:\n    - The number of valid parentheses arrangements.\n\n    Example:\n    Input: n = 3\n    Output: 5\n\n    Explanation: The valid arrangements are \"((()))\", \"(()())\", \"(())()\", \"()(())\", and \"()()()\".\n    \"\"\"\n\n    def backtrack(s, left, right):\n        if len(s) == 2 * n:\n            res.append(s)\n            return\n        if left < n:\n            backtrack(s + '(', left + 1, right)\n        if right < left:\n            backtrack(s + ')', left, right + 1)\n\n    res = []\n    backtrack('', 0, 0)\n    return len(res)\n\ndef g():\n    n = 3\n    return n\n\nassert f(g()) == 5\n\n",
        "idx_generation": 487,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if the list is sorted in non-decreasing order.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n\n    Sample Output:\n    True\n    \"\"\"\n    for i in range(len(nums) - 1):\n        if nums[i] > nums[i + 1]:\n            return False\n    return True\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 115,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Check if there exists three numbers in the list whose sum is equal to the target.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    \n    def helper(start: int, remaining: int, count: int) -> bool:\n        if count == 0:\n            return remaining == 0\n        if start >= n or count * nums[start] > remaining:\n            return False\n        \n        for i in range(start, n):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            \n            if helper(i+1, remaining-nums[i], count-1):\n                return True\n        \n        return False\n    \n    return helper(0, target, 3)\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5], target: int = 9) -> List[int]:\n    \"\"\"\n    Generate a list of integers and a target number.\n    \"\"\"\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 424,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a number is a perfect square.\"\"\"\n    if n < 0:\n        return False\n    sqrt = int(n ** 0.5)\n    return sqrt * sqrt == n\n\ndef g(n: int) -> int:\n    \"\"\"Find the largest perfect square less than or equal to n.\"\"\"\n    sqrt = int(n ** 0.5)\n    return sqrt * sqrt\n\nn = 100\nassert f(g(n))\n",
        "idx_generation": 92,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum subarray sum.\n\n    Sample Input:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Sample Output:\n    6\n\n    Explanation:\n    The maximum subarray is [4, -1, 2, 1], which has a sum of 6.\n    \"\"\"\n\n    def max_subarray_sum(nums: List[int]) -> int:\n        max_sum = float('-inf')\n        current_sum = 0\n\n        for num in nums:\n            current_sum = max(num, current_sum + num)\n            max_sum = max(max_sum, current_sum)\n\n        return max_sum\n\n    return max_subarray_sum(nums)\n\ndef g(nums: List[int] = [-2, 1, -3, 4, -1, 2, 1, -5, 4]) -> int:\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 220,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(text: str, pattern: str) -> List[int]:\n    \"\"\"Find all occurrences of a pattern in a text using string manipulation\"\"\"\n    indexes = []\n    m = len(pattern)\n    n = len(text)\n    \n    for i in range(n-m+1):\n        j = 0\n        while j < m:\n            if text[i+j] != pattern[j]:\n                break\n            j += 1\n        \n        if j == m:\n            indexes.append(i)\n    \n    return indexes\n\ndef g(text=\"abracadabra\", pattern=\"abra\"):\n    return text, pattern\n\nassert f(*g()) == [0, 7]\n",
        "idx_generation": 129,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of set bits in its binary representation.\n\n    Example:\n    n = 15\n\n    Output:\n    4\n\n    Explanation:\n    The binary representation of 15 is 1111.\n    There are 4 set bits in the binary representation of 15.\n    \"\"\"\n\n    count = 0\n\n    while n > 0:\n        count += n & 1\n        n >>= 1\n\n    return count\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return 23\n\nassert f(g()) == 4\n\n",
        "idx_generation": 430,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer 'n', calculate the factorial of n.\n\n    Example:\n    n = 5\n\n    Output:\n    120\n\n    Explanation:\n    The factorial of 5 is 5 * 4 * 3 * 2 * 1 = 120.\n    \"\"\"\n\n    result = 1\n    for i in range(1, n+1):\n        result *= i\n    return result\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == 120\n\n",
        "idx_generation": 239,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix graph representation, determine if the graph contains a cycle.\n\n    Example:\n    Input: graph = [[0, 1, 0],\n                    [0, 0, 1],\n                    [1, 0, 0]]\n    Output: True\n\n    Explanation: The graph contains a cycle: 0 -> 1 -> 2 -> 0\n\n    Hint: Use depth-first search (DFS) to traverse the graph and detect cycles.\n    \"\"\"\n\n    def dfs(node, visited, stack):\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor]:\n                if not visited[neighbor]:\n                    if dfs(neighbor, visited, stack):\n                        return True\n                elif stack[neighbor]:\n                    return True\n\n        stack[node] = False\n        return False\n\n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n    stack = [False] * num_nodes\n\n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(node, visited, stack):\n                return True\n\n    return False\n\ndef g():\n    return [[0, 1, 0],\n            [0, 0, 1],\n            [1, 0, 0]]\n\nassert f(g()) == True\n",
        "idx_generation": 372,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of possible combinations of k numbers from the range 1 to n.\n\n    Example:\n    n = 5, k = 3\n    Output: 10\n    Explanation: There are 10 possible combinations of 3 numbers from the range 1 to 5: \n    [1,2,3], [1,2,4], [1,2,5], [1,3,4], [1,3,5], [1,4,5], [2,3,4], [2,3,5], [2,4,5], [3,4,5].\n\n    Hint: Use a recursive approach to generate all combinations of k numbers from the range 1 to n.\n    \"\"\"\n\n    def generate_combinations(combination: List[int], start: int):\n        if len(combination) == k:\n            combinations.append(combination[:])\n            return\n        for i in range(start, n + 1):\n            combination.append(i)\n            generate_combinations(combination, i + 1)\n            combination.pop()\n\n    combinations = []\n    generate_combinations([], 1)\n    return len(combinations)\n\ndef g():\n    return 5, 3\n\nassert f(*g()) == 10\n\n",
        "idx_generation": 493,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, determine if there are two numbers in the list that add up to the target.\n\n    Args:\n    - nums: A list of integers in ascending order.\n    - target: The target number.\n\n    Returns:\n    - True if there exists two numbers in the list that add up to the target, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 117,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target value, find all unique combinations of numbers in the list\n    that sum up to the target.\n\n    Example:\n    nums = [2, 3, 6, 7]\n    target = 7\n\n    Output:\n    [[2, 2, 3], [7]]\n\n    Explanation:\n    The combinations [2, 2, 3] and [7] sum up to 7.\n    \"\"\"\n\n    def backtrack(combination, start, target):\n        if target == 0:\n            combinations.append(combination)\n            return\n        if target < 0:\n            return\n\n        for i in range(start, len(nums)):\n            num = nums[i]\n            backtrack(combination + [num], i, target - num)\n\n    combinations = []\n    nums.sort()\n    backtrack([], 0, target)\n\n    return combinations\n\ndef g():\n    nums = [2, 3, 6, 7]\n    target = 7\n\n    return nums, target\n\nassert f(*g()) == [[2, 2, 3], [7]]\n",
        "idx_generation": 433,
        "target_skills": [
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[int], k: int = 3) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any contiguous subarray of length k.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    k = 3\n\n    The subarrays of length 3 are [1, 2, 3], [2, 3, 4], and [3, 4, 5].\n    The maximum sum is 12, which corresponds to the subarray [3, 4, 5].\n\n    Therefore, the function should return 12.\n    \"\"\"\n    max_sum = float('-inf')\n    for i in range(len(arr) - k + 1):\n        subarray = arr[i:i+k]\n        subarray_sum = sum(subarray)\n        max_sum = max(max_sum, subarray_sum)\n    return max_sum\n\ndef g(arr = [1, 2, 3, 4, 5], k = 3):\n    return arr\n\nassert f(g()) == 12\n",
        "idx_generation": 96,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "import random\nfrom typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Compute the factorial of a given number using recursion.\n    \"\"\"\n    if n == 0:\n        return 1\n    else:\n        return n * f(n-1)\n\ndef g():\n    \"\"\"\n    Generate a random number.\n    \"\"\"\n    return 5\n\nassert f(g()) == 120\n",
        "idx_generation": 220,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, check if it is a palindrome when the spaces and special characters are removed.\n    \"\"\"\n    cleaned_str = ''.join(ch.lower() for ch in s if ch.isalpha())\n    return cleaned_str == cleaned_str[::-1]\n\ndef g() -> str:\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    s = \"A man, a plan, a canal, Panama!\"\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 132,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a subset whose bitwise XOR of all elements is equal to zero.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    True\n\n    Explanation:\n    The subsets [1, 3] and [2, 4] have bitwise XOR equal to zero.\n    \"\"\"\n    subset_xor = set()\n    subset_xor.add(0)\n\n    for num in nums:\n        new_subset_xor = set(subset ^ num for subset in subset_xor)\n        subset_xor.update(new_subset_xor)\n\n    return 0 in subset_xor\n\ndef g():\n    return [1, 2, 3, 4]\n\nassert f(g()) == True\n",
        "idx_generation": 430,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid represented as a list of lists of integers, determine if it forms a magic square.\n    A magic square is a grid in which the sum of every row, column, and diagonal is the same.\n\n    Example:\n    grid = [\n        [2, 7, 6],\n        [9, 5, 1],\n        [4, 3, 8]\n    ]\n    The sum of every row, column, and diagonal is 15, so it forms a magic square.\n\n    Return True if the grid forms a magic square, else return False.\n    \"\"\"\n    n = len(grid)\n    target_sum = sum(grid[0])\n\n    # Check rows\n    for row in grid:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for i in range(n):\n        col_sum = sum(grid[j][i] for j in range(n))\n        if col_sum != target_sum:\n            return False\n\n    # Check diagonals\n    diag_sum1 = sum(grid[i][i] for i in range(n))\n    if diag_sum1 != target_sum:\n        return False\n\n    diag_sum2 = sum(grid[i][n - 1 - i] for i in range(n))\n    if diag_sum2 != target_sum:\n        return False\n\n    return True\n\n\ndef g() -> List[List[int]]:\n    grid = [\n        [2, 7, 6],\n        [9, 5, 1],\n        [4, 3, 8]\n    ]\n    return grid\n\n\nassert f(g()) == True\n",
        "idx_generation": 244,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, return the topological ordering of the graph.\n    If the graph contains a cycle, return an empty list.\n\n    Example:\n    graph = [[1, 2], [3], [3, 4], [4], []]\n\n    Output:\n    [0, 2, 1, 3, 4] (one possible topological ordering of the graph)\n    \"\"\"\n    n = len(graph)\n    visited = [False] * n\n    stack = []\n    \n    def dfs(node):\n        visited[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n        \n        stack.append(node)\n    \n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n    \n    return stack[::-1]\n\ndef g() -> List[List[int]]:\n    graph = [[1, 2], [3], [3, 4], [4], []]\n    return graph\n\nassert f(g()) == [0, 2, 1, 3, 4]\n\n",
        "idx_generation": 375,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target integer, find the number of ways to sum the integers in the list to reach the target.\n\n    Example:\n    nums = [1, 2, 3], target = 4\n\n    Output:\n    7 (as there are 7 ways to sum the integers in the list to reach 4: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2], [3, 1], [1, 3])\n    \"\"\"\n    def count_sum_combinations(nums, target, memo):\n        if target == 0:\n            return 1\n        if target < 0:\n            return 0\n        if target in memo:\n            return memo[target]\n        \n        num_combinations = 0\n        for num in nums:\n            num_combinations += count_sum_combinations(nums, target - num, memo)\n        \n        memo[target] = num_combinations\n        return num_combinations\n    \n    return count_sum_combinations(nums, target, {})\n\ndef g(nums: List[int] = [1, 2, 3], target: int = 4) -> Tuple[List[int], int]:\n    return nums, target\n\nassert f(*g()) == 7\n\n",
        "idx_generation": 494,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, find the index of the first occurrence of the number 0 and the last occurrence of the number 1.\n    Return True if the index of 0 is less than the index of 1, False otherwise.\n\n    - arr is a list of integers.\n    - Return True if the index of 0 is less than the index of 1, False otherwise.\n    \"\"\"\n\n    def find_index(nums: List[int], target: int) -> int:\n        for i, num in enumerate(nums):\n            if num == target:\n                return i\n        return -1\n\n    index_0 = find_index(arr, 0)\n    index_1 = find_index(arr[::-1], 1)\n    if index_1 != -1:\n        index_1 = len(arr) - 1 - index_1\n\n    return index_0 != -1 and index_1 != -1 and index_0 < index_1\n\ndef g(arr: List[int]):\n    return arr\n\nassert f(g([1, 0, 1, 0, 0, 1, 1, 1]))\n",
        "idx_generation": 117,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target value using binary search.\n\n    If the target value is not found in the list, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9, 11]\n    target = 7\n    The target value 7 is found at index 3.\n\n    Return the index of the target value, or -1 if it is not found.\n    \"\"\"\n    low = 0\n    high = len(nums) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 3, 5, 7, 9, 11]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 3\n\n",
        "idx_generation": 434,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if the sum of any two numbers in the list is equal to a third number.\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(n):\n                if nums[i] + nums[j] == nums[k]:\n                    return True\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 99,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the nth Fibonacci number.\n\n    Example:\n    n = 6\n\n    Output:\n    8 (since the 6th Fibonacci number is 8)\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    fib = [0, 1]\n\n    for i in range(2, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2])\n\n    return fib[n]\n\ndef g():\n    n = 6\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 221,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a given string is a palindrome\"\"\"\n    return s == s[::-1]\n\ndef g() -> str:\n    return \"racecar\"\n\nassert f(g()) == True\n",
        "idx_generation": 142,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of set bits in its binary representation.\n\n    Sample Input:\n    n = 10\n\n    Sample Output:\n    2\n\n    Explanation:\n    The binary representation of 10 is 1010, which has 2 set bits.\n    \"\"\"\n\n    count = 0\n\n    while n > 0:\n        if n & 1:  # check if the rightmost bit is set\n            count += 1\n        n >>= 1  # right shift the number by 1 bit\n\n    return count\n\ndef g(n: int = 10) -> int:\n    return n\n\nassert f(g()) == 2\n",
        "idx_generation": 433,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nimport math\n\ndef f(n: int) -> str:\n    \"\"\"\n    Given an integer n, return its factorial as a string. The factorial of n is the product of all positive integers less than or equal to n.\n\n    Example:\n    f(5) -> \"120\" (5! = 5 * 4 * 3 * 2 * 1 = 120)\n\n    Return the factorial of n as a string.\n    \"\"\"\n    if n < 0:\n        return \"Invalid input\"\n    if n == 0 or n == 1:\n        return \"1\"\n    else:\n        factorial = math.factorial(n)\n        return str(factorial)\n\n\ndef g():\n    n = 5\n    return n\n\n\nassert f(g()) == \"120\"\n\n",
        "idx_generation": 246,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(adj_list: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given an adjacency list representation of a graph and two nodes start and end, determine if there exists a path from start to end.\n    \n    Example:\n    adj_list = [[1, 2], [3], [4], [5], [], []]\n    start = 0\n    end = 5\n    \n    Output:\n    True\n    \n    Explanation:\n    There exists a path from node 0 to node 5 in the graph.\n    \"\"\"\n    visited = [False] * len(adj_list)\n    stack = [start]\n    \n    while stack:\n        node = stack.pop()\n        visited[node] = True\n        \n        if node == end:\n            return True\n        \n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                stack.append(neighbor)\n    \n    return False\n\ndef g():\n    adj_list = [[1, 2], [3], [4], [5], [], []]\n    start = 0\n    end = 5\n    return adj_list, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 380,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[List[int]]:\n    \"\"\"\n    Given an array of integers nums and an integer k, return all possible combinations of k elements from the array.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    k = 2\n\n    Output:\n    [\n        [1, 2],\n        [1, 3],\n        [1, 4],\n        [2, 3],\n        [2, 4],\n        [3, 4]\n    ]\n\n    Explanation:\n    All possible combinations of 2 elements from the array are returned.\n\n    \"\"\"\n\n    result = []\n    def backtrack(curr_comb, start):\n        if len(curr_comb) == k:\n            result.append(curr_comb[:])\n            return\n\n        for i in range(start, len(nums)):\n            curr_comb.append(nums[i])\n            backtrack(curr_comb, i + 1)\n            curr_comb.pop()\n\n    backtrack([], 0)\n    return result\n\ndef g(nums=[1, 2, 3, 4], k=2):\n    return nums, k\n\nassert f(*g()) == [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n\n",
        "idx_generation": 495,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target element using binary search.\n    Return -1 if the target element is not found.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    nums = [1, 3, 5, 7, 9, 11]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 3\n",
        "idx_generation": 117,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    Input:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output:\n    4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n\n    Note: The subsequence can be non-contiguous.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g(nums: List[int] = [10, 9, 2, 5, 3, 7, 101, 18]):\n    return (nums,)\n\nassert f(*g()) == 4\n",
        "idx_generation": 435,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in the list that sum up to the target. Return their indices in a list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Hint: Use a dictionary to store the complement of each number and its index.\n    \"\"\"\n\n    complement_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complement_dict:\n            return [complement_dict[complement], i]\n        complement_dict[num] = i\n\n    return []\n\ndef g():\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 100,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence (LIS) in nums.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    Output:\n    4 (since the longest increasing subsequence is [2, 3, 7, 101])\n    \"\"\"\n    if not nums:\n        return 0\n    \n    dp = [1] * len(nums)\n\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 221,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(string: str, old: str, new: str) -> str:\n    \"\"\"\n    Given a string 'string', replace all occurrences of the substring 'old' with the substring 'new'.\n\n    Example:\n    string = \"Hello, World!\"\n    old = \"World\"\n    new = \"Universe\"\n\n    Output:\n    \"Hello, Universe!\"\n\n    Explanation:\n    The substring \"World\" is replaced with the substring \"Universe\".\n\n    Hint: Use string manipulation techniques to replace the substring.\n    \"\"\"\n\n    return string.replace(old, new)\n\ndef g() -> Tuple[str, str, str]:\n    string = \"Hello, World!\"\n    old = \"World\"\n    new = \"Universe\"\n    return string, old, new\n\nassert f(*g()) == \"Hello, Universe!\"\n",
        "idx_generation": 151,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the factorial of n using bit manipulation.\n\n    Sample Input:\n    n = 5\n\n    Sample Output:\n    120\n    \"\"\"\n    fact = 1\n    i = 1\n    while i <= n:\n        fact *= i\n        i += 1\n    return fact\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 120\n",
        "idx_generation": 438,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of distinct subsequences that can be formed from the list such that the sum\n    of elements in each subsequence is divisible by 3.\n    \"\"\"\n    n = len(nums)\n    count = [0] * 3\n    count[0] = 1\n    ans = 0\n    total_sum = 0\n\n    for i in range(n):\n        total_sum += nums[i]\n        rem = total_sum % 3\n        ans += count[rem]\n        count[rem] += 1\n\n    return ans\n\ndef g(nums: List[int]) -> List[int]:\n    return nums\n\nassert f(g([1, 2, 3])) == 3\n\n",
        "idx_generation": 246,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of valid paths from the top-left corner to the bottom-right corner\n    of an n x n grid. You can only move down or right.\n\n    Example:\n    n = 3\n\n    Output:\n    6\n\n    Explanation:\n    There are 6 valid paths:\n    - Right -> Right -> Down\n    - Right -> Down -> Right\n    - Down -> Right -> Right\n    - Right -> Down -> Down\n    - Down -> Right -> Down\n    - Down -> Down -> Right\n    \"\"\"\n\n    def count_paths(x: int, y: int) -> int:\n        if x == n-1 and y == n-1:\n            return 1\n        if x >= n or y >= n:\n            return 0\n        return count_paths(x+1, y) + count_paths(x, y+1)\n\n    return count_paths(0, 0)\n\ndef g() -> int:\n    n = 3\n    return n\n\nassert f(g()) == 6\n\n",
        "idx_generation": 381,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(x: int) -> bool:\n    \"\"\"\n    Check if the input integer is a perfect square.\n    \"\"\"\n    if x < 0:\n        return False\n    if x == 0:\n        return True\n    left, right = 1, x\n    while left <= right:\n        mid = left + (right - left) // 2\n        if mid * mid == x:\n            return True\n        elif mid * mid < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef g() -> int:\n    x = 16\n    return x\n\nassert f(g()) == True\n",
        "idx_generation": 119,
        "target_skills": [
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers and a target value, find two numbers in the array that sum up to the target.\n    Return the indices of the two numbers in the array.\n\n    Args:\n    - arr: A list of integers, sorted in ascending order.\n    - target: An integer, the target sum.\n\n    Returns:\n    - A list of two integers, the indices of the two numbers that sum up to the target.\n\n    Example:\n    arr = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1] (arr[0] + arr[1] = 2 + 7 = 9)\n    \"\"\"\n    def binary_search(arr: List[int], left: int, right: int, target: int) -> int:\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == target:\n                return mid\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\n    for i in range(len(arr)):\n        complement = target - arr[i]\n        index = binary_search(arr, i+1, len(arr)-1, complement)\n        if index != -1:\n            return [i, index]\n\n    return []\n\ndef g() -> List[int]:\n    arr = [2, 7, 11, 15]\n    target = 9\n    return arr, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 436,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number is a prime number.\n\n    Sample Input:\n    n = 13\n\n    Sample Output:\n    True\n    \"\"\"\n    if n < 2:\n        return False\n\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n\n    return True\n\ndef g(n=13):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 102,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the length of the longest increasing subsequence.\n\n    Sample Input:\n    arr = [10, 22, 9, 33, 21, 50, 41, 60]\n\n    Sample Output:\n    5\n    \"\"\"\n    n = len(arr)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g(arr=[10, 22, 9, 33, 21, 50, 41, 60]):\n    return arr\n\nassert f(g()) == 5\n",
        "idx_generation": 222,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if they are isomorphic.\n\n    Two strings are isomorphic if the characters in s can be replaced to get t.\n\n    Example:\n    s = \"egg\"\n    t = \"add\"\n\n    Output:\n    True\n    \"\"\"\n    if len(s) != len(t):\n        return False\n\n    mapping_s = {}\n    mapping_t = {}\n    for i in range(len(s)):\n        if s[i] not in mapping_s and t[i] not in mapping_t:\n            mapping_s[s[i]] = t[i]\n            mapping_t[t[i]] = s[i]\n        elif mapping_s.get(s[i]) != t[i] or mapping_t.get(t[i]) != s[i]:\n            return False\n\n    return True\n\ndef g(s: str = \"egg\", t: str = \"add\"):\n    return s, t\n\nassert f(*g()) == True\n",
        "idx_generation": 152,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Find the number of set bits in a binary representation of a given number n.\n\n    Example:\n    Input: n = 6\n    Output: 2\n    Explanation: The binary representation of 6 is 110, which contains 2 set bits.\n\n    Input: n = 10\n    Output: 2\n    Explanation: The binary representation of 10 is 1010, which contains 2 set bits.\n    \"\"\"\n\n    count = 0\n\n    while n > 0:\n        if n & 1 == 1:\n            count += 1\n        n >>= 1\n\n    return count\n\ndef g() -> int:\n    return 6\n\nassert f(g()) == 2\n\n",
        "idx_generation": 441,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the sum of the first n natural numbers.\n\n    Example:\n    n = 5\n\n    Output:\n    15 (1 + 2 + 3 + 4 + 5 = 15)\n    \"\"\"\n    return n * (n + 1) // 2\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == 15\n",
        "idx_generation": 249,
        "target_skills": [
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph, check if it is bipartite.\n    \"\"\"\n    visited = {}\n    for node in range(len(graph)):\n        if node not in visited:\n            if not dfs(graph, node, 0, visited):\n                return False\n    return True\n\ndef dfs(graph: List[List[int]], node: int, color: int, visited: dict) -> bool:\n    \"\"\"\n    Depth-first search to check if a graph is bipartite.\n    \"\"\"\n    visited[node] = color\n    for neighbor in graph[node]:\n        if neighbor in visited:\n            if visited[neighbor] == color:\n                return False\n        else:\n            if not dfs(graph, neighbor, 1-color, visited):\n                return False\n    return True\n\ndef g(graph: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Generate an undirected graph that is bipartite. Return the generated graph.\n    \"\"\"\n    return graph\n\nassert f(g([[1,3],[0,2],[1,3],[0,2]])) == True\n",
        "idx_generation": 385,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers, determine if there exists two numbers in the array that add up to a target value.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 120,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target value, find two numbers in the list that add up to the target value.\n    Return the indices of the two numbers in a list.\n\n    Example:\n    arr = [2, 5, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 2]\n\n    Explanation:\n    The numbers at indices 0 and 2 (2 and 7) add up to the target value 9.\n\n    Constraints:\n    - The list will be sorted in ascending order.\n    - The list will not be empty.\n    - There will always be a solution.\n    \"\"\"\n\n    left, right = 0, len(arr) - 1\n\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return [left, right]\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g(arr=[2, 5, 7, 11, 15], target=9):\n    return arr, target\n\nassert f(*g()) == [0, 2]\n\n",
        "idx_generation": 439,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, return True if n is a prime number, False otherwise.\n    \"\"\"\n    if n < 2:\n        return False\n    \n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    \n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n",
        "idx_generation": 104,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the number of paths from the top-left cell to the bottom-right cell\n    by only moving right or down.\n\n    Return the number of paths.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    6\n\n    Explanation:\n    The grid represents the following matrix:\n    1 2 3\n    4 5 6\n    7 8 9\n    There are 6 paths from the top-left cell to the bottom-right cell:\n    1 -> 2 -> 3 -> 6 -> 9\n    1 -> 2 -> 5 -> 6 -> 9\n    1 -> 4 -> 5 -> 6 -> 9\n    1 -> 4 -> 5 -> 8 -> 9\n    1 -> 4 -> 7 -> 8 -> 9\n    1 -> 4 -> 7 -> 8 -> 9\n    \"\"\"\n\n    def count_paths(grid):\n        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n\n        dp[0][0] = 1\n\n        for i in range(1, m):\n            dp[i][0] = dp[i - 1][0] if grid[i][0] != 0 else 0\n\n        for j in range(1, n):\n            dp[0][j] = dp[0][j - 1] if grid[0][j] != 0 else 0\n\n        for i in range(1, m):\n            for j in range(1, n):\n                if grid[i][j] != 0:\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n        return dp[m - 1][n - 1]\n\n    return count_paths(grid)\n\ndef g():\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g()) == 6\n",
        "idx_generation": 228,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome after removing at most one character.\n\n    Example:\n    s = \"racecar\"\n\n    Output:\n    True\n    \"\"\"\n    left = 0\n    right = len(s) - 1\n\n    while left < right:\n        if s[left] != s[right]:\n            return s[left+1:right+1] == s[left+1:right+1][::-1] or s[left:right] == s[left:right][::-1]\n        left += 1\n        right -= 1\n\n    return True\n\ndef g(s: str = \"racecar\"):\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 152,
        "target_skills": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n    \"\"\"\n\n    def find_max_xor(nums):\n        max_xor = 0\n        mask = 0\n        for i in range(31, -1, -1):\n            mask |= (1 << i)\n            prefix_set = set()\n            for num in nums:\n                prefix_set.add(num & mask)\n            temp_max = max_xor | (1 << i)\n            for prefix in prefix_set:\n                if prefix ^ temp_max in prefix_set:\n                    max_xor = temp_max\n                    break\n        return max_xor\n\n    return find_max_xor(nums)\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n\n",
        "idx_generation": 444,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of trailing zeroes in n! (n factorial).\n    \"\"\"\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n    return count\n\ndef g(n: int = 25):\n    return n\n\nassert f(g()) == 6\n\n",
        "idx_generation": 251,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, determine if the graph contains any cycles.\n\n    Example:\n    graph = [[1, 2], [3], [3, 4], [4], []]\n\n    Output:\n    True (the graph contains cycles)\n    \"\"\"\n    n = len(graph)\n    visited = [False] * n\n    \n    def dfs(node, parent):\n        visited[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node):\n                    return True\n            elif neighbor != parent:\n                return True\n        \n        return False\n    \n    for i in range(n):\n        if not visited[i]:\n            if dfs(i, -1):\n                return True\n    \n    return False\n\ndef g() -> List[List[int]]:\n    graph = [[1, 2], [3], [3, 4], [4], []]\n    return graph\n\nassert f(g()) == True\n\n",
        "idx_generation": 386,
        "target_skills": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order using the bubble sort algorithm.\n\n    Sample Input:\n    nums = [5, 3, 8, 2, 1]\n\n    Sample Output:\n    [1, 2, 3, 5, 8]\n    \"\"\"\n\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    return nums\n\ndef g(nums: List[int] = [5, 3, 8, 2, 1]):\n    return (nums,)\n\nassert f(*g()) == [1, 2, 3, 5, 8]\n",
        "idx_generation": 121,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers, sort the array in non-decreasing order.\n\n    Return the sorted array.\n\n    Example:\n    arr = [3, 1, 5, 2, 4]\n\n    Output:\n    [1, 2, 3, 4, 5]\n\n    Explanation:\n    The sorted array is [1, 2, 3, 4, 5].\n    \"\"\"\n\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr\n\n        mid = len(arr) // 2\n        left = merge_sort(arr[:mid])\n        right = merge_sort(arr[mid:])\n\n        return merge(left, right)\n\n    def merge(left, right):\n        result = []\n        i = j = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n\n        result.extend(left[i:])\n        result.extend(right[j:])\n\n        return result\n\n    return merge_sort(arr)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate an unsorted array of integers.\n    \"\"\"\n    return [3, 1, 5, 2, 4]\n\nassert f(g()) == [1, 2, 3, 4, 5]\n",
        "idx_generation": 445,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, calculate the sum of the squares of all the even integers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    20\n\n    Explanation:\n    The even integers in the list are 2 and 4. The sum of the squares of these even integers is 2^2 + 4^2 = 20.\n    \"\"\"\n\n    even_sum = 0\n\n    for num in nums:\n        if num % 2 == 0:\n            even_sum += num**2\n\n    return even_sum\n\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    return nums\n\n\nassert f(g()) == 20\n",
        "idx_generation": 107,
        "target_skills": [
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Find the number of unique paths from the top-left corner to the bottom-right corner of a grid.\n    You can only move down or right at each step.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    # Create a 2D table to store the number of unique paths\n    dp = [[0] * n for _ in range(m)]\n\n    # Base case: there is only one way to reach the top-left corner\n    dp[0][0] = 1\n\n    # Fill the table bottom-up\n    for i in range(m):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n\n    # The number of unique paths to the bottom-right corner is stored in the last cell\n    return dp[m-1][n-1]\n\ndef g():\n    return [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n        [1, 1, 1, 1]\n    ]\n\nassert f(g()) == 10\n",
        "idx_generation": 230,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"\n    Check if the target string is a substring of the given string.\n    \"\"\"\n    return target in s\n\ndef g(s: str, target: str) -> str:\n    \"\"\"\n    Generate a string where the target string is a substring.\n    \"\"\"\n    return s + target\n\nassert f(g(\"hello\", \"lo\"), \"lo\") == True\n",
        "idx_generation": 161,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, check if it is a power of 2.\n\n    Sample Input:\n    n = 16\n\n    Sample Output:\n    True\n    \"\"\"\n    return n != 0 and (n & (n - 1)) == 0\n\ndef g():\n    n = 16\n    return n\n\nassert f(g()) == True\n\n",
        "idx_generation": 445,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a power of two.\n\n    Return True if n is a power of two, False otherwise.\n\n    Example:\n    n = 16\n\n    Output:\n    True\n\n    Explanation:\n    16 is a power of two (2^4 = 16).\n    \"\"\"\n\n    if n <= 0:\n        return False\n\n    return (n & (n - 1)) == 0\n\ndef g(n=16):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 252,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, check if the graph contains a cycle.\n\n    Args:\n    - graph: A list of lists, where each inner list represents the neighbors of a node.\n    \n    Returns:\n    - True if the graph contains a cycle, False otherwise.\n    \"\"\"\n    visited = set()\n    def dfs(node, parent):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, node):\n                    return True\n            elif neighbor != parent:\n                return True\n        return False\n    \n    for node in range(len(graph)):\n        if node not in visited:\n            if dfs(node, -1):\n                return True\n    return False\n\ndef g():\n    graph = [[1, 2], [0, 2], [0, 1, 3], [2, 4], [3]]\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 387,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> float:\n    \"\"\"\n    Given a list of 2D points, find the area of the smallest rectangle that can enclose all the points.\n    \"\"\"\n    min_x = min(points, key=lambda p: p[0])[0]\n    max_x = max(points, key=lambda p: p[0])[0]\n    min_y = min(points, key=lambda p: p[1])[1]\n    max_y = max(points, key=lambda p: p[1])[1]\n\n    width = max_x - min_x\n    height = max_y - min_y\n\n    return width * height\n\ndef g() -> List[List[int]]:\n    points = [[0, 0], [0, 2], [2, 0], [2, 2]]\n    return points\n\nassert f(g()) == 4.0\n\n",
        "idx_generation": 122,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums sorted in ascending order, find two numbers such that they add up to a specific target number.\n\n    Return the indices of the two numbers (1-indexed) as a list of integers, where the first index is less than the second index.\n\n    You may assume that each input would have exactly one solution and you may not use the same element twice.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [1, 2]\n\n    Explanation:\n    The sum of numbers at indices 1 and 2 is equal to the target 9.\n\n    \"\"\"\n\n    def two_sum(nums: List[int], target: int) -> List[int]:\n        left, right = 0, len(nums) - 1\n\n        while left < right:\n            curr_sum = nums[left] + nums[right]\n            if curr_sum == target:\n                return [left + 1, right + 1]\n            elif curr_sum < target:\n                left += 1\n            else:\n                right -= 1\n\n        return []\n\n    return two_sum(nums, target)\n\ndef g():\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [1, 2]\n\n",
        "idx_generation": 448,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n    \"\"\"\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n    return max_product\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 20\n",
        "idx_generation": 110,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target value, check if there exists a subset of nums that sums up to the target.\n\n    Sample Input:\n    nums = [2, 4, 6, 8]\n    target = 10\n\n    Sample Output:\n    True\n\n    Explanation:\n    The subset [2, 8] sums up to the target value 10.\n    \"\"\"\n    n = len(nums)\n\n    def subset_sum(nums: List[int], target: int, index: int) -> bool:\n        if target == 0:\n            return True\n        if index >= n or target < 0:\n            return False\n\n        return subset_sum(nums, target - nums[index], index + 1) or subset_sum(nums, target, index + 1)\n\n    return subset_sum(nums, target, 0)\n\ndef g(nums: List[int] = [2, 4, 6, 8], target: int = 10) -> bool:\n    return nums, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 232,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it can be formed by concatenating multiple copies of a substring of s.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            substring = s[:i]\n            if substring * (n // i) == s:\n                return True\n    return False\n\ndef g():\n    s = \"abcabcabc\"\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 161,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum XOR value of any two numbers in the list.\n\n    Example:\n    Input:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output: 28\n\n    Explanation: The maximum XOR value can be obtained by taking the XOR of 5 and 25, which results in 28.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            max_xor = max(max_xor, nums[i]^nums[j])\n\n    return max_xor\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n\n",
        "idx_generation": 452,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a square matrix of integers, determine if it is a magic square.\n    A magic square is a square matrix in which the sums of each row, each column, and both diagonals are the same.\n\n    Example:\n    matrix = [[2, 7, 6],\n              [9, 5, 1],\n              [4, 3, 8]]\n    The sum of each row, column, and diagonal is 15, so the matrix is a magic square.\n    \"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check columns\n    for j in range(n):\n        col_sum = 0\n        for i in range(n):\n            col_sum += matrix[i][j]\n        if col_sum != target_sum:\n            return False\n    \n    # Check diagonal 1\n    diag_sum = 0\n    for i in range(n):\n        diag_sum += matrix[i][i]\n    if diag_sum != target_sum:\n        return False\n    \n    # Check diagonal 2\n    diag_sum = 0\n    for i in range(n):\n        diag_sum += matrix[i][n-i-1]\n    if diag_sum != target_sum:\n        return False\n    \n    return True\n\ndef g():\n    return [[2, 7, 6],\n            [9, 5, 1],\n            [4, 3, 8]]\n\nassert f(g()) == True\n",
        "idx_generation": 255,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 1s and 0s, find the length of the largest island.\n\n    Args:\n    - grid: A list of lists, where each inner list represents a row in the grid.\n    \n    Returns:\n    - The length of the largest island in the grid.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    max_island = 0\n    \n    def dfs(row, col):\n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] != 1:\n            return 0\n        \n        grid[row][col] = -1\n        island_size = 1\n        \n        island_size += dfs(row+1, col)\n        island_size += dfs(row-1, col)\n        island_size += dfs(row, col+1)\n        island_size += dfs(row, col-1)\n        \n        return island_size\n    \n    for row in range(rows):\n        for col in range(cols):\n            if grid[row][col] == 1:\n                max_island = max(max_island, dfs(row, col))\n    \n    return max_island\n\ndef g():\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 0, 1, 1],\n        [0, 0, 0, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 4\n",
        "idx_generation": 387,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three integers in the list.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5, 6]\n    return nums\n\nassert f(g()) == 120\n\n",
        "idx_generation": 122,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target in the list using binary search.\n    If the target is not found, return -1.\n\n    Example:\n    Input: [1, 3, 5, 7, 9], target = 5\n\n    Output: 2\n\n    Explanation:\n    The target value 5 is found at index 2 in the list.\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(nums = [1, 3, 5, 7, 9], target = 5):\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 449,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if a number is a perfect square.\n    \"\"\"\n    return n >= 0 and int(n ** 0.5) ** 2 == n\n\ndef g(n: int) -> int:\n    \"\"\"\n    Find the nearest perfect square less than or equal to n.\n    \"\"\"\n    while not f(n):\n        n -= 1\n    return n\n\nn = 25\nassert f(g(n))\n",
        "idx_generation": 114,
        "target_skills": [
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    \n    Constraints:\n    - You can only move right or down.\n    - The grid has at least one row and one column.\n    - All numbers in the grid are non-negative.\n    \n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    \n    The maximum sum path is 1 -> 3 -> 5 -> 2 -> 1, with a sum of 12.\n    \n    Therefore, the expected output is 12.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 12\n",
        "idx_generation": 233,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forwards and backwards.\n\n    Example:\n    s = \"racecar\"\n\n    Output:\n    True\n\n    Explanation:\n    The string \"racecar\" is the same forwards and backwards, so it is a palindrome.\n    \"\"\"\n    low = 0\n    high = len(s) - 1\n    while low < high:\n        if s[low] != s[high]:\n            return False\n        low += 1\n        high -= 1\n    return True\n\ndef g() -> str:\n    return \"racecar\"\n\nassert f(g()) == True\n",
        "idx_generation": 162,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, count the number of set bits (1s) in its binary representation.\n\n    Example:\n    n = 7\n\n    Output:\n    3\n\n    Explanation:\n    The binary representation of 7 is 111, which contains 3 set bits.\n    \"\"\"\n\n    count = 0\n\n    while n > 0:\n        if n & 1:\n            count += 1\n        n >>= 1\n\n    return count\n\ndef g(n: int) -> int:\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    return n\n\nassert f(g(7)) == 3\n",
        "idx_generation": 456,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if there exists a row or column where the sum of the elements is a perfect square.\n    \"\"\"\n    n = len(matrix)\n    m = len(matrix[0])\n\n    row_sums = [sum(row) for row in matrix]\n    col_sums = [sum(col) for col in zip(*matrix)]\n\n    for i in range(n):\n        if is_perfect_square(row_sums[i]):\n            return True\n\n    for j in range(m):\n        if is_perfect_square(col_sums[j]):\n            return True\n\n    return False\n\ndef is_perfect_square(n: int) -> bool:\n    \"\"\"\n    Check if a number is a perfect square.\n    \"\"\"\n    sqrt_n = int(n ** 0.5)\n    return sqrt_n * sqrt_n == n\n\ndef g(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    This solution calculates the sum of each row and column in the matrix and returns the resulting matrix.\n    \"\"\"\n    row_sums = [sum(row) for row in matrix]\n    col_sums = [sum(col) for col in zip(*matrix)]\n\n    return [row_sums, col_sums]\n\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nassert f(g(matrix)) == False\n\n",
        "idx_generation": 263,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> int:\n    \"\"\"\n    Given the root of a binary tree, find the maximum path sum.\n\n    Args:\n    - root: The root of the binary tree.\n\n    Returns:\n    - The maximum path sum.\n    \"\"\"\n    max_sum = float('-inf')\n    \n    def max_path_sum(node):\n        nonlocal max_sum\n        if not node:\n            return 0\n        \n        left_sum = max(0, max_path_sum(node.left))\n        right_sum = max(0, max_path_sum(node.right))\n        \n        max_sum = max(max_sum, node.val + left_sum + right_sum)\n        \n        return node.val + max(left_sum, right_sum)\n    \n    max_path_sum(root)\n    \n    return max_sum\n\ndef g():\n    # Create a binary tree\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n\n    return root\n\nassert f(g()) == 11\n\n",
        "idx_generation": 389,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the sum of all even numbers in the list.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5, 6]\n    Output: 12\n    Explanation: The even numbers in the list are 2, 4, and 6. Their sum is 12.\n    \"\"\"\n\n    even_sum = 0\n    for num in nums:\n        if num % 2 == 0:\n            even_sum += num\n    return even_sum\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6]\n    return nums\n\nassert f(g()) == 12\n",
        "idx_generation": 122,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array nums, and a target value target, find two numbers in nums such that they add up to target.\n    Return the indices of the two numbers (1-indexed) as a list, where the index1 must be less than index2.\n\n    Args:\n    - nums: A list of integers representing the sorted array.\n    - target: An integer representing the target value.\n\n    Returns:\n    - A list of two integers representing the indices of the two numbers that add up to target.\n    \"\"\"\n    n = len(nums)\n    left, right = 0, n - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left + 1, right + 1]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return [nums, target]\n\nassert f(*g()) == [1, 2]\n",
        "idx_generation": 456,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix, return True if it is a symmetric matrix and False otherwise.\n    \"\"\"\n    n = len(matrix)\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] != matrix[j][i]:\n                return False\n    return True\ndef g():\n    matrix = [[1, 2, 3], [2, 4, 5], [3, 5, 6]]\n    return matrix\nassert f(g()) == True\n",
        "idx_generation": 115,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the length of the longest increasing subsequence (LIS).\n    A subsequence is a sequence that can be derived from another sequence by deleting some or no elements\n    without changing the order of the remaining elements.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 233,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> str:\n    \"\"\"\n    Given a string and an integer n, rotate the string to the right by n places.\n\n    Example:\n    s = \"abcdefg\"\n    n = 3\n\n    Output:\n    \"efgabcd\"\n\n    Explanation:\n    The string \"abcdefg\" is rotated to the right by 3 places, resulting in \"efgabcd\".\n    \"\"\"\n    if n <= 0 or len(s) == 0:\n        return s\n\n    n = n % len(s)\n    return s[-n:] + s[:-n]\n\ndef g():\n    s = \"abcdefg\"\n    n = 3\n    return (s, n)\n\nassert f(*g()) == \"efgabcd\"\n\n",
        "idx_generation": 164,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n        for num in nums:\n            prefix_set.add(num & mask)\n        candidate = max_xor | (1 << i)\n        for prefix in prefix_set:\n            if candidate ^ prefix in prefix_set:\n                max_xor = candidate\n                break\n    return max_xor\n\ndef g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n",
        "idx_generation": 459,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if n is a prime number and the sum of its digits is a perfect square.\n    \"\"\"\n    if is_prime(n):\n        digit_sum = sum(int(digit) for digit in str(n))\n        return is_perfect_square(digit_sum)\n    return False\n\ndef is_prime(n: int) -> bool:\n    \"\"\"\n    Check if a number is prime.\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef is_perfect_square(n: int) -> bool:\n    \"\"\"\n    Check if a number is a perfect square.\n    \"\"\"\n    sqrt_n = int(n ** 0.5)\n    return sqrt_n * sqrt_n == n\n\ndef g(n: int) -> int:\n    \"\"\"\n    This solution calculates the sum of the first n prime numbers and returns the result.\n    \"\"\"\n    primes = []\n    num = 2\n    while len(primes) < n:\n        if is_prime(num):\n            primes.append(num)\n        num += 1\n\n    return sum(primes)\n\nn = 5\nassert f(g(n)) == False\n\n",
        "idx_generation": 263,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum path from the top-left corner to the bottom-right corner, by moving only right or down.\n\n    Sample Input:\n    grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\n    Sample Output:\n    7\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 7\n",
        "idx_generation": 393,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n    \"\"\"\n    # Sort the list in ascending order\n    nums.sort()\n    \n    # Return the maximum of the product of the three largest numbers or the product of the two smallest numbers and the largest number\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\n\ndef g(nums=[-10, -10, 1, 3, 2]):\n    return nums\n\nassert f(g()) == 300\n",
        "idx_generation": 123,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target number using binary search.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output:\n    2 (the index of the target number 5 is 2)\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    return [1, 3, 5, 7, 9], 5\n\nassert f(*g()) == 2\n",
        "idx_generation": 457,
        "target_skills": [
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Two Sum\n\n    Given a list of integers and a target integer, return the indices of two numbers in the list that add up to the target.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    output: [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1 (2 and 7) add up to the target 9.\n    \"\"\"\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    return []\n\ndef g(nums = [2, 7, 11, 15], target = 9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 115,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(coins: List[int], amount: int) -> int:\n    \"\"\"\n    Given a list of coin denominations and a total amount, find the minimum number of coins needed\n    to make up the amount. If it is not possible to make up the amount using the given coins,\n    return -1.\n\n    Example:\n    coins = [1, 2, 5]\n    amount = 11\n\n    Output:\n    3\n\n    Explanation:\n    5 + 5 + 1 = 11\n    \"\"\"\n\n    def coin_change(amount: int, memo: Dict[int, int]) -> int:\n        if amount in memo:\n            return memo[amount]\n        if amount == 0:\n            return 0\n        if amount < 0:\n            return -1\n\n        min_coins = float('inf')\n\n        for coin in coins:\n            remaining = amount - coin\n            result = coin_change(remaining, memo)\n            if result >= 0:\n                min_coins = min(min_coins, 1 + result)\n\n        memo[amount] = -1 if min_coins == float('inf') else min_coins\n        return memo[amount]\n\n    memo = {}\n    return coin_change(amount, memo)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    return ([1, 2, 5], 11)\n\nassert f(*g()) == 3\n",
        "idx_generation": 240,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if the given integer n is a palindrome.\n\n    Args:\n    - n: An integer.\n\n    Returns:\n    - True if the integer is a palindrome, False otherwise.\n    \"\"\"\n    str_n = str(n)\n    return str_n == str_n[::-1]\n\ndef g():\n    n = 12321\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 164,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR value between two numbers in the array.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value between two numbers in the array is 28, which is the result of XORing 5 and 25.\n\n    Constraints:\n    - The length of the input list will always be at least 2.\n    - The input list may contain duplicate elements.\n    \"\"\"\n\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n\n        for num in nums:\n            prefix = num & mask\n            prefix_set.add(prefix)\n\n        candidate = max_xor | (1 << i)\n\n        for prefix in prefix_set:\n            if candidate ^ prefix in prefix_set:\n                max_xor = candidate\n                break\n\n    return max_xor\n\ndef g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n",
        "idx_generation": 466,
        "target_skills": [
            1,
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a square matrix of integers, calculate the sum of all the elements in the matrix.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    Output:\n    45\n\n    Hint: Use nested loops to iterate over each element in the matrix and accumulate the sum.\n    \"\"\"\n\n    n = len(matrix)\n    m = len(matrix[0])\n    total_sum = 0\n\n    for i in range(n):\n        for j in range(m):\n            total_sum += matrix[i][j]\n\n    return total_sum\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a square matrix of integers.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 45\n",
        "idx_generation": 266,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, determine if it contains a Hamiltonian path.\n\n    Args:\n    - graph: The adjacency matrix representing the graph.\n\n    Returns:\n    - True if the graph contains a Hamiltonian path, False otherwise.\n    \"\"\"\n    n = len(graph)\n    for mask in range(1, 1 << n):\n        path = []\n        for node in range(n):\n            if mask & (1 << node):\n                path.append(node)\n        if is_hamiltonian(graph, path):\n            return True\n    return False\n\ndef is_hamiltonian(graph: List[List[int]], path: List[int]) -> bool:\n    for i in range(len(path) - 1):\n        if not graph[path[i]][path[i+1]]:\n            return False\n    return True\n\ndef g():\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 1],\n        [1, 0, 0, 1],\n        [1, 1, 0, 0]\n    ]\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 395,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all positive integers less than or equal\n    to n that are divisible by either 3 or 5.\n\n    Return the sum.\n\n    Example:\n    n = 10\n\n    Output:\n    33\n\n    Explanation:\n    The positive integers less than or equal to 10 that are divisible by either 3 or 5 are:\n    3, 5, 6, 9, 10. The sum of these numbers is 33.\n    \"\"\"\n\n    def sum_divisible_numbers(n):\n        total_sum = 0\n        for i in range(1, n+1):\n            if i % 3 == 0 or i % 5 == 0:\n                total_sum += i\n        return total_sum\n\n    return sum_divisible_numbers(n)\n\ndef g(n: int):\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return n\n\nassert f(g(10)) == 33\n",
        "idx_generation": 124,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n    If the target value is not found, return -1.\n    \"\"\"\n    def binary_search(nums, target, start, end):\n        if start > end:\n            return -1\n        mid = (start + end) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] > target:\n            return binary_search(nums, target, start, mid - 1)\n        else:\n            return binary_search(nums, target, mid + 1, end)\n\n    return binary_search(nums, target, 0, len(nums) - 1)\n\ndef g():\n    nums = [1, 3, 5, 7, 9, 11, 13, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == 4\n",
        "idx_generation": 459,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of numbers, find the maximum product of any two numbers in the list.\n    \"\"\"\n    max_product = float('-inf')\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n\n    return max_product\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5]):\n    \"\"\"\n    Generate a list of numbers.\n    \"\"\"\n    return nums\n\nassert f(g()) == 20\n",
        "idx_generation": 116,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subsequence where no two elements\n    are adjacent.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    9\n\n    Explanation:\n    The maximum sum can be obtained by selecting elements 1, 3, and 5.\n    \"\"\"\n\n    def max_sum(nums: List[int], idx: int, memo: Dict[int, int]) -> int:\n        if idx in memo:\n            return memo[idx]\n        if idx < 0:\n            return 0\n\n        max_sum_1 = max_sum(nums, idx - 1, memo)\n        max_sum_2 = max_sum(nums, idx - 2, memo) + nums[idx]\n\n        memo[idx] = max(max_sum_1, max_sum_2)\n        return memo[idx]\n\n    memo = {}\n    return max_sum(nums, len(nums) - 1, memo)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 9\n",
        "idx_generation": 240,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\n\ndef f(s: str) -> str:\n    \"\"\"\n    Reverse the words in a given string.\n\n    Args:\n    - s: A string.\n\n    Returns:\n    - The string with reversed words.\n    \"\"\"\n    words = s.split()\n    reversed_words = [word[::-1] for word in words]\n    return ' '.join(reversed_words)\n\ndef g():\n    s = \"Hello World\"\n    return s\n\nassert f(g()) == \"olleH dlroW\"\n\n",
        "idx_generation": 164,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the maximum number of consecutive 1s in the binary representation of any number in nums.\n\n    Example:\n    Input: [1, 15, 7, 6]\n    Output: 4\n\n    Explanation:\n    The binary representation of 1 is '1' (1 consecutive 1).\n    The binary representation of 15 is '1111' (4 consecutive 1s).\n    The binary representation of 7 is '111' (3 consecutive 1s).\n    The binary representation of 6 is '110' (2 consecutive 1s).\n    The maximum number of consecutive 1s is 4.\n    \"\"\"\n\n    max_consecutive_ones = 0\n\n    for num in nums:\n        consecutive_ones = 0\n        while num > 0:\n            if num % 2 == 1:\n                consecutive_ones += 1\n            else:\n                consecutive_ones = 0\n            max_consecutive_ones = max(max_consecutive_ones, consecutive_ones)\n            num //= 2\n\n    return max_consecutive_ones\n\ndef g() -> List[int]:\n    return [1, 15, 7, 6]\n\nassert f(g()) == 4\n",
        "idx_generation": 466,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nimport math\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a perfect square or not.\n    \n    Example:\n    n = 16\n    \n    Output:\n    True\n    \n    Explanation:\n    16 is a perfect square because sqrt(16) = 4.\n    \"\"\"\n    sqrt_n = math.isqrt(n)\n    \n    return sqrt_n * sqrt_n == n\n\ndef g(n: int = 16):\n    \"\"\"\n    Generate an integer for the function f.\n    \"\"\"\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 269,
        "target_skills": [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, determine if there is a cycle in the graph.\n\n    Example:\n    graph = [[0, 1, 0, 0],\n             [0, 0, 1, 0],\n             [0, 0, 0, 1],\n             [1, 0, 0, 0]]\n\n    Output:\n    True\n\n    Explanation:\n    The graph has a cycle: 0 -> 1 -> 2 -> 3 -> 0.\n    \"\"\"\n\n    n = len(graph)\n    visited = [False] * n\n\n    def dfs(node: int, stack: List[int]) -> bool:\n        visited[node] = True\n        stack.append(node)\n\n        for neighbor in range(n):\n            if graph[node][neighbor] == 1:\n                if neighbor in stack:\n                    return True\n                elif not visited[neighbor]:\n                    if dfs(neighbor, stack):\n                        return True\n\n        stack.pop()\n        return False\n\n    for node in range(n):\n        if not visited[node]:\n            if dfs(node, []):\n                return True\n\n    return False\n\ndef g() -> List[List[int]]:\n    return [[0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1],\n            [1, 0, 0, 0]]\n\nassert f(g()) == True\n\n",
        "idx_generation": 396,
        "target_skills": [
            1,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target element using binary search.\n    Return -1 if the target element is not found.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    return ([1, 3, 6, 8, 9, 12, 15], 8)\n\nassert f(*g()) == 3\n\n",
        "idx_generation": 126,
        "target_skills": [
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there exists a pair of numbers in the list whose sum is equal to the target.\n    \n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    \n    Output:\n    True (as there exists a pair [2, 5] whose sum is equal to the target 7)\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    return (arr, target)\n\nassert f(*g()) == True\n",
        "idx_generation": 465,
        "target_skills": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix (2D list), rotate it clockwise by 90 degrees.\n    \"\"\"\n    n = len(matrix)\n    rotated_matrix = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        for j in range(n):\n            rotated_matrix[j][n-i-1] = matrix[i][j]\n\n    return rotated_matrix\n\ndef g(matrix: List[List[int]] = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    \"\"\"\n    Generate a matrix (2D list).\n    \"\"\"\n    return matrix\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 116,
        "target_skills": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Minimum Path Sum\n\n    Given a grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.\n\n    Note: You can only move either down or right at any point in time.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum path sum from top left to bottom right is 1 + 3 + 1 + 1 + 1 = 7.\n    \"\"\"\n\n    if not grid:\n        return 0\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 240,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"Count the number of unique substrings in a given string.\"\"\"\n    substrings = set()\n    n = len(s)\n    for i in range(n):\n        for j in range(i+1, n+1):\n            substrings.add(s[i:j])\n    return len(substrings)\n\ndef g():\n    return \"abcd\"\n\nassert f(g()) == 10\n",
        "idx_generation": 165,
        "target_skills": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of bits required to represent n in binary form.\n    \"\"\"\n    if n == 0:\n        return 1\n    count = 0\n    while n > 0:\n        count += 1\n        n >>= 1\n    return count\n\ndef g() -> int:\n    \"\"\"\n    Generate the input for the function f.\n    \"\"\"\n    n = 25\n    return n\n\nassert f(g()) == 5\n",
        "idx_generation": 469,
        "target_skills": [
            1,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of the first n natural numbers.\n\n    Example:\n    n = 5\n\n    Output:\n    15\n\n    Explanation:\n    The sum of the first 5 natural numbers is 1 + 2 + 3 + 4 + 5 = 15.\n    \"\"\"\n\n    return (n * (n + 1)) // 2\n\ndef g() -> int:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    return 5\n\nassert f(g()) == 15\n",
        "idx_generation": 272,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, check if the graph contains a cycle.\n\n    Example:\n    graph = [[1, 2], [0, 2], [0, 1]]\n\n    Output:\n    True\n\n    Explanation:\n    The graph contains a cycle: 0 -> 1 -> 2 -> 0.\n\n    Hint: Use depth-first search (DFS) to detect cycles in the graph.\n    \"\"\"\n\n    def dfs(node: int, parent: int) -> bool:\n        visited[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node):\n                    return True\n            elif neighbor != parent:\n                return True\n        \n        return False\n\n    n = len(graph)\n    visited = [False] * n\n\n    for i in range(n):\n        if not visited[i]:\n            if dfs(i, -1):\n                return True\n    \n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate an adjacency list representing an undirected graph without a cycle.\n    \"\"\"\n    graph = [[1, 2], [0], [0]]\n    return graph\n\nassert f(g()) == False\n",
        "idx_generation": 402,
        "target_skills": [
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of distinct integers and a target value, return the two numbers\n    that add up to the target. You may assume that each input would have exactly one solution\n    and you may not use the same element twice.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return [nums[left], nums[right]]\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g():\n    \"\"\"\n    Generate a sorted array of distinct integers and a target value.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 10\n\n    return nums, target\n\nassert f(*g()) == [1, 9]\n",
        "idx_generation": 127,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers, find the target index in the array using binary search.\n\n    Example:\n    nums = [2, 5, 7, 9, 12], target = 7\n\n    Output:\n    2\n\n    Explanation:\n    The target number 7 is found at index 2 in the array.\n\n    Constraints:\n    - The input list will always be sorted in ascending order.\n    - The input list will not contain any duplicate elements.\n    - The target number will always be present in the input list.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    nums = [2, 5, 7, 9, 12]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 466,
        "target_skills": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum sum of a subarray within the given list.\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return (nums,)\n\nassert f(*g()) == 6\n",
        "idx_generation": 121,
        "target_skills": [
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(prices: List[int], fee: int) -> int:\n    \"\"\"\n    You are given an array prices where prices[i] is the price of a given stock on the ith day,\n    and an integer fee representing a transaction fee.\n    Find the maximum profit you can achieve, where you can complete as many transactions as you like\n    (buy one and sell one share of the stock multiple times) with the following restrictions:\n    - After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).\n    - You must sell the stock before you buy again.\n\n    Args:\n    - prices: A list of integers representing the prices of the stock on each day.\n    - fee: An integer representing a transaction fee.\n\n    Returns:\n    - The maximum profit you can achieve.\n\n    \"\"\"\n\n    n = len(prices)\n    if n < 2:\n        return 0\n\n    dp = [[0] * 2 for _ in range(n)]\n    dp[0][0] = 0\n    dp[0][1] = -prices[0]\n\n    for i in range(1, n):\n        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee)\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])\n\n    return dp[n - 1][0]\n\ndef g(prices = [1, 3, 2, 8, 4, 9], fee = 2):\n    return [1, 3, 2, 8, 4, 9], 2\n\nassert f(*g()) == 8\n",
        "idx_generation": 242,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a 2D grid of characters, count the number of occurrences of a given character 'target' in the grid.\n\n    Example:\n    grid = [\n        ['A', 'B', 'C'],\n        ['D', 'E', 'F'],\n        ['G', 'H', 'I']\n    ]\n    target = 'E'\n\n    Output:\n    1\n\n    Explanation:\n    The character 'E' occurs once in the grid.\n\n    Hint: Use nested loops to iterate through the grid and count the occurrences of the target character.\n    \"\"\"\n\n    count = 0\n    target = 'E'\n\n    for row in grid:\n        for char in row:\n            if char == target:\n                count += 1\n\n    return count\n\ndef g():\n    return [\n        ['A', 'B', 'C'],\n        ['D', 'E', 'F'],\n        ['G', 'H', 'I']\n    ]\n\nassert f(g()) == True\n",
        "idx_generation": 171,
        "target_skills": [
            0,
            1,
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n\n    Return the maximum XOR value.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value is obtained by XORing 5 and 25, which gives 28.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            max_xor = max(max_xor, nums[i] ^ nums[j])\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n\n",
        "idx_generation": 469,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Given two integers n and k, determine if there exists a combination of n items taken k at a time.\n\n    Example:\n    n = 5\n    k = 3\n\n    Output:\n    True (because there exists a combination of 5 items taken 3 at a time)\n\n    \"\"\"\n    def factorial(num):\n        if num == 0 or num == 1:\n            return 1\n        else:\n            return num * factorial(num - 1)\n\n    if k > n:\n        return False\n\n    combinations = factorial(n) // (factorial(k) * factorial(n - k))\n\n    return combinations > 0\n\ndef g():\n    n = 5\n    k = 3\n    return n, k\n\nassert f(*g()) == True\n",
        "idx_generation": 285,
        "target_skills": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Dict\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> List[int]:\n    \"\"\"\n    Given the root of a binary tree, return the inorder traversal of its nodes' values.\n\n    Sample Input:\n    root = [1,null,2,3]\n\n    Sample Output:\n    [1,3,2]\n    \"\"\"\n    def inorder(node: TreeNode, res: List[int]) -> None:\n        if node:\n            inorder(node.left, res)\n            res.append(node.val)\n            inorder(node.right, res)\n\n    result = []\n    inorder(root, result)\n    return result\n\ndef g():\n    root = TreeNode(1)\n    root.right = TreeNode(2)\n    root.right.left = TreeNode(3)\n    return root\n\nassert f(g()) == [1, 3, 2]\n",
        "idx_generation": 402,
        "target_skills": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers and a target value, find the index of the target value in the array using binary search.\n\n    Args:\n    - arr: A sorted list of integers.\n    - target: The target value to search for in the array.\n\n    Returns:\n    - The index of the target value if found, or -1 if not found.\n    \"\"\"\n    def binary_search(arr, target):\n        low = 0\n        high = len(arr) - 1\n\n        while low <= high:\n            mid = (low + high) // 2\n\n            if arr[mid] == target:\n                return mid\n            elif arr[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n\n        return -1\n\n    return binary_search(arr, target)\n\ndef g():\n    arr = [1, 3, 5, 7, 9, 11]\n    target = 5\n    return arr, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 128,
        "target_skills": [
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    Output:\n    4\n\n    Explanation:\n    The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n\n    Hint: Use dynamic programming to keep track of the length of the longest increasing subsequence ending at each index.\n    \"\"\"\n    if not nums:\n        return 0\n\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g(nums: List[int] = [10, 9, 2, 5, 3, 7, 101, 18]):\n    return (nums,)\n\nassert f(*g()) == 4\n\n",
        "idx_generation": 467,
        "target_skills": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target value, find two numbers in the list that\n    add up to the target. Return the indices of the two numbers.\n    \"\"\"\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n\n    return []\n\ndef g():\n    return [2, 7, 11, 15]\n\nassert f(g(), 9) == [0, 1]\n",
        "idx_generation": 122,
        "target_skills": [
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    Output:\n    4 (since the longest increasing subsequence is [2, 3, 7, 101])\n    \"\"\"\n    if not nums:\n        return 0\n    \n    dp = [1] * len(nums)\n    \n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[j] < nums[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 244,
        "target_skills": [
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"Check if the given string is a palindrome\"\"\"\n    reversed_string = string[::-1]\n    return string == reversed_string\n\ndef g(string='racecar'):\n    return string\n\nassert f(g()) == True\n",
        "idx_generation": 172,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum XOR value that can be obtained by selecting one element from each row.\n    The XOR value is obtained by performing a bitwise XOR operation on the selected elements.\n\n    Example:\n    grid = [\n        [2, 5, 9],\n        [3, 8, 12],\n        [7, 10, 15]\n    ]\n\n    Output:\n    14\n\n    Explanation:\n    Selecting the elements 9, 8, and 7 results in the maximum XOR value of 14: (9 ^ 8 ^ 7 = 14).\n    \"\"\"\n\n    max_xor = 0\n    for row in grid:\n        xor_value = 0\n        for num in row:\n            xor_value = xor_value ^ num\n        max_xor = max(max_xor, xor_value)\n\n    return max_xor\n\ndef g(grid: List[List[int]] = [[2, 5, 9], [3, 8, 12], [7, 10, 15]]):\n    return (grid,)\n\nassert f(*g()) == 14\n\n",
        "idx_generation": 471,
        "target_skills": [
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            1,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, compute the sum of all prime numbers in the list.\n    \"\"\"\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    prime_sum = 0\n    for num in nums:\n        if is_prime(num):\n            prime_sum += num\n\n    return prime_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    nums = [2, 3, 5, 7, 10, 12, 15]\n    return nums\n\nassert f(g()) == 17\n\n",
        "idx_generation": 288,
        "target_skills": [
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Check if a directed graph contains a cycle.\n    \"\"\"\n    def dfs(node, visited, stack):\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, stack):\n                    return True\n            elif stack[neighbor]:\n                return True\n\n        stack[node] = False\n        return False\n\n    n = len(graph)\n    visited = [False] * n\n    stack = [False] * n\n\n    for node in range(n):\n        if not visited[node]:\n            if dfs(node, visited, stack):\n                return True\n\n    return False\n\ndef g(graph: List[List[int]] = [[1, 2], [2], []]) -> List[List[int]]:\n    return graph\n\nassert f(g()) == False\n",
        "idx_generation": 407,
        "target_skills": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers 'nums' and a target value 'target',\n    determine if there are two numbers in the list that add up to the target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n\n    Output:\n    True\n\n    Explanation:\n    The numbers 1 and 5 add up to the target value 6.\n    \"\"\"\n\n    def binary_search(nums: List[int], target: int) -> bool:\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False\n\n    nums.sort()\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if binary_search(nums[i+1:], complement):\n            return True\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    return [1, 7, 2, 5, 3, 4], 9\n\nassert f(*g())\n",
        "idx_generation": 128,
        "target_skills": [
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            1
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value using binary search.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 4\n\n    Output:\n    3\n\n    Explanation:\n    The target value 4 is found at index 3 in the list.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(arr=[1, 2, 3, 4, 5], target=4):\n    return arr, target\n\nassert f(*g()) == 3\n\n",
        "idx_generation": 467,
        "target_skills": [
            0,
            0,
            1,
            0,
            1,
            0,
            1,
            1,
            1,
            1
        ]
    }
]
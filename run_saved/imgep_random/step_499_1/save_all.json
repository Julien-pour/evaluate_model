[{"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list.\n    If the target value is not present in the list, return -1.\n\n    Example:\n    Input:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output: 2\n\n    Explanation: The target value 5 is present at index 2 in the list.\n    \"\"\"\n\n    def binary_search(nums: List[int], target: int, low: int, high: int) -> int:\n        if low > high:\n            return -1\n\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            return binary_search(nums, target, mid + 1, high)\n        else:\n            return binary_search(nums, target, low, mid - 1)\n\n    return binary_search(nums, target, 0, len(nums) - 1)\n\ndef g(nums: List[int], target: int):\n    nums.sort()\n    return nums, target\n\nassert f(*g()) == 2\n", "emb": null, "idx_generation": 451, "target_skills": [1, 1, 0, 0, 0, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list.\n    If the target value is not present in the list, return -1.\n\n    Example:\n    Input:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output: 2\n\n    Explanation: The target value 5 is present at index 2 in the list.\n    \"\"\"\n\n    def binary_search(nums: List[int], target: int, low: int, high: int) -> int:\n        if low > high:\n            return -1\n\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            return binary_search(nums, target, mid + 1, high)\n        else:\n            return binary_search(nums, target, low, mid - 1)\n\n    return binary_search(nums, target, 0, len(nums) - 1)", "solution_func": "def g(nums: List[int], target: int):\n    nums.sort()\n    return nums, target", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, determine the number of ways to climb to the top of a staircase by taking either\n    1 or 2 steps at a time.\n\n    Example:\n    Input:\n    n = 3\n\n    Output: 3\n\n    Explanation: There are 3 ways to climb to the top: 1 step + 1 step + 1 step, 1 step + 2 steps, 2 steps + 1 step.\n    \"\"\"\n\n    def climb_stairs(n: int) -> int:\n        if n == 0 or n == 1:\n            return 1\n\n        dp = [0] * (n + 1)\n        dp[0] = dp[1] = 1\n\n        for i in range(2, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n\n        return dp[n]\n\n    return climb_stairs(n)\n\ndef g(n: int):\n    return n,\n\nassert f(*g()) == 3\n", "emb": null, "idx_generation": 451, "target_skills": [1, 1, 1, 1, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, determine the number of ways to climb to the top of a staircase by taking either\n    1 or 2 steps at a time.\n\n    Example:\n    Input:\n    n = 3\n\n    Output: 3\n\n    Explanation: There are 3 ways to climb to the top: 1 step + 1 step + 1 step, 1 step + 2 steps, 2 steps + 1 step.\n    \"\"\"\n\n    def climb_stairs(n: int) -> int:\n        if n == 0 or n == 1:\n            return 1\n\n        dp = [0] * (n + 1)\n        dp[0] = dp[1] = 1\n\n        for i in range(2, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n\n        return dp[n]\n\n    return climb_stairs(n)", "solution_func": "def g(n: int):\n    return n,", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome when all non-alphanumeric characters are removed.\n\n    Example:\n    Input:\n    string = \"A man, a plan, a canal: Panama\"\n\n    Output: True\n\n    Explanation: The string \"A man, a plan, a canal: Panama\" is a palindrome when non-alphanumeric characters are removed.\n    \"\"\"\n\n    def is_palindrome(string: str) -> bool:\n        string = ''.join(filter(str.isalnum, string.lower()))\n        return string == string[::-1]\n\n    return is_palindrome(string)\n\ndef g():\n    string = \"A man, a plan, a canal: Panama\"\n    return string,\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 451, "target_skills": [0, 0, 0, 1, 0, 0, 1, 1, 0, 0], "problem_func": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome when all non-alphanumeric characters are removed.\n\n    Example:\n    Input:\n    string = \"A man, a plan, a canal: Panama\"\n\n    Output: True\n\n    Explanation: The string \"A man, a plan, a canal: Panama\" is a palindrome when non-alphanumeric characters are removed.\n    \"\"\"\n\n    def is_palindrome(string: str) -> bool:\n        string = ''.join(filter(str.isalnum, string.lower()))\n        return string == string[::-1]\n\n    return is_palindrome(string)", "solution_func": "def g():\n    string = \"A man, a plan, a canal: Panama\"\n    return string,", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the sum of all the even numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n\n    Output:\n    12\n\n    Explanation:\n    The even numbers in the list are 2, 4, and 6. Their sum is 12.\n    \"\"\"\n    even_sum = 0\n\n    for num in nums:\n        if num % 2 == 0:\n            even_sum += num\n\n    return even_sum\n\ndef g(nums=[1, 2, 3, 4, 5, 6]):\n    return [nums]\n\nassert f(*g()) == 12\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 451, "target_skills": [0, 0, 1, 0, 0, 0, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the sum of all the even numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n\n    Output:\n    12\n\n    Explanation:\n    The even numbers in the list are 2, 4, and 6. Their sum is 12.\n    \"\"\"\n    even_sum = 0\n\n    for num in nums:\n        if num % 2 == 0:\n            even_sum += num\n\n    return even_sum", "solution_func": "def g(nums=[1, 2, 3, 4, 5, 6]):\n    return [nums]", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where all the even numbers are squared.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n\n    Output:\n    [1, 4, 3, 16, 5, 36]\n\n    Explanation:\n    The even numbers in the list are 2, 4, and 6. Squaring these numbers gives [1, 4, 16, 36].\n    \"\"\"\n    squared_nums = []\n\n    for num in nums:\n        if num % 2 == 0:\n            squared_nums.append(num ** 2)\n        else:\n            squared_nums.append(num)\n\n    return squared_nums\n\ndef g(nums=[1, 2, 3, 4, 5, 6]):\n    return [nums]\n\nassert f(*g()) == [1, 4, 3, 16, 5, 36]\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 451, "target_skills": [0, 0, 0, 0, 1, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where all the even numbers are squared.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n\n    Output:\n    [1, 4, 3, 16, 5, 36]\n\n    Explanation:\n    The even numbers in the list are 2, 4, and 6. Squaring these numbers gives [1, 4, 16, 36].\n    \"\"\"\n    squared_nums = []\n\n    for num in nums:\n        if num % 2 == 0:\n            squared_nums.append(num ** 2)\n        else:\n            squared_nums.append(num)\n\n    return squared_nums", "solution_func": "def g(nums=[1, 2, 3, 4, 5, 6]):\n    return [nums]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a grid of integers, return a new grid where each element is the sum of its adjacent elements (up, down, left, right).\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    [\n        [12, 16, 12],\n        [16, 20, 16],\n        [12, 16, 12]\n    ]\n\n    Explanation:\n    The new grid is obtained by summing the adjacent elements of each element in the original grid.\n    For example, the element at position (1, 1) in the original grid is 5. Its adjacent elements are 2, 4, 6, and 8.\n    The sum of these elements is 20, which is placed at position (1, 1) in the new grid.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    new_grid = [[0 for _ in range(cols)] for _ in range(rows)]\n\n    for i in range(rows):\n        for j in range(cols):\n            adjacent_sum = 0\n\n            if i > 0:\n                adjacent_sum += grid[i-1][j]\n            if i < rows - 1:\n                adjacent_sum += grid[i+1][j]\n            if j > 0:\n                adjacent_sum += grid[i][j-1]\n            if j < cols - 1:\n                adjacent_sum += grid[i][j+1]\n\n            new_grid[i][j] = adjacent_sum\n\n    return new_grid\n\ndef g(grid=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return [grid]\n\nassert f(*g()) == [[12, 16, 12], [16, 20, 16], [12, 16, 12]]\n\n", "emb": null, "idx_generation": 451, "target_skills": [0, 0, 0, 0, 1, 1, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a grid of integers, return a new grid where each element is the sum of its adjacent elements (up, down, left, right).\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    [\n        [12, 16, 12],\n        [16, 20, 16],\n        [12, 16, 12]\n    ]\n\n    Explanation:\n    The new grid is obtained by summing the adjacent elements of each element in the original grid.\n    For example, the element at position (1, 1) in the original grid is 5. Its adjacent elements are 2, 4, 6, and 8.\n    The sum of these elements is 20, which is placed at position (1, 1) in the new grid.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    new_grid = [[0 for _ in range(cols)] for _ in range(rows)]\n\n    for i in range(rows):\n        for j in range(cols):\n            adjacent_sum = 0\n\n            if i > 0:\n                adjacent_sum += grid[i-1][j]\n            if i < rows - 1:\n                adjacent_sum += grid[i+1][j]\n            if j > 0:\n                adjacent_sum += grid[i][j-1]\n            if j < cols - 1:\n                adjacent_sum += grid[i][j+1]\n\n            new_grid[i][j] = adjacent_sum\n\n    return new_grid", "solution_func": "def g(grid=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return [grid]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, obstacles: List[List[int]]) -> int:\n    \"\"\"\n    Robot in a Grid\n\n    Given a grid of size m x n, where some cells are blocked and cannot be visited, find the number of unique paths\n    from the top-left corner to the bottom-right corner, moving only right or down.\n\n    The robot can only move to the right or down, and cannot move through blocked cells.\n\n    Example:\n    n = 3\n    obstacles = [[0, 0, 0],\n                 [0, 1, 0],\n                 [0, 0, 0]]\n    output: 2\n\n    Explanation: There are two possible paths from the top-left corner to the bottom-right corner:\n    1. Right -> Right -> Down -> Down\n    2. Down -> Down -> Right -> Right\n    \"\"\"\n    m = len(obstacles)\n    if m == 0:\n        return 0\n    n = len(obstacles[0])\n    if n == 0:\n        return 0\n    if obstacles[0][0] == 1 or obstacles[m-1][n-1] == 1:\n        return 0\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1\n\n    for i in range(m):\n        for j in range(n):\n            if obstacles[i][j] == 0:\n                if i > 0 and obstacles[i-1][j] == 0:\n                    dp[i][j] += dp[i-1][j]\n                if j > 0 and obstacles[i][j-1] == 0:\n                    dp[i][j] += dp[i][j-1]\n\n    return dp[m-1][n-1]\n\n\ndef g(n = 3, obstacles = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]):\n    return n, obstacles\n\n\nassert f(*g()) == 2\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 451, "target_skills": [0, 1, 1, 1, 0, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, obstacles: List[List[int]]) -> int:\n    \"\"\"\n    Robot in a Grid\n\n    Given a grid of size m x n, where some cells are blocked and cannot be visited, find the number of unique paths\n    from the top-left corner to the bottom-right corner, moving only right or down.\n\n    The robot can only move to the right or down, and cannot move through blocked cells.\n\n    Example:\n    n = 3\n    obstacles = [[0, 0, 0],\n                 [0, 1, 0],\n                 [0, 0, 0]]\n    output: 2\n\n    Explanation: There are two possible paths from the top-left corner to the bottom-right corner:\n    1. Right -> Right -> Down -> Down\n    2. Down -> Down -> Right -> Right\n    \"\"\"\n    m = len(obstacles)\n    if m == 0:\n        return 0\n    n = len(obstacles[0])\n    if n == 0:\n        return 0\n    if obstacles[0][0] == 1 or obstacles[m-1][n-1] == 1:\n        return 0\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1\n\n    for i in range(m):\n        for j in range(n):\n            if obstacles[i][j] == 0:\n                if i > 0 and obstacles[i-1][j] == 0:\n                    dp[i][j] += dp[i-1][j]\n                if j > 0 and obstacles[i][j-1] == 0:\n                    dp[i][j] += dp[i][j-1]\n\n    return dp[m-1][n-1]", "solution_func": "def g(n = 3, obstacles = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]):\n    return n, obstacles", "map_ix": [0, 0, 1, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Count Valid Parenthesis Sequences\n\n    Given a positive integer n, return the number of valid parenthesis sequences of length 2n.\n\n    A valid parenthesis sequence is defined as:\n    - An empty string is a valid parenthesis sequence.\n    - If s is a valid parenthesis sequence, then (s) is also a valid parenthesis sequence.\n    - If s and t are valid parenthesis sequences, then st is also a valid parenthesis sequence.\n\n    Example:\n    n = 3\n    output: 5\n\n    Explanation: The valid parenthesis sequences of length 6 are:\n    ((())), (()()), (())(), ()(()), ()()()\n    \"\"\"\n    dp = [0] * (n+1)\n    dp[0] = 1\n\n    for i in range(1, n+1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i-j-1]\n\n    return dp[n]\n\n\ndef g(n = 3):\n    return n\n\n\nassert f(g()) == 5\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 451, "target_skills": [1, 0, 0, 1, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Count Valid Parenthesis Sequences\n\n    Given a positive integer n, return the number of valid parenthesis sequences of length 2n.\n\n    A valid parenthesis sequence is defined as:\n    - An empty string is a valid parenthesis sequence.\n    - If s is a valid parenthesis sequence, then (s) is also a valid parenthesis sequence.\n    - If s and t are valid parenthesis sequences, then st is also a valid parenthesis sequence.\n\n    Example:\n    n = 3\n    output: 5\n\n    Explanation: The valid parenthesis sequences of length 6 are:\n    ((())), (()()), (())(), ()(()), ()()()\n    \"\"\"\n    dp = [0] * (n+1)\n    dp[0] = 1\n\n    for i in range(1, n+1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i-j-1]\n\n    return dp[n]", "solution_func": "def g(n = 3):\n    return n", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(m: int, n: int) -> int:\n    \"\"\"\n    Unique Paths in a Grid\n\n    Given a grid of size m x n, find the number of unique paths from the top-left corner to the bottom-right corner,\n    moving only right or down.\n\n    Example:\n    m = 3\n    n = 7\n    output: 28\n\n    Explanation: There are 28 unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1\n\n    for i in range(m):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n\n    return dp[m-1][n-1]\n\n\ndef g(m = 3, n = 7):\n    return m, n\n\n\nassert f(*g()) == 28\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 451, "target_skills": [0, 0, 0, 1, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\ndef f(m: int, n: int) -> int:\n    \"\"\"\n    Unique Paths in a Grid\n\n    Given a grid of size m x n, find the number of unique paths from the top-left corner to the bottom-right corner,\n    moving only right or down.\n\n    Example:\n    m = 3\n    n = 7\n    output: 28\n\n    Explanation: There are 28 unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1\n\n    for i in range(m):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n\n    return dp[m-1][n-1]", "solution_func": "def g(m = 3, n = 7):\n    return m, n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\n\ndef f(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a grid of integers, rotate the grid 90 degrees clockwise.\n\n    Return the rotated grid.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    [\n        [7, 4, 1],\n        [8, 5, 2],\n        [9, 6, 3]\n    ]\n    \"\"\"\n\n    def rotate_grid(grid):\n        m, n = len(grid), len(grid[0])\n        rotated_grid = [[0] * m for _ in range(n)]\n\n        for i in range(m):\n            for j in range(n):\n                rotated_grid[j][m - 1 - i] = grid[i][j]\n\n        return rotated_grid\n\n    return rotate_grid(grid)\n\ndef g():\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g()) == [\n    [7, 4, 1],\n    [8, 5, 2],\n    [9, 6, 3]\n]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], "idx_generation": 451, "target_skills": [1, 1, 0, 1, 1, 1, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a grid of integers, rotate the grid 90 degrees clockwise.\n\n    Return the rotated grid.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    [\n        [7, 4, 1],\n        [8, 5, 2],\n        [9, 6, 3]\n    ]\n    \"\"\"\n\n    def rotate_grid(grid):\n        m, n = len(grid), len(grid[0])\n        rotated_grid = [[0] * m for _ in range(n)]\n\n        for i in range(m):\n            for j in range(n):\n                rotated_grid[j][m - 1 - i] = grid[i][j]\n\n        return rotated_grid\n\n    return rotate_grid(grid)", "solution_func": "def g():\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]", "map_ix": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n    \"\"\"\n    max_sum = current_sum = nums[0]\n    \n    for i in range(1, len(nums)):\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 452, "target_skills": [1, 0, 1, 0, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n    \"\"\"\n    max_sum = current_sum = nums[0]\n    \n    for i in range(1, len(nums)):\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum", "solution_func": "def g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of words in the string while preserving the order of characters within each word.\n    \"\"\"\n    words = s.split()\n    reversed_words = [word[::-1] for word in words]\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string\n\ndef g():\n    s = \"Hello World\"\n    return s\n\nassert f(g()) == \"olleH dlroW\"\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 452, "target_skills": [0, 1, 1, 0, 0, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of words in the string while preserving the order of characters within each word.\n    \"\"\"\n    words = s.split()\n    reversed_words = [word[::-1] for word in words]\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "solution_func": "def g():\n    s = \"Hello World\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of numbers, find the minimum path sum from the top-left to the bottom-right cell.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g():\n    grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    return grid\n\nassert f(g()) == 7\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 452, "target_skills": [0, 0, 0, 0, 1, 1, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of numbers, find the minimum path sum from the top-left to the bottom-right cell.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]", "solution_func": "def g():\n    grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    return grid", "map_ix": [0, 0, 0, 1, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique paths from the top-left cell to the bottom-right cell of an n x n grid.\n    You can only move down or right at any point in time.\n\n    Example:\n    Input: n = 3\n    Output: 6\n    Explanation: There are 6 unique paths from the top-left cell to the bottom-right cell of a 3 x 3 grid.\n\n    \"\"\"\n    def uniquePathsHelper(i: int, j: int, memo: List[List[int]]) -> int:\n        # Check if already computed\n        if memo[i][j] != -1:\n            return memo[i][j]\n        \n        # Base case: reached bottom-right cell\n        if i == n-1 and j == n-1:\n            return 1\n        \n        # Recursive cases: move down or right\n        downPaths = 0\n        rightPaths = 0\n        if i < n-1:\n            downPaths = uniquePathsHelper(i+1, j, memo)\n        if j < n-1:\n            rightPaths = uniquePathsHelper(i, j+1, memo)\n        \n        # Memoize the result\n        memo[i][j] = downPaths + rightPaths\n        \n        return memo[i][j]\n    \n    # Initialize memoization table\n    memo = [[-1] * n for _ in range(n)]\n    \n    return uniquePathsHelper(0, 0, memo)\n\ndef g() -> int:\n    n = 3\n    return n\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 452, "target_skills": [1, 1, 0, 0, 1, 1, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique paths from the top-left cell to the bottom-right cell of an n x n grid.\n    You can only move down or right at any point in time.\n\n    Example:\n    Input: n = 3\n    Output: 6\n    Explanation: There are 6 unique paths from the top-left cell to the bottom-right cell of a 3 x 3 grid.\n\n    \"\"\"\n    def uniquePathsHelper(i: int, j: int, memo: List[List[int]]) -> int:\n        # Check if already computed\n        if memo[i][j] != -1:\n            return memo[i][j]\n        \n        # Base case: reached bottom-right cell\n        if i == n-1 and j == n-1:\n            return 1\n        \n        # Recursive cases: move down or right\n        downPaths = 0\n        rightPaths = 0\n        if i < n-1:\n            downPaths = uniquePathsHelper(i+1, j, memo)\n        if j < n-1:\n            rightPaths = uniquePathsHelper(i, j+1, memo)\n        \n        # Memoize the result\n        memo[i][j] = downPaths + rightPaths\n        \n        return memo[i][j]\n    \n    # Initialize memoization table\n    memo = [[-1] * n for _ in range(n)]\n    \n    return uniquePathsHelper(0, 0, memo)", "solution_func": "def g() -> int:\n    n = 3\n    return n", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a set of distinct integers, return all possible subsets.\n\n    Example:\n    Input: nums = [1, 2, 3]\n    Output: [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n    Explanation: The output contains all possible subsets of the input array [1, 2, 3].\n\n    \"\"\"\n    subsets = []\n    \n    def backtrack(start: int, currSubset: List[int]):\n        subsets.append(currSubset[:])\n        \n        # Generate all possible subsets\n        for i in range(start, len(nums)):\n            currSubset.append(nums[i])\n            backtrack(i+1, currSubset)\n            currSubset.pop()\n    \n    backtrack(0, [])\n    return subsets\n\ndef g() -> List[int]:\n    nums = [1, 2, 3]\n    return nums\n\nassert f(g()) == [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n", "emb": null, "idx_generation": 452, "target_skills": [0, 1, 1, 1, 0, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a set of distinct integers, return all possible subsets.\n\n    Example:\n    Input: nums = [1, 2, 3]\n    Output: [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n    Explanation: The output contains all possible subsets of the input array [1, 2, 3].\n\n    \"\"\"\n    subsets = []\n    \n    def backtrack(start: int, currSubset: List[int]):\n        subsets.append(currSubset[:])\n        \n        # Generate all possible subsets\n        for i in range(start, len(nums)):\n            currSubset.append(nums[i])\n            backtrack(i+1, currSubset)\n            currSubset.pop()\n    \n    backtrack(0, [])\n    return subsets", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n\n    Example:\n    Input: n = 5\n    Output: 5\n    Explanation: The 5th Fibonacci number is 5.\n\n    \"\"\"\n    # Base cases: 0th and 1st Fibonacci numbers are 0 and 1, respectively\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    \n    # Initialize the first two Fibonacci numbers\n    fib1 = 0\n    fib2 = 1\n    \n    # Find the nth Fibonacci number\n    for _ in range(2, n+1):\n        fib = fib1 + fib2\n        fib1 = fib2\n        fib2 = fib\n    \n    return fib\n\ndef g() -> int:\n    n = 5\n    return n\n\nassert f(g()) == 5\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 452, "target_skills": [1, 1, 1, 0, 0, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n\n    Example:\n    Input: n = 5\n    Output: 5\n    Explanation: The 5th Fibonacci number is 5.\n\n    \"\"\"\n    # Base cases: 0th and 1st Fibonacci numbers are 0 and 1, respectively\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    \n    # Initialize the first two Fibonacci numbers\n    fib1 = 0\n    fib2 = 1\n    \n    # Find the nth Fibonacci number\n    for _ in range(2, n+1):\n        fib = fib1 + fib2\n        fib1 = fib2\n        fib2 = fib\n    \n    return fib", "solution_func": "def g() -> int:\n    n = 5\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum XOR value of any two numbers in the list.\n\n    Example:\n    Input:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output: 28\n\n    Explanation: The maximum XOR value can be obtained by taking the XOR of 5 and 25, which results in 28.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            max_xor = max(max_xor, nums[i]^nums[j])\n\n    return max_xor\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 452, "target_skills": [1, 1, 0, 0, 1, 1, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum XOR value of any two numbers in the list.\n\n    Example:\n    Input:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output: 28\n\n    Explanation: The maximum XOR value can be obtained by taking the XOR of 5 and 25, which results in 28.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            max_xor = max(max_xor, nums[i]^nums[j])\n\n    return max_xor", "solution_func": "def g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    Input:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output: 9\n\n    Explanation: The maximum sum path is 1 -> 3 -> 1 -> 1 -> 1, which gives a total sum of 9.\n    \"\"\"\n\n    m, n = len(grid), len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 9\n\n", "emb": null, "idx_generation": 452, "target_skills": [0, 0, 0, 0, 0, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    Input:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output: 9\n\n    Explanation: The maximum sum path is 1 -> 3 -> 1 -> 1 -> 1, which gives a total sum of 9.\n    \"\"\"\n\n    m, n = len(grid), len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two numbers in the list.\n\n    Example:\n    Input:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output: 250\n\n    Explanation: The maximum product can be obtained by multiplying 10 and 25, which results in 250.\n    \"\"\"\n\n    max_product = float('-inf')\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            max_product = max(max_product, nums[i]*nums[j])\n\n    return max_product\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 250\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 452, "target_skills": [0, 0, 1, 1, 1, 0, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two numbers in the list.\n\n    Example:\n    Input:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output: 250\n\n    Explanation: The maximum product can be obtained by multiplying 10 and 25, which results in 250.\n    \"\"\"\n\n    max_product = float('-inf')\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            max_product = max(max_product, nums[i]*nums[j])\n\n    return max_product", "solution_func": "def g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, return the index of the target value if it is found in the list. \n    If the target value is not found, return -1.\n\n    Args:\n    - nums: A sorted list of integers.\n    - target: The target value to search for.\n\n    Returns:\n    - The index of the target value in the list, or -1 if it is not found.\n    \"\"\"\n    low = 0\n    high = len(nums) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1\n\ndef g():\n    nums = [1, 3, 5, 7, 9, 11, 13, 15]\n    target = 7\n    return (nums, target)\n\nassert f(*g()) == 3\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 452, "target_skills": [0, 1, 0, 0, 0, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, return the index of the target value if it is found in the list. \n    If the target value is not found, return -1.\n\n    Args:\n    - nums: A sorted list of integers.\n    - target: The target value to search for.\n\n    Returns:\n    - The index of the target value in the list, or -1 if it is not found.\n    \"\"\"\n    low = 0\n    high = len(nums) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1", "solution_func": "def g():\n    nums = [1, 3, 5, 7, 9, 11, 13, 15]\n    target = 7\n    return (nums, target)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a prime number.\n\n    Example:\n    n = 7\n\n    Output:\n    True\n\n    Explanation:\n    7 is a prime number because it is only divisible by 1 and itself.\n\n    Hint: A prime number is a number greater than 1 that has no positive divisors other than 1 and itself.\n    \"\"\"\n\n    if n <= 1:\n        return False\n\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n\n    return True\n\ndef g() -> int:\n    return 7\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 453, "target_skills": [0, 0, 0, 1, 0, 1, 0, 1, 1, 0], "problem_func": "from typing import*\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a prime number.\n\n    Example:\n    n = 7\n\n    Output:\n    True\n\n    Explanation:\n    7 is a prime number because it is only divisible by 1 and itself.\n\n    Hint: A prime number is a number greater than 1 that has no positive divisors other than 1 and itself.\n    \"\"\"\n\n    if n <= 1:\n        return False\n\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n\n    return True", "solution_func": "def g() -> int:\n    return 7", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target integer, determine if it is possible to reach the target\n    by performing addition or subtraction operations on the numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    target = 5\n\n    Output:\n    True\n\n    Explanation:\n    We can reach the target 5 by subtracting 1 and 4 from 2 and 3, respectively.\n\n    Hint: Use recursion to explore all possible combinations of addition and subtraction.\n    \"\"\"\n\n    def helper(i: int, curr_sum: int) -> bool:\n        if i == len(nums):\n            return curr_sum == target\n\n        return helper(i + 1, curr_sum + nums[i]) or helper(i + 1, curr_sum - nums[i])\n\n    return helper(0, 0)\n\ndef g(nums=[1, 2, 3, 4], target=5):\n    return (nums, target)\n\nassert f(*g()) == True\n\n", "emb": null, "idx_generation": 453, "target_skills": [1, 1, 0, 1, 0, 0, 0, 1, 0, 1], "problem_func": "from typing import*\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target integer, determine if it is possible to reach the target\n    by performing addition or subtraction operations on the numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    target = 5\n\n    Output:\n    True\n\n    Explanation:\n    We can reach the target 5 by subtracting 1 and 4 from 2 and 3, respectively.\n\n    Hint: Use recursion to explore all possible combinations of addition and subtraction.\n    \"\"\"\n\n    def helper(i: int, curr_sum: int) -> bool:\n        if i == len(nums):\n            return curr_sum == target\n\n        return helper(i + 1, curr_sum + nums[i]) or helper(i + 1, curr_sum - nums[i])\n\n    return helper(0, 0)", "solution_func": "def g(nums=[1, 2, 3, 4], target=5):\n    return (nums, target)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\n\ndef f(s: str, k: int) -> str:\n    \"\"\"\n    Given a string s and an integer k, reverse the order of characters in every k-group of the string.\n\n    Example:\n    s = \"abcdefg\"\n    k = 3\n\n    Output:\n    \"cbadefg\"\n\n    Explanation:\n    The string is divided into groups of size 3: \"abc\", \"def\", and \"g\".\n    The characters in each group are reversed: \"cba\", \"fed\", and \"g\".\n    The reversed groups are concatenated to form the final string: \"cbadefg\".\n\n    Hint: Use string slicing to divide the string into k-groups and reverse each group individually.\n    \"\"\"\n\n    groups = [s[i:i+k] for i in range(0, len(s), k)]\n    reversed_groups = [group[::-1] for group in groups]\n    return ''.join(reversed_groups)\n\ndef g(s=\"abcdefg\", k=3):\n    return (s, k)\n\nassert f(*g()) == \"cbadefg\"\n\n", "emb": null, "idx_generation": 453, "target_skills": [0, 1, 0, 1, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\n\ndef f(s: str, k: int) -> str:\n    \"\"\"\n    Given a string s and an integer k, reverse the order of characters in every k-group of the string.\n\n    Example:\n    s = \"abcdefg\"\n    k = 3\n\n    Output:\n    \"cbadefg\"\n\n    Explanation:\n    The string is divided into groups of size 3: \"abc\", \"def\", and \"g\".\n    The characters in each group are reversed: \"cba\", \"fed\", and \"g\".\n    The reversed groups are concatenated to form the final string: \"cbadefg\".\n\n    Hint: Use string slicing to divide the string into k-groups and reverse each group individually.\n    \"\"\"\n\n    groups = [s[i:i+k] for i in range(0, len(s), k)]\n    reversed_groups = [group[::-1] for group in groups]\n    return ''.join(reversed_groups)", "solution_func": "def g(s=\"abcdefg\", k=3):\n    return (s, k)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there exists a pair of integers in the list whose sum is equal to the target value.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n\n    Output:\n    True\n\n    Explanation:\n    There exists a pair of integers [2, 5] in the list whose sum is equal to the target value 7.\n    \"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        current_sum = arr[left] + arr[right]\n        \n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    return arr, target\n\nassert f(*g()) == True\n\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 453, "target_skills": [0, 1, 1, 1, 1, 1, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there exists a pair of integers in the list whose sum is equal to the target value.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n\n    Output:\n    True\n\n    Explanation:\n    There exists a pair of integers [2, 5] in the list whose sum is equal to the target value 7.\n    \"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        current_sum = arr[left] + arr[right]\n        \n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False", "solution_func": "def g():\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of the first n terms of the arithmetic sequence.\n\n    Example:\n    n = 5\n\n    Output:\n    15\n\n    Explanation:\n    The sum of the first 5 terms of the arithmetic sequence is 1 + 2 + 3 + 4 + 5 = 15.\n    \"\"\"\n    return n * (n + 1) // 2\n\ndef g(n: int = 5) -> int:\n    return n\n\nassert f(g()) == 15\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 453, "target_skills": [0, 1, 0, 1, 1, 1, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of the first n terms of the arithmetic sequence.\n\n    Example:\n    n = 5\n\n    Output:\n    15\n\n    Explanation:\n    The sum of the first 5 terms of the arithmetic sequence is 1 + 2 + 3 + 4 + 5 = 15.\n    \"\"\"\n    return n * (n + 1) // 2", "solution_func": "def g(n: int = 5) -> int:\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [-5, -2, 0, 1, 2, 3, 4, 5]\n\n    Output:\n    60\n\n    Explanation:\n    The maximum product can be obtained by multiplying the numbers -5, -2, and 5: (-5) * (-2) * 5 = 60.\n    \"\"\"\n    nums.sort()\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\n\ndef g():\n    nums = [-5, -2, 0, 1, 2, 3, 4, 5]\n    return nums\n\nassert f(*g()) == 60\n\n", "emb": null, "idx_generation": 453, "target_skills": [1, 0, 0, 0, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [-5, -2, 0, 1, 2, 3, 4, 5]\n\n    Output:\n    60\n\n    Explanation:\n    The maximum product can be obtained by multiplying the numbers -5, -2, and 5: (-5) * (-2) * 5 = 60.\n    \"\"\"\n    nums.sort()\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])", "solution_func": "def g():\n    nums = [-5, -2, 0, 1, 2, 3, 4, 5]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of trailing zeros in n!.\n\n    Args:\n    - n: A positive integer.\n\n    Returns:\n    - The number of trailing zeros in n!.\n\n    Example:\n    f(5) => 1\n    f(10) => 2\n    f(20) => 4\n    \"\"\"\n\n    count = 0\n    i = 5\n    while n // i >= 1:\n        count += n // i\n        i *= 5\n\n    return count\n\ndef g() -> int:\n    n = 25\n    return n\n\nassert f(g()) == 6\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 453, "target_skills": [1, 1, 0, 1, 0, 1, 0, 0, 0, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of trailing zeros in n!.\n\n    Args:\n    - n: A positive integer.\n\n    Returns:\n    - The number of trailing zeros in n!.\n\n    Example:\n    f(5) => 1\n    f(10) => 2\n    f(20) => 4\n    \"\"\"\n\n    count = 0\n    i = 5\n    while n // i >= 1:\n        count += n // i\n        i *= 5\n\n    return count", "solution_func": "def g() -> int:\n    n = 25\n    return n", "map_ix": [1, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the sum of the first n Fibonacci numbers.\n\n    Args:\n    - n: A positive integer.\n\n    Returns:\n    - The sum of the first n Fibonacci numbers.\n\n    Example:\n    f(1) => 1\n    f(5) => 12\n    f(10) => 143\n    \"\"\"\n\n    if n <= 0:\n        return 0\n\n    fib = [0, 1]\n    sum = 1\n    for i in range(2, n+1):\n        fib.append(fib[i-1] + fib[i-2])\n        sum += fib[i]\n\n    return sum\n\ndef g() -> int:\n    n = 7\n    return n\n\nassert f(g()) == 33\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 453, "target_skills": [0, 1, 0, 1, 1, 0, 0, 1, 0, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the sum of the first n Fibonacci numbers.\n\n    Args:\n    - n: A positive integer.\n\n    Returns:\n    - The sum of the first n Fibonacci numbers.\n\n    Example:\n    f(1) => 1\n    f(5) => 12\n    f(10) => 143\n    \"\"\"\n\n    if n <= 0:\n        return 0\n\n    fib = [0, 1]\n    sum = 1\n    for i in range(2, n+1):\n        fib.append(fib[i-1] + fib[i-2])\n        sum += fib[i]\n\n    return sum", "solution_func": "def g() -> int:\n    n = 7\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "import math\nfrom typing import*\nfrom math import comb\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of ways to choose k items from a set of n items.\n\n    Args:\n    - n: A non-negative integer.\n\n    Returns:\n    - The number of ways to choose k items from a set of n items.\n\n    Example:\n    f(5, 2) => 10\n    f(10, 3) => 120\n    f(7, 5) => 21\n    \"\"\"\n\n    k = 2\n    return comb(n, k)\n\ndef g() -> int:\n    n = 6\n    return n\n\nassert f(g()) == 15\n\n", "emb": [0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 453, "target_skills": [0, 1, 0, 1, 1, 0, 0, 0, 1, 0], "problem_func": "import math\nfrom typing import*\nfrom math import comb\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of ways to choose k items from a set of n items.\n\n    Args:\n    - n: A non-negative integer.\n\n    Returns:\n    - The number of ways to choose k items from a set of n items.\n\n    Example:\n    f(5, 2) => 10\n    f(10, 3) => 120\n    f(7, 5) => 21\n    \"\"\"\n\n    k = 2\n    return comb(n, k)", "solution_func": "def g() -> int:\n    n = 6\n    return n", "map_ix": [0, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of perfect squares less than or equal to n.\n\n    Example:\n    n = 10\n    There are 3 perfect squares less than or equal to 10: 1, 4, and 9.\n    Return 3.\n\n    Constraints:\n    - The input integer n will always be greater than or equal to 0.\n    \"\"\"\n    count = 0\n    i = 1\n\n    while i * i <= n:\n        count += 1\n        i += 1\n\n    return count\n\ndef g() -> int:\n    return 16\n\nassert f(g()) == 4\n\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 453, "target_skills": [0, 1, 0, 0, 0, 0, 1, 1, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of perfect squares less than or equal to n.\n\n    Example:\n    n = 10\n    There are 3 perfect squares less than or equal to 10: 1, 4, and 9.\n    Return 3.\n\n    Constraints:\n    - The input integer n will always be greater than or equal to 0.\n    \"\"\"\n    count = 0\n    i = 1\n\n    while i * i <= n:\n        count += 1\n        i += 1\n\n    return count", "solution_func": "def g() -> int:\n    return 16", "map_ix": [1, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find the two numbers that have the maximum XOR value.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    [5, 25]\n\n    Explanation:\n    The maximum XOR value is 28, which is achieved by XORing 5 and 25.\n    \"\"\"\n\n    max_xor = 0\n    result = []\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor_val = nums[i] ^ nums[j]\n            if xor_val > max_xor:\n                max_xor = xor_val\n                result = [nums[i], nums[j]]\n\n    return result\n\n\ndef g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]\n\n\nassert f(g()) == [5, 25]\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 454, "target_skills": [1, 0, 0, 0, 1, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find the two numbers that have the maximum XOR value.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    [5, 25]\n\n    Explanation:\n    The maximum XOR value is 28, which is achieved by XORing 5 and 25.\n    \"\"\"\n\n    max_xor = 0\n    result = []\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor_val = nums[i] ^ nums[j]\n            if xor_val > max_xor:\n                max_xor = xor_val\n                result = [nums[i], nums[j]]\n\n    return result", "solution_func": "def g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of words in the string.\n\n    Example:\n    s = \"Hello World\"\n\n    Output:\n    \"World Hello\"\n\n    Explanation:\n    Reverse the order of words in the string, resulting in \"World Hello\".\n    \"\"\"\n\n    words = s.split()\n    return ' '.join(reversed(words))\n\n\ndef g() -> str:\n    return \"Hello World\"\n\n\nassert f(g()) == \"World Hello\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 454, "target_skills": [0, 1, 1, 1, 1, 0, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of words in the string.\n\n    Example:\n    s = \"Hello World\"\n\n    Output:\n    \"World Hello\"\n\n    Explanation:\n    Reverse the order of words in the string, resulting in \"World Hello\".\n    \"\"\"\n\n    words = s.split()\n    return ' '.join(reversed(words))", "solution_func": "def g() -> str:\n    return \"Hello World\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers, find two numbers in the array that sum up to the target value.\n    Return the indices of the two numbers.\n\n    Example:\n    f([-2, -1, 0, 3, 5, 6, 8, 9], 7) returns [1, 6], as nums[1] + nums[6] = -1 + 8 = 7.\n\n    Note:\n    - The input array is guaranteed to have exactly one solution.\n    - The same element cannot be used twice.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\n\ndef g() -> (List[int], int):\n    return ([-2, -1, 0, 3, 5, 6, 8, 9], 7)\n\n\nassert f(*g()) == [1, 6]\n", "emb": null, "idx_generation": 454, "target_skills": [0, 1, 0, 1, 1, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers, find two numbers in the array that sum up to the target value.\n    Return the indices of the two numbers.\n\n    Example:\n    f([-2, -1, 0, 3, 5, 6, 8, 9], 7) returns [1, 6], as nums[1] + nums[6] = -1 + 8 = 7.\n\n    Note:\n    - The input array is guaranteed to have exactly one solution.\n    - The same element cannot be used twice.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g() -> (List[int], int):\n    return ([-2, -1, 0, 3, 5, 6, 8, 9], 7)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the nth Fibonacci number.\n\n    Example:\n    n = 6\n    The 6th Fibonacci number is 8.\n\n    Constraints:\n    - The input integer n will always be non-negative.\n    \"\"\"\n\n    def fibonacci(n: int, memo: List[int]) -> int:\n        if n <= 1:\n            return n\n        elif memo[n] != 0:\n            return memo[n]\n        else:\n            memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)\n            return memo[n]\n\n    memo = [0] * (n+1)\n    return fibonacci(n, memo)\n\ndef g(n=6):\n    return n\n\nassert f(g()) == 8\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0], "idx_generation": 454, "target_skills": [0, 1, 0, 0, 0, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the nth Fibonacci number.\n\n    Example:\n    n = 6\n    The 6th Fibonacci number is 8.\n\n    Constraints:\n    - The input integer n will always be non-negative.\n    \"\"\"\n\n    def fibonacci(n: int, memo: List[int]) -> int:\n        if n <= 1:\n            return n\n        elif memo[n] != 0:\n            return memo[n]\n        else:\n            memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)\n            return memo[n]\n\n    memo = [0] * (n+1)\n    return fibonacci(n, memo)", "solution_func": "def g(n=6):\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 1]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray XOR value.\n\n    Example:\n    Input:\n    nums = [3, -10, 5, 25, 2, 8]\n\n    Output:\n    27\n\n    Explanation:\n    The maximum XOR value of any subarray in the list is 27, which is obtained\n    by XORing the subarray [5, 25, 2, 8].\n    \"\"\"\n\n    def max_subarray_xor(nums: List[int]) -> int:\n        max_xor = float('-inf')\n        curr_xor = 0\n\n        for num in nums:\n            curr_xor = curr_xor ^ num\n            max_xor = max(max_xor, curr_xor)\n            curr_xor = max(curr_xor, 0)\n\n        return max_xor\n\n    return max_subarray_xor(nums)\n\ndef g():\n    nums = [3, -10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 27\n\n", "emb": null, "idx_generation": 454, "target_skills": [0, 1, 0, 1, 0, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray XOR value.\n\n    Example:\n    Input:\n    nums = [3, -10, 5, 25, 2, 8]\n\n    Output:\n    27\n\n    Explanation:\n    The maximum XOR value of any subarray in the list is 27, which is obtained\n    by XORing the subarray [5, 25, 2, 8].\n    \"\"\"\n\n    def max_subarray_xor(nums: List[int]) -> int:\n        max_xor = float('-inf')\n        curr_xor = 0\n\n        for num in nums:\n            curr_xor = curr_xor ^ num\n            max_xor = max(max_xor, curr_xor)\n            curr_xor = max(curr_xor, 0)\n\n        return max_xor\n\n    return max_subarray_xor(nums)", "solution_func": "def g():\n    nums = [3, -10, 5, 25, 2, 8]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order using the bubble sort algorithm.\n\n    Example:\n    Input:\n    nums = [5, 2, 8, 10, 1]\n\n    Output:\n    [1, 2, 5, 8, 10]\n    \"\"\"\n\n    def bubble_sort(nums: List[int]) -> List[int]:\n        n = len(nums)\n\n        for i in range(n):\n            swapped = False\n\n            for j in range(0, n-i-1):\n                if nums[j] > nums[j+1]:\n                    nums[j], nums[j+1] = nums[j+1], nums[j]\n                    swapped = True\n\n            if not swapped:\n                break\n\n        return nums\n\n    return bubble_sort(nums)\n\ndef g():\n    nums = [5, 2, 8, 10, 1]\n    return nums\n\nassert f(g()) == [1, 2, 5, 8, 10]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 454, "target_skills": [0, 1, 1, 1, 0, 1, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order using the bubble sort algorithm.\n\n    Example:\n    Input:\n    nums = [5, 2, 8, 10, 1]\n\n    Output:\n    [1, 2, 5, 8, 10]\n    \"\"\"\n\n    def bubble_sort(nums: List[int]) -> List[int]:\n        n = len(nums)\n\n        for i in range(n):\n            swapped = False\n\n            for j in range(0, n-i-1):\n                if nums[j] > nums[j+1]:\n                    nums[j], nums[j+1] = nums[j+1], nums[j]\n                    swapped = True\n\n            if not swapped:\n                break\n\n        return nums\n\n    return bubble_sort(nums)", "solution_func": "def g():\n    nums = [5, 2, 8, 10, 1]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two positive integers n and k, return the number of ways to choose k objects from a set of n objects,\n    where each object can be chosen multiple times.\n\n    Example:\n    n = 4\n    k = 2\n\n    Output:\n    10\n\n    Explanation:\n    There are 10 ways to choose 2 objects from a set of 4 objects: \n    (1, 1), (1, 2), (1, 3), (1, 4), (2, 1), (2, 2), (2, 3), (2, 4), (3, 1), (4, 1).\n    \"\"\"\n\n    def helper(n: int, k: int) -> int:\n        if k == 0:\n            return 1\n        if n == 0:\n            return 0\n        if n < 0:\n            return float('inf')\n\n        res = float('inf')\n        for i in range(1, k+1):\n            res = min(res, 1 + helper(n-i, k))\n\n        return res\n\n    return helper(n, k)\n\ndef g():\n    n = 4\n    k = 2\n    return (n, k)\n\nassert f(*g()) == 10\n\n", "emb": null, "idx_generation": 454, "target_skills": [0, 1, 0, 0, 0, 0, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two positive integers n and k, return the number of ways to choose k objects from a set of n objects,\n    where each object can be chosen multiple times.\n\n    Example:\n    n = 4\n    k = 2\n\n    Output:\n    10\n\n    Explanation:\n    There are 10 ways to choose 2 objects from a set of 4 objects: \n    (1, 1), (1, 2), (1, 3), (1, 4), (2, 1), (2, 2), (2, 3), (2, 4), (3, 1), (4, 1).\n    \"\"\"\n\n    def helper(n: int, k: int) -> int:\n        if k == 0:\n            return 1\n        if n == 0:\n            return 0\n        if n < 0:\n            return float('inf')\n\n        res = float('inf')\n        for i in range(1, k+1):\n            res = min(res, 1 + helper(n-i, k))\n\n        return res\n\n    return helper(n, k)", "solution_func": "def g():\n    n = 4\n    k = 2\n    return (n, k)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of a subarray.\n\n    Example:\n    nums = [2, 3, -2, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The maximum product subarray is [2, 3], which gives a product of 6.\n\n    Hint: Use dynamic programming to keep track of both the maximum and minimum product at each index.\n\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    max_product = nums[0]\n    min_product = nums[0]\n    max_result = nums[0]\n\n    for i in range(1, len(nums)):\n        num = nums[i]\n        if num < 0:\n            max_product, min_product = min_product, max_product\n\n        max_product = max(num, max_product * num)\n        min_product = min(num, min_product * num)\n\n        max_result = max(max_result, max_product)\n\n    return max_result\n\ndef g(nums: List[int] = [2, 3, -2, 4]):\n    return nums\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 454, "target_skills": [0, 0, 0, 1, 1, 0, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of a subarray.\n\n    Example:\n    nums = [2, 3, -2, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The maximum product subarray is [2, 3], which gives a product of 6.\n\n    Hint: Use dynamic programming to keep track of both the maximum and minimum product at each index.\n\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    max_product = nums[0]\n    min_product = nums[0]\n    max_result = nums[0]\n\n    for i in range(1, len(nums)):\n        num = nums[i]\n        if num < 0:\n            max_product, min_product = min_product, max_product\n\n        max_product = max(num, max_product * num)\n        min_product = min(num, min_product * num)\n\n        max_result = max(max_result, max_product)\n\n    return max_result", "solution_func": "def g(nums: List[int] = [2, 3, -2, 4]):\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct pairs (a, b) such that a + b = target.\n    The pairs should be unique and the order of the pairs does not matter.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n\n    Output:\n    2\n\n    Explanation:\n    The distinct pairs (a, b) such that a + b = 6 are (1, 5) and (2, 4).\n\n    Hint: Use a set to store the complement of each number to the target.\n    \"\"\"\n\n    target = 6\n    num_set = set()\n    count = 0\n\n    for num in nums:\n        complement = target - num\n        if complement in num_set:\n            count += 1\n        num_set.add(num)\n\n    return count\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g()) == 2\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 454, "target_skills": [1, 0, 0, 1, 1, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct pairs (a, b) such that a + b = target.\n    The pairs should be unique and the order of the pairs does not matter.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n\n    Output:\n    2\n\n    Explanation:\n    The distinct pairs (a, b) such that a + b = 6 are (1, 5) and (2, 4).\n\n    Hint: Use a set to store the complement of each number to the target.\n    \"\"\"\n\n    target = 6\n    num_set = set()\n    count = 0\n\n    for num in nums:\n        complement = target - num\n        if complement in num_set:\n            count += 1\n        num_set.add(num)\n\n    return count", "solution_func": "def g(nums: List[int] = [1, 2, 3, 4, 5]):\n    return nums", "map_ix": [1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique permutations of the list.\n    \"\"\"\n    def dfs(nums: List[int], path: List[int], used: List[bool], res: List[List[int]]):\n        if len(path) == len(nums):\n            res.append(path.copy())\n            return\n\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            dfs(nums, path, used, res)\n            used[i] = False\n            path.pop()\n\n    nums.sort()\n    res = []\n    dfs(nums, [], [False] * len(nums), res)\n    return len(res)\n\ndef g(nums: List[int] = [1, 1, 2]):\n    \"\"\"\n    Generate a list of integers for the function f.\n    \"\"\"\n    return nums\n\nassert f(g()) == 3\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 454, "target_skills": [1, 0, 1, 1, 0, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique permutations of the list.\n    \"\"\"\n    def dfs(nums: List[int], path: List[int], used: List[bool], res: List[List[int]]):\n        if len(path) == len(nums):\n            res.append(path.copy())\n            return\n\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            dfs(nums, path, used, res)\n            used[i] = False\n            path.pop()\n\n    nums.sort()\n    res = []\n    dfs(nums, [], [False] * len(nums), res)\n    return len(res)", "solution_func": "def g(nums: List[int] = [1, 1, 2]):\n    \"\"\"\n    Generate a list of integers for the function f.\n    \"\"\"\n    return nums", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n    If the target value is not present in the list, return -1.\n\n    Args:\n    - arr: A sorted list of integers.\n    - target: The target value.\n\n    Returns:\n    - The index of the target value in the list, or -1 if not found.\n\n    Example:\n    f([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 6) returns 5\n    f([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 11) returns -1\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n\n    Returns:\n    - The generated list and the target value.\n\n    Example:\n    g() returns ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 6)\n    \"\"\"\n\n    return ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 6)\n\nassert f(*g()) == 5\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 455, "target_skills": [1, 0, 1, 1, 1, 1, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n    If the target value is not present in the list, return -1.\n\n    Args:\n    - arr: A sorted list of integers.\n    - target: The target value.\n\n    Returns:\n    - The index of the target value in the list, or -1 if not found.\n\n    Example:\n    f([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 6) returns 5\n    f([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 11) returns -1\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n\n    Returns:\n    - The generated list and the target value.\n\n    Example:\n    g() returns ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 6)\n    \"\"\"\n\n    return ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 6)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"\n    Given a string, check if it is a palindrome.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n\n    Args:\n    - string: The input string.\n\n    Returns:\n    - True if the string is a palindrome, False otherwise.\n\n    Example:\n    f(\"racecar\") returns True\n    f(\"hello\") returns False\n    \"\"\"\n\n    return string == string[::-1]\n\ndef g() -> str:\n    \"\"\"\n    Generate a string.\n\n    Returns:\n    - The generated string.\n\n    Example:\n    g() returns \"racecar\"\n    \"\"\"\n\n    return \"racecar\"\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 455, "target_skills": [1, 0, 1, 1, 0, 1, 1, 1, 0, 0], "problem_func": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"\n    Given a string, check if it is a palindrome.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n\n    Args:\n    - string: The input string.\n\n    Returns:\n    - True if the string is a palindrome, False otherwise.\n\n    Example:\n    f(\"racecar\") returns True\n    f(\"hello\") returns False\n    \"\"\"\n\n    return string == string[::-1]", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate a string.\n\n    Returns:\n    - The generated string.\n\n    Example:\n    g() returns \"racecar\"\n    \"\"\"\n\n    return \"racecar\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum possible by traversing from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Args:\n    - grid: A 2D grid of integers.\n\n    Returns:\n    - The maximum sum possible.\n\n    Example:\n    f([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) returns 7\n    f([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) returns 21\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers.\n\n    Returns:\n    - The generated grid.\n\n    Example:\n    g() returns [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    \"\"\"\n\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 7\n\n", "emb": null, "idx_generation": 455, "target_skills": [0, 0, 1, 1, 1, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum possible by traversing from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Args:\n    - grid: A 2D grid of integers.\n\n    Returns:\n    - The maximum sum possible.\n\n    Example:\n    f([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) returns 7\n    f([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) returns 21\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers.\n\n    Returns:\n    - The generated grid.\n\n    Example:\n    g() returns [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    \"\"\"\n\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix, rotate the matrix 90 degrees clockwise.\n\n    Example:\n    Input:\n    [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    [\n        [7, 4, 1],\n        [8, 5, 2],\n        [9, 6, 3]\n    ]\n    \"\"\"\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n    return matrix\n\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n", "emb": null, "idx_generation": 455, "target_skills": [0, 1, 0, 1, 0, 0, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix, rotate the matrix 90 degrees clockwise.\n\n    Example:\n    Input:\n    [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    [\n        [7, 4, 1],\n        [8, 5, 2],\n        [9, 6, 3]\n    ]\n    \"\"\"\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n    return matrix", "solution_func": "def g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome after removing at most one character.\n\n    Example:\n    Input: \"abcdcb\"\n    Output: True\n    Explanation: Remove 'd' to get \"abcba\", which is a palindrome.\n\n    Input: \"abcde\"\n    Output: False\n    Explanation: No character can be removed to form a palindrome.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    if is_palindrome(s):\n        return True\n\n    left, right = 0, len(s) - 1\n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s[left:right]) or is_palindrome(s[left+1:right+1])\n        left += 1\n        right -= 1\n\n    return True\n\ndef g(s=\"abcdcb\"):\n    return s\n\nassert f(g()) == True\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 455, "target_skills": [0, 1, 1, 1, 1, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome after removing at most one character.\n\n    Example:\n    Input: \"abcdcb\"\n    Output: True\n    Explanation: Remove 'd' to get \"abcba\", which is a palindrome.\n\n    Input: \"abcde\"\n    Output: False\n    Explanation: No character can be removed to form a palindrome.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    if is_palindrome(s):\n        return True\n\n    left, right = 0, len(s) - 1\n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s[left:right]) or is_palindrome(s[left+1:right+1])\n        left += 1\n        right -= 1\n\n    return True", "solution_func": "def g(s=\"abcdcb\"):\n    return s", "map_ix": [1, 1, 0, 1, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\n    You can only move either down or right at any point in time.\n\n    Example:\n    Input: 3\n    Output: 6\n    Explanation: There are 6 unique paths from (0, 0) to (2, 2).\n    \"\"\"\n\n    def unique_paths(m: int, n: int) -> int:\n        if m == 1 or n == 1:\n            return 1\n        return unique_paths(m - 1, n) + unique_paths(m, n - 1)\n\n    return unique_paths(n, n)\n\ndef g(n=3):\n    return n\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 455, "target_skills": [1, 0, 1, 0, 0, 1, 0, 0, 1, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\n    You can only move either down or right at any point in time.\n\n    Example:\n    Input: 3\n    Output: 6\n    Explanation: There are 6 unique paths from (0, 0) to (2, 2).\n    \"\"\"\n\n    def unique_paths(m: int, n: int) -> int:\n        if m == 1 or n == 1:\n            return 1\n        return unique_paths(m - 1, n) + unique_paths(m, n - 1)\n\n    return unique_paths(n, n)", "solution_func": "def g(n=3):\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    Given a directed acyclic graph represented as a list of edges, find the longest path from a source node to a target node.\n\n    Args:\n    - n: The number of nodes in the graph.\n    - edges: A list of edges, where each edge is represented as a list [source, target].\n\n    Returns:\n    - The length of the longest path from a source node to a target node.\n    \"\"\"\n    # Create an adjacency list representation of the graph\n    graph = [[] for _ in range(n + 1)]\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n    \n    # Helper function to perform DFS and calculate the longest path\n    def dfs(node):\n        if not graph[node]:\n            return 0\n        else:\n            max_path = 0\n            for neighbor in graph[node]:\n                max_path = max(max_path, dfs(neighbor) + 1)\n            return max_path\n    \n    return dfs(1)\n\ndef g():\n    n = 5\n    edges = [[1, 2], [2, 3], [3, 4], [4, 5]]\n    return n, edges\n\nassert f(*g()) == 4\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 455, "target_skills": [0, 0, 0, 0, 0, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    Given a directed acyclic graph represented as a list of edges, find the longest path from a source node to a target node.\n\n    Args:\n    - n: The number of nodes in the graph.\n    - edges: A list of edges, where each edge is represented as a list [source, target].\n\n    Returns:\n    - The length of the longest path from a source node to a target node.\n    \"\"\"\n    # Create an adjacency list representation of the graph\n    graph = [[] for _ in range(n + 1)]\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n    \n    # Helper function to perform DFS and calculate the longest path\n    def dfs(node):\n        if not graph[node]:\n            return 0\n        else:\n            max_path = 0\n            for neighbor in graph[node]:\n                max_path = max(max_path, dfs(neighbor) + 1)\n            return max_path\n    \n    return dfs(1)", "solution_func": "def g():\n    n = 5\n    edges = [[1, 2], [2, 3], [3, 4], [4, 5]]\n    return n, edges", "map_ix": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(string: str, pattern: str) -> bool:\n    \"\"\"\n    Given a string and a pattern, determine if the pattern matches the string.\n    The pattern consists of letters (a-z) and wildcards (*).\n    A wildcard can match any sequence of characters.\n\n    Args:\n    - string: The input string.\n    - pattern: The pattern to match.\n\n    Returns:\n    - True if the pattern matches the string, False otherwise.\n    \"\"\"\n    # Length of the string and pattern\n    n = len(string)\n    m = len(pattern)\n    \n    # Initialize the DP table\n    dp = [[False] * (m + 1) for _ in range(n + 1)]\n    \n    # Base case: empty string and empty pattern match\n    dp[0][0] = True\n    \n    # Initialize the first row: empty string and non-empty pattern\n    for j in range(1, m + 1):\n        if pattern[j - 1] == '*':\n            dp[0][j] = dp[0][j - 1]\n    \n    # Fill in the DP table\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if pattern[j - 1] == '*':\n                dp[i][j] = dp[i][j - 1] or dp[i - 1][j]\n            elif pattern[j - 1] == '?' or pattern[j - 1] == string[i - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n    \n    return dp[n][m]\n\ndef g():\n    string = \"abacaba\"\n    pattern = \"a*a?a*a\"\n    return string, pattern\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 455, "target_skills": [0, 1, 1, 1, 0, 0, 0, 1, 1, 1], "problem_func": "from typing import*\ndef f(string: str, pattern: str) -> bool:\n    \"\"\"\n    Given a string and a pattern, determine if the pattern matches the string.\n    The pattern consists of letters (a-z) and wildcards (*).\n    A wildcard can match any sequence of characters.\n\n    Args:\n    - string: The input string.\n    - pattern: The pattern to match.\n\n    Returns:\n    - True if the pattern matches the string, False otherwise.\n    \"\"\"\n    # Length of the string and pattern\n    n = len(string)\n    m = len(pattern)\n    \n    # Initialize the DP table\n    dp = [[False] * (m + 1) for _ in range(n + 1)]\n    \n    # Base case: empty string and empty pattern match\n    dp[0][0] = True\n    \n    # Initialize the first row: empty string and non-empty pattern\n    for j in range(1, m + 1):\n        if pattern[j - 1] == '*':\n            dp[0][j] = dp[0][j - 1]\n    \n    # Fill in the DP table\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if pattern[j - 1] == '*':\n                dp[i][j] = dp[i][j - 1] or dp[i - 1][j]\n            elif pattern[j - 1] == '?' or pattern[j - 1] == string[i - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n    \n    return dp[n][m]", "solution_func": "def g():\n    string = \"abacaba\"\n    pattern = \"a*a?a*a\"\n    return string, pattern", "map_ix": [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, prices: List[int]) -> int:\n    \"\"\"\n    Given a list of prices for items and a budget, find the maximum number of items that can be bought without exceeding the budget.\n\n    Args:\n    - n: The number of items.\n    - prices: A list of prices, where prices[i] is the price of the i-th item.\n\n    Returns:\n    - The maximum number of items that can be bought.\n    \"\"\"\n    # Sort the prices in ascending order\n    prices.sort()\n    \n    # Initialize the total cost and number of items\n    total_cost = 0\n    num_items = 0\n    \n    # Iterate over the prices\n    for price in prices:\n        if total_cost + price <= n:\n            total_cost += price\n            num_items += 1\n        else:\n            break\n    \n    return num_items\n\ndef g():\n    n = 10\n    prices = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return n, prices\n\nassert f(*g()) == 5\n", "emb": null, "idx_generation": 455, "target_skills": [1, 1, 1, 0, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, prices: List[int]) -> int:\n    \"\"\"\n    Given a list of prices for items and a budget, find the maximum number of items that can be bought without exceeding the budget.\n\n    Args:\n    - n: The number of items.\n    - prices: A list of prices, where prices[i] is the price of the i-th item.\n\n    Returns:\n    - The maximum number of items that can be bought.\n    \"\"\"\n    # Sort the prices in ascending order\n    prices.sort()\n    \n    # Initialize the total cost and number of items\n    total_cost = 0\n    num_items = 0\n    \n    # Iterate over the prices\n    for price in prices:\n        if total_cost + price <= n:\n            total_cost += price\n            num_items += 1\n        else:\n            break\n    \n    return num_items", "solution_func": "def g():\n    n = 10\n    prices = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return n, prices", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find the two elements that have the maximum product.\n\n    Example:\n    arr = [1, -2, 3, 4, -5, 6]\n\n    Output:\n    [6, -5]\n\n    Explanation:\n    The two elements with the maximum product are 6 and -5, which gives a product of -30.\n\n    Hint: Use counting and combinatorial analysis to determine the two elements with the maximum product.\n    \"\"\"\n    max_product = float('-inf')\n    max_elements = []\n    \n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            product = arr[i] * arr[j]\n            if product > max_product:\n                max_product = product\n                max_elements = [arr[i], arr[j]]\n    \n    return max_elements\n\ndef g() -> List[int]:\n    return [1, -2, 3, 4, -5, 6]\n\nassert f(g()) == [6, -5]\n\n", "emb": null, "idx_generation": 455, "target_skills": [0, 1, 1, 0, 1, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find the two elements that have the maximum product.\n\n    Example:\n    arr = [1, -2, 3, 4, -5, 6]\n\n    Output:\n    [6, -5]\n\n    Explanation:\n    The two elements with the maximum product are 6 and -5, which gives a product of -30.\n\n    Hint: Use counting and combinatorial analysis to determine the two elements with the maximum product.\n    \"\"\"\n    max_product = float('-inf')\n    max_elements = []\n    \n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            product = arr[i] * arr[j]\n            if product > max_product:\n                max_product = product\n                max_elements = [arr[i], arr[j]]\n    \n    return max_elements", "solution_func": "def g() -> List[int]:\n    return [1, -2, 3, 4, -5, 6]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers and a target value, return the index of the target value in the array.\n    If the target is not found, return -1.\n\n    Example:\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 6\n\n    Output:\n    5\n\n    Explanation:\n    The target value 6 is found at index 5 in the array.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Generate a sorted array of integers and a target value.\n    \"\"\"\n    return arr, target\n\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ntarget = 6\n\nassert f(*g(arr, target)) == 5\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 456, "target_skills": [1, 0, 0, 1, 1, 1, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers and a target value, return the index of the target value in the array.\n    If the target is not found, return -1.\n\n    Example:\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 6\n\n    Output:\n    5\n\n    Explanation:\n    The target value 6 is found at index 5 in the array.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Generate a sorted array of integers and a target value.\n    \"\"\"\n    return arr, target\n\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ntarget = 6", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, calculate the sum of all the even numbers in the list.\n\n    Example:\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    Output:\n    20\n\n    Explanation:\n    The sum of all the even numbers in the list is 20 (2 + 4 + 6 + 8).\n    \"\"\"\n\n    total = 0\n\n    for num in arr:\n        if num % 2 == 0:\n            total += num\n\n    return total\n\ndef g(arr: List[int]) -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return arr\n\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g(arr)) == 20\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 456, "target_skills": [1, 1, 1, 0, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, calculate the sum of all the even numbers in the list.\n\n    Example:\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    Output:\n    20\n\n    Explanation:\n    The sum of all the even numbers in the list is 20 (2 + 4 + 6 + 8).\n    \"\"\"\n\n    total = 0\n\n    for num in arr:\n        if num % 2 == 0:\n            total += num\n\n    return total", "solution_func": "def g(arr: List[int]) -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return arr\n\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9]", "map_ix": [1, 1, 0, 1, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, count the number of set bits (1s) in its binary representation.\n\n    Example:\n    n = 7\n\n    Output:\n    3\n\n    Explanation:\n    The binary representation of 7 is 111, which contains 3 set bits.\n    \"\"\"\n\n    count = 0\n\n    while n > 0:\n        if n & 1:\n            count += 1\n        n >>= 1\n\n    return count\n\ndef g(n: int) -> int:\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    return n\n\nassert f(g(7)) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 456, "target_skills": [0, 1, 0, 0, 0, 0, 0, 0, 0, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, count the number of set bits (1s) in its binary representation.\n\n    Example:\n    n = 7\n\n    Output:\n    3\n\n    Explanation:\n    The binary representation of 7 is 111, which contains 3 set bits.\n    \"\"\"\n\n    count = 0\n\n    while n > 0:\n        if n & 1:\n            count += 1\n        n >>= 1\n\n    return count", "solution_func": "def g(n: int) -> int:\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    return n", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\n\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> List[int]:\n    \"\"\"\n    Given a directed graph represented as an adjacency list, and two nodes start and end, return a list containing the shortest path from start to end.\n    If there is no path from start to end, return an empty list.\n    \"\"\"\n\n    # Perform breadth-first search to find the shortest path\n    queue = [(start, [start])]\n    visited = set([start])\n\n    while queue:\n        node, path = queue.pop(0)\n\n        if node == end:\n            return path\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, path + [neighbor]))\n\n    return []\n\n\ndef g():\n    \"\"\"\n    Generate a directed graph represented as an adjacency list, and two nodes start and end.\n    \"\"\"\n    graph = {1: [2, 3, 4], 2: [5], 3: [4, 5], 4: [5], 5: []}\n    start = 1\n    end = 5\n    return graph, start, end\n\n\nassert f(*g()) == [1, 2, 5]\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 456, "target_skills": [1, 0, 1, 1, 0, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> List[int]:\n    \"\"\"\n    Given a directed graph represented as an adjacency list, and two nodes start and end, return a list containing the shortest path from start to end.\n    If there is no path from start to end, return an empty list.\n    \"\"\"\n\n    # Perform breadth-first search to find the shortest path\n    queue = [(start, [start])]\n    visited = set([start])\n\n    while queue:\n        node, path = queue.pop(0)\n\n        if node == end:\n            return path\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, path + [neighbor]))\n\n    return []", "solution_func": "def g():\n    \"\"\"\n    Generate a directed graph represented as an adjacency list, and two nodes start and end.\n    \"\"\"\n    graph = {1: [2, 3, 4], 2: [5], 3: [4, 5], 4: [5], 5: []}\n    start = 1\n    end = 5\n    return graph, start, end", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\n\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Given an integer n, generate all possible combinations of n pairs of parentheses.\n    \"\"\"\n\n    def backtrack(output: List[str], curr: str, open_count: int, close_count: int, max_count: int):\n        if len(curr) == max_count * 2:\n            output.append(curr)\n            return\n\n        if open_count < max_count:\n            backtrack(output, curr + \"(\", open_count + 1, close_count, max_count)\n\n        if close_count < open_count:\n            backtrack(output, curr + \")\", open_count, close_count + 1, max_count)\n\n    output = []\n    backtrack(output, \"\", 0, 0, n)\n    return output\n\n\ndef g():\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    n = 3\n    return n\n\n\nassert f(g()) == [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 456, "target_skills": [0, 1, 0, 0, 0, 0, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Given an integer n, generate all possible combinations of n pairs of parentheses.\n    \"\"\"\n\n    def backtrack(output: List[str], curr: str, open_count: int, close_count: int, max_count: int):\n        if len(curr) == max_count * 2:\n            output.append(curr)\n            return\n\n        if open_count < max_count:\n            backtrack(output, curr + \"(\", open_count + 1, close_count, max_count)\n\n        if close_count < open_count:\n            backtrack(output, curr + \")\", open_count, close_count + 1, max_count)\n\n    output = []\n    backtrack(output, \"\", 0, 0, n)\n    return output", "solution_func": "def g():\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    n = 3\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import *\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, return the indices of two numbers such that they add up to the target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        sum = nums[left] + nums[right]\n\n        if sum == target:\n            return [left, right]\n\n        if sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\n\ndef g():\n    \"\"\"\n    Generate a sorted list of integers nums and a target value.\n    \"\"\"\n    nums = [2, 4, 6, 8, 10]\n    target = 12\n    return nums, target\n\n\nassert f(*g()) == [1, 2]\n\n", "emb": null, "idx_generation": 456, "target_skills": [1, 0, 0, 0, 1, 1, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, return the indices of two numbers such that they add up to the target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        sum = nums[left] + nums[right]\n\n        if sum == target:\n            return [left, right]\n\n        if sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g():\n    \"\"\"\n    Generate a sorted list of integers nums and a target value.\n    \"\"\"\n    nums = [2, 4, 6, 8, 10]\n    target = 12\n    return nums, target", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of distinct permutations of numbers from 1 to n such that no two adjacent numbers are consecutive integers.\n\n    Example:\n    f(3) returns 6, as there are 6 distinct permutations: [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1], [1, 2, 3].\n\n    Note:\n    - The input integer n will be greater than or equal to 1.\n    \"\"\"\n\n    def count_permutations(n: int, prev: int, count: int) -> int:\n        if count == n:\n            return 1\n        result = 0\n        for i in range(1, n + 1):\n            if i != prev and i != prev + 1 and i != prev - 1:\n                result += count_permutations(n, i, count + 1)\n        return result\n\n    return count_permutations(n, 0, 0)\n\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer.\n\n    Example:\n    g() returns 3.\n    \"\"\"\n\n    return 3\n\n\nassert f(g()) == 6\n\n", "emb": null, "idx_generation": 456, "target_skills": [0, 1, 1, 1, 0, 0, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of distinct permutations of numbers from 1 to n such that no two adjacent numbers are consecutive integers.\n\n    Example:\n    f(3) returns 6, as there are 6 distinct permutations: [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1], [1, 2, 3].\n\n    Note:\n    - The input integer n will be greater than or equal to 1.\n    \"\"\"\n\n    def count_permutations(n: int, prev: int, count: int) -> int:\n        if count == n:\n            return 1\n        result = 0\n        for i in range(1, n + 1):\n            if i != prev and i != prev + 1 and i != prev - 1:\n                result += count_permutations(n, i, count + 1)\n        return result\n\n    return count_permutations(n, 0, 0)", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a positive integer.\n\n    Example:\n    g() returns 3.\n    \"\"\"\n\n    return 3", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target sum, return the count of distinct combinations of numbers from the list that add up to the target sum.\n\n    Example:\n    f([1, 2, 3], 4) returns 7, as there are 7 distinct combinations: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2], [3, 1], [1, 3].\n\n    Note:\n    - The input list nums may contain duplicates.\n    \"\"\"\n\n    def count_combinations(nums: List[int], target: int, index: int, memo: dict) -> int:\n        if target == 0:\n            return 1\n        if index >= len(nums) or target < 0:\n            return 0\n        if (index, target) in memo:\n            return memo[(index, target)]\n        \n        count1 = count_combinations(nums, target - nums[index], index, memo)\n        count2 = count_combinations(nums, target, index + 1, memo)\n        \n        memo[(index, target)] = count1 + count2\n        return memo[(index, target)]\n\n    memo = {}\n    return count_combinations(nums, target, 0, memo)\n\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target sum.\n\n    Example:\n    g() returns ([1, 2, 3], 4).\n    \"\"\"\n\n    nums = [1, 2, 3]\n    target = 4\n    return nums, target\n\n\nassert f(*g()) == 7\n\n", "emb": null, "idx_generation": 456, "target_skills": [0, 0, 1, 1, 0, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target sum, return the count of distinct combinations of numbers from the list that add up to the target sum.\n\n    Example:\n    f([1, 2, 3], 4) returns 7, as there are 7 distinct combinations: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2], [3, 1], [1, 3].\n\n    Note:\n    - The input list nums may contain duplicates.\n    \"\"\"\n\n    def count_combinations(nums: List[int], target: int, index: int, memo: dict) -> int:\n        if target == 0:\n            return 1\n        if index >= len(nums) or target < 0:\n            return 0\n        if (index, target) in memo:\n            return memo[(index, target)]\n        \n        count1 = count_combinations(nums, target - nums[index], index, memo)\n        count2 = count_combinations(nums, target, index + 1, memo)\n        \n        memo[(index, target)] = count1 + count2\n        return memo[(index, target)]\n\n    memo = {}\n    return count_combinations(nums, target, 0, memo)", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target sum.\n\n    Example:\n    g() returns ([1, 2, 3], 4).\n    \"\"\"\n\n    nums = [1, 2, 3]\n    target = 4\n    return nums, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of positive integers nums, return the count of distinct increasing subsequences.\n\n    Example:\n    f([1, 2, 3, 4]) returns 15, as there are 15 distinct increasing subsequences: [1], [2], [3], [4], [1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4], [1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4], [1, 2, 3, 4].\n\n    Note:\n    - The input list nums may contain duplicates.\n    - The subsequences should be strictly increasing, i.e., each element in the subsequence should be greater than the previous element.\n    \"\"\"\n\n    def count_subsequences(nums: List[int], index: int, prev: int, memo: dict) -> int:\n        if index >= len(nums):\n            return 0\n        if (index, prev) in memo:\n            return memo[(index, prev)]\n        \n        count = 0\n        if nums[index] > prev:\n            count += 1 + count_subsequences(nums, index + 1, nums[index], memo)\n        count += count_subsequences(nums, index + 1, prev, memo)\n        \n        memo[(index, prev)] = count\n        return memo[(index, prev)]\n\n    memo = {}\n    return count_subsequences(nums, 0, float('-inf'), memo)\n\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers.\n\n    Example:\n    g() returns [1, 2, 3, 4].\n    \"\"\"\n\n    return [1, 2, 3, 4]\n\n\nassert f(g()) == 15\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 456, "target_skills": [0, 1, 0, 1, 0, 0, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of positive integers nums, return the count of distinct increasing subsequences.\n\n    Example:\n    f([1, 2, 3, 4]) returns 15, as there are 15 distinct increasing subsequences: [1], [2], [3], [4], [1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4], [1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4], [1, 2, 3, 4].\n\n    Note:\n    - The input list nums may contain duplicates.\n    - The subsequences should be strictly increasing, i.e., each element in the subsequence should be greater than the previous element.\n    \"\"\"\n\n    def count_subsequences(nums: List[int], index: int, prev: int, memo: dict) -> int:\n        if index >= len(nums):\n            return 0\n        if (index, prev) in memo:\n            return memo[(index, prev)]\n        \n        count = 0\n        if nums[index] > prev:\n            count += 1 + count_subsequences(nums, index + 1, nums[index], memo)\n        count += count_subsequences(nums, index + 1, prev, memo)\n        \n        memo[(index, prev)] = count\n        return memo[(index, prev)]\n\n    memo = {}\n    return count_subsequences(nums, 0, float('-inf'), memo)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers.\n\n    Example:\n    g() returns [1, 2, 3, 4].\n    \"\"\"\n\n    return [1, 2, 3, 4]", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array nums, and a target value target, find two numbers in nums such that they add up to target.\n    Return the indices of the two numbers (1-indexed) as a list, where the index1 must be less than index2.\n\n    Args:\n    - nums: A list of integers representing the sorted array.\n    - target: An integer representing the target value.\n\n    Returns:\n    - A list of two integers representing the indices of the two numbers that add up to target.\n    \"\"\"\n    n = len(nums)\n    left, right = 0, n - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left + 1, right + 1]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return [nums, target]\n\nassert f(*g()) == [1, 2]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 456, "target_skills": [0, 1, 0, 1, 0, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array nums, and a target value target, find two numbers in nums such that they add up to target.\n    Return the indices of the two numbers (1-indexed) as a list, where the index1 must be less than index2.\n\n    Args:\n    - nums: A list of integers representing the sorted array.\n    - target: An integer representing the target value.\n\n    Returns:\n    - A list of two integers representing the indices of the two numbers that add up to target.\n    \"\"\"\n    n = len(nums)\n    left, right = 0, n - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left + 1, right + 1]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g(nums=[2, 7, 11, 15], target=9):\n    return [nums, target]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target number using binary search.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output:\n    2 (the index of the target number 5 is 2)\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    return [1, 3, 5, 7, 9], 5\n\nassert f(*g()) == 2\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 457, "target_skills": [1, 1, 1, 1, 1, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target number using binary search.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output:\n    2 (the index of the target number 5 is 2)\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g():\n    return [1, 3, 5, 7, 9], 5", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> float:\n    \"\"\"\n    Given a list of 2D points, calculate the total perimeter of the convex hull.\n\n    Example:\n    points = [[0,0], [0,1], [1,0], [1,1], [0.5, 0.5]]\n\n    Output:\n    4.0 (the total perimeter of the convex hull is 4.0)\n    \"\"\"\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        elif val > 0:\n            return 1\n        else:\n            return 2\n\n    def convex_hull(points):\n        n = len(points)\n        if n < 3:\n            return []\n\n        hull = []\n\n        l = 0\n        for i in range(1, n):\n            if points[i][0] < points[l][0]:\n                l = i\n\n        p = l\n        q = 0\n        while True:\n            hull.append(points[p])\n            q = (p + 1) % n\n            for i in range(n):\n                if orientation(points[p], points[i], points[q]) == 2:\n                    q = i\n            p = q\n            if p == l:\n                break\n\n        return hull\n\n    hull_points = convex_hull(points)\n    perimeter = 0.0\n    for i in range(len(hull_points)):\n        p1 = hull_points[i]\n        p2 = hull_points[(i + 1) % len(hull_points)]\n        perimeter += ((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2) ** 0.5\n\n    return perimeter\n\ndef g():\n    return [[0,0], [0,1], [1,0], [1,1], [0.5, 0.5]]\n\nassert f(g()) == 4.0\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], "idx_generation": 457, "target_skills": [0, 1, 1, 1, 1, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> float:\n    \"\"\"\n    Given a list of 2D points, calculate the total perimeter of the convex hull.\n\n    Example:\n    points = [[0,0], [0,1], [1,0], [1,1], [0.5, 0.5]]\n\n    Output:\n    4.0 (the total perimeter of the convex hull is 4.0)\n    \"\"\"\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        elif val > 0:\n            return 1\n        else:\n            return 2\n\n    def convex_hull(points):\n        n = len(points)\n        if n < 3:\n            return []\n\n        hull = []\n\n        l = 0\n        for i in range(1, n):\n            if points[i][0] < points[l][0]:\n                l = i\n\n        p = l\n        q = 0\n        while True:\n            hull.append(points[p])\n            q = (p + 1) % n\n            for i in range(n):\n                if orientation(points[p], points[i], points[q]) == 2:\n                    q = i\n            p = q\n            if p == l:\n                break\n\n        return hull\n\n    hull_points = convex_hull(points)\n    perimeter = 0.0\n    for i in range(len(hull_points)):\n        p1 = hull_points[i]\n        p2 = hull_points[(i + 1) % len(hull_points)]\n        perimeter += ((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2) ** 0.5\n\n    return perimeter", "solution_func": "def g():\n    return [[0,0], [0,1], [1,0], [1,1], [0.5, 0.5]]", "map_ix": [1, 0, 1, 0, 0, 0, 1, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string, count the number of ways to decode it.\n\n    Example:\n    s = \"226\"\n\n    Output:\n    3 (there are 3 ways to decode the string: \"BBF\", \"BZ\", \"VF\")\n    \"\"\"\n    def decode(s):\n        n = len(s)\n        if n == 0 or (n == 1 and s[0] == '0'):\n            return 0\n        if n == 1 or (n == 2 and s[1] == '0'):\n            return 1\n\n        dp = [0] * (n + 1)\n        dp[n] = 1\n        if s[n - 1] != '0':\n            dp[n - 1] = 1\n\n        for i in range(n - 2, -1, -1):\n            if s[i] == '0':\n                continue\n            dp[i] = dp[i + 1]\n            if s[i] == '1' or (s[i] == '2' and s[i + 1] <= '6'):\n                dp[i] += dp[i + 2]\n\n        return dp[0]\n\n    return decode(s)\n\ndef g():\n    return \"226\"\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 457, "target_skills": [1, 0, 0, 1, 1, 1, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string, count the number of ways to decode it.\n\n    Example:\n    s = \"226\"\n\n    Output:\n    3 (there are 3 ways to decode the string: \"BBF\", \"BZ\", \"VF\")\n    \"\"\"\n    def decode(s):\n        n = len(s)\n        if n == 0 or (n == 1 and s[0] == '0'):\n            return 0\n        if n == 1 or (n == 2 and s[1] == '0'):\n            return 1\n\n        dp = [0] * (n + 1)\n        dp[n] = 1\n        if s[n - 1] != '0':\n            dp[n - 1] = 1\n\n        for i in range(n - 2, -1, -1):\n            if s[i] == '0':\n                continue\n            dp[i] = dp[i + 1]\n            if s[i] == '1' or (s[i] == '2' and s[i + 1] <= '6'):\n                dp[i] += dp[i + 2]\n\n        return dp[0]\n\n    return decode(s)", "solution_func": "def g():\n    return \"226\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the number of triplets (i, j, k) such that i < j < k and arr[i] < arr[j] < arr[k].\n\n    Args:\n    - arr: A list of integers.\n\n    Returns:\n    - The number of triplets satisfying the condition.\n    \"\"\"\n    n = len(arr)\n    count = 0\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if arr[i] < arr[j] < arr[k]:\n                    count += 1\n    return count\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    return arr\n\nassert f(g()) == 10\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 457, "target_skills": [1, 1, 0, 0, 1, 0, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the number of triplets (i, j, k) such that i < j < k and arr[i] < arr[j] < arr[k].\n\n    Args:\n    - arr: A list of integers.\n\n    Returns:\n    - The number of triplets satisfying the condition.\n    \"\"\"\n    n = len(arr)\n    count = 0\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if arr[i] < arr[j] < arr[k]:\n                    count += 1\n    return count", "solution_func": "def g():\n    arr = [1, 2, 3, 4, 5]\n    return arr", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    Given a directed graph represented as a list of edges, determine if the graph contains a cycle.\n\n    Args:\n    - n: The number of nodes in the graph.\n    - edges: A list of edges, where each edge is represented as a list [source, target].\n\n    Returns:\n    - True if the graph contains a cycle, False otherwise.\n    \"\"\"\n    def dfs(node, visited, stack):\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in edges[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, stack):\n                    return True\n            elif stack[neighbor]:\n                return True\n        \n        stack[node] = False\n        return False\n    \n    visited = [False] * n\n    stack = [False] * n\n\n    for node in range(n):\n        if not visited[node]:\n            if dfs(node, visited, stack):\n                return True\n    \n    return False\n\ndef g():\n    n = 4\n    edges = [[0, 1], [1, 2], [2, 3], [3, 1]]\n    return n, edges\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 457, "target_skills": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    Given a directed graph represented as a list of edges, determine if the graph contains a cycle.\n\n    Args:\n    - n: The number of nodes in the graph.\n    - edges: A list of edges, where each edge is represented as a list [source, target].\n\n    Returns:\n    - True if the graph contains a cycle, False otherwise.\n    \"\"\"\n    def dfs(node, visited, stack):\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in edges[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, stack):\n                    return True\n            elif stack[neighbor]:\n                return True\n        \n        stack[node] = False\n        return False\n    \n    visited = [False] * n\n    stack = [False] * n\n\n    for node in range(n):\n        if not visited[node]:\n            if dfs(node, visited, stack):\n                return True\n    \n    return False", "solution_func": "def g():\n    n = 4\n    edges = [[0, 1], [1, 2], [2, 3], [3, 1]]\n    return n, edges", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of the first n Fibonacci numbers.\n\n    Args:\n    - n: The number of Fibonacci numbers to calculate.\n\n    Returns:\n    - The sum of the first n Fibonacci numbers.\n    \"\"\"\n    def fibonacci(n):\n        if n <= 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            return fibonacci(n - 1) + fibonacci(n - 2)\n    \n    sum_fib = 0\n    for i in range(1, n + 1):\n        sum_fib += fibonacci(i)\n    \n    return sum_fib\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == 12\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 457, "target_skills": [0, 1, 0, 0, 1, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of the first n Fibonacci numbers.\n\n    Args:\n    - n: The number of Fibonacci numbers to calculate.\n\n    Returns:\n    - The sum of the first n Fibonacci numbers.\n    \"\"\"\n    def fibonacci(n):\n        if n <= 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            return fibonacci(n - 1) + fibonacci(n - 2)\n    \n    sum_fib = 0\n    for i in range(1, n + 1):\n        sum_fib += fibonacci(i)\n    \n    return sum_fib", "solution_func": "def g():\n    n = 5\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort them in non-decreasing order.\n\n    Args:\n    - nums: The list of integers.\n\n    Returns:\n    - The sorted list of integers.\n    \"\"\"\n    return sorted(nums)\n\ndef g():\n    nums = [5, 2, 9, 1, 7]\n    return nums\n\nassert f(g()) == [1, 2, 5, 7, 9]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 457, "target_skills": [1, 1, 1, 1, 1, 1, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort them in non-decreasing order.\n\n    Args:\n    - nums: The list of integers.\n\n    Returns:\n    - The sorted list of integers.\n    \"\"\"\n    return sorted(nums)", "solution_func": "def g():\n    nums = [5, 2, 9, 1, 7]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"\n    Given a string s and a target string, determine if the target string is a substring of s.\n\n    Args:\n    - s: The original string.\n    - target: The target string.\n\n    Returns:\n    - True if the target string is a substring of s, False otherwise.\n    \"\"\"\n    return target in s\n\ndef g():\n    s = \"hello world\"\n    target = \"world\"\n    return s, target\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 457, "target_skills": [1, 1, 0, 0, 0, 1, 1, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"\n    Given a string s and a target string, determine if the target string is a substring of s.\n\n    Args:\n    - s: The original string.\n    - target: The target string.\n\n    Returns:\n    - True if the target string is a substring of s, False otherwise.\n    \"\"\"\n    return target in s", "solution_func": "def g():\n    s = \"hello world\"\n    target = \"world\"\n    return s, target", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target integer, determine if there exists a pair of integers in the list whose sum is equal to the target.\n\n    Args:\n    - nums: The list of integers.\n    - target: The target integer.\n\n    Returns:\n    - True if there exists a pair of integers in the list whose sum is equal to the target, False otherwise.\n    \"\"\"\n    nums_set = set(nums)\n    for num in nums:\n        complement = target - num\n        if complement in nums_set:\n            return True\n    return False\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == True\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 457, "target_skills": [0, 1, 1, 1, 0, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target integer, determine if there exists a pair of integers in the list whose sum is equal to the target.\n\n    Args:\n    - nums: The list of integers.\n    - target: The target integer.\n\n    Returns:\n    - True if there exists a pair of integers in the list whose sum is equal to the target, False otherwise.\n    \"\"\"\n    nums_set = set(nums)\n    for num in nums:\n        complement = target - num\n        if complement in nums_set:\n            return True\n    return False", "solution_func": "def g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums', sort the list in non-decreasing order using bubble sort algorithm.\n\n    Example:\n    nums = [5, 2, 9, 1, 3]\n\n    Output:\n    [1, 2, 3, 5, 9]\n    \"\"\"\n\n    n = len(nums)\n    for i in range(n):\n        for j in range(n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n\n    return nums\n\ndef g() -> List[int]:\n    return [5, 2, 9, 1, 3]\n\nassert f(g()) == [1, 2, 3, 5, 9]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 457, "target_skills": [0, 0, 1, 0, 0, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums', sort the list in non-decreasing order using bubble sort algorithm.\n\n    Example:\n    nums = [5, 2, 9, 1, 3]\n\n    Output:\n    [1, 2, 3, 5, 9]\n    \"\"\"\n\n    n = len(nums)\n    for i in range(n):\n        for j in range(n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n\n    return nums", "solution_func": "def g() -> List[int]:\n    return [5, 2, 9, 1, 3]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, m: int) -> bool:\n    \"\"\"\n    Check if the sum of the first n numbers is divisible by m.\n\n    - n is the number of terms in the sum.\n    - m is the number to check divisibility against.\n    \"\"\"\n    total = (n*(n+1))//2\n    return total % m == 0\n\ndef g(n = 10, m = 3):\n    return n, m\n\nassert f(*g())\n", "emb": null, "idx_generation": 458, "target_skills": [0, 1, 0, 1, 1, 0, 1, 0, 1, 1], "problem_func": "from typing import*\ndef f(n: int, m: int) -> bool:\n    \"\"\"\n    Check if the sum of the first n numbers is divisible by m.\n\n    - n is the number of terms in the sum.\n    - m is the number to check divisibility against.\n    \"\"\"\n    total = (n*(n+1))//2\n    return total % m == 0", "solution_func": "def g(n = 10, m = 3):\n    return n, m", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Find the minimum number of steps required to reach the target cell from the starting cell in a grid.\n\n    - grid is a 2D list representing the grid where 0 represents an empty cell, 1 represents a blocked cell,\n      and 2 represents the starting and target cells.\n    - Return -1 if there is no path from the starting cell to the target cell.\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m\n\n    def bfs(start_x, start_y):\n        dx = [-1, 1, 0, 0]\n        dy = [0, 0, -1, 1]\n\n        queue = [(start_x, start_y, 0)]\n        visited = set((start_x, start_y))\n\n        while queue:\n            x, y, steps = queue.pop(0)\n\n            if grid[x][y] == 2:\n                return steps\n\n            for i in range(4):\n                nx = x + dx[i]\n                ny = y + dy[i]\n\n                if is_valid(nx, ny) and (nx, ny) not in visited and grid[nx][ny] != 1:\n                    queue.append((nx, ny, steps + 1))\n                    visited.add((nx, ny))\n\n        return -1\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 2:\n                return bfs(i, j)\n\n    return -1\n\ndef g():\n    return [\n        [2, 0, 0, 0],\n        [1, 1, 0, 1],\n        [0, 0, 0, 1],\n        [0, 1, 1, 1]\n    ]\n\nassert f(g()) == 4\n", "emb": null, "idx_generation": 458, "target_skills": [1, 1, 0, 1, 0, 1, 0, 1, 1, 1], "problem_func": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Find the minimum number of steps required to reach the target cell from the starting cell in a grid.\n\n    - grid is a 2D list representing the grid where 0 represents an empty cell, 1 represents a blocked cell,\n      and 2 represents the starting and target cells.\n    - Return -1 if there is no path from the starting cell to the target cell.\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m\n\n    def bfs(start_x, start_y):\n        dx = [-1, 1, 0, 0]\n        dy = [0, 0, -1, 1]\n\n        queue = [(start_x, start_y, 0)]\n        visited = set((start_x, start_y))\n\n        while queue:\n            x, y, steps = queue.pop(0)\n\n            if grid[x][y] == 2:\n                return steps\n\n            for i in range(4):\n                nx = x + dx[i]\n                ny = y + dy[i]\n\n                if is_valid(nx, ny) and (nx, ny) not in visited and grid[nx][ny] != 1:\n                    queue.append((nx, ny, steps + 1))\n                    visited.add((nx, ny))\n\n        return -1\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 2:\n                return bfs(i, j)\n\n    return -1", "solution_func": "def g():\n    return [\n        [2, 0, 0, 0],\n        [1, 1, 0, 1],\n        [0, 0, 0, 1],\n        [0, 1, 1, 1]\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Find the nth Fibonacci number.\n\n    - n is the index of the Fibonacci number to find.\n    - The Fibonacci sequence starts with 0 and 1, and each subsequent number is the sum of the two previous numbers.\n    \"\"\"\n    if n <= 1:\n        return n\n\n    a, b = 0, 1\n\n    for _ in range(n - 1):\n        a, b = b, a + b\n\n    return b\n\ndef g(n = 6):\n    return n\n\nassert f(g()) == 8\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 458, "target_skills": [1, 0, 1, 1, 1, 0, 0, 0, 1, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Find the nth Fibonacci number.\n\n    - n is the index of the Fibonacci number to find.\n    - The Fibonacci sequence starts with 0 and 1, and each subsequent number is the sum of the two previous numbers.\n    \"\"\"\n    if n <= 1:\n        return n\n\n    a, b = 0, 1\n\n    for _ in range(n - 1):\n        a, b = b, a + b\n\n    return b", "solution_func": "def g(n = 6):\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], target: str) -> bool:\n    \"\"\"\n    Given a list of words and a target word, determine if the target word is present in the list.\n    The target word can be formed by concatenating two or more words from the list in any order.\n\n    Example:\n    words = [\"coding\", \"is\", \"fun\"]\n    target = \"codingfun\"\n\n    Output:\n    True (since \"codingfun\" can be formed by concatenating \"coding\" and \"fun\" from the list)\n\n    Note:\n    - The target word can only be formed by concatenating words from the list, and no other characters can be included.\n    \"\"\"\n\n    def dfs(word: str, visited: List[bool]) -> bool:\n        if word == \"\":\n            return True\n\n        for i in range(len(words)):\n            if visited[i]:\n                continue\n\n            if word.startswith(words[i]):\n                visited[i] = True\n                if dfs(word[len(words[i]):], visited):\n                    return True\n                visited[i] = False\n\n        return False\n\n    visited = [False] * len(words)\n    return dfs(target, visited)\n\n\ndef g():\n    return ([\"coding\", \"is\", \"fun\"], \"codingfun\")\n\n\nassert f(*g()) == True\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 458, "target_skills": [0, 1, 0, 1, 1, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], target: str) -> bool:\n    \"\"\"\n    Given a list of words and a target word, determine if the target word is present in the list.\n    The target word can be formed by concatenating two or more words from the list in any order.\n\n    Example:\n    words = [\"coding\", \"is\", \"fun\"]\n    target = \"codingfun\"\n\n    Output:\n    True (since \"codingfun\" can be formed by concatenating \"coding\" and \"fun\" from the list)\n\n    Note:\n    - The target word can only be formed by concatenating words from the list, and no other characters can be included.\n    \"\"\"\n\n    def dfs(word: str, visited: List[bool]) -> bool:\n        if word == \"\":\n            return True\n\n        for i in range(len(words)):\n            if visited[i]:\n                continue\n\n            if word.startswith(words[i]):\n                visited[i] = True\n                if dfs(word[len(words[i]):], visited):\n                    return True\n                visited[i] = False\n\n        return False\n\n    visited = [False] * len(words)\n    return dfs(target, visited)", "solution_func": "def g():\n    return ([\"coding\", \"is\", \"fun\"], \"codingfun\")", "map_ix": [0, 1, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum sum of a subarray.\n    A subarray is a contiguous subsequence of the list.\n\n    Example:\n    nums = [1, -2, 3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    10 (maximum sum is obtained from the subarray [3, 4, -1, 2, 1])\n\n    Note:\n    - An empty list should have a maximum sum of 0.\n    \"\"\"\n\n    if len(nums) == 0:\n        return 0\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(current_sum + num, num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\n\ndef g():\n    return [1, -2, 3, 4, -1, 2, 1, -5, 4]\n\n\nassert f(g()) == 10\n\n", "emb": null, "idx_generation": 458, "target_skills": [0, 1, 1, 0, 0, 0, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum sum of a subarray.\n    A subarray is a contiguous subsequence of the list.\n\n    Example:\n    nums = [1, -2, 3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    10 (maximum sum is obtained from the subarray [3, 4, -1, 2, 1])\n\n    Note:\n    - An empty list should have a maximum sum of 0.\n    \"\"\"\n\n    if len(nums) == 0:\n        return 0\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(current_sum + num, num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g():\n    return [1, -2, 3, 4, -1, 2, 1, -5, 4]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers 'n' and 'k', compute the number of ways to choose k objects from a set of n objects.\n    The order of the objects does not matter.\n\n    Example:\n    n = 5, k = 3\n\n    Output:\n    10 (there are 10 ways to choose 3 objects from a set of 5 objects)\n\n    Note:\n    - The result should be computed modulo 10^9 + 7.\n    \"\"\"\n\n    def factorial(n: int) -> int:\n        result = 1\n        for i in range(1, n + 1):\n            result = (result * i) % (10 ** 9 + 7)\n        return result\n\n    return (factorial(n) // (factorial(k) * factorial(n - k))) % (10 ** 9 + 7)\n\n\ndef g():\n    return (5, 3)\n\n\nassert f(*g()) == 10\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 458, "target_skills": [0, 0, 0, 0, 0, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers 'n' and 'k', compute the number of ways to choose k objects from a set of n objects.\n    The order of the objects does not matter.\n\n    Example:\n    n = 5, k = 3\n\n    Output:\n    10 (there are 10 ways to choose 3 objects from a set of 5 objects)\n\n    Note:\n    - The result should be computed modulo 10^9 + 7.\n    \"\"\"\n\n    def factorial(n: int) -> int:\n        result = 1\n        for i in range(1, n + 1):\n            result = (result * i) % (10 ** 9 + 7)\n        return result\n\n    return (factorial(n) // (factorial(k) * factorial(n - k))) % (10 ** 9 + 7)", "solution_func": "def g():\n    return (5, 3)", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix and two nodes, start and end,\n    determine if there is a path from start to end in the graph.\n\n    Example:\n    graph = [\n        [0, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    start = 0\n    end = 4\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 0 to node 4 in the graph.\n\n    Hint: Use depth-first search or breadth-first search to traverse the graph and find a path from start to end.\n    \"\"\"\n\n    def dfs(node: int, visited: List[bool]) -> bool:\n        if node == end:\n            return True\n\n        visited[node] = True\n\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                if dfs(neighbor, visited):\n                    return True\n\n        return False\n\n    visited = [False] * len(graph)\n    return dfs(start, visited)\n\n\ndef g():\n    \"\"\"\n    Generate a directed graph represented as an adjacency matrix and two nodes, start and end.\n    \"\"\"\n    graph = [\n        [0, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    start = 0\n    end = 4\n    return graph, start, end\n\n\nassert f(*g())\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 458, "target_skills": [0, 0, 1, 0, 1, 1, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix and two nodes, start and end,\n    determine if there is a path from start to end in the graph.\n\n    Example:\n    graph = [\n        [0, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    start = 0\n    end = 4\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 0 to node 4 in the graph.\n\n    Hint: Use depth-first search or breadth-first search to traverse the graph and find a path from start to end.\n    \"\"\"\n\n    def dfs(node: int, visited: List[bool]) -> bool:\n        if node == end:\n            return True\n\n        visited[node] = True\n\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                if dfs(neighbor, visited):\n                    return True\n\n        return False\n\n    visited = [False] * len(graph)\n    return dfs(start, visited)", "solution_func": "def g():\n    \"\"\"\n    Generate a directed graph represented as an adjacency matrix and two nodes, start and end.\n    \"\"\"\n    graph = [\n        [0, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    start = 0\n    end = 4\n    return graph, start, end", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three elements in the list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    24\n\n    Explanation:\n    The maximum product is 2 * 3 * 4 = 24.\n\n    Hint: Sort the list in ascending order and consider the cases where the maximum product involves negative numbers.\n    \"\"\"\n\n    nums.sort()\n\n    n = len(nums)\n\n    return max(nums[0] * nums[1] * nums[n - 1], nums[n - 3] * nums[n - 2] * nums[n - 1])\n\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [1, 2, 3, 4]\n    return nums\n\n\nassert f(g()) == 24\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 458, "target_skills": [0, 0, 1, 1, 1, 1, 1, 1, 1, 0], "problem_func": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three elements in the list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    24\n\n    Explanation:\n    The maximum product is 2 * 3 * 4 = 24.\n\n    Hint: Sort the list in ascending order and consider the cases where the maximum product involves negative numbers.\n    \"\"\"\n\n    nums.sort()\n\n    n = len(nums)\n\n    return max(nums[0] * nums[1] * nums[n - 1], nums[n - 3] * nums[n - 2] * nums[n - 1])", "solution_func": "def g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [1, 2, 3, 4]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n    If the target value is not found in the list, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output:\n    2\n\n    Explanation:\n    The target value 5 is found at index 2 in the list.\n\n    Hint: Use the binary search algorithm to divide the search space in half at each step.\n    \"\"\"\n\n    low = 0\n    high = len(nums) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1\n\n\ndef g():\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target\n\n\nassert f(*g()) == 2\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 458, "target_skills": [1, 1, 0, 1, 0, 0, 1, 1, 1, 1], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n    If the target value is not found in the list, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output:\n    2\n\n    Explanation:\n    The target value 5 is found at index 2 in the list.\n\n    Hint: Use the binary search algorithm to divide the search space in half at each step.\n    \"\"\"\n\n    low = 0\n    high = len(nums) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1", "solution_func": "def g():\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of integers from 1 to n (inclusive) that are divisible by either 3 or 5.\n\n    Example:\n    Input: n = 10\n    Output: 4\n\n    Explanation: The integers from 1 to 10 that are divisible by either 3 or 5 are 3, 5, 6, and 9.\n\n    Hint: Use the principle of inclusion-exclusion to count the numbers divisible by either 3 or 5.\n    \"\"\"\n    count = 0\n    for i in range(1, n+1):\n        if i % 3 == 0 or i % 5 == 0:\n            count += 1\n    return count\n\ndef g(n=10):\n    return n\n\nassert f(g()) == 4\n", "emb": null, "idx_generation": 458, "target_skills": [0, 1, 0, 1, 1, 0, 0, 1, 0, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of integers from 1 to n (inclusive) that are divisible by either 3 or 5.\n\n    Example:\n    Input: n = 10\n    Output: 4\n\n    Explanation: The integers from 1 to 10 that are divisible by either 3 or 5 are 3, 5, 6, and 9.\n\n    Hint: Use the principle of inclusion-exclusion to count the numbers divisible by either 3 or 5.\n    \"\"\"\n    count = 0\n    for i in range(1, n+1):\n        if i % 3 == 0 or i % 5 == 0:\n            count += 1\n    return count", "solution_func": "def g(n=10):\n    return n", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, k: int) -> str:\n    \"\"\"\n    Given a string s and an integer k, return the kth largest unique substring of s.\n\n    Example:\n    s = \"abcabc\"\n    k = 2\n\n    Output:\n    \"bc\"\n\n    Explanation:\n    The unique substrings of \"abcabc\" are [\"a\", \"ab\", \"abc\", \"b\", \"bc\", \"c\"].\n    The 2nd largest unique substring is \"bc\".\n    \"\"\"\n\n    unique_substrings = set()\n\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            unique_substrings.add(s[i:j])\n\n    unique_substrings = sorted(unique_substrings, key=len, reverse=True)\n\n    return unique_substrings[k-1]\n\ndef g():\n    s = \"abcabc\"\n    k = 2\n    return (s, k)\n\nassert f(*g()) == \"bc\"\n", "emb": null, "idx_generation": 459, "target_skills": [0, 0, 0, 1, 0, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str, k: int) -> str:\n    \"\"\"\n    Given a string s and an integer k, return the kth largest unique substring of s.\n\n    Example:\n    s = \"abcabc\"\n    k = 2\n\n    Output:\n    \"bc\"\n\n    Explanation:\n    The unique substrings of \"abcabc\" are [\"a\", \"ab\", \"abc\", \"b\", \"bc\", \"c\"].\n    The 2nd largest unique substring is \"bc\".\n    \"\"\"\n\n    unique_substrings = set()\n\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            unique_substrings.add(s[i:j])\n\n    unique_substrings = sorted(unique_substrings, key=len, reverse=True)\n\n    return unique_substrings[k-1]", "solution_func": "def g():\n    s = \"abcabc\"\n    k = 2\n    return (s, k)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, t: str) -> int:\n    \"\"\"\n    Given two strings s and t, return the length of the longest common subsequence (LCS) of s and t.\n\n    Example:\n    s = \"abcde\"\n    t = \"ace\"\n\n    Output:\n    3\n\n    Explanation:\n    The LCS of \"abcde\" and \"ace\" is \"ace\" with a length of 3.\n    \"\"\"\n\n    m, n = len(s), len(t)\n    dp = [[0] * (n+1) for _ in range(m+1)]\n\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if s[i-1] == t[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n\n    return dp[m][n]\n\ndef g():\n    s = \"abcde\"\n    t = \"ace\"\n    return (s, t)\n\nassert f(*g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 459, "target_skills": [0, 1, 1, 1, 0, 0, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str, t: str) -> int:\n    \"\"\"\n    Given two strings s and t, return the length of the longest common subsequence (LCS) of s and t.\n\n    Example:\n    s = \"abcde\"\n    t = \"ace\"\n\n    Output:\n    3\n\n    Explanation:\n    The LCS of \"abcde\" and \"ace\" is \"ace\" with a length of 3.\n    \"\"\"\n\n    m, n = len(s), len(t)\n    dp = [[0] * (n+1) for _ in range(m+1)]\n\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if s[i-1] == t[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n\n    return dp[m][n]", "solution_func": "def g():\n    s = \"abcde\"\n    t = \"ace\"\n    return (s, t)", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    21\n\n    Explanation:\n    The maximum sum path is 1 -> 4 -> 7 -> 8 -> 9, which has a sum of 21.\n    \"\"\"\n\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g()) == 21\n", "emb": null, "idx_generation": 459, "target_skills": [1, 0, 0, 0, 1, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    21\n\n    Explanation:\n    The maximum sum path is 1 -> 4 -> 7 -> 8 -> 9, which has a sum of 21.\n    \"\"\"\n\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of ways to climb to the top of a staircase.\n    You can climb either 1 or 2 steps at a time.\n\n    Example:\n    n = 3\n\n    Output:\n    3 (as there are 3 ways to climb to the top: 1+1+1, 1+2, 2+1)\n    \"\"\"\n    if n <= 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\ndef g() -> int:\n    n = 3\n    return n\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 459, "target_skills": [1, 1, 0, 0, 0, 0, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of ways to climb to the top of a staircase.\n    You can climb either 1 or 2 steps at a time.\n\n    Example:\n    n = 3\n\n    Output:\n    3 (as there are 3 ways to climb to the top: 1+1+1, 1+2, 2+1)\n    \"\"\"\n    if n <= 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]", "solution_func": "def g() -> int:\n    n = 3\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of distinct integers and a target value, return the index if the target is found.\n    If not, return the index where it would be if it were inserted in order.\n\n    Example:\n    arr = [1, 3, 5, 6]\n    target = 5\n\n    Output:\n    2 (as the target is found at index 2)\n\n    Example:\n    arr = [1, 3, 5, 6]\n    target = 2\n\n    Output:\n    1 (as the target would be inserted at index 1)\n\n    \"\"\"\n    left, right = 0, len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left\n\ndef g() -> List[int]:\n    arr = [1, 3, 5, 6]\n    target = 5\n    return (arr, target)\n\nassert f(*g()) == 2\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 459, "target_skills": [1, 1, 0, 0, 0, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of distinct integers and a target value, return the index if the target is found.\n    If not, return the index where it would be if it were inserted in order.\n\n    Example:\n    arr = [1, 3, 5, 6]\n    target = 5\n\n    Output:\n    2 (as the target is found at index 2)\n\n    Example:\n    arr = [1, 3, 5, 6]\n    target = 2\n\n    Output:\n    1 (as the target would be inserted at index 1)\n\n    \"\"\"\n    left, right = 0, len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left", "solution_func": "def g() -> List[int]:\n    arr = [1, 3, 5, 6]\n    target = 5\n    return (arr, target)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray such that no two elements in the subarray are adjacent.\n\n    Example:\n    nums = [2, 7, 9, 3, 1]\n\n    Output:\n    12 (as the maximum sum subarray is [2, 9, 1])\n\n    \"\"\"\n    if not nums:\n        return 0\n\n    n = len(nums)\n    if n == 1:\n        return nums[0]\n\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])\n\n    return dp[n - 1]\n\ndef g() -> List[int]:\n    nums = [2, 7, 9, 3, 1]\n    return (nums,)\n\nassert f(*g()) == 12\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 459, "target_skills": [1, 0, 0, 1, 0, 1, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray such that no two elements in the subarray are adjacent.\n\n    Example:\n    nums = [2, 7, 9, 3, 1]\n\n    Output:\n    12 (as the maximum sum subarray is [2, 9, 1])\n\n    \"\"\"\n    if not nums:\n        return 0\n\n    n = len(nums)\n    if n == 1:\n        return nums[0]\n\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])\n\n    return dp[n - 1]", "solution_func": "def g() -> List[int]:\n    nums = [2, 7, 9, 3, 1]\n    return (nums,)", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n    If the target value is not found, return -1.\n    \"\"\"\n    def binary_search(nums, target, start, end):\n        if start > end:\n            return -1\n        mid = (start + end) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] > target:\n            return binary_search(nums, target, start, mid - 1)\n        else:\n            return binary_search(nums, target, mid + 1, end)\n\n    return binary_search(nums, target, 0, len(nums) - 1)\n\ndef g():\n    nums = [1, 3, 5, 7, 9, 11, 13, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == 4\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 459, "target_skills": [0, 1, 0, 0, 0, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n    If the target value is not found, return -1.\n    \"\"\"\n    def binary_search(nums, target, start, end):\n        if start > end:\n            return -1\n        mid = (start + end) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] > target:\n            return binary_search(nums, target, start, mid - 1)\n        else:\n            return binary_search(nums, target, mid + 1, end)\n\n    return binary_search(nums, target, 0, len(nums) - 1)", "solution_func": "def g():\n    nums = [1, 3, 5, 7, 9, 11, 13, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n        for num in nums:\n            prefix_set.add(num & mask)\n        candidate = max_xor | (1 << i)\n        for prefix in prefix_set:\n            if candidate ^ prefix in prefix_set:\n                max_xor = candidate\n                break\n    return max_xor\n\ndef g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 459, "target_skills": [0, 1, 0, 1, 0, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n        for num in nums:\n            prefix_set.add(num & mask)\n        candidate = max_xor | (1 << i)\n        for prefix in prefix_set:\n            if candidate ^ prefix in prefix_set:\n                max_xor = candidate\n                break\n    return max_xor", "solution_func": "def g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome after removing at most one character.\n    \"\"\"\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    left = 0\n    right = len(s) - 1\n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s, left + 1, right) or is_palindrome(s, left, right - 1)\n        left += 1\n        right -= 1\n    return True\n\ndef g():\n    s = \"abca\"\n    return s\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 459, "target_skills": [1, 1, 0, 1, 1, 0, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome after removing at most one character.\n    \"\"\"\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    left = 0\n    right = len(s) - 1\n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s, left + 1, right) or is_palindrome(s, left, right - 1)\n        left += 1\n        right -= 1\n    return True", "solution_func": "def g():\n    s = \"abca\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target value, find two numbers in the list that sum up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n\n    Output:\n    [2, 4]\n\n    Explanation:\n    The numbers at indices 2 and 4 in the list sum up to the target value of 7.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g(arr=[1, 2, 3, 4, 5], target=7):\n    return (arr, target)\n\nassert f(*g()) == [2, 4]\n", "emb": null, "idx_generation": 459, "target_skills": [0, 0, 0, 1, 0, 0, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target value, find two numbers in the list that sum up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n\n    Output:\n    [2, 4]\n\n    Explanation:\n    The numbers at indices 2 and 4 in the list sum up to the target value of 7.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g(arr=[1, 2, 3, 4, 5], target=7):\n    return (arr, target)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Find the maximum sum of a subarray in the given array using Kadane's algorithm.\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in arr:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef g():\n    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return arr\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 460, "target_skills": [1, 1, 1, 1, 1, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Find the maximum sum of a subarray in the given array using Kadane's algorithm.\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in arr:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum", "solution_func": "def g():\n    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return arr", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of paths from the top left to the bottom right of an n x n grid, only moving right or down.\"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return f(n-1) + f(n-1)\n\ndef g():\n    n = 3\n    return n\n\nassert f(g()) == 6\n", "emb": null, "idx_generation": 460, "target_skills": [1, 1, 1, 0, 0, 1, 1, 1, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of paths from the top left to the bottom right of an n x n grid, only moving right or down.\"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return f(n-1) + f(n-1)", "solution_func": "def g():\n    n = 3\n    return n", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there is a path between two nodes in a directed graph using Depth-First Search.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g():\n    graph = [[1, 2], [2, 3], [3], []]\n    start = 0\n    end = 3\n    return graph, start, end\n\nassert f(*g())\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 460, "target_skills": [0, 0, 0, 0, 0, 1, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there is a path between two nodes in a directed graph using Depth-First Search.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False", "solution_func": "def g():\n    graph = [[1, 2], [2, 3], [3], []]\n    start = 0\n    end = 3\n    return graph, start, end", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers and a target value, find two numbers in the array that sum up to the target.\n    Return the indices of the two numbers in the array.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        \n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 460, "target_skills": [1, 0, 0, 1, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers and a target value, find two numbers in the array that sum up to the target.\n    Return the indices of the two numbers in the array.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        \n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []", "solution_func": "def g(nums=[2, 7, 11, 15], target=9):\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, words: List[str]) -> List[str]:\n    \"\"\"\n    Given a string and a list of words, find all words from the list that are present in the string.\n    Return a list of the matching words.\n    \"\"\"\n    matching_words = []\n    \n    for word in words:\n        if word in s:\n            matching_words.append(word)\n    \n    return matching_words\n\ndef g(s=\"hello world\", words=[\"hello\", \"hi\", \"world\"]):\n    return s, words\n\nassert f(*g()) == [\"hello\", \"world\"]\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 460, "target_skills": [0, 1, 1, 0, 0, 1, 1, 1, 1, 1], "problem_func": "from typing import*\ndef f(s: str, words: List[str]) -> List[str]:\n    \"\"\"\n    Given a string and a list of words, find all words from the list that are present in the string.\n    Return a list of the matching words.\n    \"\"\"\n    matching_words = []\n    \n    for word in words:\n        if word in s:\n            matching_words.append(word)\n    \n    return matching_words", "solution_func": "def g(s=\"hello world\", words=[\"hello\", \"hi\", \"world\"]):\n    return s, words", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of unique paths from the top-left corner to the bottom-right corner of a grid of size n x n.\n    Return the number of unique paths.\n    \"\"\"\n    def count_paths(i, j):\n        if i == n - 1 and j == n - 1:\n            return 1\n        elif i >= n or j >= n:\n            return 0\n        \n        return count_paths(i + 1, j) + count_paths(i, j + 1)\n    \n    return count_paths(0, 0)\n\ndef g(n=3):\n    return n\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 460, "target_skills": [1, 1, 1, 0, 0, 1, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of unique paths from the top-left corner to the bottom-right corner of a grid of size n x n.\n    Return the number of unique paths.\n    \"\"\"\n    def count_paths(i, j):\n        if i == n - 1 and j == n - 1:\n            return 1\n        elif i >= n or j >= n:\n            return 0\n        \n        return count_paths(i + 1, j) + count_paths(i, j + 1)\n    \n    return count_paths(0, 0)", "solution_func": "def g(n=3):\n    return n", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if it is a magic square.\n    A magic square is a square matrix in which the sum of each row, each column, and both diagonals are equal.\n\n    Return True if the matrix is a magic square, otherwise return False.\n    \"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for j in range(n):\n        column_sum = 0\n        for i in range(n):\n            column_sum += matrix[i][j]\n        if column_sum != target_sum:\n            return False\n\n    # Check diagonals\n    diagonal_sum1 = 0\n    diagonal_sum2 = 0\n    for i in range(n):\n        diagonal_sum1 += matrix[i][i]\n        diagonal_sum2 += matrix[i][n-i-1]\n    if diagonal_sum1 != target_sum or diagonal_sum2 != target_sum:\n        return False\n\n    return True\n\ndef g(matrix=[[2, 7, 6], [9, 5, 1], [4, 3, 8]]):\n    return matrix\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 460, "target_skills": [0, 0, 0, 1, 0, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if it is a magic square.\n    A magic square is a square matrix in which the sum of each row, each column, and both diagonals are equal.\n\n    Return True if the matrix is a magic square, otherwise return False.\n    \"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for j in range(n):\n        column_sum = 0\n        for i in range(n):\n            column_sum += matrix[i][j]\n        if column_sum != target_sum:\n            return False\n\n    # Check diagonals\n    diagonal_sum1 = 0\n    diagonal_sum2 = 0\n    for i in range(n):\n        diagonal_sum1 += matrix[i][i]\n        diagonal_sum2 += matrix[i][n-i-1]\n    if diagonal_sum1 != target_sum or diagonal_sum2 != target_sum:\n        return False\n\n    return True", "solution_func": "def g(matrix=[[2, 7, 6], [9, 5, 1], [4, 3, 8]]):\n    return matrix", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, count the number of palindrome substrings in it.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n\n    Return the count of palindrome substrings in s.\n    \"\"\"\n    count = 0\n    n = len(s)\n\n    # Helper function to check if a substring is a palindrome\n    def is_palindrome(substring: str) -> bool:\n        return substring == substring[::-1]\n\n    # Recursive function to find palindrome substrings\n    def find_palindromes(start: int, end: int) -> None:\n        nonlocal count\n\n        if start > end:\n            return\n\n        substring = s[start:end+1]\n        if is_palindrome(substring):\n            count += 1\n\n        find_palindromes(start+1, end)\n        find_palindromes(start, end-1)\n\n    for i in range(n):\n        for j in range(i, n):\n            find_palindromes(i, j)\n\n    return count\n\ndef g(s=\"level\"):\n    return s\n\nassert f(g()) == 5\n", "emb": null, "idx_generation": 460, "target_skills": [0, 0, 0, 1, 0, 0, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, count the number of palindrome substrings in it.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n\n    Return the count of palindrome substrings in s.\n    \"\"\"\n    count = 0\n    n = len(s)\n\n    # Helper function to check if a substring is a palindrome\n    def is_palindrome(substring: str) -> bool:\n        return substring == substring[::-1]\n\n    # Recursive function to find palindrome substrings\n    def find_palindromes(start: int, end: int) -> None:\n        nonlocal count\n\n        if start > end:\n            return\n\n        substring = s[start:end+1]\n        if is_palindrome(substring):\n            count += 1\n\n        find_palindromes(start+1, end)\n        find_palindromes(start, end-1)\n\n    for i in range(n):\n        for j in range(i, n):\n            find_palindromes(i, j)\n\n    return count", "solution_func": "def g(s=\"level\"):\n    return s", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], k: int) -> int:\n    \"\"\"\n    Given a grid of integers and a number k, find the number of paths from the top-left cell to the bottom-right cell\n    that have a sum equal to k. You can only move right or down.\n\n    Return the count of such paths.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    count = 0\n\n    # Recursive function to find paths\n    def find_paths(i: int, j: int, current_sum: int) -> None:\n        nonlocal count\n\n        if i == m-1 and j == n-1:\n            if current_sum + grid[i][j] == k:\n                count += 1\n            return\n\n        if i < m-1:\n            find_paths(i+1, j, current_sum + grid[i][j])\n        if j < n-1:\n            find_paths(i, j+1, current_sum + grid[i][j])\n\n    find_paths(0, 0, 0)\n    return count\n\ndef g(grid=[[1, 2, 3], [4, 5, 6], [7, 8, 9]], k=10):\n    return grid, k\n\nassert f(*g()) == 2\n", "emb": null, "idx_generation": 460, "target_skills": [1, 0, 1, 1, 0, 1, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], k: int) -> int:\n    \"\"\"\n    Given a grid of integers and a number k, find the number of paths from the top-left cell to the bottom-right cell\n    that have a sum equal to k. You can only move right or down.\n\n    Return the count of such paths.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    count = 0\n\n    # Recursive function to find paths\n    def find_paths(i: int, j: int, current_sum: int) -> None:\n        nonlocal count\n\n        if i == m-1 and j == n-1:\n            if current_sum + grid[i][j] == k:\n                count += 1\n            return\n\n        if i < m-1:\n            find_paths(i+1, j, current_sum + grid[i][j])\n        if j < n-1:\n            find_paths(i, j+1, current_sum + grid[i][j])\n\n    find_paths(0, 0, 0)\n    return count", "solution_func": "def g(grid=[[1, 2, 3], [4, 5, 6], [7, 8, 9]], k=10):\n    return grid, k", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers and a target number, return the index of the target number in the array.\n    If the target number is not found, return -1.\n\n    Example:\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output:\n    2\n\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n    return arr, target\n\nassert f(*g()) == 2\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 460, "target_skills": [0, 1, 0, 0, 0, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers and a target number, return the index of the target number in the array.\n    If the target number is not found, return -1.\n\n    Example:\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output:\n    2\n\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g():\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> str:\n    \"\"\"\n    Given a positive integer n, return its binary representation as a string.\n\n    Example:\n    Input: 5\n    Output: \"101\"\n\n    Hint: Use the built-in bin() function to convert an integer to its binary representation.\n    \"\"\"\n    return bin(n)[2:]\n\ndef g() -> int:\n    return 5\n\nassert f(g()) == \"101\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 461, "target_skills": [0, 0, 0, 0, 1, 1, 1, 1, 0, 1], "problem_func": "from typing import*\ndef f(n: int) -> str:\n    \"\"\"\n    Given a positive integer n, return its binary representation as a string.\n\n    Example:\n    Input: 5\n    Output: \"101\"\n\n    Hint: Use the built-in bin() function to convert an integer to its binary representation.\n    \"\"\"\n    return bin(n)[2:]", "solution_func": "def g() -> int:\n    return 5", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\n\n    Example:\n    Input: 3\n    Output: 6\n\n    Explanation:\n    The unique paths are: [\"RRR\", \"DRR\", \"DDR\", \"RDR\", \"RDD\", \"DDR\"]\n\n    Hint: Use dynamic programming to calculate the number of unique paths efficiently.\n    \"\"\"\n    def uniquePathsHelper(x, y, memo):\n        if x < 0 or y < 0:\n            return 0\n        if x == 0 and y == 0:\n            return 1\n        if memo[x][y] != -1:\n            return memo[x][y]\n        memo[x][y] = uniquePathsHelper(x - 1, y, memo) + uniquePathsHelper(x, y - 1, memo)\n        return memo[x][y]\n\n    memo = [[-1] * n for _ in range(n)]\n    return uniquePathsHelper(n - 1, n - 1, memo)\n\ndef g() -> int:\n    return 3\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 461, "target_skills": [0, 1, 0, 1, 1, 1, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\n\n    Example:\n    Input: 3\n    Output: 6\n\n    Explanation:\n    The unique paths are: [\"RRR\", \"DRR\", \"DDR\", \"RDR\", \"RDD\", \"DDR\"]\n\n    Hint: Use dynamic programming to calculate the number of unique paths efficiently.\n    \"\"\"\n    def uniquePathsHelper(x, y, memo):\n        if x < 0 or y < 0:\n            return 0\n        if x == 0 and y == 0:\n            return 1\n        if memo[x][y] != -1:\n            return memo[x][y]\n        memo[x][y] = uniquePathsHelper(x - 1, y, memo) + uniquePathsHelper(x, y - 1, memo)\n        return memo[x][y]\n\n    memo = [[-1] * n for _ in range(n)]\n    return uniquePathsHelper(n - 1, n - 1, memo)", "solution_func": "def g() -> int:\n    return 3", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nimport numpy as np\n\ndef f(arr: np.ndarray) -> float:\n    \"\"\"\n    Given a 2D numpy array, find the maximum sum of a subarray within the array.\n\n    Example:\n    Input:\n    arr = np.array([[1, 2, 3],\n                    [4, 5, 6],\n                    [7, 8, 9]])\n\n    Output:\n    45\n\n    Explanation:\n    The maximum sum is obtained from the subarray [[5, 6], [8, 9]], which has a sum of 45.\n\n    Hint: Use Kadane's algorithm to calculate the maximum subarray sum efficiently.\n    \"\"\"\n    rows, cols = arr.shape\n\n    max_sum = float('-inf')\n    for left in range(cols):\n        temp = np.zeros(rows)\n        for right in range(left, cols):\n            temp += arr[:, right]\n            max_sum = max(max_sum, max(temp), 0)\n\n    return max_sum\n\ndef g() -> np.ndarray:\n    return np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\nassert f(g()) == 45\n", "emb": null, "idx_generation": 461, "target_skills": [0, 0, 0, 0, 0, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nimport numpy as np\n\ndef f(arr: np.ndarray) -> float:\n    \"\"\"\n    Given a 2D numpy array, find the maximum sum of a subarray within the array.\n\n    Example:\n    Input:\n    arr = np.array([[1, 2, 3],\n                    [4, 5, 6],\n                    [7, 8, 9]])\n\n    Output:\n    45\n\n    Explanation:\n    The maximum sum is obtained from the subarray [[5, 6], [8, 9]], which has a sum of 45.\n\n    Hint: Use Kadane's algorithm to calculate the maximum subarray sum efficiently.\n    \"\"\"\n    rows, cols = arr.shape\n\n    max_sum = float('-inf')\n    for left in range(cols):\n        temp = np.zeros(rows)\n        for right in range(left, cols):\n            temp += arr[:, right]\n            max_sum = max(max_sum, max(temp), 0)\n\n    return max_sum", "solution_func": "def g() -> np.ndarray:\n    return np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of unique pairs (i, j) such that i < j and nums[i] + nums[j] is a power of 2.\n    \n    Return the count of such pairs.\n    \n    Example:\n    nums = [1, 2, 3, 4, 5]\n    \n    Output:\n    4\n    \n    Explanation:\n    The unique pairs (i, j) are (0, 2), (0, 3), (1, 3), and (2, 3).\n    The sums of these pairs are 1 + 3 = 4, 1 + 4 = 5, 2 + 4 = 6, and 3 + 4 = 7, respectively.\n    Only the pair (0, 2) has a sum that is a power of 2 (4).\n    Therefore, the count of unique pairs is 1.\n    \"\"\"\n    def is_power_of_2(num):\n        return num & (num - 1) == 0\n    \n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if is_power_of_2(nums[i] + nums[j]):\n                count += 1\n    \n    return count\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 4\n", "emb": null, "idx_generation": 461, "target_skills": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of unique pairs (i, j) such that i < j and nums[i] + nums[j] is a power of 2.\n    \n    Return the count of such pairs.\n    \n    Example:\n    nums = [1, 2, 3, 4, 5]\n    \n    Output:\n    4\n    \n    Explanation:\n    The unique pairs (i, j) are (0, 2), (0, 3), (1, 3), and (2, 3).\n    The sums of these pairs are 1 + 3 = 4, 1 + 4 = 5, 2 + 4 = 6, and 3 + 4 = 7, respectively.\n    Only the pair (0, 2) has a sum that is a power of 2 (4).\n    Therefore, the count of unique pairs is 1.\n    \"\"\"\n    def is_power_of_2(num):\n        return num & (num - 1) == 0\n    \n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if is_power_of_2(nums[i] + nums[j]):\n                count += 1\n    \n    return count", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings words, return a new list of strings containing only the words that can be formed using the letters of other words in the list.\n    \n    Example:\n    words = [\"cat\", \"dog\", \"tac\", \"god\", \"act\"]\n    \n    Output:\n    [\"cat\", \"dog\", \"act\"]\n    \n    Explanation:\n    The words \"cat\" and \"tac\" can be formed using the letters of \"act\".\n    The word \"god\" can be formed using the letters of \"dog\".\n    Therefore, the new list contains the words \"cat\", \"dog\", and \"act\".\n    \"\"\"\n    def can_form_word(word1, word2):\n        return sorted(word1) == sorted(word2)\n    \n    result = []\n    for i in range(len(words)):\n        for j in range(i + 1, len(words)):\n            if can_form_word(words[i], words[j]):\n                result.append(words[i])\n                break\n    \n    return result\n\ndef g():\n    words = [\"cat\", \"dog\", \"tac\", \"god\", \"act\"]\n    return words\n\nassert f(g()) == [\"cat\", \"dog\", \"act\"]\n", "emb": null, "idx_generation": 461, "target_skills": [1, 0, 0, 0, 1, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings words, return a new list of strings containing only the words that can be formed using the letters of other words in the list.\n    \n    Example:\n    words = [\"cat\", \"dog\", \"tac\", \"god\", \"act\"]\n    \n    Output:\n    [\"cat\", \"dog\", \"act\"]\n    \n    Explanation:\n    The words \"cat\" and \"tac\" can be formed using the letters of \"act\".\n    The word \"god\" can be formed using the letters of \"dog\".\n    Therefore, the new list contains the words \"cat\", \"dog\", and \"act\".\n    \"\"\"\n    def can_form_word(word1, word2):\n        return sorted(word1) == sorted(word2)\n    \n    result = []\n    for i in range(len(words)):\n        for j in range(i + 1, len(words)):\n            if can_form_word(words[i], words[j]):\n                result.append(words[i])\n                break\n    \n    return result", "solution_func": "def g():\n    words = [\"cat\", \"dog\", \"tac\", \"god\", \"act\"]\n    return words", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the sum of all positive integers less than n that are divisible by 3 or 5.\n    \n    Example:\n    n = 10\n    \n    Output:\n    23\n    \n    Explanation:\n    The positive integers less than 10 that are divisible by 3 or 5 are 3, 5, 6, and 9.\n    Their sum is 3 + 5 + 6 + 9 = 23.\n    \"\"\"\n    sum = 0\n    for i in range(1, n):\n        if i % 3 == 0 or i % 5 == 0:\n            sum += i\n    \n    return sum\n\ndef g():\n    n = 10\n    return n\n\nassert f(g()) == 23\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 461, "target_skills": [0, 1, 0, 0, 1, 0, 0, 0, 1, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the sum of all positive integers less than n that are divisible by 3 or 5.\n    \n    Example:\n    n = 10\n    \n    Output:\n    23\n    \n    Explanation:\n    The positive integers less than 10 that are divisible by 3 or 5 are 3, 5, 6, and 9.\n    Their sum is 3 + 5 + 6 + 9 = 23.\n    \"\"\"\n    sum = 0\n    for i in range(1, n):\n        if i % 3 == 0 or i % 5 == 0:\n            sum += i\n    \n    return sum", "solution_func": "def g():\n    n = 10\n    return n", "map_ix": [1, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum sum of a subarray where the subarray must contain at least one positive integer.\n    The function should return the maximum sum.\n\n    Args:\n    - arr: List of integers.\n\n    Returns:\n    - The maximum sum of a subarray.\n    \"\"\"\n\n    # Initialize variables\n    max_sum = 0\n    current_sum = 0\n\n    # Iterate through the array\n    for num in arr:\n        # If the current sum becomes negative, reset it to 0\n        if current_sum < 0:\n            current_sum = 0\n        # Add the current number to the current sum\n        current_sum += num\n        # Update the maximum sum if the current sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n\n    return max_sum\n\ndef g():\n    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return arr\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 461, "target_skills": [1, 1, 1, 0, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum sum of a subarray where the subarray must contain at least one positive integer.\n    The function should return the maximum sum.\n\n    Args:\n    - arr: List of integers.\n\n    Returns:\n    - The maximum sum of a subarray.\n    \"\"\"\n\n    # Initialize variables\n    max_sum = 0\n    current_sum = 0\n\n    # Iterate through the array\n    for num in arr:\n        # If the current sum becomes negative, reset it to 0\n        if current_sum < 0:\n            current_sum = 0\n        # Add the current number to the current sum\n        current_sum += num\n        # Update the maximum sum if the current sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n\n    return max_sum", "solution_func": "def g():\n    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return arr", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the nth number in the Fibonacci sequence.\n\n    Args:\n    - n: A positive integer.\n\n    Returns:\n    - The nth number in the Fibonacci sequence.\n    \"\"\"\n\n    # Define base cases\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n\n    # Initialize variables\n    fib_1 = 0\n    fib_2 = 1\n\n    # Generate Fibonacci sequence\n    for i in range(2, n+1):\n        fib = fib_1 + fib_2\n        fib_1 = fib_2\n        fib_2 = fib\n\n    return fib\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 5\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 461, "target_skills": [0, 1, 0, 1, 0, 1, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the nth number in the Fibonacci sequence.\n\n    Args:\n    - n: A positive integer.\n\n    Returns:\n    - The nth number in the Fibonacci sequence.\n    \"\"\"\n\n    # Define base cases\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n\n    # Initialize variables\n    fib_1 = 0\n    fib_2 = 1\n\n    # Generate Fibonacci sequence\n    for i in range(2, n+1):\n        fib = fib_1 + fib_2\n        fib_1 = fib_2\n        fib_2 = fib\n\n    return fib", "solution_func": "def g(n=5):\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and a target sum, find two numbers in the array that add up to the target.\n    The function should return the indices of the two numbers.\n\n    Args:\n    - nums: List of integers.\n    - target: Target sum.\n\n    Returns:\n    - List of indices of the two numbers that add up to the target.\n    \"\"\"\n\n    # Initialize a dictionary to store the complement of each number\n    complement_dict = {}\n\n    # Iterate through the array\n    for i, num in enumerate(nums):\n        # Check if the complement of the current number exists in the dictionary\n        if num in complement_dict:\n            # Return the indices of the two numbers\n            return [complement_dict[num], i]\n        else:\n            # Add the complement of the current number to the dictionary\n            complement_dict[target - num] = i\n\n    # If no solution is found, return an empty list\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 461, "target_skills": [1, 0, 0, 1, 1, 1, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and a target sum, find two numbers in the array that add up to the target.\n    The function should return the indices of the two numbers.\n\n    Args:\n    - nums: List of integers.\n    - target: Target sum.\n\n    Returns:\n    - List of indices of the two numbers that add up to the target.\n    \"\"\"\n\n    # Initialize a dictionary to store the complement of each number\n    complement_dict = {}\n\n    # Iterate through the array\n    for i, num in enumerate(nums):\n        # Check if the complement of the current number exists in the dictionary\n        if num in complement_dict:\n            # Return the indices of the two numbers\n            return [complement_dict[num], i]\n        else:\n            # Add the complement of the current number to the dictionary\n            complement_dict[target - num] = i\n\n    # If no solution is found, return an empty list\n    return []", "solution_func": "def g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the sum of all multiples of 3 or 5 below n.\n\n    Args:\n    n (int): The upper limit.\n\n    Returns:\n    int: The sum of all multiples of 3 or 5 below n.\n    \"\"\"\n    sum = 0\n    for i in range(n):\n        if i % 3 == 0 or i % 5 == 0:\n            sum += i\n    return sum\n\ndef g(n=10):\n    \"\"\"\n    Generate an integer for calculating the sum of all multiples of 3 or 5 below n.\n    \"\"\"\n    return (n,)\n\nassert f(*g()) == 23\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 461, "target_skills": [0, 0, 1, 0, 1, 1, 1, 0, 1, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the sum of all multiples of 3 or 5 below n.\n\n    Args:\n    n (int): The upper limit.\n\n    Returns:\n    int: The sum of all multiples of 3 or 5 below n.\n    \"\"\"\n    sum = 0\n    for i in range(n):\n        if i % 3 == 0 or i % 5 == 0:\n            sum += i\n    return sum", "solution_func": "def g(n=10):\n    \"\"\"\n    Generate an integer for calculating the sum of all multiples of 3 or 5 below n.\n    \"\"\"\n    return (n,)", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the kth bit of the binary representation of n.\n\n    Example:\n    n = 5\n    k = 2\n\n    Output:\n    1\n\n    Explanation:\n    The binary representation of 5 is 101. The 2nd bit is 1.\n\n    Hint: Use bitwise operators to extract the kth bit from n.\n    \"\"\"\n\n    # Shift n k-1 times to the right and perform bitwise AND with 1\n    return (n >> (k-1)) & 1\n\ndef g():\n    n = 5\n    k = 2\n    return [n, k]\n\nassert f(*g()) == 1\n\n", "emb": null, "idx_generation": 462, "target_skills": [0, 0, 0, 0, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the kth bit of the binary representation of n.\n\n    Example:\n    n = 5\n    k = 2\n\n    Output:\n    1\n\n    Explanation:\n    The binary representation of 5 is 101. The 2nd bit is 1.\n\n    Hint: Use bitwise operators to extract the kth bit from n.\n    \"\"\"\n\n    # Shift n k-1 times to the right and perform bitwise AND with 1\n    return (n >> (k-1)) & 1", "solution_func": "def g():\n    n = 5\n    k = 2\n    return [n, k]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of characters in each word within the string while still preserving whitespace and initial word order.\n\n    Example:\n    s = \"hello world\"\n\n    Output:\n    \"olleh dlrow\"\n\n    Explanation:\n    The word \"hello\" is reversed to \"olleh\" and the word \"world\" is reversed to \"dlrow\".\n\n    Hint: Split the string into words, reverse each word, and then join them back together.\n    \"\"\"\n\n    # Split the string into words by whitespace\n    words = s.split()\n\n    # Reverse each word using slicing and join them back together with whitespace\n    return ' '.join([word[::-1] for word in words])\n\ndef g():\n    s = \"hello world\"\n    return s\n\nassert f(g()) == \"olleh dlrow\"\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 462, "target_skills": [0, 1, 0, 1, 1, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of characters in each word within the string while still preserving whitespace and initial word order.\n\n    Example:\n    s = \"hello world\"\n\n    Output:\n    \"olleh dlrow\"\n\n    Explanation:\n    The word \"hello\" is reversed to \"olleh\" and the word \"world\" is reversed to \"dlrow\".\n\n    Hint: Split the string into words, reverse each word, and then join them back together.\n    \"\"\"\n\n    # Split the string into words by whitespace\n    words = s.split()\n\n    # Reverse each word using slicing and join them back together with whitespace\n    return ' '.join([word[::-1] for word in words])", "solution_func": "def g():\n    s = \"hello world\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right at any point in time.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The maximum sum of a path from the top-left corner to the bottom-right corner is 7.\n    The path is: 1 -> 3 -> 1 -> 1 -> 1\n\n    Hint: Use dynamic programming to calculate the maximum sum of a path for each cell.\n    \"\"\"\n\n    # Get the dimensions of the grid\n    m = len(grid)\n    n = len(grid[0])\n\n    # Create a 2D dynamic programming table to store the maximum sum of a path for each cell\n    dp = [[0] * n for _ in range(m)]\n\n    # Fill in the dynamic programming table\n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    # Return the maximum sum of a path from the top-left corner to the bottom-right corner\n    return dp[m-1][n-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n\n", "emb": null, "idx_generation": 462, "target_skills": [1, 1, 1, 0, 1, 0, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right at any point in time.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The maximum sum of a path from the top-left corner to the bottom-right corner is 7.\n    The path is: 1 -> 3 -> 1 -> 1 -> 1\n\n    Hint: Use dynamic programming to calculate the maximum sum of a path for each cell.\n    \"\"\"\n\n    # Get the dimensions of the grid\n    m = len(grid)\n    n = len(grid[0])\n\n    # Create a 2D dynamic programming table to store the maximum sum of a path for each cell\n    dp = [[0] * n for _ in range(m)]\n\n    # Fill in the dynamic programming table\n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    # Return the maximum sum of a path from the top-left corner to the bottom-right corner\n    return dp[m-1][n-1]", "solution_func": "def g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of distinct prime factors of n.\n\n    Args:\n    - n: An integer\n\n    Returns:\n    - The number of distinct prime factors of n.\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    factors = set()\n    for i in range(2, n+1):\n        if n % i == 0 and is_prime(i):\n            factors.add(i)\n    return len(factors)\n\ndef g(n: int = 84):\n    return n\n\nassert f(g()) == 3\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 462, "target_skills": [0, 0, 1, 1, 0, 1, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of distinct prime factors of n.\n\n    Args:\n    - n: An integer\n\n    Returns:\n    - The number of distinct prime factors of n.\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    factors = set()\n    for i in range(2, n+1):\n        if n % i == 0 and is_prime(i):\n            factors.add(i)\n    return len(factors)", "solution_func": "def g(n: int = 84):\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the sum of the squares of the even numbers.\n\n    Args:\n    - nums: A list of integers\n\n    Returns:\n    - The sum of the squares of the even numbers.\n    \"\"\"\n    return sum([num**2 for num in nums if num % 2 == 0])\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]):\n    return nums\n\nassert f(g()) == 220\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 462, "target_skills": [0, 0, 0, 0, 1, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the sum of the squares of the even numbers.\n\n    Args:\n    - nums: A list of integers\n\n    Returns:\n    - The sum of the squares of the even numbers.\n    \"\"\"\n    return sum([num**2 for num in nums if num % 2 == 0])", "solution_func": "def g(nums: List[int] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]):\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of pairs (i, j) such that i < j and nums[i] & nums[j] == 0.\n    '&' represents the bitwise AND operation.\n\n    Args:\n    - nums: A list of integers\n\n    Returns:\n    - The number of pairs (i, j) such that i < j and nums[i] & nums[j] == 0.\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] & nums[j] == 0:\n                count += 1\n    return count\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g()) == 6\n\n", "emb": null, "idx_generation": 462, "target_skills": [1, 0, 1, 0, 0, 1, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of pairs (i, j) such that i < j and nums[i] & nums[j] == 0.\n    '&' represents the bitwise AND operation.\n\n    Args:\n    - nums: A list of integers\n\n    Returns:\n    - The number of pairs (i, j) such that i < j and nums[i] & nums[j] == 0.\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] & nums[j] == 0:\n                count += 1\n    return count", "solution_func": "def g(nums: List[int] = [1, 2, 3, 4, 5]):\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list containing only the even numbers in the original list.\n    The new list should be sorted in ascending order.\n\n    Example:\n    arr = [2, 5, 1, 8, 3, 10]\n\n    Output:\n    [2, 8, 10]\n\n    Explanation:\n    The even numbers in the original list are 2, 8, and 10.\n    The new list is sorted in ascending order.\n    \"\"\"\n\n    even_numbers = [num for num in arr if num % 2 == 0]\n    even_numbers.sort()\n\n    return even_numbers\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, 5, 1, 8, 3, 10]\n\nassert f(g()) == [2, 8, 10]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 462, "target_skills": [0, 0, 0, 1, 1, 0, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list containing only the even numbers in the original list.\n    The new list should be sorted in ascending order.\n\n    Example:\n    arr = [2, 5, 1, 8, 3, 10]\n\n    Output:\n    [2, 8, 10]\n\n    Explanation:\n    The even numbers in the original list are 2, 8, and 10.\n    The new list is sorted in ascending order.\n    \"\"\"\n\n    even_numbers = [num for num in arr if num % 2 == 0]\n    even_numbers.sort()\n\n    return even_numbers", "solution_func": "def g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, 5, 1, 8, 3, 10]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given an n x m matrix, where each cell contains either 0 or 1, determine the maximum number of connected 1's in the matrix.\n    Two cells are considered connected if they are adjacent horizontally or vertically.\n\n    Example:\n    matrix = [\n        [1, 0, 1, 1],\n        [0, 1, 0, 1],\n        [1, 1, 0, 0]\n    ]\n\n    Output:\n    5\n\n    Explanation:\n    The maximum number of connected 1's in the matrix is 5, which can be achieved by selecting the following cells:\n    (0, 0), (0, 2), (0, 3), (1, 1), (1, 3)\n    \"\"\"\n\n    def dfs(row: int, col: int) -> int:\n        if row < 0 or row >= len(matrix) or col < 0 or col >= len(matrix[0]) or matrix[row][col] != 1:\n            return 0\n        \n        matrix[row][col] = 0\n        count = 1\n        \n        count += dfs(row - 1, col)\n        count += dfs(row + 1, col)\n        count += dfs(row, col - 1)\n        count += dfs(row, col + 1)\n        \n        return count\n\n    max_connected = 0\n\n    for row in range(len(matrix)):\n        for col in range(len(matrix[0])):\n            if matrix[row][col] == 1:\n                connected = dfs(row, col)\n                max_connected = max(max_connected, connected)\n\n    return max_connected\n\ndef g():\n    \"\"\"\n    Generate an n x m matrix.\n    \"\"\"\n    return [\n        [1, 0, 1, 1],\n        [0, 1, 0, 1],\n        [1, 1, 0, 0]\n    ]\n\nassert f(g()) == 5\n", "emb": null, "idx_generation": 462, "target_skills": [0, 1, 0, 0, 0, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given an n x m matrix, where each cell contains either 0 or 1, determine the maximum number of connected 1's in the matrix.\n    Two cells are considered connected if they are adjacent horizontally or vertically.\n\n    Example:\n    matrix = [\n        [1, 0, 1, 1],\n        [0, 1, 0, 1],\n        [1, 1, 0, 0]\n    ]\n\n    Output:\n    5\n\n    Explanation:\n    The maximum number of connected 1's in the matrix is 5, which can be achieved by selecting the following cells:\n    (0, 0), (0, 2), (0, 3), (1, 1), (1, 3)\n    \"\"\"\n\n    def dfs(row: int, col: int) -> int:\n        if row < 0 or row >= len(matrix) or col < 0 or col >= len(matrix[0]) or matrix[row][col] != 1:\n            return 0\n        \n        matrix[row][col] = 0\n        count = 1\n        \n        count += dfs(row - 1, col)\n        count += dfs(row + 1, col)\n        count += dfs(row, col - 1)\n        count += dfs(row, col + 1)\n        \n        return count\n\n    max_connected = 0\n\n    for row in range(len(matrix)):\n        for col in range(len(matrix[0])):\n            if matrix[row][col] == 1:\n                connected = dfs(row, col)\n                max_connected = max(max_connected, connected)\n\n    return max_connected", "solution_func": "def g():\n    \"\"\"\n    Generate an n x m matrix.\n    \"\"\"\n    return [\n        [1, 0, 1, 1],\n        [0, 1, 0, 1],\n        [1, 1, 0, 0]\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where all the negative numbers are moved to the front of the list.\n    The new list should maintain the relative order of the positive numbers and negative numbers.\n\n    Example:\n    arr = [4, -2, 7, -5, -1, 3, -6]\n\n    Output:\n    [-2, -5, -1, -6, 4, 7, 3]\n\n    Explanation:\n    The negative numbers in the original list are -2, -5, -1, and -6.\n    The new list has the negative numbers moved to the front and the positive numbers at the end.\n    The relative order of the numbers is maintained.\n    \"\"\"\n\n    negative_numbers = [num for num in arr if num < 0]\n    positive_numbers = [num for num in arr if num >= 0]\n\n    return negative_numbers + positive_numbers\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [4, -2, 7, -5, -1, 3, -6]\n\nassert f(g()) == [-2, -5, -1, -6, 4, 7, 3]\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 462, "target_skills": [1, 0, 1, 0, 0, 0, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where all the negative numbers are moved to the front of the list.\n    The new list should maintain the relative order of the positive numbers and negative numbers.\n\n    Example:\n    arr = [4, -2, 7, -5, -1, 3, -6]\n\n    Output:\n    [-2, -5, -1, -6, 4, 7, 3]\n\n    Explanation:\n    The negative numbers in the original list are -2, -5, -1, and -6.\n    The new list has the negative numbers moved to the front and the positive numbers at the end.\n    The relative order of the numbers is maintained.\n    \"\"\"\n\n    negative_numbers = [num for num in arr if num < 0]\n    positive_numbers = [num for num in arr if num >= 0]\n\n    return negative_numbers + positive_numbers", "solution_func": "def g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [4, -2, 7, -5, -1, 3, -6]", "map_ix": [1, 1, 0, 1, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "import math\nfrom typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the sum of the elements in the diagonal from top-left to bottom-right.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    15\n\n    Explanation:\n    The diagonal elements are 1, 5, and 9. Their sum is 15.\n\n    Hint: Use the mathematical property that the row and column indices of the diagonal elements are the same (i.e., matrix[i][i]).\n    \"\"\"\n\n    diagonal_sum = 0\n\n    for i in range(len(matrix)):\n        diagonal_sum += matrix[i][i]\n\n    return diagonal_sum\n\ndef g(matrix: List[List[int]] = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix\n\nassert f(g()) == 15\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 462, "target_skills": [0, 0, 1, 1, 0, 0, 1, 0, 0, 0], "problem_func": "import math\nfrom typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the sum of the elements in the diagonal from top-left to bottom-right.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    15\n\n    Explanation:\n    The diagonal elements are 1, 5, and 9. Their sum is 15.\n\n    Hint: Use the mathematical property that the row and column indices of the diagonal elements are the same (i.e., matrix[i][i]).\n    \"\"\"\n\n    diagonal_sum = 0\n\n    for i in range(len(matrix)):\n        diagonal_sum += matrix[i][i]\n\n    return diagonal_sum", "solution_func": "def g(matrix: List[List[int]] = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(grid: List[List[str]]) -> bool:\n    \"\"\"\n    Given a 2D grid of characters, determine if it forms a valid word search.\n\n    A word search puzzle is a grid of letters with words hidden in different directions (horizontal, vertical, diagonal).\n    To solve the puzzle, the words must be found and can be read in any direction (left to right, right to left, top to bottom, bottom to top, diagonal).\n\n    Parameters:\n    grid (List[List[str]]): The 2D grid of characters representing the word search puzzle.\n\n    Returns:\n    bool: True if the grid forms a valid word search, False otherwise.\n    \"\"\"\n    def dfs(i, j, word):\n        if not word:\n            return True\n\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != word[0]:\n            return False\n\n        temp = grid[i][j]\n        grid[i][j] = \"#\"\n\n        res = dfs(i + 1, j, word[1:]) or dfs(i - 1, j, word[1:]) or dfs(i, j + 1, word[1:]) or dfs(i, j - 1, word[1:])\n\n        grid[i][j] = temp\n\n        return res\n\n    if not grid:\n        return False\n\n    m, n = len(grid), len(grid[0])\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, \"WORD\"):\n                return True\n\n    return False\n\n\ndef g(grid=[\n    [\"W\",\"R\",\"D\",\"R\"],\n    [\"O\",\"O\",\"O\",\"O\"],\n    [\"R\",\"D\",\"O\",\"O\"]\n]) -> List[List[str]]:\n    return grid\n\nassert f(g()) == True\n\n", "emb": [1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 463, "target_skills": [0, 0, 0, 0, 0, 1, 1, 0, 0, 0], "problem_func": "from typing import*\ndef f(grid: List[List[str]]) -> bool:\n    \"\"\"\n    Given a 2D grid of characters, determine if it forms a valid word search.\n\n    A word search puzzle is a grid of letters with words hidden in different directions (horizontal, vertical, diagonal).\n    To solve the puzzle, the words must be found and can be read in any direction (left to right, right to left, top to bottom, bottom to top, diagonal).\n\n    Parameters:\n    grid (List[List[str]]): The 2D grid of characters representing the word search puzzle.\n\n    Returns:\n    bool: True if the grid forms a valid word search, False otherwise.\n    \"\"\"\n    def dfs(i, j, word):\n        if not word:\n            return True\n\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != word[0]:\n            return False\n\n        temp = grid[i][j]\n        grid[i][j] = \"#\"\n\n        res = dfs(i + 1, j, word[1:]) or dfs(i - 1, j, word[1:]) or dfs(i, j + 1, word[1:]) or dfs(i, j - 1, word[1:])\n\n        grid[i][j] = temp\n\n        return res\n\n    if not grid:\n        return False\n\n    m, n = len(grid), len(grid[0])\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, \"WORD\"):\n                return True\n\n    return False", "solution_func": "def g(grid=[\n    [\"W\",\"R\",\"D\",\"R\"],\n    [\"O\",\"O\",\"O\",\"O\"],\n    [\"R\",\"D\",\"O\",\"O\"]\n]) -> List[List[str]]:\n    return grid", "map_ix": [1, 1, 1, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the maximum sum of a hourglass in the grid.\n\n    An hourglass in the grid is defined as follows:\n    - There are 7 cells in total, forming the shape of an hourglass.\n    - The cells in the hourglass must be adjacent to each other, either horizontally or vertically.\n\n    Parameters:\n    grid (List[List[int]]): The 2D grid of integers.\n\n    Returns:\n    int: The maximum sum of a hourglass in the grid.\n    \"\"\"\n\n    if not grid or len(grid) < 3 or len(grid[0]) < 3:\n        return 0\n\n    max_sum = float('-inf')\n\n    for i in range(len(grid) - 2):\n        for j in range(len(grid[0]) - 2):\n            hourglass_sum = grid[i][j] + grid[i][j + 1] + grid[i][j + 2] + grid[i + 1][j + 1] + grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2]\n            max_sum = max(max_sum, hourglass_sum)\n\n    return max_sum\n\n\ndef g(grid=[\n    [1, 1, 1, 0, 0],\n    [0, 1, 0, 0, 0],\n    [1, 1, 1, 0, 0],\n    [0, 0, 2, 4, 4],\n    [0, 0, 0, 2, 0],\n    [0, 0, 1, 2, 4]\n]) -> List[List[int]]:\n    return grid\n\nassert f(g()) == 19\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], "idx_generation": 463, "target_skills": [1, 0, 0, 1, 0, 0, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the maximum sum of a hourglass in the grid.\n\n    An hourglass in the grid is defined as follows:\n    - There are 7 cells in total, forming the shape of an hourglass.\n    - The cells in the hourglass must be adjacent to each other, either horizontally or vertically.\n\n    Parameters:\n    grid (List[List[int]]): The 2D grid of integers.\n\n    Returns:\n    int: The maximum sum of a hourglass in the grid.\n    \"\"\"\n\n    if not grid or len(grid) < 3 or len(grid[0]) < 3:\n        return 0\n\n    max_sum = float('-inf')\n\n    for i in range(len(grid) - 2):\n        for j in range(len(grid[0]) - 2):\n            hourglass_sum = grid[i][j] + grid[i][j + 1] + grid[i][j + 2] + grid[i + 1][j + 1] + grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2]\n            max_sum = max(max_sum, hourglass_sum)\n\n    return max_sum", "solution_func": "def g(grid=[\n    [1, 1, 1, 0, 0],\n    [0, 1, 0, 0, 0],\n    [1, 1, 1, 0, 0],\n    [0, 0, 2, 4, 4],\n    [0, 0, 0, 2, 0],\n    [0, 0, 1, 2, 4]\n]) -> List[List[int]]:\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of words in the string.\n\n    A word is defined as a sequence of non-space characters separated by a single space.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: The string with words reversed.\n    \"\"\"\n\n    words = s.split()\n    reversed_words = words[::-1]\n\n    return \" \".join(reversed_words)\n\n\ndef g(s=\"Hello World!\") -> str:\n    return s\n\nassert f(g()) == \"World! Hello\"\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 463, "target_skills": [1, 0, 0, 1, 0, 0, 1, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of words in the string.\n\n    A word is defined as a sequence of non-space characters separated by a single space.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: The string with words reversed.\n    \"\"\"\n\n    words = s.split()\n    reversed_words = words[::-1]\n\n    return \" \".join(reversed_words)", "solution_func": "def g(s=\"Hello World!\") -> str:\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers 'arr' and a target integer 'target', find two numbers in the list that sum up to the target.\n    Return the indices of the two numbers in a list.\n\n    Example:\n    arr = [2, 3, 5, 7, 9]\n    target = 10\n\n    Output:\n    [1, 3] (2 + 7 = 10, and their indices in the list are 1 and 3)\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g(arr=[2, 3, 5, 7, 9], target=10):\n    return arr, target\n\nassert f(*g()) == [1, 3]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0], "idx_generation": 463, "target_skills": [0, 1, 0, 1, 0, 0, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers 'arr' and a target integer 'target', find two numbers in the list that sum up to the target.\n    Return the indices of the two numbers in a list.\n\n    Example:\n    arr = [2, 3, 5, 7, 9]\n    target = 10\n\n    Output:\n    [1, 3] (2 + 7 = 10, and their indices in the list are 1 and 3)\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g(arr=[2, 3, 5, 7, 9], target=10):\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum value that can be obtained by summing the elements along a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    1 + 4 + 7 + 8 + 9 = 29\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = matrix[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix\n\nassert f(g()) == 29\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 463, "target_skills": [0, 0, 1, 0, 1, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum value that can be obtained by summing the elements along a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    1 + 4 + 7 + 8 + 9 = 29\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = matrix[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    return dp[rows-1][cols-1]", "solution_func": "def g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers 'arr', find a subarray with the maximum sum and return the starting and ending indices of the subarray.\n\n    Example:\n    arr = [1, -2, 3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    [2, 5] (the subarray [3, 4, -1, 2] has the maximum sum of 8, and its starting and ending indices are 2 and 5)\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n    start = 0\n    end = 0\n    subarray_start = 0\n\n    for i, num in enumerate(arr):\n        curr_sum += num\n\n        if curr_sum > max_sum:\n            max_sum = curr_sum\n            start = subarray_start\n            end = i\n\n        if curr_sum < 0:\n            curr_sum = 0\n            subarray_start = i + 1\n\n    return [start, end]\n\ndef g(arr=[1, -2, 3, 4, -1, 2, 1, -5, 4]):\n    return arr\n\nassert f(g()) == [2, 5]\n\n", "emb": null, "idx_generation": 463, "target_skills": [1, 1, 1, 0, 1, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers 'arr', find a subarray with the maximum sum and return the starting and ending indices of the subarray.\n\n    Example:\n    arr = [1, -2, 3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    [2, 5] (the subarray [3, 4, -1, 2] has the maximum sum of 8, and its starting and ending indices are 2 and 5)\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n    start = 0\n    end = 0\n    subarray_start = 0\n\n    for i, num in enumerate(arr):\n        curr_sum += num\n\n        if curr_sum > max_sum:\n            max_sum = curr_sum\n            start = subarray_start\n            end = i\n\n        if curr_sum < 0:\n            curr_sum = 0\n            subarray_start = i + 1\n\n    return [start, end]", "solution_func": "def g(arr=[1, -2, 3, 4, -1, 2, 1, -5, 4]):\n    return arr", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of distinct integers and a target value, return the indices of two numbers\n    such that they add up to the target. You may assume that each input would have exactly one solution,\n    and you may not use the same element twice.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    nums[0] + nums[1] = 2 + 7 = 9, so the indices are [0, 1].\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        \n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of distinct integers.\n    \"\"\"\n    return [1, 3, 5, 7, 9, 11]\n\nassert f(g(), 12) == [1, 5]\n", "emb": null, "idx_generation": 463, "target_skills": [0, 1, 0, 1, 0, 1, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of distinct integers and a target value, return the indices of two numbers\n    such that they add up to the target. You may assume that each input would have exactly one solution,\n    and you may not use the same element twice.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    nums[0] + nums[1] = 2 + 7 = 9, so the indices are [0, 1].\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        \n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of distinct integers.\n    \"\"\"\n    return [1, 3, 5, 7, 9, 11]", "map_ix": null}, {"fitness": 1.0, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> float:\n    \"\"\"\n    Given a list of points in 2D space, find the minimum distance between any two points.\n\n    Example:\n    points = [[1, 1], [3, 3], [2, 2], [4, 4]]\n\n    Output:\n    1.4142135623730951\n\n    Explanation:\n    The minimum distance is the square root of 2, which is approximately 1.4142135623730951.\n    \"\"\"\n    min_distance = float('inf')\n    \n    for i in range(len(points)):\n        for j in range(i+1, len(points)):\n            distance = ((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) ** 0.5\n            min_distance = min(min_distance, distance)\n    \n    return min_distance\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a list of random points in 2D space.\n    \"\"\"\n    return [[1, 1], [3, 3], [2, 2], [4, 4], [5, 5]]\n\nassert f(g()) == 1.4142135623730951\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 463, "target_skills": [1, 1, 1, 1, 0, 0, 1, 1, 0, 1], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> float:\n    \"\"\"\n    Given a list of points in 2D space, find the minimum distance between any two points.\n\n    Example:\n    points = [[1, 1], [3, 3], [2, 2], [4, 4]]\n\n    Output:\n    1.4142135623730951\n\n    Explanation:\n    The minimum distance is the square root of 2, which is approximately 1.4142135623730951.\n    \"\"\"\n    min_distance = float('inf')\n    \n    for i in range(len(points)):\n        for j in range(i+1, len(points)):\n            distance = ((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) ** 0.5\n            min_distance = min(min_distance, distance)\n    \n    return min_distance", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a list of random points in 2D space.\n    \"\"\"\n    return [[1, 1], [3, 3], [2, 2], [4, 4], [5, 5]]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a subgrid where the subgrid\n    is formed by selecting any rectangular region of the grid.\n\n    Example:\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n    Output:\n    45\n\n    Explanation:\n    The maximum sum is achieved by selecting the entire grid, which sums up to 45.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    max_sum = float('-inf')\n    \n    for i in range(rows):\n        for j in range(cols):\n            for k in range(i, rows):\n                for l in range(j, cols):\n                    subgrid_sum = 0\n                    for m in range(i, k+1):\n                        for n in range(j, l+1):\n                            subgrid_sum += grid[m][n]\n                    \n                    max_sum = max(max_sum, subgrid_sum)\n    \n    return max_sum\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a random grid of integers.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]\n\nassert f(g()) == 45\n", "emb": null, "idx_generation": 463, "target_skills": [1, 0, 0, 1, 0, 1, 1, 1, 0, 0], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a subgrid where the subgrid\n    is formed by selecting any rectangular region of the grid.\n\n    Example:\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n    Output:\n    45\n\n    Explanation:\n    The maximum sum is achieved by selecting the entire grid, which sums up to 45.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    max_sum = float('-inf')\n    \n    for i in range(rows):\n        for j in range(cols):\n            for k in range(i, rows):\n                for l in range(j, cols):\n                    subgrid_sum = 0\n                    for m in range(i, k+1):\n                        for n in range(j, l+1):\n                            subgrid_sum += grid[m][n]\n                    \n                    max_sum = max(max_sum, subgrid_sum)\n    \n    return max_sum", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a random grid of integers.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of trailing zeros in n!.\n\n    Example:\n    n = 5\n\n    Output:\n    1\n\n    Explanation:\n    5! = 120, which has 1 trailing zero.\n    \"\"\"\n    count = 0\n    while n >= 5:\n        n = n // 5\n        count += n\n    return count\n\ndef g() -> int:\n    return 5\n\nassert f(g()) == 1\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 463, "target_skills": [0, 1, 0, 0, 1, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of trailing zeros in n!.\n\n    Example:\n    n = 5\n\n    Output:\n    1\n\n    Explanation:\n    5! = 120, which has 1 trailing zero.\n    \"\"\"\n    count = 0\n    while n >= 5:\n        n = n // 5\n        count += n\n    return count", "solution_func": "def g() -> int:\n    return 5", "map_ix": [1, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, check if it is a palindrome.\n\n    Example:\n    s = \"racecar\"\n\n    Output:\n    True\n    \"\"\"\n    # Remove all non-alphanumeric characters from the string\n    s = ''.join(c.lower() for c in s if c.isalnum())\n\n    # Check if the string is equal to its reverse\n    return s == s[::-1]\n\ndef g():\n    return \"racecar\"\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 464, "target_skills": [0, 0, 0, 1, 0, 1, 0, 0, 0, 1], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, check if it is a palindrome.\n\n    Example:\n    s = \"racecar\"\n\n    Output:\n    True\n    \"\"\"\n    # Remove all non-alphanumeric characters from the string\n    s = ''.join(c.lower() for c in s if c.isalnum())\n\n    # Check if the string is equal to its reverse\n    return s == s[::-1]", "solution_func": "def g():\n    return \"racecar\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "import math\nfrom typing import*\nfrom math import factorial\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the factorial of n.\n\n    Example:\n    n = 5\n\n    Output:\n    120\n    \"\"\"\n    return factorial(n)\n\ndef g():\n    return 5\n\nassert f(g()) == 120\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 464, "target_skills": [1, 0, 1, 1, 0, 1, 1, 1, 0, 1], "problem_func": "import math\nfrom typing import*\nfrom math import factorial\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the factorial of n.\n\n    Example:\n    n = 5\n\n    Output:\n    120\n    \"\"\"\n    return factorial(n)", "solution_func": "def g():\n    return 5", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, target: str) -> int:\n    \"\"\"\n    Given a string s and a target string, count the number of occurrences of the target string in s.\n\n    Example:\n    s = \"abababa\"\n    target = \"aba\"\n\n    Output:\n    3\n    \"\"\"\n    count = 0\n    start = 0\n\n    while True:\n        index = s.find(target, start)\n        if index == -1:\n            break\n        count += 1\n        start = index + 1\n\n    return count\n\ndef g():\n    return \"abababa\", \"aba\"\n\nassert f(*g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 464, "target_skills": [1, 1, 0, 0, 1, 0, 1, 0, 1, 1], "problem_func": "from typing import*\ndef f(s: str, target: str) -> int:\n    \"\"\"\n    Given a string s and a target string, count the number of occurrences of the target string in s.\n\n    Example:\n    s = \"abababa\"\n    target = \"aba\"\n\n    Output:\n    3\n    \"\"\"\n    count = 0\n    start = 0\n\n    while True:\n        index = s.find(target, start)\n        if index == -1:\n            break\n        count += 1\n        start = index + 1\n\n    return count", "solution_func": "def g():\n    return \"abababa\", \"aba\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value, determine if there exists a pair of elements in the array whose sum is equal to the target value.\n    \n    Args:\n    - arr: A list of integers in ascending order.\n    - target: The target sum value.\n    \n    Returns:\n    - A boolean value indicating whether there exists a pair of elements in the array whose sum is equal to the target value.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g() -> Tuple[List[int], int]:\n    arr = [1, 2, 3, 4, 5, 6]\n    target = 8\n    return arr, target\n\nassert f(*g()) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 464, "target_skills": [0, 0, 0, 1, 1, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value, determine if there exists a pair of elements in the array whose sum is equal to the target value.\n    \n    Args:\n    - arr: A list of integers in ascending order.\n    - target: The target sum value.\n    \n    Returns:\n    - A boolean value indicating whether there exists a pair of elements in the array whose sum is equal to the target value.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False", "solution_func": "def g() -> Tuple[List[int], int]:\n    arr = [1, 2, 3, 4, 5, 6]\n    target = 8\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> str:\n    \"\"\"\n    Convert a non-negative integer into its English words representation.\n\n    Args:\n    - n: A non-negative integer.\n\n    Returns:\n    - The English words representation of the given integer.\n\n    Example:\n    n = 12345\n\n    Output:\n    \"twelve thousand three hundred forty five\"\n    \"\"\"\n    def convert_less_than_20(num: int) -> str:\n        less_than_20 = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n        return less_than_20[num]\n\n    def convert_tens(num: int) -> str:\n        tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n        return tens[num]\n\n    def convert_hundreds(num: int) -> str:\n        return convert_less_than_20(num) + \" hundred\"\n\n    def convert_thousands(num: int) -> str:\n        return convert_less_than_20(num) + \" thousand\"\n\n    if n == 0:\n        return \"zero\"\n\n    result = \"\"\n    if n >= 1000:\n        result += convert_thousands(n // 1000) + \" \"\n        n %= 1000\n    if n >= 100:\n        result += convert_hundreds(n // 100) + \" \"\n        n %= 100\n    if n >= 20:\n        result += convert_tens(n // 10) + \" \"\n        n %= 10\n    if n > 0:\n        result += convert_less_than_20(n) + \" \"\n\n    return result.strip()\n\ndef g() -> int:\n    return 12345\n\nassert f(g()) == \"twelve thousand three hundred forty five\"\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 464, "target_skills": [1, 0, 0, 1, 1, 1, 0, 0, 0, 1], "problem_func": "from typing import*\ndef f(n: int) -> str:\n    \"\"\"\n    Convert a non-negative integer into its English words representation.\n\n    Args:\n    - n: A non-negative integer.\n\n    Returns:\n    - The English words representation of the given integer.\n\n    Example:\n    n = 12345\n\n    Output:\n    \"twelve thousand three hundred forty five\"\n    \"\"\"\n    def convert_less_than_20(num: int) -> str:\n        less_than_20 = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n        return less_than_20[num]\n\n    def convert_tens(num: int) -> str:\n        tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n        return tens[num]\n\n    def convert_hundreds(num: int) -> str:\n        return convert_less_than_20(num) + \" hundred\"\n\n    def convert_thousands(num: int) -> str:\n        return convert_less_than_20(num) + \" thousand\"\n\n    if n == 0:\n        return \"zero\"\n\n    result = \"\"\n    if n >= 1000:\n        result += convert_thousands(n // 1000) + \" \"\n        n %= 1000\n    if n >= 100:\n        result += convert_hundreds(n // 100) + \" \"\n        n %= 100\n    if n >= 20:\n        result += convert_tens(n // 10) + \" \"\n        n %= 10\n    if n > 0:\n        result += convert_less_than_20(n) + \" \"\n\n    return result.strip()", "solution_func": "def g() -> int:\n    return 12345", "map_ix": [0, 1, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the maximum sum you can obtain by starting at the top-left corner and ending at the bottom-right corner.\n    You can only move down or right.\n\n    Args:\n    - grid: A 2D grid of integers.\n\n    Returns:\n    - The maximum sum you can obtain by starting at the top-left corner and ending at the bottom-right corner.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    return grid\n\nassert f(g()) == 12\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 464, "target_skills": [0, 1, 1, 0, 1, 0, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the maximum sum you can obtain by starting at the top-left corner and ending at the bottom-right corner.\n    You can only move down or right.\n\n    Args:\n    - grid: A 2D grid of integers.\n\n    Returns:\n    - The maximum sum you can obtain by starting at the top-left corner and ending at the bottom-right corner.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g() -> List[List[int]]:\n    grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    return grid", "map_ix": [0, 0, 0, 1, 0, 0, 1, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray in the list.\n\n    Example:\n    arr = [1, -2, 3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    10\n\n    Explanation:\n    The maximum sum of a subarray is [3, 4, -1, 2, 1], which gives a sum of 10.\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in arr:\n        curr_sum = max(curr_sum + num, num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate the input for the function f.\n    \"\"\"\n    return [1, -2, 3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 10\n", "emb": null, "idx_generation": 464, "target_skills": [0, 1, 0, 0, 1, 1, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray in the list.\n\n    Example:\n    arr = [1, -2, 3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    10\n\n    Explanation:\n    The maximum sum of a subarray is [3, 4, -1, 2, 1], which gives a sum of 10.\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in arr:\n        curr_sum = max(curr_sum + num, num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate the input for the function f.\n    \"\"\"\n    return [1, -2, 3, 4, -1, 2, 1, -5, 4]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of ways to arrange n pairs of parentheses such that they are balanced.\n\n    Example:\n    n = 3\n\n    Output:\n    5\n\n    Explanation:\n    The five ways to arrange 3 pairs of parentheses are: ((())), (()()), (())(), ()(()), ()()().\n    \"\"\"\n\n    def backtrack(s, left, right):\n        if left == 0 and right == 0:\n            result.append(s)\n            return\n        if left > 0:\n            backtrack(s + '(', left - 1, right + 1)\n        if right > 0:\n            backtrack(s + ')', left, right - 1)\n\n    result = []\n    backtrack('', n, 0)\n    return len(result)\n\ndef g() -> int:\n    \"\"\"\n    Generate the input for the function f.\n    \"\"\"\n    return 3\n\nassert f(g()) == 5\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 464, "target_skills": [0, 1, 0, 1, 1, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of ways to arrange n pairs of parentheses such that they are balanced.\n\n    Example:\n    n = 3\n\n    Output:\n    5\n\n    Explanation:\n    The five ways to arrange 3 pairs of parentheses are: ((())), (()()), (())(), ()(()), ()()().\n    \"\"\"\n\n    def backtrack(s, left, right):\n        if left == 0 and right == 0:\n            result.append(s)\n            return\n        if left > 0:\n            backtrack(s + '(', left - 1, right + 1)\n        if right > 0:\n            backtrack(s + ')', left, right - 1)\n\n    result = []\n    backtrack('', n, 0)\n    return len(result)", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate the input for the function f.\n    \"\"\"\n    return 3", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return the elements of the matrix in spiral order.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    [1, 2, 3, 6, 9, 8, 7, 4, 5]\n    \"\"\"\n\n    if not matrix or not matrix[0]:\n        return []\n\n    rows, cols = len(matrix), len(matrix[0])\n    top, bottom, left, right = 0, rows - 1, 0, cols - 1\n    \n    result = []\n\n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate the input for the function f.\n    \"\"\"\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0], "idx_generation": 464, "target_skills": [0, 1, 0, 0, 0, 1, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return the elements of the matrix in spiral order.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    [1, 2, 3, 6, 9, 8, 7, 4, 5]\n    \"\"\"\n\n    if not matrix or not matrix[0]:\n        return []\n\n    rows, cols = len(matrix), len(matrix[0])\n    top, bottom, left, right = 0, rows - 1, 0, cols - 1\n    \n    result = []\n\n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate the input for the function f.\n    \"\"\"\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]", "map_ix": [1, 0, 1, 0, 0, 1, 1, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if n is a power of two.\n    \"\"\"\n    if n <= 0:\n        return False\n    while n % 2 == 0:\n        n //= 2\n    return n == 1\n\ndef g() -> int:\n    \"\"\"\n    Generate a power of two.\n    \"\"\"\n    return 16\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 464, "target_skills": [0, 0, 1, 0, 1, 1, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if n is a power of two.\n    \"\"\"\n    if n <= 0:\n        return False\n    while n % 2 == 0:\n        n //= 2\n    return n == 1", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a power of two.\n    \"\"\"\n    return 16", "map_ix": [0, 0, 0, 1, 1, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the nth Fibonacci number.\n\n    Example:\n    n = 6\n\n    Output:\n    8\n\n    Explanation:\n    The Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, ...\n    The 6th Fibonacci number is 8.\n\n    Hint: Use recursion to calculate the Fibonacci sequence.\n    \"\"\"\n\n    def fibonacci(n):\n        if n <= 1:\n            return n\n        else:\n            return fibonacci(n-1) + fibonacci(n-2)\n\n    return fibonacci(n)\n\ndef g():\n    n = 6\n    return n\n\nassert f(g()) == 8\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 465, "target_skills": [0, 1, 0, 0, 0, 0, 1, 1, 1, 1], "problem_func": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the nth Fibonacci number.\n\n    Example:\n    n = 6\n\n    Output:\n    8\n\n    Explanation:\n    The Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, ...\n    The 6th Fibonacci number is 8.\n\n    Hint: Use recursion to calculate the Fibonacci sequence.\n    \"\"\"\n\n    def fibonacci(n):\n        if n <= 1:\n            return n\n        else:\n            return fibonacci(n-1) + fibonacci(n-2)\n\n    return fibonacci(n)", "solution_func": "def g():\n    n = 6\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a subarray within the matrix.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    45\n\n    Explanation:\n    The maximum sum of a subarray within the matrix is 45, which is obtained by selecting all the elements in the matrix.\n\n    Hint: Use dynamic programming to calculate the maximum sum of subarrays.\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    max_sum = float('-inf')\n\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = matrix[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + matrix[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + matrix[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n            max_sum = max(max_sum, dp[i][j])\n\n    return max_sum\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == 45\n", "emb": null, "idx_generation": 465, "target_skills": [0, 1, 0, 1, 1, 1, 1, 0, 0, 1], "problem_func": "from typing import*\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a subarray within the matrix.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    45\n\n    Explanation:\n    The maximum sum of a subarray within the matrix is 45, which is obtained by selecting all the elements in the matrix.\n\n    Hint: Use dynamic programming to calculate the maximum sum of subarrays.\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    max_sum = float('-inf')\n\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = matrix[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + matrix[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + matrix[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n            max_sum = max(max_sum, dp[i][j])\n\n    return max_sum", "solution_func": "def g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(grid: List[List[int]], k: int) -> int:\n    \"\"\"\n    Given a grid of integers and an integer k, find the maximum sum of a subgrid of size k x k within the grid.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    k = 2\n\n    Output:\n    28\n\n    Explanation:\n    The maximum sum of a 2x2 subgrid within the grid is 28, which is obtained by selecting the subgrid [5, 6, 8, 9].\n\n    Hint: Use dynamic programming to calculate the maximum sum of subgrids.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    max_sum = float('-inf')\n\n    for i in range(rows - k + 1):\n        for j in range(cols - k + 1):\n            subgrid_sum = 0\n            for x in range(i, i + k):\n                for y in range(j, j + k):\n                    subgrid_sum += grid[x][y]\n            max_sum = max(max_sum, subgrid_sum)\n\n    return max_sum\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    k = 2\n    return (grid, k)\n\nassert f(*g()) == 28\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 465, "target_skills": [0, 1, 0, 0, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\n\ndef f(grid: List[List[int]], k: int) -> int:\n    \"\"\"\n    Given a grid of integers and an integer k, find the maximum sum of a subgrid of size k x k within the grid.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    k = 2\n\n    Output:\n    28\n\n    Explanation:\n    The maximum sum of a 2x2 subgrid within the grid is 28, which is obtained by selecting the subgrid [5, 6, 8, 9].\n\n    Hint: Use dynamic programming to calculate the maximum sum of subgrids.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    max_sum = float('-inf')\n\n    for i in range(rows - k + 1):\n        for j in range(cols - k + 1):\n            subgrid_sum = 0\n            for x in range(i, i + k):\n                for y in range(j, j + k):\n                    subgrid_sum += grid[x][y]\n            max_sum = max(max_sum, subgrid_sum)\n\n    return max_sum", "solution_func": "def g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    k = 2\n    return (grid, k)", "map_ix": [0, 0, 0, 1, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of ways to arrange n identical balls into k distinct boxes,\n    where each box can contain any number of balls (including zero).\n\n    Example:\n    n = 4\n\n    Output:\n    15\n\n    Explanation:\n    The number of ways to arrange 4 identical balls into distinct boxes is 15:\n    - 4 balls in 1 box\n    - 3 balls in 1 box, 1 ball in another box\n    - 2 balls in 1 box, 2 balls in another box\n    - 2 balls in 2 boxes, 1 ball in another box\n    - 1 ball in 1 box, 3 balls in another box\n    - 1 ball in 2 boxes, 2 balls in another box\n    - 1 ball in 3 boxes, 1 ball in another box\n    - 0 balls in 1 box, 4 balls in another box\n    - 0 balls in 2 boxes, 3 balls in another box\n    - 0 balls in 3 boxes, 2 balls in another box\n    - 0 balls in 4 boxes, 1 ball in another box\n    - 0 balls in 5 boxes\n    - 0 balls in 6 boxes\n    - 0 balls in 7 boxes\n    - 0 balls in 8 boxes\n\n    Hint: Use combinatorial analysis to calculate the number of ways to arrange the balls.\n    \"\"\"\n\n    # Calculate the number of ways to arrange n identical balls into k distinct boxes\n    return pow(2, n) - 1\n\ndef g(n=4):\n    return n\n\nassert f(g()) == 15\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 465, "target_skills": [1, 1, 0, 0, 0, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of ways to arrange n identical balls into k distinct boxes,\n    where each box can contain any number of balls (including zero).\n\n    Example:\n    n = 4\n\n    Output:\n    15\n\n    Explanation:\n    The number of ways to arrange 4 identical balls into distinct boxes is 15:\n    - 4 balls in 1 box\n    - 3 balls in 1 box, 1 ball in another box\n    - 2 balls in 1 box, 2 balls in another box\n    - 2 balls in 2 boxes, 1 ball in another box\n    - 1 ball in 1 box, 3 balls in another box\n    - 1 ball in 2 boxes, 2 balls in another box\n    - 1 ball in 3 boxes, 1 ball in another box\n    - 0 balls in 1 box, 4 balls in another box\n    - 0 balls in 2 boxes, 3 balls in another box\n    - 0 balls in 3 boxes, 2 balls in another box\n    - 0 balls in 4 boxes, 1 ball in another box\n    - 0 balls in 5 boxes\n    - 0 balls in 6 boxes\n    - 0 balls in 7 boxes\n    - 0 balls in 8 boxes\n\n    Hint: Use combinatorial analysis to calculate the number of ways to arrange the balls.\n    \"\"\"\n\n    # Calculate the number of ways to arrange n identical balls into k distinct boxes\n    return pow(2, n) - 1", "solution_func": "def g(n=4):\n    return n", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the number of palindromic substrings in s.\n\n    Example:\n    s = \"abc\"\n\n    Output:\n    3\n\n    Explanation:\n    The palindromic substrings in s are \"a\", \"b\", and \"c\".\n\n    Hint: Use string manipulation techniques to check if the substrings are palindromes.\n    \"\"\"\n\n    count = 0\n\n    # Check each character in the string as the center of a palindrome\n    for i in range(len(s)):\n        count += expand_from_center(s, i, i)  # Odd length palindromes\n        count += expand_from_center(s, i, i + 1)  # Even length palindromes\n\n    return count\n\ndef expand_from_center(s: str, left: int, right: int) -> int:\n    \"\"\"\n    Helper function to expand the palindrome from the center outwards.\n    \"\"\"\n\n    count = 0\n\n    # Expand the palindrome until the characters at the left and right pointers are no longer equal\n    while left >= 0 and right < len(s) and s[left] == s[right]:\n        count += 1\n        left -= 1\n        right += 1\n\n    return count\n\ndef g(s=\"abc\"):\n    return s\n\nassert f(g()) == 3\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 465, "target_skills": [1, 0, 0, 0, 1, 1, 1, 1, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the number of palindromic substrings in s.\n\n    Example:\n    s = \"abc\"\n\n    Output:\n    3\n\n    Explanation:\n    The palindromic substrings in s are \"a\", \"b\", and \"c\".\n\n    Hint: Use string manipulation techniques to check if the substrings are palindromes.\n    \"\"\"\n\n    count = 0\n\n    # Check each character in the string as the center of a palindrome\n    for i in range(len(s)):\n        count += expand_from_center(s, i, i)  # Odd length palindromes\n        count += expand_from_center(s, i, i + 1)  # Even length palindromes\n\n    return count\n\ndef expand_from_center(s: str, left: int, right: int) -> int:\n    \"\"\"\n    Helper function to expand the palindrome from the center outwards.\n    \"\"\"\n\n    count = 0\n\n    # Expand the palindrome until the characters at the left and right pointers are no longer equal\n    while left >= 0 and right < len(s) and s[left] == s[right]:\n        count += 1\n        left -= 1\n        right += 1\n\n    return count", "solution_func": "def g(s=\"abc\"):\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the shortest distance from a source cell to a destination cell.\n    You can move in all eight directions (up, down, left, right, and diagonally) from a given cell if the adjacent cell is 1 and not visited.\n\n    Example:\n    grid = [\n        [1, 1, 0, 1, 1],\n        [1, 0, 1, 0, 0],\n        [1, 1, 1, 1, 1],\n        [0, 0, 0, 1, 0],\n        [1, 1, 1, 1, 1]\n    ]\n    source = (0, 0)\n    destination = (4, 4)\n\n    Output:\n    6\n\n    Explanation:\n    The shortest distance from the source cell (0, 0) to the destination cell (4, 4) is 6.\n\n    Hint: Use grid traversal techniques to find the shortest distance.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    if grid[0][0] == 0 or grid[rows - 1][cols - 1] == 0:\n        return -1\n\n    visited = [[False] * cols for _ in range(rows)]\n    visited[0][0] = True\n\n    queue = [(0, 0, 0)]\n\n    while queue:\n        row, col, dist = queue.pop(0)\n\n        if (row, col) == (rows - 1, cols - 1):\n            return dist\n\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]:\n            new_row = row + dr\n            new_col = col + dc\n\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1 and not visited[new_row][new_col]:\n                visited[new_row][new_col] = True\n                queue.append((new_row, new_col, dist + 1))\n\n    return -1\n\ndef g():\n    grid = [\n        [1, 1, 0, 1, 1],\n        [1, 0, 1, 0, 0],\n        [1, 1, 1, 1, 1],\n        [0, 0, 0, 1, 0],\n        [1, 1, 1, 1, 1]\n    ]\n    return [grid]\n\nassert f(*g()) == 6\n\n", "emb": null, "idx_generation": 465, "target_skills": [1, 0, 1, 1, 1, 1, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the shortest distance from a source cell to a destination cell.\n    You can move in all eight directions (up, down, left, right, and diagonally) from a given cell if the adjacent cell is 1 and not visited.\n\n    Example:\n    grid = [\n        [1, 1, 0, 1, 1],\n        [1, 0, 1, 0, 0],\n        [1, 1, 1, 1, 1],\n        [0, 0, 0, 1, 0],\n        [1, 1, 1, 1, 1]\n    ]\n    source = (0, 0)\n    destination = (4, 4)\n\n    Output:\n    6\n\n    Explanation:\n    The shortest distance from the source cell (0, 0) to the destination cell (4, 4) is 6.\n\n    Hint: Use grid traversal techniques to find the shortest distance.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    if grid[0][0] == 0 or grid[rows - 1][cols - 1] == 0:\n        return -1\n\n    visited = [[False] * cols for _ in range(rows)]\n    visited[0][0] = True\n\n    queue = [(0, 0, 0)]\n\n    while queue:\n        row, col, dist = queue.pop(0)\n\n        if (row, col) == (rows - 1, cols - 1):\n            return dist\n\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]:\n            new_row = row + dr\n            new_col = col + dc\n\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1 and not visited[new_row][new_col]:\n                visited[new_row][new_col] = True\n                queue.append((new_row, new_col, dist + 1))\n\n    return -1", "solution_func": "def g():\n    grid = [\n        [1, 1, 0, 1, 1],\n        [1, 0, 1, 0, 0],\n        [1, 1, 1, 1, 1],\n        [0, 0, 0, 1, 0],\n        [1, 1, 1, 1, 1]\n    ]\n    return [grid]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str, k: int) -> int:\n    \"\"\"\n    Given a string s consisting of lowercase alphabets, return the number of substrings that contain exactly k distinct characters.\n\n    Example:\n    s = \"abccc\"\n    k = 2\n\n    Output:\n    4\n\n    Explanation:\n    The substrings that contain exactly 2 distinct characters are \"ab\", \"bc\", \"cc\", and \"c\".\n\n    Hint: Use a sliding window approach to count the number of substrings with k distinct characters.\n    \"\"\"\n\n    count = 0\n    n = len(s)\n    freq = [0] * 26\n    unique = 0\n    left = 0\n    right = 0\n\n    while right < n:\n        freq[ord(s[right]) - ord('a')] += 1\n\n        if freq[ord(s[right]) - ord('a')] == 1:\n            unique += 1\n\n        while unique > k:\n            freq[ord(s[left]) - ord('a')] -= 1\n\n            if freq[ord(s[left]) - ord('a')] == 0:\n                unique -= 1\n\n            left += 1\n\n        count += right - left + 1\n        right += 1\n\n    return count\n\ndef g(s=\"abccc\", k=2):\n    return s, k\n\nassert f(*g()) == 4\n", "emb": null, "idx_generation": 465, "target_skills": [1, 1, 0, 0, 1, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str, k: int) -> int:\n    \"\"\"\n    Given a string s consisting of lowercase alphabets, return the number of substrings that contain exactly k distinct characters.\n\n    Example:\n    s = \"abccc\"\n    k = 2\n\n    Output:\n    4\n\n    Explanation:\n    The substrings that contain exactly 2 distinct characters are \"ab\", \"bc\", \"cc\", and \"c\".\n\n    Hint: Use a sliding window approach to count the number of substrings with k distinct characters.\n    \"\"\"\n\n    count = 0\n    n = len(s)\n    freq = [0] * 26\n    unique = 0\n    left = 0\n    right = 0\n\n    while right < n:\n        freq[ord(s[right]) - ord('a')] += 1\n\n        if freq[ord(s[right]) - ord('a')] == 1:\n            unique += 1\n\n        while unique > k:\n            freq[ord(s[left]) - ord('a')] -= 1\n\n            if freq[ord(s[left]) - ord('a')] == 0:\n                unique -= 1\n\n            left += 1\n\n        count += right - left + 1\n        right += 1\n\n    return count", "solution_func": "def g(s=\"abccc\", k=2):\n    return s, k", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, return the number of distinct islands in the grid.\n\n    Two islands are considered to be distinct if they have different shapes or orientations.\n\n    Example:\n    grid = [[1, 1, 0, 0, 0],\n            [1, 1, 0, 0, 0],\n            [0, 0, 0, 1, 1],\n            [0, 0, 0, 1, 1]]\n\n    Output:\n    3\n\n    Explanation:\n    There are 3 distinct islands in the grid.\n\n    Hint: Use depth-first search (DFS) to explore each island and represent its shape or orientation as a string.\n    \"\"\"\n\n    def dfs(grid, i, j, shape):\n        if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] == 0:\n            return\n\n        grid[i][j] = 0\n\n        dfs(grid, i + 1, j, shape + \"D\")\n        dfs(grid, i - 1, j, shape + \"U\")\n        dfs(grid, i, j + 1, shape + \"R\")\n        dfs(grid, i, j - 1, shape + \"L\")\n\n    shapes = set()\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                shape = \"\"\n                dfs(grid, i, j, shape)\n                shapes.add(shape)\n\n    return len(shapes)\n\ndef g(grid=[[1, 1, 0, 0, 0],\n            [1, 1, 0, 0, 0],\n            [0, 0, 0, 1, 1],\n            [0, 0, 0, 1, 1]]):\n    return grid\n\nassert f(g()) == 3\n", "emb": null, "idx_generation": 465, "target_skills": [1, 0, 0, 0, 1, 1, 1, 0, 1, 1], "problem_func": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, return the number of distinct islands in the grid.\n\n    Two islands are considered to be distinct if they have different shapes or orientations.\n\n    Example:\n    grid = [[1, 1, 0, 0, 0],\n            [1, 1, 0, 0, 0],\n            [0, 0, 0, 1, 1],\n            [0, 0, 0, 1, 1]]\n\n    Output:\n    3\n\n    Explanation:\n    There are 3 distinct islands in the grid.\n\n    Hint: Use depth-first search (DFS) to explore each island and represent its shape or orientation as a string.\n    \"\"\"\n\n    def dfs(grid, i, j, shape):\n        if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] == 0:\n            return\n\n        grid[i][j] = 0\n\n        dfs(grid, i + 1, j, shape + \"D\")\n        dfs(grid, i - 1, j, shape + \"U\")\n        dfs(grid, i, j + 1, shape + \"R\")\n        dfs(grid, i, j - 1, shape + \"L\")\n\n    shapes = set()\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                shape = \"\"\n                dfs(grid, i, j, shape)\n                shapes.add(shape)\n\n    return len(shapes)", "solution_func": "def g(grid=[[1, 1, 0, 0, 0],\n            [1, 1, 0, 0, 0],\n            [0, 0, 0, 1, 1],\n            [0, 0, 0, 1, 1]]):\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\n\n    You can only move down or right at any point in time.\n\n    Example:\n    n = 3\n\n    Output:\n    6\n\n    Explanation:\n    There are 6 unique paths from the top-left corner to the bottom-right corner of a 3 x 3 grid.\n\n    Hint: Use dynamic programming to build up the number of unique paths for each cell in the grid.\n    \"\"\"\n\n    dp = [[0] * n for _ in range(n)]\n    dp[0][0] = 1\n\n    for i in range(n):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] += dp[i - 1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j - 1]\n\n    return dp[n - 1][n - 1]\n\ndef g(n=3):\n    return n\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 465, "target_skills": [1, 1, 0, 1, 0, 0, 1, 1, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\n\n    You can only move down or right at any point in time.\n\n    Example:\n    n = 3\n\n    Output:\n    6\n\n    Explanation:\n    There are 6 unique paths from the top-left corner to the bottom-right corner of a 3 x 3 grid.\n\n    Hint: Use dynamic programming to build up the number of unique paths for each cell in the grid.\n    \"\"\"\n\n    dp = [[0] * n for _ in range(n)]\n    dp[0][0] = 1\n\n    for i in range(n):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] += dp[i - 1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j - 1]\n\n    return dp[n - 1][n - 1]", "solution_func": "def g(n=3):\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there exists a pair of numbers in the list whose sum is equal to the target.\n    \n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    \n    Output:\n    True (as there exists a pair [2, 5] whose sum is equal to the target 7)\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    return (arr, target)\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 465, "target_skills": [1, 0, 0, 0, 0, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there exists a pair of numbers in the list whose sum is equal to the target.\n    \n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    \n    Output:\n    True (as there exists a pair [2, 5] whose sum is equal to the target 7)\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g():\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    return (arr, target)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the sum of the first n natural numbers.\n\n    Args:\n    - n: The number of natural numbers to sum.\n\n    Returns:\n    - The sum of the first n natural numbers.\n\n    Example:\n    f(5) => 15\n    \"\"\"\n    if n == 0:\n        return 0\n    else:\n        return n + f(n-1)\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == 15\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 466, "target_skills": [1, 1, 0, 1, 0, 0, 1, 1, 1, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the sum of the first n natural numbers.\n\n    Args:\n    - n: The number of natural numbers to sum.\n\n    Returns:\n    - The sum of the first n natural numbers.\n\n    Example:\n    f(5) => 15\n    \"\"\"\n    if n == 0:\n        return 0\n    else:\n        return n + f(n-1)", "solution_func": "def g():\n    n = 5\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the path from the top-left corner to the bottom-right corner that minimizes the sum of all numbers along its path. You can only move down or right.\n\n    Args:\n    - grid: A grid of non-negative integers.\n\n    Returns:\n    - The minimum sum of all numbers along the path from the top-left corner to the bottom-right corner.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum sum path is 1 -> 3 -> 1 -> 1 -> 1, which has a sum of 7.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 466, "target_skills": [1, 0, 1, 0, 1, 0, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the path from the top-left corner to the bottom-right corner that minimizes the sum of all numbers along its path. You can only move down or right.\n\n    Args:\n    - grid: A grid of non-negative integers.\n\n    Returns:\n    - The minimum sum of all numbers along the path from the top-left corner to the bottom-right corner.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum sum path is 1 -> 3 -> 1 -> 1 -> 1, which has a sum of 7.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]", "solution_func": "def g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order using the bubble sort algorithm.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The sorted list of integers.\n\n    Example:\n    nums = [5, 2, 8, 3, 1]\n\n    Output:\n    [1, 2, 3, 5, 8]\n    \"\"\"\n    n = len(nums)\n\n    for i in range(n-1):\n        for j in range(n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n\n    return nums\n\ndef g():\n    nums = [5, 2, 8, 3, 1]\n    return nums\n\nassert f(g()) == [1, 2, 3, 5, 8]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 466, "target_skills": [0, 1, 1, 0, 1, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order using the bubble sort algorithm.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The sorted list of integers.\n\n    Example:\n    nums = [5, 2, 8, 3, 1]\n\n    Output:\n    [1, 2, 3, 5, 8]\n    \"\"\"\n    n = len(nums)\n\n    for i in range(n-1):\n        for j in range(n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n\n    return nums", "solution_func": "def g():\n    nums = [5, 2, 8, 3, 1]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers, find two numbers such that they add up to a specific target. Return the indices of the two numbers in the array.\n\n    Example:\n    nums = [2, 7, 11, 15], target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The sum of 2 and 7 is 9, and their indices in the array are 0 and 1 respectively.\n\n    Constraints:\n    - The input list will always be sorted in ascending order.\n    - The input list will not contain any duplicate elements.\n    - The target number will always be obtainable by summing two numbers from the input list.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 466, "target_skills": [1, 0, 1, 1, 0, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers, find two numbers such that they add up to a specific target. Return the indices of the two numbers in the array.\n\n    Example:\n    nums = [2, 7, 11, 15], target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The sum of 2 and 7 is 9, and their indices in the array are 0 and 1 respectively.\n\n    Constraints:\n    - The input list will always be sorted in ascending order.\n    - The input list will not contain any duplicate elements.\n    - The target number will always be obtainable by summing two numbers from the input list.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR value between two numbers in the array.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value between two numbers in the array is 28, which is the result of XORing 5 and 25.\n\n    Constraints:\n    - The length of the input list will always be at least 2.\n    - The input list may contain duplicate elements.\n    \"\"\"\n\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n\n        for num in nums:\n            prefix = num & mask\n            prefix_set.add(prefix)\n\n        candidate = max_xor | (1 << i)\n\n        for prefix in prefix_set:\n            if candidate ^ prefix in prefix_set:\n                max_xor = candidate\n                break\n\n    return max_xor\n\ndef g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 466, "target_skills": [1, 0, 0, 1, 0, 1, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR value between two numbers in the array.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value between two numbers in the array is 28, which is the result of XORing 5 and 25.\n\n    Constraints:\n    - The length of the input list will always be at least 2.\n    - The input list may contain duplicate elements.\n    \"\"\"\n\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n\n        for num in nums:\n            prefix = num & mask\n            prefix_set.add(prefix)\n\n        candidate = max_xor | (1 << i)\n\n        for prefix in prefix_set:\n            if candidate ^ prefix in prefix_set:\n                max_xor = candidate\n                break\n\n    return max_xor", "solution_func": "def g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers, find the target index in the array using binary search.\n\n    Example:\n    nums = [2, 5, 7, 9, 12], target = 7\n\n    Output:\n    2\n\n    Explanation:\n    The target number 7 is found at index 2 in the array.\n\n    Constraints:\n    - The input list will always be sorted in ascending order.\n    - The input list will not contain any duplicate elements.\n    - The target number will always be present in the input list.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    nums = [2, 5, 7, 9, 12]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 2\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 466, "target_skills": [0, 1, 0, 0, 0, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers, find the target index in the array using binary search.\n\n    Example:\n    nums = [2, 5, 7, 9, 12], target = 7\n\n    Output:\n    2\n\n    Explanation:\n    The target number 7 is found at index 2 in the array.\n\n    Constraints:\n    - The input list will always be sorted in ascending order.\n    - The input list will not contain any duplicate elements.\n    - The target number will always be present in the input list.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g():\n    nums = [2, 5, 7, 9, 12]\n    target = 7\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of unique binary search trees that can be formed with n nodes.\n\n    Example:\n    Input: 3\n    Output: 5\n\n    Explanation:\n    For n = 3, there are 5 unique binary search trees that can be formed:\n        1         3     3      2      1\n         \\       /     /      / \\      \\\n          3     2     1      1   3      2\n         /     /       \\                 \\\n        2     1         2                 3\n    \"\"\"\n\n    if n <= 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i - j - 1]\n\n    return dp[n]\n\ndef g() -> int:\n    return 3\n\nassert f(g()) == 5\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 466, "target_skills": [1, 1, 1, 1, 0, 1, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of unique binary search trees that can be formed with n nodes.\n\n    Example:\n    Input: 3\n    Output: 5\n\n    Explanation:\n    For n = 3, there are 5 unique binary search trees that can be formed:\n        1         3     3      2      1\n         \\       /     /      / \\      \\\n          3     2     1      1   3      2\n         /     /       \\                 \\\n        2     1         2                 3\n    \"\"\"\n\n    if n <= 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i - j - 1]\n\n    return dp[n]", "solution_func": "def g() -> int:\n    return 3", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, find the number of distinct islands in the grid.\n    An island is considered to be a group of connected 1s, where two cells are considered connected if they are adjacent vertically or horizontally (not diagonally).\n\n    Example:\n    Input:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 0, 1, 1],\n        [0, 0, 0, 1, 1]\n    ]\n\n    Output:\n    2\n\n    Explanation:\n    In the given grid, there are 2 distinct islands:\n    - The top-left island consists of 4 1s.\n    - The bottom-right island consists of 4 1s.\n    \"\"\"\n\n    def dfs(grid, i, j, di, dj, path):\n        m, n = len(grid), len(grid[0])\n        if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0:\n            return\n\n        grid[i][j] = 0\n        path.append((di, dj))\n        dfs(grid, i + 1, j, di + 1, dj, path)\n        dfs(grid, i - 1, j, di - 1, dj, path)\n        dfs(grid, i, j + 1, di, dj + 1, path)\n        dfs(grid, i, j - 1, di, dj - 1, path)\n\n    paths = set()\n    m, n = len(grid), len(grid[0])\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                path = []\n                dfs(grid, i, j, 0, 0, path)\n                paths.add(tuple(path))\n\n    return len(paths)\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 0, 1, 1],\n        [0, 0, 0, 1, 1]\n    ]\n\nassert f(g()) == 2\n", "emb": null, "idx_generation": 466, "target_skills": [0, 0, 1, 1, 0, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, find the number of distinct islands in the grid.\n    An island is considered to be a group of connected 1s, where two cells are considered connected if they are adjacent vertically or horizontally (not diagonally).\n\n    Example:\n    Input:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 0, 1, 1],\n        [0, 0, 0, 1, 1]\n    ]\n\n    Output:\n    2\n\n    Explanation:\n    In the given grid, there are 2 distinct islands:\n    - The top-left island consists of 4 1s.\n    - The bottom-right island consists of 4 1s.\n    \"\"\"\n\n    def dfs(grid, i, j, di, dj, path):\n        m, n = len(grid), len(grid[0])\n        if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0:\n            return\n\n        grid[i][j] = 0\n        path.append((di, dj))\n        dfs(grid, i + 1, j, di + 1, dj, path)\n        dfs(grid, i - 1, j, di - 1, dj, path)\n        dfs(grid, i, j + 1, di, dj + 1, path)\n        dfs(grid, i, j - 1, di, dj - 1, path)\n\n    paths = set()\n    m, n = len(grid), len(grid[0])\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                path = []\n                dfs(grid, i, j, 0, 0, path)\n                paths.add(tuple(path))\n\n    return len(paths)", "solution_func": "def g() -> List[List[int]]:\n    return [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 0, 1, 1],\n        [0, 0, 0, 1, 1]\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the maximum number of consecutive 1s in the binary representation of any number in nums.\n\n    Example:\n    Input: [1, 15, 7, 6]\n    Output: 4\n\n    Explanation:\n    The binary representation of 1 is '1' (1 consecutive 1).\n    The binary representation of 15 is '1111' (4 consecutive 1s).\n    The binary representation of 7 is '111' (3 consecutive 1s).\n    The binary representation of 6 is '110' (2 consecutive 1s).\n    The maximum number of consecutive 1s is 4.\n    \"\"\"\n\n    max_consecutive_ones = 0\n\n    for num in nums:\n        consecutive_ones = 0\n        while num > 0:\n            if num % 2 == 1:\n                consecutive_ones += 1\n            else:\n                consecutive_ones = 0\n            max_consecutive_ones = max(max_consecutive_ones, consecutive_ones)\n            num //= 2\n\n    return max_consecutive_ones\n\ndef g() -> List[int]:\n    return [1, 15, 7, 6]\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 466, "target_skills": [0, 1, 1, 1, 0, 0, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the maximum number of consecutive 1s in the binary representation of any number in nums.\n\n    Example:\n    Input: [1, 15, 7, 6]\n    Output: 4\n\n    Explanation:\n    The binary representation of 1 is '1' (1 consecutive 1).\n    The binary representation of 15 is '1111' (4 consecutive 1s).\n    The binary representation of 7 is '111' (3 consecutive 1s).\n    The binary representation of 6 is '110' (2 consecutive 1s).\n    The maximum number of consecutive 1s is 4.\n    \"\"\"\n\n    max_consecutive_ones = 0\n\n    for num in nums:\n        consecutive_ones = 0\n        while num > 0:\n            if num % 2 == 1:\n                consecutive_ones += 1\n            else:\n                consecutive_ones = 0\n            max_consecutive_ones = max(max_consecutive_ones, consecutive_ones)\n            num //= 2\n\n    return max_consecutive_ones", "solution_func": "def g() -> List[int]:\n    return [1, 15, 7, 6]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two numbers in the list.\n\n    Example:\n    nums = [2, 3, 4, 5]\n\n    Output:\n    20\n\n    Hint: The maximum product is either the product of the two largest positive numbers or the product of the two smallest negative numbers and the largest positive number.\n    \"\"\"\n    nums.sort()\n    return max(nums[-1] * nums[-2], nums[0] * nums[1])\n\ndef g():\n    return [2, 3, 4, 5]\n\nassert f(g()) == 20\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 466, "target_skills": [1, 1, 1, 0, 1, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two numbers in the list.\n\n    Example:\n    nums = [2, 3, 4, 5]\n\n    Output:\n    20\n\n    Hint: The maximum product is either the product of the two largest positive numbers or the product of the two smallest negative numbers and the largest positive number.\n    \"\"\"\n    nums.sort()\n    return max(nums[-1] * nums[-2], nums[0] * nums[1])", "solution_func": "def g():\n    return [2, 3, 4, 5]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the number of connected regions of 1s.\n\n    Example:\n    Input: grid = [[1, 1, 0, 0, 0],\n                   [0, 1, 0, 0, 1],\n                   [1, 0, 0, 1, 1],\n                   [0, 0, 0, 0, 0],\n                   [1, 0, 1, 0, 1]]\n    Output: 6\n    Explanation:\n    The grid contains 6 connected regions of 1s: [(0, 0), (0, 1)], [(1, 1)], [(2, 0)], [(2, 3), (2, 4)], [(4, 0)], [(4, 2)], [(4, 4)]\n    \"\"\"\n    def dfs(i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:\n            return\n        grid[i][j] = -1\n        dfs(i + 1, j)\n        dfs(i - 1, j)\n        dfs(i, j + 1)\n        dfs(i, j - 1)\n\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                count += 1\n                dfs(i, j)\n    return count\n\ndef g() -> List[List[int]]:\n    return [[1, 1, 0, 0, 0],\n            [0, 1, 0, 0, 1],\n            [1, 0, 0, 1, 1],\n            [0, 0, 0, 0, 0],\n            [1, 0, 1, 0, 1]]\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0], "idx_generation": 467, "target_skills": [0, 1, 1, 0, 1, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the number of connected regions of 1s.\n\n    Example:\n    Input: grid = [[1, 1, 0, 0, 0],\n                   [0, 1, 0, 0, 1],\n                   [1, 0, 0, 1, 1],\n                   [0, 0, 0, 0, 0],\n                   [1, 0, 1, 0, 1]]\n    Output: 6\n    Explanation:\n    The grid contains 6 connected regions of 1s: [(0, 0), (0, 1)], [(1, 1)], [(2, 0)], [(2, 3), (2, 4)], [(4, 0)], [(4, 2)], [(4, 4)]\n    \"\"\"\n    def dfs(i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:\n            return\n        grid[i][j] = -1\n        dfs(i + 1, j)\n        dfs(i - 1, j)\n        dfs(i, j + 1)\n        dfs(i, j - 1)\n\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                count += 1\n                dfs(i, j)\n    return count", "solution_func": "def g() -> List[List[int]]:\n    return [[1, 1, 0, 0, 0],\n            [0, 1, 0, 0, 1],\n            [1, 0, 0, 1, 1],\n            [0, 0, 0, 0, 0],\n            [1, 0, 1, 0, 1]]", "map_ix": [0, 0, 1, 0, 0, 0, 1, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(n: int, m: int, k: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    Given a number of nodes, a number of edges, and a list of edges between the nodes, determine the number of connected components in the graph after removing k edges.\n\n    Example:\n    Input: n = 5, m = 5, k = 2, edges = [[1, 2], [2, 3], [3, 4], [4, 5], [1, 5]]\n    Output: 2\n    Explanation:\n    Initially, the graph has 1 connected component: 1 -> 2 -> 3 -> 4 -> 5\n    After removing 2 edges, the graph has 2 connected components: 1 -> 2 -> 3 and 4 -> 5\n    \"\"\"\n    def find(x):\n        if parent[x] == -1:\n            return x\n        return find(parent[x])\n\n    def union(x, y):\n        xroot = find(x)\n        yroot = find(y)\n        if xroot == yroot:\n            return\n        parent[xroot] = yroot\n\n    parent = [-1] * n\n    count = n\n\n    for edge in edges:\n        x = edge[0] - 1\n        y = edge[1] - 1\n        if find(x) != find(y):\n            union(x, y)\n            count -= 1\n\n    return count\n\ndef g() -> Tuple[int, int, int, List[List[int]]]:\n    return 5, 5, 2, [[1, 2], [2, 3], [3, 4], [4, 5], [1, 5]]\n\nassert f(*g()) == 2\n", "emb": null, "idx_generation": 467, "target_skills": [1, 1, 0, 1, 1, 0, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(n: int, m: int, k: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    Given a number of nodes, a number of edges, and a list of edges between the nodes, determine the number of connected components in the graph after removing k edges.\n\n    Example:\n    Input: n = 5, m = 5, k = 2, edges = [[1, 2], [2, 3], [3, 4], [4, 5], [1, 5]]\n    Output: 2\n    Explanation:\n    Initially, the graph has 1 connected component: 1 -> 2 -> 3 -> 4 -> 5\n    After removing 2 edges, the graph has 2 connected components: 1 -> 2 -> 3 and 4 -> 5\n    \"\"\"\n    def find(x):\n        if parent[x] == -1:\n            return x\n        return find(parent[x])\n\n    def union(x, y):\n        xroot = find(x)\n        yroot = find(y)\n        if xroot == yroot:\n            return\n        parent[xroot] = yroot\n\n    parent = [-1] * n\n    count = n\n\n    for edge in edges:\n        x = edge[0] - 1\n        y = edge[1] - 1\n        if find(x) != find(y):\n            union(x, y)\n            count -= 1\n\n    return count", "solution_func": "def g() -> Tuple[int, int, int, List[List[int]]]:\n    return 5, 5, 2, [[1, 2], [2, 3], [3, 4], [4, 5], [1, 5]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\n\n    Example:\n    Input: n = 3\n    Output: 6\n    Explanation:\n    There are 6 unique paths from the top-left corner to the bottom-right corner in a 3 x 3 grid:\n    1. right -> right -> down\n    2. right -> down -> right\n    3. down -> right -> right\n    4. right -> down -> down\n    5. down -> right -> down\n    6. down -> down -> right\n    \"\"\"\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][0] = 1\n        dp[0][i] = 1\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    return dp[n - 1][n - 1]\n\ndef g(n = 3):\n    return n\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 467, "target_skills": [1, 0, 0, 0, 0, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\n\n    Example:\n    Input: n = 3\n    Output: 6\n    Explanation:\n    There are 6 unique paths from the top-left corner to the bottom-right corner in a 3 x 3 grid:\n    1. right -> right -> down\n    2. right -> down -> right\n    3. down -> right -> right\n    4. right -> down -> down\n    5. down -> right -> down\n    6. down -> down -> right\n    \"\"\"\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][0] = 1\n        dp[0][i] = 1\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    return dp[n - 1][n - 1]", "solution_func": "def g(n = 3):\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    24\n\n    Explanation:\n    The maximum product of three numbers in the list is 2*3*4 = 24.\n\n    Hint: Sort the list in ascending order and consider the cases where the maximum product involves either the two smallest numbers and the largest number or the three largest numbers.\n    \"\"\"\n    nums.sort()\n\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\n\ndef g(nums: List[int] = [1, 2, 3, 4]):\n    return (nums,)\n\nassert f(*g()) == 24\n\n", "emb": [1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 467, "target_skills": [0, 0, 0, 0, 1, 0, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    24\n\n    Explanation:\n    The maximum product of three numbers in the list is 2*3*4 = 24.\n\n    Hint: Sort the list in ascending order and consider the cases where the maximum product involves either the two smallest numbers and the largest number or the three largest numbers.\n    \"\"\"\n    nums.sort()\n\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])", "solution_func": "def g(nums: List[int] = [1, 2, 3, 4]):\n    return (nums,)", "map_ix": [1, 0, 1, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of prime numbers less than or equal to n.\n\n    Example:\n    n = 10\n\n    Output:\n    4\n\n    Explanation:\n    There are 4 prime numbers less than or equal to 10: 2, 3, 5, 7.\n\n    Hint: Use the Sieve of Eratosthenes algorithm to efficiently find all prime numbers up to n.\n    \"\"\"\n    primes = [True] * (n + 1)\n    primes[0] = primes[1] = False\n\n    p = 2\n    while p * p <= n:\n        if primes[p] == True:\n            for i in range(p * p, n + 1, p):\n                primes[i] = False\n        p += 1\n\n    return sum(primes)\n\ndef g(n: int = 10):\n    return (n,)\n\nassert f(*g()) == 4\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 467, "target_skills": [0, 0, 1, 1, 0, 0, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of prime numbers less than or equal to n.\n\n    Example:\n    n = 10\n\n    Output:\n    4\n\n    Explanation:\n    There are 4 prime numbers less than or equal to 10: 2, 3, 5, 7.\n\n    Hint: Use the Sieve of Eratosthenes algorithm to efficiently find all prime numbers up to n.\n    \"\"\"\n    primes = [True] * (n + 1)\n    primes[0] = primes[1] = False\n\n    p = 2\n    while p * p <= n:\n        if primes[p] == True:\n            for i in range(p * p, n + 1, p):\n                primes[i] = False\n        p += 1\n\n    return sum(primes)", "solution_func": "def g(n: int = 10):\n    return (n,)", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    Output:\n    4\n\n    Explanation:\n    The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n\n    Hint: Use dynamic programming to keep track of the length of the longest increasing subsequence ending at each index.\n    \"\"\"\n    if not nums:\n        return 0\n\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g(nums: List[int] = [10, 9, 2, 5, 3, 7, 101, 18]):\n    return (nums,)\n\nassert f(*g()) == 4\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 467, "target_skills": [0, 0, 0, 0, 1, 0, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    Output:\n    4\n\n    Explanation:\n    The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n\n    Hint: Use dynamic programming to keep track of the length of the longest increasing subsequence ending at each index.\n    \"\"\"\n    if not nums:\n        return 0\n\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)", "solution_func": "def g(nums: List[int] = [10, 9, 2, 5, 3, 7, 101, 18]):\n    return (nums,)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value using binary search.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 4\n\n    Output:\n    3\n\n    Explanation:\n    The target value 4 is found at index 3 in the list.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(arr=[1, 2, 3, 4, 5], target=4):\n    return arr, target\n\nassert f(*g()) == 3\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 467, "target_skills": [0, 0, 1, 0, 1, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value using binary search.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 4\n\n    Output:\n    3\n\n    Explanation:\n    The target value 4 is found at index 3 in the list.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g(arr=[1, 2, 3, 4, 5], target=4):\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray using Kadane's algorithm.\n\n    Example:\n    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The subarray with the maximum sum is [4, -1, 2, 1], which has a sum of 6.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g(arr=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return arr\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 467, "target_skills": [1, 1, 0, 1, 1, 1, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray using Kadane's algorithm.\n\n    Example:\n    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The subarray with the maximum sum is [4, -1, 2, 1], which has a sum of 6.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g(arr=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return arr", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list using the merge sort algorithm.\n\n    Example:\n    arr = [5, 2, 8, 4, 1]\n\n    Output:\n    [1, 2, 4, 5, 8]\n\n    Explanation:\n    The list is sorted in ascending order.\n    \"\"\"\n    def merge_sort(arr: List[int]) -> List[int]:\n        if len(arr) <= 1:\n            return arr\n\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        left_half = merge_sort(left_half)\n        right_half = merge_sort(right_half)\n\n        return merge(left_half, right_half)\n\n    def merge(left: List[int], right: List[int]) -> List[int]:\n        merged = []\n        left_index = 0\n        right_index = 0\n\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n\n        return merged\n\n    return merge_sort(arr)\n\ndef g(arr=[5, 2, 8, 4, 1]):\n    return arr\n\nassert f(g()) == [1, 2, 4, 5, 8]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 467, "target_skills": [1, 0, 0, 1, 1, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list using the merge sort algorithm.\n\n    Example:\n    arr = [5, 2, 8, 4, 1]\n\n    Output:\n    [1, 2, 4, 5, 8]\n\n    Explanation:\n    The list is sorted in ascending order.\n    \"\"\"\n    def merge_sort(arr: List[int]) -> List[int]:\n        if len(arr) <= 1:\n            return arr\n\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        left_half = merge_sort(left_half)\n        right_half = merge_sort(right_half)\n\n        return merge(left_half, right_half)\n\n    def merge(left: List[int], right: List[int]) -> List[int]:\n        merged = []\n        left_index = 0\n        right_index = 0\n\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                right_index += 1\n\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n\n        return merged\n\n    return merge_sort(arr)", "solution_func": "def g(arr=[5, 2, 8, 4, 1]):\n    return arr", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 0 represents an empty cell and 1 represents a wall,\n    find the length of the shortest path from the top-left corner to the bottom-right corner,\n    only moving horizontally or vertically. You can only move through empty cells.\n\n    Return -1 if there is no path available.\n\n    Example:\n    grid = [\n        [0, 1, 0, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 1, 0, 1, 0],\n        [1, 1, 0, 0, 0],\n        [0, 1, 0, 0, 0]\n    ]\n\n    Output: 10\n    Explanation: The shortest path is indicated by the numbers below:\n    0 1 0 0 0\n    1 2 3 X 0\n    2 X 4 X 0\n    X X 5 6 7\n    8 X 6 7 8\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    def dfs(i: int, j: int, length: int) -> None:\n        if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != 0:\n            return\n\n        if i == m - 1 and j == n - 1:\n            nonlocal min_length\n            min_length = min(min_length, length)\n            return\n\n        grid[i][j] = length + 1\n\n        dfs(i + 1, j, length + 1)\n        dfs(i - 1, j, length + 1)\n        dfs(i, j + 1, length + 1)\n        dfs(i, j - 1, length + 1)\n\n        grid[i][j] = 0\n\n    min_length = float('inf')\n    dfs(0, 0, 0)\n\n    if min_length == float('inf'):\n        return -1\n    else:\n        return min_length\n\ndef g() -> List[List[int]]:\n    return [\n        [0, 1, 0, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 1, 0, 1, 0],\n        [1, 1, 0, 0, 0],\n        [0, 1, 0, 0, 0]\n    ]\n\nassert f(g()) == 10\n", "emb": null, "idx_generation": 467, "target_skills": [0, 1, 1, 0, 0, 0, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 0 represents an empty cell and 1 represents a wall,\n    find the length of the shortest path from the top-left corner to the bottom-right corner,\n    only moving horizontally or vertically. You can only move through empty cells.\n\n    Return -1 if there is no path available.\n\n    Example:\n    grid = [\n        [0, 1, 0, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 1, 0, 1, 0],\n        [1, 1, 0, 0, 0],\n        [0, 1, 0, 0, 0]\n    ]\n\n    Output: 10\n    Explanation: The shortest path is indicated by the numbers below:\n    0 1 0 0 0\n    1 2 3 X 0\n    2 X 4 X 0\n    X X 5 6 7\n    8 X 6 7 8\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    def dfs(i: int, j: int, length: int) -> None:\n        if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != 0:\n            return\n\n        if i == m - 1 and j == n - 1:\n            nonlocal min_length\n            min_length = min(min_length, length)\n            return\n\n        grid[i][j] = length + 1\n\n        dfs(i + 1, j, length + 1)\n        dfs(i - 1, j, length + 1)\n        dfs(i, j + 1, length + 1)\n        dfs(i, j - 1, length + 1)\n\n        grid[i][j] = 0\n\n    min_length = float('inf')\n    dfs(0, 0, 0)\n\n    if min_length == float('inf'):\n        return -1\n    else:\n        return min_length", "solution_func": "def g() -> List[List[int]]:\n    return [\n        [0, 1, 0, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 1, 0, 1, 0],\n        [1, 1, 0, 0, 0],\n        [0, 1, 0, 0, 0]\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n\n    Example:\n    Input: 6\n    Output: 8\n\n    Explanation:\n    The 6th Fibonacci number is 8, where the Fibonacci sequence is [0, 1, 1, 2, 3, 5, 8, ...]\n    \"\"\"\n\n    if n <= 1:\n        return n\n\n    fib = [0, 1]\n\n    for i in range(2, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2])\n\n    return fib[n]\n\ndef g() -> int:\n    return 6\n\nassert f(g()) == 8\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 468, "target_skills": [0, 0, 0, 1, 0, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n\n    Example:\n    Input: 6\n    Output: 8\n\n    Explanation:\n    The 6th Fibonacci number is 8, where the Fibonacci sequence is [0, 1, 1, 2, 3, 5, 8, ...]\n    \"\"\"\n\n    if n <= 1:\n        return n\n\n    fib = [0, 1]\n\n    for i in range(2, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2])\n\n    return fib[n]", "solution_func": "def g() -> int:\n    return 6", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome after removing at most one character.\n\n    Example:\n    Input: \"racecar\"\n    Output: True\n\n    Explanation:\n    The string \"racecar\" is already a palindrome.\n\n    Input: \"abccdba\"\n    Output: True\n\n    Explanation:\n    The string \"abccdba\" is a palindrome after removing the character 'd'.\n\n    Input: \"abcdba\"\n    Output: False\n\n    Explanation:\n    The string \"abcdba\" is not a palindrome after removing at most one character.\n\n    \"\"\"\n\n    def is_palindrome(s: str, left: int, right: int, removed: bool) -> bool:\n        while left < right:\n            if s[left] != s[right]:\n                if removed:\n                    return False\n                else:\n                    return is_palindrome(s, left + 1, right, True) or is_palindrome(s, left, right - 1, True)\n            left += 1\n            right -= 1\n        return True\n\n    return is_palindrome(s, 0, len(s) - 1, False)\n\ndef g() -> str:\n    return \"abccdba\"\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 468, "target_skills": [0, 1, 0, 1, 0, 0, 1, 0, 1, 1], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome after removing at most one character.\n\n    Example:\n    Input: \"racecar\"\n    Output: True\n\n    Explanation:\n    The string \"racecar\" is already a palindrome.\n\n    Input: \"abccdba\"\n    Output: True\n\n    Explanation:\n    The string \"abccdba\" is a palindrome after removing the character 'd'.\n\n    Input: \"abcdba\"\n    Output: False\n\n    Explanation:\n    The string \"abcdba\" is not a palindrome after removing at most one character.\n\n    \"\"\"\n\n    def is_palindrome(s: str, left: int, right: int, removed: bool) -> bool:\n        while left < right:\n            if s[left] != s[right]:\n                if removed:\n                    return False\n                else:\n                    return is_palindrome(s, left + 1, right, True) or is_palindrome(s, left, right - 1, True)\n            left += 1\n            right -= 1\n        return True\n\n    return is_palindrome(s, 0, len(s) - 1, False)", "solution_func": "def g() -> str:\n    return \"abccdba\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target number, return the number of unique combinations of the elements in nums that sum up to the target.\n\n    Example:\n    Input: nums = [1, 2, 3], target = 4\n    Output: 7\n\n    Explanation:\n    The unique combinations of [1, 2, 3] that sum up to 4 are:\n    [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [1, 3], [2, 1, 1], [2, 2], [3, 1]\n\n    \"\"\"\n\n    def backtrack(nums: List[int], target: int, index: int, curr_sum: int, memo: dict) -> int:\n        if curr_sum == target:\n            return 1\n        if curr_sum > target:\n            return 0\n        if index == len(nums):\n            return 0\n\n        if (index, curr_sum) in memo:\n            return memo[(index, curr_sum)]\n\n        count = 0\n        for i in range(index, len(nums)):\n            count += backtrack(nums, target, i, curr_sum + nums[i], memo)\n\n        memo[(index, curr_sum)] = count\n        return count\n\n    return backtrack(nums, target, 0, 0, {})\n\ndef g() -> Tuple[List[int], int]:\n    return ([1, 2, 3], 4)\n\nassert f(*g()) == 7\n", "emb": null, "idx_generation": 468, "target_skills": [1, 0, 1, 1, 0, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target number, return the number of unique combinations of the elements in nums that sum up to the target.\n\n    Example:\n    Input: nums = [1, 2, 3], target = 4\n    Output: 7\n\n    Explanation:\n    The unique combinations of [1, 2, 3] that sum up to 4 are:\n    [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [1, 3], [2, 1, 1], [2, 2], [3, 1]\n\n    \"\"\"\n\n    def backtrack(nums: List[int], target: int, index: int, curr_sum: int, memo: dict) -> int:\n        if curr_sum == target:\n            return 1\n        if curr_sum > target:\n            return 0\n        if index == len(nums):\n            return 0\n\n        if (index, curr_sum) in memo:\n            return memo[(index, curr_sum)]\n\n        count = 0\n        for i in range(index, len(nums)):\n            count += backtrack(nums, target, i, curr_sum + nums[i], memo)\n\n        memo[(index, curr_sum)] = count\n        return count\n\n    return backtrack(nums, target, 0, 0, {})", "solution_func": "def g() -> Tuple[List[int], int]:\n    return ([1, 2, 3], 4)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of distinct pairs (a, b) such that a + b is a perfect square.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    There are 3 distinct pairs: (1, 8), (2, 7), (3, 6), (4, 5).\n    The sum of each pair is a perfect square: 9, 9, 9, 9.\n\n    Therefore, the function should return 3.\n    \"\"\"\n\n    def is_perfect_square(n: int) -> bool:\n        \"\"\"\n        Helper function to check if a number is a perfect square.\n        \"\"\"\n        return int(n**0.5)**2 == n\n\n    count = 0\n    unique_pairs = set()\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            pair_sum = nums[i] + nums[j]\n            if is_perfect_square(pair_sum):\n                unique_pairs.add((nums[i], nums[j]))\n    \n    return len(unique_pairs)\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g()) == 3\n", "emb": null, "idx_generation": 468, "target_skills": [1, 1, 0, 1, 0, 1, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of distinct pairs (a, b) such that a + b is a perfect square.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    There are 3 distinct pairs: (1, 8), (2, 7), (3, 6), (4, 5).\n    The sum of each pair is a perfect square: 9, 9, 9, 9.\n\n    Therefore, the function should return 3.\n    \"\"\"\n\n    def is_perfect_square(n: int) -> bool:\n        \"\"\"\n        Helper function to check if a number is a perfect square.\n        \"\"\"\n        return int(n**0.5)**2 == n\n\n    count = 0\n    unique_pairs = set()\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            pair_sum = nums[i] + nums[j]\n            if is_perfect_square(pair_sum):\n                unique_pairs.add((nums[i], nums[j]))\n    \n    return len(unique_pairs)", "solution_func": "def g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of distinct pairs (a, b, c) such that a^2 + b^2 = c^2.\n\n    Example:\n    nums = [3, 4, 5, 6, 7, 8, 9, 10]\n    There is 1 distinct triple: (3, 4, 5).\n    The sum of squares of the first two numbers is equal to the square of the third number: 3^2 + 4^2 = 5^2.\n\n    Therefore, the function should return 1.\n    \"\"\"\n\n    count = 0\n    unique_triples = set()\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                if nums[i]**2 + nums[j]**2 == nums[k]**2:\n                    unique_triples.add((nums[i], nums[j], nums[k]))\n    \n    return len(unique_triples)\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == 1\n", "emb": null, "idx_generation": 468, "target_skills": [0, 0, 0, 1, 1, 1, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of distinct pairs (a, b, c) such that a^2 + b^2 = c^2.\n\n    Example:\n    nums = [3, 4, 5, 6, 7, 8, 9, 10]\n    There is 1 distinct triple: (3, 4, 5).\n    The sum of squares of the first two numbers is equal to the square of the third number: 3^2 + 4^2 = 5^2.\n\n    Therefore, the function should return 1.\n    \"\"\"\n\n    count = 0\n    unique_triples = set()\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                if nums[i]**2 + nums[j]**2 == nums[k]**2:\n                    unique_triples.add((nums[i], nums[j], nums[k]))\n    \n    return len(unique_triples)", "solution_func": "def g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [3, 4, 5, 6, 7, 8, 9, 10]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find a contiguous subarray that sums up to the target.\n    Return the indices of the subarray.\n\n    Example:\n    nums = [4, 3, 5, 7, 8, 2]\n    target = 12\n\n    The subarray [3, 5, 7] has a sum of 12.\n    The indices of the subarray are [1, 2, 3].\n\n    Therefore, the function should return [1, 2, 3].\n    \"\"\"\n\n    prefix_sums = {0: -1}\n    curr_sum = 0\n    for i, num in enumerate(nums):\n        curr_sum += num\n        if curr_sum - target in prefix_sums:\n            start_index = prefix_sums[curr_sum - target] + 1\n            end_index = i\n            return list(range(start_index, end_index+1))\n        prefix_sums[curr_sum] = i\n    \n    return []\n\ndef g():\n    \"\"\"\n    Generate a list of integers and a target number.\n    \"\"\"\n    return [4, 3, 5, 7, 8, 2], 12\n\nassert f(*g()) == [1, 2, 3]\n", "emb": null, "idx_generation": 468, "target_skills": [1, 1, 1, 0, 1, 1, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find a contiguous subarray that sums up to the target.\n    Return the indices of the subarray.\n\n    Example:\n    nums = [4, 3, 5, 7, 8, 2]\n    target = 12\n\n    The subarray [3, 5, 7] has a sum of 12.\n    The indices of the subarray are [1, 2, 3].\n\n    Therefore, the function should return [1, 2, 3].\n    \"\"\"\n\n    prefix_sums = {0: -1}\n    curr_sum = 0\n    for i, num in enumerate(nums):\n        curr_sum += num\n        if curr_sum - target in prefix_sums:\n            start_index = prefix_sums[curr_sum - target] + 1\n            end_index = i\n            return list(range(start_index, end_index+1))\n        prefix_sums[curr_sum] = i\n    \n    return []", "solution_func": "def g():\n    \"\"\"\n    Generate a list of integers and a target number.\n    \"\"\"\n    return [4, 3, 5, 7, 8, 2], 12", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Parameters:\n    nums (List[int]): The list of integers.\n\n    Returns:\n    int: The maximum product of any two distinct numbers in the list.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1], nums[n-2] * nums[n-1])\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n\n    Returns:\n    List[int]: A list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 20\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 468, "target_skills": [1, 1, 1, 0, 1, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Parameters:\n    nums (List[int]): The list of integers.\n\n    Returns:\n    int: The maximum product of any two distinct numbers in the list.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1], nums[n-2] * nums[n-1])", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n\n    Returns:\n    List[int]: A list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of words in the string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: The string with reversed order of words.\n    \"\"\"\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)\n\ndef g() -> str:\n    \"\"\"\n    Generate a string.\n\n    Returns:\n    str: A string.\n    \"\"\"\n    return \"Hello World\"\n\nassert f(g()) == \"World Hello\"\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 468, "target_skills": [0, 0, 1, 0, 0, 1, 0, 0, 1, 1], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of words in the string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: The string with reversed order of words.\n    \"\"\"\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate a string.\n\n    Returns:\n    str: A string.\n    \"\"\"\n    return \"Hello World\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return the elements in spiral order.\n\n    Parameters:\n    matrix (List[List[int]]): The input matrix.\n\n    Returns:\n    List[int]: The elements in spiral order.\n    \"\"\"\n    result = []\n    if not matrix:\n        return result\n    m, n = len(matrix), len(matrix[0])\n    top, bottom, left, right = 0, m-1, 0, n-1\n    direction = 0\n    while top <= bottom and left <= right:\n        if direction == 0:\n            for i in range(left, right+1):\n                result.append(matrix[top][i])\n            top += 1\n        elif direction == 1:\n            for i in range(top, bottom+1):\n                result.append(matrix[i][right])\n            right -= 1\n        elif direction == 2:\n            for i in range(right, left-1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n        elif direction == 3:\n            for i in range(bottom, top-1, -1):\n                result.append(matrix[i][left])\n            left += 1\n        direction = (direction + 1) % 4\n    return result\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers.\n\n    Returns:\n    List[List[int]]: A matrix of integers.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 468, "target_skills": [1, 1, 1, 1, 1, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return the elements in spiral order.\n\n    Parameters:\n    matrix (List[List[int]]): The input matrix.\n\n    Returns:\n    List[int]: The elements in spiral order.\n    \"\"\"\n    result = []\n    if not matrix:\n        return result\n    m, n = len(matrix), len(matrix[0])\n    top, bottom, left, right = 0, m-1, 0, n-1\n    direction = 0\n    while top <= bottom and left <= right:\n        if direction == 0:\n            for i in range(left, right+1):\n                result.append(matrix[top][i])\n            top += 1\n        elif direction == 1:\n            for i in range(top, bottom+1):\n                result.append(matrix[i][right])\n            right -= 1\n        elif direction == 2:\n            for i in range(right, left-1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n        elif direction == 3:\n            for i in range(bottom, top-1, -1):\n                result.append(matrix[i][left])\n            left += 1\n        direction = (direction + 1) % 4\n    return result", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers.\n\n    Returns:\n    List[List[int]]: A matrix of integers.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]", "map_ix": [1, 0, 1, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the missing number in the sequence.\n\n    Example:\n    arr = [1, 2, 3, 5, 6, 7, 8]\n\n    Output:\n    4\n    \"\"\"\n    n = len(arr)\n    if arr[0] != 1:\n        return 1\n    if arr[n-1] != n+1:\n        return n+1\n    \n    left = 0\n    right = n-1\n    while left < right:\n        mid = left + (right-left)//2\n        if arr[mid] - mid == 1:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return arr[left] - 1\n\ndef g() -> List[int]:\n    return [1, 2, 3, 5, 6, 7, 8]\n\nassert f(g()) == 4\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 468, "target_skills": [1, 0, 0, 1, 0, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the missing number in the sequence.\n\n    Example:\n    arr = [1, 2, 3, 5, 6, 7, 8]\n\n    Output:\n    4\n    \"\"\"\n    n = len(arr)\n    if arr[0] != 1:\n        return 1\n    if arr[n-1] != n+1:\n        return n+1\n    \n    left = 0\n    right = n-1\n    while left < right:\n        mid = left + (right-left)//2\n        if arr[mid] - mid == 1:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return arr[left] - 1", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3, 5, 6, 7, 8]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there exists a pair of numbers whose sum is equal to a target value.\n    \"\"\"\n    def binary_search(arr, start, end, target):\n        if start > end:\n            return False\n        mid = (start + end) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            return binary_search(arr, mid+1, end, target)\n        else:\n            return binary_search(arr, start, mid-1, target)\n\n    target_sum = 10\n    for i in range(len(arr)):\n        complement = target_sum - arr[i]\n        if binary_search(arr, i+1, len(arr)-1, complement):\n            return True\n    return False\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    return arr\n\nassert f(g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 469, "target_skills": [1, 0, 0, 0, 1, 0, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there exists a pair of numbers whose sum is equal to a target value.\n    \"\"\"\n    def binary_search(arr, start, end, target):\n        if start > end:\n            return False\n        mid = (start + end) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            return binary_search(arr, mid+1, end, target)\n        else:\n            return binary_search(arr, start, mid-1, target)\n\n    target_sum = 10\n    for i in range(len(arr)):\n        complement = target_sum - arr[i]\n        if binary_search(arr, i+1, len(arr)-1, complement):\n            return True\n    return False", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    return arr", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of bits required to represent n in binary form.\n    \"\"\"\n    if n == 0:\n        return 1\n    count = 0\n    while n > 0:\n        count += 1\n        n >>= 1\n    return count\n\ndef g() -> int:\n    \"\"\"\n    Generate the input for the function f.\n    \"\"\"\n    n = 25\n    return n\n\nassert f(g()) == 5\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 469, "target_skills": [1, 0, 1, 1, 1, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of bits required to represent n in binary form.\n    \"\"\"\n    if n == 0:\n        return 1\n    count = 0\n    while n > 0:\n        count += 1\n        n >>= 1\n    return count", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate the input for the function f.\n    \"\"\"\n    n = 25\n    return n", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray such that no two elements in the subarray have the same bit representation.\n    \"\"\"\n    def max_sum(nums):\n        if len(nums) == 1:\n            return nums[0]\n        dp = [0] * len(nums)\n        dp[0] = nums[0]\n        dp[1] = max(nums[0], nums[1])\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        return dp[-1]\n\n    max_sum_no_duplicate_bits = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] & nums[j] == 0:\n                max_sum_no_duplicate_bits = max(max_sum_no_duplicate_bits, max_sum(nums[i:j+1]))\n    return max_sum_no_duplicate_bits\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    return nums\n\nassert f(g()) == 22\n", "emb": null, "idx_generation": 469, "target_skills": [1, 1, 1, 1, 1, 0, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray such that no two elements in the subarray have the same bit representation.\n    \"\"\"\n    def max_sum(nums):\n        if len(nums) == 1:\n            return nums[0]\n        dp = [0] * len(nums)\n        dp[0] = nums[0]\n        dp[1] = max(nums[0], nums[1])\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        return dp[-1]\n\n    max_sum_no_duplicate_bits = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] & nums[j] == 0:\n                max_sum_no_duplicate_bits = max(max_sum_no_duplicate_bits, max_sum(nums[i:j+1]))\n    return max_sum_no_duplicate_bits", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all the numbers that can be formed by concatenating any two numbers from the list.\n\n    Example:\n    nums = [12, 34, 5, 6]\n\n    Output:\n    124536 + 12345 + 3456 + 5634 + 3456 + 123456 + 5612 + 56345 + 561234 + 345612 + 5612345 = 5770585\n\n    Explanation:\n    The sum of all the numbers that can be formed by concatenating any two numbers from the list is 5770585.\n\n    Hint: Use recursion to generate all possible combinations of two numbers from the list and calculate their sum.\n    \"\"\"\n\n    def concat_sum(nums):\n        if len(nums) < 2:\n            return 0\n        \n        total_sum = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                num1 = nums[i]\n                num2 = nums[j]\n                concat_num = int(str(num1) + str(num2))\n                total_sum += concat_num\n        return total_sum\n\n    return concat_sum(nums)\n\ndef g() -> List[int]:\n    nums = [12, 34, 5, 6]\n    return [nums]\n\nassert f(*g()) == 5770585\n", "emb": null, "idx_generation": 469, "target_skills": [1, 1, 1, 1, 0, 0, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all the numbers that can be formed by concatenating any two numbers from the list.\n\n    Example:\n    nums = [12, 34, 5, 6]\n\n    Output:\n    124536 + 12345 + 3456 + 5634 + 3456 + 123456 + 5612 + 56345 + 561234 + 345612 + 5612345 = 5770585\n\n    Explanation:\n    The sum of all the numbers that can be formed by concatenating any two numbers from the list is 5770585.\n\n    Hint: Use recursion to generate all possible combinations of two numbers from the list and calculate their sum.\n    \"\"\"\n\n    def concat_sum(nums):\n        if len(nums) < 2:\n            return 0\n        \n        total_sum = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                num1 = nums[i]\n                num2 = nums[j]\n                concat_num = int(str(num1) + str(num2))\n                total_sum += concat_num\n        return total_sum\n\n    return concat_sum(nums)", "solution_func": "def g() -> List[int]:\n    nums = [12, 34, 5, 6]\n    return [nums]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    20\n\n    Explanation:\n    The maximum product of any two distinct numbers in the list is 5 * 4 = 20.\n\n    Hint: Sort the list in descending order and multiply the first two numbers.\n    \"\"\"\n\n    nums.sort(reverse=True)\n    return nums[0] * nums[1]\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return [nums]\n\nassert f(*g()) == 20\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 469, "target_skills": [0, 0, 0, 0, 1, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    20\n\n    Explanation:\n    The maximum product of any two distinct numbers in the list is 5 * 4 = 20.\n\n    Hint: Sort the list in descending order and multiply the first two numbers.\n    \"\"\"\n\n    nums.sort(reverse=True)\n    return nums[0] * nums[1]", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return [nums]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the minimum absolute difference between any two numbers in the list.\n\n    Example:\n    nums = [4, 2, 8, 6, 10]\n\n    Output:\n    2\n\n    Explanation:\n    The minimum absolute difference between any two numbers in the list is 2 (between 4 and 6).\n\n    Hint: Sort the list in ascending order and compare adjacent numbers to find the minimum difference.\n    \"\"\"\n\n    nums.sort()\n    min_diff = float('inf')\n    for i in range(1, len(nums)):\n        diff = abs(nums[i] - nums[i-1])\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff\n\ndef g() -> List[int]:\n    nums = [4, 2, 8, 6, 10]\n    return [nums]\n\nassert f(*g()) == 2\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 469, "target_skills": [1, 1, 1, 1, 0, 1, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the minimum absolute difference between any two numbers in the list.\n\n    Example:\n    nums = [4, 2, 8, 6, 10]\n\n    Output:\n    2\n\n    Explanation:\n    The minimum absolute difference between any two numbers in the list is 2 (between 4 and 6).\n\n    Hint: Sort the list in ascending order and compare adjacent numbers to find the minimum difference.\n    \"\"\"\n\n    nums.sort()\n    min_diff = float('inf')\n    for i in range(1, len(nums)):\n        diff = abs(nums[i] - nums[i-1])\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff", "solution_func": "def g() -> List[int]:\n    nums = [4, 2, 8, 6, 10]\n    return [nums]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n\n    Return the maximum XOR value.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value is obtained by XORing 5 and 25, which gives 28.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            max_xor = max(max_xor, nums[i] ^ nums[j])\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 469, "target_skills": [0, 0, 1, 0, 1, 1, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n\n    Return the maximum XOR value.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value is obtained by XORing 5 and 25, which gives 28.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            max_xor = max(max_xor, nums[i] ^ nums[j])\n    return max_xor", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given a number of nodes n and a list of edges representing a graph, determine if the graph contains a cycle.\n\n    Return True if the graph contains a cycle, otherwise return False.\n\n    Example:\n    n = 4\n    edges = [[0, 1], [1, 2], [2, 3], [3, 0]]\n\n    Output:\n    True\n\n    Explanation:\n    The graph contains a cycle: 0 -> 1 -> 2 -> 3 -> 0\n    \"\"\"\n    def dfs(node, visited, parent):\n        visited[node] = True\n        for neighbor in edges[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, node):\n                    return True\n            elif parent != neighbor:\n                return True\n        return False\n\n    visited = [False] * n\n    for i in range(n):\n        if not visited[i]:\n            if dfs(i, visited, -1):\n                return True\n    return False\n\ndef g() -> Tuple[int, List[List[int]]]:\n    \"\"\"\n    Generate the number of nodes and a list of edges representing a graph.\n    \"\"\"\n    return 4, [[0, 1], [1, 2], [2, 3], [3, 0]]\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 469, "target_skills": [1, 0, 1, 1, 1, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given a number of nodes n and a list of edges representing a graph, determine if the graph contains a cycle.\n\n    Return True if the graph contains a cycle, otherwise return False.\n\n    Example:\n    n = 4\n    edges = [[0, 1], [1, 2], [2, 3], [3, 0]]\n\n    Output:\n    True\n\n    Explanation:\n    The graph contains a cycle: 0 -> 1 -> 2 -> 3 -> 0\n    \"\"\"\n    def dfs(node, visited, parent):\n        visited[node] = True\n        for neighbor in edges[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, node):\n                    return True\n            elif parent != neighbor:\n                return True\n        return False\n\n    visited = [False] * n\n    for i in range(n):\n        if not visited[i]:\n            if dfs(i, visited, -1):\n                return True\n    return False", "solution_func": "def g() -> Tuple[int, List[List[int]]]:\n    \"\"\"\n    Generate the number of nodes and a list of edges representing a graph.\n    \"\"\"\n    return 4, [[0, 1], [1, 2], [2, 3], [3, 0]]", "map_ix": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n\n    Return the maximum subarray sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The maximum subarray sum is obtained by the subarray [4, -1, 2, 1], which has a sum of 6.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 469, "target_skills": [0, 0, 1, 1, 1, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n\n    Return the maximum subarray sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The maximum subarray sum is obtained by the subarray [4, -1, 2, 1], which has a sum of 6.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> List[int]:\n    \"\"\"\n    Given a directed graph represented as an adjacency list 'graph', a start node 'start',\n    and an end node 'end', find the shortest path from 'start' to 'end' using breadth-first search (BFS).\n    Return the path as a list of nodes.\n\n    Example:\n    graph = {\n        1: [2, 3],\n        2: [4],\n        3: [4, 5],\n        4: [5],\n        5: []\n    }\n    start = 1\n    end = 5\n\n    Output:\n    [1, 3, 5]\n\n    Explanation:\n    The shortest path from node 1 to node 5 is [1, 3, 5].\n    \"\"\"\n\n    def bfs(graph: Dict[int, List[int]], start: int, end: int) -> List[int]:\n        queue = deque([(start, [start])])\n        visited = set()\n\n        while queue:\n            node, path = queue.popleft()\n            visited.add(node)\n\n            if node == end:\n                return path\n\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    queue.append((neighbor, path + [neighbor]))\n\n        return []\n\n    return bfs(graph, start, end)\n\ndef g() -> Tuple[Dict[int, List[int]], int, int]:\n    return ({1: [2, 3], 2: [4], 3: [4, 5], 4: [5], 5: []}, 1, 5)\n\nassert f(*g()) == [1, 3, 5]\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 469, "target_skills": [0, 1, 1, 0, 0, 0, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> List[int]:\n    \"\"\"\n    Given a directed graph represented as an adjacency list 'graph', a start node 'start',\n    and an end node 'end', find the shortest path from 'start' to 'end' using breadth-first search (BFS).\n    Return the path as a list of nodes.\n\n    Example:\n    graph = {\n        1: [2, 3],\n        2: [4],\n        3: [4, 5],\n        4: [5],\n        5: []\n    }\n    start = 1\n    end = 5\n\n    Output:\n    [1, 3, 5]\n\n    Explanation:\n    The shortest path from node 1 to node 5 is [1, 3, 5].\n    \"\"\"\n\n    def bfs(graph: Dict[int, List[int]], start: int, end: int) -> List[int]:\n        queue = deque([(start, [start])])\n        visited = set()\n\n        while queue:\n            node, path = queue.popleft()\n            visited.add(node)\n\n            if node == end:\n                return path\n\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    queue.append((neighbor, path + [neighbor]))\n\n        return []\n\n    return bfs(graph, start, end)", "solution_func": "def g() -> Tuple[Dict[int, List[int]], int, int]:\n    return ({1: [2, 3], 2: [4], 3: [4, 5], 4: [5], 5: []}, 1, 5)", "map_ix": [0, 0, 1, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there are two integers in the list that\n    sum up to the target value. Return True if such pairs exist, otherwise return False.\n\n    Example:\n    arr = [1, 4, 2, 8, 3, 5]\n    target = 10\n\n    Output:\n    True\n\n    Explanation:\n    The pairs [2, 8] and [4, 6] sum up to the target value 10.\n\n    Hint: Use a combination of sorting and searching to find the pairs.\n    \"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr=[1, 4, 2, 8, 3, 5], target=10):\n    return arr, target\n\nassert f(*g()) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 470, "target_skills": [1, 1, 1, 1, 0, 0, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there are two integers in the list that\n    sum up to the target value. Return True if such pairs exist, otherwise return False.\n\n    Example:\n    arr = [1, 4, 2, 8, 3, 5]\n    target = 10\n\n    Output:\n    True\n\n    Explanation:\n    The pairs [2, 8] and [4, 6] sum up to the target value 10.\n\n    Hint: Use a combination of sorting and searching to find the pairs.\n    \"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False", "solution_func": "def g(arr=[1, 4, 2, 8, 3, 5], target=10):\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Find the number of ways to climb n steps.\n\n    You can climb either 1 or 2 steps at a time.\n\n    Example:\n    n = 4\n    output: 5\n\n    Explanation:\n    There are 5 different ways to climb 4 steps:\n    1. 1 -> 1 -> 1 -> 1\n    2. 1 -> 1 -> 2\n    3. 1 -> 2 -> 1\n    4. 2 -> 1 -> 1\n    5. 2 -> 2\n    \"\"\"\n    if n <= 1:\n        return n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\ndef g(n=4):\n    return n\n\nassert f(g()) == 5\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 470, "target_skills": [1, 1, 1, 1, 1, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Find the number of ways to climb n steps.\n\n    You can climb either 1 or 2 steps at a time.\n\n    Example:\n    n = 4\n    output: 5\n\n    Explanation:\n    There are 5 different ways to climb 4 steps:\n    1. 1 -> 1 -> 1 -> 1\n    2. 1 -> 1 -> 2\n    3. 1 -> 2 -> 1\n    4. 2 -> 1 -> 1\n    5. 2 -> 2\n    \"\"\"\n    if n <= 1:\n        return n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]", "solution_func": "def g(n=4):\n    return n", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the sum of all the elements.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n\n    Output:\n    45\n\n    Explanation:\n    The sum of all the elements in the matrix is 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45.\n    \"\"\"\n    total_sum = 0\n    for row in matrix:\n        for num in row:\n            total_sum += num\n    return total_sum\n\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix\n\nassert f(g()) == 45\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 470, "target_skills": [1, 1, 1, 1, 0, 1, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the sum of all the elements.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n\n    Output:\n    45\n\n    Explanation:\n    The sum of all the elements in the matrix is 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45.\n    \"\"\"\n    total_sum = 0\n    for row in matrix:\n        for num in row:\n            total_sum += num\n    return total_sum", "solution_func": "def g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(arr: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Given an array of integers and a target value, find if there are k integers in the array that sum up to the target.\n    \"\"\"\n    arr.sort()\n    return any(sum(arr[i:i+k]) == target for i in range(len(arr)-k+1))\n\ndef g():\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 15\n    k = 3\n    return arr, target, k\n\nassert f(*g())\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 470, "target_skills": [0, 0, 0, 1, 0, 0, 0, 0, 1, 0], "problem_func": "from typing import*\ndef f(arr: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Given an array of integers and a target value, find if there are k integers in the array that sum up to the target.\n    \"\"\"\n    arr.sort()\n    return any(sum(arr[i:i+k]) == target for i in range(len(arr)-k+1))", "solution_func": "def g():\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 15\n    k = 3\n    return arr, target, k", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Given two integers n and k, calculate the number of ways to choose k items from a set of n items.\n    \"\"\"\n    def factorial(n):\n        if n == 0 or n == 1:\n            return 1\n        return n * factorial(n-1)\n\n    return factorial(n) // (factorial(k) * factorial(n-k)) == 10\n\ndef g():\n    n = 10\n    k = 2\n    return n, k\n\nassert f(*g())\n", "emb": null, "idx_generation": 470, "target_skills": [0, 0, 1, 1, 1, 1, 1, 1, 1, 1], "problem_func": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Given two integers n and k, calculate the number of ways to choose k items from a set of n items.\n    \"\"\"\n    def factorial(n):\n        if n == 0 or n == 1:\n            return 1\n        return n * factorial(n-1)\n\n    return factorial(n) // (factorial(k) * factorial(n-k)) == 10", "solution_func": "def g():\n    n = 10\n    k = 2\n    return n, k", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    def add_edge(self, u, v):\n        self.graph[u][v] = 1\n        self.graph[v][u] = 1\n\n    def is_cyclic_util(self, v, visited, parent):\n        visited[v] = True\n\n        for i in range(self.V):\n            if self.graph[v][i] == 1:\n                if visited[i] == False:\n                    if self.is_cyclic_util(i, visited, v):\n                        return True\n                elif parent != i:\n                    return True\n\n        return False\n\n    def is_cyclic(self):\n        visited = [False] * self.V\n\n        for i in range(self.V):\n            if visited[i] == False:\n                if self.is_cyclic_util(i, visited, -1) == True:\n                    return True\n\n        return False\n\ndef f(edges: List[Tuple[int, int]]) -> bool:\n    \"\"\"\n    Given a list of edges in a graph, determine if the graph contains any cycles.\n    \"\"\"\n    g = Graph(len(edges))\n    for u, v in edges:\n        g.add_edge(u, v)\n\n    return g.is_cyclic()\n\ndef g():\n    edges = [(0, 1), (1, 2), (2, 0)]\n    return edges\n\nassert f(g())\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 470, "target_skills": [0, 1, 1, 0, 1, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    def add_edge(self, u, v):\n        self.graph[u][v] = 1\n        self.graph[v][u] = 1\n\n    def is_cyclic_util(self, v, visited, parent):\n        visited[v] = True\n\n        for i in range(self.V):\n            if self.graph[v][i] == 1:\n                if visited[i] == False:\n                    if self.is_cyclic_util(i, visited, v):\n                        return True\n                elif parent != i:\n                    return True\n\n        return False\n\n    def is_cyclic(self):\n        visited = [False] * self.V\n\n        for i in range(self.V):\n            if visited[i] == False:\n                if self.is_cyclic_util(i, visited, -1) == True:\n                    return True\n\n        return False\n\ndef f(edges: List[Tuple[int, int]]) -> bool:\n    \"\"\"\n    Given a list of edges in a graph, determine if the graph contains any cycles.\n    \"\"\"\n    g = Graph(len(edges))\n    for u, v in edges:\n        g.add_edge(u, v)\n\n    return g.is_cyclic()", "solution_func": "def g():\n    edges = [(0, 1), (1, 2), (2, 0)]\n    return edges", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the index of the target number in the list. If the target number is not in the list, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g() -> (List[int], int):\n    \"\"\"\n    Generate a list of integers and a target number. The target number is guaranteed to be in the list.\n    \"\"\"\n    nums = [2, 5, 7, 9, 12, 15, 18]\n    target = 9\n    return nums, target\n\nassert f(*g()) == 3\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0], "idx_generation": 470, "target_skills": [1, 0, 1, 1, 1, 1, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the index of the target number in the list. If the target number is not in the list, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1", "solution_func": "def g() -> (List[int], int):\n    \"\"\"\n    Generate a list of integers and a target number. The target number is guaranteed to be in the list.\n    \"\"\"\n    nums = [2, 5, 7, 9, 12, 15, 18]\n    target = 9\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> int:\n    \"\"\"\n    Given a string and a list of words, count the number of occurrences of each word in the string.\n    \"\"\"\n    counts = {word: 0 for word in words}\n    \n    for word in words:\n        start = 0\n        while start < len(s):\n            index = s.find(word, start)\n            if index == -1:\n                break\n            counts[word] += 1\n            start = index + len(word)\n    \n    return counts\n\ndef g() -> (str, List[str]):\n    \"\"\"\n    Generate a string and a list of words. The words are guaranteed to appear in the string.\n    \"\"\"\n    s = \"apple banana apple cherry banana\"\n    words = [\"apple\", \"banana\", \"cherry\"]\n    return s, words\n\nassert f(*g()) == {\"apple\": 2, \"banana\": 2, \"cherry\": 1}\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 470, "target_skills": [0, 1, 0, 0, 0, 0, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> int:\n    \"\"\"\n    Given a string and a list of words, count the number of occurrences of each word in the string.\n    \"\"\"\n    counts = {word: 0 for word in words}\n    \n    for word in words:\n        start = 0\n        while start < len(s):\n            index = s.find(word, start)\n            if index == -1:\n                break\n            counts[word] += 1\n            start = index + len(word)\n    \n    return counts", "solution_func": "def g() -> (str, List[str]):\n    \"\"\"\n    Generate a string and a list of words. The words are guaranteed to appear in the string.\n    \"\"\"\n    s = \"apple banana apple cherry banana\"\n    words = [\"apple\", \"banana\", \"cherry\"]\n    return s, words", "map_ix": [0, 1, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid represented as a list of lists of integers, find the minimum path sum from the top-left cell to the bottom-right cell. You can only move down or right.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers. The grid will be a 3x3 grid with random values.\n    \"\"\"\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return grid\n\nassert f(*g()) == 21\n", "emb": null, "idx_generation": 470, "target_skills": [0, 0, 1, 0, 0, 0, 1, 0, 0, 0], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid represented as a list of lists of integers, find the minimum path sum from the top-left cell to the bottom-right cell. You can only move down or right.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers. The grid will be a 3x3 grid with random values.\n    \"\"\"\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all positive integers less than n that are divisible by 3 or 5.\n    \"\"\"\n    total = 0\n    for i in range(1, n):\n        if i % 3 == 0 or i % 5 == 0:\n            total += i\n    return total\n\ndef g():\n    n = 20\n    return n\n\nassert f(g()) == 78\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 470, "target_skills": [1, 1, 0, 1, 0, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all positive integers less than n that are divisible by 3 or 5.\n    \"\"\"\n    total = 0\n    for i in range(1, n):\n        if i % 3 == 0 or i % 5 == 0:\n            total += i\n    return total", "solution_func": "def g():\n    n = 20\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nimport math\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a list of the square roots of the positive even numbers.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - A list of square roots of the positive even numbers in the input list.\n\n    Example:\n    Input:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    Output:\n    [1.4142135623730951, 2.0, 2.449489742783178, 2.8284271247461903, 3.1622776601683795]\n\n    Explanation:\n    The positive even numbers in the input list are [2, 4, 6, 8, 10].\n    The square roots of these numbers are [1.4142135623730951, 2.0, 2.449489742783178, 2.8284271247461903, 3.1622776601683795].\n    \"\"\"\n\n    even_nums = [num for num in nums if num % 2 == 0 and num > 0]\n    square_roots = [math.sqrt(num) for num in even_nums]\n\n    return square_roots\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return nums\n\nassert f(g()) == [1.4142135623730951, 2.0, 2.449489742783178, 2.8284271247461903, 3.1622776601683795]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 471, "target_skills": [1, 1, 1, 1, 1, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nimport math\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a list of the square roots of the positive even numbers.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - A list of square roots of the positive even numbers in the input list.\n\n    Example:\n    Input:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    Output:\n    [1.4142135623730951, 2.0, 2.449489742783178, 2.8284271247461903, 3.1622776601683795]\n\n    Explanation:\n    The positive even numbers in the input list are [2, 4, 6, 8, 10].\n    The square roots of these numbers are [1.4142135623730951, 2.0, 2.449489742783178, 2.8284271247461903, 3.1622776601683795].\n    \"\"\"\n\n    even_nums = [num for num in nums if num % 2 == 0 and num > 0]\n    square_roots = [math.sqrt(num) for num in even_nums]\n\n    return square_roots", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the count of all pairs of numbers whose sum is a perfect square.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The count of all pairs of numbers whose sum is a perfect square.\n\n    Example:\n    Input:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    Output:\n    6\n\n    Explanation:\n    The pairs of numbers whose sum is a perfect square are:\n    (1, 3), (2, 2), (3, 1), (4, 6), (6, 4), (8, 9).\n    The count of these pairs is 6.\n    \"\"\"\n\n    def is_perfect_square(num: int) -> bool:\n        sqrt = int(num ** 0.5)\n        return sqrt * sqrt == num\n\n    count = 0\n    n = len(nums)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_perfect_square(nums[i] + nums[j]):\n                count += 1\n\n    return count\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return nums\n\nassert f(g()) == 6\n", "emb": null, "idx_generation": 471, "target_skills": [1, 0, 1, 0, 0, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the count of all pairs of numbers whose sum is a perfect square.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The count of all pairs of numbers whose sum is a perfect square.\n\n    Example:\n    Input:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    Output:\n    6\n\n    Explanation:\n    The pairs of numbers whose sum is a perfect square are:\n    (1, 3), (2, 2), (3, 1), (4, 6), (6, 4), (8, 9).\n    The count of these pairs is 6.\n    \"\"\"\n\n    def is_perfect_square(num: int) -> bool:\n        sqrt = int(num ** 0.5)\n        return sqrt * sqrt == num\n\n    count = 0\n    n = len(nums)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_perfect_square(nums[i] + nums[j]):\n                count += 1\n\n    return count", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the product of the positive numbers that are divisible by 3 and have a 1 in their binary representation.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The product of the positive numbers that are divisible by 3 and have a 1 in their binary representation.\n\n    Example:\n    Input:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    Output:\n    7\n\n    Explanation:\n    The positive numbers that are divisible by 3 and have a 1 in their binary representation are:\n    3 (binary representation: 11), 5 (binary representation: 101), 9 (binary representation: 1001).\n    The product of these numbers is 3 * 5 * 9 = 135.\n    \"\"\"\n\n    def has_binary_one(num: int) -> bool:\n        return bin(num)[2:].count('1') > 0\n\n    product = 1\n\n    for num in nums:\n        if num > 0 and num % 3 == 0 and has_binary_one(num):\n            product *= num\n\n    return product\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return nums\n\nassert f(g()) == 7\n", "emb": null, "idx_generation": 471, "target_skills": [0, 1, 0, 1, 1, 1, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the product of the positive numbers that are divisible by 3 and have a 1 in their binary representation.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The product of the positive numbers that are divisible by 3 and have a 1 in their binary representation.\n\n    Example:\n    Input:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    Output:\n    7\n\n    Explanation:\n    The positive numbers that are divisible by 3 and have a 1 in their binary representation are:\n    3 (binary representation: 11), 5 (binary representation: 101), 9 (binary representation: 1001).\n    The product of these numbers is 3 * 5 * 9 = 135.\n    \"\"\"\n\n    def has_binary_one(num: int) -> bool:\n        return bin(num)[2:].count('1') > 0\n\n    product = 1\n\n    for num in nums:\n        if num > 0 and num % 3 == 0 and has_binary_one(num):\n            product *= num\n\n    return product", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, target: int) -> bool:\n    \"\"\"\n    Given an adjacency matrix 'graph', a starting node 'start', and a target node 'target',\n    determine if there is a path from 'start' to 'target' in the graph.\n\n    Args:\n    - graph: An adjacency matrix representing the graph.\n    - start: The starting node.\n    - target: The target node.\n\n    Returns:\n    - True if there is a path from 'start' to 'target', False otherwise.\n\n    Example:\n    graph = [[0, 1, 0, 0, 0],\n             [0, 0, 1, 0, 0],\n             [0, 0, 0, 1, 0],\n             [0, 0, 0, 0, 1],\n             [0, 0, 0, 0, 0]]\n\n    start = 0\n    target = 4\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 0 to node 4: 0 -> 1 -> 2 -> 3 -> 4.\n    \"\"\"\n\n    visited = [False] * len(graph)\n\n    def dfs(node):\n        if node == target:\n            return True\n\n        visited[node] = True\n\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n\n        return False\n\n    return dfs(start)\n\ndef g() -> Tuple[List[List[int]], int, int]:\n    \"\"\"\n    Generate an adjacency matrix representing a graph, a starting node, and a target node.\n    \"\"\"\n    graph = [[0, 1, 0, 0, 0],\n             [0, 0, 1, 0, 0],\n             [0, 0, 0, 1, 0],\n             [0, 0, 0, 0, 1],\n             [0, 0, 0, 0, 0]]\n\n    start = 0\n    target = 4\n\n    return graph, start, target\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 471, "target_skills": [0, 0, 0, 0, 1, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, target: int) -> bool:\n    \"\"\"\n    Given an adjacency matrix 'graph', a starting node 'start', and a target node 'target',\n    determine if there is a path from 'start' to 'target' in the graph.\n\n    Args:\n    - graph: An adjacency matrix representing the graph.\n    - start: The starting node.\n    - target: The target node.\n\n    Returns:\n    - True if there is a path from 'start' to 'target', False otherwise.\n\n    Example:\n    graph = [[0, 1, 0, 0, 0],\n             [0, 0, 1, 0, 0],\n             [0, 0, 0, 1, 0],\n             [0, 0, 0, 0, 1],\n             [0, 0, 0, 0, 0]]\n\n    start = 0\n    target = 4\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 0 to node 4: 0 -> 1 -> 2 -> 3 -> 4.\n    \"\"\"\n\n    visited = [False] * len(graph)\n\n    def dfs(node):\n        if node == target:\n            return True\n\n        visited[node] = True\n\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n\n        return False\n\n    return dfs(start)", "solution_func": "def g() -> Tuple[List[List[int]], int, int]:\n    \"\"\"\n    Generate an adjacency matrix representing a graph, a starting node, and a target node.\n    \"\"\"\n    graph = [[0, 1, 0, 0, 0],\n             [0, 0, 1, 0, 0],\n             [0, 0, 0, 1, 0],\n             [0, 0, 0, 0, 1],\n             [0, 0, 0, 0, 0]]\n\n    start = 0\n    target = 4\n\n    return graph, start, target", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, count the number of occurrences of a specific pattern.\n\n    Args:\n    - grid: A grid of characters.\n\n    Returns:\n    - The number of occurrences of the pattern.\n\n    Example:\n    grid = [['A', 'B', 'C', 'D'],\n            ['E', 'A', 'B', 'C'],\n            ['F', 'E', 'A', 'B'],\n            ['G', 'F', 'E', 'A']]\n\n    Output:\n    3\n\n    Explanation:\n    The pattern ['A', 'B', 'C'] appears 3 times in the grid: once starting from (0, 1), once starting from (1, 2), and once starting from (2, 3).\n    \"\"\"\n\n    pattern = ['A', 'B', 'C']\n    count = 0\n\n    for i in range(len(grid) - len(pattern) + 1):\n        for j in range(len(grid[0]) - len(pattern) + 1):\n            found = True\n            for k in range(len(pattern)):\n                if grid[i+k][j+k] != pattern[k]:\n                    found = False\n                    break\n            if found:\n                count += 1\n\n    return count\n\ndef g() -> List[List[str]]:\n    \"\"\"\n    Generate a grid of characters.\n    \"\"\"\n    grid = [['A', 'B', 'C', 'D'],\n            ['E', 'A', 'B', 'C'],\n            ['F', 'E', 'A', 'B'],\n            ['G', 'F', 'E', 'A']]\n\n    return grid\n\nassert f(g()) == 3\n\n", "emb": null, "idx_generation": 471, "target_skills": [1, 0, 1, 0, 0, 0, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, count the number of occurrences of a specific pattern.\n\n    Args:\n    - grid: A grid of characters.\n\n    Returns:\n    - The number of occurrences of the pattern.\n\n    Example:\n    grid = [['A', 'B', 'C', 'D'],\n            ['E', 'A', 'B', 'C'],\n            ['F', 'E', 'A', 'B'],\n            ['G', 'F', 'E', 'A']]\n\n    Output:\n    3\n\n    Explanation:\n    The pattern ['A', 'B', 'C'] appears 3 times in the grid: once starting from (0, 1), once starting from (1, 2), and once starting from (2, 3).\n    \"\"\"\n\n    pattern = ['A', 'B', 'C']\n    count = 0\n\n    for i in range(len(grid) - len(pattern) + 1):\n        for j in range(len(grid[0]) - len(pattern) + 1):\n            found = True\n            for k in range(len(pattern)):\n                if grid[i+k][j+k] != pattern[k]:\n                    found = False\n                    break\n            if found:\n                count += 1\n\n    return count", "solution_func": "def g() -> List[List[str]]:\n    \"\"\"\n    Generate a grid of characters.\n    \"\"\"\n    grid = [['A', 'B', 'C', 'D'],\n            ['E', 'A', 'B', 'C'],\n            ['F', 'E', 'A', 'B'],\n            ['G', 'F', 'E', 'A']]\n\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums' and a target value 'target',\n    find two numbers in the list that sum up to the target.\n\n    Args:\n    - nums: A list of integers.\n    - target: The target value.\n\n    Returns:\n    - A list of two numbers that sum up to the target.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [2, 7]\n\n    Explanation:\n    The numbers 2 and 7 sum up to the target value 9.\n    \"\"\"\n\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 471, "target_skills": [1, 1, 0, 0, 1, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums' and a target value 'target',\n    find two numbers in the list that sum up to the target.\n\n    Args:\n    - nums: A list of integers.\n    - target: The target value.\n\n    Returns:\n    - A list of two numbers that sum up to the target.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [2, 7]\n\n    Explanation:\n    The numbers 2 and 7 sum up to the target value 9.\n    \"\"\"\n\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    return nums, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum product of any two numbers in the list.\n\n    Parameters:\n    nums (List[int]): The input list of integers.\n\n    Returns:\n    int: The maximum product of any two numbers in the list.\n    \"\"\"\n    if len(nums) < 2:\n        return 0\n\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n\n    return max_product\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n\n    Returns:\n    List[int]: A list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 20\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 471, "target_skills": [1, 0, 0, 0, 1, 0, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum product of any two numbers in the list.\n\n    Parameters:\n    nums (List[int]): The input list of integers.\n\n    Returns:\n    int: The maximum product of any two numbers in the list.\n    \"\"\"\n    if len(nums) < 2:\n        return 0\n\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n\n    return max_product", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n\n    Returns:\n    List[int]: A list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct pairs that sum up to a target value.\n\n    Parameters:\n    nums (List[int]): The input list of integers.\n\n    Returns:\n    int: The number of distinct pairs that sum up to a target value.\n    \"\"\"\n    count = 0\n    seen = set()\n\n    for num in nums:\n        target = -num\n        if target in seen:\n            count += 1\n        seen.add(num)\n\n    return count\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n\n    Returns:\n    List[int]: A list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 0\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 471, "target_skills": [1, 0, 1, 0, 0, 0, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct pairs that sum up to a target value.\n\n    Parameters:\n    nums (List[int]): The input list of integers.\n\n    Returns:\n    int: The number of distinct pairs that sum up to a target value.\n    \"\"\"\n    count = 0\n    seen = set()\n\n    for num in nums:\n        target = -num\n        if target in seen:\n            count += 1\n        seen.add(num)\n\n    return count", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n\n    Returns:\n    List[int]: A list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the other elements.\n\n    Parameters:\n    nums (List[int]): The input list of integers.\n\n    Returns:\n    List[int]: A new list where each element is the product of all the other elements.\n    \"\"\"\n    n = len(nums)\n    result = [1] * n\n\n    left_product = 1\n    for i in range(n):\n        result[i] *= left_product\n        left_product *= nums[i]\n\n    right_product = 1\n    for i in range(n-1, -1, -1):\n        result[i] *= right_product\n        right_product *= nums[i]\n\n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n\n    Returns:\n    List[int]: A list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [120, 60, 40, 30, 24]\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 471, "target_skills": [1, 0, 1, 1, 0, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the other elements.\n\n    Parameters:\n    nums (List[int]): The input list of integers.\n\n    Returns:\n    List[int]: A new list where each element is the product of all the other elements.\n    \"\"\"\n    n = len(nums)\n    result = [1] * n\n\n    left_product = 1\n    for i in range(n):\n        result[i] *= left_product\n        left_product *= nums[i]\n\n    right_product = 1\n    for i in range(n-1, -1, -1):\n        result[i] *= right_product\n        right_product *= nums[i]\n\n    return result", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n\n    Returns:\n    List[int]: A list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]", "map_ix": [1, 1, 0, 1, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum XOR value that can be obtained by selecting one element from each row.\n    The XOR value is obtained by performing a bitwise XOR operation on the selected elements.\n\n    Example:\n    grid = [\n        [2, 5, 9],\n        [3, 8, 12],\n        [7, 10, 15]\n    ]\n\n    Output:\n    14\n\n    Explanation:\n    Selecting the elements 9, 8, and 7 results in the maximum XOR value of 14: (9 ^ 8 ^ 7 = 14).\n    \"\"\"\n\n    max_xor = 0\n    for row in grid:\n        xor_value = 0\n        for num in row:\n            xor_value = xor_value ^ num\n        max_xor = max(max_xor, xor_value)\n\n    return max_xor\n\ndef g(grid: List[List[int]] = [[2, 5, 9], [3, 8, 12], [7, 10, 15]]):\n    return (grid,)\n\nassert f(*g()) == 14\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 471, "target_skills": [1, 1, 0, 1, 1, 0, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum XOR value that can be obtained by selecting one element from each row.\n    The XOR value is obtained by performing a bitwise XOR operation on the selected elements.\n\n    Example:\n    grid = [\n        [2, 5, 9],\n        [3, 8, 12],\n        [7, 10, 15]\n    ]\n\n    Output:\n    14\n\n    Explanation:\n    Selecting the elements 9, 8, and 7 results in the maximum XOR value of 14: (9 ^ 8 ^ 7 = 14).\n    \"\"\"\n\n    max_xor = 0\n    for row in grid:\n        xor_value = 0\n        for num in row:\n            xor_value = xor_value ^ num\n        max_xor = max(max_xor, xor_value)\n\n    return max_xor", "solution_func": "def g(grid: List[List[int]] = [[2, 5, 9], [3, 8, 12], [7, 10, 15]]):\n    return (grid,)", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, n: int) -> str:\n    \"\"\"\n    Given a string s and an integer n, rotate the string to the right by n positions.\n\n    Example:\n    s = \"abcdefg\"\n    n = 3\n\n    Output:\n    \"efgabcd\"\n\n    Explanation:\n    The string is rotated to the right by 3 positions, resulting in \"efgabcd\".\n    \"\"\"\n    if n == 0:\n        return s\n\n    n = n % len(s)\n    rotated = s[-n:] + s[:-n]\n    return rotated\n\ndef g(s=\"abcdefg\", n=3):\n    return s, n\n\nassert f(*g()) == \"efgabcd\"\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 472, "target_skills": [0, 1, 0, 1, 1, 1, 1, 1, 1, 0], "problem_func": "from typing import*\ndef f(s: str, n: int) -> str:\n    \"\"\"\n    Given a string s and an integer n, rotate the string to the right by n positions.\n\n    Example:\n    s = \"abcdefg\"\n    n = 3\n\n    Output:\n    \"efgabcd\"\n\n    Explanation:\n    The string is rotated to the right by 3 positions, resulting in \"efgabcd\".\n    \"\"\"\n    if n == 0:\n        return s\n\n    n = n % len(s)\n    rotated = s[-n:] + s[:-n]\n    return rotated", "solution_func": "def g(s=\"abcdefg\", n=3):\n    return s, n", "map_ix": [0, 0, 0, 1, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the number of unique paths from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Args:\n    - grid: A 2D grid of non-negative integers.\n\n    Returns:\n    - The number of unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    return grid\n\nassert f(g()) == 6\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 472, "target_skills": [0, 1, 0, 1, 0, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the number of unique paths from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Args:\n    - grid: A 2D grid of non-negative integers.\n\n    Returns:\n    - The number of unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[m-1][n-1]", "solution_func": "def g() -> List[List[int]]:\n    grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    return grid", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the index of the first occurrence of the target number using binary search.\n\n    Args:\n    - arr: A sorted list of integers.\n\n    Returns:\n    - The index of the first occurrence of the target number, or -1 if the target number is not found.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            if mid == 0 or arr[mid-1] != target:\n                return mid\n            else:\n                right = mid - 1\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(arr=[1, 2, 3, 3, 3, 4, 5]):\n    return arr\n\nassert f(g()) == 2\n", "emb": null, "idx_generation": 472, "target_skills": [1, 0, 1, 0, 0, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the index of the first occurrence of the target number using binary search.\n\n    Args:\n    - arr: A sorted list of integers.\n\n    Returns:\n    - The index of the first occurrence of the target number, or -1 if the target number is not found.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            if mid == 0 or arr[mid-1] != target:\n                return mid\n            else:\n                right = mid - 1\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g(arr=[1, 2, 3, 3, 3, 4, 5]):\n    return arr", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(sentences: List[str]) -> str:\n    \"\"\"\n    Given a list of sentences, find the sentence with the maximum number of words.\n    Return that sentence.\n\n    Example:\n    sentences = [\"I love coding\", \"Coding is fun\", \"Python is awesome\"]\n\n    Output:\n    \"Python is awesome\"\n\n    Hint: Split each sentence into words and count the number of words in each sentence.\n    \"\"\"\n\n    max_sentence = \"\"\n    max_words = 0\n\n    for sentence in sentences:\n        words = sentence.split()\n        if len(words) > max_words:\n            max_sentence = sentence\n            max_words = len(words)\n    \n    return max_sentence\n\ndef g() -> List[str]:\n    \"\"\"\n    Return a list of sentences.\n    \"\"\"\n    return [\"I love coding\", \"Coding is fun\", \"Python is awesome\"]\n\nassert f(g()) == \"Python is awesome\"\n\n", "emb": null, "idx_generation": 472, "target_skills": [1, 1, 1, 0, 0, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(sentences: List[str]) -> str:\n    \"\"\"\n    Given a list of sentences, find the sentence with the maximum number of words.\n    Return that sentence.\n\n    Example:\n    sentences = [\"I love coding\", \"Coding is fun\", \"Python is awesome\"]\n\n    Output:\n    \"Python is awesome\"\n\n    Hint: Split each sentence into words and count the number of words in each sentence.\n    \"\"\"\n\n    max_sentence = \"\"\n    max_words = 0\n\n    for sentence in sentences:\n        words = sentence.split()\n        if len(words) > max_words:\n            max_sentence = sentence\n            max_words = len(words)\n    \n    return max_sentence", "solution_func": "def g() -> List[str]:\n    \"\"\"\n    Return a list of sentences.\n    \"\"\"\n    return [\"I love coding\", \"Coding is fun\", \"Python is awesome\"]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int]) -> int:\n    \"\"\"\n    Given a list of numbers, find the product of all the positive numbers in the list.\n    Return the product.\n\n    Example:\n    numbers = [2, -5, 3, -7, 4]\n\n    Output:\n    24 (2 * 3 * 4)\n\n    Hint: Iterate through the list and multiply all the positive numbers together.\n    \"\"\"\n\n    product = 1\n\n    for number in numbers:\n        if number > 0:\n            product *= number\n    \n    return product\n\ndef g() -> List[int]:\n    \"\"\"\n    Return a list of numbers.\n    \"\"\"\n    return [2, -5, 3, -7, 4]\n\nassert f(g()) == 24\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 472, "target_skills": [0, 0, 1, 1, 1, 0, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int]) -> int:\n    \"\"\"\n    Given a list of numbers, find the product of all the positive numbers in the list.\n    Return the product.\n\n    Example:\n    numbers = [2, -5, 3, -7, 4]\n\n    Output:\n    24 (2 * 3 * 4)\n\n    Hint: Iterate through the list and multiply all the positive numbers together.\n    \"\"\"\n\n    product = 1\n\n    for number in numbers:\n        if number > 0:\n            product *= number\n    \n    return product", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Return a list of numbers.\n    \"\"\"\n    return [2, -5, 3, -7, 4]", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of numbers, find all the prime numbers in the list.\n    Return a list containing the prime numbers.\n\n    Example:\n    numbers = [2, 3, 4, 5, 6, 7, 8, 9]\n\n    Output:\n    [2, 3, 5, 7]\n\n    Hint: Iterate through the list and check if each number is prime.\n    \"\"\"\n\n    def is_prime(number):\n        if number < 2:\n            return False\n        \n        for i in range(2, int(number**0.5) + 1):\n            if number % i == 0:\n                return False\n        \n        return True\n\n    prime_numbers = []\n\n    for number in numbers:\n        if is_prime(number):\n            prime_numbers.append(number)\n    \n    return prime_numbers\n\ndef g() -> List[int]:\n    \"\"\"\n    Return a list of numbers.\n    \"\"\"\n    return [2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g()) == [2, 3, 5, 7]\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 472, "target_skills": [0, 1, 1, 1, 1, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of numbers, find all the prime numbers in the list.\n    Return a list containing the prime numbers.\n\n    Example:\n    numbers = [2, 3, 4, 5, 6, 7, 8, 9]\n\n    Output:\n    [2, 3, 5, 7]\n\n    Hint: Iterate through the list and check if each number is prime.\n    \"\"\"\n\n    def is_prime(number):\n        if number < 2:\n            return False\n        \n        for i in range(2, int(number**0.5) + 1):\n            if number % i == 0:\n                return False\n        \n        return True\n\n    prime_numbers = []\n\n    for number in numbers:\n        if is_prime(number):\n            prime_numbers.append(number)\n    \n    return prime_numbers", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Return a list of numbers.\n    \"\"\"\n    return [2, 3, 4, 5, 6, 7, 8, 9]", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers, find two numbers that sum up to a target value.\n\n    Args:\n    - arr: A sorted list of integers.\n    - target: The target sum.\n\n    Returns:\n    - A list of two integers that sum up to the target value, or an empty list if no such pair exists.\n\n    Example:\n    Input:\n    arr = [-2, 0, 2, 4, 7, 11]\n    target = 9\n\n    Output:\n    [2, 7]\n\n    Explanation:\n    The two numbers that sum up to 9 are 2 and 7.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n\n        if current_sum == target:\n            return [arr[left], arr[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers.\n    \"\"\"\n    return [-2, 0, 2, 4, 7, 11]\n\nassert f(g(), 9) == [2, 7]\n", "emb": null, "idx_generation": 472, "target_skills": [1, 0, 1, 1, 1, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers, find two numbers that sum up to a target value.\n\n    Args:\n    - arr: A sorted list of integers.\n    - target: The target sum.\n\n    Returns:\n    - A list of two integers that sum up to the target value, or an empty list if no such pair exists.\n\n    Example:\n    Input:\n    arr = [-2, 0, 2, 4, 7, 11]\n    target = 9\n\n    Output:\n    [2, 7]\n\n    Explanation:\n    The two numbers that sum up to 9 are 2 and 7.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n\n        if current_sum == target:\n            return [arr[left], arr[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers.\n    \"\"\"\n    return [-2, 0, 2, 4, 7, 11]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: dict, start='A', end='E') -> List[str]:\n    \"\"\"\n    Find the shortest path from the start node to the end node in a given graph using breadth-first search.\n\n    Args:\n    - graph: A dictionary representing the graph.\n    - start: The start node.\n    - end: The end node.\n\n    Returns:\n    - A list of nodes representing the shortest path from the start to the end node, or an empty list if no path exists.\n\n    Example:\n    Input:\n    graph = {'A': ['B', 'C'],\n             'B': ['D', 'E'],\n             'C': ['F'],\n             'D': [],\n             'E': [],\n             'F': []}\n    start = 'A'\n    end = 'E'\n\n    Output:\n    ['A', 'B', 'E']\n\n    Explanation:\n    The shortest path from 'A' to 'E' is ['A', 'B', 'E'].\n    \"\"\"\n\n    queue = [(start, [start])]\n    visited = set()\n\n    while queue:\n        node, path = queue.pop(0)\n\n        if node == end:\n            return path\n\n        if node not in visited:\n            visited.add(node)\n\n            for neighbor in graph[node]:\n                queue.append((neighbor, path + [neighbor]))\n\n    return []\n\ndef g() -> dict:\n    \"\"\"\n    Generate a graph.\n    \"\"\"\n    graph = {'A': ['B', 'C'],\n             'B': ['D', 'E'],\n             'C': ['F'],\n             'D': [],\n             'E': [],\n             'F': []}\n    return graph\n\nassert f(g(), 'A', 'E') == ['A', 'B', 'E']\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 472, "target_skills": [1, 0, 0, 1, 0, 1, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: dict, start='A', end='E') -> List[str]:\n    \"\"\"\n    Find the shortest path from the start node to the end node in a given graph using breadth-first search.\n\n    Args:\n    - graph: A dictionary representing the graph.\n    - start: The start node.\n    - end: The end node.\n\n    Returns:\n    - A list of nodes representing the shortest path from the start to the end node, or an empty list if no path exists.\n\n    Example:\n    Input:\n    graph = {'A': ['B', 'C'],\n             'B': ['D', 'E'],\n             'C': ['F'],\n             'D': [],\n             'E': [],\n             'F': []}\n    start = 'A'\n    end = 'E'\n\n    Output:\n    ['A', 'B', 'E']\n\n    Explanation:\n    The shortest path from 'A' to 'E' is ['A', 'B', 'E'].\n    \"\"\"\n\n    queue = [(start, [start])]\n    visited = set()\n\n    while queue:\n        node, path = queue.pop(0)\n\n        if node == end:\n            return path\n\n        if node not in visited:\n            visited.add(node)\n\n            for neighbor in graph[node]:\n                queue.append((neighbor, path + [neighbor]))\n\n    return []", "solution_func": "def g() -> dict:\n    \"\"\"\n    Generate a graph.\n    \"\"\"\n    graph = {'A': ['B', 'C'],\n             'B': ['D', 'E'],\n             'C': ['F'],\n             'D': [],\n             'E': [],\n             'F': []}\n    return graph", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number using dynamic programming.\n\n    Args:\n    - n: The index of the Fibonacci number to calculate.\n\n    Returns:\n    - The n-th Fibonacci number.\n\n    Example:\n    Input:\n    n = 6\n\n    Output:\n    8\n\n    Explanation:\n    The 6th Fibonacci number is 8.\n    \"\"\"\n\n    if n <= 1:\n        return n\n\n    fib = [0] * (n + 1)\n    fib[1] = 1\n\n    for i in range(2, n + 1):\n        fib[i] = fib[i - 1] + fib[i - 2]\n\n    return fib[n]\n\ndef g() -> int:\n    \"\"\"\n    Generate an integer.\n    \"\"\"\n    return 6\n\nassert f(g()) == 8\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 472, "target_skills": [1, 1, 0, 0, 1, 1, 1, 1, 1, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number using dynamic programming.\n\n    Args:\n    - n: The index of the Fibonacci number to calculate.\n\n    Returns:\n    - The n-th Fibonacci number.\n\n    Example:\n    Input:\n    n = 6\n\n    Output:\n    8\n\n    Explanation:\n    The 6th Fibonacci number is 8.\n    \"\"\"\n\n    if n <= 1:\n        return n\n\n    fib = [0] * (n + 1)\n    fib[1] = 1\n\n    for i in range(2, n + 1):\n        fib[i] = fib[i - 1] + fib[i - 2]\n\n    return fib[n]", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate an integer.\n    \"\"\"\n    return 6", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique combinations that add up to the target sum.\n\n    Return the number of unique combinations.\n\n    Example:\n    arr = [2, 3, 6, 7]\n    target = 7\n\n    Output:\n    2\n\n    Explanation:\n    The unique combinations that sum up to 7 are [2, 2, 3] and [7].\n    \"\"\"\n    def backtrack(arr, target, start, path, result):\n        if target == 0:\n            result.append(path)\n            return\n        if target < 0:\n            return\n        \n        for i in range(start, len(arr)):\n            backtrack(arr, target - arr[i], i, path + [arr[i]], result)\n    \n    target = 7\n    result = []\n    backtrack(arr, target, 0, [], result)\n    return len(result)\n\ndef g(arr=[2, 3, 6, 7]):\n    return arr\n\nassert f(g()) == 2\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 472, "target_skills": [1, 1, 0, 0, 0, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique combinations that add up to the target sum.\n\n    Return the number of unique combinations.\n\n    Example:\n    arr = [2, 3, 6, 7]\n    target = 7\n\n    Output:\n    2\n\n    Explanation:\n    The unique combinations that sum up to 7 are [2, 2, 3] and [7].\n    \"\"\"\n    def backtrack(arr, target, start, path, result):\n        if target == 0:\n            result.append(path)\n            return\n        if target < 0:\n            return\n        \n        for i in range(start, len(arr)):\n            backtrack(arr, target - arr[i], i, path + [arr[i]], result)\n    \n    target = 7\n    result = []\n    backtrack(arr, target, 0, [], result)\n    return len(result)", "solution_func": "def g(arr=[2, 3, 6, 7]):\n    return arr", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\n\n\nclass TreeNode:\n    def __init__(self, val: int = 0, left: 'TreeNode' = None, right: 'TreeNode' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef f(root: TreeNode) -> bool:\n    \"\"\"\n    Given a binary tree, determine if it is a valid binary search tree (BST).\n\n    Args:\n    - root: The root node of the binary tree.\n\n    Returns:\n    - True if the binary tree is a valid BST, False otherwise.\n\n    Example:\n    root = TreeNode(5)\n    root.left = TreeNode(3)\n    root.right = TreeNode(7)\n    root.left.left = TreeNode(2)\n    root.left.right = TreeNode(4)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(8)\n\n    Output:\n    True\n\n    Explanation:\n    The binary tree is a valid BST as each node's value is greater than all the values in its left subtree and less than all the values in its right subtree.\n    \"\"\"\n\n    def is_bst(node: TreeNode, min_val: float, max_val: float) -> bool:\n        if not node:\n            return True\n        if node.val <= min_val or node.val >= max_val:\n            return False\n        return is_bst(node.left, min_val, node.val) and is_bst(node.right, node.val, max_val)\n\n    return is_bst(root, float('-inf'), float('inf'))\n\n\ndef g() -> TreeNode:\n    root = TreeNode(5)\n    root.left = TreeNode(3)\n    root.right = TreeNode(7)\n    root.left.left = TreeNode(2)\n    root.left.right = TreeNode(4)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(8)\n    return root\n\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0], "idx_generation": 473, "target_skills": [0, 0, 1, 1, 0, 0, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import *\n\n\nclass TreeNode:\n    def __init__(self, val: int = 0, left: 'TreeNode' = None, right: 'TreeNode' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef f(root: TreeNode) -> bool:\n    \"\"\"\n    Given a binary tree, determine if it is a valid binary search tree (BST).\n\n    Args:\n    - root: The root node of the binary tree.\n\n    Returns:\n    - True if the binary tree is a valid BST, False otherwise.\n\n    Example:\n    root = TreeNode(5)\n    root.left = TreeNode(3)\n    root.right = TreeNode(7)\n    root.left.left = TreeNode(2)\n    root.left.right = TreeNode(4)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(8)\n\n    Output:\n    True\n\n    Explanation:\n    The binary tree is a valid BST as each node's value is greater than all the values in its left subtree and less than all the values in its right subtree.\n    \"\"\"\n\n    def is_bst(node: TreeNode, min_val: float, max_val: float) -> bool:\n        if not node:\n            return True\n        if node.val <= min_val or node.val >= max_val:\n            return False\n        return is_bst(node.left, min_val, node.val) and is_bst(node.right, node.val, max_val)\n\n    return is_bst(root, float('-inf'), float('inf'))", "solution_func": "def g() -> TreeNode:\n    root = TreeNode(5)\n    root.left = TreeNode(3)\n    root.right = TreeNode(7)\n    root.left.left = TreeNode(2)\n    root.left.right = TreeNode(4)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(8)\n    return root", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\n\n\nclass Graph:\n    def __init__(self, num_vertices: int):\n        self.num_vertices = num_vertices\n        self.adj_list = [[] for _ in range(num_vertices)]\n\n    def add_edge(self, src: int, dest: int) -> None:\n        self.adj_list[src].append(dest)\n\n    def is_cyclic_util(self, v: int, visited: List[bool], stack: List[bool]) -> bool:\n        visited[v] = True\n        stack[v] = True\n\n        for neighbor in self.adj_list[v]:\n            if not visited[neighbor]:\n                if self.is_cyclic_util(neighbor, visited, stack):\n                    return True\n            elif stack[neighbor]:\n                return True\n\n        stack[v] = False\n        return False\n\n    def is_cyclic(self) -> bool:\n        visited = [False] * self.num_vertices\n        stack = [False] * self.num_vertices\n\n        for v in range(self.num_vertices):\n            if not visited[v]:\n                if self.is_cyclic_util(v, visited, stack):\n                    return True\n\n        return False\n\n\ndef f(graph: Graph) -> bool:\n    \"\"\"\n    Given a directed graph, determine if it contains a cycle.\n\n    Args:\n    - graph: The directed graph represented as an adjacency list.\n\n    Returns:\n    - True if the graph contains a cycle, False otherwise.\n\n    Example:\n    graph = Graph(4)\n    graph.add_edge(0, 1)\n    graph.add_edge(1, 2)\n    graph.add_edge(2, 0)\n    graph.add_edge(2, 3)\n\n    Output:\n    True\n\n    Explanation:\n    The graph contains a cycle: 0 -> 1 -> 2 -> 0.\n    \"\"\"\n\n    return graph.is_cyclic()\n\n\ndef g() -> Graph:\n    graph = Graph(4)\n    graph.add_edge(0, 1)\n    graph.add_edge(1, 2)\n    graph.add_edge(2, 0)\n    graph.add_edge(2, 3)\n    return graph\n\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 473, "target_skills": [0, 0, 1, 0, 0, 1, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import *\n\n\nclass Graph:\n    def __init__(self, num_vertices: int):\n        self.num_vertices = num_vertices\n        self.adj_list = [[] for _ in range(num_vertices)]\n\n    def add_edge(self, src: int, dest: int) -> None:\n        self.adj_list[src].append(dest)\n\n    def is_cyclic_util(self, v: int, visited: List[bool], stack: List[bool]) -> bool:\n        visited[v] = True\n        stack[v] = True\n\n        for neighbor in self.adj_list[v]:\n            if not visited[neighbor]:\n                if self.is_cyclic_util(neighbor, visited, stack):\n                    return True\n            elif stack[neighbor]:\n                return True\n\n        stack[v] = False\n        return False\n\n    def is_cyclic(self) -> bool:\n        visited = [False] * self.num_vertices\n        stack = [False] * self.num_vertices\n\n        for v in range(self.num_vertices):\n            if not visited[v]:\n                if self.is_cyclic_util(v, visited, stack):\n                    return True\n\n        return False\n\n\ndef f(graph: Graph) -> bool:\n    \"\"\"\n    Given a directed graph, determine if it contains a cycle.\n\n    Args:\n    - graph: The directed graph represented as an adjacency list.\n\n    Returns:\n    - True if the graph contains a cycle, False otherwise.\n\n    Example:\n    graph = Graph(4)\n    graph.add_edge(0, 1)\n    graph.add_edge(1, 2)\n    graph.add_edge(2, 0)\n    graph.add_edge(2, 3)\n\n    Output:\n    True\n\n    Explanation:\n    The graph contains a cycle: 0 -> 1 -> 2 -> 0.\n    \"\"\"\n\n    return graph.is_cyclic()", "solution_func": "def g() -> Graph:\n    graph = Graph(4)\n    graph.add_edge(0, 1)\n    graph.add_edge(1, 2)\n    graph.add_edge(2, 0)\n    graph.add_edge(2, 3)\n    return graph", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\n\n\nclass Queue:\n    def __init__(self):\n        self.queue = []\n\n    def enqueue(self, item: int) -> None:\n        self.queue.append(item)\n\n    def dequeue(self) -> int:\n        return self.queue.pop(0)\n\n    def is_empty(self) -> bool:\n        return len(self.queue) == 0\n\n\ndef f(graph: Dict[int, List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph and a source node, determine if it is possible to reach all other nodes from the source node.\n\n    Args:\n    - graph: The undirected graph represented as an adjacency list.\n\n    Returns:\n    - True if all other nodes can be reached from the source node, False otherwise.\n\n    Example:\n    graph = {\n        0: [1, 2],\n        1: [0],\n        2: [0, 3],\n        3: [2]\n    }\n\n    Output:\n    True\n\n    Explanation:\n    All other nodes can be reached from the source node 0.\n    \"\"\"\n\n    source = 0\n    visited = set()\n\n    queue = Queue()\n    queue.enqueue(source)\n    visited.add(source)\n\n    while not queue.is_empty():\n        node = queue.dequeue()\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                queue.enqueue(neighbor)\n                visited.add(neighbor)\n\n    return len(visited) == len(graph)\n\n\ndef g() -> Dict[int, List[int]]:\n    graph = {\n        0: [1, 2],\n        1: [0],\n        2: [0, 3],\n        3: [2]\n    }\n    return graph\n\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 473, "target_skills": [0, 1, 1, 1, 0, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import *\n\n\nclass Queue:\n    def __init__(self):\n        self.queue = []\n\n    def enqueue(self, item: int) -> None:\n        self.queue.append(item)\n\n    def dequeue(self) -> int:\n        return self.queue.pop(0)\n\n    def is_empty(self) -> bool:\n        return len(self.queue) == 0\n\n\ndef f(graph: Dict[int, List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph and a source node, determine if it is possible to reach all other nodes from the source node.\n\n    Args:\n    - graph: The undirected graph represented as an adjacency list.\n\n    Returns:\n    - True if all other nodes can be reached from the source node, False otherwise.\n\n    Example:\n    graph = {\n        0: [1, 2],\n        1: [0],\n        2: [0, 3],\n        3: [2]\n    }\n\n    Output:\n    True\n\n    Explanation:\n    All other nodes can be reached from the source node 0.\n    \"\"\"\n\n    source = 0\n    visited = set()\n\n    queue = Queue()\n    queue.enqueue(source)\n    visited.add(source)\n\n    while not queue.is_empty():\n        node = queue.dequeue()\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                queue.enqueue(neighbor)\n                visited.add(neighbor)\n\n    return len(visited) == len(graph)", "solution_func": "def g() -> Dict[int, List[int]]:\n    graph = {\n        0: [1, 2],\n        1: [0],\n        2: [0, 3],\n        3: [2]\n    }\n    return graph", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, path: str) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency list, a start node, an end node, and a path string,\n    determine if there exists a path from the start node to the end node that follows the given path string.\n\n    Return True if a valid path exists, otherwise return False.\n\n    Example:\n    graph = [\n        [1],\n        [0, 2],\n        [1, 3],\n        [2, 4],\n        [3]\n    ]\n    start = 0\n    end = 4\n    path = \"LRD\"\n\n    Output:\n    True\n\n    Explanation:\n    The path \"LRD\" represents the path from node 0 to node 4, which exists in the graph.\n    \"\"\"\n\n    def dfs(node, path_idx):\n        if path_idx == len(path):\n            return node == end\n\n        neighbors = graph[node]\n        for neighbor in neighbors:\n            if path[path_idx] == \"L\":\n                if dfs(neighbor, path_idx + 1):\n                    return True\n            elif path[path_idx] == \"R\":\n                if dfs(neighbor, path_idx + 1):\n                    return True\n            elif path[path_idx] == \"D\":\n                if dfs(neighbor, path_idx + 1):\n                    return True\n\n        return False\n\n    return dfs(start, 0)\n\ndef g() -> Tuple[List[List[int]], int, int, str]:\n    \"\"\"\n    Generate a graph represented as an adjacency list, a start node, an end node, and a path string.\n\n    Returns:\n    - The generated graph, start node, end node, and path string.\n\n    Example:\n    g() returns ([[1], [0, 2], [1, 3], [2, 4], [3]], 0, 4, \"LRD\")\n    \"\"\"\n\n    return ([[1], [0, 2], [1, 3], [2, 4], [3]], 0, 4, \"LRD\")\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 473, "target_skills": [0, 1, 0, 1, 1, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, path: str) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency list, a start node, an end node, and a path string,\n    determine if there exists a path from the start node to the end node that follows the given path string.\n\n    Return True if a valid path exists, otherwise return False.\n\n    Example:\n    graph = [\n        [1],\n        [0, 2],\n        [1, 3],\n        [2, 4],\n        [3]\n    ]\n    start = 0\n    end = 4\n    path = \"LRD\"\n\n    Output:\n    True\n\n    Explanation:\n    The path \"LRD\" represents the path from node 0 to node 4, which exists in the graph.\n    \"\"\"\n\n    def dfs(node, path_idx):\n        if path_idx == len(path):\n            return node == end\n\n        neighbors = graph[node]\n        for neighbor in neighbors:\n            if path[path_idx] == \"L\":\n                if dfs(neighbor, path_idx + 1):\n                    return True\n            elif path[path_idx] == \"R\":\n                if dfs(neighbor, path_idx + 1):\n                    return True\n            elif path[path_idx] == \"D\":\n                if dfs(neighbor, path_idx + 1):\n                    return True\n\n        return False\n\n    return dfs(start, 0)", "solution_func": "def g() -> Tuple[List[List[int]], int, int, str]:\n    \"\"\"\n    Generate a graph represented as an adjacency list, a start node, an end node, and a path string.\n\n    Returns:\n    - The generated graph, start node, end node, and path string.\n\n    Example:\n    g() returns ([[1], [0, 2], [1, 3], [2, 4], [3]], 0, 4, \"LRD\")\n    \"\"\"\n\n    return ([[1], [0, 2], [1, 3], [2, 4], [3]], 0, 4, \"LRD\")", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a square subgrid.\n\n    Return the maximum sum.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    45\n\n    Explanation:\n    The maximum sum is obtained from the subgrid [5, 6, 8, 9], which sums up to 45.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    max_sum = float(\"-inf\")\n\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(i, rows):\n                for l in range(j, cols):\n                    subgrid_sum = 0\n                    for m in range(i, k+1):\n                        for n in range(j, l+1):\n                            subgrid_sum += grid[m][n]\n                    max_sum = max(max_sum, subgrid_sum)\n\n    return max_sum\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers.\n\n    Returns:\n    - The generated grid.\n\n    Example:\n    g() returns [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    \"\"\"\n\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 45\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 473, "target_skills": [1, 0, 0, 0, 0, 1, 0, 0, 0, 1], "problem_func": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a square subgrid.\n\n    Return the maximum sum.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    45\n\n    Explanation:\n    The maximum sum is obtained from the subgrid [5, 6, 8, 9], which sums up to 45.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    max_sum = float(\"-inf\")\n\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(i, rows):\n                for l in range(j, cols):\n                    subgrid_sum = 0\n                    for m in range(i, k+1):\n                        for n in range(j, l+1):\n                            subgrid_sum += grid[m][n]\n                    max_sum = max(max_sum, subgrid_sum)\n\n    return max_sum", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers.\n\n    Returns:\n    - The generated grid.\n\n    Example:\n    g() returns [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    \"\"\"\n\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool:\n    \"\"\"\n    Given a grid of integers, a start coordinate, and an end coordinate,\n    determine if it is possible to reach the end coordinate from the start coordinate using only right and down movements.\n\n    Return True if it is possible, otherwise return False.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    start = (0, 0)\n    end = (2, 2)\n\n    Output:\n    True\n\n    Explanation:\n    It is possible to reach the end coordinate (2, 2) from the start coordinate (0, 0) by moving right and down.\n    \"\"\"\n\n    def dfs(row, col):\n        if row == end[0] and col == end[1]:\n            return True\n\n        if row < end[0] and grid[row+1][col] != -1:\n            if dfs(row+1, col):\n                return True\n\n        if col < end[1] and grid[row][col+1] != -1:\n            if dfs(row, col+1):\n                return True\n\n        return False\n\n    return dfs(start[0], start[1])\n\ndef g() -> Tuple[List[List[int]], Tuple[int, int], Tuple[int, int]]:\n    \"\"\"\n    Generate a grid of integers, a start coordinate, and an end coordinate.\n\n    Returns:\n    - The generated grid, start coordinate, and end coordinate.\n\n    Example:\n    g() returns ([[1, 2, 3], [4, 5, 6], [7, 8, 9]], (0, 0), (2, 2))\n    \"\"\"\n\n    return ([[1, 2, 3], [4, 5, 6], [7, 8, 9]], (0, 0), (2, 2))\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 473, "target_skills": [1, 0, 0, 1, 1, 1, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool:\n    \"\"\"\n    Given a grid of integers, a start coordinate, and an end coordinate,\n    determine if it is possible to reach the end coordinate from the start coordinate using only right and down movements.\n\n    Return True if it is possible, otherwise return False.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    start = (0, 0)\n    end = (2, 2)\n\n    Output:\n    True\n\n    Explanation:\n    It is possible to reach the end coordinate (2, 2) from the start coordinate (0, 0) by moving right and down.\n    \"\"\"\n\n    def dfs(row, col):\n        if row == end[0] and col == end[1]:\n            return True\n\n        if row < end[0] and grid[row+1][col] != -1:\n            if dfs(row+1, col):\n                return True\n\n        if col < end[1] and grid[row][col+1] != -1:\n            if dfs(row, col+1):\n                return True\n\n        return False\n\n    return dfs(start[0], start[1])", "solution_func": "def g() -> Tuple[List[List[int]], Tuple[int, int], Tuple[int, int]]:\n    \"\"\"\n    Generate a grid of integers, a start coordinate, and an end coordinate.\n\n    Returns:\n    - The generated grid, start coordinate, and end coordinate.\n\n    Example:\n    g() returns ([[1, 2, 3], [4, 5, 6], [7, 8, 9]], (0, 0), (2, 2))\n    \"\"\"\n\n    return ([[1, 2, 3], [4, 5, 6], [7, 8, 9]], (0, 0), (2, 2))", "map_ix": [0, 0, 1, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two positive integers n and m, return the number of unique paths from the top-left corner of a n x m grid to the bottom-right corner.\n    You can only move right or down at any point in time.\n\n    Example:\n    n = 3\n    m = 4\n\n    Output:\n    10\n\n    Explanation:\n    The grid is represented as follows:\n    1  1  1  1\n    1  2  3  4\n    1  3  6 10\n    \n    There are 10 unique paths from the top-left corner to the bottom-right corner.\n\n    Hint: Use dynamic programming to solve this problem.\n    \"\"\"\n\n    dp = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            if i == 0 or j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[n-1][m-1]\n\ndef g() -> List[int]:\n    n = 3\n    m = 4\n    return [n, m]\n\nassert f(*g()) == 10\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0], "idx_generation": 473, "target_skills": [1, 1, 1, 0, 1, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two positive integers n and m, return the number of unique paths from the top-left corner of a n x m grid to the bottom-right corner.\n    You can only move right or down at any point in time.\n\n    Example:\n    n = 3\n    m = 4\n\n    Output:\n    10\n\n    Explanation:\n    The grid is represented as follows:\n    1  1  1  1\n    1  2  3  4\n    1  3  6 10\n    \n    There are 10 unique paths from the top-left corner to the bottom-right corner.\n\n    Hint: Use dynamic programming to solve this problem.\n    \"\"\"\n\n    dp = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            if i == 0 or j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[n-1][m-1]", "solution_func": "def g() -> List[int]:\n    n = 3\n    m = 4\n    return [n, m]", "map_ix": [0, 0, 0, 1, 0, 0, 1, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> int:\n    \"\"\"\n    Given a list of points in a 2D plane, find the minimum area of a rectangle formed by any four points.\n\n    Example:\n    points = [[1, 1], [1, 2], [2, 2], [2, 1], [3, 1], [3, 2]]\n\n    Output:\n    1\n\n    Explanation:\n    The minimum area of a rectangle formed by the points [[2, 1], [2, 2], [3, 2], [3, 1]] is 1.\n\n    Hint: Use the Shoelace formula to calculate the area of a 2D polygon.\n    \"\"\"\n\n    min_area = float('inf')\n\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            for k in range(j + 1, len(points)):\n                for l in range(k + 1, len(points)):\n                    x1, y1 = points[i]\n                    x2, y2 = points[j]\n                    x3, y3 = points[k]\n                    x4, y4 = points[l]\n\n                    area = abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2) + x4*(y2-y1)) / 2\n\n                    min_area = min(min_area, area)\n\n    return min_area\n\ndef g() -> List[List[int]]:\n    points = [[1, 1], [1, 2], [2, 2], [2, 1], [3, 1], [3, 2]]\n    return points\n\nassert f(g()) == 1\n", "emb": null, "idx_generation": 473, "target_skills": [1, 1, 1, 1, 1, 0, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> int:\n    \"\"\"\n    Given a list of points in a 2D plane, find the minimum area of a rectangle formed by any four points.\n\n    Example:\n    points = [[1, 1], [1, 2], [2, 2], [2, 1], [3, 1], [3, 2]]\n\n    Output:\n    1\n\n    Explanation:\n    The minimum area of a rectangle formed by the points [[2, 1], [2, 2], [3, 2], [3, 1]] is 1.\n\n    Hint: Use the Shoelace formula to calculate the area of a 2D polygon.\n    \"\"\"\n\n    min_area = float('inf')\n\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            for k in range(j + 1, len(points)):\n                for l in range(k + 1, len(points)):\n                    x1, y1 = points[i]\n                    x2, y2 = points[j]\n                    x3, y3 = points[k]\n                    x4, y4 = points[l]\n\n                    area = abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2) + x4*(y2-y1)) / 2\n\n                    min_area = min(min_area, area)\n\n    return min_area", "solution_func": "def g() -> List[List[int]]:\n    points = [[1, 1], [1, 2], [2, 2], [2, 1], [3, 1], [3, 2]]\n    return points", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the minimum path sum from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum path is 1 -> 3 -> 1 -> 1 -> 1, which gives a total sum of 7.\n\n    Hint: Use dynamic programming to solve this problem.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 473, "target_skills": [1, 1, 1, 0, 0, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the minimum path sum from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum path is 1 -> 3 -> 1 -> 1 -> 1, which gives a total sum of 7.\n\n    Hint: Use dynamic programming to solve this problem.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of trailing zeros in n!.\n\n    Example:\n    n = 10\n\n    Output:\n    2\n\n    Explanation:\n    10! = 3628800, which has 2 trailing zeros.\n\n    Hint: Count the number of factors of 5 in the prime factorization of n!\n    \"\"\"\n\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n\n    return count\n\n\ndef g() -> int:\n    return 25\n\n\nassert f(g()) == 6\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 473, "target_skills": [0, 1, 1, 1, 0, 0, 1, 1, 1, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of trailing zeros in n!.\n\n    Example:\n    n = 10\n\n    Output:\n    2\n\n    Explanation:\n    10! = 3628800, which has 2 trailing zeros.\n\n    Hint: Count the number of factors of 5 in the prime factorization of n!\n    \"\"\"\n\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n\n    return count", "solution_func": "def g() -> int:\n    return 25", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(s: str, target: str) -> List[int]:\n    \"\"\"\n    Given a string and a target substring, find all the starting indices of the target substring in the string.\n\n    Example:\n    Input:\n    s = \"abababa\"\n    target = \"aba\"\n\n    Output:\n    [0, 2, 4]\n\n    Explanation:\n    The target substring \"aba\" starts at indices 0, 2, and 4 in the string \"abababa\".\n    \"\"\"\n\n    def search(s: str, target: str) -> List[int]:\n        indices = []\n\n        for i in range(len(s) - len(target) + 1):\n            if s[i:i+len(target)] == target:\n                indices.append(i)\n\n        return indices\n\n    return search(s, target)\n\ndef g() -> Tuple[str, str]:\n    \"\"\"\n    Generate a string and a target substring.\n    \"\"\"\n    return (\"abababa\", \"aba\")\n\nassert f(*g()) == [0, 2, 4]\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 474, "target_skills": [1, 0, 1, 0, 1, 1, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(s: str, target: str) -> List[int]:\n    \"\"\"\n    Given a string and a target substring, find all the starting indices of the target substring in the string.\n\n    Example:\n    Input:\n    s = \"abababa\"\n    target = \"aba\"\n\n    Output:\n    [0, 2, 4]\n\n    Explanation:\n    The target substring \"aba\" starts at indices 0, 2, and 4 in the string \"abababa\".\n    \"\"\"\n\n    def search(s: str, target: str) -> List[int]:\n        indices = []\n\n        for i in range(len(s) - len(target) + 1):\n            if s[i:i+len(target)] == target:\n                indices.append(i)\n\n        return indices\n\n    return search(s, target)", "solution_func": "def g() -> Tuple[str, str]:\n    \"\"\"\n    Generate a string and a target substring.\n    \"\"\"\n    return (\"abababa\", \"aba\")", "map_ix": [1, 1, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int:\n    \"\"\"\n    Given a grid of integers representing a maze, find the minimum number of steps required to reach the end position from the start position.\n    You can only move up, down, left, or right, and you cannot move through walls (represented by 1).\n\n    Example:\n    Input:\n    grid = [[0, 0, 0, 0, 0],\n            [0, 1, 1, 1, 0],\n            [0, 0, 0, 0, 0],\n            [0, 0, 1, 1, 1],\n            [0, 0, 0, 0, 0]]\n    start = (0, 0)\n    end = (4, 4)\n\n    Output:\n    8\n\n    Explanation:\n    The minimum number of steps required to reach the end position (4, 4) from the start position (0, 0) is 8.\n    \"\"\"\n\n    def bfs(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int:\n        queue = [(start, 0)]\n        visited = set()\n\n        while queue:\n            current, steps = queue.pop(0)\n            row, col = current\n\n            if current == end:\n                return steps\n\n            if current in visited:\n                continue\n\n            visited.add(current)\n\n            for direction in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_row, new_col = row + direction[0], col + direction[1]\n\n                if 0 <= new_row < len(grid) and 0 <= new_col < len(grid[0]) and grid[new_row][new_col] != 1:\n                    queue.append(((new_row, new_col), steps + 1))\n\n        return -1\n\n    return bfs(grid, start, end)\n\ndef g() -> Tuple[List[List[int]], Tuple[int, int], Tuple[int, int]]:\n    \"\"\"\n    Generate a grid, start position, and end position.\n    \"\"\"\n    return ([[0, 0, 0, 0, 0],\n             [0, 1, 1, 1, 0],\n             [0, 0, 0, 0, 0],\n             [0, 0, 1, 1, 1],\n             [0, 0, 0, 0, 0]], (0, 0), (4, 4))\n\nassert f(*g()) == 8\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0], "idx_generation": 474, "target_skills": [0, 0, 1, 1, 0, 1, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int:\n    \"\"\"\n    Given a grid of integers representing a maze, find the minimum number of steps required to reach the end position from the start position.\n    You can only move up, down, left, or right, and you cannot move through walls (represented by 1).\n\n    Example:\n    Input:\n    grid = [[0, 0, 0, 0, 0],\n            [0, 1, 1, 1, 0],\n            [0, 0, 0, 0, 0],\n            [0, 0, 1, 1, 1],\n            [0, 0, 0, 0, 0]]\n    start = (0, 0)\n    end = (4, 4)\n\n    Output:\n    8\n\n    Explanation:\n    The minimum number of steps required to reach the end position (4, 4) from the start position (0, 0) is 8.\n    \"\"\"\n\n    def bfs(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int:\n        queue = [(start, 0)]\n        visited = set()\n\n        while queue:\n            current, steps = queue.pop(0)\n            row, col = current\n\n            if current == end:\n                return steps\n\n            if current in visited:\n                continue\n\n            visited.add(current)\n\n            for direction in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_row, new_col = row + direction[0], col + direction[1]\n\n                if 0 <= new_row < len(grid) and 0 <= new_col < len(grid[0]) and grid[new_row][new_col] != 1:\n                    queue.append(((new_row, new_col), steps + 1))\n\n        return -1\n\n    return bfs(grid, start, end)", "solution_func": "def g() -> Tuple[List[List[int]], Tuple[int, int], Tuple[int, int]]:\n    \"\"\"\n    Generate a grid, start position, and end position.\n    \"\"\"\n    return ([[0, 0, 0, 0, 0],\n             [0, 1, 1, 1, 0],\n             [0, 0, 0, 0, 0],\n             [0, 0, 1, 1, 1],\n             [0, 0, 0, 0, 0]], (0, 0), (4, 4))", "map_ix": [0, 0, 1, 0, 0, 0, 1, 1, 1, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> int:\n    \"\"\"\n    Given a graph represented as an adjacency list and two nodes, find the minimum number of edges required to reach the end node from the start node.\n    If it is not possible to reach the end node from the start node, return -1.\n\n    Example:\n    Input:\n    graph = {0: [1, 2], 1: [2], 2: [0, 3], 3: [3]}\n    start = 2\n    end = 3\n\n    Output:\n    1\n\n    Explanation:\n    The minimum number of edges required to reach node 3 from node 2 is 1.\n    \"\"\"\n\n    def bfs(graph: Dict[int, List[int]], start: int, end: int) -> int:\n        queue = [(start, 0)]\n        visited = set()\n\n        while queue:\n            current, edges = queue.pop(0)\n\n            if current == end:\n                return edges\n\n            if current in visited:\n                continue\n\n            visited.add(current)\n\n            for neighbor in graph[current]:\n                queue.append((neighbor, edges + 1))\n\n        return -1\n\n    return bfs(graph, start, end)\n\ndef g() -> Tuple[Dict[int, List[int]], int, int]:\n    \"\"\"\n    Generate a graph represented as an adjacency list, start node, and end node.\n    \"\"\"\n    return ({0: [1, 2], 1: [2], 2: [0, 3], 3: [3]}, 2, 3)\n\nassert f(*g()) == 1\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 474, "target_skills": [0, 0, 1, 0, 1, 0, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> int:\n    \"\"\"\n    Given a graph represented as an adjacency list and two nodes, find the minimum number of edges required to reach the end node from the start node.\n    If it is not possible to reach the end node from the start node, return -1.\n\n    Example:\n    Input:\n    graph = {0: [1, 2], 1: [2], 2: [0, 3], 3: [3]}\n    start = 2\n    end = 3\n\n    Output:\n    1\n\n    Explanation:\n    The minimum number of edges required to reach node 3 from node 2 is 1.\n    \"\"\"\n\n    def bfs(graph: Dict[int, List[int]], start: int, end: int) -> int:\n        queue = [(start, 0)]\n        visited = set()\n\n        while queue:\n            current, edges = queue.pop(0)\n\n            if current == end:\n                return edges\n\n            if current in visited:\n                continue\n\n            visited.add(current)\n\n            for neighbor in graph[current]:\n                queue.append((neighbor, edges + 1))\n\n        return -1\n\n    return bfs(graph, start, end)", "solution_func": "def g() -> Tuple[Dict[int, List[int]], int, int]:\n    \"\"\"\n    Generate a graph represented as an adjacency list, start node, and end node.\n    \"\"\"\n    return ({0: [1, 2], 1: [2], 2: [0, 3], 3: [3]}, 2, 3)", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the nth Fibonacci number.\n\n    Example:\n    n = 6\n\n    Output:\n    8\n\n    Explanation:\n    The 6th Fibonacci number is 8.\n\n    Hint: Use a recursive approach to calculate the Fibonacci numbers.\n    \"\"\"\n\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return f(n-1) + f(n-2)\n\ndef g():\n    return 6\n\nassert f(g()) == 8\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 474, "target_skills": [1, 0, 1, 1, 1, 1, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the nth Fibonacci number.\n\n    Example:\n    n = 6\n\n    Output:\n    8\n\n    Explanation:\n    The 6th Fibonacci number is 8.\n\n    Hint: Use a recursive approach to calculate the Fibonacci numbers.\n    \"\"\"\n\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return f(n-1) + f(n-2)", "solution_func": "def g():\n    return 6", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n\n    Output:\n    3\n\n    Explanation:\n    The longest substring without repeating characters is \"abc\", which has a length of 3.\n\n    Hint: Use a sliding window approach to find the longest substring without repeating characters.\n    \"\"\"\n\n    if len(s) == 0:\n        return 0\n\n    max_length = 0\n    start = 0\n    char_map = {}\n\n    for end in range(len(s)):\n        if s[end] in char_map:\n            start = max(start, char_map[s[end]] + 1)\n        char_map[s[end]] = end\n        max_length = max(max_length, end - start + 1)\n\n    return max_length\n\ndef g():\n    return \"abcabcbb\"\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 474, "target_skills": [1, 0, 1, 1, 0, 0, 1, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n\n    Output:\n    3\n\n    Explanation:\n    The longest substring without repeating characters is \"abc\", which has a length of 3.\n\n    Hint: Use a sliding window approach to find the longest substring without repeating characters.\n    \"\"\"\n\n    if len(s) == 0:\n        return 0\n\n    max_length = 0\n    start = 0\n    char_map = {}\n\n    for end in range(len(s)):\n        if s[end] in char_map:\n            start = max(start, char_map[s[end]] + 1)\n        char_map[s[end]] = end\n        max_length = max(max_length, end - start + 1)\n\n    return max_length", "solution_func": "def g():\n    return \"abcabcbb\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(prices: List[int]) -> int:\n    \"\"\"\n    Given a list of prices representing the stock prices on different days, find the maximum profit that can be obtained by buying and selling the stock.\n\n    Example:\n    prices = [7, 1, 5, 3, 6, 4]\n\n    Output:\n    5\n\n    Explanation:\n    The maximum profit can be obtained by buying the stock on day 2 and selling it on day 5. The maximum profit is 5.\n\n    Hint: Use dynamic programming to keep track of the minimum price and maximum profit so far.\n    \"\"\"\n\n    if len(prices) == 0:\n        return 0\n\n    min_price = prices[0]\n    max_profit = 0\n\n    for price in prices:\n        min_price = min(min_price, price)\n        max_profit = max(max_profit, price - min_price)\n\n    return max_profit\n\ndef g():\n    return [7, 1, 5, 3, 6, 4]\n\nassert f(g()) == 5\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 474, "target_skills": [0, 1, 0, 1, 1, 1, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(prices: List[int]) -> int:\n    \"\"\"\n    Given a list of prices representing the stock prices on different days, find the maximum profit that can be obtained by buying and selling the stock.\n\n    Example:\n    prices = [7, 1, 5, 3, 6, 4]\n\n    Output:\n    5\n\n    Explanation:\n    The maximum profit can be obtained by buying the stock on day 2 and selling it on day 5. The maximum profit is 5.\n\n    Hint: Use dynamic programming to keep track of the minimum price and maximum profit so far.\n    \"\"\"\n\n    if len(prices) == 0:\n        return 0\n\n    min_price = prices[0]\n    max_profit = 0\n\n    for price in prices:\n        min_price = min(min_price, price)\n        max_profit = max(max_profit, price - min_price)\n\n    return max_profit", "solution_func": "def g():\n    return [7, 1, 5, 3, 6, 4]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> int:\n    \"\"\"\n    Given a binary tree, calculate the sum of all the odd-valued nodes in the tree.\n\n    Sample Input:\n    root = TreeNode(1)\n                1\n               / \\\n              2   3\n             / \\ / \\\n            4  5 6  7\n\n    Sample Output:\n    16\n    \"\"\"\n    def dfs(node: TreeNode) -> int:\n        if not node:\n            return 0\n        \n        current = 0\n        if node.val % 2 == 1:\n            current = node.val\n        \n        left_sum = dfs(node.left)\n        right_sum = dfs(node.right)\n        \n        return current + left_sum + right_sum\n    \n    return dfs(root)\n\ndef g():\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    \n    return root\n\nassert f(g()) == 16\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 474, "target_skills": [1, 1, 0, 1, 1, 1, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import *\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> int:\n    \"\"\"\n    Given a binary tree, calculate the sum of all the odd-valued nodes in the tree.\n\n    Sample Input:\n    root = TreeNode(1)\n                1\n               / \\\n              2   3\n             / \\ / \\\n            4  5 6  7\n\n    Sample Output:\n    16\n    \"\"\"\n    def dfs(node: TreeNode) -> int:\n        if not node:\n            return 0\n        \n        current = 0\n        if node.val % 2 == 1:\n            current = node.val\n        \n        left_sum = dfs(node.left)\n        right_sum = dfs(node.right)\n        \n        return current + left_sum + right_sum\n    \n    return dfs(root)", "solution_func": "def g():\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    \n    return root", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import *\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum XOR value between any two elements in the grid.\n\n    Sample Input:\n    grid = [[3, 10, 5], [25, 2, 8], [7, 4, 11]]\n\n    Sample Output:\n    28\n    \"\"\"\n    def dfs(i: int, j: int, val: int) -> int:\n        if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]):\n            return val\n        \n        val ^= grid[i][j]\n        \n        up = dfs(i-1, j, val)\n        down = dfs(i+1, j, val)\n        left = dfs(i, j-1, val)\n        right = dfs(i, j+1, val)\n        \n        return max(up, down, left, right)\n    \n    max_xor = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            max_xor = max(max_xor, dfs(i, j, 0))\n    \n    return max_xor\n\ndef g():\n    grid = [[3, 10, 5], [25, 2, 8], [7, 4, 11]]\n    \n    return grid\n\nassert f(g()) == 28\n\n", "emb": null, "idx_generation": 474, "target_skills": [1, 0, 0, 1, 0, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum XOR value between any two elements in the grid.\n\n    Sample Input:\n    grid = [[3, 10, 5], [25, 2, 8], [7, 4, 11]]\n\n    Sample Output:\n    28\n    \"\"\"\n    def dfs(i: int, j: int, val: int) -> int:\n        if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]):\n            return val\n        \n        val ^= grid[i][j]\n        \n        up = dfs(i-1, j, val)\n        down = dfs(i+1, j, val)\n        left = dfs(i, j-1, val)\n        right = dfs(i, j+1, val)\n        \n        return max(up, down, left, right)\n    \n    max_xor = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            max_xor = max(max_xor, dfs(i, j, 0))\n    \n    return max_xor", "solution_func": "def g():\n    grid = [[3, 10, 5], [25, 2, 8], [7, 4, 11]]\n    \n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters representing a maze, find the minimum number of steps required to reach the\n    destination from the starting point. You can only move in the four cardinal directions (up, down, left, right)\n    and you cannot pass through walls represented by '#'.\n\n    Sample Input:\n    grid = [\n        [\"S\", \".\", \"#\", \"#\", \".\", \".\", \".\"],\n        [\".\", \".\", \".\", \"#\", \".\", \".\", \".\"],\n        [\".\", \"#\", \".\", \".\", \".\", \"#\", \".\"],\n        [\".\", \"#\", \"#\", \"#\", \".\", \".\", \".\"],\n        [\".\", \".\", \".\", \".\", \".\", \"#\", \"E\"]\n    ]\n\n    Sample Output:\n    11\n    \"\"\"\n    def dfs(i: int, j: int, steps: int) -> int:\n        if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] == \"#\":\n            return float('inf')\n        \n        if grid[i][j] == \"E\":\n            return steps\n        \n        grid[i][j] = \"#\"\n        up = dfs(i-1, j, steps + 1)\n        down = dfs(i+1, j, steps + 1)\n        left = dfs(i, j-1, steps + 1)\n        right = dfs(i, j+1, steps + 1)\n        grid[i][j] = \".\"\n        \n        return min(up, down, left, right)\n    \n    \n    start_i, start_j = 0, 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == \"S\":\n                start_i, start_j = i, j\n                break\n    \n    return dfs(start_i, start_j, 0)\n\ndef g():\n    grid = [\n        [\"S\", \".\", \"#\", \"#\", \".\", \".\", \".\"],\n        [\".\", \".\", \".\", \"#\", \".\", \".\", \".\"],\n        [\".\", \"#\", \".\", \".\", \".\", \"#\", \".\"],\n        [\".\", \"#\", \"#\", \"#\", \".\", \".\", \".\"],\n        [\".\", \".\", \".\", \".\", \".\", \"#\", \"E\"]\n    ]\n    \n    return grid\n\nassert f(g()) == 11\n\n", "emb": null, "idx_generation": 474, "target_skills": [0, 1, 1, 1, 1, 0, 1, 0, 1, 0], "problem_func": "from typing import*\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters representing a maze, find the minimum number of steps required to reach the\n    destination from the starting point. You can only move in the four cardinal directions (up, down, left, right)\n    and you cannot pass through walls represented by '#'.\n\n    Sample Input:\n    grid = [\n        [\"S\", \".\", \"#\", \"#\", \".\", \".\", \".\"],\n        [\".\", \".\", \".\", \"#\", \".\", \".\", \".\"],\n        [\".\", \"#\", \".\", \".\", \".\", \"#\", \".\"],\n        [\".\", \"#\", \"#\", \"#\", \".\", \".\", \".\"],\n        [\".\", \".\", \".\", \".\", \".\", \"#\", \"E\"]\n    ]\n\n    Sample Output:\n    11\n    \"\"\"\n    def dfs(i: int, j: int, steps: int) -> int:\n        if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] == \"#\":\n            return float('inf')\n        \n        if grid[i][j] == \"E\":\n            return steps\n        \n        grid[i][j] = \"#\"\n        up = dfs(i-1, j, steps + 1)\n        down = dfs(i+1, j, steps + 1)\n        left = dfs(i, j-1, steps + 1)\n        right = dfs(i, j+1, steps + 1)\n        grid[i][j] = \".\"\n        \n        return min(up, down, left, right)\n    \n    \n    start_i, start_j = 0, 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == \"S\":\n                start_i, start_j = i, j\n                break\n    \n    return dfs(start_i, start_j, 0)", "solution_func": "def g():\n    grid = [\n        [\"S\", \".\", \"#\", \"#\", \".\", \".\", \".\"],\n        [\".\", \".\", \".\", \"#\", \".\", \".\", \".\"],\n        [\".\", \"#\", \".\", \".\", \".\", \"#\", \".\"],\n        [\".\", \"#\", \"#\", \"#\", \".\", \".\", \".\"],\n        [\".\", \".\", \".\", \".\", \".\", \"#\", \"E\"]\n    ]\n    \n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list.\n    If the target is not found, return -1.\n\n    Example:\n    nums = [-1, 0, 3, 5, 9, 12]\n    target = 9\n\n    Output:\n    4\n\n    Explanation:\n    The target value 9 is found at index 4 in the list.\n\n    Hint: Consider using binary search to efficiently find the target value in the sorted list.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(nums: List[int] = [-1, 0, 3, 5, 9, 12], target: int = 9) -> int:\n    return nums, target\n\nassert f(*g()) == 4\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 474, "target_skills": [0, 0, 0, 1, 0, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list.\n    If the target is not found, return -1.\n\n    Example:\n    nums = [-1, 0, 3, 5, 9, 12]\n    target = 9\n\n    Output:\n    4\n\n    Explanation:\n    The target value 9 is found at index 4 in the list.\n\n    Hint: Consider using binary search to efficiently find the target value in the sorted list.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g(nums: List[int] = [-1, 0, 3, 5, 9, 12], target: int = 9) -> int:\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n\n    Output:\n    3\n\n    Explanation:\n    The longest substring without repeating characters is \"abc\", which has a length of 3.\n    \"\"\"\n\n    def longest_substring(s, start, end):\n        if start == end:\n            return 1\n\n        if start > end:\n            return 0\n\n        if len(set(s[start:end+1])) == end - start + 1:\n            return end - start + 1\n\n        return max(longest_substring(s, start+1, end), longest_substring(s, start, end-1))\n\n    return longest_substring(s, 0, len(s)-1)\n\ndef g(s = \"abcabcbb\"):\n    return s\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 475, "target_skills": [0, 0, 0, 0, 0, 1, 0, 1, 0, 1], "problem_func": "from typing import*\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n\n    Output:\n    3\n\n    Explanation:\n    The longest substring without repeating characters is \"abc\", which has a length of 3.\n    \"\"\"\n\n    def longest_substring(s, start, end):\n        if start == end:\n            return 1\n\n        if start > end:\n            return 0\n\n        if len(set(s[start:end+1])) == end - start + 1:\n            return end - start + 1\n\n        return max(longest_substring(s, start+1, end), longest_substring(s, start, end-1))\n\n    return longest_substring(s, 0, len(s)-1)", "solution_func": "def g(s = \"abcabcbb\"):\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the minimum number of cuts needed to partition the string into palindromic substrings.\n\n    Example:\n    s = \"aab\"\n\n    Output:\n    1\n\n    Explanation:\n    The string \"aab\" can be partitioned into \"aa\" and \"b\", which requires 1 cut.\n    \"\"\"\n\n    def is_palindrome(s):\n        left = 0\n        right = len(s) - 1\n\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n\n        return True\n\n    def min_cuts(s, start, end):\n        if start >= end or is_palindrome(s[start:end+1]):\n            return 0\n\n        min_cuts_needed = float('inf')\n        for i in range(start, end):\n            if is_palindrome(s[start:i+1]):\n                min_cuts_needed = min(min_cuts_needed, 1 + min_cuts(s, i+1, end))\n\n        return min_cuts_needed\n\n    return min_cuts(s, 0, len(s)-1)\n\ndef g(s = \"aab\"):\n    return s\n\nassert f(g()) == 1\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 475, "target_skills": [1, 1, 1, 0, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the minimum number of cuts needed to partition the string into palindromic substrings.\n\n    Example:\n    s = \"aab\"\n\n    Output:\n    1\n\n    Explanation:\n    The string \"aab\" can be partitioned into \"aa\" and \"b\", which requires 1 cut.\n    \"\"\"\n\n    def is_palindrome(s):\n        left = 0\n        right = len(s) - 1\n\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n\n        return True\n\n    def min_cuts(s, start, end):\n        if start >= end or is_palindrome(s[start:end+1]):\n            return 0\n\n        min_cuts_needed = float('inf')\n        for i in range(start, end):\n            if is_palindrome(s[start:i+1]):\n                min_cuts_needed = min(min_cuts_needed, 1 + min_cuts(s, i+1, end))\n\n        return min_cuts_needed\n\n    return min_cuts(s, 0, len(s)-1)", "solution_func": "def g(s = \"aab\"):\n    return s", "map_ix": [0, 1, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target integer, return the number of ways to reach the target by adding or subtracting the elements in the list.\n\n    Example:\n    nums = [1, 1, 1, 1, 1]\n    target = 3\n\n    Output:\n    5\n\n    Explanation:\n    There are 5 ways to reach the target by adding or subtracting the elements in the list:\n    1 + 1 + 1 + 1 - 1\n    1 + 1 - 1 + 1 + 1\n    1 - 1 + 1 + 1 + 1\n    -1 + 1 + 1 + 1 + 1\n    1 + 1 + 1 - 1 + 1\n    \"\"\"\n\n    def ways_to_reach_target(nums, target, curr_sum, curr_index):\n        if curr_index == len(nums):\n            if curr_sum == target:\n                return 1\n            else:\n                return 0\n\n        ways = ways_to_reach_target(nums, target, curr_sum + nums[curr_index], curr_index + 1) + ways_to_reach_target(nums, target, curr_sum - nums[curr_index], curr_index + 1)\n        return ways\n\n    return ways_to_reach_target(nums, target, 0, 0)\n\ndef g(nums=[1, 1, 1, 1, 1], target=3):\n    return nums, target\n\nassert f(*g()) == 5\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 475, "target_skills": [1, 1, 0, 0, 0, 0, 1, 0, 0, 0], "problem_func": "from typing import*\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target integer, return the number of ways to reach the target by adding or subtracting the elements in the list.\n\n    Example:\n    nums = [1, 1, 1, 1, 1]\n    target = 3\n\n    Output:\n    5\n\n    Explanation:\n    There are 5 ways to reach the target by adding or subtracting the elements in the list:\n    1 + 1 + 1 + 1 - 1\n    1 + 1 - 1 + 1 + 1\n    1 - 1 + 1 + 1 + 1\n    -1 + 1 + 1 + 1 + 1\n    1 + 1 + 1 - 1 + 1\n    \"\"\"\n\n    def ways_to_reach_target(nums, target, curr_sum, curr_index):\n        if curr_index == len(nums):\n            if curr_sum == target:\n                return 1\n            else:\n                return 0\n\n        ways = ways_to_reach_target(nums, target, curr_sum + nums[curr_index], curr_index + 1) + ways_to_reach_target(nums, target, curr_sum - nums[curr_index], curr_index + 1)\n        return ways\n\n    return ways_to_reach_target(nums, target, 0, 0)", "solution_func": "def g(nums=[1, 1, 1, 1, 1], target=3):\n    return nums, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, return the index of the target value if it is found in the list. If the target value is not found, return -1.\n    \n    Example:\n    Input: arr = [1, 3, 5, 6, 8, 9], target = 6\n    Output: 3\n    \n    Hint: Use binary search to find the target value in the list.\n    \"\"\"\n    \n    def binary_search(arr, target, left, right):\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == target:\n                return mid\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n    \n    return binary_search(arr, target, 0, len(arr) - 1)\n\ndef g(arr: List[int] = [1, 3, 5, 6, 8, 9], target: int = 6) -> List[int]:\n    \"\"\"\n    Generate the values of arr and target for the function f.\n    \"\"\"\n    return arr, target\n\nassert f(g()) == 3\n", "emb": null, "idx_generation": 475, "target_skills": [1, 1, 1, 0, 0, 1, 1, 0, 1, 0], "problem_func": "from typing import*\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, return the index of the target value if it is found in the list. If the target value is not found, return -1.\n    \n    Example:\n    Input: arr = [1, 3, 5, 6, 8, 9], target = 6\n    Output: 3\n    \n    Hint: Use binary search to find the target value in the list.\n    \"\"\"\n    \n    def binary_search(arr, target, left, right):\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == target:\n                return mid\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n    \n    return binary_search(arr, target, 0, len(arr) - 1)", "solution_func": "def g(arr: List[int] = [1, 3, 5, 6, 8, 9], target: int = 6) -> List[int]:\n    \"\"\"\n    Generate the values of arr and target for the function f.\n    \"\"\"\n    return arr, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the number of unique spanning trees in a complete graph with n vertices.\n\n    Example:\n    Input: n = 4\n    Output: 16\n\n    Hint: Use Cayley's formula to calculate the number of spanning trees in a complete graph.\n    \"\"\"\n\n    return n ** (n - 2)\n\ndef g(n: int = 4) -> int:\n    \"\"\"\n    Generate the value of n for the function f.\n    \"\"\"\n    return n\n\nassert f(g()) == 16\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 475, "target_skills": [1, 0, 1, 1, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the number of unique spanning trees in a complete graph with n vertices.\n\n    Example:\n    Input: n = 4\n    Output: 16\n\n    Hint: Use Cayley's formula to calculate the number of spanning trees in a complete graph.\n    \"\"\"\n\n    return n ** (n - 2)", "solution_func": "def g(n: int = 4) -> int:\n    \"\"\"\n    Generate the value of n for the function f.\n    \"\"\"\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the shortest path from the top-left cell to the bottom-right cell. Each cell in the grid represents the cost to move to that cell. You can only move down or right.\n\n    Example:\n    Input: grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    Output: 7\n\n    Explanation:\n    The shortest path is 1 -> 3 -> 1 -> 1 -> 1, which has a total cost of 7.\n\n    Hint: Use dynamic programming to calculate the minimum cost to reach each cell.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[m - 1][n - 1]\n\ndef g(grid: List[List[int]] = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) -> List[List[int]]:\n    \"\"\"\n    Generate the value of grid for the function f.\n    \"\"\"\n    return grid\n\nassert f(g()) == 7\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 475, "target_skills": [0, 1, 1, 0, 0, 1, 1, 1, 1, 0], "problem_func": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the shortest path from the top-left cell to the bottom-right cell. Each cell in the grid represents the cost to move to that cell. You can only move down or right.\n\n    Example:\n    Input: grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    Output: 7\n\n    Explanation:\n    The shortest path is 1 -> 3 -> 1 -> 1 -> 1, which has a total cost of 7.\n\n    Hint: Use dynamic programming to calculate the minimum cost to reach each cell.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[m - 1][n - 1]", "solution_func": "def g(grid: List[List[int]] = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) -> List[List[int]]:\n    \"\"\"\n    Generate the value of grid for the function f.\n    \"\"\"\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the number of paths from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    matrix = [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1]\n    ]\n\n    Output:\n    6 (there are 6 possible paths to reach the bottom-right corner)\n    \"\"\"\n\n    def count_paths(matrix: List[List[int]], row: int, col: int) -> int:\n        if row == len(matrix) - 1 and col == len(matrix[0]) - 1:\n            return 1\n        if row >= len(matrix) or col >= len(matrix[0]):\n            return 0\n\n        return count_paths(matrix, row + 1, col) + count_paths(matrix, row, col + 1)\n\n    return count_paths(matrix, 0, 0)\n\ndef g():\n    matrix = [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1]\n    ]\n    return matrix\n\nassert f(*g()) == 6\n", "emb": null, "idx_generation": 475, "target_skills": [1, 0, 1, 1, 0, 0, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the number of paths from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    matrix = [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1]\n    ]\n\n    Output:\n    6 (there are 6 possible paths to reach the bottom-right corner)\n    \"\"\"\n\n    def count_paths(matrix: List[List[int]], row: int, col: int) -> int:\n        if row == len(matrix) - 1 and col == len(matrix[0]) - 1:\n            return 1\n        if row >= len(matrix) or col >= len(matrix[0]):\n            return 0\n\n        return count_paths(matrix, row + 1, col) + count_paths(matrix, row, col + 1)\n\n    return count_paths(matrix, 0, 0)", "solution_func": "def g():\n    matrix = [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1]\n    ]\n    return matrix", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum of numbers along a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7 (the minimum sum of numbers along the path is 1 + 3 + 1 + 1 + 1 = 7)\n    \"\"\"\n\n    def min_path_sum(grid: List[List[int]], row: int, col: int) -> int:\n        if row == len(grid) - 1 and col == len(grid[0]) - 1:\n            return grid[row][col]\n        if row >= len(grid) or col >= len(grid[0]):\n            return float('inf')\n\n        return grid[row][col] + min(min_path_sum(grid, row + 1, col), min_path_sum(grid, row, col + 1))\n\n    return min_path_sum(grid, 0, 0)\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(*g()) == 7\n", "emb": null, "idx_generation": 475, "target_skills": [0, 1, 1, 0, 1, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum of numbers along a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7 (the minimum sum of numbers along the path is 1 + 3 + 1 + 1 + 1 = 7)\n    \"\"\"\n\n    def min_path_sum(grid: List[List[int]], row: int, col: int) -> int:\n        if row == len(grid) - 1 and col == len(grid[0]) - 1:\n            return grid[row][col]\n        if row >= len(grid) or col >= len(grid[0]):\n            return float('inf')\n\n        return grid[row][col] + min(min_path_sum(grid, row + 1, col), min_path_sum(grid, row, col + 1))\n\n    return min_path_sum(grid, 0, 0)", "solution_func": "def g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of numbers along a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    29 (the maximum sum of numbers along the path is 1 + 4 + 7 + 8 + 9 = 29)\n    \"\"\"\n\n    def max_path_sum(matrix: List[List[int]], row: int, col: int) -> int:\n        if row == len(matrix) - 1 and col == len(matrix[0]) - 1:\n            return matrix[row][col]\n        if row >= len(matrix) or col >= len(matrix[0]):\n            return float('-inf')\n\n        return matrix[row][col] + max(max_path_sum(matrix, row + 1, col), max_path_sum(matrix, row, col + 1))\n\n    return max_path_sum(matrix, 0, 0)\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(*g()) == 29\n", "emb": null, "idx_generation": 475, "target_skills": [1, 1, 1, 0, 1, 0, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of numbers along a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    29 (the maximum sum of numbers along the path is 1 + 4 + 7 + 8 + 9 = 29)\n    \"\"\"\n\n    def max_path_sum(matrix: List[List[int]], row: int, col: int) -> int:\n        if row == len(matrix) - 1 and col == len(matrix[0]) - 1:\n            return matrix[row][col]\n        if row >= len(matrix) or col >= len(matrix[0]):\n            return float('-inf')\n\n        return matrix[row][col] + max(max_path_sum(matrix, row + 1, col), max_path_sum(matrix, row, col + 1))\n\n    return max_path_sum(matrix, 0, 0)", "solution_func": "def g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the index of the target value using binary search.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output:\n    2\n\n    Explanation:\n    The target value 5 is found at index 2 in the list [1, 3, 5, 7, 9].\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    return ([1, 3, 5, 7, 9], 5)\n\nassert f(*g()) == 2\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0], "idx_generation": 475, "target_skills": [1, 0, 0, 1, 1, 1, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the index of the target value using binary search.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output:\n    2\n\n    Explanation:\n    The target value 5 is found at index 2 in the list [1, 3, 5, 7, 9].\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    return ([1, 3, 5, 7, 9], 5)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 1]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    The maximum sum path is 1 -> 3 -> 1 -> 1 -> 1, which gives a sum of 7.\n\n    Hint: Use dynamic programming to calculate the maximum sum at each position in the grid.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Create a 2D list to store the maximum sum at each position\n    max_sum = [[0] * cols for _ in range(rows)]\n\n    # Initialize the first row and first column with the cumulative sum\n    max_sum[0][0] = grid[0][0]\n    for i in range(1, rows):\n        max_sum[i][0] = max_sum[i-1][0] + grid[i][0]\n    for j in range(1, cols):\n        max_sum[0][j] = max_sum[0][j-1] + grid[0][j]\n\n    # Calculate the maximum sum at each position\n    for i in range(1, rows):\n        for j in range(1, cols):\n            max_sum[i][j] = max(max_sum[i-1][j], max_sum[i][j-1]) + grid[i][j]\n\n    return max_sum[rows-1][cols-1]\n\ndef g(grid: List[List[int]] = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) -> List[List[int]]:\n    \"\"\"Generate a grid of integers.\"\"\"\n    return grid\n\nassert f(g()) == 7\n", "emb": null, "idx_generation": 476, "target_skills": [0, 1, 1, 1, 0, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    The maximum sum path is 1 -> 3 -> 1 -> 1 -> 1, which gives a sum of 7.\n\n    Hint: Use dynamic programming to calculate the maximum sum at each position in the grid.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Create a 2D list to store the maximum sum at each position\n    max_sum = [[0] * cols for _ in range(rows)]\n\n    # Initialize the first row and first column with the cumulative sum\n    max_sum[0][0] = grid[0][0]\n    for i in range(1, rows):\n        max_sum[i][0] = max_sum[i-1][0] + grid[i][0]\n    for j in range(1, cols):\n        max_sum[0][j] = max_sum[0][j-1] + grid[0][j]\n\n    # Calculate the maximum sum at each position\n    for i in range(1, rows):\n        for j in range(1, cols):\n            max_sum[i][j] = max(max_sum[i-1][j], max_sum[i][j-1]) + grid[i][j]\n\n    return max_sum[rows-1][cols-1]", "solution_func": "def g(grid: List[List[int]] = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) -> List[List[int]]:\n    \"\"\"Generate a grid of integers.\"\"\"\n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, path: List[int] = []) -> List[int]:\n    \"\"\"\n    Given a graph represented as an adjacency matrix, find a path from a start node to an end node.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 1, 1],\n        [0, 0, 0, 0, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    start = 0\n    end = 4\n    The path from node 0 to node 4 is [0, 1, 3, 4].\n\n    Hint: Use depth-first search (DFS) to explore the graph and find a path from the start node to the end node.\n    \"\"\"\n    path.append(start)\n\n    if start == end:\n        return path\n\n    for i in range(len(graph[start])):\n        if graph[start][i] == 1 and i not in path:\n            new_path = f(graph, i, end, path)\n            if new_path:\n                return new_path\n\n    return []\n\ndef g(graph: List[List[int]] = [[0, 1, 1, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 1, 1], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0]], start: int = 0, end: int = 4) -> List[List[int]]:\n    \"\"\"Generate a graph represented as an adjacency matrix, and a start and end node.\"\"\"\n    return graph, start, end\n\nassert f(*g()) == [0, 1, 3, 4]\n", "emb": null, "idx_generation": 476, "target_skills": [0, 0, 0, 0, 0, 1, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, path: List[int] = []) -> List[int]:\n    \"\"\"\n    Given a graph represented as an adjacency matrix, find a path from a start node to an end node.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 1, 1],\n        [0, 0, 0, 0, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    start = 0\n    end = 4\n    The path from node 0 to node 4 is [0, 1, 3, 4].\n\n    Hint: Use depth-first search (DFS) to explore the graph and find a path from the start node to the end node.\n    \"\"\"\n    path.append(start)\n\n    if start == end:\n        return path\n\n    for i in range(len(graph[start])):\n        if graph[start][i] == 1 and i not in path:\n            new_path = f(graph, i, end, path)\n            if new_path:\n                return new_path\n\n    return []", "solution_func": "def g(graph: List[List[int]] = [[0, 1, 1, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 1, 1], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0]], start: int = 0, end: int = 4) -> List[List[int]]:\n    \"\"\"Generate a graph represented as an adjacency matrix, and a start and end node.\"\"\"\n    return graph, start, end", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n\n    Example:\n    n = 3\n    There are 3 ways to climb to the top: 1 -> 1 -> 1, 1 -> 2, 2 -> 1.\n\n    Hint: Use dynamic programming to calculate the number of ways to climb to each step.\n    \"\"\"\n    if n <= 2:\n        return n\n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\ndef g(n: int = 3) -> int:\n    \"\"\"Generate a positive integer n.\"\"\"\n    return n\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 476, "target_skills": [1, 1, 1, 0, 0, 0, 0, 1, 0, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n\n    Example:\n    n = 3\n    There are 3 ways to climb to the top: 1 -> 1 -> 1, 1 -> 2, 2 -> 1.\n\n    Hint: Use dynamic programming to calculate the number of ways to climb to each step.\n    \"\"\"\n    if n <= 2:\n        return n\n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]", "solution_func": "def g(n: int = 3) -> int:\n    \"\"\"Generate a positive integer n.\"\"\"\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, check if t is an anagram of s.\n\n    An anagram is a word or phrase formed by rearranging the letters of a different word or phrase,\n    typically using all the original letters exactly once.\n\n    Example:\n    s = \"listen\"\n    t = \"silent\"\n\n    Output:\n    True\n\n    Explanation:\n    The string \"silent\" is an anagram of \"listen\" because the letters can be rearranged to form \"listen\".\n    \"\"\"\n\n    # Convert the strings to lists of characters\n    s_list = list(s)\n    t_list = list(t)\n\n    # Sort the characters in each list\n    s_list.sort()\n    t_list.sort()\n\n    # Check if the sorted lists are equal\n    return s_list == t_list\n\ndef g(s=\"listen\", t=\"silent\"):\n    \"\"\"\n    Generate two strings such that one is an anagram of the other.\n    \"\"\"\n    return s, t\n\nassert f(*g())\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 476, "target_skills": [0, 0, 1, 0, 0, 0, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, check if t is an anagram of s.\n\n    An anagram is a word or phrase formed by rearranging the letters of a different word or phrase,\n    typically using all the original letters exactly once.\n\n    Example:\n    s = \"listen\"\n    t = \"silent\"\n\n    Output:\n    True\n\n    Explanation:\n    The string \"silent\" is an anagram of \"listen\" because the letters can be rearranged to form \"listen\".\n    \"\"\"\n\n    # Convert the strings to lists of characters\n    s_list = list(s)\n    t_list = list(t)\n\n    # Sort the characters in each list\n    s_list.sort()\n    t_list.sort()\n\n    # Check if the sorted lists are equal\n    return s_list == t_list", "solution_func": "def g(s=\"listen\", t=\"silent\"):\n    \"\"\"\n    Generate two strings such that one is an anagram of the other.\n    \"\"\"\n    return s, t", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of the words in the string.\n\n    Example:\n    s = \"hello world\"\n\n    Output:\n    \"world hello\"\n\n    Explanation:\n    The words in the string \"hello world\" are \"hello\" and \"world\". By reversing the order of the words,\n    we get the string \"world hello\".\n    \"\"\"\n\n    # Split the string into a list of words\n    words = s.split()\n\n    # Reverse the order of the words\n    words.reverse()\n\n    # Join the words back into a string\n    reversed_string = \" \".join(words)\n\n    return reversed_string\n\ndef g(s=\"hello world\"):\n    \"\"\"\n    Generate a string with multiple words.\n    \"\"\"\n    return s\n\nassert f(g()) == \"world hello\"\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 476, "target_skills": [1, 1, 0, 1, 0, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of the words in the string.\n\n    Example:\n    s = \"hello world\"\n\n    Output:\n    \"world hello\"\n\n    Explanation:\n    The words in the string \"hello world\" are \"hello\" and \"world\". By reversing the order of the words,\n    we get the string \"world hello\".\n    \"\"\"\n\n    # Split the string into a list of words\n    words = s.split()\n\n    # Reverse the order of the words\n    words.reverse()\n\n    # Join the words back into a string\n    reversed_string = \" \".join(words)\n\n    return reversed_string", "solution_func": "def g(s=\"hello world\"):\n    \"\"\"\n    Generate a string with multiple words.\n    \"\"\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string of lowercase letters, find the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n\n    Output:\n    3\n\n    Explanation:\n    The longest substring without repeating characters is \"abc\", which has a length of 3.\n    \"\"\"\n\n    # Create a set to store the unique characters in the current substring\n    unique_chars = set()\n\n    # Initialize variables to keep track of the start and end indices of the current substring\n    start = 0\n    end = 0\n\n    # Initialize variable to store the length of the longest substring\n    longest_length = 0\n\n    # Iterate through the string\n    while end < len(s):\n        # If the current character is not in the set, add it to the set and move the end index forward\n        if s[end] not in unique_chars:\n            unique_chars.add(s[end])\n            end += 1\n            # Update the longest length if necessary\n            longest_length = max(longest_length, end - start)\n        # If the current character is already in the set, remove the character from the set and move the start index forward\n        else:\n            unique_chars.remove(s[start])\n            start += 1\n\n    return longest_length\n\ndef g(s=\"abcabcbb\"):\n    \"\"\"\n    Generate a string with repeated characters to find the length of the longest substring without repeating characters.\n    \"\"\"\n    return s\n\nassert f(g()) == 3\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 476, "target_skills": [0, 0, 0, 1, 0, 0, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string of lowercase letters, find the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n\n    Output:\n    3\n\n    Explanation:\n    The longest substring without repeating characters is \"abc\", which has a length of 3.\n    \"\"\"\n\n    # Create a set to store the unique characters in the current substring\n    unique_chars = set()\n\n    # Initialize variables to keep track of the start and end indices of the current substring\n    start = 0\n    end = 0\n\n    # Initialize variable to store the length of the longest substring\n    longest_length = 0\n\n    # Iterate through the string\n    while end < len(s):\n        # If the current character is not in the set, add it to the set and move the end index forward\n        if s[end] not in unique_chars:\n            unique_chars.add(s[end])\n            end += 1\n            # Update the longest length if necessary\n            longest_length = max(longest_length, end - start)\n        # If the current character is already in the set, remove the character from the set and move the start index forward\n        else:\n            unique_chars.remove(s[start])\n            start += 1\n\n    return longest_length", "solution_func": "def g(s=\"abcabcbb\"):\n    \"\"\"\n    Generate a string with repeated characters to find the length of the longest substring without repeating characters.\n    \"\"\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the missing number in the sequence.\n\n    Example:\n    nums = [0, 1, 2, 4, 5, 6, 7, 8, 9]\n\n    Output:\n    3\n\n    Explanation:\n    The missing number in the sequence is 3.\n\n    Constraints:\n    - The input list will always be sorted in ascending order.\n    - The input list will contain a range of consecutive integers, with one number missing.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        mid = left + (right - left) // 2\n        if nums[mid] - nums[left] != mid - left:\n            right = mid\n        else:\n            left = mid + 1\n\n    return nums[left] - 1\n\ndef g():\n    nums = [0, 1, 2, 4, 5, 6, 7, 8, 9]\n    return nums\n\nassert f(g()) == 3\n\n", "emb": null, "idx_generation": 476, "target_skills": [0, 0, 1, 0, 1, 0, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the missing number in the sequence.\n\n    Example:\n    nums = [0, 1, 2, 4, 5, 6, 7, 8, 9]\n\n    Output:\n    3\n\n    Explanation:\n    The missing number in the sequence is 3.\n\n    Constraints:\n    - The input list will always be sorted in ascending order.\n    - The input list will contain a range of consecutive integers, with one number missing.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        mid = left + (right - left) // 2\n        if nums[mid] - nums[left] != mid - left:\n            right = mid\n        else:\n            left = mid + 1\n\n    return nums[left] - 1", "solution_func": "def g():\n    nums = [0, 1, 2, 4, 5, 6, 7, 8, 9]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representing a weighted graph, find the minimum spanning tree using Prim's algorithm.\n\n    Example:\n    graph = [\n        [0, 2, 0, 6, 0],\n        [2, 0, 3, 8, 5],\n        [0, 3, 0, 0, 7],\n        [6, 8, 0, 0, 9],\n        [0, 5, 7, 9, 0]\n    ]\n\n    Output:\n    16\n\n    Explanation:\n    The minimum spanning tree has the following edges: [(0, 1), (1, 2), (0, 3), (1, 4)], with a total weight of 16.\n\n    Constraints:\n    - The input graph will be represented as a square matrix.\n    - The weight of each edge will be a non-negative integer.\n    \"\"\"\n\n    num_vertices = len(graph)\n    mst = [False] * num_vertices\n    key = [float('inf')] * num_vertices\n    parent = [None] * num_vertices\n    key[0] = 0\n\n    for _ in range(num_vertices):\n        min_key = float('inf')\n        min_vertex = None\n        for v in range(num_vertices):\n            if not mst[v] and key[v] < min_key:\n                min_key = key[v]\n                min_vertex = v\n        mst[min_vertex] = True\n\n        for v in range(num_vertices):\n            if graph[min_vertex][v] > 0 and not mst[v] and graph[min_vertex][v] < key[v]:\n                key[v] = graph[min_vertex][v]\n                parent[v] = min_vertex\n\n    return sum(graph[v][parent[v]] for v in range(1, num_vertices))\n\ndef g():\n    graph = [\n        [0, 2, 0, 6, 0],\n        [2, 0, 3, 8, 5],\n        [0, 3, 0, 0, 7],\n        [6, 8, 0, 0, 9],\n        [0, 5, 7, 9, 0]\n    ]\n    return graph\n\nassert f(g()) == 16\n\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 476, "target_skills": [1, 0, 0, 1, 0, 1, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representing a weighted graph, find the minimum spanning tree using Prim's algorithm.\n\n    Example:\n    graph = [\n        [0, 2, 0, 6, 0],\n        [2, 0, 3, 8, 5],\n        [0, 3, 0, 0, 7],\n        [6, 8, 0, 0, 9],\n        [0, 5, 7, 9, 0]\n    ]\n\n    Output:\n    16\n\n    Explanation:\n    The minimum spanning tree has the following edges: [(0, 1), (1, 2), (0, 3), (1, 4)], with a total weight of 16.\n\n    Constraints:\n    - The input graph will be represented as a square matrix.\n    - The weight of each edge will be a non-negative integer.\n    \"\"\"\n\n    num_vertices = len(graph)\n    mst = [False] * num_vertices\n    key = [float('inf')] * num_vertices\n    parent = [None] * num_vertices\n    key[0] = 0\n\n    for _ in range(num_vertices):\n        min_key = float('inf')\n        min_vertex = None\n        for v in range(num_vertices):\n            if not mst[v] and key[v] < min_key:\n                min_key = key[v]\n                min_vertex = v\n        mst[min_vertex] = True\n\n        for v in range(num_vertices):\n            if graph[min_vertex][v] > 0 and not mst[v] and graph[min_vertex][v] < key[v]:\n                key[v] = graph[min_vertex][v]\n                parent[v] = min_vertex\n\n    return sum(graph[v][parent[v]] for v in range(1, num_vertices))", "solution_func": "def g():\n    graph = [\n        [0, 2, 0, 6, 0],\n        [2, 0, 3, 8, 5],\n        [0, 3, 0, 0, 7],\n        [6, 8, 0, 0, 9],\n        [0, 5, 7, 9, 0]\n    ]\n    return graph", "map_ix": [1, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the number of occurrences of a specific target number.\n\n    Example:\n    nums = [1, 2, 2, 2, 3, 4, 5, 6, 6, 7, 8, 8, 9]\n    target = 2\n\n    Output:\n    3\n\n    Explanation:\n    The number 2 occurs 3 times in the list.\n\n    Constraints:\n    - The input list will always be sorted in ascending order.\n    - The input list may contain duplicate elements.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n    count = 0\n\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            count += 1\n            left = mid + 1\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return count\n\ndef g():\n    nums = [1, 2, 2, 2, 3, 4, 5, 6, 6, 7, 8, 8, 9]\n    target = 2\n    return nums, target\n\nassert f(*g()) == 3\n\n", "emb": null, "idx_generation": 476, "target_skills": [1, 1, 1, 0, 0, 1, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the number of occurrences of a specific target number.\n\n    Example:\n    nums = [1, 2, 2, 2, 3, 4, 5, 6, 6, 7, 8, 8, 9]\n    target = 2\n\n    Output:\n    3\n\n    Explanation:\n    The number 2 occurs 3 times in the list.\n\n    Constraints:\n    - The input list will always be sorted in ascending order.\n    - The input list may contain duplicate elements.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n    count = 0\n\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            count += 1\n            left = mid + 1\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return count", "solution_func": "def g():\n    nums = [1, 2, 2, 2, 3, 4, 5, 6, 6, 7, 8, 8, 9]\n    target = 2\n    return nums, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency list and two nodes, determine if there is a path from the start node to the end node.\n\n    Example:\n    graph = [\n        [1, 2],\n        [2],\n        [3],\n        [],\n    ]\n    start = 0\n    end = 3\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 0 to node 3 in the graph.\n\n    Hint: Use a depth-first search (DFS) algorithm to traverse the graph and determine if there is a path from the start node to the end node.\n    \"\"\"\n    visited = [False] * len(graph)\n    \n    def dfs(node):\n        if node == end:\n            return True\n        \n        visited[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n        \n        return False\n    \n    return dfs(start)\n\ndef g() -> Tuple[List[List[int]], int, int]:\n    \"\"\"\n    Generate a directed graph represented as an adjacency list, and two nodes (start and end) for the puzzle.\n    \"\"\"\n    graph = [\n        [1, 2],\n        [2],\n        [3],\n        [],\n    ]\n    start = 0\n    end = 3\n    return graph, start, end\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 476, "target_skills": [0, 1, 1, 1, 0, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency list and two nodes, determine if there is a path from the start node to the end node.\n\n    Example:\n    graph = [\n        [1, 2],\n        [2],\n        [3],\n        [],\n    ]\n    start = 0\n    end = 3\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 0 to node 3 in the graph.\n\n    Hint: Use a depth-first search (DFS) algorithm to traverse the graph and determine if there is a path from the start node to the end node.\n    \"\"\"\n    visited = [False] * len(graph)\n    \n    def dfs(node):\n        if node == end:\n            return True\n        \n        visited[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n        \n        return False\n    \n    return dfs(start)", "solution_func": "def g() -> Tuple[List[List[int]], int, int]:\n    \"\"\"\n    Generate a directed graph represented as an adjacency list, and two nodes (start and end) for the puzzle.\n    \"\"\"\n    graph = [\n        [1, 2],\n        [2],\n        [3],\n        [],\n    ]\n    start = 0\n    end = 3\n    return graph, start, end", "map_ix": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the number of ways to arrange n pairs of parentheses in a valid combination.\n\n    Example:\n    n = 3\n\n    Output:\n    5\n\n    Explanation:\n    The valid combinations of arranging 3 pairs of parentheses are: \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\". There are 5 valid combinations.\n    \"\"\"\n    dp = [0] * (n+1)\n    dp[0] = 1\n    for i in range(1, n+1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i-j-1]\n    return dp[n]\n\ndef g(n=3):\n    return n\n\nassert f(g()) == 5\n\n", "emb": [0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 477, "target_skills": [0, 1, 1, 0, 1, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the number of ways to arrange n pairs of parentheses in a valid combination.\n\n    Example:\n    n = 3\n\n    Output:\n    5\n\n    Explanation:\n    The valid combinations of arranging 3 pairs of parentheses are: \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\". There are 5 valid combinations.\n    \"\"\"\n    dp = [0] * (n+1)\n    dp[0] = 1\n    for i in range(1, n+1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i-j-1]\n    return dp[n]", "solution_func": "def g(n=3):\n    return n", "map_ix": [0, 1, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the maximum XOR value between two numbers in the array.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value between two numbers in the array is achieved by XORing 5 and 25, resulting in 28.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n        for num in nums:\n            prefix_set.add(num & mask)\n        max_candidate = max_xor | (1 << i)\n        for prefix in prefix_set:\n            if max_candidate ^ prefix in prefix_set:\n                max_xor = max_candidate\n                break\n    return max_xor\n\ndef g(nums=[3, 10, 5, 25, 2, 8]):\n    return nums\n\nassert f(g()) == 28\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 477, "target_skills": [1, 0, 1, 1, 1, 0, 0, 1, 1, 1], "problem_func": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the maximum XOR value between two numbers in the array.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value between two numbers in the array is achieved by XORing 5 and 25, resulting in 28.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n        for num in nums:\n            prefix_set.add(num & mask)\n        max_candidate = max_xor | (1 << i)\n        for prefix in prefix_set:\n            if max_candidate ^ prefix in prefix_set:\n                max_xor = max_candidate\n                break\n    return max_xor", "solution_func": "def g(nums=[3, 10, 5, 25, 2, 8]):\n    return nums", "map_ix": [1, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two positive integers n and k, calculate the number of different permutations of choosing k elements from a set of n elements.\n\n    Sample Input:\n    n = 5\n    k = 3\n\n    Sample Output:\n    60\n    Explanation: There are 60 different permutations of choosing 3 elements from a set of 5 elements.\n    \"\"\"\n    def factorial(num: int) -> int:\n        fact = 1\n        for i in range(1, num+1):\n            fact *= i\n        return fact\n\n    return factorial(n) // factorial(n-k)\n\ndef g(n=5, k=3):\n    return n, k\n\nassert f(*g()) == 60\n\n", "emb": [0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 477, "target_skills": [1, 0, 1, 0, 0, 0, 1, 1, 1, 0], "problem_func": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two positive integers n and k, calculate the number of different permutations of choosing k elements from a set of n elements.\n\n    Sample Input:\n    n = 5\n    k = 3\n\n    Sample Output:\n    60\n    Explanation: There are 60 different permutations of choosing 3 elements from a set of 5 elements.\n    \"\"\"\n    def factorial(num: int) -> int:\n        fact = 1\n        for i in range(1, num+1):\n            fact *= i\n        return fact\n\n    return factorial(n) // factorial(n-k)", "solution_func": "def g(n=5, k=3):\n    return n, k", "map_ix": [0, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the longest increasing subsequence (LIS) in the list.\n\n    Example:\n    nums = [10, 22, 9, 33, 21, 50, 41, 60, 80]\n    The longest increasing subsequence is [10, 22, 33, 50, 60, 80], which has a length of 6.\n    Return the length of the longest increasing subsequence.\n\n    Hint: Use dynamic programming to solve this problem.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g():\n    return [10, 22, 9, 33, 21, 50, 41, 60, 80]\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 477, "target_skills": [0, 1, 1, 0, 1, 1, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the longest increasing subsequence (LIS) in the list.\n\n    Example:\n    nums = [10, 22, 9, 33, 21, 50, 41, 60, 80]\n    The longest increasing subsequence is [10, 22, 33, 50, 60, 80], which has a length of 6.\n    Return the length of the longest increasing subsequence.\n\n    Hint: Use dynamic programming to solve this problem.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)", "solution_func": "def g():\n    return [10, 22, 9, 33, 21, 50, 41, 60, 80]", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray XOR value.\n\n    Example:\n    nums = [2, 3, -1, 8, -2, 5, -4]\n    The maximum subarray XOR value is 11, which is obtained from the subarray [2, 3, -1, 8, -2, 5].\n\n    Return the maximum subarray XOR value.\n\n    Hint: Use dynamic programming and bit manipulation to solve this problem.\n    \"\"\"\n    max_xor = float('-inf')\n    curr_xor = 0\n    prefix_xor = {0: -1}\n\n    for i, num in enumerate(nums):\n        curr_xor ^= num\n        prefix_xor[curr_xor] = i\n        max_xor = max(max_xor, curr_xor)\n\n        for j in range(32):\n            check_xor = curr_xor ^ (1 << j)\n            if check_xor in prefix_xor:\n                max_xor = max(max_xor, curr_xor ^ prefix_xor[check_xor])\n\n    return max_xor\n\ndef g():\n    return [2, 3, -1, 8, -2, 5, -4]\n\nassert f(g()) == 11\n\n", "emb": null, "idx_generation": 477, "target_skills": [0, 1, 0, 0, 0, 1, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray XOR value.\n\n    Example:\n    nums = [2, 3, -1, 8, -2, 5, -4]\n    The maximum subarray XOR value is 11, which is obtained from the subarray [2, 3, -1, 8, -2, 5].\n\n    Return the maximum subarray XOR value.\n\n    Hint: Use dynamic programming and bit manipulation to solve this problem.\n    \"\"\"\n    max_xor = float('-inf')\n    curr_xor = 0\n    prefix_xor = {0: -1}\n\n    for i, num in enumerate(nums):\n        curr_xor ^= num\n        prefix_xor[curr_xor] = i\n        max_xor = max(max_xor, curr_xor)\n\n        for j in range(32):\n            check_xor = curr_xor ^ (1 << j)\n            if check_xor in prefix_xor:\n                max_xor = max(max_xor, curr_xor ^ prefix_xor[check_xor])\n\n    return max_xor", "solution_func": "def g():\n    return [2, 3, -1, 8, -2, 5, -4]", "map_ix": null}, {"fitness": 1.0, "program_str": "import math\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all numbers that are multiples of either 3 or 5.\n\n    Example:\n    nums = [3, 5, 6, 9, 10, 12, 15]\n    The multiples of 3 or 5 are 3, 5, 6, 9, 10, 12, 15.\n    The sum of these numbers is 60.\n\n    Return the sum of all numbers that are multiples of either 3 or 5.\n\n    Hint: Use mathematical foundations and bit manipulation to solve this problem.\n    \"\"\"\n    sum_multiples = 0\n\n    for num in nums:\n        if num % 3 == 0 or num % 5 == 0:\n            sum_multiples += num\n\n    return sum_multiples\n\ndef g():\n    return [3, 5, 6, 9, 10, 12, 15]\n\nassert f(g()) == 60\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 477, "target_skills": [0, 0, 0, 1, 1, 0, 1, 1, 1, 0], "problem_func": "import math\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all numbers that are multiples of either 3 or 5.\n\n    Example:\n    nums = [3, 5, 6, 9, 10, 12, 15]\n    The multiples of 3 or 5 are 3, 5, 6, 9, 10, 12, 15.\n    The sum of these numbers is 60.\n\n    Return the sum of all numbers that are multiples of either 3 or 5.\n\n    Hint: Use mathematical foundations and bit manipulation to solve this problem.\n    \"\"\"\n    sum_multiples = 0\n\n    for num in nums:\n        if num % 3 == 0 or num % 5 == 0:\n            sum_multiples += num\n\n    return sum_multiples", "solution_func": "def g():\n    return [3, 5, 6, 9, 10, 12, 15]", "map_ix": [1, 0, 0, 0, 1, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the list.\n    \n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    \n    Output:\n    [0, 1]\n    \n    Explanation:\n    The numbers at indices 0 and 1 (2 and 7) add up to the target value of 9.\n    \"\"\"\n    \n    seen = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    \n    return []\n\ndef g():\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 477, "target_skills": [0, 0, 1, 1, 1, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the list.\n    \n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    \n    Output:\n    [0, 1]\n    \n    Explanation:\n    The numbers at indices 0 and 1 (2 and 7) add up to the target value of 9.\n    \"\"\"\n    \n    seen = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    \n    return []", "solution_func": "def g():\n    return [2, 7, 11, 15], 9", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return the elements of the matrix in spiral order.\n    \n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    \n    Output:\n    [1, 2, 3, 6, 9, 8, 7, 4, 5]\n    \n    Explanation:\n    The elements of the matrix are traversed in the following order: \n    1, 2, 3, 6, 9, 8, 7, 4, 5\n    \"\"\"\n    \n    if not matrix:\n        return []\n    \n    result = []\n    top = 0\n    bottom = len(matrix) - 1\n    left = 0\n    right = len(matrix[0]) - 1\n    \n    while top <= bottom and left <= right:\n        # Traverse top row\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n        \n        # Traverse right column\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n        \n        # Traverse bottom row\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n        \n        # Traverse left column\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n    \n    return result\n\ndef g():\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0], "idx_generation": 477, "target_skills": [1, 0, 1, 0, 1, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return the elements of the matrix in spiral order.\n    \n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    \n    Output:\n    [1, 2, 3, 6, 9, 8, 7, 4, 5]\n    \n    Explanation:\n    The elements of the matrix are traversed in the following order: \n    1, 2, 3, 6, 9, 8, 7, 4, 5\n    \"\"\"\n    \n    if not matrix:\n        return []\n    \n    result = []\n    top = 0\n    bottom = len(matrix) - 1\n    left = 0\n    right = len(matrix[0]) - 1\n    \n    while top <= bottom and left <= right:\n        # Traverse top row\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n        \n        # Traverse right column\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n        \n        # Traverse bottom row\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n        \n        # Traverse left column\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n    \n    return result", "solution_func": "def g():\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]", "map_ix": [1, 0, 1, 0, 0, 1, 1, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of non-negative integers representing the heights of a set of buildings,\n    calculate the total amount of rainwater that can be trapped between the buildings.\n    \n    Example:\n    heights = [0, 1, 0, 2, 1, 0, 3, 2, 1, 2, 1]\n    \n    Output:\n    6\n    \n    Explanation:\n    The heights of the buildings are visualized as follows:\n    [0, 1, 0, 2, 1, 0, 3, 2, 1, 2, 1]\n    \n    The amount of rainwater that can be trapped between the buildings is 6 units.\n    \"\"\"\n    \n    if not heights:\n        return 0\n    \n    n = len(heights)\n    left_max = [0] * n\n    right_max = [0] * n\n    \n    left_max[0] = heights[0]\n    for i in range(1, n):\n        left_max[i] = max(left_max[i-1], heights[i])\n    \n    right_max[n-1] = heights[n-1]\n    for i in range(n-2, -1, -1):\n        right_max[i] = max(right_max[i+1], heights[i])\n    \n    total_water = 0\n    for i in range(n):\n        min_height = min(left_max[i], right_max[i])\n        if min_height > heights[i]:\n            total_water += min_height - heights[i]\n    \n    return total_water\n\ndef g():\n    return [0, 1, 0, 2, 1, 0, 3, 2, 1, 2, 1]\n\nassert f(g()) == 6\n", "emb": null, "idx_generation": 477, "target_skills": [1, 1, 0, 1, 1, 0, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of non-negative integers representing the heights of a set of buildings,\n    calculate the total amount of rainwater that can be trapped between the buildings.\n    \n    Example:\n    heights = [0, 1, 0, 2, 1, 0, 3, 2, 1, 2, 1]\n    \n    Output:\n    6\n    \n    Explanation:\n    The heights of the buildings are visualized as follows:\n    [0, 1, 0, 2, 1, 0, 3, 2, 1, 2, 1]\n    \n    The amount of rainwater that can be trapped between the buildings is 6 units.\n    \"\"\"\n    \n    if not heights:\n        return 0\n    \n    n = len(heights)\n    left_max = [0] * n\n    right_max = [0] * n\n    \n    left_max[0] = heights[0]\n    for i in range(1, n):\n        left_max[i] = max(left_max[i-1], heights[i])\n    \n    right_max[n-1] = heights[n-1]\n    for i in range(n-2, -1, -1):\n        right_max[i] = max(right_max[i+1], heights[i])\n    \n    total_water = 0\n    for i in range(n):\n        min_height = min(left_max[i], right_max[i])\n        if min_height > heights[i]:\n            total_water += min_height - heights[i]\n    \n    return total_water", "solution_func": "def g():\n    return [0, 1, 0, 2, 1, 0, 3, 2, 1, 2, 1]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct combinations that add up to a target value.\n\n    Example:\n    nums = [1, 2, 3]\n    target = 4\n\n    Output:\n    7\n\n    Explanation:\n    There are 7 distinct combinations that add up to 4: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2], [1, 3], [3, 1].\n    \"\"\"\n\n    def count_combinations(nums, target):\n        if target == 0:\n            return 1\n        if target < 0:\n            return 0\n\n        count = 0\n        for num in nums:\n            count += count_combinations(nums, target - num)\n\n        return count\n\n    return count_combinations(nums, len(nums))\n\ndef g(nums: List[int] = [1, 2, 3]):\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return (nums,)\n\nassert f(*g()) == 7\n", "emb": null, "idx_generation": 477, "target_skills": [1, 0, 0, 0, 1, 1, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct combinations that add up to a target value.\n\n    Example:\n    nums = [1, 2, 3]\n    target = 4\n\n    Output:\n    7\n\n    Explanation:\n    There are 7 distinct combinations that add up to 4: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2], [1, 3], [3, 1].\n    \"\"\"\n\n    def count_combinations(nums, target):\n        if target == 0:\n            return 1\n        if target < 0:\n            return 0\n\n        count = 0\n        for num in nums:\n            count += count_combinations(nums, target - num)\n\n        return count\n\n    return count_combinations(nums, len(nums))", "solution_func": "def g(nums: List[int] = [1, 2, 3]):\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return (nums,)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers n and m, calculate the number of ways to choose m items from a set of n distinct items.\n\n    Example:\n    n = 5\n    m = 3\n\n    Output:\n    10\n\n    Explanation:\n    There are 10 ways to choose 3 items from a set of 5 distinct items.\n\n    Hint: Use combinatorial analysis to solve the problem.\n    \"\"\"\n\n    def factorial(num: int) -> int:\n        if num <= 1:\n            return 1\n        return num * factorial(num - 1)\n\n    return factorial(n) // (factorial(m) * factorial(n - m))\n\ndef g(n: int = 5, m: int = 3) -> int:\n    \"\"\"\n    Return the input values n and m.\n    \"\"\"\n    return n, m\n\nassert f(*g()) == 10\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 478, "target_skills": [0, 1, 1, 1, 1, 1, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers n and m, calculate the number of ways to choose m items from a set of n distinct items.\n\n    Example:\n    n = 5\n    m = 3\n\n    Output:\n    10\n\n    Explanation:\n    There are 10 ways to choose 3 items from a set of 5 distinct items.\n\n    Hint: Use combinatorial analysis to solve the problem.\n    \"\"\"\n\n    def factorial(num: int) -> int:\n        if num <= 1:\n            return 1\n        return num * factorial(num - 1)\n\n    return factorial(n) // (factorial(m) * factorial(n - m))", "solution_func": "def g(n: int = 5, m: int = 3) -> int:\n    \"\"\"\n    Return the input values n and m.\n    \"\"\"\n    return n, m", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all elements that have a set bit at a specific position.\n\n    Example:\n    numbers = [2, 3, 5, 8]\n    position = 1\n\n    Output:\n    11\n\n    Explanation:\n    The integers with a set bit at position 1 are 3 (0b11) and 5 (0b101). Their sum is 11.\n\n    Hint: Use bitwise operations to check if a bit is set.\n    \"\"\"\n\n    result = 0\n    for num in numbers:\n        if num & (1 << position):\n            result += num\n    return result\n\ndef g(numbers: List[int] = [2, 3, 5, 8], position: int = 1) -> List[int]:\n    \"\"\"\n    Return the input list of numbers and the position.\n    \"\"\"\n    return numbers, position\n\nassert f(*g()) == 11\n\n", "emb": null, "idx_generation": 478, "target_skills": [0, 1, 0, 0, 1, 0, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all elements that have a set bit at a specific position.\n\n    Example:\n    numbers = [2, 3, 5, 8]\n    position = 1\n\n    Output:\n    11\n\n    Explanation:\n    The integers with a set bit at position 1 are 3 (0b11) and 5 (0b101). Their sum is 11.\n\n    Hint: Use bitwise operations to check if a bit is set.\n    \"\"\"\n\n    result = 0\n    for num in numbers:\n        if num & (1 << position):\n            result += num\n    return result", "solution_func": "def g(numbers: List[int] = [2, 3, 5, 8], position: int = 1) -> List[int]:\n    \"\"\"\n    Return the input list of numbers and the position.\n    \"\"\"\n    return numbers, position", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> str:\n    \"\"\"\n    Given a list of words, find the longest common prefix among them.\n\n    Example:\n    words = [\"apple\", \"application\", \"appstore\"]\n\n    Output:\n    \"app\"\n\n    Explanation:\n    The longest common prefix among the words is \"app\".\n\n    Hint: Use string manipulation techniques to compare prefixes.\n    \"\"\"\n\n    if not words:\n        return \"\"\n\n    min_length = min(len(word) for word in words)\n    prefix = \"\"\n\n    for i in range(min_length):\n        char = words[0][i]\n        for word in words:\n            if word[i] != char:\n                return prefix\n        prefix += char\n\n    return prefix\n\ndef g(words: List[str] = [\"apple\", \"application\", \"appstore\"]) -> List[str]:\n    \"\"\"\n    Return the input list of words.\n    \"\"\"\n    return words\n\nassert f(*g()) == \"app\"\n\n", "emb": null, "idx_generation": 478, "target_skills": [0, 0, 1, 0, 1, 0, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> str:\n    \"\"\"\n    Given a list of words, find the longest common prefix among them.\n\n    Example:\n    words = [\"apple\", \"application\", \"appstore\"]\n\n    Output:\n    \"app\"\n\n    Explanation:\n    The longest common prefix among the words is \"app\".\n\n    Hint: Use string manipulation techniques to compare prefixes.\n    \"\"\"\n\n    if not words:\n        return \"\"\n\n    min_length = min(len(word) for word in words)\n    prefix = \"\"\n\n    for i in range(min_length):\n        char = words[0][i]\n        for word in words:\n            if word[i] != char:\n                return prefix\n        prefix += char\n\n    return prefix", "solution_func": "def g(words: List[str] = [\"apple\", \"application\", \"appstore\"]) -> List[str]:\n    \"\"\"\n    Return the input list of words.\n    \"\"\"\n    return words", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two elements in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask = mask | (1 << i)\n        xor_set = set()\n        for num in nums:\n            xor_set.add(num & mask)\n        temp = max_xor | (1 << i)\n        for prefix in xor_set:\n            if prefix ^ temp in xor_set:\n                max_xor = temp\n                break\n    return max_xor\n\ndef g(nums=[3, 10, 5, 25, 2, 8]):\n    return nums\n\nassert f(*g()) == 28\n", "emb": null, "idx_generation": 478, "target_skills": [1, 0, 0, 0, 0, 0, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two elements in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask = mask | (1 << i)\n        xor_set = set()\n        for num in nums:\n            xor_set.add(num & mask)\n        temp = max_xor | (1 << i)\n        for prefix in xor_set:\n            if prefix ^ temp in xor_set:\n                max_xor = temp\n                break\n    return max_xor", "solution_func": "def g(nums=[3, 10, 5, 25, 2, 8]):\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the number of pairs of elements in the list\n    that XOR to the target.\n\n    Example:\n    nums = [4, 7, 10, 2, 9]\n    target = 6\n\n    Output:\n    2\n    \"\"\"\n    count = 0\n    xor_set = set()\n    for num in nums:\n        if num ^ target in xor_set:\n            count += 1\n        xor_set.add(num)\n    return count\n\ndef g(nums=[4, 7, 10, 2, 9], target=6):\n    return nums, target\n\nassert f(*g()) == 2\n", "emb": null, "idx_generation": 478, "target_skills": [0, 0, 0, 0, 1, 0, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the number of pairs of elements in the list\n    that XOR to the target.\n\n    Example:\n    nums = [4, 7, 10, 2, 9]\n    target = 6\n\n    Output:\n    2\n    \"\"\"\n    count = 0\n    xor_set = set()\n    for num in nums:\n        if num ^ target in xor_set:\n            count += 1\n        xor_set.add(num)\n    return count", "solution_func": "def g(nums=[4, 7, 10, 2, 9], target=6):\n    return nums, target", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number k, find the number of triplets of elements in the list\n    that XOR to k.\n\n    Example:\n    nums = [5, 2, 7, 10, 4]\n    k = 9\n\n    Output:\n    2\n    \"\"\"\n    count = 0\n    xor_set = set()\n    for num in nums:\n        if k ^ num in xor_set:\n            count += 1\n        for xor_val in xor_set:\n            xor_set.add(xor_val ^ num)\n        xor_set.add(num)\n    return count\n\ndef g(nums=[5, 2, 7, 10, 4], k=9):\n    return nums, k\n\nassert f(*g()) == 2\n", "emb": null, "idx_generation": 478, "target_skills": [0, 1, 0, 0, 1, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number k, find the number of triplets of elements in the list\n    that XOR to k.\n\n    Example:\n    nums = [5, 2, 7, 10, 4]\n    k = 9\n\n    Output:\n    2\n    \"\"\"\n    count = 0\n    xor_set = set()\n    for num in nums:\n        if k ^ num in xor_set:\n            count += 1\n        for xor_val in xor_set:\n            xor_set.add(xor_val ^ num)\n        xor_set.add(num)\n    return count", "solution_func": "def g(nums=[5, 2, 7, 10, 4], k=9):\n    return nums, k", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR value between two numbers in the array.\n\n    Example:\n    arr = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value between two numbers in the array is 28, which is the result of 25 XOR 5.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(32, -1, -1):\n        mask |= (1 << i)\n        prefixes = set()\n        for num in arr:\n            prefixes.add(num & mask)\n        target_xor = max_xor | (1 << i)\n        for prefix in prefixes:\n            if (prefix ^ target_xor) in prefixes:\n                max_xor = target_xor\n                break\n    return max_xor\n\ndef g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n\n", "emb": [0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 478, "target_skills": [1, 0, 1, 1, 0, 1, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR value between two numbers in the array.\n\n    Example:\n    arr = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value between two numbers in the array is 28, which is the result of 25 XOR 5.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(32, -1, -1):\n        mask |= (1 << i)\n        prefixes = set()\n        for num in arr:\n            prefixes.add(num & mask)\n        target_xor = max_xor | (1 << i)\n        for prefix in prefixes:\n            if (prefix ^ target_xor) in prefixes:\n                max_xor = target_xor\n                break\n    return max_xor", "solution_func": "def g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]", "map_ix": [0, 1, 0, 1, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(arr: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    Given an array of integers, find the two numbers that have the minimum XOR value.\n\n    Example:\n    arr = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    (3, 2)\n\n    Explanation:\n    The pair of numbers (3, 2) has the minimum XOR value of 1.\n    \"\"\"\n    min_xor = float('inf')\n    num1, num2 = 0, 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            xor_val = arr[i] ^ arr[j]\n            if xor_val < min_xor:\n                min_xor = xor_val\n                num1, num2 = arr[i], arr[j]\n    return num1, num2\n\ndef g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == (3, 2)\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 478, "target_skills": [1, 1, 1, 0, 1, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(arr: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    Given an array of integers, find the two numbers that have the minimum XOR value.\n\n    Example:\n    arr = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    (3, 2)\n\n    Explanation:\n    The pair of numbers (3, 2) has the minimum XOR value of 1.\n    \"\"\"\n    min_xor = float('inf')\n    num1, num2 = 0, 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            xor_val = arr[i] ^ arr[j]\n            if xor_val < min_xor:\n                min_xor = xor_val\n                num1, num2 = arr[i], arr[j]\n    return num1, num2", "solution_func": "def g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(arr: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    Given an array of integers, find the two numbers that have the maximum XOR value.\n\n    Example:\n    arr = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    (10, 25)\n\n    Explanation:\n    The pair of numbers (10, 25) has the maximum XOR value of 27.\n    \"\"\"\n    max_xor = 0\n    num1, num2 = 0, 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            xor_val = arr[i] ^ arr[j]\n            if xor_val > max_xor:\n                max_xor = xor_val\n                num1, num2 = arr[i], arr[j]\n    return num1, num2\n\ndef g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == (10, 25)\n\n", "emb": null, "idx_generation": 478, "target_skills": [0, 0, 1, 0, 0, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(arr: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    Given an array of integers, find the two numbers that have the maximum XOR value.\n\n    Example:\n    arr = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    (10, 25)\n\n    Explanation:\n    The pair of numbers (10, 25) has the maximum XOR value of 27.\n    \"\"\"\n    max_xor = 0\n    num1, num2 = 0, 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            xor_val = arr[i] ^ arr[j]\n            if xor_val > max_xor:\n                max_xor = xor_val\n                num1, num2 = arr[i], arr[j]\n    return num1, num2", "solution_func": "def g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Check if a target number is present in a sorted list of integers using binary search.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5], target: int = 3) -> List[int]:\n    return nums\n\nassert f(g(), 3) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 478, "target_skills": [0, 1, 1, 1, 1, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Check if a target number is present in a sorted list of integers using binary search.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False", "solution_func": "def g(nums: List[int] = [1, 2, 3, 4, 5], target: int = 3) -> List[int]:\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order and return the sorted list.\n    \"\"\"\n    nums.sort()\n    return nums\n\ndef g() -> List[int]:\n    \"\"\"\n    Return a list of integers.\n    \"\"\"\n    return [4, 2, 1, 3]\n\nassert f(g()) == [1, 2, 3, 4]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 479, "target_skills": [1, 1, 1, 0, 1, 0, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order and return the sorted list.\n    \"\"\"\n    nums.sort()\n    return nums", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Return a list of integers.\n    \"\"\"\n    return [4, 2, 1, 3]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix represented by a list of lists, where each inner list represents a row, find the maximum value in the matrix.\n    \"\"\"\n    max_value = float('-inf')\n    for row in matrix:\n        for num in row:\n            if num > max_value:\n                max_value = num\n    return max_value\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Return a matrix represented by a list of lists.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 9\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 479, "target_skills": [1, 0, 1, 1, 1, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix represented by a list of lists, where each inner list represents a row, find the maximum value in the matrix.\n    \"\"\"\n    max_value = float('-inf')\n    for row in matrix:\n        for num in row:\n            if num > max_value:\n                max_value = num\n    return max_value", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Return a matrix represented by a list of lists.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of even numbers between 1 and n (inclusive) that can be expressed as the sum of two prime numbers.\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            for j in range(2, i // 2 + 1):\n                if is_prime(j) and is_prime(i - j):\n                    count += 1\n                    break\n    return count\n\ndef g(n=10):\n    \"\"\"\n    Return the given positive integer n.\n    \"\"\"\n    return n\n\nassert f(g()) == 2\n", "emb": null, "idx_generation": 479, "target_skills": [1, 1, 1, 0, 1, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of even numbers between 1 and n (inclusive) that can be expressed as the sum of two prime numbers.\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            for j in range(2, i // 2 + 1):\n                if is_prime(j) and is_prime(i - j):\n                    count += 1\n                    break\n    return count", "solution_func": "def g(n=10):\n    \"\"\"\n    Return the given positive integer n.\n    \"\"\"\n    return n", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nimport collections\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list that sum up to the target\"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums=[2, 4, 6, 8, 10], target=12):\n    return f(nums, target)\n\nassert f(g())\n", "emb": null, "idx_generation": 479, "target_skills": [1, 0, 0, 1, 1, 0, 0, 1, 1, 0], "problem_func": "from typing import*\nimport collections\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list that sum up to the target\"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False", "solution_func": "def g(nums=[2, 4, 6, 8, 10], target=12):\n    return f(nums, target)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(num: int) -> bool:\n    \"\"\"Check if a given number is a power of 2\"\"\"\n    if num <= 0:\n        return False\n    return num & (num - 1) == 0\n\ndef g(num=16):\n    return f(num)\n\nassert f(g())\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 479, "target_skills": [1, 0, 1, 1, 0, 1, 0, 0, 0, 1], "problem_func": "from typing import*\ndef f(num: int) -> bool:\n    \"\"\"Check if a given number is a power of 2\"\"\"\n    if num <= 0:\n        return False\n    return num & (num - 1) == 0", "solution_func": "def g(num=16):\n    return f(num)", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"Check if a given string is a palindrome\"\"\"\n    if len(string) <= 1:\n        return True\n    if string[0] != string[-1]:\n        return False\n    return f(string[1:-1])\n\ndef g(string=\"racecar\"):\n    return f(string)\n\nassert f(g())\n", "emb": null, "idx_generation": 479, "target_skills": [0, 0, 1, 1, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"Check if a given string is a palindrome\"\"\"\n    if len(string) <= 1:\n        return True\n    if string[0] != string[-1]:\n        return False\n    return f(string[1:-1])", "solution_func": "def g(string=\"racecar\"):\n    return f(string)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers and a target value, find two numbers in the array that\n    sum up to the target value. Return the indices of the two numbers.\n\n    Args:\n    - arr: A list of integers in sorted order.\n    - target: The target value.\n\n    Returns:\n    - A list containing the indices of the two numbers that sum up to the target value.\n\n    Example:\n    arr = [2, 4, 6, 8, 10], target = 14\n    Output: [2, 4]\n\n    Explanation:\n    The numbers at indices 2 and 4 (6 and 8) sum up to the target value 14.\n\n    Hint: Use the two-pointer technique to solve this problem.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    arr = [2, 4, 6, 8, 10]\n    target = 14\n    return arr, target\n\nassert f(*g()) == [2, 4]\n", "emb": null, "idx_generation": 479, "target_skills": [0, 0, 0, 1, 0, 0, 1, 0, 1, 0], "problem_func": "from typing import*\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers and a target value, find two numbers in the array that\n    sum up to the target value. Return the indices of the two numbers.\n\n    Args:\n    - arr: A list of integers in sorted order.\n    - target: The target value.\n\n    Returns:\n    - A list containing the indices of the two numbers that sum up to the target value.\n\n    Example:\n    arr = [2, 4, 6, 8, 10], target = 14\n    Output: [2, 4]\n\n    Explanation:\n    The numbers at indices 2 and 4 (6 and 8) sum up to the target value 14.\n\n    Hint: Use the two-pointer technique to solve this problem.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    arr = [2, 4, 6, 8, 10]\n    target = 14\n    return arr, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> int:\n    \"\"\"\n    Given a binary tree, calculate the sum of all the numbers formed by concatenating\n    the root-to-leaf paths.\n\n    Args:\n    - root: The root node of the binary tree.\n\n    Returns:\n    - The sum of all the numbers formed by concatenating the root-to-leaf paths.\n\n    Example:\n    Input:\n         1\n        / \\\n       2   3\n\n    Output: 25\n\n    Explanation:\n    The root-to-leaf paths are \"1->2\" and \"1->3\". The numbers formed by concatenating\n    these paths are 12 and 13 respectively. The sum of these numbers is 25.\n\n    Hint: Use a recursive helper function to traverse the tree and calculate the sum.\n    \"\"\"\n\n    def helper(node: TreeNode, path_sum: int) -> int:\n        if node is None:\n            return 0\n\n        path_sum = (path_sum * 10) + node.val\n\n        if node.left is None and node.right is None:\n            return path_sum\n\n        return helper(node.left, path_sum) + helper(node.right, path_sum)\n\n    return helper(root, 0)\n\ndef g() -> TreeNode:\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    return root\n\nassert f(g()) == 25\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 479, "target_skills": [1, 0, 1, 0, 0, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> int:\n    \"\"\"\n    Given a binary tree, calculate the sum of all the numbers formed by concatenating\n    the root-to-leaf paths.\n\n    Args:\n    - root: The root node of the binary tree.\n\n    Returns:\n    - The sum of all the numbers formed by concatenating the root-to-leaf paths.\n\n    Example:\n    Input:\n         1\n        / \\\n       2   3\n\n    Output: 25\n\n    Explanation:\n    The root-to-leaf paths are \"1->2\" and \"1->3\". The numbers formed by concatenating\n    these paths are 12 and 13 respectively. The sum of these numbers is 25.\n\n    Hint: Use a recursive helper function to traverse the tree and calculate the sum.\n    \"\"\"\n\n    def helper(node: TreeNode, path_sum: int) -> int:\n        if node is None:\n            return 0\n\n        path_sum = (path_sum * 10) + node.val\n\n        if node.left is None and node.right is None:\n            return path_sum\n\n        return helper(node.left, path_sum) + helper(node.right, path_sum)\n\n    return helper(root, 0)", "solution_func": "def g() -> TreeNode:\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    return root", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> List[List[int]]:\n    \"\"\"\n    Given two integers n and m, generate a matrix of size n x m such that it contains all\n    integers from 1 to n*m in a spiral order.\n\n    Args:\n    - n: An integer representing the number of rows in the matrix.\n    - m: An integer representing the number of columns in the matrix.\n\n    Returns:\n    - A matrix of size n x m containing integers from 1 to n*m in a spiral order.\n\n    Example:\n    n = 3, m = 3\n    Output: [[1, 2, 3], [8, 9, 4], [7, 6, 5]]\n\n    Explanation:\n    The spiral order of the matrix is [1, 2, 3, 4, 5, 6, 7, 8, 9]. When reshaped into a\n    matrix of size 3 x 3, it becomes [[1, 2, 3], [8, 9, 4], [7, 6, 5]].\n\n    Hint: Use a recursive function to generate the spiral order matrix.\n    \"\"\"\n\n    def generate_matrix(matrix: List[List[int]], start: int, end: int, num: int) -> None:\n        if start > end or num > n * m:\n            return\n\n        for i in range(start, end + 1):\n            matrix[start][i] = num\n            num += 1\n\n        for i in range(start + 1, end + 1):\n            matrix[i][end] = num\n            num += 1\n\n        for i in range(end - 1, start - 1, -1):\n            matrix[end][i] = num\n            num += 1\n\n        for i in range(end - 1, start, -1):\n            matrix[i][start] = num\n            num += 1\n\n        generate_matrix(matrix, start + 1, end - 1, num)\n\n    matrix = [[0] * m for _ in range(n)]\n    generate_matrix(matrix, 0, min(n // 2, m // 2), 1)\n\n    return matrix\n\ndef g() -> List[int, int]:\n    n = 3\n    m = 3\n    return n, m\n\nassert f(*g()) == [[1, 2, 3], [8, 9, 4], [7, 6, 5]]\n", "emb": null, "idx_generation": 479, "target_skills": [1, 0, 1, 0, 1, 0, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> List[List[int]]:\n    \"\"\"\n    Given two integers n and m, generate a matrix of size n x m such that it contains all\n    integers from 1 to n*m in a spiral order.\n\n    Args:\n    - n: An integer representing the number of rows in the matrix.\n    - m: An integer representing the number of columns in the matrix.\n\n    Returns:\n    - A matrix of size n x m containing integers from 1 to n*m in a spiral order.\n\n    Example:\n    n = 3, m = 3\n    Output: [[1, 2, 3], [8, 9, 4], [7, 6, 5]]\n\n    Explanation:\n    The spiral order of the matrix is [1, 2, 3, 4, 5, 6, 7, 8, 9]. When reshaped into a\n    matrix of size 3 x 3, it becomes [[1, 2, 3], [8, 9, 4], [7, 6, 5]].\n\n    Hint: Use a recursive function to generate the spiral order matrix.\n    \"\"\"\n\n    def generate_matrix(matrix: List[List[int]], start: int, end: int, num: int) -> None:\n        if start > end or num > n * m:\n            return\n\n        for i in range(start, end + 1):\n            matrix[start][i] = num\n            num += 1\n\n        for i in range(start + 1, end + 1):\n            matrix[i][end] = num\n            num += 1\n\n        for i in range(end - 1, start - 1, -1):\n            matrix[end][i] = num\n            num += 1\n\n        for i in range(end - 1, start, -1):\n            matrix[i][start] = num\n            num += 1\n\n        generate_matrix(matrix, start + 1, end - 1, num)\n\n    matrix = [[0] * m for _ in range(n)]\n    generate_matrix(matrix, 0, min(n // 2, m // 2), 1)\n\n    return matrix", "solution_func": "def g() -> List[int, int]:\n    n = 3\n    m = 3\n    return n, m", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order.\n\n    Example:\n    nums = [5, 2, 8, 1, 9]\n\n    Output:\n    [1, 2, 5, 8, 9]\n    \"\"\"\n    nums.sort()\n    return nums\n\ndef g() -> List[int]:\n    return [5, 2, 8, 1, 9]\n\nassert f(g()) == [1, 2, 5, 8, 9]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 479, "target_skills": [0, 0, 0, 1, 0, 1, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order.\n\n    Example:\n    nums = [5, 2, 8, 1, 9]\n\n    Output:\n    [1, 2, 5, 8, 9]\n    \"\"\"\n    nums.sort()\n    return nums", "solution_func": "def g() -> List[int]:\n    return [5, 2, 8, 1, 9]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find two numbers whose sum is equal to the target number.\n    Return the indices of the two numbers in the list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    Output: [0, 1]\n    Explanation: The sum of nums[0] + nums[1] = 2 + 7 = 9, and their indices are 0 and 1.\n\n    Hint: You can solve this problem using a two-pointer approach.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        \n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 480, "target_skills": [1, 0, 0, 1, 0, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find two numbers whose sum is equal to the target number.\n    Return the indices of the two numbers in the list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    Output: [0, 1]\n    Explanation: The sum of nums[0] + nums[1] = 2 + 7 = 9, and their indices are 0 and 1.\n\n    Hint: You can solve this problem using a two-pointer approach.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        \n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []", "solution_func": "def g(nums=[2, 7, 11, 15], target=9):\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, rotate the matrix 90 degrees clockwise.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    [\n        [7, 4, 1],\n        [8, 5, 2],\n        [9, 6, 3]\n    ]\n\n    Explanation:\n    The matrix is rotated 90 degrees clockwise.\n\n    Hint: You can solve this problem by first transposing the matrix and then reversing each row.\n    \"\"\"\n    n = len(matrix)\n    \n    # Transpose the matrix\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n    \n    # Reverse each row\n    for i in range(n):\n        matrix[i] = matrix[i][::-1]\n    \n    return matrix\n\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    \"\"\"\n    Generate a matrix of integers.\n    \"\"\"\n    return matrix\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n", "emb": null, "idx_generation": 480, "target_skills": [0, 1, 1, 0, 0, 0, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, rotate the matrix 90 degrees clockwise.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    [\n        [7, 4, 1],\n        [8, 5, 2],\n        [9, 6, 3]\n    ]\n\n    Explanation:\n    The matrix is rotated 90 degrees clockwise.\n\n    Hint: You can solve this problem by first transposing the matrix and then reversing each row.\n    \"\"\"\n    n = len(matrix)\n    \n    # Transpose the matrix\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n    \n    # Reverse each row\n    for i in range(n):\n        matrix[i] = matrix[i][::-1]\n    \n    return matrix", "solution_func": "def g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    \"\"\"\n    Generate a matrix of integers.\n    \"\"\"\n    return matrix", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\nclass Stack:\n    def __init__(self):\n        self.items = []\n\n    def is_empty(self):\n        return len(self.items) == 0\n\n    def push(self, item):\n        self.items.append(item)\n\n    def pop(self):\n        if self.is_empty():\n            return None\n        return self.items.pop()\n\n    def peek(self):\n        if self.is_empty():\n            return None\n        return self.items[-1]\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string containing only parentheses, braces, and brackets, determine if the string is valid.\n    A string is valid if all parentheses, braces, and brackets are properly closed.\n\n    Example:\n    s = \"([{}])\"\n    Output: True\n    Explanation: The string is valid since all parentheses, braces, and brackets are properly closed.\n\n    Hint: You can solve this problem using a stack to keep track of opening and closing brackets.\n    \"\"\"\n    stack = Stack()\n    pairs = {')': '(', ']': '[', '}': '{'}\n    \n    for char in s:\n        if char in pairs.values():\n            stack.push(char)\n        elif char in pairs.keys():\n            if stack.is_empty() or stack.pop() != pairs[char]:\n                return False\n    \n    return stack.is_empty()\n\ndef g(s=\"([{}])\"):\n    \"\"\"\n    Generate a string containing only parentheses, braces, and brackets.\n    \"\"\"\n    return s\n\nassert f(g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 480, "target_skills": [0, 1, 0, 1, 1, 0, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\nclass Stack:\n    def __init__(self):\n        self.items = []\n\n    def is_empty(self):\n        return len(self.items) == 0\n\n    def push(self, item):\n        self.items.append(item)\n\n    def pop(self):\n        if self.is_empty():\n            return None\n        return self.items.pop()\n\n    def peek(self):\n        if self.is_empty():\n            return None\n        return self.items[-1]\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string containing only parentheses, braces, and brackets, determine if the string is valid.\n    A string is valid if all parentheses, braces, and brackets are properly closed.\n\n    Example:\n    s = \"([{}])\"\n    Output: True\n    Explanation: The string is valid since all parentheses, braces, and brackets are properly closed.\n\n    Hint: You can solve this problem using a stack to keep track of opening and closing brackets.\n    \"\"\"\n    stack = Stack()\n    pairs = {')': '(', ']': '[', '}': '{'}\n    \n    for char in s:\n        if char in pairs.values():\n            stack.push(char)\n        elif char in pairs.keys():\n            if stack.is_empty() or stack.pop() != pairs[char]:\n                return False\n    \n    return stack.is_empty()", "solution_func": "def g(s=\"([{}])\"):\n    \"\"\"\n    Generate a string containing only parentheses, braces, and brackets.\n    \"\"\"\n    return s", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums and a target value, find all unique combinations in nums where the sum of the values equals the target.\n    Each number in nums may only be used once in the combination.\n    The solution set must not contain duplicate combinations.\n\n    Example:\n    nums = [10, 1, 2, 7, 6, 1, 5]\n    target = 8\n\n    Output:\n    [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n\n    Hint: Use backtracking to generate all combinations and check if their sum equals the target.\n    \"\"\"\n\n    def backtrack(curr_comb, start, curr_sum):\n        if curr_sum == target:\n            result.append(curr_comb[:])\n            return\n\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n\n            if curr_sum + nums[i] > target:\n                break\n\n            curr_comb.append(nums[i])\n            backtrack(curr_comb, i+1, curr_sum + nums[i])\n            curr_comb.pop()\n\n    nums.sort()\n    result = []\n    backtrack([], 0, 0)\n    return result\n\ndef g():\n    return ([10, 1, 2, 7, 6, 1, 5], 8)\n\nassert f(*g()) == [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 480, "target_skills": [0, 1, 1, 1, 0, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums and a target value, find all unique combinations in nums where the sum of the values equals the target.\n    Each number in nums may only be used once in the combination.\n    The solution set must not contain duplicate combinations.\n\n    Example:\n    nums = [10, 1, 2, 7, 6, 1, 5]\n    target = 8\n\n    Output:\n    [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n\n    Hint: Use backtracking to generate all combinations and check if their sum equals the target.\n    \"\"\"\n\n    def backtrack(curr_comb, start, curr_sum):\n        if curr_sum == target:\n            result.append(curr_comb[:])\n            return\n\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n\n            if curr_sum + nums[i] > target:\n                break\n\n            curr_comb.append(nums[i])\n            backtrack(curr_comb, i+1, curr_sum + nums[i])\n            curr_comb.pop()\n\n    nums.sort()\n    result = []\n    backtrack([], 0, 0)\n    return result", "solution_func": "def g():\n    return ([10, 1, 2, 7, 6, 1, 5], 8)", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target value, return the number of unique combinations in nums where the sum of the values equals the target.\n    Each number in nums may only be used once in the combination.\n    The solution set must not contain duplicate combinations.\n\n    Example:\n    nums = [10, 1, 2, 7, 6, 1, 5]\n    target = 8\n\n    Output:\n    4\n\n    Hint: Use dynamic programming to count the number of unique combinations.\n    \"\"\"\n\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for num in nums:\n        for i in range(target, num-1, -1):\n            dp[i] += dp[i - num]\n\n    return dp[target]\n\ndef g():\n    return ([10, 1, 2, 7, 6, 1, 5], 8)\n\nassert f(*g()) == 4\n\n", "emb": null, "idx_generation": 480, "target_skills": [0, 1, 0, 1, 1, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target value, return the number of unique combinations in nums where the sum of the values equals the target.\n    Each number in nums may only be used once in the combination.\n    The solution set must not contain duplicate combinations.\n\n    Example:\n    nums = [10, 1, 2, 7, 6, 1, 5]\n    target = 8\n\n    Output:\n    4\n\n    Hint: Use dynamic programming to count the number of unique combinations.\n    \"\"\"\n\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for num in nums:\n        for i in range(target, num-1, -1):\n            dp[i] += dp[i - num]\n\n    return dp[target]", "solution_func": "def g():\n    return ([10, 1, 2, 7, 6, 1, 5], 8)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target value, return the minimum number of unique combinations in nums where the sum of the values equals the target.\n    Each number in nums may be used any number of times in the combination.\n    If no combination is possible, return -1.\n\n    Example:\n    nums = [1, 2, 5]\n    target = 11\n\n    Output:\n    3\n\n    Hint: Use dynamic programming to find the minimum number of unique combinations.\n    \"\"\"\n\n    dp = [float('inf')] * (target + 1)\n    dp[0] = 0\n\n    for num in nums:\n        for i in range(num, target + 1):\n            dp[i] = min(dp[i], dp[i - num] + 1)\n\n    return dp[target] if dp[target] != float('inf') else -1\n\ndef g():\n    return ([1, 2, 5], 11)\n\nassert f(*g()) == 3\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 480, "target_skills": [0, 0, 0, 1, 1, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target value, return the minimum number of unique combinations in nums where the sum of the values equals the target.\n    Each number in nums may be used any number of times in the combination.\n    If no combination is possible, return -1.\n\n    Example:\n    nums = [1, 2, 5]\n    target = 11\n\n    Output:\n    3\n\n    Hint: Use dynamic programming to find the minimum number of unique combinations.\n    \"\"\"\n\n    dp = [float('inf')] * (target + 1)\n    dp[0] = 0\n\n    for num in nums:\n        for i in range(num, target + 1):\n            dp[i] = min(dp[i], dp[i - num] + 1)\n\n    return dp[target] if dp[target] != float('inf') else -1", "solution_func": "def g():\n    return ([1, 2, 5], 11)", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n\n    Example:\n    n = 6\n\n    Output:\n    8\n\n    Explanation:\n    The 6th Fibonacci number is 8 (0, 1, 1, 2, 3, 5, 8).\n    \"\"\"\n\n    if n <= 1:\n        return n\n\n    fib = [0, 1]\n    for i in range(2, n+1):\n        fib.append(fib[i-1] + fib[i-2])\n\n    return fib[n]\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    return 6\n\nassert f(g()) == 8\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 480, "target_skills": [0, 1, 1, 1, 1, 1, 0, 0, 1, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n\n    Example:\n    n = 6\n\n    Output:\n    8\n\n    Explanation:\n    The 6th Fibonacci number is 8 (0, 1, 1, 2, 3, 5, 8).\n    \"\"\"\n\n    if n <= 1:\n        return n\n\n    fib = [0, 1]\n    for i in range(2, n+1):\n        fib.append(fib[i-1] + fib[i-2])\n\n    return fib[n]", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    return 6", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the factorial of n.\n\n    Example:\n    n = 5\n\n    Output:\n    120\n\n    Explanation:\n    The factorial of 5 is 5 * 4 * 3 * 2 * 1 = 120.\n    \"\"\"\n\n    if n == 0:\n        return 1\n\n    factorial = 1\n    for i in range(1, n+1):\n        factorial *= i\n\n    return factorial\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    return 5\n\nassert f(g()) == 120\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 480, "target_skills": [0, 0, 0, 0, 0, 1, 0, 1, 1, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the factorial of n.\n\n    Example:\n    n = 5\n\n    Output:\n    120\n\n    Explanation:\n    The factorial of 5 is 5 * 4 * 3 * 2 * 1 = 120.\n    \"\"\"\n\n    if n == 0:\n        return 1\n\n    factorial = 1\n    for i in range(1, n+1):\n        factorial *= i\n\n    return factorial", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    return 5", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of trailing zeros in n!.\n\n    Example:\n    n = 10\n\n    Output:\n    2\n\n    Explanation:\n    10! = 3628800, which has 2 trailing zeros.\n    \"\"\"\n\n    count = 0\n    i = 5\n\n    while n // i >= 1:\n        count += n // i\n        i *= 5\n\n    return count\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    return 10\n\nassert f(g()) == 2\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 480, "target_skills": [1, 1, 0, 1, 0, 0, 1, 0, 1, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of trailing zeros in n!.\n\n    Example:\n    n = 10\n\n    Output:\n    2\n\n    Explanation:\n    10! = 3628800, which has 2 trailing zeros.\n    \"\"\"\n\n    count = 0\n    i = 5\n\n    while n // i >= 1:\n        count += n // i\n        i *= 5\n\n    return count", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    return 10", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of combinations of three elements in the list that sum to zero.\n    \"\"\"\n    def helper(nums: List[int], target: int, count: int) -> int:\n        if target == 0 and count == 3:\n            return 1\n        if count > 3 or len(nums) == 0:\n            return 0\n        return helper(nums[1:], target - nums[0], count + 1) + helper(nums[1:], target, count)\n\n    return helper(nums, 0, 0)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    nums = [-1, 0, 1, 2, -1, -4]\n    return nums\n\nassert f(g()) == 2\n\n", "emb": null, "idx_generation": 480, "target_skills": [1, 0, 0, 0, 1, 0, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of combinations of three elements in the list that sum to zero.\n    \"\"\"\n    def helper(nums: List[int], target: int, count: int) -> int:\n        if target == 0 and count == 3:\n            return 1\n        if count > 3 or len(nums) == 0:\n            return 0\n        return helper(nums[1:], target - nums[0], count + 1) + helper(nums[1:], target, count)\n\n    return helper(nums, 0, 0)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    nums = [-1, 0, 1, 2, -1, -4]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value, determine if there are two numbers in the array that add up to the target.\n    The array is sorted in ascending order and may contain duplicates.\n\n    Example:\n    Input:\n    arr = [1, 2, 3, 4, 5, 6, 7]\n    k = 9\n\n    Output: True\n\n    Explanation: The numbers 2 and 7 in the array add up to 9.\n    \"\"\"\n\n    def two_sum(arr: List[int], target: int) -> bool:\n        left = 0\n        right = len(arr) - 1\n\n        while left < right:\n            current_sum = arr[left] + arr[right]\n            if current_sum == target:\n                return True\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n\n        return False\n\n    return two_sum(arr, k)\n\ndef g():\n    arr = [1, 2, 3, 4, 5, 6, 7]\n    k = 9\n    return arr, k\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 481, "target_skills": [1, 1, 1, 0, 1, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value, determine if there are two numbers in the array that add up to the target.\n    The array is sorted in ascending order and may contain duplicates.\n\n    Example:\n    Input:\n    arr = [1, 2, 3, 4, 5, 6, 7]\n    k = 9\n\n    Output: True\n\n    Explanation: The numbers 2 and 7 in the array add up to 9.\n    \"\"\"\n\n    def two_sum(arr: List[int], target: int) -> bool:\n        left = 0\n        right = len(arr) - 1\n\n        while left < right:\n            current_sum = arr[left] + arr[right]\n            if current_sum == target:\n                return True\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n\n        return False\n\n    return two_sum(arr, k)", "solution_func": "def g():\n    arr = [1, 2, 3, 4, 5, 6, 7]\n    k = 9\n    return arr, k", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of trailing zeroes in n!.\n\n    Example:\n    Input:\n    n = 10\n\n    Output: 2\n\n    Explanation: 10! = 3628800, which has 2 trailing zeroes.\n    \"\"\"\n\n    def count_trailing_zeroes(n: int) -> int:\n        count = 0\n        while n >= 5:\n            n = n // 5\n            count += n\n        return count\n\n    return count_trailing_zeroes(n)\n\ndef g():\n    n = 10\n    return n,\n\nassert f(*g()) == 2\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 481, "target_skills": [1, 1, 1, 0, 0, 0, 1, 0, 1, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of trailing zeroes in n!.\n\n    Example:\n    Input:\n    n = 10\n\n    Output: 2\n\n    Explanation: 10! = 3628800, which has 2 trailing zeroes.\n    \"\"\"\n\n    def count_trailing_zeroes(n: int) -> int:\n        count = 0\n        while n >= 5:\n            n = n // 5\n            count += n\n        return count\n\n    return count_trailing_zeroes(n)", "solution_func": "def g():\n    n = 10\n    return n,", "map_ix": [1, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    Input:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\n    Output: 7\n\n    Explanation: The maximum sum path is 1 -> 3 -> 1 -> 1 -> 1, which has a sum of 7.\n    \"\"\"\n\n    def max_sum_path(grid: List[List[int]]) -> int:\n        rows = len(grid)\n        cols = len(grid[0])\n\n        dp = [[0] * cols for _ in range(rows)]\n\n        dp[0][0] = grid[0][0]\n\n        for i in range(1, rows):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n\n        for j in range(1, cols):\n            dp[0][j] = dp[0][j-1] + grid[0][j]\n\n        for i in range(1, rows):\n            for j in range(1, cols):\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n        return dp[rows-1][cols-1]\n\n    return max_sum_path(grid)\n\ndef g():\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n    return grid,\n\nassert f(*g()) == 7\n", "emb": null, "idx_generation": 481, "target_skills": [1, 1, 0, 1, 1, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    Input:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\n    Output: 7\n\n    Explanation: The maximum sum path is 1 -> 3 -> 1 -> 1 -> 1, which has a sum of 7.\n    \"\"\"\n\n    def max_sum_path(grid: List[List[int]]) -> int:\n        rows = len(grid)\n        cols = len(grid[0])\n\n        dp = [[0] * cols for _ in range(rows)]\n\n        dp[0][0] = grid[0][0]\n\n        for i in range(1, rows):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n\n        for j in range(1, cols):\n            dp[0][j] = dp[0][j-1] + grid[0][j]\n\n        for i in range(1, rows):\n            for j in range(1, cols):\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n        return dp[rows-1][cols-1]\n\n    return max_sum_path(grid)", "solution_func": "def g():\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n    return grid,", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Count Pairs with Given Sum\n\n    Given a list of integers, count the number of pairs whose sum is equal to the target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    Output: 2\n\n    Explanation:\n    The pairs with sum equal to 6 are (1, 5) and (2, 4), so the count is 2.\n    \"\"\"\n    nums.sort()\n    count = 0\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            count += 1\n            left += 1\n            right -= 1\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return count\n\ndef g(nums = [1, 2, 3, 4, 5], target = 6):\n    return nums, target\n\nassert f(*g()) == 2\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 481, "target_skills": [0, 0, 1, 0, 1, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Count Pairs with Given Sum\n\n    Given a list of integers, count the number of pairs whose sum is equal to the target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    Output: 2\n\n    Explanation:\n    The pairs with sum equal to 6 are (1, 5) and (2, 4), so the count is 2.\n    \"\"\"\n    nums.sort()\n    count = 0\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            count += 1\n            left += 1\n            right -= 1\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return count", "solution_func": "def g(nums = [1, 2, 3, 4, 5], target = 6):\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Minimum Path Sum in a Grid\n\n    Given a grid filled with non-negative numbers, find the minimum path sum from the top-left corner to the bottom-right corner.\n\n    You can only move down or right at any point in time.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 7\n\n    Explanation:\n    The minimum path sum from the top-left corner to the bottom-right corner is 7 (1 + 3 + 1 + 1 + 1).\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[m - 1][n - 1]\n\ndef g(grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(*g()) == 7\n", "emb": null, "idx_generation": 481, "target_skills": [1, 1, 1, 1, 0, 1, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Minimum Path Sum in a Grid\n\n    Given a grid filled with non-negative numbers, find the minimum path sum from the top-left corner to the bottom-right corner.\n\n    You can only move down or right at any point in time.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 7\n\n    Explanation:\n    The minimum path sum from the top-left corner to the bottom-right corner is 7 (1 + 3 + 1 + 1 + 1).\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[m - 1][n - 1]", "solution_func": "def g(grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Sort Array by Parity\n\n    Given an array of integers, sort the array such that all even numbers come before odd numbers.\n\n    Example:\n    nums = [3, 1, 2, 4]\n    Output: [2, 4, 3, 1]\n\n    Explanation:\n    The even numbers are 2 and 4, which come before the odd numbers 3 and 1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        if nums[left] % 2 != 0:\n            nums[left], nums[right] = nums[right], nums[left]\n            right -= 1\n        else:\n            left += 1\n\n    return nums\n\ndef g(nums = [3, 1, 2, 4]):\n    return nums\n\nassert f(*g()) == [2, 4, 3, 1]\n", "emb": null, "idx_generation": 481, "target_skills": [0, 1, 0, 1, 1, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Sort Array by Parity\n\n    Given an array of integers, sort the array such that all even numbers come before odd numbers.\n\n    Example:\n    nums = [3, 1, 2, 4]\n    Output: [2, 4, 3, 1]\n\n    Explanation:\n    The even numbers are 2 and 4, which come before the odd numbers 3 and 1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        if nums[left] % 2 != 0:\n            nums[left], nums[right] = nums[right], nums[left]\n            right -= 1\n        else:\n            left += 1\n\n    return nums", "solution_func": "def g(nums = [3, 1, 2, 4]):\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n\n    Parameters:\n    n (int): The number of steps in the staircase.\n\n    Returns:\n    int: The number of ways to climb to the top of the staircase.\n    \"\"\"\n    if n <= 1:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    \n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    \n    return dp[n]\n\ndef g() -> int:\n    \"\"\"\n    Generate a random integer n.\n\n    Returns:\n    int: A random integer.\n    \"\"\"\n    return 5\n\nassert f(g()) == 8\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 481, "target_skills": [1, 0, 1, 0, 0, 0, 0, 1, 1, 1], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n\n    Parameters:\n    n (int): The number of steps in the staircase.\n\n    Returns:\n    int: The number of ways to climb to the top of the staircase.\n    \"\"\"\n    if n <= 1:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    \n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    \n    return dp[n]", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a random integer n.\n\n    Returns:\n    int: A random integer.\n    \"\"\"\n    return 5", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all the numbers that are divisible by 3 or 5.\n\n    Parameters:\n    nums (List[int]): The list of integers.\n\n    Returns:\n    int: The sum of all the numbers that are divisible by 3 or 5.\n    \"\"\"\n    return sum(num for num in nums if num % 3 == 0 or num % 5 == 0)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n\n    Returns:\n    List[int]: A list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == 33\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 481, "target_skills": [0, 1, 0, 0, 0, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all the numbers that are divisible by 3 or 5.\n\n    Parameters:\n    nums (List[int]): The list of integers.\n\n    Returns:\n    int: The sum of all the numbers that are divisible by 3 or 5.\n    \"\"\"\n    return sum(num for num in nums if num % 3 == 0 or num % 5 == 0)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n\n    Returns:\n    List[int]: A list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of the words in the string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: The string with the order of words reversed.\n    \"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)\n\ndef g() -> str:\n    \"\"\"\n    Generate a random string.\n\n    Returns:\n    str: A random string.\n    \"\"\"\n    return \"Hello, world!\"\n\nassert f(g()) == \"world! Hello,\"\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 481, "target_skills": [1, 1, 1, 0, 1, 1, 1, 1, 1, 1], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of the words in the string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: The string with the order of words reversed.\n    \"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate a random string.\n\n    Returns:\n    str: A random string.\n    \"\"\"\n    return \"Hello, world!\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given a number of nodes n and a list of edges, determine if the graph is a binary tree.\n\n    Arguments:\n    - n: the number of nodes in the graph\n    - edges: a list of edges, where each edge is represented as a pair of nodes [u, v]\n\n    Returns:\n    - True if the graph is a binary tree, False otherwise\n    \"\"\"\n\n    # Check if the number of nodes is one less than the number of edges\n    if len(edges) != n - 1:\n        return False\n\n    # Create an adjacency list representation of the graph\n    adj_list = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    # Check if the graph is connected and acyclic\n    visited = [False] * (n + 1)\n    parent = [-1] * (n + 1)\n\n    def dfs(node):\n        visited[node] = True\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                parent[neighbor] = node\n                dfs(neighbor)\n            elif parent[node] != neighbor:\n                return False\n        return True\n\n    if not dfs(1):\n        return False\n\n    # Check if the graph is a binary tree\n    in_degrees = [0] * (n + 1)\n    for u in range(1, n + 1):\n        for v in adj_list[u]:\n            in_degrees[v] += 1\n\n    root_count = 0\n    for u in range(1, n + 1):\n        if in_degrees[u] == 0:\n            root_count += 1\n        elif in_degrees[u] > 1:\n            return False\n\n    return root_count == 1\n\ndef g() -> Tuple[int, List[List[int]]]:\n    n = 5\n    edges = [[1, 2], [1, 3], [2, 4], [2, 5]]\n    return n, edges\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 481, "target_skills": [0, 1, 0, 1, 0, 1, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given a number of nodes n and a list of edges, determine if the graph is a binary tree.\n\n    Arguments:\n    - n: the number of nodes in the graph\n    - edges: a list of edges, where each edge is represented as a pair of nodes [u, v]\n\n    Returns:\n    - True if the graph is a binary tree, False otherwise\n    \"\"\"\n\n    # Check if the number of nodes is one less than the number of edges\n    if len(edges) != n - 1:\n        return False\n\n    # Create an adjacency list representation of the graph\n    adj_list = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    # Check if the graph is connected and acyclic\n    visited = [False] * (n + 1)\n    parent = [-1] * (n + 1)\n\n    def dfs(node):\n        visited[node] = True\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                parent[neighbor] = node\n                dfs(neighbor)\n            elif parent[node] != neighbor:\n                return False\n        return True\n\n    if not dfs(1):\n        return False\n\n    # Check if the graph is a binary tree\n    in_degrees = [0] * (n + 1)\n    for u in range(1, n + 1):\n        for v in adj_list[u]:\n            in_degrees[v] += 1\n\n    root_count = 0\n    for u in range(1, n + 1):\n        if in_degrees[u] == 0:\n            root_count += 1\n        elif in_degrees[u] > 1:\n            return False\n\n    return root_count == 1", "solution_func": "def g() -> Tuple[int, List[List[int]]]:\n    n = 5\n    edges = [[1, 2], [1, 3], [2, 4], [2, 5]]\n    return n, edges", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 2],\n        [4, 1, 7],\n        [9, 5, 2]\n    ]\n\n    Output:\n    17\n\n    Explanation:\n    The maximum sum path is: 1 -> 3 -> 2 -> 7 -> 2, which sums to 17.\n\n    Hint: Use dynamic programming to store the maximum sum at each cell.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    return [\n        [1, 3, 2],\n        [4, 1, 7],\n        [9, 5, 2]\n    ]\n\nassert f(g()) == 17\n\n", "emb": null, "idx_generation": 482, "target_skills": [0, 0, 0, 0, 1, 0, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 2],\n        [4, 1, 7],\n        [9, 5, 2]\n    ]\n\n    Output:\n    17\n\n    Explanation:\n    The maximum sum path is: 1 -> 3 -> 2 -> 7 -> 2, which sums to 17.\n\n    Hint: Use dynamic programming to store the maximum sum at each cell.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    return [\n        [1, 3, 2],\n        [4, 1, 7],\n        [9, 5, 2]\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique paths from the top-left corner to the bottom-right corner\n    of an n x n grid. You can only move down or right.\n\n    Example:\n    n = 3\n\n    Output:\n    6\n\n    Explanation:\n    There are 6 unique paths from the top-left corner to the bottom-right corner of a 3 x 3 grid.\n\n    Hint: Use dynamic programming to store the number of unique paths at each cell.\n    \"\"\"\n\n    dp = [[0] * n for _ in range(n)]\n    dp[0][0] = 1\n\n    for i in range(1, n):\n        dp[i][0] = 1\n\n    for j in range(1, n):\n        dp[0][j] = 1\n\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[n-1][n-1]\n\ndef g() -> int:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    return 3\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 482, "target_skills": [0, 1, 0, 0, 0, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique paths from the top-left corner to the bottom-right corner\n    of an n x n grid. You can only move down or right.\n\n    Example:\n    n = 3\n\n    Output:\n    6\n\n    Explanation:\n    There are 6 unique paths from the top-left corner to the bottom-right corner of a 3 x 3 grid.\n\n    Hint: Use dynamic programming to store the number of unique paths at each cell.\n    \"\"\"\n\n    dp = [[0] * n for _ in range(n)]\n    dp[0][0] = 1\n\n    for i in range(1, n):\n        dp[i][0] = 1\n\n    for j in range(1, n):\n        dp[0][j] = 1\n\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[n-1][n-1]", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    return 3", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum cost to reach the bottom-right cell from the top-left cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum cost path is: 1 -> 3 -> 1 -> 1 -> 1, which has a total cost of 7.\n\n    Hint: Use dynamic programming to store the minimum cost at each cell.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 482, "target_skills": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum cost to reach the bottom-right cell from the top-left cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum cost path is: 1 -> 3 -> 1 -> 1 -> 1, which has a total cost of 7.\n\n    Hint: Use dynamic programming to store the minimum cost at each cell.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate the inputs for the function f.\n    \"\"\"\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(string: str) -> int:\n    \"\"\"\n    Given a string of parentheses, consisting of only '(' and ')', determine the minimum number of parentheses that need to be removed in order to make the string valid.\n\n    A string is considered valid if it contains a balanced number of opening and closing parentheses, and if any opening parentheses is followed by a corresponding closing parentheses.\n\n    Return the minimum number of parentheses that need to be removed to make the string valid.\n\n    Sample Input:\n    string = \"())(\"\n\n    Sample Output:\n    2\n\n    Explanation:\n    The string can be made valid by removing the parentheses at indices 0 and 3, resulting in the string \"()\".\n    \"\"\"\n\n    stack = []\n    count = 0\n\n    for char in string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if stack and stack[-1] == '(':\n                stack.pop()\n            else:\n                count += 1\n\n    return count + len(stack)\n\ndef g(string: str = \"())(\"):\n    return string\n\nassert f(g()) == 2\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 482, "target_skills": [1, 1, 1, 0, 0, 1, 0, 1, 1, 1], "problem_func": "from typing import*\n\ndef f(string: str) -> int:\n    \"\"\"\n    Given a string of parentheses, consisting of only '(' and ')', determine the minimum number of parentheses that need to be removed in order to make the string valid.\n\n    A string is considered valid if it contains a balanced number of opening and closing parentheses, and if any opening parentheses is followed by a corresponding closing parentheses.\n\n    Return the minimum number of parentheses that need to be removed to make the string valid.\n\n    Sample Input:\n    string = \"())(\"\n\n    Sample Output:\n    2\n\n    Explanation:\n    The string can be made valid by removing the parentheses at indices 0 and 3, resulting in the string \"()\".\n    \"\"\"\n\n    stack = []\n    count = 0\n\n    for char in string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if stack and stack[-1] == '(':\n                stack.pop()\n            else:\n                count += 1\n\n    return count + len(stack)", "solution_func": "def g(string: str = \"())(\"):\n    return string", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\n\ndef f(strings: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, return a new list where each string is replaced by a new string that is formed by reversing the original string and removing any duplicate characters.\n\n    Sample Input:\n    strings = [\"hello\", \"world\", \"python\", \"programming\"]\n\n    Sample Output:\n    [\"oleh\", \"dlrow\", \"nohtyp\", \"gnimmargorp\"]\n\n    Explanation:\n    The original strings are reversed and any duplicate characters are removed to form the new strings.\n    \"\"\"\n\n    def reverse_and_remove_duplicates(string):\n        return ''.join(list(dict.fromkeys(string[::-1])))\n\n    return [reverse_and_remove_duplicates(string) for string in strings]\n\ndef g(strings: List[str] = [\"hello\", \"world\", \"python\", \"programming\"]):\n    return strings\n\nassert f(g()) == [\"oleh\", \"dlrow\", \"nohtyp\", \"gnimmargorp\"]\n\n", "emb": null, "idx_generation": 482, "target_skills": [0, 0, 1, 1, 0, 0, 1, 1, 0, 1], "problem_func": "from typing import*\n\ndef f(strings: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, return a new list where each string is replaced by a new string that is formed by reversing the original string and removing any duplicate characters.\n\n    Sample Input:\n    strings = [\"hello\", \"world\", \"python\", \"programming\"]\n\n    Sample Output:\n    [\"oleh\", \"dlrow\", \"nohtyp\", \"gnimmargorp\"]\n\n    Explanation:\n    The original strings are reversed and any duplicate characters are removed to form the new strings.\n    \"\"\"\n\n    def reverse_and_remove_duplicates(string):\n        return ''.join(list(dict.fromkeys(string[::-1])))\n\n    return [reverse_and_remove_duplicates(string) for string in strings]", "solution_func": "def g(strings: List[str] = [\"hello\", \"world\", \"python\", \"programming\"]):\n    return strings", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers 'nums' and a target integer 'target', find the number of valid combinations that can be formed by adding up the numbers in the list to reach the target.\n\n    Each number in the list can be used multiple times.\n\n    Sample Input:\n    nums = [1, 2, 3]\n    target = 4\n\n    Sample Output:\n    7\n\n    Explanation:\n    The valid combinations are: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2], [3, 1], [1, 3].\n    \"\"\"\n\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i - num >= 0:\n                dp[i] += dp[i - num]\n\n    return dp[target]\n\ndef g(nums: List[int] = [1, 2, 3], target: int = 4):\n    return nums, target\n\nassert f(*g()) == 7\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 482, "target_skills": [1, 0, 1, 0, 1, 1, 1, 1, 0, 0], "problem_func": "from typing import*\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers 'nums' and a target integer 'target', find the number of valid combinations that can be formed by adding up the numbers in the list to reach the target.\n\n    Each number in the list can be used multiple times.\n\n    Sample Input:\n    nums = [1, 2, 3]\n    target = 4\n\n    Sample Output:\n    7\n\n    Explanation:\n    The valid combinations are: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2], [3, 1], [1, 3].\n    \"\"\"\n\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i - num >= 0:\n                dp[i] += dp[i - num]\n\n    return dp[target]", "solution_func": "def g(nums: List[int] = [1, 2, 3], target: int = 4):\n    return nums, target", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph, determine if it contains a cycle.\n\n    Parameters:\n    graph (List[List[int]]): An adjacency list representation of the graph. Each element is a list of neighbors for a given vertex.\n\n    Returns:\n    bool: True if the graph contains a cycle, False otherwise.\n    \"\"\"\n\n    def is_cycle(node, visited, parent):\n        visited[node] = True\n\n        for neighbor in graph[node]:\n            if visited[neighbor] == False:\n                if is_cycle(neighbor, visited, node):\n                    return True\n            elif parent != neighbor:\n                return True\n\n        return False\n\n    num_vertices = len(graph)\n    visited = [False] * num_vertices\n\n    for node in range(num_vertices):\n        if visited[node] == False:\n            if is_cycle(node, visited, -1):\n                return True\n\n    return False\n\ndef g() -> List[List[int]]:\n    graph = [[1, 2], [0, 2], [0, 1, 3], [2]]\n    return graph\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 482, "target_skills": [0, 1, 0, 0, 0, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph, determine if it contains a cycle.\n\n    Parameters:\n    graph (List[List[int]]): An adjacency list representation of the graph. Each element is a list of neighbors for a given vertex.\n\n    Returns:\n    bool: True if the graph contains a cycle, False otherwise.\n    \"\"\"\n\n    def is_cycle(node, visited, parent):\n        visited[node] = True\n\n        for neighbor in graph[node]:\n            if visited[neighbor] == False:\n                if is_cycle(neighbor, visited, node):\n                    return True\n            elif parent != neighbor:\n                return True\n\n        return False\n\n    num_vertices = len(graph)\n    visited = [False] * num_vertices\n\n    for node in range(num_vertices):\n        if visited[node] == False:\n            if is_cycle(node, visited, -1):\n                return True\n\n    return False", "solution_func": "def g() -> List[List[int]]:\n    graph = [[1, 2], [0, 2], [0, 1, 3], [2]]\n    return graph", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an undirected graph, find the number of connected components.\n\n    Parameters:\n    graph (List[List[int]]): An adjacency list representation of the graph. Each element is a list of neighbors for a given vertex.\n\n    Returns:\n    int: The number of connected components in the graph.\n    \"\"\"\n\n    def dfs(node, visited):\n        visited[node] = True\n\n        for neighbor in graph[node]:\n            if visited[neighbor] == False:\n                dfs(neighbor, visited)\n\n    num_vertices = len(graph)\n    visited = [False] * num_vertices\n    count = 0\n\n    for node in range(num_vertices):\n        if visited[node] == False:\n            count += 1\n            dfs(node, visited)\n\n    return count\n\ndef g() -> List[List[int]]:\n    graph = [[1, 2], [0, 2], [0, 1], [3], [4], [5], [6], [7], [8], [9], [10]]\n    return graph\n\nassert f(g()) == 3\n", "emb": null, "idx_generation": 482, "target_skills": [1, 0, 0, 1, 0, 0, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an undirected graph, find the number of connected components.\n\n    Parameters:\n    graph (List[List[int]]): An adjacency list representation of the graph. Each element is a list of neighbors for a given vertex.\n\n    Returns:\n    int: The number of connected components in the graph.\n    \"\"\"\n\n    def dfs(node, visited):\n        visited[node] = True\n\n        for neighbor in graph[node]:\n            if visited[neighbor] == False:\n                dfs(neighbor, visited)\n\n    num_vertices = len(graph)\n    visited = [False] * num_vertices\n    count = 0\n\n    for node in range(num_vertices):\n        if visited[node] == False:\n            count += 1\n            dfs(node, visited)\n\n    return count", "solution_func": "def g() -> List[List[int]]:\n    graph = [[1, 2], [0, 2], [0, 1], [3], [4], [5], [6], [7], [8], [9], [10]]\n    return graph", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an undirected graph, find the length of the longest path.\n\n    Parameters:\n    graph (List[List[int]]): An adjacency list representation of the graph. Each element is a list of neighbors for a given vertex.\n\n    Returns:\n    int: The length of the longest path in the graph.\n    \"\"\"\n\n    def dfs(node, visited, curr_length):\n        visited[node] = True\n        max_length = curr_length\n\n        for neighbor in graph[node]:\n            if visited[neighbor] == False:\n                max_length = max(max_length, dfs(neighbor, visited, curr_length + 1))\n\n        return max_length\n\n    num_vertices = len(graph)\n    visited = [False] * num_vertices\n    max_length = 0\n\n    for node in range(num_vertices):\n        if visited[node] == False:\n            max_length = max(max_length, dfs(node, visited, 1))\n\n    return max_length\n\ndef g() -> List[List[int]]:\n    graph = [[1, 2], [0, 2], [0, 1, 3], [2, 4], [3]]\n    return graph\n\nassert f(g()) == 4\n", "emb": null, "idx_generation": 482, "target_skills": [1, 1, 1, 0, 0, 0, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an undirected graph, find the length of the longest path.\n\n    Parameters:\n    graph (List[List[int]]): An adjacency list representation of the graph. Each element is a list of neighbors for a given vertex.\n\n    Returns:\n    int: The length of the longest path in the graph.\n    \"\"\"\n\n    def dfs(node, visited, curr_length):\n        visited[node] = True\n        max_length = curr_length\n\n        for neighbor in graph[node]:\n            if visited[neighbor] == False:\n                max_length = max(max_length, dfs(neighbor, visited, curr_length + 1))\n\n        return max_length\n\n    num_vertices = len(graph)\n    visited = [False] * num_vertices\n    max_length = 0\n\n    for node in range(num_vertices):\n        if visited[node] == False:\n            max_length = max(max_length, dfs(node, visited, 1))\n\n    return max_length", "solution_func": "def g() -> List[List[int]]:\n    graph = [[1, 2], [0, 2], [0, 1, 3], [2, 4], [3]]\n    return graph", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n    If the target value is not in the list, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target: int = 6):\n    return nums, target\n\nassert f(*g()) == 5\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 482, "target_skills": [0, 0, 1, 0, 1, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n    If the target value is not in the list, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1", "solution_func": "def g(nums: List[int] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target: int = 6):\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of trailing zeros in n!.\n\n    Example:\n    n = 5\n\n    Output:\n    1\n\n    Explanation:\n    5! = 5 * 4 * 3 * 2 * 1 = 120, which has 1 trailing zero.\n\n    Hint: Count the number of factors of 5 in n! to determine the number of trailing zeros.\n    \"\"\"\n\n    count = 0\n    i = 5\n    while n // i >= 1:\n        count += n // i\n        i *= 5\n    return count\n\ndef g(n: int):\n    return n\n\nassert f(g(20)) == 4\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 483, "target_skills": [0, 1, 0, 1, 1, 1, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of trailing zeros in n!.\n\n    Example:\n    n = 5\n\n    Output:\n    1\n\n    Explanation:\n    5! = 5 * 4 * 3 * 2 * 1 = 120, which has 1 trailing zero.\n\n    Hint: Count the number of factors of 5 in n! to determine the number of trailing zeros.\n    \"\"\"\n\n    count = 0\n    i = 5\n    while n // i >= 1:\n        count += n // i\n        i *= 5\n    return count", "solution_func": "def g(n: int):\n    return n", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome.\n\n    Example:\n    s = \"racecar\"\n\n    Output:\n    True\n\n    Explanation:\n    The string \"racecar\" is a palindrome.\n\n    Hint: Compare the string with its reverse to check if it is a palindrome.\n    \"\"\"\n\n    return s == s[::-1]\n\ndef g(s: str):\n    return s\n\nassert f(g(\"hello\")) == False\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 483, "target_skills": [1, 1, 1, 1, 1, 1, 0, 1, 0, 1], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome.\n\n    Example:\n    s = \"racecar\"\n\n    Output:\n    True\n\n    Explanation:\n    The string \"racecar\" is a palindrome.\n\n    Hint: Compare the string with its reverse to check if it is a palindrome.\n    \"\"\"\n\n    return s == s[::-1]", "solution_func": "def g(s: str):\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the nth Fibonacci number.\n\n    Example:\n    n = 6\n\n    Output:\n    8\n\n    Explanation:\n    The 6th Fibonacci number is 8.\n\n    Hint: Use recursion to calculate the Fibonacci numbers.\n    \"\"\"\n\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return f(n - 1) + f(n - 2)\n\ndef g(n: int):\n    return n\n\nassert f(g(10)) == 55\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 483, "target_skills": [0, 0, 1, 0, 0, 0, 0, 0, 1, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the nth Fibonacci number.\n\n    Example:\n    n = 6\n\n    Output:\n    8\n\n    Explanation:\n    The 6th Fibonacci number is 8.\n\n    Hint: Use recursion to calculate the Fibonacci numbers.\n    \"\"\"\n\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return f(n - 1) + f(n - 2)", "solution_func": "def g(n: int):\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Determine if there exists an integer x such that x^k = n.\"\"\"\n    def isPerfectPower(n: int, k: int) -> bool:\n        if n <= 1:\n            return True\n        for i in range(2, int(n ** (1/k)) + 1):\n            x = i\n            while x ** k <= n:\n                if x ** k == n:\n                    return True\n                x += 1\n        return False\n\n    return isPerfectPower(n, k)\n\ndef g(n=16, k=2):\n    return n, k\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 483, "target_skills": [1, 1, 0, 0, 1, 1, 0, 1, 0, 0], "problem_func": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Determine if there exists an integer x such that x^k = n.\"\"\"\n    def isPerfectPower(n: int, k: int) -> bool:\n        if n <= 1:\n            return True\n        for i in range(2, int(n ** (1/k)) + 1):\n            x = i\n            while x ** k <= n:\n                if x ** k == n:\n                    return True\n                x += 1\n        return False\n\n    return isPerfectPower(n, k)", "solution_func": "def g(n=16, k=2):\n    return n, k", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Given a matrix of integers, find the maximum sum of any submatrix.\"\"\"\n\n    def kadane(arr: List[int]) -> int:\n        max_sum = float('-inf')\n        curr_sum = 0\n        for num in arr:\n            curr_sum = max(num, curr_sum + num)\n            max_sum = max(max_sum, curr_sum)\n        return max_sum\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n    max_sum = float('-inf')\n\n    for left in range(cols):\n        temp = [0] * rows\n        for right in range(left, cols):\n            for i in range(rows):\n                temp[i] += matrix[i][right]\n            max_sum = max(max_sum, kadane(temp))\n    return max_sum\n\ndef g(matrix=[[1, 2, -1, -4, -20],\n              [-8, -3, 4, 2, 1],\n              [3, 8, 10, 1, 3],\n              [-4, -1, 1, 7, -6]]):\n\n    return matrix\n\nassert f(*g()) == 29\n", "emb": null, "idx_generation": 483, "target_skills": [1, 0, 0, 0, 1, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Given a matrix of integers, find the maximum sum of any submatrix.\"\"\"\n\n    def kadane(arr: List[int]) -> int:\n        max_sum = float('-inf')\n        curr_sum = 0\n        for num in arr:\n            curr_sum = max(num, curr_sum + num)\n            max_sum = max(max_sum, curr_sum)\n        return max_sum\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n    max_sum = float('-inf')\n\n    for left in range(cols):\n        temp = [0] * rows\n        for right in range(left, cols):\n            for i in range(rows):\n                temp[i] += matrix[i][right]\n            max_sum = max(max_sum, kadane(temp))\n    return max_sum", "solution_func": "def g(matrix=[[1, 2, -1, -4, -20],\n              [-8, -3, 4, 2, 1],\n              [3, 8, 10, 1, 3],\n              [-4, -1, 1, 7, -6]]):\n\n    return matrix", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(string1: str, string2: str) -> bool:\n    \"\"\"Check if two strings are anagrams of each other.\"\"\"\n\n    def count_chars(string: str) -> dict:\n        char_count = {}\n        for char in string:\n            char_count[char] = char_count.get(char, 0) + 1\n        return char_count\n\n    char_count1 = count_chars(string1)\n    char_count2 = count_chars(string2)\n\n    return char_count1 == char_count2\n\ndef g(string1=\"listen\", string2=\"silent\"):\n    return string1, string2\n\nassert f(*g()) == True\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 483, "target_skills": [0, 1, 1, 1, 1, 1, 1, 1, 0, 0], "problem_func": "from typing import*\ndef f(string1: str, string2: str) -> bool:\n    \"\"\"Check if two strings are anagrams of each other.\"\"\"\n\n    def count_chars(string: str) -> dict:\n        char_count = {}\n        for char in string:\n            char_count[char] = char_count.get(char, 0) + 1\n        return char_count\n\n    char_count1 = count_chars(string1)\n    char_count2 = count_chars(string2)\n\n    return char_count1 == char_count2", "solution_func": "def g(string1=\"listen\", string2=\"silent\"):\n    return string1, string2", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency list, determine if there exists a path from a given start node\n    to a given end node.\n\n    Return True if a path exists, and False otherwise.\n\n    Example:\n    graph = {1: [2, 3],\n             2: [4],\n             3: [4],\n             4: []}\n    start = 1, end = 4\n    The graph is represented as follows:\n    1 -> 2 -> 4\n     \\-> 3 -> 4\n    There exists a path from node 1 to node 4, so the function should return True.\n    \"\"\"\n    visited = set()\n    stack = deque([start])\n\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n\n    return False\n\ndef g():\n    return {1: [2, 3],\n            2: [4],\n            3: [4],\n            4: []}, 1, 4\n\nassert f(*g()) == True\n\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 483, "target_skills": [1, 1, 1, 1, 0, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency list, determine if there exists a path from a given start node\n    to a given end node.\n\n    Return True if a path exists, and False otherwise.\n\n    Example:\n    graph = {1: [2, 3],\n             2: [4],\n             3: [4],\n             4: []}\n    start = 1, end = 4\n    The graph is represented as follows:\n    1 -> 2 -> 4\n     \\-> 3 -> 4\n    There exists a path from node 1 to node 4, so the function should return True.\n    \"\"\"\n    visited = set()\n    stack = deque([start])\n\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n\n    return False", "solution_func": "def g():\n    return {1: [2, 3],\n            2: [4],\n            3: [4],\n            4: []}, 1, 4", "map_ix": [1, 0, 1, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom heapq import heappop, heappush\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the minimum path sum from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Return the minimum path sum.\n\n    Example:\n    matrix = [[1, 3, 1],\n              [1, 5, 1],\n              [4, 2, 1]]\n    The minimum path sum is: 1 -> 3 -> 1 -> 1 -> 1, with a sum of 7.\n    \"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n\n    # Initialize the distance matrix with maximum values\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = matrix[0][0]\n\n    # Create a priority queue to store the nodes to be visited\n    pq = [(matrix[0][0], 0, 0)]\n\n    while pq:\n        dist, row, col = heappop(pq)\n\n        # Check if the current distance is already updated\n        if dist > distance[row][col]:\n            continue\n\n        # Explore the neighbors (down and right)\n        for dr, dc in [(1, 0), (0, 1)]:\n            new_row = row + dr\n            new_col = col + dc\n\n            # Check if the new position is within the matrix boundaries\n            if 0 <= new_row < m and 0 <= new_col < n:\n                new_dist = dist + matrix[new_row][new_col]\n\n                # Update the distance if a shorter path is found\n                if new_dist < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_dist\n                    heappush(pq, (new_dist, new_row, new_col))\n\n    return distance[m - 1][n - 1]\n\ndef g():\n    return [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\nassert f(g()) == 7\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 483, "target_skills": [1, 0, 0, 1, 0, 1, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import *\nfrom heapq import heappop, heappush\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the minimum path sum from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Return the minimum path sum.\n\n    Example:\n    matrix = [[1, 3, 1],\n              [1, 5, 1],\n              [4, 2, 1]]\n    The minimum path sum is: 1 -> 3 -> 1 -> 1 -> 1, with a sum of 7.\n    \"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n\n    # Initialize the distance matrix with maximum values\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = matrix[0][0]\n\n    # Create a priority queue to store the nodes to be visited\n    pq = [(matrix[0][0], 0, 0)]\n\n    while pq:\n        dist, row, col = heappop(pq)\n\n        # Check if the current distance is already updated\n        if dist > distance[row][col]:\n            continue\n\n        # Explore the neighbors (down and right)\n        for dr, dc in [(1, 0), (0, 1)]:\n            new_row = row + dr\n            new_col = col + dc\n\n            # Check if the new position is within the matrix boundaries\n            if 0 <= new_row < m and 0 <= new_col < n:\n                new_dist = dist + matrix[new_row][new_col]\n\n                # Update the distance if a shorter path is found\n                if new_dist < distance[new_row][new_col]:\n                    distance[new_row][new_col] = new_dist\n                    heappush(pq, (new_dist, new_row, new_col))\n\n    return distance[m - 1][n - 1]", "solution_func": "def g():\n    return [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]", "map_ix": [0, 0, 1, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom heapq import heappop, heappush\n\ndef f(graph: Dict[int, List[Tuple[int, int]]], start: int, end: int) -> List[int]:\n    \"\"\"\n    Given a weighted directed graph represented as an adjacency list, find the shortest path from a given start node\n    to a given end node.\n\n    Return the shortest path as a list of nodes.\n\n    Example:\n    graph = {1: [(2, 1), (3, 3)],\n             2: [(4, 2)],\n             3: [(4, 1)],\n             4: []}\n    start = 1, end = 4\n    The graph is represented as follows:\n    1 -(1)-> 2 -(2)-> 4\n      -(3)-> 3 -(1)-> 4\n    The shortest path from node 1 to node 4 is 1 -> 2 -> 4, so the function should return [1, 2, 4].\n    \"\"\"\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    heap = [(0, start)]\n    prev = {}\n\n    while heap:\n        dist, node = heappop(heap)\n\n        if dist > distances[node]:\n            continue\n\n        if node == end:\n            path = []\n            while node is not None:\n                path.append(node)\n                node = prev.get(node)\n            return path[::-1]\n\n        for neighbor, weight in graph[node]:\n            new_dist = dist + weight\n\n            if new_dist < distances[neighbor]:\n                distances[neighbor] = new_dist\n                prev[neighbor] = node\n                heappush(heap, (new_dist, neighbor))\n\n    return []\n\ndef g():\n    return {1: [(2, 1), (3, 3)],\n            2: [(4, 2)],\n            3: [(4, 1)],\n            4: []}, 1, 4\n\nassert f(*g()) == [1, 2, 4]\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 483, "target_skills": [0, 1, 0, 0, 1, 0, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import *\nfrom heapq import heappop, heappush\n\ndef f(graph: Dict[int, List[Tuple[int, int]]], start: int, end: int) -> List[int]:\n    \"\"\"\n    Given a weighted directed graph represented as an adjacency list, find the shortest path from a given start node\n    to a given end node.\n\n    Return the shortest path as a list of nodes.\n\n    Example:\n    graph = {1: [(2, 1), (3, 3)],\n             2: [(4, 2)],\n             3: [(4, 1)],\n             4: []}\n    start = 1, end = 4\n    The graph is represented as follows:\n    1 -(1)-> 2 -(2)-> 4\n      -(3)-> 3 -(1)-> 4\n    The shortest path from node 1 to node 4 is 1 -> 2 -> 4, so the function should return [1, 2, 4].\n    \"\"\"\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    heap = [(0, start)]\n    prev = {}\n\n    while heap:\n        dist, node = heappop(heap)\n\n        if dist > distances[node]:\n            continue\n\n        if node == end:\n            path = []\n            while node is not None:\n                path.append(node)\n                node = prev.get(node)\n            return path[::-1]\n\n        for neighbor, weight in graph[node]:\n            new_dist = dist + weight\n\n            if new_dist < distances[neighbor]:\n                distances[neighbor] = new_dist\n                prev[neighbor] = node\n                heappush(heap, (new_dist, neighbor))\n\n    return []", "solution_func": "def g():\n    return {1: [(2, 1), (3, 3)],\n            2: [(4, 2)],\n            3: [(4, 1)],\n            4: []}, 1, 4", "map_ix": [0, 0, 1, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(arr: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Given an array of integers, check if it is possible to select k numbers from the array such that their sum is equal to the target.\n    The selected numbers must be consecutive in the array.\n    \"\"\"\n    arr.sort()\n    n = len(arr)\n    for i in range(n - k + 1):\n        if sum(arr[i:i+k]) == target:\n            return True\n    return False\n\ndef g(arr=[1, 2, 3, 4, 5, 6, 7], target=12, k=3):\n    return arr\n\nassert f(g())\n", "emb": null, "idx_generation": 483, "target_skills": [1, 1, 0, 0, 1, 1, 0, 1, 0, 0], "problem_func": "from typing import*\ndef f(arr: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Given an array of integers, check if it is possible to select k numbers from the array such that their sum is equal to the target.\n    The selected numbers must be consecutive in the array.\n    \"\"\"\n    arr.sort()\n    n = len(arr)\n    for i in range(n - k + 1):\n        if sum(arr[i:i+k]) == target:\n            return True\n    return False", "solution_func": "def g(arr=[1, 2, 3, 4, 5, 6, 7], target=12, k=3):\n    return arr", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nimport math\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two elements.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value can be obtained by XORing 5 and 25, which results in 28.\n\n    Hint: Use bitwise XOR to compare all pairs of numbers and keep track of the maximum XOR value.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor\n\ndef g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0], "idx_generation": 484, "target_skills": [1, 0, 0, 0, 1, 0, 0, 0, 1, 1], "problem_func": "from typing import*\nimport math\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two elements.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value can be obtained by XORing 5 and 25, which results in 28.\n\n    Hint: Use bitwise XOR to compare all pairs of numbers and keep track of the maximum XOR value.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor", "solution_func": "def g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list using the bubble sort algorithm.\n\n    Example:\n    nums = [5, 3, 8, 2, 1]\n\n    Output:\n    [1, 2, 3, 5, 8]\n\n    Explanation:\n    The bubble sort algorithm repeatedly swaps adjacent elements if they are in the wrong order.\n    In this case, the list is sorted in ascending order.\n\n    Hint: Implement the bubble sort algorithm by repeatedly iterating through the list and swapping adjacent elements if necessary.\n    \"\"\"\n\n    n = len(nums)\n\n    for i in range(n-1):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n\n    return nums\n\ndef g():\n    nums = [5, 3, 8, 2, 1]\n    return nums\n\nassert f(g()) == [1, 2, 3, 5, 8]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 484, "target_skills": [0, 0, 1, 0, 1, 0, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list using the bubble sort algorithm.\n\n    Example:\n    nums = [5, 3, 8, 2, 1]\n\n    Output:\n    [1, 2, 3, 5, 8]\n\n    Explanation:\n    The bubble sort algorithm repeatedly swaps adjacent elements if they are in the wrong order.\n    In this case, the list is sorted in ascending order.\n\n    Hint: Implement the bubble sort algorithm by repeatedly iterating through the list and swapping adjacent elements if necessary.\n    \"\"\"\n\n    n = len(nums)\n\n    for i in range(n-1):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n\n    return nums", "solution_func": "def g():\n    nums = [5, 3, 8, 2, 1]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(boxes: List[str], max_weight: int) -> int:\n    \"\"\"\n    Given a list of boxes and their respective weights, and a maximum weight limit,\n    find the maximum total weight of boxes that can be carried without exceeding the weight limit.\n    Each box can only be selected once.\n\n    Example:\n    boxes = [\"Box1\", \"Box2\", \"Box3\", \"Box4\", \"Box5\"]\n    weights = [2, 5, 4, 3, 7]\n    max_weight = 10\n\n    Output:\n    9\n\n    Explanation:\n    The maximum total weight that can be carried without exceeding the weight limit is 9,\n    obtained by selecting Box1, Box3, and Box4.\n\n    Hint: Use a stack to keep track of the boxes selected so far and perform a depth-first search to find the maximum total weight.\n    \"\"\"\n\n    n = len(boxes)\n    max_total_weight = 0\n\n    def dfs(weight, index):\n        nonlocal max_total_weight\n\n        if weight > max_weight:\n            return\n\n        if index == n:\n            max_total_weight = max(max_total_weight, weight)\n            return\n\n        dfs(weight + weights[index], index + 1)\n        dfs(weight, index + 1)\n\n    dfs(0, 0)\n\n    return max_total_weight\n\ndef g():\n    boxes = [\"Box1\", \"Box2\", \"Box3\", \"Box4\", \"Box5\"]\n    weights = [2, 5, 4, 3, 7]\n    max_weight = 10\n    return boxes, weights, max_weight\n\nassert f(*g()) == 9\n\n", "emb": null, "idx_generation": 484, "target_skills": [1, 0, 0, 1, 1, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(boxes: List[str], max_weight: int) -> int:\n    \"\"\"\n    Given a list of boxes and their respective weights, and a maximum weight limit,\n    find the maximum total weight of boxes that can be carried without exceeding the weight limit.\n    Each box can only be selected once.\n\n    Example:\n    boxes = [\"Box1\", \"Box2\", \"Box3\", \"Box4\", \"Box5\"]\n    weights = [2, 5, 4, 3, 7]\n    max_weight = 10\n\n    Output:\n    9\n\n    Explanation:\n    The maximum total weight that can be carried without exceeding the weight limit is 9,\n    obtained by selecting Box1, Box3, and Box4.\n\n    Hint: Use a stack to keep track of the boxes selected so far and perform a depth-first search to find the maximum total weight.\n    \"\"\"\n\n    n = len(boxes)\n    max_total_weight = 0\n\n    def dfs(weight, index):\n        nonlocal max_total_weight\n\n        if weight > max_weight:\n            return\n\n        if index == n:\n            max_total_weight = max(max_total_weight, weight)\n            return\n\n        dfs(weight + weights[index], index + 1)\n        dfs(weight, index + 1)\n\n    dfs(0, 0)\n\n    return max_total_weight", "solution_func": "def g():\n    boxes = [\"Box1\", \"Box2\", \"Box3\", \"Box4\", \"Box5\"]\n    weights = [2, 5, 4, 3, 7]\n    max_weight = 10\n    return boxes, weights, max_weight", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> bool:\n    \"\"\"\n    Given a binary tree, determine if it is a valid binary search tree (BST).\n\n    A valid BST is defined as follows:\n        - The left subtree of a node contains only nodes with keys less than the node's key.\n        - The right subtree of a node contains only nodes with keys greater than the node's key.\n        - Both the left and right subtrees must also be binary search trees.\n\n    Example:\n    Input:\n        2\n       / \\\n      1   3\n    Output: True\n\n    Explanation: The binary tree [2,1,3] is a valid BST.\n\n    Hint: Perform an inorder traversal and check if the values are in ascending order. Use a stack to store the nodes during traversal.\n    \"\"\"\n\n    stack = []\n    prev = None\n\n    while root or stack:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and prev.val >= root.val:\n            return False\n        prev = root\n        root = root.right\n\n    return True\n\ndef g():\n    root = TreeNode(2)\n    root.left = TreeNode(1)\n    root.right = TreeNode(3)\n    return root\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 484, "target_skills": [1, 1, 0, 0, 1, 1, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> bool:\n    \"\"\"\n    Given a binary tree, determine if it is a valid binary search tree (BST).\n\n    A valid BST is defined as follows:\n        - The left subtree of a node contains only nodes with keys less than the node's key.\n        - The right subtree of a node contains only nodes with keys greater than the node's key.\n        - Both the left and right subtrees must also be binary search trees.\n\n    Example:\n    Input:\n        2\n       / \\\n      1   3\n    Output: True\n\n    Explanation: The binary tree [2,1,3] is a valid BST.\n\n    Hint: Perform an inorder traversal and check if the values are in ascending order. Use a stack to store the nodes during traversal.\n    \"\"\"\n\n    stack = []\n    prev = None\n\n    while root or stack:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if prev and prev.val >= root.val:\n            return False\n        prev = root\n        root = root.right\n\n    return True", "solution_func": "def g():\n    root = TreeNode(2)\n    root.left = TreeNode(1)\n    root.right = TreeNode(3)\n    return root", "map_ix": [0, 0, 1, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> int:\n    \"\"\"\n    Given a binary tree, find its maximum depth.\n\n    The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n    Example:\n    Input:\n        3\n       / \\\n      9  20\n        /  \\\n       15   7\n    Output: 3\n\n    Hint: Use depth-first search (DFS) to traverse the tree. Recursively calculate the depth of the left and right subtrees and return the maximum depth.\n    \"\"\"\n\n    if not root:\n        return 0\n\n    left_depth = f(root.left)\n    right_depth = f(root.right)\n\n    return max(left_depth, right_depth) + 1\n\ndef g():\n    root = TreeNode(3)\n    root.left = TreeNode(9)\n    root.right = TreeNode(20)\n    root.right.left = TreeNode(15)\n    root.right.right = TreeNode(7)\n    return root\n\nassert f(g()) == 3\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 484, "target_skills": [0, 0, 1, 1, 0, 0, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> int:\n    \"\"\"\n    Given a binary tree, find its maximum depth.\n\n    The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n    Example:\n    Input:\n        3\n       / \\\n      9  20\n        /  \\\n       15   7\n    Output: 3\n\n    Hint: Use depth-first search (DFS) to traverse the tree. Recursively calculate the depth of the left and right subtrees and return the maximum depth.\n    \"\"\"\n\n    if not root:\n        return 0\n\n    left_depth = f(root.left)\n    right_depth = f(root.right)\n\n    return max(left_depth, right_depth) + 1", "solution_func": "def g():\n    root = TreeNode(3)\n    root.left = TreeNode(9)\n    root.right = TreeNode(20)\n    root.right.left = TreeNode(15)\n    root.right.right = TreeNode(7)\n    return root", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> List[int]:\n    \"\"\"\n    Given a binary tree, return the inorder traversal of its nodes' values.\n\n    Example:\n    Input:\n        1\n         \\\n          2\n         /\n        3\n    Output: [1,3,2]\n\n    Hint: Use a stack to simulate the recursive inorder traversal. Start from the root and traverse to the leftmost node, pushing all the nodes along the way. Once there are no more left nodes, pop a node from the stack, add its value to the result list, and move to its right child. Repeat until the stack is empty and all nodes have been traversed.\n    \"\"\"\n\n    result = []\n    stack = []\n\n    while root or stack:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        result.append(root.val)\n        root = root.right\n\n    return result\n\ndef g():\n    root = TreeNode(1)\n    root.right = TreeNode(2)\n    root.right.left = TreeNode(3)\n    return root\n\nassert f(g()) == [1, 3, 2]\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 484, "target_skills": [0, 1, 0, 1, 1, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> List[int]:\n    \"\"\"\n    Given a binary tree, return the inorder traversal of its nodes' values.\n\n    Example:\n    Input:\n        1\n         \\\n          2\n         /\n        3\n    Output: [1,3,2]\n\n    Hint: Use a stack to simulate the recursive inorder traversal. Start from the root and traverse to the leftmost node, pushing all the nodes along the way. Once there are no more left nodes, pop a node from the stack, add its value to the result list, and move to its right child. Repeat until the stack is empty and all nodes have been traversed.\n    \"\"\"\n\n    result = []\n    stack = []\n\n    while root or stack:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        result.append(root.val)\n        root = root.right\n\n    return result", "solution_func": "def g():\n    root = TreeNode(1)\n    root.right = TreeNode(2)\n    root.right.left = TreeNode(3)\n    return root", "map_ix": [0, 0, 1, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the median of the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    3 (since the median of the list is 3)\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    if n % 2 == 0:\n        return (nums[n//2] + nums[n//2 - 1]) / 2\n    else:\n        return nums[n//2]\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 3\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 484, "target_skills": [1, 1, 1, 1, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the median of the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    3 (since the median of the list is 3)\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    if n % 2 == 0:\n        return (nums[n//2] + nums[n//2 - 1]) / 2\n    else:\n        return nums[n//2]", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\nimport math\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the sum of all the numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    15 (since 1 + 2 + 3 + 4 + 5 = 15)\n    \"\"\"\n    return sum(nums)\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 15\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 484, "target_skills": [0, 0, 1, 0, 0, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\nimport math\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the sum of all the numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    15 (since 1 + 2 + 3 + 4 + 5 = 15)\n    \"\"\"\n    return sum(nums)", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the sum of the binary representations of all the numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    1111 (since the binary representation of 1 is 1, 2 is 10, 3 is 11, 4 is 100, and 5 is 101. So the sum of the binary representations is 1111)\n    \"\"\"\n    binary_sum = 0\n    for num in nums:\n        binary_sum += int(bin(num)[2:])\n    return binary_sum\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 1111\n", "emb": null, "idx_generation": 484, "target_skills": [1, 0, 1, 1, 1, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the sum of the binary representations of all the numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    1111 (since the binary representation of 1 is 1, 2 is 10, 3 is 11, 4 is 100, and 5 is 101. So the sum of the binary representations is 1111)\n    \"\"\"\n    binary_sum = 0\n    for num in nums:\n        binary_sum += int(bin(num)[2:])\n    return binary_sum", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target value, find two numbers in the list that add up to the target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    Output:\n    [2, 5]\n\n    Explanation:\n    The numbers 2 and 5 add up to 7.\n\n    Hint: Use a two-pointer approach to search for the two numbers. Start with two pointers at both ends of the list and move them towards the middle, adjusting their positions based on the sum of the numbers at the pointers.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return [nums[left], nums[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value for the puzzle.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target\n\nassert f(*g()) == [2, 5]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 484, "target_skills": [0, 0, 1, 1, 0, 1, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target value, find two numbers in the list that add up to the target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    Output:\n    [2, 5]\n\n    Explanation:\n    The numbers 2 and 5 add up to 7.\n\n    Hint: Use a two-pointer approach to search for the two numbers. Start with two pointers at both ends of the list and move them towards the middle, adjusting their positions based on the sum of the numbers at the pointers.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return [nums[left], nums[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value for the puzzle.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target integer, determine if the target integer is present in the list.\n\n    Example:\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output:\n    True (since the target integer 5 is present in the list)\n    \"\"\"\n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n    return arr, target\n\nassert f(*g()) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 485, "target_skills": [1, 0, 0, 0, 1, 0, 0, 0, 0, 1], "problem_func": "from typing import*\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target integer, determine if the target integer is present in the list.\n\n    Example:\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output:\n    True (since the target integer 5 is present in the list)\n    \"\"\"\n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return False", "solution_func": "def g() -> Tuple[List[int], int]:\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of set bits (i.e., 1s) in its binary representation.\n\n    Example:\n    n = 7\n\n    Output:\n    3 (since the binary representation of 7 is 111 and it has 3 set bits)\n    \"\"\"\n    count = 0\n    while n > 0:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g() -> int:\n    return 7\n\nassert f(g()) == 3\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 485, "target_skills": [1, 1, 0, 0, 0, 1, 1, 1, 0, 1], "problem_func": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of set bits (i.e., 1s) in its binary representation.\n\n    Example:\n    n = 7\n\n    Output:\n    3 (since the binary representation of 7 is 111 and it has 3 set bits)\n    \"\"\"\n    count = 0\n    while n > 0:\n        count += n & 1\n        n >>= 1\n    return count", "solution_func": "def g() -> int:\n    return 7", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order using the bubble sort algorithm.\n\n    Example:\n    arr = [5, 3, 2, 4, 1]\n\n    Output:\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\n\ndef g() -> List[int]:\n    return [5, 3, 2, 4, 1]\n\nassert f(g()) == [1, 2, 3, 4, 5]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 485, "target_skills": [0, 1, 0, 0, 1, 1, 0, 0, 1, 1], "problem_func": "from typing import*\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order using the bubble sort algorithm.\n\n    Example:\n    arr = [5, 3, 2, 4, 1]\n\n    Output:\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr", "solution_func": "def g() -> List[int]:\n    return [5, 3, 2, 4, 1]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of all the previous elements in the input list.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5]\n    Output: [1, 3, 6, 10, 15]\n\n    Explanation: The output list is obtained by summing the previous elements in the input list. \n    The first element remains the same, while each subsequent element is the sum of all the previous elements.\n    \"\"\"\n    result = []\n    for i in range(len(nums)):\n        if i == 0:\n            result.append(nums[i])\n        else:\n            result.append(nums[i] + result[i-1])\n    return result\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [1, 3, 6, 10, 15]\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 485, "target_skills": [1, 0, 1, 1, 1, 0, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of all the previous elements in the input list.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5]\n    Output: [1, 3, 6, 10, 15]\n\n    Explanation: The output list is obtained by summing the previous elements in the input list. \n    The first element remains the same, while each subsequent element is the sum of all the previous elements.\n    \"\"\"\n    result = []\n    for i in range(len(nums)):\n        if i == 0:\n            result.append(nums[i])\n        else:\n            result.append(nums[i] + result[i-1])\n    return result", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3, 4, 5]", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a sorted 2D matrix of integers and a target value, determine if the target is present in the matrix.\n\n    The matrix is sorted row-wise and column-wise.\n\n    Example:\n    Input: \n    matrix = [\n        [1, 4, 7],\n        [2, 5, 8],\n        [3, 6, 9]\n    ]\n    target = 5\n\n    Output: True\n\n    Explanation: The target value 5 is present in the matrix.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    row = 0\n    col = cols - 1\n\n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n\n    return False\n\ndef g() -> Tuple[List[List[int]], int]:\n    matrix = [\n        [1, 4, 7],\n        [2, 5, 8],\n        [3, 6, 9]\n    ]\n    target = 5\n    return (matrix, target)\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 485, "target_skills": [0, 0, 0, 1, 1, 0, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a sorted 2D matrix of integers and a target value, determine if the target is present in the matrix.\n\n    The matrix is sorted row-wise and column-wise.\n\n    Example:\n    Input: \n    matrix = [\n        [1, 4, 7],\n        [2, 5, 8],\n        [3, 6, 9]\n    ]\n    target = 5\n\n    Output: True\n\n    Explanation: The target value 5 is present in the matrix.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    row = 0\n    col = cols - 1\n\n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n\n    return False", "solution_func": "def g() -> Tuple[List[List[int]], int]:\n    matrix = [\n        [1, 4, 7],\n        [2, 5, 8],\n        [3, 6, 9]\n    ]\n    target = 5\n    return (matrix, target)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray within the list.\n\n    Example:\n    Input: nums = [1, -2, 3, 4, -1, 2, 1, -5, 4]\n    Output: 10\n\n    Explanation: The subarray with the maximum sum is [3, 4, -1, 2, 1], which has a sum of 10.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum += num\n        if curr_sum > max_sum:\n            max_sum = curr_sum\n        if curr_sum < 0:\n            curr_sum = 0\n\n    return max_sum\n\ndef g() -> List[int]:\n    return [1, -2, 3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 10\n", "emb": null, "idx_generation": 485, "target_skills": [0, 1, 0, 0, 0, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray within the list.\n\n    Example:\n    Input: nums = [1, -2, 3, 4, -1, 2, 1, -5, 4]\n    Output: 10\n\n    Explanation: The subarray with the maximum sum is [3, 4, -1, 2, 1], which has a sum of 10.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum += num\n        if curr_sum > max_sum:\n            max_sum = curr_sum\n        if curr_sum < 0:\n            curr_sum = 0\n\n    return max_sum", "solution_func": "def g() -> List[int]:\n    return [1, -2, 3, 4, -1, 2, 1, -5, 4]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of ways to climb to the top of a staircase, where you can either climb 1 or 2 steps at a time.\n    Return the number of distinct ways.\n\n    Example:\n    n = 3\n\n    Output:\n    3 (as there are 3 ways to climb to the top: 1+1+1, 1+2, 2+1)\n\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    def climb_stairs_helper(n, memo):\n        if n <= 2:\n            return n\n        if n in memo:\n            return memo[n]\n        \n        distinct_ways = climb_stairs_helper(n - 1, memo) + climb_stairs_helper(n - 2, memo)\n        \n        memo[n] = distinct_ways\n        return distinct_ways\n\n    return climb_stairs_helper(n, {})\n\ndef g(n = 4):\n    return n\n\nassert f(g()) == 5\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 485, "target_skills": [1, 1, 0, 0, 0, 0, 0, 1, 1, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of ways to climb to the top of a staircase, where you can either climb 1 or 2 steps at a time.\n    Return the number of distinct ways.\n\n    Example:\n    n = 3\n\n    Output:\n    3 (as there are 3 ways to climb to the top: 1+1+1, 1+2, 2+1)\n\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    def climb_stairs_helper(n, memo):\n        if n <= 2:\n            return n\n        if n in memo:\n            return memo[n]\n        \n        distinct_ways = climb_stairs_helper(n - 1, memo) + climb_stairs_helper(n - 2, memo)\n        \n        memo[n] = distinct_ways\n        return distinct_ways\n\n    return climb_stairs_helper(n, {})", "solution_func": "def g(n = 4):\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s consisting of lowercase English letters, return the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n\n    Output:\n    3 (as the longest substring without repeating characters is \"abc\")\n\n    \"\"\"\n    if not s:\n        return 0\n    \n    max_length = 0\n    start = 0\n    seen = {}\n    \n    for end in range(len(s)):\n        if s[end] in seen and start <= seen[s[end]]:\n            start = seen[s[end]] + 1\n        else:\n            max_length = max(max_length, end - start + 1)\n        \n        seen[s[end]] = end\n\n    return max_length\n\ndef g(s = \"pwwkew\"):\n    return s\n\nassert f(g()) == 3\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 485, "target_skills": [1, 0, 1, 1, 1, 1, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s consisting of lowercase English letters, return the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n\n    Output:\n    3 (as the longest substring without repeating characters is \"abc\")\n\n    \"\"\"\n    if not s:\n        return 0\n    \n    max_length = 0\n    start = 0\n    seen = {}\n    \n    for end in range(len(s)):\n        if s[end] in seen and start <= seen[s[end]]:\n            start = seen[s[end]] + 1\n        else:\n            max_length = max(max_length, end - start + 1)\n        \n        seen[s[end]] = end\n\n    return max_length", "solution_func": "def g(s = \"pwwkew\"):\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers nums and a target integer target, return the number of combinations that add up to target.\n\n    Example:\n    nums = [1, 2, 3], target = 4\n\n    Output:\n    7 (as there are 7 combinations that add up to 4: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2], [3, 1], [1, 3])\n\n    \"\"\"\n    def combination_sum_helper(target, nums, memo):\n        if target == 0:\n            return 1\n        if target < 0:\n            return 0\n        if target in memo:\n            return memo[target]\n        \n        num_combinations = 0\n        for num in nums:\n            num_combinations += combination_sum_helper(target - num, nums, memo)\n        \n        memo[target] = num_combinations\n        return num_combinations\n    \n    return combination_sum_helper(target, nums, {})\n\ndef g(nums: List[int] = [1, 2, 3], target: int = 4):\n    return nums, target\n\nassert f(*g()) == 7\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 485, "target_skills": [1, 0, 1, 1, 0, 1, 1, 0, 1, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers nums and a target integer target, return the number of combinations that add up to target.\n\n    Example:\n    nums = [1, 2, 3], target = 4\n\n    Output:\n    7 (as there are 7 combinations that add up to 4: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2], [3, 1], [1, 3])\n\n    \"\"\"\n    def combination_sum_helper(target, nums, memo):\n        if target == 0:\n            return 1\n        if target < 0:\n            return 0\n        if target in memo:\n            return memo[target]\n        \n        num_combinations = 0\n        for num in nums:\n            num_combinations += combination_sum_helper(target - num, nums, memo)\n        \n        memo[target] = num_combinations\n        return num_combinations\n    \n    return combination_sum_helper(target, nums, {})", "solution_func": "def g(nums: List[int] = [1, 2, 3], target: int = 4):\n    return nums, target", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a sorted array of integers in ascending order (arr), find the missing number in the range from 0 to n+1.\n    The array does not contain any duplicate numbers.\n\n    Example:\n    arr = [0, 1, 2, 4, 5, 6]\n\n    Output:\n    3\n\n    Explanation:\n    The number 3 is missing from the array.\n    \"\"\"\n\n    n = len(arr)\n    left, right = 0, n - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        # Check if the missing number is on the left side\n        if arr[mid] - mid > 1 and (mid == 0 or arr[mid - 1] - (mid - 1) == 1):\n            return arr[mid] - 1\n\n        # Check if the missing number is on the right side\n        if arr[mid] - mid < 1:\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return -1\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted array of integers for the function f.\n    \"\"\"\n    return [0, 1, 2, 4, 5, 6]\n\nassert f(g()) == 3\n\n", "emb": null, "idx_generation": 485, "target_skills": [0, 0, 0, 0, 1, 0, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a sorted array of integers in ascending order (arr), find the missing number in the range from 0 to n+1.\n    The array does not contain any duplicate numbers.\n\n    Example:\n    arr = [0, 1, 2, 4, 5, 6]\n\n    Output:\n    3\n\n    Explanation:\n    The number 3 is missing from the array.\n    \"\"\"\n\n    n = len(arr)\n    left, right = 0, n - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        # Check if the missing number is on the left side\n        if arr[mid] - mid > 1 and (mid == 0 or arr[mid - 1] - (mid - 1) == 1):\n            return arr[mid] - 1\n\n        # Check if the missing number is on the right side\n        if arr[mid] - mid < 1:\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return -1", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a sorted array of integers for the function f.\n    \"\"\"\n    return [0, 1, 2, 4, 5, 6]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int, k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, a target integer, and an integer k, find the k closest elements to the target in the list.\n    The returned list should be sorted in ascending order by the absolute difference between each element and the target.\n    If there are multiple elements with the same difference, sort them in ascending order.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5], target = 3, k = 3\n    Output: [2, 3, 4]\n\n    Explanation: The absolute difference between each element and the target: [2, 1, 0, 1, 2].\n    The k closest elements to the target are [2, 3, 4].\n\n    Hint: Sort the list based on the absolute difference between each element and the target, and then return the first k elements.\n\n    \"\"\"\n    nums.sort(key=lambda x: (abs(x - target), x))\n    return nums[:k]\n\ndef g(nums=[1, 2, 3, 4, 5], target=3, k=3):\n    return nums, target, k\n\nassert f(*g()) == [2, 3, 4]\n\n", "emb": null, "idx_generation": 486, "target_skills": [1, 1, 0, 1, 1, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int, k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, a target integer, and an integer k, find the k closest elements to the target in the list.\n    The returned list should be sorted in ascending order by the absolute difference between each element and the target.\n    If there are multiple elements with the same difference, sort them in ascending order.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5], target = 3, k = 3\n    Output: [2, 3, 4]\n\n    Explanation: The absolute difference between each element and the target: [2, 1, 0, 1, 2].\n    The k closest elements to the target are [2, 3, 4].\n\n    Hint: Sort the list based on the absolute difference between each element and the target, and then return the first k elements.\n\n    \"\"\"\n    nums.sort(key=lambda x: (abs(x - target), x))\n    return nums[:k]", "solution_func": "def g(nums=[1, 2, 3, 4, 5], target=3, k=3):\n    return nums, target, k", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of characters in each word within the string while still preserving whitespace and initial word order.\n\n    Example:\n    Input: s = \"hello world\"\n    Output: \"olleh dlrow\"\n\n    Explanation: Reverse the order of characters in each word:\n    \"hello\" -> \"olleh\"\n    \"world\" -> \"dlrow\"\n\n    Hint: Split the string into words, reverse each word, and then join the words back together.\n\n    \"\"\"\n    words = s.split()\n    reverse_words = [word[::-1] for word in words]\n    return \" \".join(reverse_words)\n\ndef g(s=\"hello world\"):\n    return s\n\nassert f(*g()) == \"olleh dlrow\"\n\n", "emb": null, "idx_generation": 486, "target_skills": [0, 0, 1, 0, 0, 0, 0, 0, 1, 0], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of characters in each word within the string while still preserving whitespace and initial word order.\n\n    Example:\n    Input: s = \"hello world\"\n    Output: \"olleh dlrow\"\n\n    Explanation: Reverse the order of characters in each word:\n    \"hello\" -> \"olleh\"\n    \"world\" -> \"dlrow\"\n\n    Hint: Split the string into words, reverse each word, and then join the words back together.\n\n    \"\"\"\n    words = s.split()\n    reverse_words = [word[::-1] for word in words]\n    return \" \".join(reverse_words)", "solution_func": "def g(s=\"hello world\"):\n    return s", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, determine if there are two numbers in the list that add up to the target.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5], target = 7\n    Output: True\n\n    Explanation: There are two numbers in the list, 2 and 5, that add up to the target 7.\n\n    Hint: Use two pointers to iterate through the list and check if the sum of the current pair of numbers is equal to the target.\n\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5], target=7):\n    return nums, target\n\nassert f(*g()) == True\n\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 486, "target_skills": [1, 0, 1, 0, 1, 0, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, determine if there are two numbers in the list that add up to the target.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5], target = 7\n    Output: True\n\n    Explanation: There are two numbers in the list, 2 and 5, that add up to the target 7.\n\n    Hint: Use two pointers to iterate through the list and check if the sum of the current pair of numbers is equal to the target.\n\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g(nums=[1, 2, 3, 4, 5], target=7):\n    return nums, target", "map_ix": [1, 0, 1, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\nclass Node:\n    def __init__(self, val: int):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef f(root: Node, target: int) -> List[List[int]]:\n    \"\"\"\n    Given a binary tree and a target value, find all paths in the tree that sum up to the target.\n\n    Example:\n    root = Node(5)\n    root.left = Node(4)\n    root.right = Node(8)\n    root.left.left = Node(11)\n    root.left.left.left = Node(7)\n    root.left.left.right = Node(2)\n    root.right.left = Node(13)\n    root.right.right = Node(4)\n    root.right.right.left = Node(5)\n    root.right.right.right = Node(1)\n    target = 22\n\n    Output:\n    [[5, 4, 11, 2], [5, 8, 4, 5]]\n    \n    Explanation:\n    The paths [5, 4, 11, 2] and [5, 8, 4, 5] sum up to 22.\n    \"\"\"\n\n    def dfs(node, path, curr_sum):\n        if not node:\n            return\n        curr_sum += node.val\n        path.append(node.val)\n        if curr_sum == target:\n            paths.append(path[:])\n        dfs(node.left, path, curr_sum)\n        dfs(node.right, path, curr_sum)\n        path.pop()\n\n    paths = []\n    dfs(root, [], 0)\n\n    return paths\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers to construct the binary tree.\n    \"\"\"\n    return [5, 4, 8, 11, None, 13, 4, 7, 2, None, None, None, None, None, 5, 1]\n\nroot_vals = g()\n\ndef build_tree(vals, i):\n    if i >= len(vals) or vals[i] == None:\n        return None\n    root = Node(vals[i])\n    root.left = build_tree(vals, 2 * i + 1)\n    root.right = build_tree(vals, 2 * i + 2)\n    return root\n\nroot = build_tree(root_vals, 0)\n\ntarget = 22\n\nassert f(root, target) == [[5, 4, 11, 2], [5, 8, 4, 5]]\n", "emb": null, "idx_generation": 486, "target_skills": [0, 1, 1, 0, 0, 1, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\nclass Node:\n    def __init__(self, val: int):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef f(root: Node, target: int) -> List[List[int]]:\n    \"\"\"\n    Given a binary tree and a target value, find all paths in the tree that sum up to the target.\n\n    Example:\n    root = Node(5)\n    root.left = Node(4)\n    root.right = Node(8)\n    root.left.left = Node(11)\n    root.left.left.left = Node(7)\n    root.left.left.right = Node(2)\n    root.right.left = Node(13)\n    root.right.right = Node(4)\n    root.right.right.left = Node(5)\n    root.right.right.right = Node(1)\n    target = 22\n\n    Output:\n    [[5, 4, 11, 2], [5, 8, 4, 5]]\n    \n    Explanation:\n    The paths [5, 4, 11, 2] and [5, 8, 4, 5] sum up to 22.\n    \"\"\"\n\n    def dfs(node, path, curr_sum):\n        if not node:\n            return\n        curr_sum += node.val\n        path.append(node.val)\n        if curr_sum == target:\n            paths.append(path[:])\n        dfs(node.left, path, curr_sum)\n        dfs(node.right, path, curr_sum)\n        path.pop()\n\n    paths = []\n    dfs(root, [], 0)\n\n    return paths", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers to construct the binary tree.\n    \"\"\"\n    return [5, 4, 8, 11, None, 13, 4, 7, 2, None, None, None, None, None, 5, 1]\n\nroot_vals = g()\n\ndef build_tree(vals, i):\n    if i >= len(vals) or vals[i] == None:\n        return None\n    root = Node(vals[i])\n    root.left = build_tree(vals, 2 * i + 1)\n    root.right = build_tree(vals, 2 * i + 2)\n    return root\n\nroot = build_tree(root_vals, 0)\n\ntarget = 22", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the shortest path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    matrix = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The shortest path is 1 -> 3 -> 1 -> 1 -> 1, which gives a sum of 7.\n    \"\"\"\n\n    m = len(matrix)\n    n = len(matrix[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = matrix[0][0]\n\n    for i in range(1, n):\n        dp[0][i] = dp[0][i-1] + matrix[0][i]\n    for j in range(1, m):\n        dp[j][0] = dp[j-1][0] + matrix[j][0]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers.\n    \"\"\"\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 486, "target_skills": [1, 1, 1, 1, 1, 0, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the shortest path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    matrix = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The shortest path is 1 -> 3 -> 1 -> 1 -> 1, which gives a sum of 7.\n    \"\"\"\n\n    m = len(matrix)\n    n = len(matrix[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = matrix[0][0]\n\n    for i in range(1, n):\n        dp[0][i] = dp[0][i-1] + matrix[0][i]\n    for j in range(1, m):\n        dp[j][0] = dp[j-1][0] + matrix[j][0]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers.\n    \"\"\"\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given a directed graph, determine if it contains a cycle.\n\n    Example:\n    graph = [\n        [1, 2],\n        [2],\n        [3],\n        [3]\n    ]\n\n    Output:\n    False\n\n    Explanation:\n    The graph does not contain a cycle.\n    \"\"\"\n\n    def dfs(node):\n        if visited[node] == 1:\n            return False\n        if visited[node] == -1:\n            return True\n\n        visited[node] = -1\n\n        for neighbor in graph[node]:\n            if dfs(neighbor):\n                return True\n\n        visited[node] = 1\n\n        return False\n\n    n = len(graph)\n    visited = [0] * n\n\n    for i in range(n):\n        if dfs(i):\n            return True\n\n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a directed graph.\n    \"\"\"\n    return [\n        [1, 2],\n        [2],\n        [3],\n        [3]\n    ]\n\nassert f(g()) == False\n", "emb": null, "idx_generation": 486, "target_skills": [0, 0, 1, 1, 0, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given a directed graph, determine if it contains a cycle.\n\n    Example:\n    graph = [\n        [1, 2],\n        [2],\n        [3],\n        [3]\n    ]\n\n    Output:\n    False\n\n    Explanation:\n    The graph does not contain a cycle.\n    \"\"\"\n\n    def dfs(node):\n        if visited[node] == 1:\n            return False\n        if visited[node] == -1:\n            return True\n\n        visited[node] = -1\n\n        for neighbor in graph[node]:\n            if dfs(neighbor):\n                return True\n\n        visited[node] = 1\n\n        return False\n\n    n = len(graph)\n    visited = [0] * n\n\n    for i in range(n):\n        if dfs(i):\n            return True\n\n    return False", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a directed graph.\n    \"\"\"\n    return [\n        [1, 2],\n        [2],\n        [3],\n        [3]\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Find the index of the target element in a sorted array using binary search.\n    If the target element is not found, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g(nums = [1, 2, 3, 4, 5], target = 3):\n    return nums, target\n\nassert f(*g()) == 2\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 486, "target_skills": [1, 1, 1, 1, 0, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Find the index of the target element in a sorted array using binary search.\n    If the target element is not found, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1", "solution_func": "def g(nums = [1, 2, 3, 4, 5], target = 3):\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Find the minimum number of steps required to reach the bottom-right corner of a grid.\n    You can only move down or right.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Create a 2D DP table to store the minimum steps\n    dp = [[0] * cols for _ in range(rows)]\n\n    # Initialize the first row and first column of the DP table\n    for i in range(cols):\n        dp[0][i] = i\n    for i in range(rows):\n        dp[i][0] = i\n\n    # Fill the rest of the DP table\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    return grid\n\nassert f(g()) == 7\n", "emb": null, "idx_generation": 486, "target_skills": [0, 1, 1, 0, 1, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Find the minimum number of steps required to reach the bottom-right corner of a grid.\n    You can only move down or right.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Create a 2D DP table to store the minimum steps\n    dp = [[0] * cols for _ in range(rows)]\n\n    # Initialize the first row and first column of the DP table\n    for i in range(cols):\n        dp[0][i] = i\n    for i in range(rows):\n        dp[i][0] = i\n\n    # Fill the rest of the DP table\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]", "solution_func": "def g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Determine if a directed graph contains a cycle.\n    \"\"\"\n    visited = [0] * len(graph)\n    path = [0] * len(graph)\n\n    for node in range(len(graph)):\n        if not visited[node] and dfs(graph, node, visited, path):\n            return True\n    \n    return False\n\ndef dfs(graph: List[List[int]], node: int, visited: List[int], path: List[int]) -> bool:\n    visited[node] = 1\n    path[node] = 1\n\n    for neighbor in range(len(graph)):\n        if graph[node][neighbor] == 1:\n            if not visited[neighbor] and dfs(graph, neighbor, visited, path):\n                return True\n            elif path[neighbor]:\n                return True\n    \n    path[node] = 0\n\n    return False\n\ndef g():\n    graph = [\n        [0, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 1],\n        [1, 0, 0, 0, 0]\n    ]\n\n    return graph\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 486, "target_skills": [0, 0, 1, 0, 0, 1, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Determine if a directed graph contains a cycle.\n    \"\"\"\n    visited = [0] * len(graph)\n    path = [0] * len(graph)\n\n    for node in range(len(graph)):\n        if not visited[node] and dfs(graph, node, visited, path):\n            return True\n    \n    return False\n\ndef dfs(graph: List[List[int]], node: int, visited: List[int], path: List[int]) -> bool:\n    visited[node] = 1\n    path[node] = 1\n\n    for neighbor in range(len(graph)):\n        if graph[node][neighbor] == 1:\n            if not visited[neighbor] and dfs(graph, neighbor, visited, path):\n                return True\n            elif path[neighbor]:\n                return True\n    \n    path[node] = 0\n\n    return False", "solution_func": "def g():\n    graph = [\n        [0, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 1],\n        [1, 0, 0, 0, 0]\n    ]\n\n    return graph", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Two Sum\n\n    Given an array of integers, return the indices of two numbers such that they add up to a specific target.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    output: [0, 1]\n\n    Explanation:\n    nums[0] + nums[1] = 2 + 7 = 9\n    \"\"\"\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []\n\ndef g(nums = [2, 7, 11, 15], target = 9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 486, "target_skills": [1, 1, 1, 0, 1, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Two Sum\n\n    Given an array of integers, return the indices of two numbers such that they add up to a specific target.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    output: [0, 1]\n\n    Explanation:\n    nums[0] + nums[1] = 2 + 7 = 9\n    \"\"\"\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []", "solution_func": "def g(nums = [2, 7, 11, 15], target = 9):\n    return nums, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the number of ways to arrange n pairs of parentheses.\n\n    Args:\n    - n: An integer representing the number of pairs of parentheses.\n\n    Returns:\n    - The number of valid parentheses arrangements.\n\n    Example:\n    Input: n = 3\n    Output: 5\n\n    Explanation: The valid arrangements are \"((()))\", \"(()())\", \"(())()\", \"()(())\", and \"()()()\".\n    \"\"\"\n\n    def backtrack(s, left, right):\n        if len(s) == 2 * n:\n            res.append(s)\n            return\n        if left < n:\n            backtrack(s + '(', left + 1, right)\n        if right < left:\n            backtrack(s + ')', left, right + 1)\n\n    res = []\n    backtrack('', 0, 0)\n    return len(res)\n\ndef g():\n    n = 3\n    return n\n\nassert f(g()) == 5\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 487, "target_skills": [0, 1, 1, 0, 1, 1, 0, 1, 0, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the number of ways to arrange n pairs of parentheses.\n\n    Args:\n    - n: An integer representing the number of pairs of parentheses.\n\n    Returns:\n    - The number of valid parentheses arrangements.\n\n    Example:\n    Input: n = 3\n    Output: 5\n\n    Explanation: The valid arrangements are \"((()))\", \"(()())\", \"(())()\", \"()(())\", and \"()()()\".\n    \"\"\"\n\n    def backtrack(s, left, right):\n        if len(s) == 2 * n:\n            res.append(s)\n            return\n        if left < n:\n            backtrack(s + '(', left + 1, right)\n        if right < left:\n            backtrack(s + ')', left, right + 1)\n\n    res = []\n    backtrack('', 0, 0)\n    return len(res)", "solution_func": "def g():\n    n = 3\n    return n", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, calculate the length of the longest substring without repeating characters.\n\n    Args:\n    - s: A string.\n\n    Returns:\n    - The length of the longest substring without repeating characters.\n\n    Example:\n    Input: s = \"abcabcbb\"\n    Output: 3\n\n    Explanation: The longest substring without repeating characters is \"abc\".\n    \"\"\"\n\n    start = 0\n    max_len = 0\n    char_map = {}\n\n    for end in range(len(s)):\n        if s[end] in char_map:\n            start = max(start, char_map[s[end]] + 1)\n        char_map[s[end]] = end\n        max_len = max(max_len, end - start + 1)\n\n    return max_len\n\ndef g():\n    s = \"abcabcbb\"\n    return s\n\nassert f(g()) == 3\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 487, "target_skills": [0, 1, 1, 1, 1, 0, 1, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, calculate the length of the longest substring without repeating characters.\n\n    Args:\n    - s: A string.\n\n    Returns:\n    - The length of the longest substring without repeating characters.\n\n    Example:\n    Input: s = \"abcabcbb\"\n    Output: 3\n\n    Explanation: The longest substring without repeating characters is \"abc\".\n    \"\"\"\n\n    start = 0\n    max_len = 0\n    char_map = {}\n\n    for end in range(len(s)):\n        if s[end] in char_map:\n            start = max(start, char_map[s[end]] + 1)\n        char_map[s[end]] = end\n        max_len = max(max_len, end - start + 1)\n\n    return max_len", "solution_func": "def g():\n    s = \"abcabcbb\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\n    Args:\n    - nums: A list of integers.\n    - target: An integer.\n\n    Returns:\n    - A list of two integers representing the indices of the two numbers.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation: The sum of nums[0] = 2 and nums[1] = 7 is 9, so the indices are [0, 1].\n    \"\"\"\n\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 487, "target_skills": [0, 0, 0, 1, 0, 0, 1, 0, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\n    Args:\n    - nums: A list of integers.\n    - target: An integer.\n\n    Returns:\n    - A list of two integers representing the indices of the two numbers.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation: The sum of nums[0] = 2 and nums[1] = 7 is 9, so the indices are [0, 1].\n    \"\"\"\n\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n\n    return []", "solution_func": "def g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique BSTs (binary search trees) that can be constructed with n nodes.\n\n    Example:\n    n = 3\n\n    Output:\n    5\n\n    Explanation:\n    For n = 3, there are 5 unique BSTs that can be constructed:\n       1         3     3      2      1\n        \\       /     /      / \\      \\\n         3     2     1      1   3      2\n        /     /       \\                 \\\n       2     1         2                 3\n\n    Hint: Use dynamic programming to solve this problem.\n    \"\"\"\n\n    dp = [0] * (n+1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n+1):\n        for j in range(1, i+1):\n            dp[i] += dp[j-1] * dp[i-j]\n\n    return dp[n]\n\ndef g():\n    return 3\n\nassert f(g()) == 5\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 487, "target_skills": [1, 0, 0, 1, 0, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique BSTs (binary search trees) that can be constructed with n nodes.\n\n    Example:\n    n = 3\n\n    Output:\n    5\n\n    Explanation:\n    For n = 3, there are 5 unique BSTs that can be constructed:\n       1         3     3      2      1\n        \\       /     /      / \\      \\\n         3     2     1      1   3      2\n        /     /       \\                 \\\n       2     1         2                 3\n\n    Hint: Use dynamic programming to solve this problem.\n    \"\"\"\n\n    dp = [0] * (n+1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n+1):\n        for j in range(1, i+1):\n            dp[i] += dp[j-1] * dp[i-j]\n\n    return dp[n]", "solution_func": "def g():\n    return 3", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer k, return the maximum sum of a subarray of size k.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    k = 3\n\n    Output:\n    12\n\n    Explanation:\n    The subarray with maximum sum is [3, 4, 5] with a sum of 12.\n\n    Hint: Use sliding window technique to solve this problem.\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n    left = 0\n\n    for right in range(len(nums)):\n        curr_sum += nums[right]\n\n        if right - left + 1 == k:\n            max_sum = max(max_sum, curr_sum)\n            curr_sum -= nums[left]\n            left += 1\n\n    return max_sum\n\ndef g(nums=[1, 2, 3, 4, 5], k=3):\n    return nums, k\n\nassert f(*g()) == 12\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 487, "target_skills": [1, 1, 0, 1, 1, 0, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer k, return the maximum sum of a subarray of size k.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    k = 3\n\n    Output:\n    12\n\n    Explanation:\n    The subarray with maximum sum is [3, 4, 5] with a sum of 12.\n\n    Hint: Use sliding window technique to solve this problem.\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n    left = 0\n\n    for right in range(len(nums)):\n        curr_sum += nums[right]\n\n        if right - left + 1 == k:\n            max_sum = max(max_sum, curr_sum)\n            curr_sum -= nums[left]\n            left += 1\n\n    return max_sum", "solution_func": "def g(nums=[1, 2, 3, 4, 5], k=3):\n    return nums, k", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the maximum sum of a contiguous subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The subarray with maximum sum is [4, -1, 2, 1] with a sum of 6.\n\n    Hint: Use Kadane's algorithm to solve this problem.\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 487, "target_skills": [1, 0, 0, 1, 0, 1, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the maximum sum of a contiguous subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The subarray with maximum sum is [4, -1, 2, 1] with a sum of 6.\n\n    Hint: Use Kadane's algorithm to solve this problem.\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum", "solution_func": "def g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> float:\n    \"\"\"\n    Given a list of 2D points, calculate the area of the triangle formed by three points.\n\n    Example:\n    points = [[0, 0], [3, 0], [0, 4]]\n\n    Output:\n    6.0\n\n    Explanation:\n    The points form a triangle with base 3 and height 4, resulting in an area of 6.\n    \"\"\"\n\n    # Function to calculate area of triangle given 3 points\n    def calculate_area(p1, p2, p3):\n        return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2)\n\n    # Extract points\n    p1, p2, p3 = points[0], points[1], points[2]\n\n    # Calculate area of triangle\n    area = calculate_area(p1, p2, p3)\n\n    return area\n\ndef g() -> List[List[int]]:\n    return [[0, 0], [3, 0], [0, 4]]\n\nassert f(g()) == 6.0\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 487, "target_skills": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> float:\n    \"\"\"\n    Given a list of 2D points, calculate the area of the triangle formed by three points.\n\n    Example:\n    points = [[0, 0], [3, 0], [0, 4]]\n\n    Output:\n    6.0\n\n    Explanation:\n    The points form a triangle with base 3 and height 4, resulting in an area of 6.\n    \"\"\"\n\n    # Function to calculate area of triangle given 3 points\n    def calculate_area(p1, p2, p3):\n        return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2)\n\n    # Extract points\n    p1, p2, p3 = points[0], points[1], points[2]\n\n    # Calculate area of triangle\n    area = calculate_area(p1, p2, p3)\n\n    return area", "solution_func": "def g() -> List[List[int]]:\n    return [[0, 0], [3, 0], [0, 4]]", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> bool:\n    \"\"\"\n    Given a list of 2D points, determine if the points form a square.\n\n    Example:\n    points = [[0, 0], [0, 2], [2, 0], [2, 2]]\n\n    Output:\n    True\n\n    Explanation:\n    The points form a square with equal side lengths and right angles.\n    \"\"\"\n\n    # Function to calculate distance between two points\n    def calculate_distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    # Extract points\n    p1, p2, p3, p4 = points[0], points[1], points[2], points[3]\n\n    # Check if lengths of all sides are equal\n    side1 = calculate_distance(p1, p2)\n    side2 = calculate_distance(p2, p3)\n    side3 = calculate_distance(p3, p4)\n    side4 = calculate_distance(p4, p1)\n\n    if side1 == side2 == side3 == side4:\n        # Check if diagonals are equal\n        diagonal1 = calculate_distance(p1, p3)\n        diagonal2 = calculate_distance(p2, p4)\n\n        if diagonal1 == diagonal2:\n            return True\n\n    return False\n\ndef g() -> List[List[int]]:\n    return [[0, 0], [0, 2], [2, 0], [2, 2]]\n\nassert f(g()) == True\n", "emb": null, "idx_generation": 487, "target_skills": [1, 0, 1, 1, 0, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> bool:\n    \"\"\"\n    Given a list of 2D points, determine if the points form a square.\n\n    Example:\n    points = [[0, 0], [0, 2], [2, 0], [2, 2]]\n\n    Output:\n    True\n\n    Explanation:\n    The points form a square with equal side lengths and right angles.\n    \"\"\"\n\n    # Function to calculate distance between two points\n    def calculate_distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    # Extract points\n    p1, p2, p3, p4 = points[0], points[1], points[2], points[3]\n\n    # Check if lengths of all sides are equal\n    side1 = calculate_distance(p1, p2)\n    side2 = calculate_distance(p2, p3)\n    side3 = calculate_distance(p3, p4)\n    side4 = calculate_distance(p4, p1)\n\n    if side1 == side2 == side3 == side4:\n        # Check if diagonals are equal\n        diagonal1 = calculate_distance(p1, p3)\n        diagonal2 = calculate_distance(p2, p4)\n\n        if diagonal1 == diagonal2:\n            return True\n\n    return False", "solution_func": "def g() -> List[List[int]]:\n    return [[0, 0], [0, 2], [2, 0], [2, 2]]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> int:\n    \"\"\"\n    Given a list of 2D points, count the number of points lying on the perimeter of a rectangle.\n\n    Example:\n    points = [[0, 0], [0, 1], [1, 0], [1, 1], [2, 2]]\n\n    Output:\n    4\n\n    Explanation:\n    The points (0, 0), (0, 1), (1, 0), and (1, 1) lie on the perimeter of a rectangle.\n    \"\"\"\n\n    # Function to check if three points are collinear\n    def are_collinear(p1, p2, p3):\n        return (p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1])) == 0\n\n    # Extract points\n    p1, p2, p3, p4, p5 = points[0], points[1], points[2], points[3], points[4]\n\n    count = 0\n\n    # Check if each point forms a rectangle with other points\n    if are_collinear(p1, p2, p3) or are_collinear(p1, p2, p4) or are_collinear(p1, p2, p5):\n        count += 1\n\n    if are_collinear(p2, p3, p4) or are_collinear(p2, p3, p5):\n        count += 1\n\n    if are_collinear(p3, p4, p5):\n        count += 1\n\n    return count\n\ndef g() -> List[List[int]]:\n    return [[0, 0], [0, 1], [1, 0], [1, 1], [2, 2]]\n\nassert f(g()) == 4\n", "emb": null, "idx_generation": 487, "target_skills": [1, 0, 0, 1, 0, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> int:\n    \"\"\"\n    Given a list of 2D points, count the number of points lying on the perimeter of a rectangle.\n\n    Example:\n    points = [[0, 0], [0, 1], [1, 0], [1, 1], [2, 2]]\n\n    Output:\n    4\n\n    Explanation:\n    The points (0, 0), (0, 1), (1, 0), and (1, 1) lie on the perimeter of a rectangle.\n    \"\"\"\n\n    # Function to check if three points are collinear\n    def are_collinear(p1, p2, p3):\n        return (p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1])) == 0\n\n    # Extract points\n    p1, p2, p3, p4, p5 = points[0], points[1], points[2], points[3], points[4]\n\n    count = 0\n\n    # Check if each point forms a rectangle with other points\n    if are_collinear(p1, p2, p3) or are_collinear(p1, p2, p4) or are_collinear(p1, p2, p5):\n        count += 1\n\n    if are_collinear(p2, p3, p4) or are_collinear(p2, p3, p5):\n        count += 1\n\n    if are_collinear(p3, p4, p5):\n        count += 1\n\n    return count", "solution_func": "def g() -> List[List[int]]:\n    return [[0, 0], [0, 1], [1, 0], [1, 1], [2, 2]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find two numbers in the list that sum up to the target.\n    Return the indices of the two numbers in the list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Hint: Use a two-pointer approach to search for the pair of numbers.\n    \"\"\"\n\n    def two_sum(nums, target):\n        num_dict = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in num_dict:\n                return [num_dict[complement], i]\n            num_dict[num] = i\n        return []\n\n    return two_sum(nums, target)\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return (nums, target)\n\nassert f(*g()) == [0, 1]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 487, "target_skills": [0, 1, 1, 1, 1, 1, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find two numbers in the list that sum up to the target.\n    Return the indices of the two numbers in the list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Hint: Use a two-pointer approach to search for the pair of numbers.\n    \"\"\"\n\n    def two_sum(nums, target):\n        num_dict = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in num_dict:\n                return [num_dict[complement], i]\n            num_dict[num] = i\n        return []\n\n    return two_sum(nums, target)", "solution_func": "def g(nums=[2, 7, 11, 15], target=9):\n    return (nums, target)", "map_ix": [1, 0, 0, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, find the index of the target value in the list using binary search.\n    If the target value is not found, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g():\n    nums = [1, 3, 5, 7, 9]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 3\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 488, "target_skills": [1, 0, 1, 1, 0, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, find the index of the target value in the list using binary search.\n    If the target value is not found, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1", "solution_func": "def g():\n    nums = [1, 3, 5, 7, 9]\n    target = 7\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the minimum path sum from the top-left corner to the bottom-right corner.\n    The minimum path sum is the sum of all the numbers along the path with the smallest sum.\n    You can only move down or right at any point in time.\n\n    Return the minimum path sum.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0], "idx_generation": 488, "target_skills": [1, 1, 0, 1, 1, 0, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the minimum path sum from the top-left corner to the bottom-right corner.\n    The minimum path sum is the sum of all the numbers along the path with the smallest sum.\n    You can only move down or right at any point in time.\n\n    Return the minimum path sum.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]", "solution_func": "def g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers as a list.\n\n    Note: You may assume that each input would have exactly one solution, and you may not use the same element twice.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    nums[0] + nums[1] = 2 + 7 = 9, so the indices are [0, 1].\n\n    Hint: Use a dictionary to store the complement of each number as you iterate through the list. Check if the complement exists in the dictionary, and if so, return the indices.\n    \"\"\"\n    complement_map = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        if complement in complement_map:\n            return [complement_map[complement], i]\n        \n        complement_map[num] = i\n    \n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 488, "target_skills": [1, 0, 0, 1, 1, 0, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers as a list.\n\n    Note: You may assume that each input would have exactly one solution, and you may not use the same element twice.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    nums[0] + nums[1] = 2 + 7 = 9, so the indices are [0, 1].\n\n    Hint: Use a dictionary to store the complement of each number as you iterate through the list. Check if the complement exists in the dictionary, and if so, return the indices.\n    \"\"\"\n    complement_map = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        if complement in complement_map:\n            return [complement_map[complement], i]\n        \n        complement_map[num] = i\n    \n    return []", "solution_func": "def g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target number if it exists in the list.\n    If the target number does not exist in the list, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(nums=[2, 4, 6, 8, 10, 12], target=8):\n    return nums, target\n\nassert f(*g()) == 3\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 488, "target_skills": [0, 0, 1, 0, 1, 0, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target number if it exists in the list.\n    If the target number does not exist in the list, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g(nums=[2, 4, 6, 8, 10, 12], target=8):\n    return nums, target", "map_ix": [1, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Count the number of digits in the factorial of a given number n.\n    \"\"\"\n    count = 0\n    factorial = 1\n\n    for i in range(1, n + 1):\n        factorial *= i\n\n    while factorial > 0:\n        count += 1\n        factorial //= 10\n\n    return count\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 488, "target_skills": [0, 0, 1, 0, 1, 1, 1, 0, 0, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Count the number of digits in the factorial of a given number n.\n    \"\"\"\n    count = 0\n    factorial = 1\n\n    for i in range(1, n + 1):\n        factorial *= i\n\n    while factorial > 0:\n        count += 1\n        factorial //= 10\n\n    return count", "solution_func": "def g(n=5):\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Find the maximum product of two numbers in a given list of integers.\n    \"\"\"\n    max_product = float('-inf')\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n\n    return max_product\n\ndef g(nums=[-2, -3, -4, -5, -6]):\n    return nums\n\nassert f(g()) == 20\n", "emb": null, "idx_generation": 488, "target_skills": [1, 0, 1, 1, 0, 1, 0, 0, 1, 1], "problem_func": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Find the maximum product of two numbers in a given list of integers.\n    \"\"\"\n    max_product = float('-inf')\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n\n    return max_product", "solution_func": "def g(nums=[-2, -3, -4, -5, -6]):\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target integer, determine if there are two numbers in the list that add up to the target.\n\n    Return True if there exists two numbers that add up to the target, False otherwise.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    Output:\n    True\n\n    Explanation:\n    There exists 2 and 5 in the list that add up to 7.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        total = nums[left] + nums[right]\n        if total == target:\n            return True\n        elif total < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 488, "target_skills": [0, 0, 1, 1, 1, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target integer, determine if there are two numbers in the list that add up to the target.\n\n    Return True if there exists two numbers that add up to the target, False otherwise.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    Output:\n    True\n\n    Explanation:\n    There exists 2 and 5 in the list that add up to 7.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        total = nums[left] + nums[right]\n        if total == target:\n            return True\n        elif total < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a contiguous subarray.\n\n    Return the maximum sum.\n\n    Example:\n    nums = [1, -2, 3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    9\n\n    Explanation:\n    The contiguous subarray with the maximum sum is [3, 4, -1, 2, 1], which sums up to 9.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g():\n    nums = [1, -2, 3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 9\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 488, "target_skills": [1, 0, 1, 0, 1, 1, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a contiguous subarray.\n\n    Return the maximum sum.\n\n    Example:\n    nums = [1, -2, 3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    9\n\n    Explanation:\n    The contiguous subarray with the maximum sum is [3, 4, -1, 2, 1], which sums up to 9.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g():\n    nums = [1, -2, 3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target integer, find all unique combinations of numbers in the list that add up to the target.\n\n    Return a list of lists containing the combinations.\n\n    Example:\n    nums = [2, 3, 6, 7]\n    target = 7\n\n    Output:\n    [[2, 2, 3], [7]]\n\n    Explanation:\n    There are two unique combinations that add up to 7: [2, 2, 3] and [7].\n    \"\"\"\n    def backtrack(start, target, path):\n        if target == 0:\n            result.append(path)\n            return\n        elif target < 0:\n            return\n\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            backtrack(i, target - nums[i], path + [nums[i]])\n\n    nums.sort()\n    result = []\n    backtrack(0, target, [])\n    return result\n\ndef g():\n    nums = [2, 3, 6, 7]\n    target = 7\n    return nums, target\n\nassert f(*g()) == [[2, 2, 3], [7]]\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 488, "target_skills": [0, 0, 0, 1, 0, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target integer, find all unique combinations of numbers in the list that add up to the target.\n\n    Return a list of lists containing the combinations.\n\n    Example:\n    nums = [2, 3, 6, 7]\n    target = 7\n\n    Output:\n    [[2, 2, 3], [7]]\n\n    Explanation:\n    There are two unique combinations that add up to 7: [2, 2, 3] and [7].\n    \"\"\"\n    def backtrack(start, target, path):\n        if target == 0:\n            result.append(path)\n            return\n        elif target < 0:\n            return\n\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            backtrack(i, target - nums[i], path + [nums[i]])\n\n    nums.sort()\n    result = []\n    backtrack(0, target, [])\n    return result", "solution_func": "def g():\n    nums = [2, 3, 6, 7]\n    target = 7\n    return nums, target", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Use dynamic programming to calculate the maximum sum at each cell\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g():\n    # Creating a grid\n    grid = [\n        [1, 3, 2],\n        [2, 1, 4],\n        [3, 2, 1]\n    ]\n\n    return grid\n\nassert f(g()) == 10\n", "emb": null, "idx_generation": 488, "target_skills": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Use dynamic programming to calculate the maximum sum at each cell\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]", "solution_func": "def g():\n    # Creating a grid\n    grid = [\n        [1, 3, 2],\n        [2, 1, 4],\n        [3, 2, 1]\n    ]\n\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a subsequence of length 3 such that the sum of the three elements is 0.\n\n    Parameters:\n    nums (List[int]): The input list of integers.\n\n    Returns:\n    bool: True if there exists a subsequence of length 3 with sum 0, False otherwise.\n    \"\"\"\n    n = len(nums)\n    for i in range(n-2):\n        for j in range(i+1, n-1):\n            for k in range(j+1, n):\n                if nums[i] + nums[j] + nums[k] == 0:\n                    return True\n    return False\n\ndef g(nums=[-1, 2, 1, -4, 3]):\n    \"\"\"\n    Generate a list of integers.\n\n    Returns:\n    List[int]: A list of integers.\n    \"\"\"\n    return nums\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 489, "target_skills": [0, 0, 1, 1, 0, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a subsequence of length 3 such that the sum of the three elements is 0.\n\n    Parameters:\n    nums (List[int]): The input list of integers.\n\n    Returns:\n    bool: True if there exists a subsequence of length 3 with sum 0, False otherwise.\n    \"\"\"\n    n = len(nums)\n    for i in range(n-2):\n        for j in range(i+1, n-1):\n            for k in range(j+1, n):\n                if nums[i] + nums[j] + nums[k] == 0:\n                    return True\n    return False", "solution_func": "def g(nums=[-1, 2, 1, -4, 3]):\n    \"\"\"\n    Generate a list of integers.\n\n    Returns:\n    List[int]: A list of integers.\n    \"\"\"\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the elements in the original list except itself.\n\n    Parameters:\n    nums (List[int]): The input list of integers.\n\n    Returns:\n    List[int]: The new list where each element is the product of all the elements in the original list except itself.\n    \"\"\"\n    n = len(nums)\n    result = [1] * n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                result[i] *= nums[j]\n    return result\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    \"\"\"\n    Generate a list of integers.\n\n    Returns:\n    List[int]: A list of integers.\n    \"\"\"\n    return nums\n\nassert f(g()) == [120, 60, 40, 30, 24]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 489, "target_skills": [0, 1, 0, 0, 0, 1, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the elements in the original list except itself.\n\n    Parameters:\n    nums (List[int]): The input list of integers.\n\n    Returns:\n    List[int]: The new list where each element is the product of all the elements in the original list except itself.\n    \"\"\"\n    n = len(nums)\n    result = [1] * n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                result[i] *= nums[j]\n    return result", "solution_func": "def g(nums=[1, 2, 3, 4, 5]):\n    \"\"\"\n    Generate a list of integers.\n\n    Returns:\n    List[int]: A list of integers.\n    \"\"\"\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if they are isomorphic.\n\n    Two strings are isomorphic if the characters in s can be replaced to get t.\n\n    Parameters:\n    s (str): The first input string.\n    t (str): The second input string.\n\n    Returns:\n    bool: True if the strings are isomorphic, False otherwise.\n    \"\"\"\n    if len(s) != len(t):\n        return False\n\n    map_s = {}\n    map_t = {}\n\n    for i in range(len(s)):\n        if s[i] in map_s:\n            if map_s[s[i]] != t[i]:\n                return False\n        else:\n            map_s[s[i]] = t[i]\n\n        if t[i] in map_t:\n            if map_t[t[i]] != s[i]:\n                return False\n        else:\n            map_t[t[i]] = s[i]\n\n    return True\n\ndef g(s=\"egg\", t=\"add\"):\n    \"\"\"\n    Generate two strings.\n\n    Returns:\n    Tuple[str, str]: Two strings.\n    \"\"\"\n    return s, t\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 489, "target_skills": [1, 1, 0, 0, 1, 0, 0, 0, 1, 0], "problem_func": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if they are isomorphic.\n\n    Two strings are isomorphic if the characters in s can be replaced to get t.\n\n    Parameters:\n    s (str): The first input string.\n    t (str): The second input string.\n\n    Returns:\n    bool: True if the strings are isomorphic, False otherwise.\n    \"\"\"\n    if len(s) != len(t):\n        return False\n\n    map_s = {}\n    map_t = {}\n\n    for i in range(len(s)):\n        if s[i] in map_s:\n            if map_s[s[i]] != t[i]:\n                return False\n        else:\n            map_s[s[i]] = t[i]\n\n        if t[i] in map_t:\n            if map_t[t[i]] != s[i]:\n                return False\n        else:\n            map_t[t[i]] = s[i]\n\n    return True", "solution_func": "def g(s=\"egg\", t=\"add\"):\n    \"\"\"\n    Generate two strings.\n\n    Returns:\n    Tuple[str, str]: Two strings.\n    \"\"\"\n    return s, t", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import Tuple\n\ndef f(s: str, k: int) -> Tuple[str, int]:\n    \"\"\"\n    Given a string s and an integer k, find the kth character in the string by counting the number of times each character\n    appears in the string and considering their cumulative count.\n\n    Example:\n    Input:\n    s = \"abacabad\"\n    k = 7\n\n    Output:\n    (\"d\", 7)\n\n    Explanation:\n    The string \"abacabad\" consists of the characters a, b, c, and d.\n    The cumulative counts of each character are: a=3, b=2, c=1, d=1.\n    The kth character is \"d\" because it is the 7th character in the cumulative counts.\n    The output is a tuple containing the kth character and its cumulative count.\n    \"\"\"\n\n    counts = {}\n    cumulative_counts = []\n    cumulative_count = 0\n\n    for char in s:\n        counts[char] = counts.get(char, 0) + 1\n        cumulative_count += counts[char]\n        cumulative_counts.append(cumulative_count)\n\n    for i, count in enumerate(cumulative_counts):\n        if k <= count:\n            return (s[i], count)\n\n    return (\"\", -1)\n\ndef g() -> Tuple[str, int]:\n    \"\"\"\n    Generate a string and an integer.\n    \"\"\"\n    return (\"abacabad\", 7)\n\nassert f(*g()) == (\"d\", 7)\n\n", "emb": null, "idx_generation": 489, "target_skills": [1, 0, 1, 1, 1, 0, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import Tuple\n\ndef f(s: str, k: int) -> Tuple[str, int]:\n    \"\"\"\n    Given a string s and an integer k, find the kth character in the string by counting the number of times each character\n    appears in the string and considering their cumulative count.\n\n    Example:\n    Input:\n    s = \"abacabad\"\n    k = 7\n\n    Output:\n    (\"d\", 7)\n\n    Explanation:\n    The string \"abacabad\" consists of the characters a, b, c, and d.\n    The cumulative counts of each character are: a=3, b=2, c=1, d=1.\n    The kth character is \"d\" because it is the 7th character in the cumulative counts.\n    The output is a tuple containing the kth character and its cumulative count.\n    \"\"\"\n\n    counts = {}\n    cumulative_counts = []\n    cumulative_count = 0\n\n    for char in s:\n        counts[char] = counts.get(char, 0) + 1\n        cumulative_count += counts[char]\n        cumulative_counts.append(cumulative_count)\n\n    for i, count in enumerate(cumulative_counts):\n        if k <= count:\n            return (s[i], count)\n\n    return (\"\", -1)", "solution_func": "def g() -> Tuple[str, int]:\n    \"\"\"\n    Generate a string and an integer.\n    \"\"\"\n    return (\"abacabad\", 7)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import Union, List\n\ndef f(matrix: List[List[Union[int, str]]], target: int) -> int:\n    \"\"\"\n    Given a matrix of numbers and strings, find the total sum of the numbers in the matrix that are equal to the target value.\n\n    Example:\n    Input:\n    matrix = [\n        [1, 2, \"a\"],\n        [3, 4, \"b\"],\n        [5, 6, \"c\"]\n    ]\n    target = 4\n\n    Output:\n    7\n\n    Explanation:\n    The target value is 4.\n    The numbers in the matrix that are equal to 4 are: 1, 3.\n    The sum of these numbers is 1 + 3 = 4.\n    The output is the total sum of the numbers equal to the target value.\n    \"\"\"\n\n    total_sum = 0\n\n    for row in matrix:\n        for element in row:\n            if isinstance(element, int) and element == target:\n                total_sum += element\n\n    return total_sum\n\ndef g(matrix: List[List[Union[int, str]]] = [[1, 2, \"a\"], [3, 4, \"b\"], [5, 6, \"c\"]], target: int = 4):\n    return (matrix, target)\n\nassert f(*g()) == 7\n\n", "emb": null, "idx_generation": 489, "target_skills": [1, 0, 0, 1, 0, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import Union, List\n\ndef f(matrix: List[List[Union[int, str]]], target: int) -> int:\n    \"\"\"\n    Given a matrix of numbers and strings, find the total sum of the numbers in the matrix that are equal to the target value.\n\n    Example:\n    Input:\n    matrix = [\n        [1, 2, \"a\"],\n        [3, 4, \"b\"],\n        [5, 6, \"c\"]\n    ]\n    target = 4\n\n    Output:\n    7\n\n    Explanation:\n    The target value is 4.\n    The numbers in the matrix that are equal to 4 are: 1, 3.\n    The sum of these numbers is 1 + 3 = 4.\n    The output is the total sum of the numbers equal to the target value.\n    \"\"\"\n\n    total_sum = 0\n\n    for row in matrix:\n        for element in row:\n            if isinstance(element, int) and element == target:\n                total_sum += element\n\n    return total_sum", "solution_func": "def g(matrix: List[List[Union[int, str]]] = [[1, 2, \"a\"], [3, 4, \"b\"], [5, 6, \"c\"]], target: int = 4):\n    return (matrix, target)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import Dict, List\n\ndef f(words: List[str]) -> Dict[str, int]:\n    \"\"\"\n    Given a list of words, count the number of occurrences of each word in the list and return a dictionary with the word as the key and its count as the value.\n\n    Example:\n    Input:\n    words = [\"apple\", \"banana\", \"apple\", \"cherry\", \"banana\"]\n\n    Output:\n    {\"apple\": 2, \"banana\": 2, \"cherry\": 1}\n\n    Explanation:\n    The list of words contains the words \"apple\", \"banana\", and \"cherry\".\n    The word \"apple\" appears twice, the word \"banana\" appears twice, and the word \"cherry\" appears once.\n    The output is a dictionary with the word as the key and its count as the value.\n    \"\"\"\n\n    word_count = {}\n\n    for word in words:\n        word_count[word] = word_count.get(word, 0) + 1\n\n    return word_count\n\ndef g(words: List[str] = [\"apple\", \"banana\", \"apple\", \"cherry\", \"banana\"]):\n    return (words,)\n\nassert f(*g()) == {\"apple\": 2, \"banana\": 2, \"cherry\": 1}\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 489, "target_skills": [1, 0, 0, 1, 0, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import Dict, List\n\ndef f(words: List[str]) -> Dict[str, int]:\n    \"\"\"\n    Given a list of words, count the number of occurrences of each word in the list and return a dictionary with the word as the key and its count as the value.\n\n    Example:\n    Input:\n    words = [\"apple\", \"banana\", \"apple\", \"cherry\", \"banana\"]\n\n    Output:\n    {\"apple\": 2, \"banana\": 2, \"cherry\": 1}\n\n    Explanation:\n    The list of words contains the words \"apple\", \"banana\", and \"cherry\".\n    The word \"apple\" appears twice, the word \"banana\" appears twice, and the word \"cherry\" appears once.\n    The output is a dictionary with the word as the key and its count as the value.\n    \"\"\"\n\n    word_count = {}\n\n    for word in words:\n        word_count[word] = word_count.get(word, 0) + 1\n\n    return word_count", "solution_func": "def g(words: List[str] = [\"apple\", \"banana\", \"apple\", \"cherry\", \"banana\"]):\n    return (words,)", "map_ix": [0, 1, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    nums = [2, 7, 11, 15], target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1 in the list add up to the target value of 9.\n\n    Hint: Use a dictionary to store the complement of each number as you iterate through the list. If the complement is found in the dictionary, return the indices of the current number and its complement.\n    \"\"\"\n\n    complement_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complement_dict:\n            return [complement_dict[complement], i]\n        complement_dict[num] = i\n\n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0], "idx_generation": 489, "target_skills": [0, 0, 1, 0, 1, 1, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    nums = [2, 7, 11, 15], target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1 in the list add up to the target value of 9.\n\n    Hint: Use a dictionary to store the complement of each number as you iterate through the list. If the complement is found in the dictionary, return the indices of the current number and its complement.\n    \"\"\"\n\n    complement_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complement_dict:\n            return [complement_dict[complement], i]\n        complement_dict[num] = i\n\n    return []", "solution_func": "def g(nums=[2, 7, 11, 15], target=9):\n    return nums, target", "map_ix": [1, 1, 0, 0, 0, 1, 0, 1, 1, 1]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums, return all possible subsets of the list.\n\n    Example:\n    nums = [1, 2, 3]\n\n    Output:\n    [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n\n    Hint: Use the counting and combinatorics skill to generate all possible subsets. Iterate through all possible combinations of indices and append the corresponding elements to the result list.\n    \"\"\"\n\n    n = len(nums)\n    subsets = []\n    for i in range(2 ** n):\n        subset = []\n        for j in range(n):\n            if (i >> j) & 1:\n                subset.append(nums[j])\n        subsets.append(subset)\n\n    return subsets\n\ndef g(nums=[1, 2, 3]):\n    return nums\n\nassert f(g()) == [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n\n", "emb": null, "idx_generation": 489, "target_skills": [1, 1, 0, 0, 1, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums, return all possible subsets of the list.\n\n    Example:\n    nums = [1, 2, 3]\n\n    Output:\n    [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n\n    Hint: Use the counting and combinatorics skill to generate all possible subsets. Iterate through all possible combinations of indices and append the corresponding elements to the result list.\n    \"\"\"\n\n    n = len(nums)\n    subsets = []\n    for i in range(2 ** n):\n        subset = []\n        for j in range(n):\n            if (i >> j) & 1:\n                subset.append(nums[j])\n        subsets.append(subset)\n\n    return subsets", "solution_func": "def g(nums=[1, 2, 3]):\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value between any two numbers in the list.\n    Return the maximum XOR value.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value is obtained by XORing 5 and 25, which gives 28.\n\n    Hint: Use the bit manipulation skill to find the maximum XOR value. Iterate through all possible prefixes of the numbers and check if there is a pair of numbers that XOR to a higher value.\n    \"\"\"\n\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = set()\n        for num in nums:\n            prefixes.add(num & mask)\n        max_possible_xor = max_xor | (1 << i)\n        for prefix in prefixes:\n            if prefix ^ max_possible_xor in prefixes:\n                max_xor = max_possible_xor\n                break\n\n    return max_xor\n\ndef g(nums=[3, 10, 5, 25, 2, 8]):\n    return nums\n\nassert f(g()) == 28\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 489, "target_skills": [0, 1, 1, 0, 1, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value between any two numbers in the list.\n    Return the maximum XOR value.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value is obtained by XORing 5 and 25, which gives 28.\n\n    Hint: Use the bit manipulation skill to find the maximum XOR value. Iterate through all possible prefixes of the numbers and check if there is a pair of numbers that XOR to a higher value.\n    \"\"\"\n\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = set()\n        for num in nums:\n            prefixes.add(num & mask)\n        max_possible_xor = max_xor | (1 << i)\n        for prefix in prefixes:\n            if prefix ^ max_possible_xor in prefixes:\n                max_xor = max_possible_xor\n                break\n\n    return max_xor", "solution_func": "def g(nums=[3, 10, 5, 25, 2, 8]):\n    return nums", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(adj_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix of a graph, determine whether the graph is a tree or not.\n    Return True if the graph is a tree, False otherwise.\n    \"\"\"\n\n    def dfs(node, visited, parent):\n        visited[node] = True\n        for neighbor in range(len(adj_matrix)):\n            if adj_matrix[node][neighbor] == 1:\n                if visited[neighbor] == False:\n                    if dfs(neighbor, visited, node) == True:\n                        return True\n                elif parent != neighbor:\n                    return True\n        return False\n\n    n = len(adj_matrix)\n    visited = [False] * n\n\n    if dfs(0, visited, -1) == True:\n        return False\n\n    for i in range(n):\n        if visited[i] == False:\n            return False\n\n    return True\n\ndef g(adj_matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Return the adjacency matrix of a graph to determine whether it is a tree or not.\n    \"\"\"\n    return adj_matrix\n\nassert f(*g([[0, 1, 0, 0, 0],\n             [1, 0, 1, 0, 0],\n             [0, 1, 0, 1, 1],\n             [0, 0, 1, 0, 0],\n             [0, 0, 1, 0, 0]])) == False\n", "emb": null, "idx_generation": 489, "target_skills": [1, 1, 0, 1, 1, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(adj_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix of a graph, determine whether the graph is a tree or not.\n    Return True if the graph is a tree, False otherwise.\n    \"\"\"\n\n    def dfs(node, visited, parent):\n        visited[node] = True\n        for neighbor in range(len(adj_matrix)):\n            if adj_matrix[node][neighbor] == 1:\n                if visited[neighbor] == False:\n                    if dfs(neighbor, visited, node) == True:\n                        return True\n                elif parent != neighbor:\n                    return True\n        return False\n\n    n = len(adj_matrix)\n    visited = [False] * n\n\n    if dfs(0, visited, -1) == True:\n        return False\n\n    for i in range(n):\n        if visited[i] == False:\n            return False\n\n    return True", "solution_func": "def g(adj_matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Return the adjacency matrix of a graph to determine whether it is a tree or not.\n    \"\"\"\n    return adj_matrix", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in non-decreasing order.\n\n    Example:\n    nums = [5, 2, 8, 1, 9]\n\n    Output:\n    [1, 2, 5, 8, 9]\n\n    Hint: Use any sorting algorithm such as bubble sort, insertion sort, or merge sort.\n    \"\"\"\n\n    # Bubble sort implementation\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n\n    return nums\n\ndef g(nums: List[int] = [5, 2, 8, 1, 9]):\n    \"\"\"\n    Generate a list of integers to be sorted.\n    \"\"\"\n    return nums\n\nassert f(g()) == [1, 2, 5, 8, 9]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 490, "target_skills": [1, 0, 0, 0, 1, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in non-decreasing order.\n\n    Example:\n    nums = [5, 2, 8, 1, 9]\n\n    Output:\n    [1, 2, 5, 8, 9]\n\n    Hint: Use any sorting algorithm such as bubble sort, insertion sort, or merge sort.\n    \"\"\"\n\n    # Bubble sort implementation\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n\n    return nums", "solution_func": "def g(nums: List[int] = [5, 2, 8, 1, 9]):\n    \"\"\"\n    Generate a list of integers to be sorted.\n    \"\"\"\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two elements in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n    k = 5\n\n    Output:\n    29\n\n    Explanation:\n    The maximum XOR value of any two elements in the list is 29, which is obtained by XORing 5 and 25.\n\n    Hint: Use a brute-force approach to check all possible pairs of elements and find the maximum XOR value.\n    \"\"\"\n\n    max_xor = 0\n    n = len(nums)\n\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_value = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor_value)\n\n    return max_xor\n\ndef g(nums: List[int] = [3, 10, 5, 25, 2, 8], k: int = 5):\n    \"\"\"\n    Generate a list of integers and a target value for finding the maximum XOR.\n    \"\"\"\n    return nums, k\n\nassert f(*g()) == 29\n", "emb": null, "idx_generation": 490, "target_skills": [0, 1, 1, 0, 1, 1, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two elements in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n    k = 5\n\n    Output:\n    29\n\n    Explanation:\n    The maximum XOR value of any two elements in the list is 29, which is obtained by XORing 5 and 25.\n\n    Hint: Use a brute-force approach to check all possible pairs of elements and find the maximum XOR value.\n    \"\"\"\n\n    max_xor = 0\n    n = len(nums)\n\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_value = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor_value)\n\n    return max_xor", "solution_func": "def g(nums: List[int] = [3, 10, 5, 25, 2, 8], k: int = 5):\n    \"\"\"\n    Generate a list of integers and a target value for finding the maximum XOR.\n    \"\"\"\n    return nums, k", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Given two strings, check if they are anagrams of each other.\n\n    Example:\n    s1 = \"listen\"\n    s2 = \"silent\"\n\n    Output:\n    True\n\n    Explanation:\n    The strings \"listen\" and \"silent\" are anagrams of each other.\n\n    Hint: An anagram is a word or phrase formed by rearranging the letters of another word or phrase.\n    \"\"\"\n\n    # Convert the strings to lowercase and remove whitespace\n    s1 = s1.lower().replace(\" \", \"\")\n    s2 = s2.lower().replace(\" \", \"\")\n\n    # Check if the sorted characters of the first string are equal to the sorted characters of the second string\n    return sorted(s1) == sorted(s2)\n\ndef g(s1: str = \"listen\", s2: str = \"silent\"):\n    \"\"\"\n    Generate two strings to check if they are anagrams of each other.\n    \"\"\"\n    return s1, s2\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 490, "target_skills": [0, 0, 1, 0, 1, 0, 0, 1, 1, 1], "problem_func": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Given two strings, check if they are anagrams of each other.\n\n    Example:\n    s1 = \"listen\"\n    s2 = \"silent\"\n\n    Output:\n    True\n\n    Explanation:\n    The strings \"listen\" and \"silent\" are anagrams of each other.\n\n    Hint: An anagram is a word or phrase formed by rearranging the letters of another word or phrase.\n    \"\"\"\n\n    # Convert the strings to lowercase and remove whitespace\n    s1 = s1.lower().replace(\" \", \"\")\n    s2 = s2.lower().replace(\" \", \"\")\n\n    # Check if the sorted characters of the first string are equal to the sorted characters of the second string\n    return sorted(s1) == sorted(s2)", "solution_func": "def g(s1: str = \"listen\", s2: str = \"silent\"):\n    \"\"\"\n    Generate two strings to check if they are anagrams of each other.\n    \"\"\"\n    return s1, s2", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the number of paths from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    matrix = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The possible paths are: \n    1 -> 3 -> 1 -> 1 -> 2 -> 1\n    1 -> 3 -> 1 -> 5 -> 2 -> 1\n    1 -> 1 -> 5 -> 2 -> 1\n    1 -> 1 -> 2 -> 5 -> 1\n    1 -> 1 -> 2 -> 1 -> 1 -> 1\n    1 -> 1 -> 2 -> 1 -> 2 -> 1\n    1 -> 1 -> 1 -> 2 -> 5 -> 1\n\n    Hint: Use dynamic programming to calculate the number of paths.\n    \"\"\"\n\n    m = len(matrix)\n    n = len(matrix[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1\n\n    for i in range(m):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n\n    return dp[m-1][n-1]\n\ndef g():\n    matrix = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return [matrix]\n\nassert f(*g()) == 7\n", "emb": null, "idx_generation": 490, "target_skills": [0, 1, 1, 0, 1, 0, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the number of paths from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    matrix = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The possible paths are: \n    1 -> 3 -> 1 -> 1 -> 2 -> 1\n    1 -> 3 -> 1 -> 5 -> 2 -> 1\n    1 -> 1 -> 5 -> 2 -> 1\n    1 -> 1 -> 2 -> 5 -> 1\n    1 -> 1 -> 2 -> 1 -> 1 -> 1\n    1 -> 1 -> 2 -> 1 -> 2 -> 1\n    1 -> 1 -> 1 -> 2 -> 5 -> 1\n\n    Hint: Use dynamic programming to calculate the number of paths.\n    \"\"\"\n\n    m = len(matrix)\n    n = len(matrix[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1\n\n    for i in range(m):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n\n    return dp[m-1][n-1]", "solution_func": "def g():\n    matrix = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return [matrix]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[str]]) -> bool:\n    \"\"\"\n    Given a 2D grid of characters and a word, determine if the word exists in the grid.\n    The word can be constructed from adjacent letters (horizontally or vertically) in the grid.\n\n    Example:\n    grid = [\n        ['A', 'B', 'C', 'E'],\n        ['S', 'F', 'C', 'S'],\n        ['A', 'D', 'E', 'E']\n    ]\n\n    word = \"ABCCED\"\n\n    Output:\n    True\n\n    Hint: Use backtracking to search for the word in the grid.\n    \"\"\"\n\n    def backtrack(i, j, word_idx):\n        if word_idx == len(word):\n            return True\n\n        if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != word[word_idx]:\n            return False\n\n        temp = grid[i][j]\n        grid[i][j] = '#'\n\n        if backtrack(i+1, j, word_idx+1) or backtrack(i-1, j, word_idx+1) or backtrack(i, j+1, word_idx+1) or backtrack(i, j-1, word_idx+1):\n            return True\n\n        grid[i][j] = temp\n\n        return False\n\n    m = len(grid)\n    n = len(grid[0])\n    word = \"ABCCED\"\n\n    for i in range(m):\n        for j in range(n):\n            if backtrack(i, j, 0):\n                return True\n\n    return False\n\ndef g():\n    grid = [\n        ['A', 'B', 'C', 'E'],\n        ['S', 'F', 'C', 'S'],\n        ['A', 'D', 'E', 'E']\n    ]\n    return [grid]\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 490, "target_skills": [1, 1, 1, 1, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[str]]) -> bool:\n    \"\"\"\n    Given a 2D grid of characters and a word, determine if the word exists in the grid.\n    The word can be constructed from adjacent letters (horizontally or vertically) in the grid.\n\n    Example:\n    grid = [\n        ['A', 'B', 'C', 'E'],\n        ['S', 'F', 'C', 'S'],\n        ['A', 'D', 'E', 'E']\n    ]\n\n    word = \"ABCCED\"\n\n    Output:\n    True\n\n    Hint: Use backtracking to search for the word in the grid.\n    \"\"\"\n\n    def backtrack(i, j, word_idx):\n        if word_idx == len(word):\n            return True\n\n        if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != word[word_idx]:\n            return False\n\n        temp = grid[i][j]\n        grid[i][j] = '#'\n\n        if backtrack(i+1, j, word_idx+1) or backtrack(i-1, j, word_idx+1) or backtrack(i, j+1, word_idx+1) or backtrack(i, j-1, word_idx+1):\n            return True\n\n        grid[i][j] = temp\n\n        return False\n\n    m = len(grid)\n    n = len(grid[0])\n    word = \"ABCCED\"\n\n    for i in range(m):\n        for j in range(n):\n            if backtrack(i, j, 0):\n                return True\n\n    return False", "solution_func": "def g():\n    grid = [\n        ['A', 'B', 'C', 'E'],\n        ['S', 'F', 'C', 'S'],\n        ['A', 'D', 'E', 'E']\n    ]\n    return [grid]", "map_ix": [0, 0, 0, 0, 0, 1, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the length of the shortest path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The shortest path is: \n    1 -> 3 -> 1 -> 1 -> 2 -> 1 -> 1\n\n    Hint: Use dynamic programming to calculate the shortest path length.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(m):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j])\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j])\n\n    return dp[m-1][n-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return [grid]\n\nassert f(*g()) == 7\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 490, "target_skills": [0, 1, 1, 0, 0, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the length of the shortest path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The shortest path is: \n    1 -> 3 -> 1 -> 1 -> 2 -> 1 -> 1\n\n    Hint: Use dynamic programming to calculate the shortest path length.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(m):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j])\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j])\n\n    return dp[m-1][n-1]", "solution_func": "def g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return [grid]", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find the maximum subarray sum.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The maximum subarray sum.\n    \"\"\"\n\n    if not nums:\n        return []\n    \n    curr_sum = max_sum = nums[0]\n    start = end = 0\n\n    for i in range(1, len(nums)):\n        if nums[i] > curr_sum + nums[i]:\n            curr_sum = nums[i]\n            start = i\n        else:\n            curr_sum += nums[i]\n        \n        if curr_sum > max_sum:\n            max_sum = curr_sum\n            end = i\n    \n    return nums[start:end+1]\n\ndef g(nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\n\nassert f(g()) == [4, -1, 2, 1]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 490, "target_skills": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find the maximum subarray sum.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The maximum subarray sum.\n    \"\"\"\n\n    if not nums:\n        return []\n    \n    curr_sum = max_sum = nums[0]\n    start = end = 0\n\n    for i in range(1, len(nums)):\n        if nums[i] > curr_sum + nums[i]:\n            curr_sum = nums[i]\n            start = i\n        else:\n            curr_sum += nums[i]\n        \n        if curr_sum > max_sum:\n            max_sum = curr_sum\n            end = i\n    \n    return nums[start:end+1]", "solution_func": "def g(nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an n x n matrix, rotate the matrix by 90 degrees clockwise in-place.\n\n    Args:\n    - matrix: A 2D list of integers.\n\n    Returns:\n    - The rotated matrix.\n    \"\"\"\n\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n    \n    return matrix\n\ndef g(matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n", "emb": null, "idx_generation": 490, "target_skills": [0, 1, 1, 0, 0, 0, 0, 0, 1, 1], "problem_func": "from typing import*\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an n x n matrix, rotate the matrix by 90 degrees clockwise in-place.\n\n    Args:\n    - matrix: A 2D list of integers.\n\n    Returns:\n    - The rotated matrix.\n    \"\"\"\n\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n    \n    return matrix", "solution_func": "def g(matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums sorted in ascending order,\n    find two numbers such that they add up to a specific target number.\n\n    Args:\n    - nums: A list of integers.\n    - target: The target sum.\n\n    Returns:\n    - The indices of the two numbers such that they add up to the target.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g(nums = [2, 7, 11, 15], target = 9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 490, "target_skills": [1, 1, 1, 0, 1, 1, 0, 0, 1, 1], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums sorted in ascending order,\n    find two numbers such that they add up to a specific target number.\n\n    Args:\n    - nums: A list of integers.\n    - target: The target sum.\n\n    Returns:\n    - The indices of the two numbers such that they add up to the target.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []", "solution_func": "def g(nums = [2, 7, 11, 15], target = 9):\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target integer, find the number of combinations of elements in nums that add up to the target.\n    Each element in nums can only be used once in a combination.\n\n    Args:\n    - nums: List of integers\n    - target: Target integer\n\n    Returns:\n    - Number of combinations that add up to the target\n    \"\"\"\n    def backtrack(nums, target, index, curr_sum):\n        if curr_sum == target:\n            return 1\n        if curr_sum > target or index >= len(nums):\n            return 0\n\n        count = 0\n        for i in range(index, len(nums)):\n            count += backtrack(nums, target, i + 1, curr_sum + nums[i])\n\n        return count\n\n    return backtrack(nums, target, 0, 0)\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 8\n    return nums, target\n\nassert f(*g()) == 2\n", "emb": null, "idx_generation": 490, "target_skills": [0, 0, 1, 0, 1, 1, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target integer, find the number of combinations of elements in nums that add up to the target.\n    Each element in nums can only be used once in a combination.\n\n    Args:\n    - nums: List of integers\n    - target: Target integer\n\n    Returns:\n    - Number of combinations that add up to the target\n    \"\"\"\n    def backtrack(nums, target, index, curr_sum):\n        if curr_sum == target:\n            return 1\n        if curr_sum > target or index >= len(nums):\n            return 0\n\n        count = 0\n        for i in range(index, len(nums)):\n            count += backtrack(nums, target, i + 1, curr_sum + nums[i])\n\n        return count\n\n    return backtrack(nums, target, 0, 0)", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    target = 8\n    return nums, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\nclass Graph:\n    def __init__(self, num_vertices: int):\n        self.num_vertices = num_vertices\n        self.adj_list = [[] for _ in range(num_vertices)]\n    \n    def add_edge(self, u: int, v: int):\n        self.adj_list[u].append(v)\n    \n    def is_cyclic_util(self, v: int, visited: List[bool], stack: List[bool]) -> bool:\n        visited[v] = True\n        stack[v] = True\n        \n        for neighbor in self.adj_list[v]:\n            if not visited[neighbor]:\n                if self.is_cyclic_util(neighbor, visited, stack):\n                    return True\n            elif stack[neighbor]:\n                return True\n        \n        stack[v] = False\n        return False\n    \n    def is_cyclic(self) -> bool:\n        visited = [False] * self.num_vertices\n        stack = [False] * self.num_vertices\n        \n        for v in range(self.num_vertices):\n            if not visited[v]:\n                if self.is_cyclic_util(v, visited, stack):\n                    return True\n        \n        return False\n\ndef f(edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given a list of directed edges, check if the graph contains a cycle.\n    \"\"\"\n    num_vertices = max(max(edge) for edge in edges) + 1\n    graph = Graph(num_vertices)\n    \n    for edge in edges:\n        u, v = edge\n        graph.add_edge(u, v)\n    \n    return graph.is_cyclic()\n\ndef g():\n    edges = [[0, 1], [1, 2], [2, 0]]\n    return edges\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 491, "target_skills": [1, 0, 1, 1, 0, 1, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\nclass Graph:\n    def __init__(self, num_vertices: int):\n        self.num_vertices = num_vertices\n        self.adj_list = [[] for _ in range(num_vertices)]\n    \n    def add_edge(self, u: int, v: int):\n        self.adj_list[u].append(v)\n    \n    def is_cyclic_util(self, v: int, visited: List[bool], stack: List[bool]) -> bool:\n        visited[v] = True\n        stack[v] = True\n        \n        for neighbor in self.adj_list[v]:\n            if not visited[neighbor]:\n                if self.is_cyclic_util(neighbor, visited, stack):\n                    return True\n            elif stack[neighbor]:\n                return True\n        \n        stack[v] = False\n        return False\n    \n    def is_cyclic(self) -> bool:\n        visited = [False] * self.num_vertices\n        stack = [False] * self.num_vertices\n        \n        for v in range(self.num_vertices):\n            if not visited[v]:\n                if self.is_cyclic_util(v, visited, stack):\n                    return True\n        \n        return False\n\ndef f(edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given a list of directed edges, check if the graph contains a cycle.\n    \"\"\"\n    num_vertices = max(max(edge) for edge in edges) + 1\n    graph = Graph(num_vertices)\n    \n    for edge in edges:\n        u, v = edge\n        graph.add_edge(u, v)\n    \n    return graph.is_cyclic()", "solution_func": "def g():\n    edges = [[0, 1], [1, 2], [2, 0]]\n    return edges", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nimport re\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, check if it is a valid email address.\n    \"\"\"\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return bool(re.match(pattern, s))\n\ndef g():\n    return \"john.doe@example.com\"\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 491, "target_skills": [1, 1, 0, 0, 0, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import *\nimport re\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, check if it is a valid email address.\n    \"\"\"\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return bool(re.match(pattern, s))", "solution_func": "def g():\n    return \"john.doe@example.com\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import *\nimport heapq\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the kth smallest element in the matrix.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n    heap = []\n    \n    for i in range(m):\n        for j in range(n):\n            heapq.heappush(heap, matrix[i][j])\n    \n    for _ in range(k):\n        result = heapq.heappop(heap)\n    \n    return result\n\ndef g():\n    matrix = [\n        [1, 5, 9],\n        [10, 11, 13],\n        [12, 13, 15]\n    ]\n    k = 8\n    return matrix, k\n\nassert f(*g()) == 13\n\n", "emb": null, "idx_generation": 491, "target_skills": [0, 1, 0, 1, 1, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import *\nimport heapq\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the kth smallest element in the matrix.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n    heap = []\n    \n    for i in range(m):\n        for j in range(n):\n            heapq.heappush(heap, matrix[i][j])\n    \n    for _ in range(k):\n        result = heapq.heappop(heap)\n    \n    return result", "solution_func": "def g():\n    matrix = [\n        [1, 5, 9],\n        [10, 11, 13],\n        [12, 13, 15]\n    ]\n    k = 8\n    return matrix, k", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, sort the words based on the number of vowels in each word in descending order.\n\n    Example:\n    words = [\"apple\", \"banana\", \"cherry\", \"date\"]\n\n    Output:\n    [\"banana\", \"apple\", \"cherry\", \"date\"]\n    Explanation: The words are sorted based on the number of vowels in each word in descending order. \"banana\" has 3 vowels, \"apple\" has 2 vowels, \"cherry\" has 2 vowels, and \"date\" has 2 vowels.\n\n    \"\"\"\n\n    def count_vowels(word):\n        vowels = ['a', 'e', 'i', 'o', 'u']\n        count = 0\n\n        for char in word:\n            if char.lower() in vowels:\n                count += 1\n\n        return count\n\n    sorted_words = sorted(words, key=count_vowels, reverse=True)\n\n    return sorted_words\n\ndef g():\n    \"\"\"\n    Generate a list of words.\n    \"\"\"\n    return [\"apple\", \"banana\", \"cherry\", \"date\"]\n\nassert f(*g()) == [\"banana\", \"apple\", \"cherry\", \"date\"]\n\n", "emb": null, "idx_generation": 491, "target_skills": [0, 1, 1, 0, 0, 1, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, sort the words based on the number of vowels in each word in descending order.\n\n    Example:\n    words = [\"apple\", \"banana\", \"cherry\", \"date\"]\n\n    Output:\n    [\"banana\", \"apple\", \"cherry\", \"date\"]\n    Explanation: The words are sorted based on the number of vowels in each word in descending order. \"banana\" has 3 vowels, \"apple\" has 2 vowels, \"cherry\" has 2 vowels, and \"date\" has 2 vowels.\n\n    \"\"\"\n\n    def count_vowels(word):\n        vowels = ['a', 'e', 'i', 'o', 'u']\n        count = 0\n\n        for char in word:\n            if char.lower() in vowels:\n                count += 1\n\n        return count\n\n    sorted_words = sorted(words, key=count_vowels, reverse=True)\n\n    return sorted_words", "solution_func": "def g():\n    \"\"\"\n    Generate a list of words.\n    \"\"\"\n    return [\"apple\", \"banana\", \"cherry\", \"date\"]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in descending order, but keep the negative numbers at the front of the list.\n\n    Example:\n    nums = [-3, 5, -2, 0, 4]\n\n    Output:\n    [-3, -2, 5, 4, 0]\n    Explanation: The negative numbers (-3 and -2) are at the front of the list, followed by the positive numbers in descending order.\n\n    \"\"\"\n\n    negative_nums = [num for num in nums if num < 0]\n    positive_nums = [num for num in nums if num >= 0]\n\n    sorted_nums = sorted(positive_nums, reverse=True)\n\n    return negative_nums + sorted_nums\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [-3, 5, -2, 0, 4]\n\nassert f(*g()) == [-3, -2, 5, 4, 0]\n\n", "emb": null, "idx_generation": 491, "target_skills": [1, 1, 0, 0, 1, 0, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in descending order, but keep the negative numbers at the front of the list.\n\n    Example:\n    nums = [-3, 5, -2, 0, 4]\n\n    Output:\n    [-3, -2, 5, 4, 0]\n    Explanation: The negative numbers (-3 and -2) are at the front of the list, followed by the positive numbers in descending order.\n\n    \"\"\"\n\n    negative_nums = [num for num in nums if num < 0]\n    positive_nums = [num for num in nums if num >= 0]\n\n    sorted_nums = sorted(positive_nums, reverse=True)\n\n    return negative_nums + sorted_nums", "solution_func": "def g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [-3, 5, -2, 0, 4]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str]) -> str:\n    \"\"\"\n    Given a list of strings, concatenate all the strings together in reverse order, separating each string by a space.\n\n    Example:\n    strings = [\"Hello\", \"World\", \"Python\"]\n\n    Output:\n    \"Python World Hello\"\n    Explanation: The strings are concatenated in reverse order, separated by a space.\n\n    \"\"\"\n\n    reversed_strings = strings[::-1]\n    concatenated_string = \" \".join(reversed_strings)\n\n    return concatenated_string\n\ndef g():\n    \"\"\"\n    Generate a list of strings.\n    \"\"\"\n    return [\"Hello\", \"World\", \"Python\"]\n\nassert f(*g()) == \"Python World Hello\"\n\n", "emb": null, "idx_generation": 491, "target_skills": [0, 1, 1, 0, 0, 0, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str]) -> str:\n    \"\"\"\n    Given a list of strings, concatenate all the strings together in reverse order, separating each string by a space.\n\n    Example:\n    strings = [\"Hello\", \"World\", \"Python\"]\n\n    Output:\n    \"Python World Hello\"\n    Explanation: The strings are concatenated in reverse order, separated by a space.\n\n    \"\"\"\n\n    reversed_strings = strings[::-1]\n    concatenated_string = \" \".join(reversed_strings)\n\n    return concatenated_string", "solution_func": "def g():\n    \"\"\"\n    Generate a list of strings.\n    \"\"\"\n    return [\"Hello\", \"World\", \"Python\"]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of positive integers, find the number of subsets whose sum is divisible by 3.\n\n    Example:\n    nums = [3, 6, 9, 12, 15]\n    Output: 6\n    Explanation: The subsets with sum divisible by 3 are [3], [6, 9], [3, 6, 9], [3, 12], [6, 9, 12], [3, 6, 9, 12, 15]\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(1, 2 ** n):\n        subset_sum = 0\n        for j in range(n):\n            if i & (1 << j):\n                subset_sum += nums[j]\n        if subset_sum % 3 == 0:\n            count += 1\n    return count\n\ndef g(nums: List[int] = [3, 6, 9, 12, 15]):\n    return nums\n\nassert f(*g()) == 6\n", "emb": null, "idx_generation": 491, "target_skills": [1, 1, 1, 0, 1, 1, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of positive integers, find the number of subsets whose sum is divisible by 3.\n\n    Example:\n    nums = [3, 6, 9, 12, 15]\n    Output: 6\n    Explanation: The subsets with sum divisible by 3 are [3], [6, 9], [3, 6, 9], [3, 12], [6, 9, 12], [3, 6, 9, 12, 15]\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(1, 2 ** n):\n        subset_sum = 0\n        for j in range(n):\n            if i & (1 << j):\n                subset_sum += nums[j]\n        if subset_sum % 3 == 0:\n            count += 1\n    return count", "solution_func": "def g(nums: List[int] = [3, 6, 9, 12, 15]):\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all positive integers less than or equal to n that are divisible by 3 or 5.\n\n    Example:\n    n = 10\n    Output: 33\n    Explanation: The positive integers less than or equal to 10 that are divisible by 3 or 5 are 3, 5, 6, and 9. Their sum is 33.\n    \"\"\"\n    sum = 0\n    for i in range(1, n + 1):\n        if i % 3 == 0 or i % 5 == 0:\n            sum += i\n    return sum\n\ndef g(n: int = 10):\n    return n\n\nassert f(g()) == 33\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 491, "target_skills": [1, 1, 1, 1, 1, 0, 1, 1, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all positive integers less than or equal to n that are divisible by 3 or 5.\n\n    Example:\n    n = 10\n    Output: 33\n    Explanation: The positive integers less than or equal to 10 that are divisible by 3 or 5 are 3, 5, 6, and 9. Their sum is 33.\n    \"\"\"\n    sum = 0\n    for i in range(1, n + 1):\n        if i % 3 == 0 or i % 5 == 0:\n            sum += i\n    return sum", "solution_func": "def g(n: int = 10):\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of the first n Fibonacci numbers.\n\n    Example:\n    n = 6\n    Output: 20\n    Explanation: The first 6 Fibonacci numbers are 0, 1, 1, 2, 3, and 5. Their sum is 20.\n    \"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 0\n    \n    fib_sum = 0\n    fib_n_minus_2 = 0\n    fib_n_minus_1 = 1\n    for i in range(2, n + 1):\n        fib_sum += fib_n_minus_1\n        fib_n_minus_2, fib_n_minus_1 = fib_n_minus_1, fib_n_minus_2 + fib_n_minus_1\n    return fib_sum\n\ndef g(n: int = 6):\n    return n\n\nassert f(g()) == 20\n", "emb": null, "idx_generation": 491, "target_skills": [0, 1, 1, 0, 1, 0, 1, 1, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of the first n Fibonacci numbers.\n\n    Example:\n    n = 6\n    Output: 20\n    Explanation: The first 6 Fibonacci numbers are 0, 1, 1, 2, 3, and 5. Their sum is 20.\n    \"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 0\n    \n    fib_sum = 0\n    fib_n_minus_2 = 0\n    fib_n_minus_1 = 1\n    for i in range(2, n + 1):\n        fib_sum += fib_n_minus_1\n        fib_n_minus_2, fib_n_minus_1 = fib_n_minus_1, fib_n_minus_2 + fib_n_minus_1\n    return fib_sum", "solution_func": "def g(n: int = 6):\n    return n", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of permutations that satisfy a specific condition.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n\n    Output: 6\n\n    Explanation:\n    The number of permutations that satisfy the condition is 6.\n    \"\"\"\n\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] + nums[j] == 6:\n                count += 1\n\n    return count\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 6\n\n", "emb": null, "idx_generation": 491, "target_skills": [0, 1, 1, 0, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of permutations that satisfy a specific condition.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n\n    Output: 6\n\n    Explanation:\n    The number of permutations that satisfy the condition is 6.\n    \"\"\"\n\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] + nums[j] == 6:\n                count += 1\n\n    return count", "solution_func": "def g():\n    return [1, 2, 3, 4, 5]", "map_ix": null}, {"fitness": 1.0, "program_str": "import math\nfrom typing import*\nfrom typing import List\n\ndef f(expression: str) -> bool:\n    \"\"\"\n    Given a mathematical expression as a string, determine if the parentheses in the expression are balanced.\n    Return True if the parentheses are balanced, False otherwise.\n\n    Example:\n    expression = \"(3 + 5) * (4 - 2)\"\n    Output: True\n\n    expression = \"(3 + 5) * (4 - 2))\"\n    Output: False\n\n    Constraints:\n    - The expression will only contain parentheses, numbers, and arithmetic operators (+, -, *, /).\n    - The expression will be a valid mathematical expression.\n    \"\"\"\n\n    stack = []\n\n    for char in expression:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n\n    return len(stack) == 0\n\ndef g(expression=\"(3 + 5) * (4 - 2)\"):\n    return expression\n\nassert f(g()) == True\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 492, "target_skills": [0, 0, 0, 1, 0, 1, 0, 0, 0, 0], "problem_func": "import math\nfrom typing import*\nfrom typing import List\n\ndef f(expression: str) -> bool:\n    \"\"\"\n    Given a mathematical expression as a string, determine if the parentheses in the expression are balanced.\n    Return True if the parentheses are balanced, False otherwise.\n\n    Example:\n    expression = \"(3 + 5) * (4 - 2)\"\n    Output: True\n\n    expression = \"(3 + 5) * (4 - 2))\"\n    Output: False\n\n    Constraints:\n    - The expression will only contain parentheses, numbers, and arithmetic operators (+, -, *, /).\n    - The expression will be a valid mathematical expression.\n    \"\"\"\n\n    stack = []\n\n    for char in expression:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n\n    return len(stack) == 0", "solution_func": "def g(expression=\"(3 + 5) * (4 - 2)\"):\n    return expression", "map_ix": [1, 1, 0, 1, 0, 1, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "import math\nfrom typing import*\nfrom typing import List\n\ndef f(equation: str) -> str:\n    \"\"\"\n    Given a mathematical equation as a string, solve the equation and return the result as a string.\n\n    Example:\n    equation = \"2 * (3 + 4) - (5 * 2)\"\n    Output: \"9\"\n\n    equation = \"5 + 3 * 2\"\n    Output: \"11\"\n\n    Constraints:\n    - The equation will only contain numbers, arithmetic operators (+, -, *, /), and parentheses.\n    - The equation will be a valid mathematical equation.\n    \"\"\"\n\n    return str(eval(equation))\n\ndef g(equation=\"2 * (3 + 4) - (5 * 2)\"):\n    return equation\n\nassert f(g()) == \"9\"\n", "emb": null, "idx_generation": 492, "target_skills": [0, 1, 0, 1, 1, 0, 0, 0, 1, 0], "problem_func": "import math\nfrom typing import*\nfrom typing import List\n\ndef f(equation: str) -> str:\n    \"\"\"\n    Given a mathematical equation as a string, solve the equation and return the result as a string.\n\n    Example:\n    equation = \"2 * (3 + 4) - (5 * 2)\"\n    Output: \"9\"\n\n    equation = \"5 + 3 * 2\"\n    Output: \"11\"\n\n    Constraints:\n    - The equation will only contain numbers, arithmetic operators (+, -, *, /), and parentheses.\n    - The equation will be a valid mathematical equation.\n    \"\"\"\n\n    return str(eval(equation))", "solution_func": "def g(equation=\"2 * (3 + 4) - (5 * 2)\"):\n    return equation", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(number: int) -> str:\n    \"\"\"\n    Given a positive integer, convert it to a Roman numeral and return the Roman numeral as a string.\n\n    Example:\n    number = 37\n    Output: \"XXXVII\"\n\n    number = 99\n    Output: \"XCIX\"\n\n    Constraints:\n    - The input number will be between 1 and 3999.\n    \"\"\"\n\n    roman_numerals = {\n        1000: 'M',\n        900: 'CM',\n        500: 'D',\n        400: 'CD',\n        100: 'C',\n        90: 'XC',\n        50: 'L',\n        40: 'XL',\n        10: 'X',\n        9: 'IX',\n        5: 'V',\n        4: 'IV',\n        1: 'I'\n    }\n\n    result = \"\"\n\n    for value, symbol in roman_numerals.items():\n        while number >= value:\n            result += symbol\n            number -= value\n\n    return result\n\ndef g(number=37):\n    return number\n\nassert f(g()) == \"XXXVII\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 492, "target_skills": [0, 0, 0, 1, 1, 1, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(number: int) -> str:\n    \"\"\"\n    Given a positive integer, convert it to a Roman numeral and return the Roman numeral as a string.\n\n    Example:\n    number = 37\n    Output: \"XXXVII\"\n\n    number = 99\n    Output: \"XCIX\"\n\n    Constraints:\n    - The input number will be between 1 and 3999.\n    \"\"\"\n\n    roman_numerals = {\n        1000: 'M',\n        900: 'CM',\n        500: 'D',\n        400: 'CD',\n        100: 'C',\n        90: 'XC',\n        50: 'L',\n        40: 'XL',\n        10: 'X',\n        9: 'IX',\n        5: 'V',\n        4: 'IV',\n        1: 'I'\n    }\n\n    result = \"\"\n\n    for value, symbol in roman_numerals.items():\n        while number >= value:\n            result += symbol\n            number -= value\n\n    return result", "solution_func": "def g(number=37):\n    return number", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if they are isomorphic.\n\n    Two strings are isomorphic if the characters in s can be replaced to get t.\n\n    Example:\n    s = \"egg\"\n    t = \"add\"\n\n    Output:\n    True\n\n    Explanation:\n    The characters 'e' and 'a' can be mapped to 'a'.\n    The characters 'g' and 'd' can be mapped to 'd'.\n\n    Therefore, the strings are isomorphic.\n\n    Hint: Use dictionaries to map characters from s to t and vice versa, and check if the mappings are valid.\n    \"\"\"\n\n    if len(s) != len(t):\n        return False\n\n    s_to_t = {}\n    t_to_s = {}\n\n    for i in range(len(s)):\n        if s[i] in s_to_t:\n            if s_to_t[s[i]] != t[i]:\n                return False\n        else:\n            s_to_t[s[i]] = t[i]\n\n        if t[i] in t_to_s:\n            if t_to_s[t[i]] != s[i]:\n                return False\n        else:\n            t_to_s[t[i]] = s[i]\n\n    return True\n\ndef g() -> Tuple[str, str]:\n    s = \"paper\"\n    t = \"title\"\n    return s, t\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 492, "target_skills": [1, 1, 1, 1, 0, 0, 1, 1, 1, 1], "problem_func": "from typing import*\n\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if they are isomorphic.\n\n    Two strings are isomorphic if the characters in s can be replaced to get t.\n\n    Example:\n    s = \"egg\"\n    t = \"add\"\n\n    Output:\n    True\n\n    Explanation:\n    The characters 'e' and 'a' can be mapped to 'a'.\n    The characters 'g' and 'd' can be mapped to 'd'.\n\n    Therefore, the strings are isomorphic.\n\n    Hint: Use dictionaries to map characters from s to t and vice versa, and check if the mappings are valid.\n    \"\"\"\n\n    if len(s) != len(t):\n        return False\n\n    s_to_t = {}\n    t_to_s = {}\n\n    for i in range(len(s)):\n        if s[i] in s_to_t:\n            if s_to_t[s[i]] != t[i]:\n                return False\n        else:\n            s_to_t[s[i]] = t[i]\n\n        if t[i] in t_to_s:\n            if t_to_s[t[i]] != s[i]:\n                return False\n        else:\n            t_to_s[t[i]] = s[i]\n\n    return True", "solution_func": "def g() -> Tuple[str, str]:\n    s = \"paper\"\n    t = \"title\"\n    return s, t", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of prime numbers less than or equal to n.\n\n    Example:\n    n = 10\n\n    Output:\n    4\n\n    Explanation:\n    There are 4 prime numbers less than or equal to 10: 2, 3, 5, and 7.\n\n    Hint: Use the Sieve of Eratosthenes algorithm to find all prime numbers up to n.\n    \"\"\"\n\n    if n <= 1:\n        return 0\n\n    primes = [True] * (n + 1)\n    primes[0] = primes[1] = False\n\n    for i in range(2, int(n ** 0.5) + 1):\n        if primes[i]:\n            for j in range(i*i, n + 1, i):\n                primes[j] = False\n\n    return sum(primes)\n\ndef g() -> int:\n    n = 20\n    return n\n\nassert f(g()) == 8\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 492, "target_skills": [0, 1, 1, 0, 0, 0, 1, 0, 1, 1], "problem_func": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of prime numbers less than or equal to n.\n\n    Example:\n    n = 10\n\n    Output:\n    4\n\n    Explanation:\n    There are 4 prime numbers less than or equal to 10: 2, 3, 5, and 7.\n\n    Hint: Use the Sieve of Eratosthenes algorithm to find all prime numbers up to n.\n    \"\"\"\n\n    if n <= 1:\n        return 0\n\n    primes = [True] * (n + 1)\n    primes[0] = primes[1] = False\n\n    for i in range(2, int(n ** 0.5) + 1):\n        if primes[i]:\n            for j in range(i*i, n + 1, i):\n                primes[j] = False\n\n    return sum(primes)", "solution_func": "def g() -> int:\n    n = 20\n    return n", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a power of two.\n\n    Example:\n    n = 16\n\n    Output:\n    True\n\n    Explanation:\n    16 is a power of two because it can be expressed as 2^4.\n\n    Hint: Use bitwise operations to check if a number is a power of two.\n    \"\"\"\n\n    if n <= 0:\n        return False\n\n    return n & (n - 1) == 0\n\ndef g() -> int:\n    n = 32\n    return n\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 492, "target_skills": [1, 0, 0, 1, 1, 0, 0, 1, 1, 0], "problem_func": "from typing import*\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a power of two.\n\n    Example:\n    n = 16\n\n    Output:\n    True\n\n    Explanation:\n    16 is a power of two because it can be expressed as 2^4.\n\n    Hint: Use bitwise operations to check if a number is a power of two.\n    \"\"\"\n\n    if n <= 0:\n        return False\n\n    return n & (n - 1) == 0", "solution_func": "def g() -> int:\n    n = 32\n    return n", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of bits that are set to 1 in its binary representation.\n\n    Example:\n    n = 27\n\n    Output:\n    4\n\n    Explanation:\n    The binary representation of 27 is 11011, which has 4 bits set to 1.\n\n    Hint: Use bit manipulation to solve this problem.\n    \"\"\"\n\n    count = 0\n\n    while n > 0:\n        count += n & 1\n        n >>= 1\n\n    return count\n\ndef g() -> int:\n    n = 27\n    return n\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 492, "target_skills": [1, 0, 1, 1, 0, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of bits that are set to 1 in its binary representation.\n\n    Example:\n    n = 27\n\n    Output:\n    4\n\n    Explanation:\n    The binary representation of 27 is 11011, which has 4 bits set to 1.\n\n    Hint: Use bit manipulation to solve this problem.\n    \"\"\"\n\n    count = 0\n\n    while n > 0:\n        count += n & 1\n        n >>= 1\n\n    return count", "solution_func": "def g() -> int:\n    n = 27\n    return n", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of any contiguous subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The contiguous subarray with the maximum sum is [4, -1, 2, 1], which has a sum of 6.\n\n    Hint: Use dynamic programming and recursion to solve this problem.\n    \"\"\"\n\n    def max_subarray(nums: List[int], start: int, end: int) -> int:\n        if start == end:\n            return nums[start]\n\n        mid = (start + end) // 2\n\n        left_max = max_subarray(nums, start, mid)\n        right_max = max_subarray(nums, mid+1, end)\n\n        left_sum = float('-inf')\n        right_sum = float('-inf')\n        sum = 0\n\n        for i in range(mid, start-1, -1):\n            sum += nums[i]\n            left_sum = max(left_sum, sum)\n\n        sum = 0\n\n        for i in range(mid+1, end+1):\n            sum += nums[i]\n            right_sum = max(right_sum, sum)\n\n        return max(left_max, right_max, left_sum + right_sum)\n\n    return max_subarray(nums, 0, len(nums)-1)\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 492, "target_skills": [1, 1, 0, 0, 0, 0, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of any contiguous subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The contiguous subarray with the maximum sum is [4, -1, 2, 1], which has a sum of 6.\n\n    Hint: Use dynamic programming and recursion to solve this problem.\n    \"\"\"\n\n    def max_subarray(nums: List[int], start: int, end: int) -> int:\n        if start == end:\n            return nums[start]\n\n        mid = (start + end) // 2\n\n        left_max = max_subarray(nums, start, mid)\n        right_max = max_subarray(nums, mid+1, end)\n\n        left_sum = float('-inf')\n        right_sum = float('-inf')\n        sum = 0\n\n        for i in range(mid, start-1, -1):\n            sum += nums[i]\n            left_sum = max(left_sum, sum)\n\n        sum = 0\n\n        for i in range(mid+1, end+1):\n            sum += nums[i]\n            right_sum = max(right_sum, sum)\n\n        return max(left_max, right_max, left_sum + right_sum)\n\n    return max_subarray(nums, 0, len(nums)-1)", "solution_func": "def g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a grid of integers representing a maze, find a path from the top-left corner to the bottom-right corner.\n    Each cell in the grid represents a room in the maze, where 0 represents an open room that can be traversed and 1 represents a blocked room that cannot be traversed.\n    Return a grid with the path marked with 2.\n\n    Example:\n    grid = [\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 0, 1],\n        [1, 1, 0, 1, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 0, 1, 0]\n    ]\n\n    Output:\n    [\n        [2, 2, 1, 0, 0],\n        [0, 0, 0, 0, 1],\n        [1, 1, 0, 1, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 0, 1, 2]\n    ]\n\n    Constraints:\n    - The grid will always be a rectangular shape.\n    - The grid will always have at least one row and one column.\n    - The grid will only contain 0 and 1.\n    - The top-left corner of the grid will always be a 0.\n    - The bottom-right corner of the grid will always be a 0.\n    - It is guaranteed that there is a path from the top-left corner to the bottom-right corner of the grid.\n\n    Hint: Use recursion and stack to solve this problem.\n    \"\"\"\n\n    def dfs(i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 0:\n            return\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\n            grid[i][j] = 2\n            return\n\n        grid[i][j] = 2\n        dfs(i+1, j)\n        dfs(i-1, j)\n        dfs(i, j+1)\n        dfs(i, j-1)\n\n    dfs(0, 0)\n    return grid\n\ndef g() -> List[List[int]]:\n    grid = [\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 0, 1],\n        [1, 1, 0, 1, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 0, 1, 0]\n    ]\n    return grid\n\nassert f(g()) == [\n    [2, 2, 1, 0, 0],\n    [0, 0, 0, 0, 1],\n    [1, 1, 0, 1, 0],\n    [1, 1, 0, 0, 0],\n    [0, 0, 0, 1, 2]\n]\n", "emb": null, "idx_generation": 492, "target_skills": [0, 1, 1, 0, 1, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a grid of integers representing a maze, find a path from the top-left corner to the bottom-right corner.\n    Each cell in the grid represents a room in the maze, where 0 represents an open room that can be traversed and 1 represents a blocked room that cannot be traversed.\n    Return a grid with the path marked with 2.\n\n    Example:\n    grid = [\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 0, 1],\n        [1, 1, 0, 1, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 0, 1, 0]\n    ]\n\n    Output:\n    [\n        [2, 2, 1, 0, 0],\n        [0, 0, 0, 0, 1],\n        [1, 1, 0, 1, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 0, 1, 2]\n    ]\n\n    Constraints:\n    - The grid will always be a rectangular shape.\n    - The grid will always have at least one row and one column.\n    - The grid will only contain 0 and 1.\n    - The top-left corner of the grid will always be a 0.\n    - The bottom-right corner of the grid will always be a 0.\n    - It is guaranteed that there is a path from the top-left corner to the bottom-right corner of the grid.\n\n    Hint: Use recursion and stack to solve this problem.\n    \"\"\"\n\n    def dfs(i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 0:\n            return\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\n            grid[i][j] = 2\n            return\n\n        grid[i][j] = 2\n        dfs(i+1, j)\n        dfs(i-1, j)\n        dfs(i, j+1)\n        dfs(i, j-1)\n\n    dfs(0, 0)\n    return grid", "solution_func": "def g() -> List[List[int]]:\n    grid = [\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 0, 1],\n        [1, 1, 0, 1, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 0, 1, 0]\n    ]\n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(points: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculate the perimeter of a polygon given its vertices.\n\n    Example:\n    points = [(0, 0), (3, 0), (0, 4), (3, 4)]\n\n    Output:\n    12\n\n    Explanation:\n    The perimeter of the polygon with vertices (0, 0), (3, 0), (0, 4), and (3, 4) is 12.\n    \"\"\"\n    def distance(p1: Tuple[int, int], p2: Tuple[int, int]) -> float:\n        x1, y1 = p1\n        x2, y2 = p2\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    perimeter = 0\n    n = len(points)\n    for i in range(n):\n        j = (i + 1) % n\n        perimeter += distance(points[i], points[j])\n    \n    return int(perimeter)\n\ndef g() -> List[Tuple[int, int]]:\n    \"\"\"\n    Generate a list of vertices for a polygon.\n    \"\"\"\n    return [(0, 0), (3, 0), (0, 4), (3, 4)]\n\nassert f(g()) == 12\n", "emb": null, "idx_generation": 492, "target_skills": [0, 0, 1, 0, 1, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(points: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculate the perimeter of a polygon given its vertices.\n\n    Example:\n    points = [(0, 0), (3, 0), (0, 4), (3, 4)]\n\n    Output:\n    12\n\n    Explanation:\n    The perimeter of the polygon with vertices (0, 0), (3, 0), (0, 4), and (3, 4) is 12.\n    \"\"\"\n    def distance(p1: Tuple[int, int], p2: Tuple[int, int]) -> float:\n        x1, y1 = p1\n        x2, y2 = p2\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    perimeter = 0\n    n = len(points)\n    for i in range(n):\n        j = (i + 1) % n\n        perimeter += distance(points[i], points[j])\n    \n    return int(perimeter)", "solution_func": "def g() -> List[Tuple[int, int]]:\n    \"\"\"\n    Generate a list of vertices for a polygon.\n    \"\"\"\n    return [(0, 0), (3, 0), (0, 4), (3, 4)]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of possible combinations of k numbers from the range 1 to n.\n\n    Example:\n    n = 5, k = 3\n    Output: 10\n    Explanation: There are 10 possible combinations of 3 numbers from the range 1 to 5: \n    [1,2,3], [1,2,4], [1,2,5], [1,3,4], [1,3,5], [1,4,5], [2,3,4], [2,3,5], [2,4,5], [3,4,5].\n\n    Hint: Use a recursive approach to generate all combinations of k numbers from the range 1 to n.\n    \"\"\"\n\n    def generate_combinations(combination: List[int], start: int):\n        if len(combination) == k:\n            combinations.append(combination[:])\n            return\n        for i in range(start, n + 1):\n            combination.append(i)\n            generate_combinations(combination, i + 1)\n            combination.pop()\n\n    combinations = []\n    generate_combinations([], 1)\n    return len(combinations)\n\ndef g():\n    return 5, 3\n\nassert f(*g()) == 10\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 493, "target_skills": [0, 1, 0, 0, 1, 0, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of possible combinations of k numbers from the range 1 to n.\n\n    Example:\n    n = 5, k = 3\n    Output: 10\n    Explanation: There are 10 possible combinations of 3 numbers from the range 1 to 5: \n    [1,2,3], [1,2,4], [1,2,5], [1,3,4], [1,3,5], [1,4,5], [2,3,4], [2,3,5], [2,4,5], [3,4,5].\n\n    Hint: Use a recursive approach to generate all combinations of k numbers from the range 1 to n.\n    \"\"\"\n\n    def generate_combinations(combination: List[int], start: int):\n        if len(combination) == k:\n            combinations.append(combination[:])\n            return\n        for i in range(start, n + 1):\n            combination.append(i)\n            generate_combinations(combination, i + 1)\n            combination.pop()\n\n    combinations = []\n    generate_combinations([], 1)\n    return len(combinations)", "solution_func": "def g():\n    return 5, 3", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n    Output: 28\n    Explanation: The maximum XOR value between any two numbers in the list is 28, which is the XOR of 5 and 25.\n\n    Hint: Use a recursive approach to generate all possible XOR values between any two numbers in the list.\n    \"\"\"\n\n    def find_max_xor(nums: List[int], current_xor: int, index: int):\n        if index == len(nums):\n            max_xor[0] = max(max_xor[0], current_xor)\n            return\n        \n        find_max_xor(nums, current_xor ^ nums[index], index + 1)\n        find_max_xor(nums, current_xor, index + 1)\n\n    max_xor = [0]\n    find_max_xor(nums, 0, 0)\n    return max_xor[0]\n\ndef g():\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n\n", "emb": null, "idx_generation": 493, "target_skills": [0, 0, 0, 0, 1, 0, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n    Output: 28\n    Explanation: The maximum XOR value between any two numbers in the list is 28, which is the XOR of 5 and 25.\n\n    Hint: Use a recursive approach to generate all possible XOR values between any two numbers in the list.\n    \"\"\"\n\n    def find_max_xor(nums: List[int], current_xor: int, index: int):\n        if index == len(nums):\n            max_xor[0] = max(max_xor[0], current_xor)\n            return\n        \n        find_max_xor(nums, current_xor ^ nums[index], index + 1)\n        find_max_xor(nums, current_xor, index + 1)\n\n    max_xor = [0]\n    find_max_xor(nums, 0, 0)\n    return max_xor[0]", "solution_func": "def g():\n    return [3, 10, 5, 25, 2, 8]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of possible permutations of k numbers from the range 1 to n.\n\n    Example:\n    n = 5, k = 3\n    Output: 60\n    Explanation: There are 60 possible permutations of 3 numbers from the range 1 to 5: \n    [1,2,3], [1,2,4], [1,2,5], [1,3,2], [1,3,4], [1,3,5], [1,4,2], [1,4,3], [1,4,5], [1,5,2], [1,5,3], [1,5,4],\n    [2,1,3], [2,1,4], [2,1,5], [2,3,1], [2,3,4], [2,3,5], [2,4,1], [2,4,3], [2,4,5], [2,5,1], [2,5,3], [2,5,4],\n    [3,1,2], [3,1,4], [3,1,5], [3,2,1], [3,2,4], [3,2,5], [3,4,1], [3,4,2], [3,4,5], [3,5,1], [3,5,2], [3,5,4],\n    [4,1,2], [4,1,3], [4,1,5], [4,2,1], [4,2,3], [4,2,5], [4,3,1], [4,3,2], [4,3,5], [4,5,1], [4,5,2], [4,5,3],\n    [5,1,2], [5,1,3], [5,1,4], [5,2,1], [5,2,3], [5,2,4], [5,3,1], [5,3,2], [5,3,4], [5,4,1], [5,4,2], [5,4,3].\n\n    Hint: Use a recursive approach to generate all permutations of k numbers from the range 1 to n.\n    \"\"\"\n\n    def generate_permutations(permutation: List[int], used: List[bool]):\n        if len(permutation) == k:\n            permutations.append(permutation[:])\n            return\n        \n        for i in range(1, n + 1):\n            if not used[i]:\n                used[i] = True\n                permutation.append(i)\n                generate_permutations(permutation, used)\n                used[i] = False\n                permutation.pop()\n\n    permutations = []\n    used = [False] * (n + 1)\n    generate_permutations([], used)\n    return len(permutations)\n\ndef g():\n    return 5, 3\n\nassert f(*g()) == 60\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 493, "target_skills": [1, 0, 0, 1, 0, 0, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of possible permutations of k numbers from the range 1 to n.\n\n    Example:\n    n = 5, k = 3\n    Output: 60\n    Explanation: There are 60 possible permutations of 3 numbers from the range 1 to 5: \n    [1,2,3], [1,2,4], [1,2,5], [1,3,2], [1,3,4], [1,3,5], [1,4,2], [1,4,3], [1,4,5], [1,5,2], [1,5,3], [1,5,4],\n    [2,1,3], [2,1,4], [2,1,5], [2,3,1], [2,3,4], [2,3,5], [2,4,1], [2,4,3], [2,4,5], [2,5,1], [2,5,3], [2,5,4],\n    [3,1,2], [3,1,4], [3,1,5], [3,2,1], [3,2,4], [3,2,5], [3,4,1], [3,4,2], [3,4,5], [3,5,1], [3,5,2], [3,5,4],\n    [4,1,2], [4,1,3], [4,1,5], [4,2,1], [4,2,3], [4,2,5], [4,3,1], [4,3,2], [4,3,5], [4,5,1], [4,5,2], [4,5,3],\n    [5,1,2], [5,1,3], [5,1,4], [5,2,1], [5,2,3], [5,2,4], [5,3,1], [5,3,2], [5,3,4], [5,4,1], [5,4,2], [5,4,3].\n\n    Hint: Use a recursive approach to generate all permutations of k numbers from the range 1 to n.\n    \"\"\"\n\n    def generate_permutations(permutation: List[int], used: List[bool]):\n        if len(permutation) == k:\n            permutations.append(permutation[:])\n            return\n        \n        for i in range(1, n + 1):\n            if not used[i]:\n                used[i] = True\n                permutation.append(i)\n                generate_permutations(permutation, used)\n                used[i] = False\n                permutation.pop()\n\n    permutations = []\n    used = [False] * (n + 1)\n    generate_permutations([], used)\n    return len(permutations)", "solution_func": "def g():\n    return 5, 3", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR subset sum.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The maximum XOR subset sum.\n    \"\"\"\n    def xor_subset_sum(nums: List[int], index: int, xor_sum: int) -> int:\n        if index == len(nums):\n            return xor_sum\n        else:\n            # Include current number in XOR sum\n            include_sum = xor_subset_sum(nums, index + 1, xor_sum ^ nums[index])\n            # Exclude current number from XOR sum\n            exclude_sum = xor_subset_sum(nums, index + 1, xor_sum)\n            # Return the maximum of the two sums\n            return max(include_sum, exclude_sum)\n\n    return xor_subset_sum(nums, 0, 0)\n\ndef g():\n    nums = [2, 5, 8, 10]\n    return nums\n\nassert f(g()) == 15\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 493, "target_skills": [0, 1, 0, 1, 1, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR subset sum.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The maximum XOR subset sum.\n    \"\"\"\n    def xor_subset_sum(nums: List[int], index: int, xor_sum: int) -> int:\n        if index == len(nums):\n            return xor_sum\n        else:\n            # Include current number in XOR sum\n            include_sum = xor_subset_sum(nums, index + 1, xor_sum ^ nums[index])\n            # Exclude current number from XOR sum\n            exclude_sum = xor_subset_sum(nums, index + 1, xor_sum)\n            # Return the maximum of the two sums\n            return max(include_sum, exclude_sum)\n\n    return xor_subset_sum(nums, 0, 0)", "solution_func": "def g():\n    nums = [2, 5, 8, 10]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR of two numbers in the list.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The maximum XOR of two numbers in the list.\n    \"\"\"\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor\n\ndef g():\n    nums = [4, 7, 2, 9, 5]\n    return nums\n\nassert f(g()) == 15\n", "emb": null, "idx_generation": 493, "target_skills": [1, 1, 0, 0, 1, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR of two numbers in the list.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The maximum XOR of two numbers in the list.\n    \"\"\"\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor", "solution_func": "def g():\n    nums = [4, 7, 2, 9, 5]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR subset size.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The maximum XOR subset size.\n    \"\"\"\n    def xor_subset_size(nums: List[int], index: int, xor_sum: int) -> int:\n        if index == len(nums):\n            return 0\n        else:\n            # Include current number in XOR sum\n            include_size = xor_subset_size(nums, index + 1, xor_sum ^ nums[index]) + 1\n            # Exclude current number from XOR sum\n            exclude_size = xor_subset_size(nums, index + 1, xor_sum)\n            # Return the maximum of the two sizes\n            return max(include_size, exclude_size)\n\n    return xor_subset_size(nums, 0, 0)\n\ndef g():\n    nums = [2, 5, 8, 10]\n    return nums\n\nassert f(g()) == 3\n", "emb": null, "idx_generation": 493, "target_skills": [0, 0, 1, 0, 0, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR subset size.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The maximum XOR subset size.\n    \"\"\"\n    def xor_subset_size(nums: List[int], index: int, xor_sum: int) -> int:\n        if index == len(nums):\n            return 0\n        else:\n            # Include current number in XOR sum\n            include_size = xor_subset_size(nums, index + 1, xor_sum ^ nums[index]) + 1\n            # Exclude current number from XOR sum\n            exclude_size = xor_subset_size(nums, index + 1, xor_sum)\n            # Return the maximum of the two sizes\n            return max(include_size, exclude_size)\n\n    return xor_subset_size(nums, 0, 0)", "solution_func": "def g():\n    nums = [2, 5, 8, 10]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there are two numbers in the list that add up to the target.\n    Return True if such numbers exist, otherwise return False.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 10\n\n    Output:\n    True (since 1 + 9 = 10)\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g() -> Tuple[List[int], int]:\n    return ([1, 3, 5, 7, 9], 10)\n\nassert f(*g())\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 493, "target_skills": [1, 1, 0, 0, 0, 0, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there are two numbers in the list that add up to the target.\n    Return True if such numbers exist, otherwise return False.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 10\n\n    Output:\n    True (since 1 + 9 = 10)\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False", "solution_func": "def g() -> Tuple[List[int], int]:\n    return ([1, 3, 5, 7, 9], 10)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with all duplicate elements removed.\n    The order of the elements in the new list should be the same as the original list.\n\n    Example:\n    nums = [2, 3, 1, 3, 4, 2]\n\n    Output:\n    [2, 3, 1, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    \n    for num in nums:\n        if num not in seen:\n            result.append(num)\n            seen.add(num)\n    \n    return result\n\ndef g() -> List[int]:\n    return [2, 3, 1, 3, 4, 2]\n\nassert f(g()) == [2, 3, 1, 4]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 493, "target_skills": [1, 0, 1, 1, 0, 0, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with all duplicate elements removed.\n    The order of the elements in the new list should be the same as the original list.\n\n    Example:\n    nums = [2, 3, 1, 3, 4, 2]\n\n    Output:\n    [2, 3, 1, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    \n    for num in nums:\n        if num not in seen:\n            result.append(num)\n            seen.add(num)\n    \n    return result", "solution_func": "def g() -> List[int]:\n    return [2, 3, 1, 3, 4, 2]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, return the index of the target value in the list.\n    If the target value is not found in the list, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output:\n    2\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    return ([1, 3, 5, 7, 9], 5)\n\nassert f(*g()) == 2\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 493, "target_skills": [0, 0, 0, 0, 0, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, return the index of the target value in the list.\n    If the target value is not found in the list, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output:\n    2\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1", "solution_func": "def g() -> Tuple[List[int], int]:\n    return ([1, 3, 5, 7, 9], 5)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, k: int, p: int) -> int:\n    \"\"\"\n    Given two integers n and k, and a prime number p, find the number of ways to choose k elements from a set of n elements,\n    such that the product of the chosen elements is divisible by p.\n    \"\"\"\n    def count_divisible(nums, p):\n        count = 0\n        for num in nums:\n            if num % p == 0:\n                count += 1\n        return count\n    \n    def choose(n, k):\n        if k == 0 or k == n:\n            return 1\n        if k > n:\n            return 0\n        return choose(n - 1, k - 1) + choose(n - 1, k)\n    \n    nums = list(range(1, n + 1))\n    divisible_count = count_divisible(nums, p)\n    non_divisible_count = n - divisible_count\n    combinations = choose(non_divisible_count, k)\n    return combinations\n\ndef g(n=10, k=3, p=2):\n    return n, k, p\n\nassert f(*g()) == 56\n", "emb": null, "idx_generation": 493, "target_skills": [0, 0, 1, 1, 0, 0, 1, 1, 0, 1], "problem_func": "from typing import*\ndef f(n: int, k: int, p: int) -> int:\n    \"\"\"\n    Given two integers n and k, and a prime number p, find the number of ways to choose k elements from a set of n elements,\n    such that the product of the chosen elements is divisible by p.\n    \"\"\"\n    def count_divisible(nums, p):\n        count = 0\n        for num in nums:\n            if num % p == 0:\n                count += 1\n        return count\n    \n    def choose(n, k):\n        if k == 0 or k == n:\n            return 1\n        if k > n:\n            return 0\n        return choose(n - 1, k - 1) + choose(n - 1, k)\n    \n    nums = list(range(1, n + 1))\n    divisible_count = count_divisible(nums, p)\n    non_divisible_count = n - divisible_count\n    combinations = choose(non_divisible_count, k)\n    return combinations", "solution_func": "def g(n=10, k=3, p=2):\n    return n, k, p", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted (in ascending order) integer array nums and a target value, find the starting and ending position of a given target value in the array.\n\n    Your algorithm's runtime complexity must be in the order of O(log n).\n\n    If the target is not found in the array, return [-1, -1].\n\n    Example:\n    nums = [5,7,7,8,8,10]\n    target = 8\n\n    Output:\n    [3, 4]\n\n    Explanation:\n    The value 8 appears at indices 3 and 4 in the array.\n    \"\"\"\n    def binary_search(nums, target, left):\n        low = 0\n        high = len(nums) - 1\n\n        while low <= high:\n            mid = (low + high) // 2\n            if nums[mid] > target or (left and nums[mid] == target):\n                high = mid - 1\n            else:\n                low = mid + 1\n\n        return low\n\n    left_idx = binary_search(nums, target, True)\n    if left_idx >= len(nums) or nums[left_idx] != target:\n        return [-1, -1]\n\n    right_idx = binary_search(nums, target, False) - 1\n\n    return [left_idx, right_idx]\n\ndef g(nums: List[int] = [5,7,7,8,8,10], target: int = 8):\n    return (nums, target,)\n\nassert f(*g()) == [3, 4]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 494, "target_skills": [1, 0, 1, 0, 0, 1, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted (in ascending order) integer array nums and a target value, find the starting and ending position of a given target value in the array.\n\n    Your algorithm's runtime complexity must be in the order of O(log n).\n\n    If the target is not found in the array, return [-1, -1].\n\n    Example:\n    nums = [5,7,7,8,8,10]\n    target = 8\n\n    Output:\n    [3, 4]\n\n    Explanation:\n    The value 8 appears at indices 3 and 4 in the array.\n    \"\"\"\n    def binary_search(nums, target, left):\n        low = 0\n        high = len(nums) - 1\n\n        while low <= high:\n            mid = (low + high) // 2\n            if nums[mid] > target or (left and nums[mid] == target):\n                high = mid - 1\n            else:\n                low = mid + 1\n\n        return low\n\n    left_idx = binary_search(nums, target, True)\n    if left_idx >= len(nums) or nums[left_idx] != target:\n        return [-1, -1]\n\n    right_idx = binary_search(nums, target, False) - 1\n\n    return [left_idx, right_idx]", "solution_func": "def g(nums: List[int] = [5,7,7,8,8,10], target: int = 8):\n    return (nums, target,)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size m x n, each cell of which contains a positive integer, find the minimum number of operations to make all the cells of the grid equal.\n\n    In one operation, you can increment or decrement the value of any cell by 1.\n\n    Example:\n    grid = [[1,2,3],[4,5,6],[7,8,9]]\n\n    Output:\n    10\n\n    Explanation:\n    The minimum number of operations required is 10.\n    Grid after 10 operations: [[4, 5, 6], [4, 5, 6], [4, 5, 6]]\n    \"\"\"\n\n    m, n = len(grid), len(grid[0])\n    row_ops = [0] * m\n    col_ops = [0] * n\n\n    for i in range(m):\n        for j in range(n):\n            row_ops[i] += abs(grid[i][j] - grid[0][0])\n            col_ops[j] += abs(grid[i][j] - grid[0][0])\n\n    min_ops = float('inf')\n    for i in range(m):\n        for j in range(n):\n            ops = row_ops[i] + col_ops[j] - abs(grid[i][j] - grid[0][0])\n            min_ops = min(min_ops, ops)\n\n    return min_ops\n\ndef g(grid: List[List[int]] = [[1,2,3],[4,5,6],[7,8,9]]):\n    return (grid,)\n\nassert f(*g()) == 10\n\n", "emb": null, "idx_generation": 494, "target_skills": [0, 0, 0, 1, 0, 1, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size m x n, each cell of which contains a positive integer, find the minimum number of operations to make all the cells of the grid equal.\n\n    In one operation, you can increment or decrement the value of any cell by 1.\n\n    Example:\n    grid = [[1,2,3],[4,5,6],[7,8,9]]\n\n    Output:\n    10\n\n    Explanation:\n    The minimum number of operations required is 10.\n    Grid after 10 operations: [[4, 5, 6], [4, 5, 6], [4, 5, 6]]\n    \"\"\"\n\n    m, n = len(grid), len(grid[0])\n    row_ops = [0] * m\n    col_ops = [0] * n\n\n    for i in range(m):\n        for j in range(n):\n            row_ops[i] += abs(grid[i][j] - grid[0][0])\n            col_ops[j] += abs(grid[i][j] - grid[0][0])\n\n    min_ops = float('inf')\n    for i in range(m):\n        for j in range(n):\n            ops = row_ops[i] + col_ops[j] - abs(grid[i][j] - grid[0][0])\n            min_ops = min(min_ops, ops)\n\n    return min_ops", "solution_func": "def g(grid: List[List[int]] = [[1,2,3],[4,5,6],[7,8,9]]):\n    return (grid,)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums sorted in ascending order, find two numbers such that they add up to a specific target number.\n\n    Return the indices of the two numbers (1-indexed) as an integer array answer of size 2, where 1 <= answer[0] < answer[1] <= nums.length.\n\n    You may assume that each input would have exactly one solution and you may not use the same element twice.\n\n    Example:\n    nums = [2,7,11,15]\n    target = 9\n\n    Output:\n    [1, 2]\n\n    Explanation:\n    The sum of 2 and 7 is 9. Therefore, the indices are 1 and 2.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left + 1, right + 1]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g(nums: List[int] = [2,7,11,15], target: int = 9):\n    return (nums, target,)\n\nassert f(*g()) == [1, 2]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 494, "target_skills": [0, 1, 0, 1, 1, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums sorted in ascending order, find two numbers such that they add up to a specific target number.\n\n    Return the indices of the two numbers (1-indexed) as an integer array answer of size 2, where 1 <= answer[0] < answer[1] <= nums.length.\n\n    You may assume that each input would have exactly one solution and you may not use the same element twice.\n\n    Example:\n    nums = [2,7,11,15]\n    target = 9\n\n    Output:\n    [1, 2]\n\n    Explanation:\n    The sum of 2 and 7 is 9. Therefore, the indices are 1 and 2.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left + 1, right + 1]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g(nums: List[int] = [2,7,11,15], target: int = 9):\n    return (nums, target,)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers n and m, calculate the value of n! * m!.\n\n    Example:\n    n = 3, m = 4\n\n    Output:\n    144 (as 3! = 3*2*1 = 6 and 4! = 4*3*2*1 = 24, so the result is 6 * 24 = 144)\n    \"\"\"\n    def factorial(num):\n        if num == 0 or num == 1:\n            return 1\n        else:\n            return num * factorial(num - 1)\n    \n    return factorial(n) * factorial(m)\n\ndef g(n: int = 3, m: int = 4) -> Tuple[int, int]:\n    return n, m\n\nassert f(*g()) == 144\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 494, "target_skills": [0, 1, 1, 1, 0, 1, 0, 0, 1, 0], "problem_func": "from typing import*\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers n and m, calculate the value of n! * m!.\n\n    Example:\n    n = 3, m = 4\n\n    Output:\n    144 (as 3! = 3*2*1 = 6 and 4! = 4*3*2*1 = 24, so the result is 6 * 24 = 144)\n    \"\"\"\n    def factorial(num):\n        if num == 0 or num == 1:\n            return 1\n        else:\n            return num * factorial(num - 1)\n    \n    return factorial(n) * factorial(m)", "solution_func": "def g(n: int = 3, m: int = 4) -> Tuple[int, int]:\n    return n, m", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the shortest path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7 (as the shortest path is 1 -> 3 -> 1 -> 1 -> 1, with a total cost of 7)\n\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g(grid: List[List[int]] = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) -> List[List[int]]:\n    return grid\n\nassert f(*g()) == 7\n\n", "emb": null, "idx_generation": 494, "target_skills": [1, 1, 1, 0, 1, 1, 1, 0, 0, 1], "problem_func": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the shortest path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7 (as the shortest path is 1 -> 3 -> 1 -> 1 -> 1, with a total cost of 7)\n\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]", "solution_func": "def g(grid: List[List[int]] = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) -> List[List[int]]:\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target integer, find the number of ways to sum the integers in the list to reach the target.\n\n    Example:\n    nums = [1, 2, 3], target = 4\n\n    Output:\n    7 (as there are 7 ways to sum the integers in the list to reach 4: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2], [3, 1], [1, 3])\n    \"\"\"\n    def count_sum_combinations(nums, target, memo):\n        if target == 0:\n            return 1\n        if target < 0:\n            return 0\n        if target in memo:\n            return memo[target]\n        \n        num_combinations = 0\n        for num in nums:\n            num_combinations += count_sum_combinations(nums, target - num, memo)\n        \n        memo[target] = num_combinations\n        return num_combinations\n    \n    return count_sum_combinations(nums, target, {})\n\ndef g(nums: List[int] = [1, 2, 3], target: int = 4) -> Tuple[List[int], int]:\n    return nums, target\n\nassert f(*g()) == 7\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 494, "target_skills": [0, 0, 1, 1, 1, 1, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target integer, find the number of ways to sum the integers in the list to reach the target.\n\n    Example:\n    nums = [1, 2, 3], target = 4\n\n    Output:\n    7 (as there are 7 ways to sum the integers in the list to reach 4: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2], [3, 1], [1, 3])\n    \"\"\"\n    def count_sum_combinations(nums, target, memo):\n        if target == 0:\n            return 1\n        if target < 0:\n            return 0\n        if target in memo:\n            return memo[target]\n        \n        num_combinations = 0\n        for num in nums:\n            num_combinations += count_sum_combinations(nums, target - num, memo)\n        \n        memo[target] = num_combinations\n        return num_combinations\n    \n    return count_sum_combinations(nums, target, {})", "solution_func": "def g(nums: List[int] = [1, 2, 3], target: int = 4) -> Tuple[List[int], int]:\n    return nums, target", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of perfect squares in the list.\n\n    Example:\n    Input: [1, 4, 7, 9, 16, 20]\n    Output: 2\n    Explanation: The perfect squares in the list are 1 and 16.\n    \"\"\"\n    count = 0\n\n    for num in arr:\n        if num >= 0 and int(num ** 0.5) ** 2 == num:\n            count += 1\n\n    return count\n\ndef g(arr: List[int] = [1, 4, 7, 9, 16, 20]):\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return arr\n\nassert f(g()) == 2\n\n", "emb": null, "idx_generation": 494, "target_skills": [1, 1, 0, 0, 0, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of perfect squares in the list.\n\n    Example:\n    Input: [1, 4, 7, 9, 16, 20]\n    Output: 2\n    Explanation: The perfect squares in the list are 1 and 16.\n    \"\"\"\n    count = 0\n\n    for num in arr:\n        if num >= 0 and int(num ** 0.5) ** 2 == num:\n            count += 1\n\n    return count", "solution_func": "def g(arr: List[int] = [1, 4, 7, 9, 16, 20]):\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return arr", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of ways to divide the list into two non-empty parts such that the sum of elements in each part is equal.\n\n    Example:\n    Input: [1, 5, 3, 2, 4]\n    Output: 2\n    Explanation: The two possible divisions are [1, 5] and [3, 2, 4], both of which have a sum of 6.\n    \"\"\"\n    total_sum = sum(arr)\n    target_sum = total_sum / 2\n    count = 0\n\n    if total_sum % 2 != 0:\n        return 0\n\n    for i in range(1, len(arr)):\n        prefix_sum = sum(arr[:i])\n        if prefix_sum == target_sum:\n            count += 1\n\n    return count\n\ndef g(arr: List[int] = [1, 5, 3, 2, 4]):\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return arr\n\nassert f(g()) == 2\n\n", "emb": null, "idx_generation": 494, "target_skills": [1, 1, 1, 0, 1, 1, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of ways to divide the list into two non-empty parts such that the sum of elements in each part is equal.\n\n    Example:\n    Input: [1, 5, 3, 2, 4]\n    Output: 2\n    Explanation: The two possible divisions are [1, 5] and [3, 2, 4], both of which have a sum of 6.\n    \"\"\"\n    total_sum = sum(arr)\n    target_sum = total_sum / 2\n    count = 0\n\n    if total_sum % 2 != 0:\n        return 0\n\n    for i in range(1, len(arr)):\n        prefix_sum = sum(arr[:i])\n        if prefix_sum == target_sum:\n            count += 1\n\n    return count", "solution_func": "def g(arr: List[int] = [1, 5, 3, 2, 4]):\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return arr", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find all pairs of numbers in the list whose sum is a power of 2.\n\n    Example:\n    Input: [1, 3, 2, 5, 8]\n    Output: [(1, 7), (2, 6), (3, 5)]\n    Explanation: The pairs whose sum is a power of 2 are (1, 7), (2, 6), and (3, 5).\n\n    Note: The pairs should be returned in ascending order of the first element.\n    \"\"\"\n    powers_of_two = set()\n    for i in range(31):\n        powers_of_two.add(2 ** i)\n\n    pairs = []\n\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] + arr[j] in powers_of_two:\n                pairs.append((arr[i], arr[j]))\n\n    return sorted(pairs)\n\ndef g(arr: List[int] = [1, 3, 2, 5, 8]):\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return arr\n\nassert f(g()) == [(1, 7), (2, 6), (3, 5)]\n\n", "emb": null, "idx_generation": 494, "target_skills": [1, 0, 1, 1, 0, 1, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find all pairs of numbers in the list whose sum is a power of 2.\n\n    Example:\n    Input: [1, 3, 2, 5, 8]\n    Output: [(1, 7), (2, 6), (3, 5)]\n    Explanation: The pairs whose sum is a power of 2 are (1, 7), (2, 6), and (3, 5).\n\n    Note: The pairs should be returned in ascending order of the first element.\n    \"\"\"\n    powers_of_two = set()\n    for i in range(31):\n        powers_of_two.add(2 ** i)\n\n    pairs = []\n\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] + arr[j] in powers_of_two:\n                pairs.append((arr[i], arr[j]))\n\n    return sorted(pairs)", "solution_func": "def g(arr: List[int] = [1, 3, 2, 5, 8]):\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return arr", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique permutations that can be formed\n    by selecting a subset of the numbers from the list.\n    \"\"\"\n    def backtrack(nums, subset, visited, result):\n        if len(subset) > 0:\n            result.append(subset[:])\n        for i in range(len(nums)):\n            if visited[i] or (i > 0 and nums[i] == nums[i-1] and not visited[i-1]):\n                continue\n            visited[i] = True\n            subset.append(nums[i])\n            backtrack(nums, subset, visited, result)\n            visited[i] = False\n            subset.pop()\n\n    nums.sort()\n    result = []\n    visited = [False] * len(nums)\n    backtrack(nums, [], visited, result)\n    return len(result)\n\ndef g():\n    nums = [1, 2, 2]\n    return (nums,)\n\nassert f(*g()) == 4\n", "emb": null, "idx_generation": 494, "target_skills": [0, 1, 0, 1, 1, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique permutations that can be formed\n    by selecting a subset of the numbers from the list.\n    \"\"\"\n    def backtrack(nums, subset, visited, result):\n        if len(subset) > 0:\n            result.append(subset[:])\n        for i in range(len(nums)):\n            if visited[i] or (i > 0 and nums[i] == nums[i-1] and not visited[i-1]):\n                continue\n            visited[i] = True\n            subset.append(nums[i])\n            backtrack(nums, subset, visited, result)\n            visited[i] = False\n            subset.pop()\n\n    nums.sort()\n    result = []\n    visited = [False] * len(nums)\n    backtrack(nums, [], visited, result)\n    return len(result)", "solution_func": "def g():\n    nums = [1, 2, 2]\n    return (nums,)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a 2D matrix of integers and a target integer, determine if the target value exists in the matrix.\n\n    Example:\n    matrix = [\n        [1, 4, 7, 11, 15],\n        [2, 5, 8, 12, 19],\n        [3, 6, 9, 16, 22],\n        [10, 13, 14, 17, 24],\n        [18, 21, 23, 26, 30]\n    ]\n    target = 9\n\n    Output:\n    True\n\n    Explanation:\n    The target value 9 exists in the matrix.\n\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    # Start from top right corner of the matrix\n    row = 0\n    col = cols - 1\n\n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n\n    return False\n\ndef g(matrix=[\n    [1, 4, 7, 11, 15],\n    [2, 5, 8, 12, 19],\n    [3, 6, 9, 16, 22],\n    [10, 13, 14, 17, 24],\n    [18, 21, 23, 26, 30]\n], target=9):\n    return matrix, target\n\nassert f(*g()) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 495, "target_skills": [1, 1, 0, 0, 1, 0, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a 2D matrix of integers and a target integer, determine if the target value exists in the matrix.\n\n    Example:\n    matrix = [\n        [1, 4, 7, 11, 15],\n        [2, 5, 8, 12, 19],\n        [3, 6, 9, 16, 22],\n        [10, 13, 14, 17, 24],\n        [18, 21, 23, 26, 30]\n    ]\n    target = 9\n\n    Output:\n    True\n\n    Explanation:\n    The target value 9 exists in the matrix.\n\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    # Start from top right corner of the matrix\n    row = 0\n    col = cols - 1\n\n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n\n    return False", "solution_func": "def g(matrix=[\n    [1, 4, 7, 11, 15],\n    [2, 5, 8, 12, 19],\n    [3, 6, 9, 16, 22],\n    [10, 13, 14, 17, 24],\n    [18, 21, 23, 26, 30]\n], target=9):\n    return matrix, target", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[List[int]]:\n    \"\"\"\n    Given an array of integers nums and an integer k, return all possible combinations of k elements from the array.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    k = 2\n\n    Output:\n    [\n        [1, 2],\n        [1, 3],\n        [1, 4],\n        [2, 3],\n        [2, 4],\n        [3, 4]\n    ]\n\n    Explanation:\n    All possible combinations of 2 elements from the array are returned.\n\n    \"\"\"\n\n    result = []\n    def backtrack(curr_comb, start):\n        if len(curr_comb) == k:\n            result.append(curr_comb[:])\n            return\n\n        for i in range(start, len(nums)):\n            curr_comb.append(nums[i])\n            backtrack(curr_comb, i + 1)\n            curr_comb.pop()\n\n    backtrack([], 0)\n    return result\n\ndef g(nums=[1, 2, 3, 4], k=2):\n    return nums, k\n\nassert f(*g()) == [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 495, "target_skills": [1, 0, 0, 1, 1, 1, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[List[int]]:\n    \"\"\"\n    Given an array of integers nums and an integer k, return all possible combinations of k elements from the array.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    k = 2\n\n    Output:\n    [\n        [1, 2],\n        [1, 3],\n        [1, 4],\n        [2, 3],\n        [2, 4],\n        [3, 4]\n    ]\n\n    Explanation:\n    All possible combinations of 2 elements from the array are returned.\n\n    \"\"\"\n\n    result = []\n    def backtrack(curr_comb, start):\n        if len(curr_comb) == k:\n            result.append(curr_comb[:])\n            return\n\n        for i in range(start, len(nums)):\n            curr_comb.append(nums[i])\n            backtrack(curr_comb, i + 1)\n            curr_comb.pop()\n\n    backtrack([], 0)\n    return result", "solution_func": "def g(nums=[1, 2, 3, 4], k=2):\n    return nums, k", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers in non-decreasing order and a target value,\n    return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\n    Example:\n    nums = [1, 3, 5, 6]\n    target = 5\n\n    Output:\n    2\n\n    Explanation:\n    The target value 5 is found in the array at index 2.\n\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left\n\ndef g(nums=[1, 3, 5, 6], target=5):\n    return nums, target\n\nassert f(*g()) == 2\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 495, "target_skills": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers in non-decreasing order and a target value,\n    return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\n    Example:\n    nums = [1, 3, 5, 6]\n    target = 5\n\n    Output:\n    2\n\n    Explanation:\n    The target value 5 is found in the array at index 2.\n\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left", "solution_func": "def g(nums=[1, 3, 5, 6], target=5):\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there exists a subsequence (not necessarily contiguous) whose sum is equal to the target.\n    \"\"\"\n    def subset_sum(nums, target):\n        n = len(nums)\n        dp = [[False] * (target+1) for _ in range(n+1)]\n        for i in range(n+1):\n            dp[i][0] = True\n        for i in range(1, n+1):\n            for j in range(1, target+1):\n                if nums[i-1] <= j:\n                    dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i-1]]\n                else:\n                    dp[i][j] = dp[i-1][j]\n        return dp[n][target]\n    \n    return subset_sum(nums, target)\n\ndef g():\n    nums = [3, 5, 7, 9, 11]\n    target = 16\n    return nums, target\n\nassert f(*g())\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 495, "target_skills": [1, 0, 0, 0, 1, 1, 1, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there exists a subsequence (not necessarily contiguous) whose sum is equal to the target.\n    \"\"\"\n    def subset_sum(nums, target):\n        n = len(nums)\n        dp = [[False] * (target+1) for _ in range(n+1)]\n        for i in range(n+1):\n            dp[i][0] = True\n        for i in range(1, n+1):\n            for j in range(1, target+1):\n                if nums[i-1] <= j:\n                    dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i-1]]\n                else:\n                    dp[i][j] = dp[i-1][j]\n        return dp[n][target]\n    \n    return subset_sum(nums, target)", "solution_func": "def g():\n    nums = [3, 5, 7, 9, 11]\n    target = 16\n    return nums, target", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome after removing exactly one character.\n    \"\"\"\n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    for i in range(len(s)):\n        temp = s[:i] + s[i+1:]\n        if is_palindrome(temp):\n            return True\n    return False\n\ndef g():\n    s = \"level\"\n    return s\n\nassert f(g())\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0], "idx_generation": 495, "target_skills": [0, 1, 1, 0, 0, 1, 1, 1, 1, 1], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome after removing exactly one character.\n    \"\"\"\n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    for i in range(len(s)):\n        temp = s[:i] + s[i+1:]\n        if is_palindrome(temp):\n            return True\n    return False", "solution_func": "def g():\n    s = \"level\"\n    return s", "map_ix": [1, 1, 0, 1, 0, 1, 0, 1, 1, 1]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, modify the list in-place so that every odd element is replaced with the next even element.\n    \"\"\"\n    i = 0\n    while i < len(nums):\n        if nums[i] % 2 != 0:\n            j = i + 1\n            while j < len(nums) and nums[j] % 2 == 0:\n                j += 1\n            if j < len(nums):\n                nums[i] = nums[j]\n            else:\n                break\n        i += 1\n    return nums\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    return nums\n\nassert f(g()) == [2, 2, 4, 4, 6, 6, 8, 8, 9]\n", "emb": null, "idx_generation": 495, "target_skills": [1, 1, 1, 0, 0, 0, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, modify the list in-place so that every odd element is replaced with the next even element.\n    \"\"\"\n    i = 0\n    while i < len(nums):\n        if nums[i] % 2 != 0:\n            j = i + 1\n            while j < len(nums) and nums[j] % 2 == 0:\n                j += 1\n            if j < len(nums):\n                nums[i] = nums[j]\n            else:\n                break\n        i += 1\n    return nums", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of all the elements in the original list\n    that are smaller than it.\n\n    Example:\n    nums = [4, 2, 9, 7, 5]\n    The sums of the elements smaller than 4 are 2 and 4, so the first element in the new list is 6.\n    The sums of the elements smaller than 2 are [], so the second element in the new list is 0.\n    The sums of the elements smaller than 9 are 4, 2, 7, and 5, so the third element in the new list is 18.\n    The sums of the elements smaller than 7 are 4, 2, and 5, so the fourth element in the new list is 11.\n    The sums of the elements smaller than 5 are 4 and 2, so the fifth element in the new list is 6.\n\n    Therefore, the function should return [6, 0, 18, 11, 6].\n    \"\"\"\n    sorted_nums = sorted(nums)\n    prefix_sum = [0] * len(sorted_nums)\n\n    for i in range(1, len(sorted_nums)):\n        prefix_sum[i] = prefix_sum[i - 1] + sorted_nums[i - 1]\n    \n    new_nums = []\n    for num in nums:\n        index = sorted_nums.index(num)\n        new_nums.append(prefix_sum[index])\n    \n    return new_nums\n\ndef g() -> List[int]:\n    nums = [4, 2, 9, 7, 5]\n    return nums\n\nassert f(g()) == [6, 0, 18, 11, 6]\n", "emb": null, "idx_generation": 495, "target_skills": [1, 1, 1, 1, 0, 1, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of all the elements in the original list\n    that are smaller than it.\n\n    Example:\n    nums = [4, 2, 9, 7, 5]\n    The sums of the elements smaller than 4 are 2 and 4, so the first element in the new list is 6.\n    The sums of the elements smaller than 2 are [], so the second element in the new list is 0.\n    The sums of the elements smaller than 9 are 4, 2, 7, and 5, so the third element in the new list is 18.\n    The sums of the elements smaller than 7 are 4, 2, and 5, so the fourth element in the new list is 11.\n    The sums of the elements smaller than 5 are 4 and 2, so the fifth element in the new list is 6.\n\n    Therefore, the function should return [6, 0, 18, 11, 6].\n    \"\"\"\n    sorted_nums = sorted(nums)\n    prefix_sum = [0] * len(sorted_nums)\n\n    for i in range(1, len(sorted_nums)):\n        prefix_sum[i] = prefix_sum[i - 1] + sorted_nums[i - 1]\n    \n    new_nums = []\n    for num in nums:\n        index = sorted_nums.index(num)\n        new_nums.append(prefix_sum[index])\n    \n    return new_nums", "solution_func": "def g() -> List[int]:\n    nums = [4, 2, 9, 7, 5]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of subarrays whose sum is divisible by k.\n\n    Example:\n    nums = [4, 5, 0, -2, -3, 1], k = 5\n    There are 7 subarrays whose sum is divisible by 5: [4, 5, 0, -2, -3, 1], [5], [5, 0], [0, -2, -3], [-2, -3, 1],\n    [4, 5, 0, -2, -3, 1], [5].\n\n    Therefore, the function should return 7.\n    \"\"\"\n    prefix_sum = 0\n    count = 0\n    prefix_sums = {0: 1}\n\n    for num in nums:\n        prefix_sum = (prefix_sum + num) % k\n        count += prefix_sums.get(prefix_sum, 0)\n        prefix_sums[prefix_sum] = prefix_sums.get(prefix_sum, 0) + 1\n    \n    return count\n\ndef g() -> List[int]:\n    nums = [4, 5, 0, -2, -3, 1]\n    k = 5\n    return nums, k\n\nassert f(*g()) == 7\n", "emb": null, "idx_generation": 495, "target_skills": [0, 1, 1, 1, 1, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of subarrays whose sum is divisible by k.\n\n    Example:\n    nums = [4, 5, 0, -2, -3, 1], k = 5\n    There are 7 subarrays whose sum is divisible by 5: [4, 5, 0, -2, -3, 1], [5], [5, 0], [0, -2, -3], [-2, -3, 1],\n    [4, 5, 0, -2, -3, 1], [5].\n\n    Therefore, the function should return 7.\n    \"\"\"\n    prefix_sum = 0\n    count = 0\n    prefix_sums = {0: 1}\n\n    for num in nums:\n        prefix_sum = (prefix_sum + num) % k\n        count += prefix_sums.get(prefix_sum, 0)\n        prefix_sums[prefix_sum] = prefix_sums.get(prefix_sum, 0) + 1\n    \n    return count", "solution_func": "def g() -> List[int]:\n    nums = [4, 5, 0, -2, -3, 1]\n    k = 5\n    return nums, k", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the elements in the original list\n    except for the current element.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    The product of all the elements in the original list except for 1 is 2 * 3 * 4 = 24, so the first element in the new\n    list is 24.\n    The product of all the elements in the original list except for 2 is 1 * 3 * 4 = 12, so the second element in the new\n    list is 12.\n    The product of all the elements in the original list except for 3 is 1 * 2 * 4 = 8, so the third element in the new\n    list is 8.\n    The product of all the elements in the original list except for 4 is 1 * 2 * 3 = 6, so the fourth element in the new\n    list is 6.\n\n    Therefore, the function should return [24, 12, 8, 6].\n    \"\"\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n\n    new_nums = []\n    for num in nums:\n        new_nums.append(total_product // num)\n\n    return new_nums\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == [24, 12, 8, 6]\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 495, "target_skills": [0, 1, 1, 1, 1, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the elements in the original list\n    except for the current element.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    The product of all the elements in the original list except for 1 is 2 * 3 * 4 = 24, so the first element in the new\n    list is 24.\n    The product of all the elements in the original list except for 2 is 1 * 3 * 4 = 12, so the second element in the new\n    list is 12.\n    The product of all the elements in the original list except for 3 is 1 * 2 * 4 = 8, so the third element in the new\n    list is 8.\n    The product of all the elements in the original list except for 4 is 1 * 2 * 3 = 6, so the fourth element in the new\n    list is 6.\n\n    Therefore, the function should return [24, 12, 8, 6].\n    \"\"\"\n    total_product = 1\n    for num in nums:\n        total_product *= num\n\n    new_nums = []\n    for num in nums:\n        new_nums.append(total_product // num)\n\n    return new_nums", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4]\n    return nums", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list\n    using binary search. If the target value is not present in the list, return -1.\n\n    Example:\n    Input: nums = [1, 3, 5, 7, 9], target = 5\n    Output: 2\n    Explanation:\n    The target value 5 is present at index 2 in the list.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    return ([1, 3, 5, 7, 9], 5)\n\nassert f(*g()) == 2\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 495, "target_skills": [0, 0, 0, 1, 1, 1, 1, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list\n    using binary search. If the target value is not present in the list, return -1.\n\n    Example:\n    Input: nums = [1, 3, 5, 7, 9], target = 5\n    Output: 2\n    Explanation:\n    The target value 5 is present at index 2 in the list.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1", "solution_func": "def g() -> Tuple[List[int], int]:\n    return ([1, 3, 5, 7, 9], 5)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers 'arr', check if the sum of any three consecutive elements in the list is prime.\n    Return True if such a sum exists, otherwise return False.\n\n    Example:\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    Output:\n    True\n\n    Explanation:\n    The sum of the three consecutive elements [2, 3, 4] is 9, which is a prime number.\n    \"\"\"\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    for i in range(len(arr) - 2):\n        if is_prime(sum(arr[i:i+3])):\n            return True\n\n    return False\n\ndef g() -> List[int]:\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    return arr\n\nassert f(g()) == True\n\n", "emb": null, "idx_generation": 496, "target_skills": [1, 0, 0, 1, 1, 1, 1, 1, 1, 1], "problem_func": "from typing import*\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers 'arr', check if the sum of any three consecutive elements in the list is prime.\n    Return True if such a sum exists, otherwise return False.\n\n    Example:\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    Output:\n    True\n\n    Explanation:\n    The sum of the three consecutive elements [2, 3, 4] is 9, which is a prime number.\n    \"\"\"\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    for i in range(len(arr) - 2):\n        if is_prime(sum(arr[i:i+3])):\n            return True\n\n    return False", "solution_func": "def g() -> List[int]:\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    return arr", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(s: str, k: int) -> int:\n    \"\"\"\n    Given a string 's' consisting of lowercase English letters, return the length of the longest substring that contains at most 'k' distinct characters.\n\n    Example:\n    s = \"abaccc\"\n    k = 2\n\n    Output:\n    4\n\n    Explanation:\n    The longest substring with at most 2 distinct characters is \"abac\", which has a length of 4.\n    \"\"\"\n\n    if k == 0:\n        return 0\n\n    counts = {}\n    max_length = 0\n    left = 0\n    right = 0\n\n    while right < len(s):\n        counts[s[right]] = counts.get(s[right], 0) + 1\n\n        if len(counts) <= k:\n            max_length = max(max_length, right - left + 1)\n        else:\n            counts[s[left]] -= 1\n            if counts[s[left]] == 0:\n                del counts[s[left]]\n            left += 1\n\n        right += 1\n\n    return max_length\n\ndef g() -> Tuple[str, int]:\n    s = \"abaccc\"\n    k = 2\n    return s, k\n\nassert f(*g()) == 4\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 496, "target_skills": [1, 0, 1, 1, 0, 0, 1, 1, 1, 1], "problem_func": "from typing import*\n\ndef f(s: str, k: int) -> int:\n    \"\"\"\n    Given a string 's' consisting of lowercase English letters, return the length of the longest substring that contains at most 'k' distinct characters.\n\n    Example:\n    s = \"abaccc\"\n    k = 2\n\n    Output:\n    4\n\n    Explanation:\n    The longest substring with at most 2 distinct characters is \"abac\", which has a length of 4.\n    \"\"\"\n\n    if k == 0:\n        return 0\n\n    counts = {}\n    max_length = 0\n    left = 0\n    right = 0\n\n    while right < len(s):\n        counts[s[right]] = counts.get(s[right], 0) + 1\n\n        if len(counts) <= k:\n            max_length = max(max_length, right - left + 1)\n        else:\n            counts[s[left]] -= 1\n            if counts[s[left]] == 0:\n                del counts[s[left]]\n            left += 1\n\n        right += 1\n\n    return max_length", "solution_func": "def g() -> Tuple[str, int]:\n    s = \"abaccc\"\n    k = 2\n    return s, k", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\n\nclass Stack:\n    def __init__(self):\n        self.stack = []\n\n    def push(self, x):\n        self.stack.append(x)\n\n    def pop(self):\n        if self.stack:\n            return self.stack.pop()\n        else:\n            return None\n\n    def top(self):\n        if self.stack:\n            return self.stack[-1]\n        else:\n            return None\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string 's' containing only parentheses '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n    An input string is valid if:\n    1. Open brackets must be closed by the same type of brackets.\n    2. Open brackets must be closed in the correct order.\n\n    Example:\n    s = \"([]){}\"\n\n    Output:\n    True\n\n    Explanation:\n    The input string is valid because all open brackets are correctly closed in the right order.\n    \"\"\"\n\n    stack = Stack()\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n\n    for char in s:\n        if char in mapping:\n            if stack.is_empty() or stack.pop() != mapping[char]:\n                return False\n        else:\n            stack.push(char)\n\n    return stack.is_empty()\n\ndef g() -> str:\n    s = \"([]){}\"\n    return s\n\nassert f(g()) == True\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 496, "target_skills": [1, 1, 1, 1, 1, 0, 0, 1, 0, 1], "problem_func": "from typing import*\n\nclass Stack:\n    def __init__(self):\n        self.stack = []\n\n    def push(self, x):\n        self.stack.append(x)\n\n    def pop(self):\n        if self.stack:\n            return self.stack.pop()\n        else:\n            return None\n\n    def top(self):\n        if self.stack:\n            return self.stack[-1]\n        else:\n            return None\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string 's' containing only parentheses '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n    An input string is valid if:\n    1. Open brackets must be closed by the same type of brackets.\n    2. Open brackets must be closed in the correct order.\n\n    Example:\n    s = \"([]){}\"\n\n    Output:\n    True\n\n    Explanation:\n    The input string is valid because all open brackets are correctly closed in the right order.\n    \"\"\"\n\n    stack = Stack()\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n\n    for char in s:\n        if char in mapping:\n            if stack.is_empty() or stack.pop() != mapping[char]:\n                return False\n        else:\n            stack.push(char)\n\n    return stack.is_empty()", "solution_func": "def g() -> str:\n    s = \"([]){}\"\n    return s", "map_ix": [1, 1, 0, 0, 0, 1, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, sort each row in ascending order.\n\n    Args:\n    - matrix: A matrix of integers.\n\n    Returns:\n    - A matrix with each row sorted in ascending order.\n\n    Example:\n    matrix = [\n        [3, 2, 1],\n        [6, 5, 4],\n        [9, 8, 7]\n    ]\n\n    Output:\n    [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    \"\"\"\n    for row in matrix:\n        row.sort()\n    \n    return matrix\n\ndef g(matrix=[[3, 2, 1], [6, 5, 4], [9, 8, 7]]):\n    \"\"\"\n    Generate a matrix of integers.\n    \"\"\"\n    return matrix\n\nassert f(g()) == [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 496, "target_skills": [0, 1, 0, 0, 0, 0, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, sort each row in ascending order.\n\n    Args:\n    - matrix: A matrix of integers.\n\n    Returns:\n    - A matrix with each row sorted in ascending order.\n\n    Example:\n    matrix = [\n        [3, 2, 1],\n        [6, 5, 4],\n        [9, 8, 7]\n    ]\n\n    Output:\n    [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    \"\"\"\n    for row in matrix:\n        row.sort()\n    \n    return matrix", "solution_func": "def g(matrix=[[3, 2, 1], [6, 5, 4], [9, 8, 7]]):\n    \"\"\"\n    Generate a matrix of integers.\n    \"\"\"\n    return matrix", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all even numbers from 1 to n (inclusive).\n\n    Args:\n    - n: A positive integer.\n\n    Returns:\n    - The sum of all even numbers from 1 to n.\n\n    Example:\n    n = 10\n\n    Output:\n    30\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n % 2 == 0:\n        return n + f(n-2)\n    else:\n        return f(n-1)\n\ndef g(n=10):\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return n\n\nassert f(g()) == 30\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 496, "target_skills": [1, 1, 1, 1, 0, 1, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all even numbers from 1 to n (inclusive).\n\n    Args:\n    - n: A positive integer.\n\n    Returns:\n    - The sum of all even numbers from 1 to n.\n\n    Example:\n    n = 10\n\n    Output:\n    30\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n % 2 == 0:\n        return n + f(n-2)\n    else:\n        return f(n-1)", "solution_func": "def g(n=10):\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Args:\n    - grid: A grid of integers.\n\n    Returns:\n    - The maximum sum of a path from the top-left cell to the bottom-right cell.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n    Explanation: The maximum sum of a path from the top-left cell (1) to the bottom-right cell (1) is 7 (1 + 3 + 1 + 1 + 1).\n\n    Hint: You can solve this problem using dynamic programming.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return grid\n\nassert f(g()) == 7\n", "emb": null, "idx_generation": 496, "target_skills": [1, 1, 0, 1, 0, 1, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Args:\n    - grid: A grid of integers.\n\n    Returns:\n    - The maximum sum of a path from the top-left cell to the bottom-right cell.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n    Explanation: The maximum sum of a path from the top-left cell (1) to the bottom-right cell (1) is 7 (1 + 3 + 1 + 1 + 1).\n\n    Hint: You can solve this problem using dynamic programming.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]", "solution_func": "def g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Args:\n    - nums: A list of integers\n\n    Returns:\n    - The maximum product of any two distinct numbers in the list.\n    \"\"\"\n    n = len(nums)\n    max_product = float('-inf')\n\n    for i in range(n):\n        for j in range(i+1, n):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n\n    return max_product\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 20\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 496, "target_skills": [1, 1, 1, 0, 0, 0, 1, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Args:\n    - nums: A list of integers\n\n    Returns:\n    - The maximum product of any two distinct numbers in the list.\n    \"\"\"\n    n = len(nums)\n    max_product = float('-inf')\n\n    for i in range(n):\n        for j in range(i+1, n):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n\n    return max_product", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of the first n natural numbers.\n\n    Args:\n    - n: A positive integer\n\n    Returns:\n    - The sum of the first n natural numbers.\n    \"\"\"\n    if n == 1:\n        return 1\n    else:\n        return n + f(n-1)\n\ndef g() -> int:\n    n = 5\n    return n\n\nassert f(g()) == 15\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 496, "target_skills": [1, 1, 1, 1, 1, 0, 0, 1, 0, 1], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of the first n natural numbers.\n\n    Args:\n    - n: A positive integer\n\n    Returns:\n    - The sum of the first n natural numbers.\n    \"\"\"\n    if n == 1:\n        return 1\n    else:\n        return n + f(n-1)", "solution_func": "def g() -> int:\n    n = 5\n    return n", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n\n    Args:\n    - nums: A sorted list of integers\n    - target: The target value to search for\n\n    Returns:\n    - The index of the target value in the list, or -1 if the target value is not found.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target\n\nassert f(*g()) == 2\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 496, "target_skills": [1, 1, 1, 0, 1, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n\n    Args:\n    - nums: A sorted list of integers\n    - target: The target value to search for\n\n    Returns:\n    - The index of the target value in the list, or -1 if the target value is not found.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target integer, find the number of unique combinations of nums that sum up to the target.\n    Each number in nums can be used an unlimited number of times.\n\n    Example:\n    nums = [1, 2, 3]\n    target = 4\n\n    The unique combinations that sum up to 4 are:\n    [1, 1, 1, 1]\n    [1, 1, 2]\n    [1, 3]\n    [2, 2]\n\n    Therefore, the output should be 4.\n    \"\"\"\n\n    def backtrack(combination, remaining):\n        if remaining == 0:\n            return 1\n        if remaining < 0:\n            return 0\n\n        count = 0\n        for num in nums:\n            if num > remaining:\n                break\n            count += backtrack(combination + [num], remaining - num)\n        \n        return count\n\n    return backtrack([], target)\n\ndef g():\n    nums = [1, 2, 3]\n    target = 4\n    return nums, target\n\nassert f(*g()) == 4\n", "emb": null, "idx_generation": 496, "target_skills": [1, 1, 0, 1, 1, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target integer, find the number of unique combinations of nums that sum up to the target.\n    Each number in nums can be used an unlimited number of times.\n\n    Example:\n    nums = [1, 2, 3]\n    target = 4\n\n    The unique combinations that sum up to 4 are:\n    [1, 1, 1, 1]\n    [1, 1, 2]\n    [1, 3]\n    [2, 2]\n\n    Therefore, the output should be 4.\n    \"\"\"\n\n    def backtrack(combination, remaining):\n        if remaining == 0:\n            return 1\n        if remaining < 0:\n            return 0\n\n        count = 0\n        for num in nums:\n            if num > remaining:\n                break\n            count += backtrack(combination + [num], remaining - num)\n        \n        return count\n\n    return backtrack([], target)", "solution_func": "def g():\n    nums = [1, 2, 3]\n    target = 4\n    return nums, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the list.\n\n    Args:\n    - nums: A list of integers.\n    - target: The target value.\n\n    Returns:\n    - A list containing the indices of the two numbers that add up to the target.\n    \"\"\"\n    complement_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complement_map:\n            return [complement_map[complement], i]\n        complement_map[num] = i\n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9) -> List[int]:\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 497, "target_skills": [1, 0, 1, 1, 1, 1, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the list.\n\n    Args:\n    - nums: A list of integers.\n    - target: The target value.\n\n    Returns:\n    - A list containing the indices of the two numbers that add up to the target.\n    \"\"\"\n    complement_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complement_map:\n            return [complement_map[complement], i]\n        complement_map[num] = i\n    return []", "solution_func": "def g(nums=[2, 7, 11, 15], target=9) -> List[int]:\n    return nums, target", "map_ix": [1, 1, 0, 0, 0, 1, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], pattern: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a pattern string, return a new list of words that match the pattern.\n    A word matches the pattern if there is a one-to-one mapping between its characters and the pattern characters,\n    such that the same pattern character is always mapped to the same word character.\n\n    Args:\n    - words: A list of strings.\n    - pattern: The pattern string.\n\n    Returns:\n    - A new list of words that match the pattern.\n    \"\"\"\n    def match(word, pattern):\n        if len(word) != len(pattern):\n            return False\n        word_to_pattern = {}\n        pattern_to_word = {}\n        for w, p in zip(word, pattern):\n            if w in word_to_pattern and word_to_pattern[w] != p:\n                return False\n            if p in pattern_to_word and pattern_to_word[p] != w:\n                return False\n            word_to_pattern[w] = p\n            pattern_to_word[p] = w\n        return True\n\n    return [word for word in words if match(word, pattern)]\n\ndef g(words=[\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern=\"abb\") -> List[str]:\n    return words, pattern\n\nassert f(*g()) == [\"mee\", \"aqq\"]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 497, "target_skills": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], pattern: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a pattern string, return a new list of words that match the pattern.\n    A word matches the pattern if there is a one-to-one mapping between its characters and the pattern characters,\n    such that the same pattern character is always mapped to the same word character.\n\n    Args:\n    - words: A list of strings.\n    - pattern: The pattern string.\n\n    Returns:\n    - A new list of words that match the pattern.\n    \"\"\"\n    def match(word, pattern):\n        if len(word) != len(pattern):\n            return False\n        word_to_pattern = {}\n        pattern_to_word = {}\n        for w, p in zip(word, pattern):\n            if w in word_to_pattern and word_to_pattern[w] != p:\n                return False\n            if p in pattern_to_word and pattern_to_word[p] != w:\n                return False\n            word_to_pattern[w] = p\n            pattern_to_word[p] = w\n        return True\n\n    return [word for word in words if match(word, pattern)]", "solution_func": "def g(words=[\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern=\"abb\") -> List[str]:\n    return words, pattern", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, determine the number of islands in the grid.\n    An island is formed by connected land cells (represented by '1') that are adjacent horizontally or vertically.\n    Assume the grid is surrounded by water cells (represented by '0').\n\n    Args:\n    - grid: A 2D grid of characters.\n\n    Returns:\n    - The number of islands in the grid.\n    \"\"\"\n    def dfs(grid, i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != '1':\n            return\n        grid[i][j] = '0'\n        dfs(grid, i-1, j)\n        dfs(grid, i+1, j)\n        dfs(grid, i, j-1)\n        dfs(grid, i, j+1)\n\n    if not grid or not grid[0]:\n        return 0\n\n    num_islands = 0\n    rows = len(grid)\n    cols = len(grid[0])\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == '1':\n                num_islands += 1\n                dfs(grid, i, j)\n\n    return num_islands\n\ndef g(grid=[['1','1','1','1','0'],\n            ['1','1','0','1','0'],\n            ['1','1','0','0','0'],\n            ['0','0','0','0','0']]) -> List[List[str]]:\n    return grid\n\nassert f(*g()) == 1\n", "emb": null, "idx_generation": 497, "target_skills": [1, 1, 1, 0, 0, 0, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, determine the number of islands in the grid.\n    An island is formed by connected land cells (represented by '1') that are adjacent horizontally or vertically.\n    Assume the grid is surrounded by water cells (represented by '0').\n\n    Args:\n    - grid: A 2D grid of characters.\n\n    Returns:\n    - The number of islands in the grid.\n    \"\"\"\n    def dfs(grid, i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != '1':\n            return\n        grid[i][j] = '0'\n        dfs(grid, i-1, j)\n        dfs(grid, i+1, j)\n        dfs(grid, i, j-1)\n        dfs(grid, i, j+1)\n\n    if not grid or not grid[0]:\n        return 0\n\n    num_islands = 0\n    rows = len(grid)\n    cols = len(grid[0])\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == '1':\n                num_islands += 1\n                dfs(grid, i, j)\n\n    return num_islands", "solution_func": "def g(grid=[['1','1','1','1','0'],\n            ['1','1','0','1','0'],\n            ['1','1','0','0','0'],\n            ['0','0','0','0','0']]) -> List[List[str]]:\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n    \n    Output:\n    28\n    \"\"\"\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n    \n    return max_xor\n\ndef g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 497, "target_skills": [0, 0, 1, 1, 0, 0, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n    \n    Output:\n    28\n    \"\"\"\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n    \n    return max_xor", "solution_func": "def g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums', return the list with the duplicate numbers removed.\n\n    Example:\n    nums = [1, 2, 3, 2, 4, 3, 5]\n    \n    Output:\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    unique_nums = []\n\n    for num in nums:\n        if num not in unique_nums:\n            unique_nums.append(num)\n    \n    return unique_nums\n\ndef g() -> List[int]:\n    return [1, 2, 3, 2, 4, 3, 5]\n\nassert f(g()) == [1, 2, 3, 4, 5]\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 497, "target_skills": [0, 0, 1, 1, 1, 0, 0, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums', return the list with the duplicate numbers removed.\n\n    Example:\n    nums = [1, 2, 3, 2, 4, 3, 5]\n    \n    Output:\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    unique_nums = []\n\n    for num in nums:\n        if num not in unique_nums:\n            unique_nums.append(num)\n    \n    return unique_nums", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3, 2, 4, 3, 5]", "map_ix": [1, 1, 0, 0, 0, 1, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer 'n', determine if it is a prime number.\n\n    Example:\n    n = 17\n    \n    Output:\n    True\n    \"\"\"\n    if n <= 1:\n        return False\n    \n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    \n    return True\n\ndef g() -> int:\n    return 17\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 497, "target_skills": [1, 0, 1, 0, 1, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer 'n', determine if it is a prime number.\n\n    Example:\n    n = 17\n    \n    Output:\n    True\n    \"\"\"\n    if n <= 1:\n        return False\n    \n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    \n    return True", "solution_func": "def g() -> int:\n    return 17", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return a new list where each element is the product of all the elements of nums except the corresponding element.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    [24, 12, 8, 6]\n\n    Explanation:\n    The product of all elements in nums except 1 is 2*3*4 = 24.\n    The product of all elements in nums except 2 is 1*3*4 = 12.\n    The product of all elements in nums except 3 is 1*2*4 = 8.\n    The product of all elements in nums except 4 is 1*2*3 = 6.\n    \"\"\"\n\n    n = len(nums)\n    prefix = [1] * n\n    suffix = [1] * n\n    result = [0] * n\n\n    for i in range(1, n):\n        prefix[i] = prefix[i - 1] * nums[i - 1]\n        suffix[n - i - 1] = suffix[n - i] * nums[n - i]\n\n    for i in range(n):\n        result[i] = prefix[i] * suffix[i]\n\n    return result\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4]\n\nassert f(g()) == [24, 12, 8, 6]\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 497, "target_skills": [1, 0, 0, 1, 0, 0, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import *\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return a new list where each element is the product of all the elements of nums except the corresponding element.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    [24, 12, 8, 6]\n\n    Explanation:\n    The product of all elements in nums except 1 is 2*3*4 = 24.\n    The product of all elements in nums except 2 is 1*3*4 = 12.\n    The product of all elements in nums except 3 is 1*2*4 = 8.\n    The product of all elements in nums except 4 is 1*2*3 = 6.\n    \"\"\"\n\n    n = len(nums)\n    prefix = [1] * n\n    suffix = [1] * n\n    result = [0] * n\n\n    for i in range(1, n):\n        prefix[i] = prefix[i - 1] * nums[i - 1]\n        suffix[n - i - 1] = suffix[n - i] * nums[n - i]\n\n    for i in range(n):\n        result[i] = prefix[i] * suffix[i]\n\n    return result", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3, 4]", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\ndef f(adj_list: Dict[int, List[int]]) -> List[int]:\n    \"\"\"\n    Given an adjacency list representation of a directed graph, return a list of nodes in the topological order.\n\n    Example:\n    adj_list = {\n        0: [1, 2],\n        1: [3],\n        2: [3],\n        3: []\n    }\n\n    Output:\n    [0, 2, 1, 3]\n\n    Explanation:\n    The topological order of the graph is [0, 2, 1, 3].\n    \"\"\"\n\n    def dfs(node, visited, stack):\n        visited[node] = True\n\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, stack)\n\n        stack.append(node)\n\n    n = len(adj_list)\n    visited = [False] * n\n    stack = []\n\n    for node in range(n):\n        if not visited[node]:\n            dfs(node, visited, stack)\n\n    return stack[::-1]\n\ndef g() -> Dict[int, List[int]]:\n    return {\n        0: [1, 2],\n        1: [3],\n        2: [3],\n        3: []\n    }\n\nassert f(g()) == [0, 2, 1, 3]\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 497, "target_skills": [0, 0, 1, 1, 0, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import *\ndef f(adj_list: Dict[int, List[int]]) -> List[int]:\n    \"\"\"\n    Given an adjacency list representation of a directed graph, return a list of nodes in the topological order.\n\n    Example:\n    adj_list = {\n        0: [1, 2],\n        1: [3],\n        2: [3],\n        3: []\n    }\n\n    Output:\n    [0, 2, 1, 3]\n\n    Explanation:\n    The topological order of the graph is [0, 2, 1, 3].\n    \"\"\"\n\n    def dfs(node, visited, stack):\n        visited[node] = True\n\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, stack)\n\n        stack.append(node)\n\n    n = len(adj_list)\n    visited = [False] * n\n    stack = []\n\n    for node in range(n):\n        if not visited[node]:\n            dfs(node, visited, stack)\n\n    return stack[::-1]", "solution_func": "def g() -> Dict[int, List[int]]:\n    return {\n        0: [1, 2],\n        1: [3],\n        2: [3],\n        3: []\n    }", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target sum, return True if there exists a subset of nums that adds up to the target sum, and False otherwise.\n\n    Example:\n    nums = [2, 4, 6, 8]\n    target = 10\n\n    Output:\n    True\n\n    Explanation:\n    There exists a subset [2, 8] in nums that adds up to the target sum 10.\n    \"\"\"\n\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if nums[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n\n    return dp[n][target]\n\ndef g() -> Tuple[List[int], int]:\n    return ([2, 4, 6, 8], 10)\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 497, "target_skills": [1, 1, 1, 1, 1, 0, 1, 0, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target sum, return True if there exists a subset of nums that adds up to the target sum, and False otherwise.\n\n    Example:\n    nums = [2, 4, 6, 8]\n    target = 10\n\n    Output:\n    True\n\n    Explanation:\n    There exists a subset [2, 8] in nums that adds up to the target sum 10.\n    \"\"\"\n\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if nums[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n\n    return dp[n][target]", "solution_func": "def g() -> Tuple[List[int], int]:\n    return ([2, 4, 6, 8], 10)", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the product of all the elements in the list.\n\n    Args:\n    - nums: The input list of integers.\n\n    Returns:\n    - The product of all the elements in the list.\n    \"\"\"\n    product = 1\n\n    for num in nums:\n        product *= num\n\n    return product\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g()) == 120\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 497, "target_skills": [0, 1, 0, 1, 1, 0, 0, 0, 1, 1], "problem_func": "from typing import*\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the product of all the elements in the list.\n\n    Args:\n    - nums: The input list of integers.\n\n    Returns:\n    - The product of all the elements in the list.\n    \"\"\"\n    product = 1\n\n    for num in nums:\n        product *= num\n\n    return product", "solution_func": "def g(nums=[1, 2, 3, 4, 5]):\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of pairs (i, j) where i < j and nums[i] + nums[j] is a power of 2.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The pairs (0, 2) and (1, 3) have a sum of 4, which is a power of 2. So the output should be 2.\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] + nums[j]) & (nums[i] + nums[j] - 1) == 0:\n                count += 1\n    return count\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return (nums,)\n\nassert f(*g()) == 2\n", "emb": [0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 498, "target_skills": [1, 1, 0, 0, 1, 1, 1, 1, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of pairs (i, j) where i < j and nums[i] + nums[j] is a power of 2.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The pairs (0, 2) and (1, 3) have a sum of 4, which is a power of 2. So the output should be 2.\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] + nums[j]) & (nums[i] + nums[j] - 1) == 0:\n                count += 1\n    return count", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return (nums,)", "map_ix": [0, 1, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import Tuple\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the number of distinct subsequences of s that are palindromes.\n\n    Example:\n    s = \"aab\"\n\n    The distinct subsequences that are palindromes are \"a\", \"a\", and \"aa\". So the output should be 3.\n    \"\"\"\n    def is_palindrome(sub: str) -> bool:\n        return sub == sub[::-1]\n\n    def count_subsequences(s: str) -> int:\n        if len(s) == 0:\n            return 1\n        if len(s) == 1:\n            return 2\n        if is_palindrome(s):\n            return 2 * count_subsequences(s[1:-1]) + 1\n        else:\n            return count_subsequences(s[:-1]) + count_subsequences(s[1:])\n\n    return count_subsequences(s)\n\ndef g():\n    s = \"aab\"\n    return (s,)\n\nassert f(*g()) == 3\n", "emb": null, "idx_generation": 498, "target_skills": [0, 0, 0, 1, 1, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import Tuple\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the number of distinct subsequences of s that are palindromes.\n\n    Example:\n    s = \"aab\"\n\n    The distinct subsequences that are palindromes are \"a\", \"a\", and \"aa\". So the output should be 3.\n    \"\"\"\n    def is_palindrome(sub: str) -> bool:\n        return sub == sub[::-1]\n\n    def count_subsequences(s: str) -> int:\n        if len(s) == 0:\n            return 1\n        if len(s) == 1:\n            return 2\n        if is_palindrome(s):\n            return 2 * count_subsequences(s[1:-1]) + 1\n        else:\n            return count_subsequences(s[:-1]) + count_subsequences(s[1:])\n\n    return count_subsequences(s)", "solution_func": "def g():\n    s = \"aab\"\n    return (s,)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid, find the minimum number of steps required to move from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    The minimum number of steps required is 7. So the output should be 7.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[rows - 1][cols - 1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 498, "target_skills": [1, 1, 0, 0, 1, 1, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid, find the minimum number of steps required to move from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    The minimum number of steps required is 7. So the output should be 7.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[rows - 1][cols - 1]", "solution_func": "def g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given an array of positive integers and a target number, determine if it is possible to obtain the target number\n    by performing bitwise OR operations on the elements of the array. Each element can be used multiple times.\n\n    Return True if it is possible to obtain the target number, False otherwise.\n\n    Example:\n    arr = [2, 4, 8]\n    target = 10\n\n    Output:\n    True\n\n    Explanation:\n    The target number 10 can be obtained by performing the bitwise OR operation on 2 (2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2) = 10.\n\n    Hint: Use dynamic programming to build the solution incrementally by checking if the target number can be obtained\n    using the previous results.\n    \"\"\"\n    dp = [False] * (target + 1)\n    dp[0] = True\n\n    for i in range(1, target + 1):\n        for num in arr:\n            if i >= num and dp[i - num]:\n                dp[i] = True\n                break\n\n    return dp[target]\n\ndef g():\n    arr = [2, 4, 8]\n    target = 10\n    return arr, target\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 498, "target_skills": [0, 1, 0, 1, 1, 1, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given an array of positive integers and a target number, determine if it is possible to obtain the target number\n    by performing bitwise OR operations on the elements of the array. Each element can be used multiple times.\n\n    Return True if it is possible to obtain the target number, False otherwise.\n\n    Example:\n    arr = [2, 4, 8]\n    target = 10\n\n    Output:\n    True\n\n    Explanation:\n    The target number 10 can be obtained by performing the bitwise OR operation on 2 (2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2) = 10.\n\n    Hint: Use dynamic programming to build the solution incrementally by checking if the target number can be obtained\n    using the previous results.\n    \"\"\"\n    dp = [False] * (target + 1)\n    dp[0] = True\n\n    for i in range(1, target + 1):\n        for num in arr:\n            if i >= num and dp[i - num]:\n                dp[i] = True\n                break\n\n    return dp[target]", "solution_func": "def g():\n    arr = [2, 4, 8]\n    target = 10\n    return arr, target", "map_ix": [0, 0, 0, 0, 1, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum sum of a subarray such that the sum is a power of two.\n\n    Return the maximum sum of a subarray that is a power of two.\n\n    Example:\n    nums = [4, 3, 2, 1, 5]\n\n    Output:\n    7\n\n    Explanation:\n    The maximum sum of a subarray that is a power of two is 7, which can be obtained from the subarray [3, 2, 1, 5].\n\n    Hint: Use dynamic programming to keep track of the maximum sum of a subarray ending at each index and check if\n    the sum is a power of two.\n    \"\"\"\n    max_sum = 0\n    prefix_sum = 0\n    prefix_sums = set([0])\n\n    for num in nums:\n        prefix_sum += num\n        for i in range(31):\n            desired_sum = 1 << i\n            if prefix_sum - desired_sum in prefix_sums:\n                max_sum = max(max_sum, prefix_sum - desired_sum)\n        prefix_sums.add(prefix_sum)\n\n    return max_sum\n\ndef g():\n    nums = [4, 3, 2, 1, 5]\n    return nums\n\nassert f(*g()) == 7\n", "emb": null, "idx_generation": 498, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum sum of a subarray such that the sum is a power of two.\n\n    Return the maximum sum of a subarray that is a power of two.\n\n    Example:\n    nums = [4, 3, 2, 1, 5]\n\n    Output:\n    7\n\n    Explanation:\n    The maximum sum of a subarray that is a power of two is 7, which can be obtained from the subarray [3, 2, 1, 5].\n\n    Hint: Use dynamic programming to keep track of the maximum sum of a subarray ending at each index and check if\n    the sum is a power of two.\n    \"\"\"\n    max_sum = 0\n    prefix_sum = 0\n    prefix_sums = set([0])\n\n    for num in nums:\n        prefix_sum += num\n        for i in range(31):\n            desired_sum = 1 << i\n            if prefix_sum - desired_sum in prefix_sums:\n                max_sum = max(max_sum, prefix_sum - desired_sum)\n        prefix_sums.add(prefix_sum)\n\n    return max_sum", "solution_func": "def g():\n    nums = [4, 3, 2, 1, 5]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> int:\n    \"\"\"\n    Given a list of words, find the length of the longest chain of words where each word can be obtained from the\n    previous word by adding or removing a single character.\n\n    Return the length of the longest chain of words.\n\n    Example:\n    words = [\"a\", \"ab\", \"abc\", \"abcd\", \"abcde\", \"abcdef\", \"abcdefg\"]\n\n    Output:\n    7\n\n    Explanation:\n    The longest chain of words is [\"a\", \"ab\", \"abc\", \"abcd\", \"abcde\", \"abcdef\", \"abcdefg\"].\n\n    Hint: Use dynamic programming to keep track of the longest chain of words ending at each index in the list.\n    \"\"\"\n    max_length = 0\n    word_lengths = {}\n\n    for word in sorted(words, key=lambda x: len(x)):\n        if word not in word_lengths:\n            word_lengths[word] = 1\n        for i in range(len(word)):\n            new_word = word[:i] + word[i + 1:]\n            if new_word in word_lengths:\n                word_lengths[word] = max(word_lengths[word], word_lengths[new_word] + 1)\n        max_length = max(max_length, word_lengths[word])\n\n    return max_length\n\ndef g():\n    words = [\"a\", \"ab\", \"abc\", \"abcd\", \"abcde\", \"abcdef\", \"abcdefg\"]\n    return words\n\nassert f(*g()) == 7\n", "emb": null, "idx_generation": 498, "target_skills": [0, 1, 1, 0, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> int:\n    \"\"\"\n    Given a list of words, find the length of the longest chain of words where each word can be obtained from the\n    previous word by adding or removing a single character.\n\n    Return the length of the longest chain of words.\n\n    Example:\n    words = [\"a\", \"ab\", \"abc\", \"abcd\", \"abcde\", \"abcdef\", \"abcdefg\"]\n\n    Output:\n    7\n\n    Explanation:\n    The longest chain of words is [\"a\", \"ab\", \"abc\", \"abcd\", \"abcde\", \"abcdef\", \"abcdefg\"].\n\n    Hint: Use dynamic programming to keep track of the longest chain of words ending at each index in the list.\n    \"\"\"\n    max_length = 0\n    word_lengths = {}\n\n    for word in sorted(words, key=lambda x: len(x)):\n        if word not in word_lengths:\n            word_lengths[word] = 1\n        for i in range(len(word)):\n            new_word = word[:i] + word[i + 1:]\n            if new_word in word_lengths:\n                word_lengths[word] = max(word_lengths[word], word_lengths[new_word] + 1)\n        max_length = max(max_length, word_lengths[word])\n\n    return max_length", "solution_func": "def g():\n    words = [\"a\", \"ab\", \"abc\", \"abcd\", \"abcde\", \"abcdef\", \"abcdefg\"]\n    return words", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target value, find two numbers in the list that add up to the target value.\n    \n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    \n    Output:\n    [2, 7]\n    \"\"\"\n    \n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        cur_sum = nums[left] + nums[right]\n        if cur_sum == target:\n            return [nums[left], nums[right]]\n        elif cur_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [2, 7]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 498, "target_skills": [1, 0, 1, 1, 0, 0, 1, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target value, find two numbers in the list that add up to the target value.\n    \n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    \n    Output:\n    [2, 7]\n    \"\"\"\n    \n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        cur_sum = nums[left] + nums[right]\n        if cur_sum == target:\n            return [nums[left], nums[right]]\n        elif cur_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []", "solution_func": "def g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Generate all possible paths on a grid from the top-left corner to the bottom-right corner.\n\n    Given a grid of size n x n, where each cell can be either 0 or 1, find all possible paths from the top-left corner to the bottom-right corner. You can only move down or right.\n\n    Example:\n    n = 3\n\n    Output:\n    [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ],\n    [\n        [0, 0, 0],\n        [0, 0, 0],\n        [0, 0, 0]\n    ]\n    ]\n\n    Constraints:\n    - The grid will always have a size of at least 1 x 1.\n    \"\"\"\n\n    def backtrack(row: int, col: int, path: List[List[int]]) -> None:\n        if row == n - 1 and col == n - 1:\n            paths.append(path)\n            return\n\n        if row < n - 1:\n            path_down = path.copy()\n            path_down[row + 1][col] = 1\n            backtrack(row + 1, col, path_down)\n\n        if col < n - 1:\n            path_right = path.copy()\n            path_right[row][col + 1] = 1\n            backtrack(row, col + 1, path_right)\n\n    paths = []\n    initial_path = [[0] * n for _ in range(n)]\n    initial_path[0][0] = 1\n    backtrack(0, 0, initial_path)\n\n    return paths\n\ndef g():\n    n = 3\n    return n\n\nassert f(g()) == [\n    [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ],\n    [\n        [0, 0, 0],\n        [0, 0, 0],\n        [0, 0, 0]\n    ]\n]\n", "emb": null, "idx_generation": 498, "target_skills": [0, 0, 1, 0, 1, 1, 1, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Generate all possible paths on a grid from the top-left corner to the bottom-right corner.\n\n    Given a grid of size n x n, where each cell can be either 0 or 1, find all possible paths from the top-left corner to the bottom-right corner. You can only move down or right.\n\n    Example:\n    n = 3\n\n    Output:\n    [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ],\n    [\n        [0, 0, 0],\n        [0, 0, 0],\n        [0, 0, 0]\n    ]\n    ]\n\n    Constraints:\n    - The grid will always have a size of at least 1 x 1.\n    \"\"\"\n\n    def backtrack(row: int, col: int, path: List[List[int]]) -> None:\n        if row == n - 1 and col == n - 1:\n            paths.append(path)\n            return\n\n        if row < n - 1:\n            path_down = path.copy()\n            path_down[row + 1][col] = 1\n            backtrack(row + 1, col, path_down)\n\n        if col < n - 1:\n            path_right = path.copy()\n            path_right[row][col + 1] = 1\n            backtrack(row, col + 1, path_right)\n\n    paths = []\n    initial_path = [[0] * n for _ in range(n)]\n    initial_path[0][0] = 1\n    backtrack(0, 0, initial_path)\n\n    return paths", "solution_func": "def g():\n    n = 3\n    return n", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], prefix: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a prefix, find all words in the list that start with the given prefix.\n\n    Example:\n    words = [\"apple\", \"banana\", \"cherry\", \"date\"]\n    prefix = \"b\"\n\n    Output:\n    [\"banana\"]\n\n    Constraints:\n    - The words list will contain at least one word.\n    - The prefix will be a non-empty string.\n    \"\"\"\n\n    def search_trie(node: dict, word: str) -> List[str]:\n        if not word:\n            return node[\"words\"]\n\n        char = word[0]\n        if char not in node:\n            return []\n\n        return search_trie(node[char], word[1:])\n\n    trie = {}\n    for word in words:\n        node = trie\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        if \"words\" not in node:\n            node[\"words\"] = []\n        node[\"words\"].append(word)\n\n    return search_trie(trie, prefix)\n\ndef g():\n    words = [\"apple\", \"banana\", \"cherry\", \"date\"]\n    prefix = \"b\"\n    return words, prefix\n\nassert f(*g()) == [\"banana\"]\n", "emb": null, "idx_generation": 498, "target_skills": [1, 1, 1, 1, 1, 0, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], prefix: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a prefix, find all words in the list that start with the given prefix.\n\n    Example:\n    words = [\"apple\", \"banana\", \"cherry\", \"date\"]\n    prefix = \"b\"\n\n    Output:\n    [\"banana\"]\n\n    Constraints:\n    - The words list will contain at least one word.\n    - The prefix will be a non-empty string.\n    \"\"\"\n\n    def search_trie(node: dict, word: str) -> List[str]:\n        if not word:\n            return node[\"words\"]\n\n        char = word[0]\n        if char not in node:\n            return []\n\n        return search_trie(node[char], word[1:])\n\n    trie = {}\n    for word in words:\n        node = trie\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        if \"words\" not in node:\n            node[\"words\"] = []\n        node[\"words\"].append(word)\n\n    return search_trie(trie, prefix)", "solution_func": "def g():\n    words = [\"apple\", \"banana\", \"cherry\", \"date\"]\n    prefix = \"b\"\n    return words, prefix", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, count the number of prime numbers less than or equal to n.\n\n    Args:\n    - n: An integer representing the upper limit.\n\n    Returns:\n    - The count of prime numbers less than or equal to n.\n    \"\"\"\n\n    def is_prime(num: int) -> bool:\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2, n + 1):\n        if is_prime(i):\n            count += 1\n    return count\n\ndef g(n = 20):\n    return n\n\nassert f(g()) == 8\n\n", "emb": [0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 498, "target_skills": [1, 0, 0, 0, 0, 1, 1, 0, 0, 0], "problem_func": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, count the number of prime numbers less than or equal to n.\n\n    Args:\n    - n: An integer representing the upper limit.\n\n    Returns:\n    - The count of prime numbers less than or equal to n.\n    \"\"\"\n\n    def is_prime(num: int) -> bool:\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2, n + 1):\n        if is_prime(i):\n            count += 1\n    return count", "solution_func": "def g(n = 20):\n    return n", "map_ix": [0, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of arithmetic subsequences in the list.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The number of arithmetic subsequences in the list.\n    \"\"\"\n\n    n = len(nums)\n    dp = [{} for _ in range(n)]\n    count = 0\n\n    for i in range(n):\n        for j in range(i):\n            diff = nums[i] - nums[j]\n            dp[i][diff] = dp[i].get(diff, 0) + dp[j].get(diff, 0) + 1\n            count += dp[j].get(diff, 0)\n\n    return count\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate the input for the function f.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 9\n\n", "emb": null, "idx_generation": 499, "target_skills": [0, 1, 0, 1, 0, 1, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of arithmetic subsequences in the list.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The number of arithmetic subsequences in the list.\n    \"\"\"\n\n    n = len(nums)\n    dp = [{} for _ in range(n)]\n    count = 0\n\n    for i in range(n):\n        for j in range(i):\n            diff = nums[i] - nums[j]\n            dp[i][diff] = dp[i].get(diff, 0) + dp[j].get(diff, 0) + 1\n            count += dp[j].get(diff, 0)\n\n    return count", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate the input for the function f.\n    \"\"\"\n    return [1, 2, 3, 4, 5]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of perfect squares in the list.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The number of perfect squares in the list.\n    \"\"\"\n\n    count = 0\n\n    for num in nums:\n        if is_perfect_square(num):\n            count += 1\n\n    return count\n\ndef is_perfect_square(num: int) -> bool:\n    root = int(num ** 0.5)\n    return root * root == num\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate the input for the function f.\n    \"\"\"\n    return [4, 8, 16, 25, 36]\n\nassert f(g()) == 3\n\n", "emb": null, "idx_generation": 499, "target_skills": [0, 0, 1, 0, 0, 1, 0, 0, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of perfect squares in the list.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The number of perfect squares in the list.\n    \"\"\"\n\n    count = 0\n\n    for num in nums:\n        if is_perfect_square(num):\n            count += 1\n\n    return count\n\ndef is_perfect_square(num: int) -> bool:\n    root = int(num ** 0.5)\n    return root * root == num", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate the input for the function f.\n    \"\"\"\n    return [4, 8, 16, 25, 36]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the number of distinct palindromic subsequences in the string.\n\n    Args:\n    - s: A string.\n\n    Returns:\n    - The number of distinct palindromic subsequences in the string.\n    \"\"\"\n\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        dp[i][i] = 1\n\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n\n            if s[i] == s[j]:\n                left = i + 1\n                right = j - 1\n\n                while left <= right and s[left] != s[i]:\n                    left += 1\n\n                while left <= right and s[right] != s[i]:\n                    right -= 1\n\n                if left > right:\n                    dp[i][j] = dp[i + 1][j - 1] * 2 + 2\n                elif left == right:\n                    dp[i][j] = dp[i + 1][j - 1] * 2 + 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1] * 2 - dp[left + 1][right - 1]\n\n            else:\n                dp[i][j] = dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1]\n\n    return dp[0][n - 1]\n\ndef g() -> str:\n    \"\"\"\n    Generate the input for the function f.\n    \"\"\"\n    return \"bccb\"\n\nassert f(g()) == 6\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 499, "target_skills": [1, 0, 0, 0, 0, 0, 0, 1, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the number of distinct palindromic subsequences in the string.\n\n    Args:\n    - s: A string.\n\n    Returns:\n    - The number of distinct palindromic subsequences in the string.\n    \"\"\"\n\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        dp[i][i] = 1\n\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n\n            if s[i] == s[j]:\n                left = i + 1\n                right = j - 1\n\n                while left <= right and s[left] != s[i]:\n                    left += 1\n\n                while left <= right and s[right] != s[i]:\n                    right -= 1\n\n                if left > right:\n                    dp[i][j] = dp[i + 1][j - 1] * 2 + 2\n                elif left == right:\n                    dp[i][j] = dp[i + 1][j - 1] * 2 + 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1] * 2 - dp[left + 1][right - 1]\n\n            else:\n                dp[i][j] = dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1]\n\n    return dp[0][n - 1]", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate the input for the function f.\n    \"\"\"\n    return \"bccb\"", "map_ix": [0, 1, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\nclass Node:\n    def __init__(self, val: int) -> None:\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef f(root: Node) -> List[int]:\n    \"\"\"\n    Given the root of a binary tree, return the inorder traversal of its nodes' values.\n\n    Args:\n    - root: The root node of the binary tree.\n\n    Returns:\n    - The inorder traversal of the binary tree as a list of integers.\n    \"\"\"\n    def inorder(node: Node, res: List[int]) -> None:\n        if node:\n            inorder(node.left, res)\n            res.append(node.val)\n            inorder(node.right, res)\n    \n    result = []\n    inorder(root, result)\n    return result\n\ndef g() -> Node:\n    root = Node(1)\n    root.right = Node(2)\n    root.right.left = Node(3)\n    return root\n\nassert f(g()) == [1, 3, 2]\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 499, "target_skills": [1, 0, 0, 1, 0, 1, 0, 0, 1, 1], "problem_func": "from typing import*\nfrom typing import List\n\nclass Node:\n    def __init__(self, val: int) -> None:\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef f(root: Node) -> List[int]:\n    \"\"\"\n    Given the root of a binary tree, return the inorder traversal of its nodes' values.\n\n    Args:\n    - root: The root node of the binary tree.\n\n    Returns:\n    - The inorder traversal of the binary tree as a list of integers.\n    \"\"\"\n    def inorder(node: Node, res: List[int]) -> None:\n        if node:\n            inorder(node.left, res)\n            res.append(node.val)\n            inorder(node.right, res)\n    \n    result = []\n    inorder(root, result)\n    return result", "solution_func": "def g() -> Node:\n    root = Node(1)\n    root.right = Node(2)\n    root.right.left = Node(3)\n    return root", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\nclass Graph:\n    def __init__(self, num_vertices: int) -> None:\n        self.num_vertices = num_vertices\n        self.adj_list = [[] for _ in range(num_vertices)]\n    \n    def add_edge(self, u: int, v: int) -> None:\n        self.adj_list[u].append(v)\n    \n    def f(self, start: int, end: int) -> List[List[int]]:\n        \"\"\"\n        Given a directed acyclic graph (DAG) and two vertices, start and end, find all paths from start to end.\n\n        Args:\n        - start: The starting vertex.\n        - end: The ending vertex.\n\n        Returns:\n        - A list of all paths from start to end.\n        \"\"\"\n        def dfs(curr: int, path: List[int], paths: List[List[int]]) -> None:\n            if curr == end:\n                paths.append(path)\n                return\n            \n            for next_vertex in self.adj_list[curr]:\n                dfs(next_vertex, path + [next_vertex], paths)\n        \n        paths = []\n        dfs(start, [start], paths)\n        return paths\n\ndef g() -> Graph:\n    graph = Graph(4)\n    graph.add_edge(0, 1)\n    graph.add_edge(0, 2)\n    graph.add_edge(1, 2)\n    graph.add_edge(1, 3)\n    graph.add_edge(2, 3)\n    return graph\n\nassert g().f(0, 3) == [[0, 1, 2, 3], [0, 2, 3]]\n\nassert f(g()) == True", "emb": null, "idx_generation": 499, "target_skills": [1, 1, 1, 1, 1, 1, 1, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\nclass Graph:\n    def __init__(self, num_vertices: int) -> None:\n        self.num_vertices = num_vertices\n        self.adj_list = [[] for _ in range(num_vertices)]\n    \n    def add_edge(self, u: int, v: int) -> None:\n        self.adj_list[u].append(v)\n    \n    def f(self, start: int, end: int) -> List[List[int]]:\n        \"\"\"\n        Given a directed acyclic graph (DAG) and two vertices, start and end, find all paths from start to end.\n\n        Args:\n        - start: The starting vertex.\n        - end: The ending vertex.\n\n        Returns:\n        - A list of all paths from start to end.\n        \"\"\"\n        def dfs(curr: int, path: List[int], paths: List[List[int]]) -> None:\n            if curr == end:\n                paths.append(path)\n                return\n            \n            for next_vertex in self.adj_list[curr]:\n                dfs(next_vertex, path + [next_vertex], paths)\n        \n        paths = []\n        dfs(start, [start], paths)\n        return paths", "solution_func": "def g() -> Graph:\n    graph = Graph(4)\n    graph.add_edge(0, 1)\n    graph.add_edge(0, 2)\n    graph.add_edge(1, 2)\n    graph.add_edge(1, 3)\n    graph.add_edge(2, 3)\n    return graph", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, return the longest common prefix among them.\n\n    Args:\n    - strings: A list of strings.\n\n    Returns:\n    - The longest common prefix among the strings.\n    \"\"\"\n    if not strings:\n        return \"\"\n    \n    prefix = strings[0]\n    for string in strings:\n        while not string.startswith(prefix):\n            prefix = prefix[:-1]\n            if not prefix:\n                return \"\"\n    \n    return prefix\n\ndef g() -> List[str]:\n    return [\"flower\", \"flow\", \"flight\"]\n\nassert f(g()) == \"fl\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 499, "target_skills": [0, 0, 1, 0, 1, 0, 0, 1, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, return the longest common prefix among them.\n\n    Args:\n    - strings: A list of strings.\n\n    Returns:\n    - The longest common prefix among the strings.\n    \"\"\"\n    if not strings:\n        return \"\"\n    \n    prefix = strings[0]\n    for string in strings:\n        while not string.startswith(prefix):\n            prefix = prefix[:-1]\n            if not prefix:\n                return \"\"\n    \n    return prefix", "solution_func": "def g() -> List[str]:\n    return [\"flower\", \"flow\", \"flight\"]", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the number of unique combinations that add up to the target sum.\n\n    Return the number of unique combinations.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 6\n\n    Output:\n    4\n\n    Explanation:\n    The unique combinations that sum up to 6 are [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 2], [1, 1, 2, 2], and [2, 2, 2].\n    \"\"\"\n    def backtrack(arr, target, start, path, result):\n        if target == 0:\n            result.append(path)\n            return\n        if target < 0:\n            return\n        \n        for i in range(start, len(arr)):\n            if i > start and arr[i] == arr[i-1]:\n                continue\n            backtrack(arr, target - arr[i], i, path + [arr[i]], result)\n    \n    result = []\n    backtrack(arr, target, 0, [], result)\n    return len(result)\n\ndef g(arr=[1, 2, 3, 4, 5], target=6):\n    return arr, target\n\nassert f(*g()) == 4\n", "emb": null, "idx_generation": 499, "target_skills": [0, 1, 0, 1, 0, 0, 0, 0, 1, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the number of unique combinations that add up to the target sum.\n\n    Return the number of unique combinations.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 6\n\n    Output:\n    4\n\n    Explanation:\n    The unique combinations that sum up to 6 are [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 2], [1, 1, 2, 2], and [2, 2, 2].\n    \"\"\"\n    def backtrack(arr, target, start, path, result):\n        if target == 0:\n            result.append(path)\n            return\n        if target < 0:\n            return\n        \n        for i in range(start, len(arr)):\n            if i > start and arr[i] == arr[i-1]:\n                continue\n            backtrack(arr, target - arr[i], i, path + [arr[i]], result)\n    \n    result = []\n    backtrack(arr, target, 0, [], result)\n    return len(result)", "solution_func": "def g(arr=[1, 2, 3, 4, 5], target=6):\n    return arr, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray with the constraint that no two numbers in the subarray are adjacent.\n    \n    Return the maximum sum.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n\n    Output:\n    9\n\n    Explanation:\n    The maximum sum of a subarray with the constraint is achieved by selecting [1, 3, 5] or [2, 4].\n    \"\"\"\n    if len(arr) == 0:\n        return 0\n    \n    if len(arr) == 1:\n        return arr[0]\n    \n    dp = [0] * len(arr)\n    dp[0] = arr[0]\n    dp[1] = max(arr[0], arr[1])\n\n    for i in range(2, len(arr)):\n        dp[i] = max(dp[i-1], dp[i-2] + arr[i])\n    \n    return dp[-1]\n\ndef g(arr=[1, 2, 3, 4, 5]):\n    return arr\n\nassert f(g()) == 9\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 499, "target_skills": [0, 1, 1, 1, 1, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray with the constraint that no two numbers in the subarray are adjacent.\n    \n    Return the maximum sum.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n\n    Output:\n    9\n\n    Explanation:\n    The maximum sum of a subarray with the constraint is achieved by selecting [1, 3, 5] or [2, 4].\n    \"\"\"\n    if len(arr) == 0:\n        return 0\n    \n    if len(arr) == 1:\n        return arr[0]\n    \n    dp = [0] * len(arr)\n    dp[0] = arr[0]\n    dp[1] = max(arr[0], arr[1])\n\n    for i in range(2, len(arr)):\n        dp[i] = max(dp[i-1], dp[i-2] + arr[i])\n    \n    return dp[-1]", "solution_func": "def g(arr=[1, 2, 3, 4, 5]):\n    return arr", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the minimum sum path from the top-left corner to the bottom-right corner.\n    Only down and right movements are allowed.\n\n    Return the minimum sum.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum sum path is 1 -> 3 -> 1 -> 1 -> 1.\n    \"\"\"\n    if not grid:\n        return 0\n\n    rows, cols = len(grid), len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    \n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[-1][-1]\n\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(g()) == 7\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 499, "target_skills": [1, 0, 0, 1, 0, 1, 1, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the minimum sum path from the top-left corner to the bottom-right corner.\n    Only down and right movements are allowed.\n\n    Return the minimum sum.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum sum path is 1 -> 3 -> 1 -> 1 -> 1.\n    \"\"\"\n    if not grid:\n        return 0\n\n    rows, cols = len(grid), len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    \n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[-1][-1]", "solution_func": "def g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid", "map_ix": [0, 0, 0, 1, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\n\n    Example:\n    Input: arr = [2, 4, 7, 11, 15], target = 9\n    Output: True\n\n    Explanation: The sum of 2 and 7 is equal to the target value 9.\n\n    Hint: Use a two-pointer approach to search for the pair of numbers.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    return ([2, 4, 7, 11, 15], 9)\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 499, "target_skills": [0, 1, 1, 0, 1, 0, 0, 1, 0, 1], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\n\n    Example:\n    Input: arr = [2, 4, 7, 11, 15], target = 9\n    Output: True\n\n    Explanation: The sum of 2 and 7 is equal to the target value 9.\n\n    Hint: Use a two-pointer approach to search for the pair of numbers.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g():\n    return ([2, 4, 7, 11, 15], 9)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}]